use strict;
use warnings;
no warnings qw(uninitialized redefine);

use FindBin qw($Bin);
use lib "$Bin/othlia";
use Down::GBabz;
use Down::Goodat;
use Down::Tides;
use G;
use Ise::KnowTime;
use Ise::Rob;
use Ise::Shelf;
use Ngwe;
our $A = {};
$A->{I} = {};
$A->{AAAA} = [
$Down::GBabz::A,$Down::Goodat::A,$Down::Tides::A,$G::A,$Ise::KnowTime::A,$Ise::Rob::A,$Ise::Shelf::A,$Ngwe::A];
for my $AA (@{$A->{AAAA}}) {
    my @D = map{values%$_} map{values%$_} values %{$AA->{II}};
    my $ne = {map{$_=>1}keys%{$AA->{I}}};
    for my $D (@D) {
        unless ($ne->{$D->{t}}) {
            $D->{sc}->{eg} || die "notI sub not .eg".ki$D;
            $AA->{symb} ||= eval'\%'.$D->{sc}->{eg}.'::';
            $AA->{I}->{$D->{t}} = $ne->{$D->{t}} = $AA->{symb}->{$D->{t}};
        }
        delete $ne->{$D->{t}} || sayre("II index for not in I: ".ki$D) && next;
        $A->{I}->{$D->{t}.'_dige'} = $D->{sc}->{dige};
        $A->{I}->{$D->{t}} = $AA->{I}->{$D->{t}};
        $A->{tople}->{$D->{t}} = 1;
    }
}
sayyl "Have : ".join' ', sort keys %{$A->{tople}};
my $G;
$G->{up} = hitime();
$G->{id} = mkuid();
$G->{I} = $A->{I};
$G->{A} = $A;
my $C = {};
my $T = {};
for my $sn (qw'pwin tie h w airlock') {
    $G->{$sn} = $G->{I}->{$sn} || die "No $sn from G I";
}
$SIG{__DIE__} = $G->{I}->{sigstackend} || die "NO sigstackend";

$G->{h}->($A,$C,$G,$T,"init");

$G->{w}->($A,$C,$G,$T,"Rune",A=>$A,C=>$C,G=>$G,T=>$T,m=>["i"]);

Mojo::IOLoop->start unless Mojo::IOLoop->is_running;