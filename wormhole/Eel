--- 
I: 
  "0.1": 
    mkD: 
      c: 
        el: 1
        s: "A.I.mkD = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($pin,$ar,@Me) = @M;\n    my $I = A.I;\n    my $D;\n    D.point = $pin;\n    if (my $C = ar.__D) {\n        delete ar.__D;\n        D.bab = C.c.s || die \"N s\".ki $C;\n        D.noise .= C.sc.dige if C.sc.dige;\n        D.babnon = 1 if C.sc.bab eq 'non';\n        D.Verb = 1;\n    }\n    D.ar = $ar;\n    D.name = join ' ', D.point, sort keys %{D.ar};\n    D.sign = \"Z\";\n    D.talk = join' ',grep{defined}map{$D->{$_}}qw'sign name noise';\n    $D;\n};\n"
      sc: 
        acgt: pin,ar
        args: A,C,G,T,pin,ar
        code: I 1
        dige: 974b297c1911
        gro: Goodat
      t: mkD
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Goodat/Goodat
    pin: 
      c: 
        el: 1
        s: "A.I.pin = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($pin,$way,@Me) = @M;\n    my $I = A.I;\n    I.pwin || die \"nopwin from pin\";\n    I.pwin->($pin,$way);\n};\n"
      sc: 
        acgt: pin,way
        args: A,C,G,T,pin,way
        code: I 1
        dige: 82803a8c20f2
        gro: Goodat
      t: pin
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Goodat/Goodat
    pon: 
      c: 
        el: 1
        s: "A.I.pon = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($pin,$way,$s,@Me) = @M;\n    my $I = A.I;\n    I.pwin || die \"nopwin from pin\";\n    I.pwin->($pin,$way,{et=>$s});\n};\n"
      sc: 
        acgt: pin,way,s
        args: A,C,G,T,pin,way,s
        code: I 1
        dige: e37d81abf9f1
        gro: Goodat
      t: pon
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Goodat/Goodat
    pwin: 
      c: 
        el: 1
        s: "A.I.pwin = sub {\n    my ($pin,$way,$set,@Me) = @_;\n    my $I = A.I;\n    if (exists $way->{$pin}) {\n          my $o = $way->{$pin};\n        $way->{$pin} = set.et if exists set.et;\n        delete $way->{$pin} if set.de;\n        return $o;\n    }\n    my @path = split /\\/|\\./, $pin;\n    my $h = $way;\n    my $last;\n    for my $p (@path) {\n        if (ref $h ne 'HASH' && ref $h ne 'G') {\n            undef $last;\n            undef $h;\n            last;\n        }\n        $last = [$h,$p];\n        $h = $h->{$p};\n        # ref = T makes it look for jointed rest of path in tiedinto {}\n        # then T collapses the feely data mesh\n    }\n    if ($last) {\n        my ($he,$pi) = @$last;\n        $he->{$pi} = set.et if exists set.et;\n        delete $he->{$pi} if set.de;\n    }\n    return $h if defined $h;\n    \n    return undef unless $pin =~ /\\*/;\n    die \"sat rs findy $pin\";\n};\n"
      sc: 
        acgt: s
        args: pin,way,set
        code: I 1
        dige: 41ad5cef7aed
        gro: Goodat
      t: pwin
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Goodat/Goodat
J: 
  "0.622211": 
    J_622211: 
      c: 
        el: 1
        s: "A.I.J_622211 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    my $x = A.J.pix || J.mo.J.pix || return;\n    my @m = ref $x eq 'ARRAY' ? @$x : $x;\n    for my $x (@m) {\n        if (x.pi ? C.c.pi eq x.pi : \n            x.any ? 1 :\n            0) {\n            saybl \"matched: J.name ::: \".ki $x;\n            x.u &&\n            u x.u\n        }\n        # up!\n    }\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: J 622211
        dige: 030f397c269c
        gk: J
        gro: Foli
        nk: c
        v: cJ
      t: J_622211
      "y": 
        cv: '0.622211'
        cvt: 0.622211	C.t
        p: qq/Foli/Foli
Mo: 
  "0.221": 
    yall_: 
      c: 
        el: 1
        s: "A.I.yall_ = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $y = C.y;\n    C.y = {thi => C.y} if !ref C.y;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo 221
        dige: 1dc839684266
        gro: Spaci
        its: 1
        nk: 'y'
        v: 'y'
      t: yall_
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Spaci/Spaci
  "0.223": 
    bal_: 
      c: 
        el: 1
        s: "A.I.bal_ = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $y = C.y;\n    my $bal = C.y.bal;\n    y.thi = @$bal;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo 223
        dige: d6a901a533ea
        gk: bal
        gro: bal
        nk: 'y'
        v: ybal
      t: bal_
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/bal/bal
  "0.23": 
    yin_: 
      c: 
        el: 1
        s: "A.I.yin_ = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $y = C.y;\n    # build wave plot manifold\n    # solar systems\n    y.cv ||= 0.3 if !defined y.cv && !defined y.in;\n    y.in = y.cv if defined y.cv;\n    y.in ||= 0.1;\n    y.out = y.in + y.space if defined y.space;\n    y.out ||= 0.9; # up to, then low things big\n    y.thi ||= 1;\n    if (my $mk = y.ert) {\n        $mk += y.ert while y.thi > $mk;\n        y.thi = $mk;\n    }\n    y.space = y.out - y.in;\n    y.space *= -1 unless y.space > 0;\n    y.aspace = y.space / y.thi;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo 23
        dige: b8b2317909f4
        gro: Spaci
        its: 1
        nk: 'y'
        v: 'y'
      t: yin_
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Spaci/Spaci
  "0.241": 
    muav_: 
      c: 
        el: 1
        s: "A.I.muav_ = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $y = C.y;\n    my $bal = C.y.bal;\n    my $total = sum(map { y.thy||1 } @$bal) || 1;\n    my $over = @$bal || 1;\n    y.u.muav = $over / $total;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo 241
        dige: a65c817c1fac
        gk: bal
        gro: bal
        nk: 'y'
        v: ybal
      t: muav_
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/bal/bal
  "0.26": 
    yarN_: 
      c: 
        el: 1
        s: "A.I.yarN_ = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $y = C.y;\n    # twist, lay into segment\n    ref $y eq 'HASH' || die \"Notash: \".wdump 2, $C;\n    !defined y.u || ref y.u eq 'HASH' || die \"Nou : y.u \".wdump 2, $y;\n    y.u.v = defined y.cv ? y.cv\n        : defined y.in ? y.in\n        : die \"no yiny\".ki$y;\n    y.thi || die \"Whythi\".ki$C;\n    die \":idify\" if $y ne C.y;\n    # y.u. shares av, y. separates\n    # difference pours out of y.bal via y.i in 32\n    my @lot = map {\n        my $C = eval { I.d&xot,{},$C };\n        C.y.i = $_-1;\n        $@ && die \"Tpp \".wdump 2, $C;\n        $C\n    } 1..y.thi;\n    if (@lot > 1) {\n        push @{A.mo.re->{0.29}||=[]}, map{[undef,$_]}@lot;\n        T.not = 1;\n    }\n    else {\n        my ($CC) = @lot;\n        ref $CC eq 'HASH' || die \"not one? $CC\";\n        %$C = %$CC;\n    }\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo 26
        dige: 8b60c744edc4
        gro: Spaci
        its: 1
        nk: 'y'
        v: 'y'
      t: yarN_
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Spaci/Spaci
  "0.3": 
    yinvout_: 
      c: 
        el: 1
        s: "A.I.yinvout_ = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $y = C.y;\n    y.mu = 1;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo 3
        dige: ea75f29040cf
        gro: Spaci
        its: 1
        nk: 'y'
        v: 'y'
      t: yinvout_
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Spaci/Spaci
  "0.301": 
    balin_: 
      c: 
        el: 1
        s: "A.I.balin_ = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $y = C.y;\n    my $bal = C.y.bal;\n    my $CC = $bal->[y.i];\n    if (ref $CC ne 'HASH') {\n        sayre \"Not ref: $CC A.J.name  C.t bal y.i :\";\n        return T.not = 1;\n    }\n    $CC ||= {};\n    I.d&xot,$C,$CC;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo 301
        dige: 8b609488ea6d
        gk: bal
        gro: bal
        nk: 'y'
        v: ybal
      t: balin_
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/bal/bal
  "0.337": 
    balou_: 
      c: 
        el: 1
        s: "A.I.balou_ = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $y = C.y;\n    my $bal = C.y.bal;\n    y.mu = y.thy if exists y.thy;\n    y.mu = y.mu * y.u.muav if y.u.muav;\n    #\n    say \"A.J.C.t  /  T.t ist y.mu  among y.u.muav\"\n        if A.J.V && y.u.muav != 1;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo 337
        dige: 4ade4215e92e
        gk: bal
        gro: bal
        nk: 'y'
        v: ybal
      t: balou_
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/bal/bal
  "0.34": 
    black_: 
      c: 
        el: 1
        s: "A.I.black_ = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $y = C.y;\n    my $was = y.u.v;\n    defined $was || die\"noAv\".ki$C;\n    # in:\n    y.cv = 0+sprintf '%.6f', y.u.v unless y.cvil && defined y.cv;\n    y.pcv = 0+sprintf '%.6f', y.i / C.y.thi;\n    # over:\n    my $in = y.aspace * y.mu;\n    y.u.v += $in;\n    # out: \n    y.ov = sprintf '%.6f', y.u.v;\n    y.spc = y.ov - y.cv;\n    #\n    sayyl \"Bend: C.t   $was += $in       y.aspace * y.mu       muav:y.u.muav\"\n        if A.J.V && y.u.muav && y.u.muav != 1;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo 34
        dige: 0f5f111f2197
        gro: Spaci
        its: 1
        nk: 'y'
        v: 'y'
      t: black_
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Spaci/Spaci
  "0.37": 
    ent_: 
      c: 
        el: 1
        s: "A.I.ent_ = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $y = C.y;\n    $y->{$_} = 0+sprintf('%.6f',$y->{$_}) for qw'cv ov aspace spc';\n    C.sc.yspc = y.spc if C.sc.nspc;\n    C.sc.ml = (C.y.over * 40).\"%\" if y.over;\n    if (!y.bal && y.aspace == 0.6 && y.in == 0.3) {\n        #saygr \"tidying the y of A.J.name C.t: $y \".ki $y;\n        #delete $y->{$_} for qw'aspace i in mu out ov pcv space spc thi u';\n        # unless any y.o, spacestuff around it\n    }\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo 37
        dige: 9aa3d27345c8
        gro: Spaci
        its: 1
        nk: 'y'
        v: 'y'
      t: ent_
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Spaci/Spaci
  "0.77": 
    pin_: 
      c: 
        el: 1
        s: "A.I.pin_ = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $y = C.y;\n    return if delete T.oke;\n    my $oJ = A.J;\n    my $J = C.y.o && C.y.o.J || $oJ;\n    my $ar = {};\n    ar.s = C.c.s if exists C.c.s;\n    \n    Rw jamsc + $J $oJ $C $sc:C.sc;\n    \n    # man is an insect is a flame\n    \n    sayyl \"Hamsc! A.talk: C.t C.y.cv     \".ki(1,{c=>C.c,sc=>C.sc})\n        if A.J.V;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo 77
        dige: 30369ff61d2a
        gro: Spaci
        its: 1
        nk: 'y'
        v: 'y'
      t: pin_
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Spaci/Spaci
em: 
  "0.21": 
    em_21: 
      c: 
        el: 1
        s: "A.I.em_21 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $em = C.c.em;\n    em.lines || die \"Not lines\";\n    em.hitime = hitime();\n    em.is.W = C.sc.Wid || A.J.id;\n    em.is.M = C.sc.Mid || A.J.name;\n    em.id = em.is.W.'.'.(0+em.i);\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: em 21
        dige: c304cc4fd1ff
        gk: em
        gro: Meta
        nk: c
        v: cem
      t: em_21
      "y": 
        cv: '0.21'
        cvt: 0.21	C.t
        p: qq/Meta/Meta
  "0.3": 
    jslines_3: 
      c: 
        el: 1
        s: "A.I.jslines_3 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $sc = C.sc;\n    my $jslines = C.sc.jslines;\n    my $J = C.c.J;\n    my $em = C.c.em;\n    Rw EmJSlines $A $J $em $C $T;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        cg: J,em
        code: em 3
        dige: 41cef4532459
        gk: jslines
        gkiss: s
        gro: Meta
        nk: sc
        nov: 1
        nv: scjslines
        rg: J,em
        v: scjslines
      t: jslines_3
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Meta/Meta
    ressur_3: 
      c: 
        el: 1
        s: "A.I.ressur_3 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $sc = C.sc;\n    my $ressur = C.sc.ressur;\n    my $J = C.c.J;\n    my $em = C.c.em;\n    saybl \"Ressurrecting $ressur ...\";\n    die \"zomp $ressur\" if $ressur =~ /\\W/;\n    die \"bno JSlines\" unless -e \"life/W/$ressur\";\n    `cd life; ln -s ../W/$ressur J/em.id\\.c`;\n    my $catch = sjson {y=>J=>id=>em.id};\n    I.d&writef,\"life/J\\.s\",$catch,1;\n    T.whack = 1; # out of em\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        cg: J,em
        code: em 3
        dige: bc77ff177d9a
        gk: ressur
        gkiss: s
        gro: Meta
        nk: sc
        nov: 1
        nv: scressur
        rg: J,em
        v: scressur
      t: ressur_3
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Meta/Meta
    ux_3: 
      c: 
        el: 1
        s: "A.I.ux_3 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $sc = C.sc;\n    my $ux = C.sc.ux;\n    my $em = C.c.em;\n    my $J = G.oin;\n    my $M = ['','',{W=>J.id},{z=>em.lines}];\n    em.lines = [sjson($M)];\n    C.sc.Wc = 1;\n    n GW\n    # ^ router, W with an .e v\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        cg: em
        code: em 3
        dige: ff8f2dae6153
        gk: ux
        gkiss: s
        gro: Meta
        nk: sc
        nov: 1
        nv: scux
        rg: em
        v: scux
      t: ux_3
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Meta/Meta
