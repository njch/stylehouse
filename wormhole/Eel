--- 
I: 
  "0.1": 
    Cngk: 
      c: 
        el: 1
        s: "A.I.Cngk = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($s,$D,@Me) = @M;\n    my $I = A.I;\n    ref $A || die \"nmonref A!\";\n    aft { $@ .= \"\\nLookat: \".ki($s).\"\\nWith: \".ki($D) if $@ };\n    return 1 if D.c.any;\n    die \"nonNKnk\".ki$D if !D.c.nk;\n    return 0 if !exists $s->{D.c.nk};\n    return [$s->{D.c.nk}] if !exists D.c.gk;\n    return 0 if !exists $s->{D.c.nk}->{D.c.gk};\n    return [$s->{D.c.nk}->{D.c.gk}];\n};\n"
      sc: 
        acgt: s,D
        args: A,C,G,T,s,D
        code: I 1
        dige: 1ce95658c144
        gro: C
      t: Cngk
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    atom: 
      c: 
        el: 1
        s: "A.I.atom = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($last,$here,@Me) = @M;\n    my $I = A.I;\n    # spacin\n    here.dist = here.cv - last.cv;\n    # twistin spin inherit\n    here.spin += last.spin;\n    # scale local-local change\n    here.rad += here.spin * here.dist * 10;\n    # builds rad on rad\n    here.rad += last.rad;\n    # distort space + more ways, orbital\n    # chuck skeletons for mods\n    # adapt M meta for what kinda places things want\n    # into constellations of high level things\n    # atomised hairs\n    here.zoom ||= last.zoom;\n    here.dist *= here.zoom if here.zoom;\n    # and move\n    here.x = last.x + (here.rad ? cos(here.rad) : 0) * here.dist;\n    here.y = last.y + (here.rad ? sin(here.rad) : 1) * here.dist;\n};\n"
      sc: 
        acgt: last,here
        args: A,C,G,T,last,here
        code: I 1
        dige: a2b2426c55db
        gro: GeoSo
      t: atom
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/GeoSo/GeoSo
    c: 
      c: 
        el: 1
        s: "A.I.c = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($D,@Me) = @M;\n    my $I = A.I;\n    I.d&inDin,$C,@M;\n};\n"
      sc: 
        acgt: D
        args: A,C,G,T,D
        code: I 1
        dige: a931936381c2
        gro: C
      t: c
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    e: 
      c: 
        el: 1
        s: "A.I.e = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($D,@Me) = @M;\n    my $I = A.I;\n    I.d&inDin,C.c.e,@M;\n};\n"
      sc: 
        acgt: D
        args: A,C,G,T,D
        code: I 1
        dige: 06747ef15695
        gro: C
      t: e
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    fourreal: 
      c: 
        el: 1
        s: "A.I.fourreal = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    (C.t, C.y) = @$s;\n    C.c  = $s->[2] if exists $s->[2];\n    C.sc = $s->[3] if exists $s->[3];\n    die'@>4'.wdump $s if @$s > 4;\n    die\"C.t from \".wdump $s if ref C.t; # dives\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 87baea0c56c8
        gro: C
      t: fourreal
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    fourstring: 
      c: 
        el: 1
        s: "A.I.fourstring = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    I.d&MZu,$1 if $s =~ /^\\s*#?\\s*MZ (.+)$/;\n    if ($s =~ /^\\s*(#.*)$/) {\n       T.not = 1;\n       T.com = $1;\n    }\n    elsif ($s eq '') {\n       T.not = T.space = 1;\n    }\n    else {\n       my $ci = $s;\n       for my $nk (qw't y c sc') {\n           if ($ci =~ s/^(\\S+) *//) { # some t are types of space\n               my $v = $1;\n               $v = I.d&peel,$v if $nk ne 't' && $v =~ I.peels;\n               # << consumes more lines into $nk, then ...\n               $v = '' if $v =~ /^(''|\"\")$/;\n               $C->{$nk} = $v;\n           }\n       }\n    }\n    saybl \"4string: $s            \".ki $C if A.V&C;\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 94abbc0a2dcf
        gro: C
      t: fourstring
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    geo2lin: 
      c: 
        el: 1
        s: "A.I.geo2lin = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($geo,@Me) = @M;\n    my $I = A.I;\n    # shove com toeget\n    # OR SOMETHING\n    # loses its compressibility as csz\n    my @am = qw'a? ab  x x  y y  r radial  s scale';\n    my @l;\n    while (@am) {\n        my $k = shift @am;\n        my $v = shift @am;\n        my $sens = $k =~ s/\\?$//;\n        push @l, ($sens && $k).$geo->{$v} if exists $geo->{$v};\n    }\n    my $l = join ' ', @l;\n    $l\n};\n"
      sc: 
        acgt: geo
        args: A,C,G,T,geo
        code: I 1
        dige: 755b1ccec764
        gro: GeoSo
      t: geo2lin
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/GeoSo/GeoSo
    here2geo: 
      c: 
        el: 1
        s: "A.I.here2geo = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($here,@Me) = @M;\n    my $I = A.I;\n    my $geo = {};\n    geo.rad = here.rad;\n    # unwind (into...)\n    my $o = $RADIAN*4;\n    my $swish = $o;\n    $swish *= -1 if geo.rad < 0;\n    my $i = 0;\n    geo.rad -= $swish until\n        do {$i++>5&&die\"$i muchwind\".ki$here;0}\n        ||\n        $o*-1 < geo.rad && geo.rad < $o*4;\n    # pan to hemisphere...\n    # from O- is it in the left hemisphere etc\n    my $rad = geo.rad;\n    my $radleg = -$RADIAN;\n    $radleg *= -1 unless $rad < -$RADIAN && $rad > $RADIAN;\n    $rad -= $radleg;\n    geo.radial = I.d&ron,$rad;\n    geo.x = here.x;\n    geo.y = here.y;\n    geo.ab = '100' if 1; # w=h=100,ab=1\n    # transform about\n    geo.tro = '0 0.5'; # midleft\n    geo.tro = '0 0' if 0; # topleft\n    #\n    my $fo = sub { (shift() * 100).'%' };\n    geo.tro = join' ',map{$fo->($_)}split' ',geo.tro;\n    \n    I.d&geo2lin,$geo;\n};\n"
      sc: 
        acgt: here
        args: A,C,G,T,here
        code: I 1
        dige: e81d82f252c3
        gro: GeoSo
      t: here2geo
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/GeoSo/GeoSo
    hup: 
      c: 
        el: 1
        s: "A.I.hup = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $CC = {%$s};\n    $CC->{$_} = {%{$CC->{$_}}} for grep {ref $CC->{$_} eq 'HASH'} keys %$CC;\n    $CC;\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 2bc362811316
        gro: C
      t: hup
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    inDin: 
      c: 
        el: 1
        s: "A.I.inDin = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($s,$D,@Me) = @M;\n    my $I = A.I;\n    die'nofA' if !I.nF.A;\n    #\n    return () unless defined $s;\n    return $s if $D eq 'C';\n    #\n    shift @M; # s\n    $D = I.d&interpD,@M if !ref $D;\n    #\n    my $v = I.d&Cngk,$s,$D;\n    #\n    return () unless $v;\n    # blankgk\n    A.note->{D.c.nk}->{D.c.gk} = $v if A.note;\n    #\n    die 'mulitAn' if @$v > 1;\n    if (D.c.as eq 'list') {\n        ref $v eq 'ARRAY' || die 'Cngk not array';\n        return @$v;\n    }\n    return 1;\n};\n"
      sc: 
        acgt: s,D
        args: A,C,G,T,s,D
        code: I 1
        dige: bc7f2cfdcb5f
        gro: C
      t: inDin
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    interpD: 
      c: 
        el: 1
        s: "A.I.interpD = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($nk,$gk,@Me) = @M;\n    my $I = A.I;\n    my $defnk = 'c';\n    return $nk if ref $nk;\n    my $D = {};\n    D.c.as = 'list' if 1 || $nk =~ s/^_//;\n    while ($gk =~ s/^%(.+?):(.+?)(?=%|$)//g) {\n        D.c->{$1} = $2;\n        pop @M if @M == 2;\n    }\n    if (@M == 1 && $nk eq 't') {\n        D.c.nk = $nk;\n    }\n    elsif (@M == 1) { # or from t,,,\n        D.c.nk ||= $defnk;\n        D.c.gk ||= $nk;\n    }\n    elsif (@M == 2) {\n        D.c.nk = $nk;\n        D.c.gk = $gk;\n    }\n    delete D.c.gk if D.c.gk eq 'NOGK';\n    $D\n};\n"
      sc: 
        acgt: nk,gk
        args: A,C,G,T,nk,gk
        code: I 1
        dige: 688db989ec06
        gro: C
      t: interpD
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    last2here: 
      c: 
        el: 1
        s: "A.I.last2here = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($last,$r,$here,@Me) = @M;\n    my $I = A.I;\n    here.x  = last.x = r.x if exists r.x;\n    here.y = last.y = r.y if exists r.y;\n    here.rad = 4*$RADIAN * r.spun if exists r.spun;\n    here.zoom = r.zoom if defined r.zoom;\n    \n    I.d&atom,$last,$here;\n    \n    here.spin = r.curve if exists r.curve; # on the level\n    #\n    here.x = I.d&ron,here.x;\n    here.y = I.d&ron,here.y;\n    here.rad = I.d&ron,here.rad;\n};\n"
      sc: 
        acgt: last,r,here
        args: A,C,G,T,last,r,here
        code: I 1
        dige: 338d0c840521
        gro: GeoSo
      t: last2here
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/GeoSo/GeoSo
    mkD: 
      c: 
        el: 1
        s: "A.I.mkD = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($pin,$ar,@Me) = @M;\n    my $I = A.I;\n    my $D;\n    D.point = $pin;\n    if (my $C = ar.__D) {\n        delete ar.__D;\n        D.bab = C.c.s || die \"N s\".ki $C;\n        D.noise .= C.sc.dige if C.sc.dige;\n        D.babnon = 1 if C.sc.bab eq 'non';\n        D.Verb = 1;\n    }\n    D.ar = $ar;\n    D.name = join ' ', D.point, sort keys %{D.ar};\n    D.sign = \"Z\";\n    D.talk = join' ',grep{defined}map{$D->{$_}}qw'sign name noise';\n    $D;\n};\n"
      sc: 
        acgt: pin,ar
        args: A,C,G,T,pin,ar
        code: I 1
        dige: 974b297c1911
        gro: Goodat
      t: mkD
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Goodat/Goodat
    peel: 
      c: 
        el: 1
        s: "A.I.peel = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    $s =~ s/^%// || \n        $s =~ s/^{// && $s =~ s/}$//\n        || die \"unpealable $s\";\n    my $c;\n    for (split ',', $s) {\n        my ($k, $v) = split ':', $_, 2;\n        $v = 1 if !defined $v;\n        $c->{$k} = $v;\n    }\n    $c||{}\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 86d02e052c88
        gro: C
      t: peel
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    peels: 
      c: 
        el: 1
        s: "A.I.peels = (sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    qr/^[\\{\\%]/;\n})->($A,$C,$G,$T);\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 2cef197e1b39
        gro: C
        subpeel: 1
      t: peels
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    pin: 
      c: 
        el: 1
        s: "A.I.pin = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($pin,$way,@Me) = @M;\n    my $I = A.I;\n    I.pwin || die \"nopwin from pin\";\n    I.pwin->($pin,$way);\n};\n"
      sc: 
        acgt: pin,way
        args: A,C,G,T,pin,way
        code: I 1
        dige: 82803a8c20f2
        gro: Goodat
      t: pin
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Goodat/Goodat
    pwin: 
      c: 
        el: 1
        s: "A.I.pwin = sub {\n    my ($pin,$way,@Me) = @_;\n    my $I = A.I;\n    return $way->{$pin} if exists $way->{$pin};\n    my @path = split /\\/|\\./, $pin;\n    my $h = $way;\n    for my $p (@path) {\n        $h = $h->{$p};\n        unless ($h) {\n            undef $h;\n            last;\n        }\n    }\n    return $h if defined $h;\n    \n    return undef unless $pin =~ /\\*/;\n    die \"sat rs findy $pin\";\n};\n"
      sc: 
        acgt: s
        args: pin,way
        code: I 1
        dige: cc43f0214875
        gro: Goodat
      t: pwin
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Goodat/Goodat
    ron: 
      c: 
        el: 1
        s: "A.I.ron = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    0.0001 * int(10000*$s)\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 45a95b7f03ae
        gro: GeoSo
      t: ron
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/GeoSo/GeoSo
    us: 
      c: 
        el: 1
        s: "A.I.us = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($D,@Me) = @M;\n    my $I = A.I;\n    my $E = C.c.e || return ();\n    push @M, 'NOGK' if @M == 1;\n    I.d&inDin,E.c.us,@M;\n};\n"
      sc: 
        acgt: D
        args: A,C,G,T,D
        code: I 1
        dige: 0cdebb6cbbf0
        gro: C
      t: us
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    xot: 
      c: 
        el: 1
        s: "A.I.xot = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($s,$c,@Me) = @M;\n    my $I = A.I;\n    while (my($k,$v) = each %$c) {\n        $s->{$k} = ref $v ? {%{$s->{$k}||{}}, %$v} : $v;\n    }\n    $s\n};\n"
      sc: 
        acgt: s,c
        args: A,C,G,T,s,c
        code: I 1
        dige: f8940275bf17
        gro: C
      t: xot
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
oJ: 
  "0.344": 
    J_344: 
      c: 
        el: 1
        s: "A.I.J_344 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    # here before we could be interrupting\n    my $isJ = sub { my $J = shift; ref $J eq 'HASH' && J.bb };\n    if (A.J ne $J) {\n        # what we are holding out as .e and .s helps it leave\n        A.ztime = 6 if exists C.c.e;\n        sayre \"THosught of A.J.name  holds  J.name  \".ki C.c if A.V&V;\n        return;\n    }\n    unless (exists C.c.e || $isJ->(C.c.s)) { # subscribe maintain there\n        say \"threesorbtion: A.J.name to J.name\"\n            .\" is not holding e or sJ\" if A.V&V;\n        # absorb self Cing\n        T.not = 1;\n        return;\n    }\n    my $S = C.c.s;\n    $S = {name=>\"An: C.c.s\"} if !ref $S;\n    saybl \"In s A.J.name: J.name   \".ki(C.c.e)\n        .\"\\n   unto  S.name     \".ki $C if 1 || A.V&V;\n    die \" unable to count self ?\" if C.c.s eq $J;\n    die \"thoughts of a thous\" if A.J ne $J;\n    if (!exists C.c.e) {\n        # be thing=>W=>other, later\n        C.c.IsOn || return do {\n            say \"Comebacking J.name with C.t...\" if A.V&V;\n            Rw wayt $J $C $d=0.01 $p=jive;\n            T.not = 1;\n        }\n    }\n    # no J being tricks for handulation, event energy\n    A.Iso.th = 1;\n    delete A.Iso.oJ;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: oJ 344
        dige: 7aa7127c8a99
        gk: J
        gro: threes
        nk: c
        v: cJ
      t: J_344
      "y": 
        cv: '0.344'
        cvt: 0.344	C.t
        p: qq/threes/threes
th: 
  "0.4": 
    J_4: 
      c: 
        el: 1
        s: "A.I.J_4 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    my $ar;\n    ar.A=$A;ar.G=$G;ar.C=$C;ar.T=$T;ar.J=$J;\n    C.c.e ?\n        Rw threve\n    :\n        Rw thank;\n    if (T.oke) {\n        delete A.Iso.th;\n        A.Iso.oJ = 1;\n        A.ztime = 6;\n        return sayyl \"Tanking into J.name\";\n    }\n    T.not = 1;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: th 4
        dige: db9c30797819
        gk: J
        gro: threes
        nk: c
        v: cJ
      t: J_4
      "y": 
        cv: '0.4'
        cvt: 0.4	C.t
        p: qq/threes/threes
