--- 
Art: 
  "0.4": 
    js_4: 
      c: 
        el: 1
        s: "A.I.js_4 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $sc = C.sc;\n    my $js = C.sc.js;\n    my $J = C.sc.J;\n    my $V = C.sc.V;\n    my $k = C.y.k;\n    my $at = C.y.at;\n    my $ta = C.y.ta;\n    my $lv = C.y.lv;\n    my $vl = C.y.vl;\n    sayyl \"Have fopr J.name the C.t  via \".ki C.sc;\n    my $v = {}; # spots indexes\n    Rw ym/jscoi $A $C $G $T $v;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Art 4
        dige: da67c61e4226
        gk: js
        gkiss: s
        gro: jsfisto
        nk: sc
        nov: 1
        nv: scjs
        rg: J,V,yk,yat,yta,ylv,yvl
        v: scjs
      t: js_4
      "y": 
        cv: '0.4'
        cvt: 0.4	C.t
        p: qq/jsfisto/jsfisto
I: 
  "0.1": 
    mkD: 
      c: 
        el: 1
        s: "A.I.mkD = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($pin,$ar,@Me) = @M;\n    my $I = A.I;\n    my $D;\n    D.point = $pin;\n    if (my $C = ar.__D) {\n        delete ar.__D;\n        D.bab = C.c.s || die \"N s\".ki $C;\n        D.noise .= C.sc.dige if C.sc.dige;\n        D.babnon = 1 if C.sc.bab eq 'non';\n        D.Verb = 1;\n    }\n    D.ar = $ar;\n    D.name = join ' ', D.point, sort keys %{D.ar};\n    D.sign = \"Z\";\n    D.talk = join' ',grep{defined}map{$D->{$_}}qw'sign name noise';\n    $D;\n};\n"
      sc: 
        acgt: pin,ar
        args: A,C,G,T,pin,ar
        code: I 1
        dige: 974b297c1911
        gro: Goodat
      t: mkD
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Goodat/Goodat
    pin: 
      c: 
        el: 1
        s: "A.I.pin = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($pin,$way,@Me) = @M;\n    my $I = A.I;\n    I.pwin || die \"nopwin from pin\";\n    I.pwin->($pin,$way);\n};\n"
      sc: 
        acgt: pin,way
        args: A,C,G,T,pin,way
        code: I 1
        dige: 82803a8c20f2
        gro: Goodat
      t: pin
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Goodat/Goodat
    pon: 
      c: 
        el: 1
        s: "A.I.pon = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($pin,$way,$s,@Me) = @M;\n    my $I = A.I;\n    I.pwin || die \"nopwin from pin\";\n    I.pwin->($pin,$way,{et=>$s});\n};\n"
      sc: 
        acgt: pin,way,s
        args: A,C,G,T,pin,way,s
        code: I 1
        dige: e37d81abf9f1
        gro: Goodat
      t: pon
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Goodat/Goodat
    pwin: 
      c: 
        el: 1
        s: "A.I.pwin = sub {\n    my ($pin,$way,$set,@Me) = @_;\n    my $I = A.I;\n    if (exists $way->{$pin}) {\n          my $o = $way->{$pin};\n        $way->{$pin} = set.et if exists set.et;\n        delete $way->{$pin} if set.de;\n        return $o;\n    }\n    my @path = split /\\/|\\./, $pin;\n    my $h = $way;\n    my $last;\n    for my $p (@path) {\n        if (ref $h ne 'HASH' && ref $h ne 'G') {\n            undef $last;\n            undef $h;\n            last;\n        }\n        $last = [$h,$p];\n        $h = $h->{$p};\n        # ref = T makes it look for jointed rest of path in tiedinto {}\n        # then T collapses the feely data mesh\n    }\n    if ($last) {\n        my ($he,$pi) = @$last;\n        $he->{$pi} = set.et if exists set.et;\n        delete $he->{$pi} if set.de;\n    }\n    return $h if defined $h;\n    \n    return undef unless $pin =~ /\\*/;\n    die \"sat rs findy $pin\";\n};\n"
      sc: 
        acgt: s
        args: pin,way,set
        code: I 1
        dige: 41ad5cef7aed
        gro: Goodat
      t: pwin
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Goodat/Goodat
