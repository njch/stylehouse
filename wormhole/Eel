--- 
I: 
  "0.1": 
    carebowl: 
      c: 
        el: 1
        s: "A.I.carebowl = sub {\n    my ($A,$C,$G,$T,$s,$iii,$x,$xrd) = @_;\n    my $I = A.I;\n    for my $ik (sort keys %$iii) {\n        my $D = $iii->{$ik};\n        if (my $nk = D.sc.nk) {\n            my $C = I.nF.C;\n            next if !exists $C->{$nk};\n            if (my $gk = D.sc.gk) {\n                next if !exists $C->{$nk}->{$gk};\n            }\n        }\n        my $act;\n        my $dont;\n        if (D.sc.acgt && D.sc.act) {\n            $act = 1;\n            # acgtsubs can be defined at any cv\n            # run themselves if act\n            # usu. one receiver (Ci) and the rest scheme\n            die \"D.t .act gets... D.sc.act\" if D.sc.act ne '1';\n            $dont = 1 if exists A.I->{D.t};\n        }\n        # way or acgt-setuping-way\n        unless ($dont) {\n            my $paw = join\"_\",'',I.k,I.cv,D.t;\n            $paw =~ s/\\W//g;\n            Rw $paw $A $C $G $T $__D:D;\n        }\n        # most tiny ticks\n        # this ind is all flywheel\n        # it's a kind of unity that wants to be a block of code like this\n        # and c\n        my @is = A.s;\n        @is = I.d&scIfs,D.sc.Ifs if D.sc.Ifs;\n        @is || next;\n        if ($act) {\n            push @$xrd, [I.k,$ik];\n            my $Ds = $x->{I.k}->{$ik} ||= {};\n            Ds.D = $D;\n            Ds.is = \\@is;\n            D.sc.its = @is;\n        }\n        # TreeD\n        $s->{I.k}->{I.cv}->{$ik} = $D;\n    }\n};\n"
      sc: 
        acgt: s,iii,x,xrd
        args: A,C,G,T,s,iii,x,xrd
        code: I 1
        dige: 6a65d4535276
        gro: KowTime
        l: "#c"
      t: carebowl
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/KowTime/KowTime
    ex: 
      c: 
        el: 1
        s: "A.I.ex = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($i,$K,$cv,$av) = @M;\n    my $I = A.I;\n    # was Rw SNat $A $C $G $T $I $i $K $cv;\n    # baseism\n    my $c = 0+(\"0.\".$cv);\n    my $Av = $av || A.cv;\n    my $sp = $av ? \" Flav $av (no A.cv)\" : \"\";\n    \n    my $talk = \"A.talk: $K$sp $Av > $c --- C.t \";\n    \n    my $aim = {$K=>1};\n    if ($aim->{A.am}) {\n        $aim->{$_} = 1 for @{A.Isl||[]};\n        aim.I = 1;\n    }\n    \n    my $yv = {};\n    # make K/cv/t -> cv/K/t\n    for my $k (sort keys %$i) {\n        my $ii = $i->{$k};\n    \n        next if $k eq 'Ii';\n        next if $k eq 'ooI';\n        ref $ii eq 'HASH' || die \"weird $k=$ii\";\n    \n        for my $vc (sort keys %$ii) {\n            my $iii = $ii->{$vc};\n            die'$k !0<$vc<1' unless $vc > 0 && $vc < 1;\n            $yv->{$vc}->{$k} = $iii;\n        }\n    }\n    \n    # do stuff\n    my $vb; # in fractions\n    my $wasSubtle;\n    for my $vc (sort keys %$yv) {\n        my $is = $yv->{$vc};\n        my $s = {};\n        my $x = {};\n        my $xrd = [];\n    \n        next if $vc <= $Av && $vc != $c;\n        next if $vc > $c;\n    \n        # (for oscillating stretches of inner being)\n        if ($wasSubtle) {\n            undef $wasSubtle;\n            $vb = $vc;\n        }\n        # inter cv wideness loop v and its not ^\n        if ($vb && $vc > $vb && (\n            @{A.N} || @{A.mo.re->{$vb}||[]}\n            )) {\n            # sincing, wide order\n            # various others want to be around for only some of the process...\n            sayre \"$vb -> $vc  bump, \". @{A.N} if A.J.V > 1;\n            T.Z->{$vb} = 1;\n            A.cv = $vb; # so we dont wind up to 6 on the way out of t\n            return T.not = 1;\n        }\n    \n        # pin down poles\n        I.cv = $vc;\n        I.vb = $vb;\n        # draw curvles as spirals done\n    \n        for my $k (sort keys %$is) {\n            my $iii = $is->{$k};\n            next unless $aim->{$k} || (aim.I && A.Iso->{$k});\n            I.k = $k;\n            I.d&carebowl,$s,$iii,$x,$xrd;\n        }\n        #c suble\n        my $se = Rw TreeD $s $scby=gro \n            if A.J.V > 1 && keys %$s;\n        $c == 0.1 ? saygr $se : say $se if $se;\n    \n        die if I.cv ne $vc;\n        die if I.vb ne $vb;\n        my $o;\n        o.vc = $vc;\n        o.vb = $vb;\n        o.Subtle = 0;\n        o.nonSubtle = 0;\n        I.d&exood,$o,$x,$xrd;\n        $vc = o.vc;\n        $vb = o.vb;\n        if (o.Subtle && !o.nonSubtle) {\n            $wasSubtle = 1;\n        }\n    \n        return if T.not;  # will &z, oseve\n        return if delete T.whack;\n    }\n};\n"
      sc: 
        acgt: i,K,cv,av
        args: A,C,G,T,i,K,cv,av
        code: I 1
        dige: 4660c00e5e7a
        gro: KowTime
        nois: "#c"
      t: ex
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/KowTime/KowTime
    exood: 
      c: 
        el: 1
        s: "A.I.exood = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($o,$x,$xrd) = @M;\n    my $I = A.I;\n    for my $kik (@$xrd) {\n        my ($k,$ik) = @$kik;\n        A.Subtle && A.Subtle->{$k} ? o.Subtle++ : o.nonSubtle++;\n        my $Ds = $x->{$k}->{$ik};\n        my $D = Ds.D;\n        for my $s (@{Ds.is}) {\n            D.sc.acgt eq 's'||die \"nonacgts\".wdump $D;\n            exists A.I->{D.t}||die \"acgtI D.t not up: \".wdump A.I;\n    \n            I.d&D.t,$s;\n    \n            I.acted and I.d&acted,$s;\n    \n            if (my $ut = T.ut) {\n                if (ut.matchTd) {\n                    my $d = s.d || die \"confuse\";\n                    d.od.s.T.q->{d.e.k} ||= $d;\n                    d.od.s.T.m->{d.e.k} ||= $d\n                        unless delete(T.noTd);\n                }\n                else { die\"utrowhat \".wdump 2, $ut }\n            }\n    \n            # outwave: schools of many fish (not upcv if !@is)\n            o.vb ||= o.vc if D.sc.v;\n    \n            last if T.not || T.whack;\n        }\n        delete T.ut;\n        last if T.not || T.whack;\n    }\n};\n"
      sc: 
        acgt: o,x,xrd
        args: A,C,G,T,o,x,xrd
        code: I 1
        dige: b15d585bb0fa
        gro: KowTime
        l: "#c"
      t: exood
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/KowTime/KowTime
Mo: 
  "0.434": 
    J_434: 
      c: 
        el: 1
        s: "A.I.J_434 = sub {\n    my ($A,$C,$G,$T,$s) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    $J = C.c.J = C.sc.J;\n    # TODO: soft acuminy over \\d esp. until .bb or something\n    A.mo.Js->{J.name} = $J;\n    # A falls\n    # A.mo exits\n    # J.A persists\n    J.A.first ||= hitime();\n    if (C.sc.W && G.oin ne $J) {\n        my $lev = G.oin.A.tid;\n        if (J.A.tidi && (J.A.tidi + 3) > $lev) {\n            A.ztime = 4;\n        }\n        else {\n            J.A.tidi = $lev;\n        }\n    }\n    sayre \"same A.J.name inside J.name\" if A.J eq $J;\n    if (exists C.sc.pi) {\n        die 'JiternotAJ' if J.Jiter ne A.J;\n        die 'pimostJ'if J.most.J eq $J;\n    }\n    else {\n        die 'esel' if J.most.J ne $J;\n    }\n    A.ztime ||= 6;\n    A.time && die \"Had atime\";\n    A.time = sub { # A.t& cover, serve single digit ad hocs, like 2\n        my ($JJ,$q) = @_;\n        die\"JTIMEJ\" if $JJ ne $J;\n        A.ztime >= $q\n    };\n    if (C.sc.pi) {\n        J.A.d = J.Jiter.A.d + 1;\n        J.ind = join '  ', ('') x J.A.d;\n        J.name = \"J.A.d. C.c.pi*C.t\";\n        J.d = J.C = $C;\n        A.ztime = 6 if A.ztime < 6;\n    }\n    A.talk .= \"J: J.name\";\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo 434
        dige: 0988a4ef61cf
        gk: J
        gro: Jamping
        nk: c
        v: cJ
      t: J_434
      "y": 
        cv: '0.434'
        cvt: 0.434	C.t
        p: qq/Jamping/Jamping
  "0.6": 
    J_6: 
      c: 
        el: 1
        s: "A.I.J_6 = sub {\n    my ($A,$C,$G,$T,$s) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n        my $talk = \"T $A->{cv} $A->{ztime} $J->{most}->{J}->{name}       $J->{name}\";\n        $A->{time}->($J, 6) || return do {\n            say\"$talk   SKive!\" if $A->{J}->{V};\n            $T->{nose} = 1;\n        };\n        sayyl \"J6 ! $talk\";\n        $A->{Subtle}->{J} = 1;\n        $A->{t}->(\"J\",9,1);\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo 6
        dige: 14d02492dab9
        gk: J
        gro: Jumps
        nk: c
        v: cJ
      t: J_6
      "y": 
        cv: '0.6'
        cvt: 0.6	C.t
        p: qq/Jumps/Jumps
  "0.7": 
    J_7: 
      c: 
        el: 1
        s: "A.I.J_7 = sub {\n    my ($A,$C,$G,$T,$s) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n        return if $T->{nose};\n        return sayre \"Tsame=$T->{same} $J->{name}\" if $T->{same};\n        $J->{most}->{eo} = 'Sev' if $J->{A}->{II}->{Sev};\n        say \"oJ77 77 $J->{name} -> $J->{most}->{eo}\" unless $J->{yt}->{quiet} || $C->{sc}->{pi};\n        $G->{w}->(\"$J->{most}->{eo}\", {J => $J, A => $A}, $G);\n        # dos geo ^ Yesui\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo 7
        dige: 1a126155924a
        gk: J
        gro: Jumps
        nk: c
        v: cJ
      t: J_7
      "y": 
        cv: '0.7'
        cvt: 0.7	C.t
        p: qq/Jumps/Jumps
O: 
  "0.31": 
    tycsc_31: 
      c: 
        el: 1
        s: "A.I.tycsc_31 = sub {\n    my ($A,$C,$G,$T,$s) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $Y = C.c.Y;\n    my $J = C.c.J;\n    my $V = C.c.V;\n    my $k = C.y.k;\n    my $at = C.y.at;\n    my $ta = C.y.ta;\n    my $lv = C.y.lv;\n    my $vl = C.y.vl;\n    at.t = C.t;\n    at.y.cv = C.y.cv;\n    sayre \"OSC7 C.t no c_s: \".ki $C if !exists C.c.s;\n    at.c.s = C.c.s;\n    at.sc = {%{C.sc}};\n    delete at.sc->{$_} for qw'geo idly ml nspc path yspc';\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: O 31
        dige: c8cedc1e0bb5
        gk: 'Y'
        gro: Yosc
        nk: c
        rg: J,V,yk,yat,yta,ylv,yvl
        v: cY
      t: tycsc_31
      "y": 
        cv: '0.31'
        cvt: 0.31	C.t
        p: qq/Yosc/Yosc
  "0.36": 
    Jin_36: 
      c: 
        el: 1
        s: "A.I.Jin_36 = sub {\n    my ($A,$C,$G,$T,$s) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $Y = C.c.Y;\n    my $J = C.c.J;\n    my $V = C.c.V;\n    my $k = C.y.k;\n    my $at = C.y.at;\n    my $ta = C.y.ta;\n    my $lv = C.y.lv;\n    my $vl = C.y.vl;\n    if (my $v = at.sc.J) { # J unifies -\n        at.sc.J = v.name;\n    \n        my $nV = v.El->{V.name};\n        $nV || return sayre \"no V.name on v.name\";\n        my $rv = nV.rv || {LIES=>\"from v.name\"};\n        nV.rv || return sayre \"no rv V.name on v.name: \".wdump 2,v.El;\n    \n        lv.do->{V.name} = $rv;\n        at.V->{V.name} = rv.i;\n    }\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: O 36
        dige: 190456f4daf3
        gk: 'Y'
        gro: Yosc
        nk: c
        rg: J,V,yk,yat,yta,ylv,yvl
        v: cY
      t: Jin_36
      "y": 
        cv: '0.36'
        cvt: 0.36	C.t
        p: qq/Yosc/Yosc
  "0.37": 
    Jnine_37: 
      c: 
        el: 1
        s: "A.I.Jnine_37 = sub {\n    my ($A,$C,$G,$T,$s) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $Y = C.c.Y;\n    my $J = C.c.J;\n    my $V = C.c.V;\n    my $k = C.y.k;\n    my $at = C.y.at;\n    my $ta = C.y.ta;\n    my $lv = C.y.lv;\n    my $vl = C.y.vl;\n    if (C.c.root) { # / unifies  <\n        lv.voso = 1;\n        for my $ik (@{V.os}) {\n            my $iv = V.lv->{$ik};\n            do { sayre(\"Skip self in self\") for 1..6 } && next\n                if C.sc.J && C.sc.J eq A.J;\n            lv.do->{$ik} = $iv;\n            at.V->{$ik} = iv.i;\n        }\n    }\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: O 37
        dige: 6b7f4694cde2
        gk: 'Y'
        gro: Yosc
        nk: c
        rg: J,V,yk,yat,yta,ylv,yvl
        v: cY
      t: Jnine_37
      "y": 
        cv: '0.37'
        cvt: 0.37	C.t
        p: qq/Yosc/Yosc
  "0.38": 
    sel_38: 
      c: 
        el: 1
        s: "A.I.sel_38 = sub {\n    my ($A,$C,$G,$T,$s) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $Y = C.c.Y;\n    my $J = C.c.J;\n    my $V = C.c.V;\n    my $k = C.y.k;\n    my $at = C.y.at;\n    my $ta = C.y.ta;\n    my $lv = C.y.lv;\n    my $vl = C.y.vl;\n    at.sc.geo = ki(at.sc.geo) if at.sc.geo;\n    at.y = at.y.cv if keys %{at.y} == 1 && exists at.y.cv;\n    # ^ to SlideEater decode array of y expressions, xotted together\n    for my $up (qw'tag id') {\n        at.c->{$up} = delete at.sc->{$up} if exists at.sc->{$up}\n    }\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: O 38
        dige: 882e888a0a8a
        gk: 'Y'
        gro: Yosc
        nk: c
        rg: J,V,yk,yat,yta,ylv,yvl
        v: cY
      t: sel_38
      "y": 
        cv: '0.38'
        cvt: 0.38	C.t
        p: qq/Yosc/Yosc
