--- 
I: 
  "0.1": 
    Cngk: 
      c: 
        el: 2
        s: "A.I.Cngk = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($s,$D,@Me) = @M;\n    my $I = A.I;\n    ref $A || die \"nmonref A!\";\n    aft { $@ .= \"\\nLookat: \".ki($s).\"\\nWith: \".ki($D) if $@ };\n    return 1 if D.c.any;\n    die \"nonNKnk\".ki$D if !D.c.nk;\n    return 0 if !exists $s->{D.c.nk};\n    return [$s->{D.c.nk}] if !exists D.c.gk;\n    return 0 if !exists $s->{D.c.nk}->{D.c.gk};\n    return [$s->{D.c.nk}->{D.c.gk}];\n};\n"
      sc: 
        acgt: s,D
        args: A,C,G,T,s,D
        code: I 1
        dige: 1ce95658c144
        gro: C
      t: Cngk
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    El: 
      c: 
        el: 2
        s: "A.I.El = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($J,$name,@Me) = @M;\n    my $I = A.I;\n    J.El->{$name} ||= {bb=>{},name=>$name};\n};\n"
      sc: 
        acgt: J,name
        args: A,C,G,T,J,name
        code: I 1
        dige: 9fd87735d303
        gro: Pha
        l: "#c without a self"
      t: El
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Pha/Pha
    Elj: 
      c: 
        el: 2
        s: "A.I.Elj = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($J,$name,@Me) = @M;\n    my $I = A.I;\n    J.El->{$name} ||= Rw Jto - $le:J $name;\n};\n"
      sc: 
        acgt: J,name
        args: A,C,G,T,J,name
        code: I 1
        dige: 3001808fbcce
        gro: Pha
        l: "#c with a self"
      t: Elj
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Pha/Pha
    Elvis: 
      c: 
        el: 2
        s: "A.I.Elvis = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($J,$Y,@Me) = @M;\n    my $I = A.I;\n    my $wtf = I.d&wtfch,J.bb,Y.bb;\n    \n    Y.tw ||= {};\n    Y.lo = {}; # compile\n    \n    for my $mo (qw'gone diff new') {\n        for my $r (keys %{$wtf->{$mo}}) {\n            my $j = I.d&rJ,$r,$J;\n            j.r = $r;\n            j.lt = j.cv.\"\\t\".j.t;\n            if (!j.lt=~/\\S/) {\n                die \"Got $r =>   \".ki $j;\n            }\n            if ($mo eq 'gone') {\n                delete Y.bb->{j.r};\n                delete Y.tw->{j.lt}->{j.style};\n            }\n            else {\n                Y.bb->{j.r} = j.s;\n                Y.tw->{j.lt}->{j.style} = j.s;\n            }\n            Y.lo->{j.lt}->{$mo}->{j.style} = j.s;\n        }\n    }\n    \n    Y.tv ||= {};\n    Y.v ||= {};\n    Y.go = {};\n    my $same = 1;\n    for my $k (keys %{Y.lo}) {\n        my $tf = Y.lo->{$k};\n        my $cs = Y.tw->{$k};\n        if (tf.new && !tf.gone && !tf.diff && keys %{tf.new} == keys %$cs) {\n            $same = 0; # new line to make\n        }\n        if (tf.gone && !keys %$cs) {\n            $same = 0; # line to disappear\n            my $C = Y.go->{$k} = delete Y.tv->{$k};\n            my ($cv,$t) = $k =~ /^(.+?)\\t(.*)$/;\n            delete Y.v->{$cv}->{$t};\n            delete Y.v->{$cv} unless keys %{Y.v->{$cv}};\n        }\n        if (tf.diff || tf.new) {\n            keys %$cs || die 'nokeys';\n            my ($cv,$t) = $k =~ /^(.+?)\\t(.*)$/;\n            defined $cv || die \"twas $k\";\n            my $foam = sub {\n                my $C = shift;\n                %$C = (t=>$t,y=>{cv=>$cv},c=>{},sc=>{%$cs});\n                C.c.s = delete C.sc->{''} if exists C.sc->{''};\n            };\n            $foam->(Y.tv->{$k} ||= {});\n            $foam->(Y.v->{$cv}->{$t} ||= {});\n        }\n    }\n    if (!$same) {\n        Y.vs = [];\n        Y.kvi = {};\n        Y.cvi = {};\n        Y.te = {};\n        my $i = 0;\n        for my $k (sort keys %{Y.tv}) {\n            my $C = Y.tv->{$k} || die \"wtf $k\";\n            push @{Y.vs}, $C;\n            Y.kvi->{$k} = $i;\n            Y.cvi->{C.y.cv} ||= $i;\n            Y.te->{C.t}->{C.y.cv} = $C;\n            $i++;\n        }\n    }\n    \n    Y.ra = I.d&ratio,wtf.sami,wtf.tot;\n    Y.rato = wtf.tot;\n    Y.revs = !$same;\n    \n    $Y;\n};\n"
      sc: 
        acgt: J,Y
        args: A,C,G,T,J,Y
        code: I 1
        dige: 16dbd22a49a6
        gro: Pha
        l: "#c"
      t: Elvis
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Pha/Pha
    array: 
      c: 
        el: 2
        s: "A.I.array = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    return I.d&fourreal,$s if @$s != 1 && !ref $s->[0] || $s->[0] =~ /^\\w+$/;\n    return I.d&fourstring,$s->[0] if @$s == 1 && !ref $s->[0];\n    # should stick In in first and M it? \n    # kind of motion that wants to be unsure in the wild\n    unshift @{A.N}, @$s;\n    T.not = 1;\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 1621c6fcf424
        gro: SlideEa
      t: array
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/SlideEa/SlideEa
    as: 
      c: 
        el: 2
        s: "A.I.as = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($s,$x,@Me) = @M;\n    my $I = A.I;\n    for (qw'begin bb ord tim wtf') {\n         exists $x->{$_} || next;\n         my $v = $x->{$_};\n         $v = [@$v] if ref $v eq 'ARRAY';\n         $v = {%$v} if ref $v eq 'HASH';\n         $s->{$_} = $v;\n    }\n};\n"
      sc: 
        acgt: s,x
        args: A,C,G,T,s,x
        code: I 1
        dige: e6a7402c5fdd
        gro: Pha
      t: as
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Pha/Pha
    bandon: 
      c: 
        el: 2
        s: "A.I.bandon = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    delete s.J.phy->{s.name};\n    s.abandoned = 1;\n    if (my $x = s.head) {\n        I.d&as,$s,$x;\n    }\n    I.d&end,$s\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: e6de6441b8ff
        gro: Pha
      t: bandon
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Pha/Pha
    c: 
      c: 
        el: 2
        s: "A.I.c = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($D,@Me) = @M;\n    my $I = A.I;\n    I.d&inDin,$C,@M;\n};\n"
      sc: 
        acgt: D
        args: A,C,G,T,D
        code: I 1
        dige: a931936381c2
        gro: C
      t: c
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    carebowl: 
      c: 
        el: 2
        s: "A.I.carebowl = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($s,$iii,$x,$xrd,@Me) = @M;\n    my $I = A.I;\n    for my $ik (sort keys %$iii) {\n        my $D = $iii->{$ik};\n        if (my $nk = D.sc.nk) {\n            my $C = I.nF.C;\n            next if !exists $C->{$nk};\n            if (my $gk = D.sc.gk) {\n                next if !exists $C->{$nk}->{$gk};\n            }\n        }\n        my $act;\n        my $dont;\n        if (D.sc.acgt && D.sc.act) {\n            $act = 1;\n            # acgtsubs can be defined at any cv\n            # run themselves if act\n            # usu. one receiver (Ci) and the rest scheme\n            die \"D.t .act gets... D.sc.act\" if D.sc.act ne '1';\n            $dont = 1 if exists A.I->{D.t};\n        }\n        # way or acgt-setuping-way\n        unless ($dont) {\n            my $paw = join\"_\",'',I.k,I.cv,D.t;\n            $paw =~ s/\\W//g;\n            Rw $paw $A $C $G $T $__D:D;\n        }\n        # most tiny ticks\n        # this ind is all flywheel\n        # it's a kind of unity that wants to be a block of code like this\n        # and c\n        my @is = A.s;\n        @is = I.d&scIfs,D.sc.Ifs if D.sc.Ifs;\n        @is || next;\n        if ($act) {\n            push @$xrd, [I.k,$ik];\n            my $Ds = $x->{I.k}->{$ik} ||= {};\n            Ds.D = $D;\n            Ds.is = \\@is;\n            D.sc.its = @is;\n        }\n        # TreeD\n        $s->{I.k}->{I.cv}->{$ik} = $D;\n    }\n};\n"
      sc: 
        acgt: s,iii,x,xrd
        args: A,C,G,T,s,iii,x,xrd
        code: I 1
        dige: 1e38d8a681fb
        gro: KnowTime
        l: "#c"
      t: carebowl
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/KnowTime/KnowTime
    e: 
      c: 
        el: 2
        s: "A.I.e = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($D,@Me) = @M;\n    my $I = A.I;\n    I.d&inDin,C.c.e,@M;\n};\n"
      sc: 
        acgt: D
        args: A,C,G,T,D
        code: I 1
        dige: 06747ef15695
        gro: C
      t: e
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    end: 
      c: 
        el: 2
        s: "A.I.end = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $y = s.J.phl->{s.name} ||= {name=>s.name, l=>[]};\n    s.ended = hitime();\n    delete s.J.phy->{s.name};\n    shift @{y.l} while @{y.l} > 5;\n    # layers ^ rolling in time index .r -> the y.l\n    # so last phase of $name can be found?\n    push @{y.l}, $s;\n    if (s.bb) {\n        my $w = @{y.l};\n        y.l_bb->{$_} = $w for keys %{s.bb};\n    }\n    # somewhere thinks about what happened\n    $y\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 45e558668e71
        gro: Pha
      t: end
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Pha/Pha
    ex: 
      c: 
        el: 2
        s: "A.I.ex = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($i,$K,$cv,$av,@Me) = @M;\n    my $I = A.I;\n    # was Rw SNat $A $C $G $T $I $i $K $cv;\n    # baseism\n    my $c = 0+(\"0.\".$cv);\n    my $Av = $av || A.cv;\n    my $sp = $av ? \" Flav $av (no A.cv)\" : \"\";\n    \n    my $talk = \"A.talk: $K$sp $Av > $c --- C.t \";\n    \n    my $aim = {$K=>1};\n    if ($aim->{A.am}) {\n        $aim->{$_} = 1 for @{A.Isl||[]};\n        aim.I = 1;\n    }\n    \n    my $yv = {};\n    # make K/cv/t -> cv/K/t\n    for my $k (sort keys %$i) {\n        my $ii = $i->{$k};\n    \n        next if $k eq 'Ii';\n        next if $k eq 'ooI';\n        ref $ii eq 'HASH' || die \"weird $k=$ii\";\n    \n        for my $vc (sort keys %$ii) {\n            my $iii = $ii->{$vc};\n            die'$k !0<$vc<1' unless $vc > 0 && $vc < 1;\n            $yv->{$vc}->{$k} = $iii;\n        }\n    }\n    \n    # do stuff\n    my $vb; # in fractions\n    my $wasSubtle;\n    for my $vc (sort keys %$yv) {\n        my $is = $yv->{$vc};\n        my $s = {};\n        my $x = {};\n        my $xrd = [];\n    \n        next if $vc <= $Av && $vc != $c;\n        next if $vc > $c;\n    \n        # our  osc (stay in K per Subtle ness);\n        my @iz = grep {\n            $aim->{$_} || (aim.I && (A.Iso->{$_} || I.also->{$_}))\n        } sort keys %$is;\n        next if !@iz;\n    \n        # decide inter cv wideness loop\n        if ($wasSubtle) {\n            undef $wasSubtle;\n        }\n        elsif ($vb && $vc > $vb && (\n            @{A.N} || @{A.mo.re->{$vb}||[]}\n            )) {\n            # sincing, wide order\n            # various others want to be around for only some of the process...\n            sayre \"$vb -> $vc  bump, \". @{A.N} if A.J.V > 1;\n            T.Z->{$vb} = 1;\n            A.cv = $vb; # so we dont wind up to 6 on the way out of t\n            return T.not = 1;\n        }\n    \n        # pin down poles\n        I.cv = $vc;\n        I.vb = $vb;\n        # draw curvles as spirals done\n    \n        for my $k (@iz) {\n            my $iii = $is->{$k};\n            I.k = $k;\n            I.d&carebowl,$s,$iii,$x,$xrd;\n        }\n        # suble\n        my $se = Rw TreeD $s $scby=gro \n            if A.J.V > 1 && keys %$s;\n        $c == 0.1 ? saygr $se : say $se if $se;\n    \n        my $o;\n        (o.vc,o.vb) = ($vc,$vb);\n        I.d&exood,$o,$x,$xrd;\n        ($vc,$vb) = (o.vc,o.vb);\n        if (o.Subtle && !o.nonSubtle) {\n            $wasSubtle = 1;\n        }\n    \n        return if T.not;  # will &z, oseve\n        return if delete T.whack;\n    }\n};\n"
      sc: 
        acgt: i,K,cv,av
        args: A,C,G,T,i,K,cv,av
        code: I 1
        dige: c1559663dda3
        gro: KnowTime
        nois: "#c"
      t: ex
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/KnowTime/KnowTime
    exactl: 
      c: 
        el: 2
        s: "A.I.exactl = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $q = shift;\n    my $y = I.d&end,$s;\n    my $cur = y.l->[-1];\n    my $last = y.l->[-2];\n    $cur eq $s || die \"sidf$cur $s\";\n    last.bb ||= {};\n    \n    my $wtf = I.d&wtfch,cur.bb,last.bb;\n    \n    delete s.J.bb->{$_} for keys %{wtf.gone};\n    \n    # see s.extill, time passing interesto...\n    # churn stats like 30% of last disappear, 20% new\n    s.wtf = $wtf;\n    $wtf;\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: c98060f45a3a
        gro: Pha
        l: "#c un-ins things from J"
      t: exactl
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Pha/Pha
    exood: 
      c: 
        el: 2
        s: "A.I.exood = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($o,$x,$xrd,@Me) = @M;\n    my $I = A.I;\n    for my $kik (@$xrd) {\n        my ($k,$ik) = @$kik;\n        A.Subtle && A.Subtle->{$k} ? o.Subtle++ : o.nonSubtle++;\n        my $Ds = $x->{$k}->{$ik};\n        my $D = Ds.D;\n        for my $s (@{Ds.is}) {\n            D.sc.acgt eq 's'||die \"nonacgts\".wdump $D;\n            exists A.I->{D.t}||die \"acgtI D.t not up: \".wdump A.I;\n    \n            T.D = $D;\n            I.d&D.t,$s;\n    \n            I.acted and I.d&acted,$s;\n    \n            if (my $ut = T.ut) {\n                if (ut.matchTd) {\n                    my $d = s.d || die \"confuse\";\n                    d.od.s.T.q->{d.e.k} ||= $d;\n                    d.od.s.T.m->{d.e.k} ||= $d\n                        unless delete(T.noTd);\n                }\n                else { die\"utrowhat \".wdump 2, $ut }\n            }\n    \n            # outwave: schools of many fish (not upcv if !@is)\n            o.vb ||= o.vc if D.sc.v;\n    \n            last if T.not || T.whack;\n        }\n        delete T.ut;\n        last if T.not || T.whack;\n    }\n};\n"
      sc: 
        acgt: o,x,xrd
        args: A,C,G,T,o,x,xrd
        code: I 1
        dige: 3cd32866a91c
        gro: KnowTime
        l: "#c"
      t: exood
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/KnowTime/KnowTime
    fourreal: 
      c: 
        el: 2
        s: "A.I.fourreal = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    (C.t, C.y) = @$s;\n    C.c  = $s->[2] if exists $s->[2];\n    C.sc = $s->[3] if exists $s->[3];\n    die'@>4'.wdump $s if @$s > 4;\n    die\"C.t from \".wdump $s if ref C.t; # dives\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 87baea0c56c8
        gro: C
      t: fourreal
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    fourstring: 
      c: 
        el: 2
        s: "A.I.fourstring = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    I.d&MZu,$1 if $s =~ /^\\s*#?\\s*MZ (.+)$/;\n    $s =~ s/^\\s+//;\n    if ($s =~ /^\\s*(#.*)$/) {\n       T.not = 1;\n       T.com = $1;\n    }\n    elsif ($s eq '') {\n       T.not = T.space = 1;\n    }\n    else {\n       my $ci = $s;\n       for my $nk (qw't y c sc') {\n           if ($ci =~ s/^(\\S+) *//) { # some t are types of space\n               my $v = $1;\n               $v = I.d&peel,$v if $nk ne 't' && $v =~ I.peels;\n               # << consumes more lines into $nk, then ...\n               $v = '' if $v =~ /^(''|\"\")$/;\n               $C->{$nk} = $v;\n           }\n       }\n    }\n    saybl \"4string: $s            \".ki $C if A.V&C;\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: dbd7f1097b0d
        gro: C
      t: fourstring
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    givy: 
      c: 
        el: 2
        s: "A.I.givy = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $y = C.y;\n    if (ref $s eq 'ARRAY') {\n        for my $yy (@$s) {\n            C.y = {};\n            I.d&givy,$yy;\n            ref $y || die \"notash \".ki $y;\n            I.d&xot,$y,C.y;\n            C.y = $y;\n        }\n    }\n    elsif (ref $s) {\n        ref $s eq 'HASH' || die \"no $s\";\n        if (I.d&taJe,$s ) {\n            my $yy = C.y;\n            C.y = {} if ref C.y ne 'HASH';\n            I.d&givy,$yy;\n        }\n        elsif ($y ne $s) {\n            I.d&xot,$y,$s;\n        }\n    }\n    elsif ($s eq '') {\n        my $x = I.blanky ? I.d&blanky : {};\n        I.d&xot,C.y,$x if keys %$x;\n    }\n    elsif ($s =~ /^($NUM)$/) {\n        y.cv = $1;\n    }\n    elsif ($s =~ /^($NUM)-($NUM)$/) {\n        y.in = $1;\n        y.out = $2;\n    }\n    elsif ($s =~ /^($NUM)-($NUM)x($NUM)$/) {\n        y.in = $1;\n        y.out = $2;\n        y.thi = $3;\n    }\n    elsif ($s =~ /^-(\\w+)$/) {\n        C.c.pi = $1;\n        C.c.s = C.t if !exists C.c.s || A.btw.cwass;\n    }\n    elsif ($s =~ /^([a-zA-Z]+)(?::(.+))?$/) {\n        C.c->{$1} = $2 || C.t;\n    }\n    else {\n        die \"C y wtf: $s\";\n    }\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 85c5e641ba7a
        gro: SlideEa
      t: givy
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/SlideEa/SlideEa
    hash: 
      c: 
        el: 2
        s: "A.I.hash = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    return %$C = %$s if exists s.t && s.y && s.c;\n    I.d&servehash,$s;\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: a28cc9c268cf
        gro: SlideEa
      t: hash
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/SlideEa/SlideEa
    hup: 
      c: 
        el: 2
        s: "A.I.hup = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $CC = {%$s};\n    $CC->{$_} = {%{$CC->{$_}}} for grep {ref $CC->{$_} eq 'HASH'} keys %$CC;\n    return $CC;\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 5c16f3716362
        gro: C
      t: hup
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    inDin: 
      c: 
        el: 2
        s: "A.I.inDin = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($s,$D,@Me) = @M;\n    my $I = A.I;\n    die'nofA' if !I.nF.A;\n    #\n    return () unless defined $s;\n    return $s if $D eq 'C';\n    #\n    shift @M; # s\n    $D = I.d&interpD,@M if !ref $D;\n    #\n    my $v = I.d&Cngk,$s,$D;\n    die \"Unhandles any: $v: \".ki $D if $v eq '1';\n    #\n    return () unless $v;\n    # blankgk\n    A.note->{D.c.nk}->{D.c.gk} = $v if A.note;\n    #\n    @$v == 1 || die \"Many somehowed \".wdump 3,[ki($D),$v];\n    ($v) = @$v;\n    if (D.c.as eq 'list') {\n        ref $v eq 'ARRAY' || die 'Cngk for list not array '.ki $D;\n        return @$v;\n    }\n    return $v;\n};\n"
      sc: 
        acgt: s,D
        args: A,C,G,T,s,D
        code: I 1
        dige: 8af6fd71ba5e
        gro: C
      t: inDin
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    interpD: 
      c: 
        el: 2
        s: "A.I.interpD = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($nk,$gk,@Me) = @M;\n    my $I = A.I;\n    my $defnk = 'c';\n    return $nk if ref $nk;\n    my $D = {};\n    D.c.as = 'list' if $nk =~ s/^_//;\n    while ($gk =~ s/^%(.+?):(.+?)(?=%|$)//g) {\n        D.c->{$1} = $2;\n        pop @M if @M == 2;\n    }\n    if (@M == 1 && $nk eq 't') {\n        D.c.nk = $nk;\n    }\n    elsif (@M == 1) { # or from t,,,\n        D.c.nk ||= $defnk;\n        D.c.gk ||= $nk;\n    }\n    elsif (@M == 2) {\n        D.c.nk = $nk;\n        D.c.gk = $gk;\n    }\n    delete D.c.gk if D.c.gk eq 'NOGK';\n    $D\n};\n"
      sc: 
        acgt: nk,gk
        args: A,C,G,T,nk,gk
        code: I 1
        dige: 9d1fccaf5235
        gro: C
      t: interpD
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    isC: 
      c: 
        el: 2
        s: "A.I.isC = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    return 0 unless ref $s eq 'HASH';\n    exists s.t && defined C.t && !ref s.t\n    && ref s.y && ref s.c && 9 > keys %$s;\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 63202b6a0791
        gro: SlideEa
      t: isC
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/SlideEa/SlideEa
    isJ: 
      c: 
        el: 2
        s: "A.I.isJ = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    ref $s eq 'HASH' && ref s.bb eq 'HASH';\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 133e12cc5fa2
        gro: SlideEa
      t: isJ
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/SlideEa/SlideEa
    mkD: 
      c: 
        el: 2
        s: "A.I.mkD = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($pin,$ar,@Me) = @M;\n    my $I = A.I;\n    my $D;\n    D.point = $pin;\n    if (my $C = ar.__D) {\n        delete ar.__D;\n        D.bab = C.c.s || die \"N s\".ki $C;\n        D.noise .= C.sc.dige if C.sc.dige;\n        D.babnon = 1 if C.sc.bab eq 'non';\n        D.Verb = 1;\n    }\n    D.ar = $ar;\n    D.name = join ' ', D.point, sort keys %{D.ar};\n    D.sign = \"Z\";\n    D.talk = join' ',grep{defined}map{$D->{$_}}qw'sign name noise';\n    $D;\n};\n"
      sc: 
        acgt: pin,ar
        args: A,C,G,T,pin,ar
        code: I 1
        dige: 974b297c1911
        gro: Goodat
      t: mkD
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Goodat/Goodat
    peel: 
      c: 
        el: 2
        s: "A.I.peel = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    $s =~ s/^%// || \n        $s =~ s/^{// && $s =~ s/}$//\n        || die \"unpealable $s\";\n    my $c;\n    for (split ',', $s) {\n        my ($k, $v) = split ':', $_, 2;\n        $v = 1 if !defined $v;\n        $c->{$k} = $v;\n    }\n    $c||{}\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 86d02e052c88
        gro: C
      t: peel
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    peels: 
      c: 
        el: 2
        s: "A.I.peels = (sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    qr/^[\\{\\%]\\w+/;\n})->($A,$C,$G,$T);\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 1a4b86ada8e3
        gro: C
        subpeel: 1
      t: peels
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    pha: 
      c: 
        el: 2
        s: "A.I.pha = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($J,$name,@Me) = @M;\n    my $I = A.I;\n    # tracked being\n    # temporal phatness, per suJ (encap $M surges within)\n    if (my $x = J.phy->{$name}) {\n        sayre \"J.name 's $name was re entrant\";\n        I.d&end,$x;\n        # end - maybe new stuffright as some random part of this process\n        # hold yay minutes of changes in 10 second groups, etc\n    }\n    # bz multicasts\n    my $x = J.phy->{$name} = {};\n    x.begin = hitime();\n    x.name = $name;\n    x.J = $J;\n    x.bb = {};\n    x.ord = [];\n    #x.tim = {};\n    #x.wtf = {}; # F grab\n    #x.ap = sub{}; # bz do aftering\n    x.qui = 1;\n    x.head = J.phl->{$name}->{l}->[-1] if J.phy->{$name};\n    $x;\n};\n"
      sc: 
        acgt: J,name
        args: A,C,G,T,J,name
        code: I 1
        dige: ab1fd2a37714
        gro: Pha
      t: pha
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Pha/Pha
    pin: 
      c: 
        el: 2
        s: "A.I.pin = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($pin,$way,@Me) = @M;\n    my $I = A.I;\n    I.pwin || die \"nopwin from pin\";\n    I.pwin->($pin,$way);\n};\n"
      sc: 
        acgt: pin,way
        args: A,C,G,T,pin,way
        code: I 1
        dige: 82803a8c20f2
        gro: Goodat
      t: pin
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Goodat/Goodat
    pon: 
      c: 
        el: 2
        s: "A.I.pon = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($pin,$way,$s,@Me) = @M;\n    my $I = A.I;\n    I.pwin || die \"nopwin from pin\";\n    I.pwin->($pin,$way,{et=>$s});\n};\n"
      sc: 
        acgt: pin,way,s
        args: A,C,G,T,pin,way,s
        code: I 1
        dige: e37d81abf9f1
        gro: Goodat
      t: pon
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Goodat/Goodat
    pwin: 
      c: 
        el: 2
        s: "A.I.pwin = sub {\n    my ($pin,$way,$set,@Me) = @_;\n    my $I = A.I;\n    if (exists $way->{$pin}) {\n          my $o = $way->{$pin};\n        $way->{$pin} = set.et if exists set.et;\n        delete $way->{$pin} if set.de;\n        return $o;\n    }\n    my @path = split /\\/|\\./, $pin;\n    my $h = $way;\n    my $last;\n    for my $p (@path) {\n        if (ref $h ne 'HASH' && ref $h ne 'G') {\n            undef $last;\n            undef $h;\n            last;\n        }\n        $last = [$h,$p];\n        $h = $h->{$p};\n        # ref = T makes it look for jointed rest of path in tiedinto {}\n        # then T collapses the feely data mesh\n    }\n    if ($last) {\n        my ($he,$pi) = @$last;\n        $he->{$pi} = set.et if exists set.et;\n        delete $he->{$pi} if set.de;\n    }\n    return $h if defined $h;\n    \n    return undef unless $pin =~ /\\*/;\n    die \"sat rs findy $pin\";\n};\n"
      sc: 
        acgt: s
        args: pin,way,set
        code: I 1
        dige: 41ad5cef7aed
        gro: Goodat
      t: pwin
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Goodat/Goodat
    renc: 
      c: 
        el: 2
        s: "A.I.renc = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    C.c = C.c =~ I.peels ? I.d&peel,C.c\n      : do {\n        A.btw.cwass = 1 if \"\" eq C.c;\n        A.btw.cwasnd = 1 if !defined C.c;\n          {s => C.c};\n      };\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: c80f2d6f0f67
        gro: SlideEa
      t: renc
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/SlideEa/SlideEa
    rensc: 
      c: 
        el: 2
        s: "A.I.rensc = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    C.sc = C.sc eq '' ? {}\n        : C.sc =~ I.peels\n        ? I.d&peel,C.sc\n        : die \"C sc nostr: C.sc   of I.peels  \".ki $C\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 4e4662544dd1
        gro: SlideEa
      t: rensc
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/SlideEa/SlideEa
    sca: 
      c: 
        el: 2
        s: "A.I.sca = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    $s /= 10 while $s > 1 || $s < -1;\n    return $s\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 2649b4f98317
        gro: SlideEa
      t: sca
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/SlideEa/SlideEa
    scyvle: 
      c: 
        el: 2
        s: "A.I.scyvle = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    for (qw'in out cv') {\n        if (my $so = C.y->{$_}) {\n            my $i;\n            while (C.y->{$_} <= -1 || C.y->{$_} >= 1) {\n                C.y->{$_} /= 10;\n                die \"Many i chewing on \".ki C.y if $i++ > 10;\n            }\n        }\n    }\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: d054be1e9bda
        gro: SlideEa
      t: scyvle
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/SlideEa/SlideEa
    string: 
      c: 
        el: 2
        s: "A.I.string = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    die \"string: $s\";\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 196a2239898a
        gro: SlideEa
      t: string
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/SlideEa/SlideEa
    t: 
      c: 
        el: 2
        s: "A.I.t = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($K,$cv,$av,@Me) = @M;\n    my $I = A.I;\n    ($K,$cv) = (A.am,$K) if !$cv && $K;\n    $av = 0+(\"0.\".$av) if $av;\n    die \"K$K cv$cv\" unless $K && $cv;\n    my $c = 0+(\"0.\".$cv);\n    my $Av = $av || A.cv;\n    \n    # adapt to much  mergey       extendo  rubble\n    my $i = Rw collaspII $A;\n    die'difAvcol' if $Av ne ($av || A.cv);\n    #\n    my $ncv;\n    my $re;\n    my $dont;\n    if ($Av < 0.6 || $c >= 0.7) {\n        if ($c >= $Av) {\n            $ncv = $c;\n            $re = 1;\n        }\n        else {\n            $re = 0;\n            $dont = 1;\n            say \" deInc $Av - $cv $c\";\n        }\n        die \"pre bigger\" if $cv < $Av;\n    }\n    else {\n        if ($c < $Av) {\n            if ($Av == 0.6) { # scoop up all on entering timezone\n                $re = 1;\n                $dont = 1; # or will II fall away\n            }\n            else {\n                $re = 0;\n                $dont = 1;\n            }\n        }\n        elsif ($c == $Av) {\n            $re = 1;\n        }\n        elsif ($c > $Av) { # and $c < 0.7, is a next time\n            T.Z->{$c} = 1;\n            $re = 0;\n            $dont = 1;\n        }\n        else {die\"nof\"}\n    }\n    undef $ncv if $av; # aux K\n    my $was = A.cv;\n    $dont || I.d&ex,$i,$K,$cv,$av;\n    A.cv = $ncv if defined $ncv && A.cv == $was;\n    $re;\n};\n"
      sc: 
        acgt: K,cv,av
        args: A,C,G,T,K,cv,av
        code: I 1
        dige: 442c4320522f
        gro: KnowTime
        nois: "#c"
      t: t
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/KnowTime/KnowTime
    taJe: 
      c: 
        el: 2
        s: "A.I.taJe = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    I.d&isC,$s || I.d&isJ,$s || return;\n    if (s.bb) {\n        if (I.d&isC,C.c ) {\n            C.c = {e=>C.c};\n        }\n        C.c.s = $s;\n    }\n    else {\n        if (I.d&isJ,C.c ) {\n            C.c = {s=>C.c};\n        }\n        C.c.e = $s;\n    }\n    C.y = {};\n    C.c.W = C.t;\n    return 1\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: faa4604847df
        gro: SlideEa
      t: taJe
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/SlideEa/SlideEa
    us: 
      c: 
        el: 2
        s: "A.I.us = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($D,@Me) = @M;\n    my $I = A.I;\n    my $E = C.c.e || return ();\n    push @M, 'NOGK' if @M == 1;\n    I.d&inDin,E.c.us,@M;\n};\n"
      sc: 
        acgt: D
        args: A,C,G,T,D
        code: I 1
        dige: 0cdebb6cbbf0
        gro: C
      t: us
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    wtfch: 
      c: 
        el: 2
        s: "A.I.wtfch = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($Jb,$Yb,@Me) = @M;\n    my $I = A.I;\n    my $wtf = {};\n    wtf.same = 1;\n    $wtf->{$_} = {} for qw'new diff gone';\n    \n    for (sort keys %$Jb) {\n        if (!exists $Yb->{$_}) {\n            wtf.new->{$_} = $Jb->{$_};\n            wtf.same = 0;\n        } \n        elsif ($Yb->{$_} ne $Jb->{$_}) {\n            wtf.diff->{$_} = $Jb->{$_};\n            wtf.same = 0;\n        }\n        else {\n            wtf.sami++;\n            wtf.still->{$_} = $Jb->{$_};\n        }\n        wtf.tot++;\n    }\n    for (grep { !exists $Jb->{$_} } sort keys %$Yb) {\n        wtf.gone->{$_} = $Yb->{$_};\n        wtf.same = 0;\n    }\n    $wtf;\n};\n"
      sc: 
        acgt: Jb,Yb
        args: A,C,G,T,Jb,Yb
        code: I 1
        dige: 75e75366ec49
        gro: Pha
        l: "#c diff J"
      t: wtfch
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Pha/Pha
    xot: 
      c: 
        el: 2
        s: "A.I.xot = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($s,$c,@Me) = @M;\n    my $I = A.I;\n    ref $c eq 'HASH' && ref $s eq 'HASH' ||\n        die \"Hash up\".wdump 3, [$s,$c];\n    while (my($k,$v) = each %$c) {\n        $s->{$k} = ref $v eq 'HASH' ?\n                    {%{$s->{$k}||{}}, %$v}\n        : ref $v ? \n            die \"Hash a ref v: \".wdump 2, $s\n        : $v;\n    }\n    return $s\n};\n"
      sc: 
        acgt: s,c
        args: A,C,G,T,s,c
        code: I 1
        dige: 5b5480545ba0
        gro: C
      t: xot
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    xoy: 
      c: 
        el: 2
        s: "A.I.xoy = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($s,$c,@Me) = @M;\n    my $I = A.I;\n    $c = I.d&xot,{},$c;\n    I.d&xot,$c,$s;\n    return $s;\n};\n"
      sc: 
        acgt: s,c
        args: A,C,G,T,s,c
        code: I 1
        dige: 3bee9aa63385
        gro: C
      t: xoy
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
  "0.12": 
    Ci: 
      c: 
        el: 2
        s: "A.I.Ci = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    !ref $s ? I.d&string,$s\n    :\n    ref $s eq 'ARRAY' ? I.d&array,$s\n    :\n    ref $s eq 'HASH' ? I.d&hash,$s\n    :\n    die \"mmtype:$s\";\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: I 12
        dige: 0ae2f062639c
        gro: SlideEa
        its: 1
      t: Ci
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/SlideEa/SlideEa
  "0.18": 
    reasonlock: 
      c: 
        el: 2
        s: "A.I.reasonlock = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    die\"reft\" if ref C.t;\n    if (A.J.name eq 'qq' || A.J.most.J eq A.J) {\n        C.c.W = C.t unless C.c || C.sc || C.y;\n    }\n    I.d&renc if !ref C.c;\n    \n    my $yy = C.y;\n    C.y = {} if ref C.y ne 'HASH';\n    I.d&givy,$yy;\n    \n    I.d&rensc if !ref C.sc;\n    \n    I.d&isC,$C && ref C.sc\n        || die \"reaso fail\".wdump [A.s,$C];\n    I.d&scyvle;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: I 18
        dige: 2498294940c1
        gro: SlideEa
        its: 1
      t: reasonlock
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/SlideEa/SlideEa
J: 
  "0.6211": 
    J_6211: 
      c: 
        el: 2
        s: "A.I.J_6211 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    return if exists C.c.pi;\n    \n    if (A.ztime < 9) {\n        if (A.jr&bol) {\n            sayre \"STOPPING \".ki($C) for 1..3;\n            # TODO stop\n        }\n        A.bangdesk.aft.unblocknine = A.jr&bol,9;\n    }\n    A.bangdesk.bang.bang_ts = sub {\n        A.jr&bang_ts,hitime\n    };\n    \n    C.c.pin = J.name;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: J 6211
        dige: 613d690d5559
        gk: J
        gro: Jiterbug
        nk: c
        v: cJ
      t: J_6211
      "y": 
        cv: '0.6211'
        cvt: 0.6211	C.t
        p: qq/Jiterbug/Jiterbug
  "0.6212": 
    J_6212: 
      c: 
        el: 2
        s: "A.I.J_6212 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    return unless exists C.c.pi;\n    \n    die'csnod' if $C ne J.C;\n    J.cv = (C.c.gp && C.c.gp.cv) || C.c.cv || 0.6;\n    my $path = C.sc.pi||die'nopi';\n    if (J.A.d > 9) {\n        $path = 'text';\n        warn \"J.name J.A.d limit to text\";\n    }\n    C.c.pin = \"pi/$path\";\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: J 6212
        dige: dd3968d99abd
        gk: J
        gro: Jiterbug
        nk: c
        v: cJ
      t: J_6212
      "y": 
        cv: '0.6212'
        cvt: 0.6212	C.t
        p: qq/Jiterbug/Jiterbug
  "0.622211": 
    J_622211: 
      c: 
        el: 2
        s: "A.I.J_622211 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    my $x = A.J.pix || J.mo.J.pix || return;\n    my @m = ref $x eq 'ARRAY' ? @$x : $x;\n    for my $x (@m) {\n        if (x.pi ? C.c.pi eq x.pi : \n            x.any ? 1 :\n            0) {\n            saybl \"matched: J.name ::: \".ki $x;\n            x.u &&\n            u x.u\n        }\n        # up!\n    }\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: J 622211
        dige: 030f397c269c
        gk: J
        gro: Foli
        nk: c
        v: cJ
      t: J_622211
      "y": 
        cv: '0.622211'
        cvt: 0.622211	C.t
        p: qq/Foli/Foli
  "0.631": 
    J_631: 
      c: 
        el: 2
        s: "A.I.J_631 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    A.coi = I.d&pha,$J,'ako';\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: J 631
        dige: 59b0dc2b2481
        gk: J
        gro: Jiterbug
        nk: c
        v: cJ
      t: J_631
      "y": 
        cv: '0.631'
        cvt: 0.631	C.t
        p: qq/Jiterbug/Jiterbug
  "0.632": 
    J_632: 
      c: 
        el: 2
        s: "A.I.J_632 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    return unless exists C.sc.pi;\n    \n    map { # telephone winch, propaganda (top-er levels receiving stuff)\n         J.A->{$_} = J.Jiter.A->{$_}\n         if J.Jiter && J.Jiter.A->{$_};\n    } qw'ljm ljmo';\n    \n    A.time = sub {\n        my($JJ,$q) = @_;\n        $J eq $JJ || die \"wtfJure  J.name   vs JJ.name\";\n        # wanna A.t&T,2,0 us to difference streams\n        # they could be xot maps or code to run\n        # then all over things \n    \n        if ($q == 2) {\n            my $sc = Rw Jamroot $J $C:J.C $y:J.oy if J.oy.at;\n    \n            A.ico = I.d&pha,$J,'ico';\n            A.ico.qui = 1;\n            I.d&as,A.ico,A.coi;\n            my $wtf = I.d&exactl,A.ico;\n    \n            if (wtf.last && !wtf.same) {\n                my $uf = join \"\\n\", map{\"$_: \".wdump(1,$wtf->{$_})}\n                    grep {keys %{$wtf->{$_}}} qw'new diff gone';\n                saybl \"T.alk  2222  $uf\";\n            }\n    \n            my $iM = 1 if sc.osci && J.mo.J.act;\n            my $stick = !J.mo.J.act && !$iM && # travel part\n                Rw eighthnot $J;\n            if (!$stick) { # am sticking\n                my ($o,$O) = (J.oy,J.Oy);\n                for (grep{$o->{$_} ne $O->{$_}} \n                    grep{!ref $o->{$_}} keys %$o) {\n                    $stick = 1; # unless y.? nonref changed, or wider spacer\n                    saybl \"J.name unstuck due to ychange: $_:  $o->{$_} ne $O->{$_}\";\n                }\n            }\n            # rhythm^\n            if ($stick) {\n                A.ico.wtf.same = 0;\n            }\n            elsif (wtf.same) {\n                T.iM = $iM if $iM;\n                return 0;\n            }\n    \n            # for the lift, osc should Jiter ne A.J and pd it\n            J.A.ljm = [];\n            J.A.ljmo = \"fr  J.name\";\n            return 1;\n        }\n    \n        warn \"T.alk other $q\";\n        if ($q == 8) {\n            # until J.most coord attention evaporates\n            # as in pulling on a list\n        }\n        A.ztime >= $q;\n    };\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: J 632
        dige: 1dd46aa913a3
        gk: J
        gro: Juperfi
        nk: c
        v: cJ
      t: J_632
      "y": 
        cv: '0.632'
        cvt: 0.632	C.t
        p: qq/Juperfi/Juperfi
  "0.66": 
    J_66: 
      c: 
        el: 2
        s: "A.I.J_66 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    my $M = [];\n    my $y = {o=>$M};\n    my $ar = {%{C.c}};\n    ar.s = '' if !exists ar.s;\n    ar.u = ar.s;\n    ar.pin = C.c.pin || die \"nopin\";\n    J.oy = $y;\n    \n    Rw ar.pin + $A $C $G $T $I $J $M $y;\n    \n    if (T.iM) {\n        J.Oy || die \"no JOy J.name\";\n        ref J.Oy.o eq 'HASH' || die \"J.name oYo not hash/picked up\";\n        ref J.Oy.o.M eq 'ARRAY' || die \"J.name oYoM not array\";\n        push @{J.oy.o}, @{J.Oy.o.M};\n    }\n    J.Oy = $y;\n    if (@$M) {\n        n z=>$y=>{}\n    }\n    Rw Jamroot $C $J $y if y.at;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: J 66
        dige: 8d6731d27957
        gk: J
        gro: Jiterbug
        nk: c
        v: cJ
      t: J_66
      "y": 
        cv: '0.66'
        cvt: 0.66	C.t
        p: qq/Jiterbug/Jiterbug
  "0.672": 
    J_672: 
      c: 
        el: 2
        s: "A.I.J_672 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    return unless A.ico && A.ico.wtf.same;\n    # first the superstilled\n    # anything T_D can arrange through time...\n    # wants to join G subtly vis T and so....\n    # should be no M in the first bit\n    # it is just pinpricks of consciousness keeping it alive, like mtime\n    # be nicer to do with an I that can T out of this whole change res patch\n    my $cut = @{A.ico.ord};\n    my @cc = @{A.coi.ord};\n    if (@cc > $cut) {\n        warn\"J.name entered stuff after 2!\".wdump [@cc, \n        '                 =============', @{A.ico.ord}];\n    }\n    I.d&bandon,A.coi;\n    if (my $ljm = J.A.ljm) {\n        for my $s (@$ljm) {\n            s.noR=1;\n            I.d&jamsc,$s;\n        }\n    }\n    sayre \"SKIP T.alk\";# if J.V || J.most.J.V;\n    T.whack = 1; # exit A.t&J\n    T.same = 1; # exit Mo, T.not but not, kind of unlet ztime6->7\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: J 672
        dige: 8a8f5c43f7ab
        gk: J
        gro: Juperfi
        nk: c
        v: cJ
      t: J_672
      "y": 
        cv: '0.672'
        cvt: 0.672	C.t
        p: qq/Juperfi/Juperfi
  "0.677": 
    J_677: 
      c: 
        el: 2
        s: "A.I.J_677 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    if (J.oy.ope) {\n        sayyl \"Leaving J.name open pha...\" if A.V&ope;\n        I.d&end,A.coi;\n        return;\n    }\n    A.coi.qui = 1;\n    my $wt = I.d&exactl,A.coi;\n    if (wt.same) {\n        if (++J.A.wch > 4) {\n            J.A.wch = 0;\n            # ^ rate to avoid v see J 632 eighthnot\n        }\n        else {\n           sayre \"SAME T.alk\" if A.V&SAME;\n           T.same = 1;\n        }\n    }\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: J 677
        dige: fe51018f11a7
        gk: J
        gro: Jiterbug
        nk: c
        v: cJ
      t: J_677
      "y": 
        cv: '0.677'
        cvt: 0.677	C.t
        p: qq/Jiterbug/Jiterbug
Mo: 
  "0.221": 
    yall_: 
      c: 
        el: 2
        s: "A.I.yall_ = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $y = C.y;\n    C.y = {thi => C.y} if !ref C.y;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo 221
        dige: 1dc839684266
        gro: Spaci
        its: 1
        nk: 'y'
        v: 'y'
      t: yall_
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Spaci/Spaci
  "0.223": 
    bal_: 
      c: 
        el: 2
        s: "A.I.bal_ = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $y = C.y;\n    my $bal = C.y.bal;\n    y.thi = @$bal;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo 223
        dige: d6a901a533ea
        gk: bal
        gro: bal
        nk: 'y'
        v: ybal
      t: bal_
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/bal/bal
  "0.23": 
    yin_: 
      c: 
        el: 2
        s: "A.I.yin_ = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $y = C.y;\n    # build wave plot manifold\n    # solar systems\n    y.cv ||= 0.3 if !defined y.cv && !defined y.in;\n    y.in = y.cv if defined y.cv;\n    y.in ||= 0.1;\n    y.out = y.in + y.space if defined y.space;\n    y.out ||= 0.9; # up to, then low things big\n    y.thi ||= 1;\n    if (my $mk = y.ert) {\n        $mk += y.ert while y.thi > $mk;\n        y.thi = $mk;\n    }\n    y.space = y.out - y.in;\n    y.space *= -1 unless y.space > 0;\n    y.aspace = y.space / y.thi;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo 23
        dige: b8b2317909f4
        gro: Spaci
        its: 1
        nk: 'y'
        v: 'y'
      t: yin_
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Spaci/Spaci
  "0.241": 
    muav_: 
      c: 
        el: 2
        s: "A.I.muav_ = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $y = C.y;\n    my $bal = C.y.bal;\n    my $total = sum(map { y.thy||1 } @$bal) || 1;\n    my $over = @$bal || 1;\n    y.u.muav = $over / $total;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo 241
        dige: a65c817c1fac
        gk: bal
        gro: bal
        nk: 'y'
        v: ybal
      t: muav_
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/bal/bal
  "0.26": 
    yarN_: 
      c: 
        el: 2
        s: "A.I.yarN_ = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $y = C.y;\n    # twist, lay into segment\n    ref $y eq 'HASH' || die \"Notash: \".wdump 2, $C;\n    !defined y.u || ref y.u eq 'HASH' || die \"Nou : y.u \".wdump 2, $y;\n    y.u.v = defined y.cv ? y.cv\n        : defined y.in ? y.in\n        : die \"no yiny\".ki$y;\n    y.thi || die \"Whythi\".ki$C;\n    die \":idify\" if $y ne C.y;\n    # y.u. shares av, y. separates\n    # difference pours out of y.bal via y.i in 32\n    my @lot = map {\n        my $C = eval { I.d&xot,{},$C };\n        C.y.i = $_-1;\n        $@ && die \"Tpp \".wdump 2, $C;\n        $C\n    } 1..y.thi;\n    if (@lot > 1) {\n        push @{A.mo.re->{0.29}||=[]}, map{[undef,$_]}@lot;\n        T.not = 1;\n    }\n    else {\n        my ($CC) = @lot;\n        ref $CC eq 'HASH' || die \"not one? $CC\";\n        %$C = %$CC;\n    }\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo 26
        dige: 8b60c744edc4
        gro: Spaci
        its: 1
        nk: 'y'
        v: 'y'
      t: yarN_
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Spaci/Spaci
  "0.3": 
    yinvout_: 
      c: 
        el: 2
        s: "A.I.yinvout_ = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $y = C.y;\n    y.mu = 1;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo 3
        dige: ea75f29040cf
        gro: Spaci
        its: 1
        nk: 'y'
        v: 'y'
      t: yinvout_
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Spaci/Spaci
  "0.301": 
    balin_: 
      c: 
        el: 2
        s: "A.I.balin_ = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $y = C.y;\n    my $bal = C.y.bal;\n    my $CC = $bal->[y.i];\n    if (ref $CC ne 'HASH') {\n        sayre \"Not ref: $CC A.J.name  C.t bal y.i :\";\n        return T.not = 1;\n    }\n    $CC ||= {};\n    I.d&xot,$C,$CC;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo 301
        dige: 8b609488ea6d
        gk: bal
        gro: bal
        nk: 'y'
        v: ybal
      t: balin_
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/bal/bal
  "0.337": 
    balou_: 
      c: 
        el: 2
        s: "A.I.balou_ = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $y = C.y;\n    my $bal = C.y.bal;\n    y.mu = y.thy if exists y.thy;\n    y.mu = y.mu * y.u.muav if y.u.muav;\n    #\n    say \"A.J.C.t  /  T.t ist y.mu  among y.u.muav\"\n        if A.J.V && y.u.muav != 1;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo 337
        dige: 4ade4215e92e
        gk: bal
        gro: bal
        nk: 'y'
        v: ybal
      t: balou_
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/bal/bal
  "0.34": 
    black_: 
      c: 
        el: 2
        s: "A.I.black_ = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $y = C.y;\n    my $was = y.u.v;\n    defined $was || die\"noAv\".ki$C;\n    # in:\n    y.cv = 0+sprintf '%.6f', y.u.v unless y.cvil && defined y.cv;\n    y.pcv = 0+sprintf '%.6f', y.i / C.y.thi;\n    # over:\n    my $in = y.aspace * y.mu;\n    y.u.v += $in;\n    # out: \n    y.ov = sprintf '%.6f', y.u.v;\n    y.spc = y.ov - y.cv;\n    #\n    sayyl \"Bend: C.t   $was += $in       y.aspace * y.mu       muav:y.u.muav\"\n        if A.J.V && y.u.muav && y.u.muav != 1;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo 34
        dige: 0f5f111f2197
        gro: Spaci
        its: 1
        nk: 'y'
        v: 'y'
      t: black_
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Spaci/Spaci
  "0.37": 
    ent_: 
      c: 
        el: 2
        s: "A.I.ent_ = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $y = C.y;\n    $y->{$_} = 0+sprintf('%.6f',$y->{$_}) for qw'cv ov aspace spc';\n    C.sc.yspc = y.spc if C.sc.nspc;\n    C.sc.ml = (C.y.over * 40).\"%\" if y.over;\n    if (!y.bal && y.aspace == 0.6 && y.in == 0.3) {\n        #saygr \"tidying the y of A.J.name C.t: $y \".ki $y;\n        #delete $y->{$_} for qw'aspace i in mu out ov pcv space spc thi u';\n        # unless any y.o, spacestuff around it\n    }\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo 37
        dige: 9aa3d27345c8
        gro: Spaci
        its: 1
        nk: 'y'
        v: 'y'
      t: ent_
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Spaci/Spaci
  "0.77": 
    pin_: 
      c: 
        el: 2
        s: "A.I.pin_ = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $y = C.y;\n    return if delete T.oke;\n    my $oJ = A.J;\n    my $J = C.y.o && C.y.o.J || $oJ;\n    my $ar = {};\n    ar.s = C.c.s if exists C.c.s;\n    \n    Rw jamsc + $J $oJ $C $sc:C.sc;\n    \n    # man is an insect is a flame\n    \n    sayyl \"Hamsc! A.talk: C.t C.y.cv     \".ki(1,{c=>C.c,sc=>C.sc})\n        if A.J.V;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo 77
        dige: 30369ff61d2a
        gro: Spaci
        its: 1
        nk: 'y'
        v: 'y'
      t: pin_
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Spaci/Spaci
Sev: 
  "0.4311": 
    tsnew_4311: 
      c: 
        el: 2
        s: "A.I.tsnew_4311 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $d = s.d;\n    my $o = s.o;\n    my $v = s.v;\n    my $talk = s.talk;\n    my $nk = s.nk;\n    my $gk = s.gk;\n    my $wk = s.wk;\n    my $c = C.c;\n    my $Y = C.c.Y;\n    my $J = C.c.J;\n    my $V = C.c.V;\n    my $k = C.y.k;\n    my $at = C.y.at;\n    my $ta = C.y.ta;\n    my $lv = C.y.lv;\n    my $vl = C.y.vl;\n        $lv->{op}->{t} = 1;\n};\n"
      sc: 
        Ifs: 
          Td: 
            atar: 
              - nk
              - gk
              - wk
            onpa: 
              - T
              - d
            path: 
              - t
              - s
              - new
        Td: t/s/new
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Sev 4311
        dige: 45beb479e8e9
        gk: 'Y'
        gro: Ydo
        nk: c
        rg: J,V,yk,yat,yta,ylv,yvl
        sr: d,o,v,talk,nk,gk,wk
        v: cY
      t: tsnew_4311
      "y": 
        cv: '0.4311'
        cvt: 0.4311	C.t
        p: qq/Ydo/Ydo
  "0.4312": 
    ysnew_4312: 
      c: 
        el: 2
        s: "A.I.ysnew_4312 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $d = s.d;\n    my $o = s.o;\n    my $v = s.v;\n    my $talk = s.talk;\n    my $nk = s.nk;\n    my $gk = s.gk;\n    my $wk = s.wk;\n    my $c = C.c;\n    my $Y = C.c.Y;\n    my $J = C.c.J;\n    my $V = C.c.V;\n    my $k = C.y.k;\n    my $at = C.y.at;\n    my $ta = C.y.ta;\n    my $lv = C.y.lv;\n    my $vl = C.y.vl;\n        $lv->{op}->{y} = 1;\n};\n"
      sc: 
        Ifs: 
          Td: 
            atar: 
              - nk
              - gk
              - wk
            onpa: 
              - T
              - d
            path: 
              - 'y'
              - s
              - new
        Td: y/s/new
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Sev 4312
        dige: b11ce7cbcd47
        gk: 'Y'
        gro: Ydo
        nk: c
        rg: J,V,yk,yat,yta,ylv,yvl
        sr: d,o,v,talk,nk,gk,wk
        v: cY
      t: ysnew_4312
      "y": 
        cv: '0.4312'
        cvt: 0.4312	C.t
        p: qq/Ydo/Ydo
  "0.4321": 
    cgone_4321: 
      c: 
        el: 2
        s: "A.I.cgone_4321 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $d = s.d;\n    my $o = s.o;\n    my $v = s.v;\n    my $talk = s.talk;\n    my $nk = s.nk;\n    my $gk = s.gk;\n    my $wk = s.wk;\n    my $c = C.c;\n    my $Y = C.c.Y;\n    my $J = C.c.J;\n    my $V = C.c.V;\n    my $k = C.y.k;\n    my $at = C.y.at;\n    my $ta = C.y.ta;\n    my $lv = C.y.lv;\n    my $vl = C.y.vl;\n        sayre \"how delete a c $gk\";\n        $lv->{op}->{c}->{$gk} = 9;\n};\n"
      sc: 
        Ifs: 
          Td: 
            atar: 
              - nk
              - gk
              - wk
            onpa: 
              - T
              - d
            path: 
              - c
              - "*"
              - gone
        Td: c/*/gone
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Sev 4321
        dige: 73fd3a261366
        gk: 'Y'
        gro: Ydo
        nk: c
        rg: J,V,yk,yat,yta,ylv,yvl
        sr: d,o,v,talk,nk,gk,wk
        v: cY
      t: cgone_4321
      "y": 
        cv: '0.4321'
        cvt: 0.4321	C.t
        p: qq/Ydo/Ydo
    cnew_4321: 
      c: 
        el: 2
        s: "A.I.cnew_4321 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $d = s.d;\n    my $o = s.o;\n    my $v = s.v;\n    my $talk = s.talk;\n    my $nk = s.nk;\n    my $gk = s.gk;\n    my $wk = s.wk;\n    my $c = C.c;\n    my $Y = C.c.Y;\n    my $J = C.c.J;\n    my $V = C.c.V;\n    my $k = C.y.k;\n    my $at = C.y.at;\n    my $ta = C.y.ta;\n    my $lv = C.y.lv;\n    my $vl = C.y.vl;\n        sayre \"how inject a c $gk\" if $vl;\n        $lv->{op}->{c}->{$gk} = 9;\n};\n"
      sc: 
        Ifs: 
          Td: 
            atar: 
              - nk
              - gk
              - wk
            onpa: 
              - T
              - d
            path: 
              - c
              - "*"
              - new
        Td: c/*/new
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Sev 4321
        dige: 94e3a3249bf6
        gk: 'Y'
        gro: Ydo
        nk: c
        rg: J,V,yk,yat,yta,ylv,yvl
        sr: d,o,v,talk,nk,gk,wk
        v: cY
      t: cnew_4321
      "y": 
        cv: '0.4321'
        cvt: 0.4321	C.t
        p: qq/Ydo/Ydo
  "0.4323": 
    csdiff_4323: 
      c: 
        el: 2
        s: "A.I.csdiff_4323 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $d = s.d;\n    my $o = s.o;\n    my $v = s.v;\n    my $talk = s.talk;\n    my $nk = s.nk;\n    my $gk = s.gk;\n    my $wk = s.wk;\n    my $c = C.c;\n    my $Y = C.c.Y;\n    my $J = C.c.J;\n    my $V = C.c.V;\n    my $k = C.y.k;\n    my $at = C.y.at;\n    my $ta = C.y.ta;\n    my $lv = C.y.lv;\n    my $vl = C.y.vl;\n        $lv->{pur}->{c}->{$gk} = 1;\n        $lv->{pur}->{c}->{ht} = 1 if $at->{c}->{ht};\n};\n"
      sc: 
        Ifs: 
          Td: 
            atar: 
              - nk
              - gk
              - wk
            onpa: 
              - T
              - d
            path: 
              - c
              - s
              - diff
        Td: c/s/diff
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Sev 4323
        dige: 0dbc0fafbfec
        gk: 'Y'
        gro: Ydo
        nk: c
        rg: J,V,yk,yat,yta,ylv,yvl
        sr: d,o,v,talk,nk,gk,wk
        v: cY
      t: csdiff_4323
      "y": 
        cv: '0.4323'
        cvt: 0.4323	C.t
        p: qq/Ydo/Ydo
  "0.4324": 
    cdiff_4324: 
      c: 
        el: 2
        s: "A.I.cdiff_4324 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $d = s.d;\n    my $o = s.o;\n    my $v = s.v;\n    my $talk = s.talk;\n    my $nk = s.nk;\n    my $gk = s.gk;\n    my $wk = s.wk;\n    my $c = C.c;\n    my $Y = C.c.Y;\n    my $J = C.c.J;\n    my $V = C.c.V;\n    my $k = C.y.k;\n    my $at = C.y.at;\n    my $ta = C.y.ta;\n    my $lv = C.y.lv;\n    my $vl = C.y.vl;\n        sayre \"how to c dif $gk\".slim(30,$v).\" <--- \".slim(30,$o);\n        $lv->{op}->{c}->{$gk} = 9;\n};\n"
      sc: 
        Ifs: 
          Td: 
            atar: 
              - nk
              - gk
              - wk
            onpa: 
              - T
              - d
            path: 
              - c
              - "*"
              - diff
        Td: c/*/diff
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Sev 4324
        dige: cc3740350322
        gk: 'Y'
        gro: Ydo
        nk: c
        rg: J,V,yk,yat,yta,ylv,yvl
        sr: d,o,v,talk,nk,gk,wk
        v: cY
      t: cdiff_4324
      "y": 
        cv: '0.4324'
        cvt: 0.4324	C.t
        p: qq/Ydo/Ydo
    cstill_4324: 
      c: 
        el: 2
        s: "A.I.cstill_4324 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $d = s.d;\n    my $o = s.o;\n    my $v = s.v;\n    my $talk = s.talk;\n    my $nk = s.nk;\n    my $gk = s.gk;\n    my $wk = s.wk;\n    my $c = C.c;\n    my $Y = C.c.Y;\n    my $J = C.c.J;\n    my $V = C.c.V;\n    my $k = C.y.k;\n    my $at = C.y.at;\n    my $ta = C.y.ta;\n    my $lv = C.y.lv;\n    my $vl = C.y.vl;\n        # ya\n};\n"
      sc: 
        Ifs: 
          Td: 
            atar: 
              - nk
              - gk
              - wk
            onpa: 
              - T
              - d
            path: 
              - c
              - "*"
              - still
        Td: c/*/still
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Sev 4324
        dige: f0385bf11ed7
        gk: 'Y'
        gro: Ydo
        nk: c
        rg: J,V,yk,yat,yta,ylv,yvl
        sr: d,o,v,talk,nk,gk,wk
        v: cY
      t: cstill_4324
      "y": 
        cv: '0.4324'
        cvt: 0.4324	C.t
        p: qq/Ydo/Ydo
  "0.4331": 
    scnew_4331: 
      c: 
        el: 2
        s: "A.I.scnew_4331 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $d = s.d;\n    my $o = s.o;\n    my $v = s.v;\n    my $talk = s.talk;\n    my $nk = s.nk;\n    my $gk = s.gk;\n    my $wk = s.wk;\n    my $c = C.c;\n    my $Y = C.c.Y;\n    my $J = C.c.J;\n    my $V = C.c.V;\n    my $k = C.y.k;\n    my $at = C.y.at;\n    my $ta = C.y.ta;\n    my $lv = C.y.lv;\n    my $vl = C.y.vl;\n        $lv->{pur}->{sc}->{$gk} = 1;\n};\n"
      sc: 
        Ifs: 
          Td: 
            atar: 
              - nk
              - gk
              - wk
            onpa: 
              - T
              - d
            path: 
              - sc
              - "*"
              - new
        Td: sc/*/new
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Sev 4331
        dige: ed6a3580064b
        gk: 'Y'
        gro: Ydo
        nk: c
        rg: J,V,yk,yat,yta,ylv,yvl
        sr: d,o,v,talk,nk,gk,wk
        v: cY
      t: scnew_4331
      "y": 
        cv: '0.4331'
        cvt: 0.4331	C.t
        p: qq/Ydo/Ydo
  "0.4332": 
    scgone_4332: 
      c: 
        el: 2
        s: "A.I.scgone_4332 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $d = s.d;\n    my $o = s.o;\n    my $v = s.v;\n    my $talk = s.talk;\n    my $nk = s.nk;\n    my $gk = s.gk;\n    my $wk = s.wk;\n    my $c = C.c;\n    my $Y = C.c.Y;\n    my $J = C.c.J;\n    my $V = C.c.V;\n    my $k = C.y.k;\n    my $at = C.y.at;\n    my $ta = C.y.ta;\n    my $lv = C.y.lv;\n    my $vl = C.y.vl;\n        die \"how delete a sc $gk\";\n        $lv->{op}->{sc}->{$gk} = 9;\n};\n"
      sc: 
        Ifs: 
          Td: 
            atar: 
              - nk
              - gk
              - wk
            onpa: 
              - T
              - d
            path: 
              - sc
              - "*"
              - gone
        Td: sc/*/gone
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Sev 4332
        dige: a50837aa4b0a
        gk: 'Y'
        gro: Ydo
        nk: c
        rg: J,V,yk,yat,yta,ylv,yvl
        sr: d,o,v,talk,nk,gk,wk
        v: cY
      t: scgone_4332
      "y": 
        cv: '0.4332'
        cvt: 0.4332	C.t
        p: qq/Ydo/Ydo
  "0.4333": 
    scdiff_4333: 
      c: 
        el: 2
        s: "A.I.scdiff_4333 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $d = s.d;\n    my $o = s.o;\n    my $v = s.v;\n    my $talk = s.talk;\n    my $nk = s.nk;\n    my $gk = s.gk;\n    my $wk = s.wk;\n    my $c = C.c;\n    my $Y = C.c.Y;\n    my $J = C.c.J;\n    my $V = C.c.V;\n    my $k = C.y.k;\n    my $at = C.y.at;\n    my $ta = C.y.ta;\n    my $lv = C.y.lv;\n    my $vl = C.y.vl;\n        $lv->{pur}->{sc}->{$gk} = 1;\n};\n"
      sc: 
        Ifs: 
          Td: 
            atar: 
              - nk
              - gk
              - wk
            onpa: 
              - T
              - d
            path: 
              - sc
              - "*"
              - diff
        Td: sc/*/diff
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Sev 4333
        dige: f99cd21f7ef8
        gk: 'Y'
        gro: Ydo
        nk: c
        rg: J,V,yk,yat,yta,ylv,yvl
        sr: d,o,v,talk,nk,gk,wk
        v: cY
      t: scdiff_4333
      "y": 
        cv: '0.4333'
        cvt: 0.4333	C.t
        p: qq/Ydo/Ydo
  "0.4334": 
    scstill_4334: 
      c: 
        el: 2
        s: "A.I.scstill_4334 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $d = s.d;\n    my $o = s.o;\n    my $v = s.v;\n    my $talk = s.talk;\n    my $nk = s.nk;\n    my $gk = s.gk;\n    my $wk = s.wk;\n    my $c = C.c;\n    my $Y = C.c.Y;\n    my $J = C.c.J;\n    my $V = C.c.V;\n    my $k = C.y.k;\n    my $at = C.y.at;\n    my $ta = C.y.ta;\n    my $lv = C.y.lv;\n    my $vl = C.y.vl;\n        # ya\n};\n"
      sc: 
        Ifs: 
          Td: 
            atar: 
              - nk
              - gk
              - wk
            onpa: 
              - T
              - d
            path: 
              - sc
              - "*"
              - still
        Td: sc/*/still
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Sev 4334
        dige: 17b5350c4358
        gk: 'Y'
        gro: Ydo
        nk: c
        rg: J,V,yk,yat,yta,ylv,yvl
        sr: d,o,v,talk,nk,gk,wk
        v: cY
      t: scstill_4334
      "y": 
        cv: '0.4334'
        cvt: 0.4334	C.t
        p: qq/Ydo/Ydo
em: 
  "0.21": 
    em_21: 
      c: 
        el: 2
        s: "A.I.em_21 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $em = C.c.em;\n    em.lines || die \"Not lines\";\n    em.hitime = hitime();\n    em.is.W = C.sc.Wid || A.J.id;\n    em.is.M = C.sc.Mid || A.J.name;\n    em.id = em.is.W.'.'.(0+em.i);\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: em 21
        dige: c304cc4fd1ff
        gk: em
        gro: Meta
        nk: c
        v: cem
      t: em_21
      "y": 
        cv: '0.21'
        cvt: 0.21	C.t
        p: qq/Meta/Meta
  "0.3": 
    jslines_3: 
      c: 
        el: 2
        s: "A.I.jslines_3 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $sc = C.sc;\n    my $jslines = C.sc.jslines;\n    my $J = C.c.J;\n    my $em = C.c.em;\n    Rw EmJSlines $A $J $em $C $T;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        cg: J,em
        code: em 3
        dige: 41cef4532459
        gk: jslines
        gro: Meta
        nk: sc
        nov: 1
        nv: scjslines
        rg: J,em
        v: scjslines
      t: jslines_3
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Meta/Meta
    ressur_3: 
      c: 
        el: 2
        s: "A.I.ressur_3 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $sc = C.sc;\n    my $ressur = C.sc.ressur;\n    my $J = C.c.J;\n    my $em = C.c.em;\n    saybl \"Ressurrecting $ressur ...\";\n    die \"zomp $ressur\" if $ressur =~ /\\W/;\n    die \"bno JSlines\" unless -e \"life/W/$ressur\";\n    `cd life; ln -s ../W/$ressur J/em.id\\.c`;\n    my $catch = sjson {y=>J=>id=>em.id};\n    I.d&writef,\"life/J\\.s\",$catch,1;\n    T.whack = 1; # out of em\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        cg: J,em
        code: em 3
        dige: bc77ff177d9a
        gk: ressur
        gro: Meta
        nk: sc
        nov: 1
        nv: scressur
        rg: J,em
        v: scressur
      t: ressur_3
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Meta/Meta
    ux_3: 
      c: 
        el: 2
        s: "A.I.ux_3 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $sc = C.sc;\n    my $ux = C.sc.ux;\n    my $em = C.c.em;\n    my $J = G.oin;\n    my $M = ['','',{W=>J.id},{z=>em.lines}];\n    em.lines = [sjson($M)];\n    C.sc.Wc = 1;\n    n GW\n    # ^ router, W with an .e v\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        cg: em
        code: em 3
        dige: ff8f2dae6153
        gk: ux
        gro: Meta
        nk: sc
        nov: 1
        nv: scux
        rg: em
        v: scux
      t: ux_3
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Meta/Meta
  "0.446": 
    Wc_446: 
      c: 
        el: 2
        s: "A.I.Wc_446 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $sc = C.sc;\n    my $Wc = C.sc.Wc;\n    my $J = C.c.J;\n    my $em = C.c.em;\n    saybl join\"\\n\",\"Downing em.is.M: em.is.W: \",\n        map{!ref $_ ? $_ : wdump 5,$_} @{em.lines}\n        if A.V&W;\n    I.d&writef,\"life/W/em.is.W\\.c\",em.lines,em.i;\n    \n    # is coming soon: (only space or)\n    C.c.as = !C.c.os;\n    C.c.As = C.c.as;\n    C.sc.meta = 1;\n    C.sc.speak = 1 if C.c.as;\n    C.sc.takeover = 1 if C.c.As;\n    saybl \"WHITESPACE S em.is.M\" if C.c.os;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        cg: J,em
        code: em 446
        dige: 07197e436c17
        gk: Wc
        gro: Wuts
        nk: sc
        nov: 1
        nv: scWc
        rg: J,em
        v: scWc
      t: Wc_446
      "y": 
        cv: '0.446'
        cvt: 0.446	C.t
        p: qq/Wuts/Wuts
  "0.47": 
    meta_47: 
      c: 
        el: 2
        s: "A.I.meta_47 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $sc = C.sc;\n    my $meta = C.sc.meta;\n    my $em = C.c.em;\n    G.Wh->{em.is.W} && return;\n    G.Wh->{em.is.W} = A.J;\n    my $me = I.d&hup,$em;\n    delete me.lines;\n    $me = sjson $me;\n    I.d&writef,\"life/W/em.is.W\\.i\",$me;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        cg: em
        code: em 47
        dige: 30bf9edceb58
        gk: meta
        gro: Wuts
        nk: sc
        nov: 1
        nv: scmeta
        rg: em
        v: scmeta
      t: meta_47
      "y": 
        cv: '0.47'
        cvt: 0.47	C.t
        p: qq/Wuts/Wuts
  "0.48": 
    speak_48: 
      c: 
        el: 2
        s: "A.I.speak_48 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $sc = C.sc;\n    my $speak = C.sc.speak;\n    my $em = C.c.em;\n    return if G.Jlone;\n    \n    I.d&writef,\"life/J/em.id\\.c\",em.lines;\n    \n    my $catch = sjson {y=>J=>id=>em.id};\n    I.d&writef,\"life/J\\.s\",$catch,1;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        cg: em
        code: em 48
        dige: 0d76e3292b22
        gk: speak
        gro: Wuts
        nk: sc
        nov: 1
        nv: scspeak
        rg: em
        v: scspeak
      t: speak_48
      "y": 
        cv: '0.48'
        cvt: 0.48	C.t
        p: qq/Wuts/Wuts
  "0.49": 
    takeover_49: 
      c: 
        el: 2
        s: "A.I.takeover_49 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $sc = C.sc;\n    my $takeover = C.sc.takeover;\n    my $em = C.c.em;\n    -l $_ && `unlink $_` for \"life/W/em.is.M\";\n    `cd life/W; ln -s em.is.W\\.c em.is.M`;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        cg: em
        code: em 49
        dige: 9e3b4735db14
        gk: takeover
        gro: Wuts
        nk: sc
        nov: 1
        nv: sctakeover
        rg: em
        v: sctakeover
      t: takeover_49
      "y": 
        cv: '0.49'
        cvt: 0.49	C.t
        p: qq/Wuts/Wuts
oJ: 
  "0.61": 
    J_61: 
      c: 
        el: 2
        s: "A.I.J_61 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n        $T->{alk} = \"$A->{talk}  TT  $A->{ztime}\";\n        $A->{time}->($J, 6) || return do {\n            say \"SKive! $T->{alk}\" if $A->{V}->(\"skive\");\n            $T->{nose} = 1;\n        };\n        sayyl \"J6 ! $T->{alk}\" unless !$A->{V}->(\"sixes\") || $C->{sc}->{pi} || $T->{alk} =~ /^all/;\n        $A->{Subtle}->{J} = 1;\n        $A->{t}->(\"J\",9,1);\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: oJ 61
        dige: 7184afd776e4
        gk: J
        gro: Jumps
        nk: c
        v: cJ
      t: J_61
      "y": 
        cv: '0.61'
        cvt: 0.61	C.t
        p: qq/Jumps/Jumps
  "0.71": 
    J_71: 
      c: 
        el: 2
        s: "A.I.J_71 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n        $T->{nose} && return $A->{V}->(\"nose\") && sayre \"nose $T->{alk}\";\n        if (!$J->{A}->{II}->{Sev}) {\n            $G->{w}->(\"collaspII\", {A => $_, m => [\"for\",\"{J=>$J\",\"G=>$G}\"]}, $G);\n            say \"$J->{name} \".($J->{A}->{II}->{Sev} ? \"quietly Sevs\" : 'Yesuis???????????????');\n        }\n        $J->{most}->{eo} = 'Sev' if $J->{A}->{II}->{Sev};\n        say \"oJ77 77 $T->{alk}     -> $J->{most}->{eo}\"\n            unless $J->{most}->{eo} ne 'Sev' || !$A->{V}->(\"sevens\") || $J->{yt}->{quiet} || $C->{sc}->{pi} || $T->{alk} =~ /^all/;\n        $G->{w}->(\"$J->{most}->{eo}\", {J => $J, A => $A}, $G);\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: oJ 71
        dige: b62c5af25c01
        gk: J
        gro: Jumps
        nk: c
        v: cJ
      t: J_71
      "y": 
        cv: '0.71'
        cvt: 0.71	C.t
        p: qq/Jumps/Jumps
