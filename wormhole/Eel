--- 
I: 
  "0.1": 
    ex: 
      c: 
        el: 1
        s: "A.I.ex = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($i,$K,$cv,$av) = @M;\n    my $I = A.I;\n    # was Rw SNat $A $C $G $T $I $i $K $cv;\n    # baseism\n    my $c = 0+(\"0.\".$cv);\n    my $Av = $av || A.cv;\n    my $sp = $av ? \" Flav $av (no A.cv)\" : \"\";\n    \n    my $talk = \"A.talk: $K$sp $Av > $c --- C.t \";\n    \n    my $aim = {$K=>1};\n    if ($aim->{A.am}) {\n        $aim->{$_} = 1 for @{A.Isl||[]};\n        aim.I = 1;\n    }\n    \n    my $yv = {};\n    # make K/cv/t -> cv/K/t\n    for my $k (sort keys %$i) {\n        my $ii = $i->{$k};\n    \n        next if $k eq 'Ii';\n        next if $k eq 'ooI';\n        ref $ii eq 'HASH' || die \"weird $k=$ii\";\n    \n        for my $vc (sort keys %$ii) {\n            my $iii = $ii->{$vc};\n            die'$k !0<$vc<1' unless $vc > 0 && $vc < 1;\n            $yv->{$vc}->{$k} = $iii;\n        }\n    }\n    \n    # do stuff\n    my $vb; # in fractions\n    my $wasSubtle;\n    for my $vc (sort keys %$yv) {\n        my $is = $yv->{$vc};\n        my $s = {};\n        my $x = {};\n        my $xrd = [];\n    \n        next if $vc <= $Av && $vc != $c;\n        next if $vc > $c;\n    \n        if (0 && $K eq 'Sev') {\n            saybl \"We $K - $vb -> $vc  \".join', ',\n                map{\"$_: \".@{A.mo.re->{$_}}} sort keys %{A.mo.re||{}};\n        }\n        if ($wasSubtle) {\n            undef $wasSubtle;\n            $vb = $vc;\n        }\n        if ($vb && $vc > $vb && (\n            @{A.N} || @{A.mo.re->{$vb}||[]}\n            )) {\n            # sincing, wide order\n            # various others want to be around for only some of the process...\n            sayre \"$vb -> $vc  bump, \". @{A.N} if A.J.V;\n            T.Z->{$vb} = 1;\n            A.cv = $vb; # so we dont wind up to 6 on the way out of t\n            return T.not = 1;\n        }\n        for my $k (sort keys %$is) {\n            my $iii = $is->{$k};\n    \n            next unless $aim->{$k} || (aim.I && A.Iso->{$k});\n    \n            for my $ik (sort keys %$iii) {\n                my $D = $iii->{$ik};\n    \n                if (my $nk = D.sc.nk) {\n                    my $C = I.nF.C;\n                    next if !exists $C->{$nk};\n                    if (my $gk = D.sc.gk) {\n                        next if !exists $C->{$nk}->{$gk};\n                    }\n                }\n                my $act;\n                my $dont;\n                if (D.sc.acgt && D.sc.act) {\n                    $act = 1;\n                    # acgtsubs can be defined at any cv\n                    # run themselves if act\n                    # usu. one receiver (Ci) and the rest scheme\n                    die \"D.t .act gets... D.sc.act\" if D.sc.act ne '1';\n                    $dont = 1 if exists A.I->{D.t};\n                }\n    \n                # way or acgt-setuping-way\n                unless ($dont) {\n                    my $paw = join\"_\",'',$k,$vc,D.t;\n                    $paw =~ s/\\W//g;\n                    Rw $paw $A $C $G $T $__D:D;\n                }\n                # most tiny ticks\n                # this ind is all flywheel\n                # it's a kind of unity that wants to be a block of code like this\n                # and c\n                my @is = A.s;\n                #\n                @is = I.d&scIfs,D.sc.Ifs if D.sc.Ifs;\n                say \"Scuf\" if @is && D.sc.Ifs;\n                #\n                @is || next;\n    \n                if ($act) {\n                    push @$xrd, [$k,$ik];\n                    my $Ds = $x->{$k}->{$ik} ||= {};\n                    Ds.D = $D;\n                    Ds.is = \\@is;\n                    D.sc.its = @is;\n                    # pin down poles\n                    #I.cv = $vc;\n                    #I.vb = $vb;\n                    # draw curvles as spirals done\n                }\n    \n                # TreeD\n                $s->{$k}->{$vc}->{$ik} = $D;\n            }\n        }\n        #c suble\n        my $se = Rw TreeD $s $scby=gro\n            if A.J.V > 1 && keys %$s;\n        $c == 0.1 ? saygr $se : say $se if $se;\n    \n        my ($Subtle,$nonSubtle);\n        for my $kik (@$xrd) {\n            my ($k,$ik) = @$kik;\n            A.Subtle && A.Subtle->{$k} ? $Subtle++ : $nonSubtle++;\n            my $Ds = $x->{$k}->{$ik};\n            my $D = Ds.D;\n            for my $s (@{Ds.is}) {\n                D.sc.acgt eq 's'||die \"nonacgts\".wdump $D;\n                exists A.I->{D.t}||die \"acgtI D.t not up: \".wdump A.I;\n    \n                I.d&D.t,$s;\n    \n                I.acted and I.d&acted,$s;\n    \n                if (my $ut = T.ut) {\n                    if (ut.matchTd) {\n                        my $d = s.d || die \"confuse\";\n                        d.od.s.T.q->{d.e.k} ||= $d;\n                        d.od.s.T.m->{d.e.k} ||= $d\n                            unless delete(T.noTd);\n                    }\n                    else { die\"utrowhat \".wdump 2, $ut }\n                }\n    \n                # schools of many fish (not upcv if !@is)\n                $vb ||= $vc if D.sc.v;\n    \n                last if T.not || T.whack;\n            }\n            delete T.ut;\n            last if T.not || T.whack;\n        }\n    \n        if ($Subtle && !$nonSubtle) {\n            $wasSubtle = 1;\n        }\n    \n        return if T.not;  # will &z, oseve\n        return if delete T.whack;\n    }\n};\n"
      sc: 
        acgt: i,K,cv,av
        args: A,C,G,T,i,K,cv,av
        code: I 1
        dige: cc9d84756646
        gro: KowTime
        nois: "#c"
      t: ex
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/KowTime/KowTime
