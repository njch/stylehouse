--- 
I: 
  "0.1": 
    Cngk: 
      c: 
        el: 1
        s: "A.I.Cngk = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($D,@Me) = @M;\n    my $I = A.I;\n    ref $A || die \"nmonref A!\";\n    aft {\n        $@ .= \"\\n\\nWas: \".ki$D if $@;\n    };\n    die 'nk no gk' if exists D.c.nk && !exists D.c.gk;\n    return 1 if D.c.any;\n    if (D.c.nk && exists $C->{D.c.nk} && exists $C->{D.c.nk}->{D.c.gk}) {\n        my $v = [$C->{D.c.nk}->{D.c.gk}];\n        delete $C->{D.c.nk}->{D.c.gk} if D.c.mdel;\n        return $v;\n    }\n    die \"noNnk\".wdump $D unless exists D.c.nk;\n    0;\n};\n"
      sc: 
        acgt: D
        args: A,C,G,T,D
        code: I 1
        dige: d34d293f0760
        gro: C
      t: Cngk
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    array: 
      c: 
        el: 1
        s: "A.I.array = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    return I.d&fourreal,$s if @$s != 1 && !ref $s->[0] || $s->[0] =~ /^\\w+$/;\n    return I.d&fourstring,$s if @$s == 1 && !ref $s->[0];\n    # should stick In in first and M it? \n    # kind of motion that wants to be unsure in the wild\n    unshift @{A.N}, @$s;\n    T.not = 1;\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 2e38d4764050
        gro: SlideEa
      t: array
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/SlideEa/SlideEa
    c: 
      c: 
        el: 1
        s: "A.I.c = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($D,@Me) = @M;\n    my $I = A.I;\n    die'nofA' if !I.nF.A;\n    $D = I.d&interpD,@M if !ref $D;\n    for (qw'code if of ref') {\n        exists C.c->{$_} && die \"COT I\".ki $C\n    }\n    my $v = I.d&Cngk,$D;\n    return () unless $v;\n    A.note->{D.c.nk}->{D.c.gk} = $v if A.note;\n    die 'mulitAn' if @$v > 1;\n    if (D.c.as eq 'list') {\n        return ref $v eq 'ARRAY' ? @$v : die'Cngk not array';\n    }\n    return 1;\n};\n"
      sc: 
        acgt: D
        args: A,C,G,T,D
        code: I 1
        dige: 58c6c34b9569
        gro: C
      t: c
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    fourreal: 
      c: 
        el: 1
        s: "A.I.fourreal = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    (C.t, C.y) = @$s;\n    C.c  = $s->[2] if exists $s->[2];\n    C.sc = $s->[3] if exists $s->[3];\n    die'@>4'.wdump $s if @$s > 4;\n    die\"C.t from \".wdump $s if ref C.t; # dives\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 87baea0c56c8
        gro: C
      t: fourreal
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    fourstring: 
      c: 
        el: 1
        s: "A.I.fourstring = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    I.d&MZu,$1 if $s =~ /^\\s*#?\\s*MZ (.+)$/;\n    if ($s =~ /^\\s*(#.*)$/) {\n       T.not = 1;\n       T.com = $1;\n    }\n    elsif ($s eq '') {\n       T.not = T.space = 1;\n    }\n    else {\n       my $ci = $s;\n       for my $nk (qw't y c sc') {\n           if ($ci =~ s/^(\\S+) *//) { # some t are types of space\n               my $v = $1;\n               $v = I.d&peel,$v if $nk ne 't' && $v =~ I.peels;\n               # << consumes more lines into $nk, then ...\n               $v = '' if $v =~ /^(''|\"\")$/;\n               $C->{$nk} = $v;\n           }\n       }\n    }\n    saybl \"4string: \".ki $C;\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 9406b8c7ea6e
        gro: C
      t: fourstring
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    hash: 
      c: 
        el: 1
        s: "A.I.hash = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    return %$C = %$s if exists s.t && s.y && s.c;\n    # some talking to self - how to C over exactly\n    # the object could be live\n    I.d&servehash,$s;\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: d4c8ca29125b
        gro: SlideEa
      t: hash
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/SlideEa/SlideEa
    interpD: 
      c: 
        el: 1
        s: "A.I.interpD = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($nk,$gk,@Me) = @M;\n    my $I = A.I;\n    return $nk if ref $nk;\n    my $D = {};\n    D.c.as = 'list' if $nk =~ s/^_//;\n        while ($gk =~ s/^%(.+?):(.+?)(?=%|$)//g) {\n            D.c->{$1} = $2;\n            pop @M if @M == 2;\n        }\n        if (@M == 1) { # or from t,,,\n            D.c.nk ||= 'c';\n            D.c.gk ||= $nk;\n        }\n        elsif (@M == 2) {\n            D.c.nk = $nk;\n            D.c.gk = $gk;\n        }\n    $D\n};\n"
      sc: 
        acgt: nk,gk
        args: A,C,G,T,nk,gk
        code: I 1
        dige: 296a30efd23e
        gro: C
      t: interpD
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    peel: 
      c: 
        el: 1
        s: "A.I.peel = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    $s =~ s/^%// || \n        $s =~ s/^{// && $s =~ s/}$//\n        || die \"unpealable $s\";\n    my $c;\n    for (split ',', $s) {\n        my ($k, $v) = split ':', $_, 2;\n        $v = 1 if !defined $v;\n        $c->{$k} = $v;\n    }\n    $c||{}\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 86d02e052c88
        gro: C
      t: peel
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    peels: 
      c: 
        el: 1
        s: "A.I.peels = (sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    qr/^[\\{\\%]/;\n})->($A,$C,$G,$T);\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 2cef197e1b39
        gro: C
        subpeel: 1
      t: peels
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    renc: 
      c: 
        el: 1
        s: "A.I.renc = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    C.c = C.c =~ I.peels ? I.d&peel,C.c\n      : {s => C.c};\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: eae926764058
        gro: SlideEa
      t: renc
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/SlideEa/SlideEa
    rensc: 
      c: 
        el: 1
        s: "A.I.rensc = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    C.sc = C.sc eq '' ? {}\n        : C.sc =~ I.peels\n        ? I.d&peel,C.sc\n        : die \"C sc nostr: C.sc   of I.peels  \".ki $C\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 4e4662544dd1
        gro: SlideEa
      t: rensc
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/SlideEa/SlideEa
    reny: 
      c: 
        el: 1
        s: "A.I.reny = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    C.y = C.y eq '' ? (I.blanky ? I.d&blanky : {})\n        : C.y =~ /^($NUM)$/ ? {cv=>$1}\n        : C.y =~ /^($NUM)-($NUM)$/ ? {in=>$1,out=>$2}\n        : C.y =~ /^($NUM)-($NUM)x($NUM)$/ ? {in=>$1,out=>$2,thi=>$3}\n        : C.y =~ /^([WJ])$/ ? do {\n            C.c->{$1} = C.t;\n            {};\n        }\n        : I.rey ? I.d&rey\n        : die \"C y wtf: C.y\";\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: ccdfbda93abd
        gro: SlideEa
      t: reny
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/SlideEa/SlideEa
    scyvle: 
      c: 
        el: 1
        s: "A.I.scyvle = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    for (qw'in out cv') {\n        if (my $so = C.y->{$_}) {\n            my $i;\n            while (C.y->{$_} <= -1 || C.y->{$_} >= 1) {\n                C.y->{$_} /= 10;\n                die \"Many i chewing on \".ki C.y if $i++ > 10;\n            }\n        }\n    }\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: d054be1e9bda
        gro: SlideEa
      t: scyvle
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/SlideEa/SlideEa
    string: 
      c: 
        el: 1
        s: "A.I.string = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    die \"string: $s\";\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 196a2239898a
        gro: SlideEa
      t: string
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/SlideEa/SlideEa
    xot: 
      c: 
        el: 1
        s: "A.I.xot = sub {\n    my ($A,$C,$G,$T,$s,$c,@Me) = @_;\n    my $I = A.I;\n    while (my($k,$v) = each %$c) {\n        $s->{$k} = ref $v ? {%{$s->{$k}||{}}, %$v} : $v;\n    }\n    $s\n};\n"
      sc: 
        acgt: s,c
        args: A,C,G,T,s,c
        code: I 1
        dige: ebbcb1ba9ff2
        gro: C
      t: xot
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
  "0.12": 
    Ci: 
      c: 
        el: 1
        s: "A.I.Ci = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    !ref $s ? I.d&string,$s\n    :\n    ref $s eq 'ARRAY' ? I.d&array,$s\n    :\n    ref $s eq 'HASH' ? I.d&hash,$s\n    :\n    die \"mmtype:$s\";\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: I 12
        dige: 0ae2f062639c
        gro: SlideEa
        its: 1
      t: Ci
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/SlideEa/SlideEa
  "0.18": 
    reasonlock: 
      c: 
        el: 1
        s: "A.I.reasonlock = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    die\"reft\" if ref C.t;\n    my $istf = sub {\n        my $s = shift;\n        exists s.t && !ref s.t && ref s.y && ref s.c && 9 > keys %$s;\n    };\n    # uis a nested wave - falling ]]]]]]]\n    # allow much manufold\n    # knot this not this:\n    if (A.J.name eq 'qq' || A.J.most.J eq A.J) {\n        C.c.W = C.t unless C.c || C.sc || C.y;\n    }\n    # this form:\n    if (ref C.y eq 'HASH' && (C.y.bb || $istf->(C.y))) {\n        if (C.y.bb) {\n            if (ref C.c eq 'HASH' && $istf->(C.c)) {\n                C.c = {e=>C.c};\n            }\n            C.c.s = C.y;\n        }\n        else {\n            if (ref C.c eq 'HASH' && C.c.bb) {\n                C.c = {s=>C.c};\n            }\n            C.c.e = C.y;\n        }\n        C.y = '';\n        C.c.W = C.t;\n    }\n    \n    I.d&renc if !ref C.c;\n    I.d&reny if !ref C.y;\n    I.d&rensc if !ref C.sc;\n    defined C.t && !ref C.t\n    && ref C.y && ref C.c && ref C.sc\n        || die \"reaso fail\".wdump [A.s,$C];\n    I.d&scyvle;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: I 18
        dige: 82f088fd235b
        gro: SlideEa
        its: 1
        li: "#c"
      t: reasonlock
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/SlideEa/SlideEa
