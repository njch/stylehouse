--- 
I: 
  "0.1": 
    Act: 
      c: 
        el: 1
        s: "A.I.Act = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n        $A = {%$s};\n        $A->{mo}->{ont} = $A;\n        $A->{s} = shift @{$A->{N}};\n        $T = {};\n        $T->{oM} = [];\n        $I->{d}->(\"n\",$A,{},$G,$T);\n        $I->{d}->(\"An\");\n        $A->{t}->(\"2\");\n        map{$I->{nF}->{$_}}qw'A C T';\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: e24a2c98dffd
        gro: Motion
      t: Act
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Motion/Motion
    An: 
      c: 
        el: 1
        s: "A.I.An = sub {\n    my ($A,$C,$G,$T,@Me) = @_;\n    my $I = A.I;\n        $A->{note} = {}; # pinging csc\n        $A->{talk} = \"$A->{J}->{name} \".($A->{J}->{le} && $A->{J}->{le}->{name});\n        $A->{c} = sub { $I->{d}->(\"c\",@_); };\n        $A->{e} = sub { $I->{d}->(\"e\",@_); };\n        $A->{us} = sub { $I->{d}->(\"us\",@_); };\n        $A->{t} = sub { $I->{d}->(\"t\",@_); };\n        $A->{V} = sub {\n            my $bl = shift;\n            $A->{J}->{VV} && $A->{J}->{VV}->{$bl}\n            || $A->{J}->{V}\n        };\n        $A\n};A.I.d&An;\n"
      sc: 
        acgt: 1
        args: A,C,G,T
        code: I 1
        dige: fb63d04c1357
        gro: Motion
      t: An
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Motion/Motion
    Cngk: 
      c: 
        el: 1
        s: "A.I.Cngk = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($s,$D,@Me) = @M;\n    my $I = A.I;\n    ref $A || die \"nmonref A!\";\n    aft { $@ .= \"\\nLookat: \".ki($s).\"\\nWith: \".ki($D) if $@ };\n    return 1 if D.c.any;\n    die \"nonNKnk\".ki$D if !D.c.nk;\n    return 0 if !exists $s->{D.c.nk};\n    return [$s->{D.c.nk}] if !exists D.c.gk;\n    return 0 if !exists $s->{D.c.nk}->{D.c.gk};\n    return [$s->{D.c.nk}->{D.c.gk}];\n};\n"
      sc: 
        acgt: s,D
        args: A,C,G,T,s,D
        code: I 1
        dige: 1ce95658c144
        gro: C
      t: Cngk
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    El: 
      c: 
        el: 1
        s: "A.I.El = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($J,$name,@Me) = @M;\n    my $I = A.I;\n    J.El->{$name} ||= {bb=>{},name=>$name};\n};\n"
      sc: 
        acgt: J,name
        args: A,C,G,T,J,name
        code: I 1
        dige: 9fd87735d303
        gro: Pha
        l: "#c without a self"
      t: El
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Pha/Pha
    Elj: 
      c: 
        el: 1
        s: "A.I.Elj = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($J,$name,@Me) = @M;\n    my $I = A.I;\n    J.El->{$name} ||= Rw Jto - $le:J $name;\n};\n"
      sc: 
        acgt: J,name
        args: A,C,G,T,J,name
        code: I 1
        dige: 3001808fbcce
        gro: Pha
        l: "#c with a self"
      t: Elj
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Pha/Pha
    Elvis: 
      c: 
        el: 1
        s: "A.I.Elvis = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($J,$Y,@Me) = @M;\n    my $I = A.I;\n    my $wtf = I.d&wtfch,J.bb,Y.bb;\n    \n    Y.tw ||= {};\n    Y.lo = {}; # compile\n    \n    for my $mo (qw'gone diff new') {\n        for my $r (keys %{$wtf->{$mo}}) {\n            my $j = I.d&rJ,$r,$J;\n            j.r = $r;\n            j.lt = j.cv.\"\\t\".j.t;\n            if (!j.lt=~/\\S/) {\n                die \"Got $r =>   \".ki $j;\n            }\n            if ($mo eq 'gone') {\n                delete Y.bb->{j.r};\n                delete Y.tw->{j.lt}->{j.style};\n            }\n            else {\n                Y.bb->{j.r} = j.s;\n                Y.tw->{j.lt}->{j.style} = j.s;\n            }\n            Y.lo->{j.lt}->{$mo}->{j.style} = j.s;\n        }\n    }\n    \n    Y.tv ||= {};\n    Y.v ||= {};\n    Y.go = {};\n    my $same = 1;\n    for my $k (keys %{Y.lo}) {\n        my $tf = Y.lo->{$k};\n        my $cs = Y.tw->{$k};\n        if (tf.new && !tf.gone && !tf.diff && keys %{tf.new} == keys %$cs) {\n            $same = 0; # new line to make\n        }\n        if (tf.gone && !keys %$cs) {\n            $same = 0; # line to disappear\n            my $C = Y.go->{$k} = delete Y.tv->{$k};\n            my ($cv,$t) = $k =~ /^(.+?)\\t(.*)$/;\n            delete Y.v->{$cv}->{$t};\n            delete Y.v->{$cv} unless keys %{Y.v->{$cv}};\n        }\n        if (tf.diff || tf.new) {\n            keys %$cs || die 'nokeys';\n            my ($cv,$t) = $k =~ /^(.+?)\\t(.*)$/;\n            defined $cv || die \"twas $k\";\n            my $foam = sub {\n                my $C = shift;\n                %$C = (t=>$t,y=>{cv=>$cv},c=>{},sc=>{%$cs});\n                C.c.s = delete C.sc->{''} if exists C.sc->{''};\n            };\n            $foam->(Y.tv->{$k} ||= {});\n            $foam->(Y.v->{$cv}->{$t} ||= {});\n        }\n    }\n    if (!$same) {\n        Y.vs = [];\n        Y.kvi = {};\n        Y.cvi = {};\n        my $i = 0;\n        for my $k (sort keys %{Y.tv}) {\n            my $C = Y.tv->{$k} || die \"wtf $k\";\n            push @{Y.vs}, $C;\n            Y.kvi->{$k} = $i;\n            Y.cvi->{C.y.cv||die\"nocv \".ki$C} ||= $i;\n            $i++;\n        }\n    }\n    \n    Y.ra = I.d&ratio,wtf.sami,wtf.tot;\n    Y.rato = wtf.tot;\n    Y.revs = !$same;\n    \n    $Y;\n};\n"
      sc: 
        acgt: J,Y
        args: A,C,G,T,J,Y
        code: I 1
        dige: 57d7fc141aa6
        gro: Pha
        l: "#c"
      t: Elvis
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Pha/Pha
    Other: 
      c: 
        el: 1
        s: "A.I.Other = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n        my $ar = $F[0]->{ar};\n        $A = $G->{w}->(\"RB\", {%$ar, t => $s}, $G);\n        $I = $A->{I};\n        # midnight at the oasis\n        $I->{d}->(\"n\",$A,{},$G,{});\n        $I->{d}->(\"An\");\n        $A->{t}->(\"1\");\n        $A->{t}->(\"11111\") || warn \"NO 1\";\n        ($A,$A->{I})\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 9e38e8306a8d
        gro: Motion
      t: Other
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Motion/Motion
    Tat: 
      c: 
        el: 1
        s: "A.I.Tat = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n        my $at = delete $T->{at};\n        $at || die \"youAT\";\n        $C->{sc}->{$_} = $at->{$_} for keys %$at; # sizling update sprites\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 0a4f4c661b5b
        gro: Motion
      t: Tat
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Motion/Motion
    array: 
      c: 
        el: 1
        s: "A.I.array = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    return I.d&fourreal,$s if @$s != 1 && !ref $s->[0] || $s->[0] =~ /^\\w+$/;\n    return I.d&fourstring,$s->[0] if @$s == 1 && !ref $s->[0];\n    # should stick In in first and M it? \n    # kind of motion that wants to be unsure in the wild\n    unshift @{A.N}, @$s;\n    T.not = 1;\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 1621c6fcf424
        gro: SlideEa
      t: array
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/SlideEa/SlideEa
    as: 
      c: 
        el: 1
        s: "A.I.as = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($s,$x,@Me) = @M;\n    my $I = A.I;\n    for (qw'begin bb ord tim wtf') {\n         exists $x->{$_} || next;\n         my $v = $x->{$_};\n         $v = [@$v] if ref $v eq 'ARRAY';\n         $v = {%$v} if ref $v eq 'HASH';\n         $s->{$_} = $v;\n    }\n};\n"
      sc: 
        acgt: s,x
        args: A,C,G,T,s,x
        code: I 1
        dige: e6a7402c5fdd
        gro: Pha
      t: as
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Pha/Pha
    bandon: 
      c: 
        el: 1
        s: "A.I.bandon = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    delete s.J.phy->{s.name};\n    s.abandoned = 1;\n    if (my $x = s.head) {\n        I.d&as,$s,$x;\n    }\n    I.d&end,$s\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: e6de6441b8ff
        gro: Pha
      t: bandon
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Pha/Pha
    c: 
      c: 
        el: 1
        s: "A.I.c = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($D,@Me) = @M;\n    my $I = A.I;\n    I.d&inDin,$C,@M;\n};\n"
      sc: 
        acgt: D
        args: A,C,G,T,D
        code: I 1
        dige: a931936381c2
        gro: C
      t: c
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    e: 
      c: 
        el: 1
        s: "A.I.e = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($D,@Me) = @M;\n    my $I = A.I;\n    I.d&inDin,C.c.e,@M;\n};\n"
      sc: 
        acgt: D
        args: A,C,G,T,D
        code: I 1
        dige: 06747ef15695
        gro: C
      t: e
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    end: 
      c: 
        el: 1
        s: "A.I.end = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $y = s.J.phl->{s.name} ||= {name=>s.name, l=>[]};\n    s.ended = hitime();\n    delete s.J.phy->{s.name};\n    shift @{y.l} while @{y.l} > 5;\n    # layers ^ rolling in time index .r -> the y.l\n    # so last phase of $name can be found?\n    push @{y.l}, $s;\n    if (s.bb) {\n        my $w = @{y.l};\n        y.l_bb->{$_} = $w for keys %{s.bb};\n    }\n    # somewhere thinks about what happened\n    $y\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 45e558668e71
        gro: Pha
      t: end
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Pha/Pha
    exactl: 
      c: 
        el: 1
        s: "A.I.exactl = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $q = shift;\n    my $y = I.d&end,$s;\n    my $cur = y.l->[-1];\n    my $last = y.l->[-2];\n    $cur eq $s || die \"sidf$cur $s\";\n    last.bb ||= {};\n    \n    my $wtf = I.d&wtfch,cur.bb,last.bb;\n    \n    delete s.J.bb->{$_} for keys %{wtf.gone};\n    \n    # see s.extill, time passing interesto...\n    # churn stats like 30% of last disappear, 20% new\n    s.wtf = $wtf;\n    $wtf;\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: c98060f45a3a
        gro: Pha
        l: "#c un-ins things from J"
      t: exactl
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Pha/Pha
    flywheels: 
      c: 
        el: 1
        s: "A.I.flywheels = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n        # wants to be a six alwayser... ,{code=>'I 6',act=>'all'} # $II->{All}? $II->{Fly}?\n        # its $I->{d}->(\"nded\") and holds things to code, $v a spiral it's filling up\n        # $v could be mounted... aj8 mysteries\n        for my $k (sort keys %{$A->{fl}}) {\n            my $v = $A->{fl}->{$k};\n            #   ^ bus to ride\n            $k = $2 if $k =~ /^(\\d+) (.+)$/;\n            $G->{w}->(\"ym/$k\", {I => $I, J => $A->{J}, A => $A, C => $C, v => $v, G => $G, T => $T}, $G);\n        }\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 6a90e0b56807
        gro: Motion
      t: flywheels
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Motion/Motion
    fourreal: 
      c: 
        el: 1
        s: "A.I.fourreal = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    (C.t, C.y) = @$s;\n    C.c  = $s->[2] if exists $s->[2];\n    C.sc = $s->[3] if exists $s->[3];\n    die'@>4'.wdump $s if @$s > 4;\n    die\"C.t from \".wdump $s if ref C.t; # dives\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 87baea0c56c8
        gro: C
      t: fourreal
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    fourstring: 
      c: 
        el: 1
        s: "A.I.fourstring = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    I.d&MZu,$1 if $s =~ /^\\s*#?\\s*MZ (.+)$/;\n    if ($s =~ /^\\s*(#.*)$/) {\n       T.not = 1;\n       T.com = $1;\n    }\n    elsif ($s eq '') {\n       T.not = T.space = 1;\n    }\n    else {\n       my $ci = $s;\n       for my $nk (qw't y c sc') {\n           if ($ci =~ s/^(\\S+) *//) { # some t are types of space\n               my $v = $1;\n               $v = I.d&peel,$v if $nk ne 't' && $v =~ I.peels;\n               # << consumes more lines into $nk, then ...\n               $v = '' if $v =~ /^(''|\"\")$/;\n               $C->{$nk} = $v;\n           }\n       }\n    }\n    saybl \"4string: $s            \".ki $C;\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 173505d9057f
        gro: C
      t: fourstring
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    hash: 
      c: 
        el: 1
        s: "A.I.hash = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    return %$C = %$s if exists s.t && s.y && s.c;\n    # some talking to self - how to C over exactly\n    # the object could be live\n    I.d&servehash,$s;\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: d4c8ca29125b
        gro: SlideEa
      t: hash
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/SlideEa/SlideEa
    inDin: 
      c: 
        el: 1
        s: "A.I.inDin = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($s,$D,@Me) = @M;\n    my $I = A.I;\n    die'nofA' if !I.nF.A;\n    #\n    return () unless defined $s;\n    return $s if $D eq 'C';\n    #\n    shift @M; # s\n    $D = I.d&interpD,@M if !ref $D;\n    #\n    my $v = I.d&Cngk,$s,$D;\n    #\n    return () unless $v;\n    # blankgk\n    A.note->{D.c.nk}->{D.c.gk} = $v if A.note;\n    #\n    die 'mulitAn' if @$v > 1;\n    if (D.c.as eq 'list') {\n        ref $v eq 'ARRAY' || die 'Cngk not array';\n        return @$v;\n    }\n    return 1;\n};\n"
      sc: 
        acgt: s,D
        args: A,C,G,T,s,D
        code: I 1
        dige: bc7f2cfdcb5f
        gro: C
      t: inDin
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    interpD: 
      c: 
        el: 1
        s: "A.I.interpD = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($nk,$gk,@Me) = @M;\n    my $I = A.I;\n    my $defnk = 'c';\n    return $nk if ref $nk;\n    my $D = {};\n    D.c.as = 'list' if 1 || $nk =~ s/^_//;\n    while ($gk =~ s/^%(.+?):(.+?)(?=%|$)//g) {\n        D.c->{$1} = $2;\n        pop @M if @M == 2;\n    }\n    if (@M == 1 && $nk eq 't') {\n        D.c.nk = $nk;\n    }\n    elsif (@M == 1) { # or from t,,,\n        D.c.nk ||= $defnk;\n        D.c.gk ||= $nk;\n    }\n    elsif (@M == 2) {\n        D.c.nk = $nk;\n        D.c.gk = $gk;\n    }\n    delete D.c.gk if D.c.gk eq 'NOGK';\n    $D\n};\n"
      sc: 
        acgt: nk,gk
        args: A,C,G,T,nk,gk
        code: I 1
        dige: 688db989ec06
        gro: C
      t: interpD
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    moy: 
      c: 
        el: 1
        s: "A.I.moy = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n        # groups, spread the moise over A\n        my $i = $A->{mo}->{y}->{$s}||die\"no$s\";\n        my $is = $i->{$C->{y}->{p}}; # things in our C's pool\n        {is=>$is,N=>[map{$is->{$_}}sort keys %$is]};\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 2fb4d87f09eb
        gro: Motion
      t: moy
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Motion/Motion
    oseverato: 
      c: 
        el: 1
        s: "A.I.oseverato = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n        if ($T->{d}) {\n            $A->{T}->{d} = $T->{d}; # carte\n        }\n        if (my $z = delete $T->{Z}) { # tease out the next times\n            my ($lo) = sort keys %$z; # next one\n            my $v = $z->{$lo};\n            push @{$A->{mo}->{re}->{$lo} ||= []},\n                ref $v eq 'ARRAY' ? @$v :\n                $v ne '1' ? [$A,$C,$v] :\n                [$A,$C];\n            @{$T->{oM}} = ();\n        }\n        if (!@{$A->{mo}->{N}} && $A->{mo}->{re}) {\n            my $ats = $A->{mo}->{re} || {};\n            my @wa = sort keys %$ats;\n            my ($lo) = @wa;\n            if ($lo) {\n                my $ay = delete $ats->{$lo};\n                my @N = map { {AZ=>{$lo=>$_}} } @$ay;\n                push @{$A->{mo}->{N}}, @N;\n                saybl \"Looping \".@N.\" to $lo\" if $A->{J}->{V} > 1;\n            }\n        }\n        # concoi severaliser, for conglom up; merging spiral snips of code\n        if (my $y = $T->{y}) {\n            for my $k (keys %$y) {\n                $A->{mo}->{y}->{$k}->{$C->{y}->{p}}->{$C->{y}->{cvt}} = $C;\n            }\n        }\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: c2111bfab654
        gro: Motion
      t: oseverato
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Motion/Motion
    peel: 
      c: 
        el: 1
        s: "A.I.peel = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    $s =~ s/^%// || \n        $s =~ s/^{// && $s =~ s/}$//\n        || die \"unpealable $s\";\n    my $c;\n    for (split ',', $s) {\n        my ($k, $v) = split ':', $_, 2;\n        $v = 1 if !defined $v;\n        $c->{$k} = $v;\n    }\n    $c||{}\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 86d02e052c88
        gro: C
      t: peel
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    peels: 
      c: 
        el: 1
        s: "A.I.peels = (sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    qr/^[\\{\\%]/;\n})->($A,$C,$G,$T);\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 2cef197e1b39
        gro: C
        subpeel: 1
      t: peels
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    pha: 
      c: 
        el: 1
        s: "A.I.pha = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($J,$name,@Me) = @M;\n    my $I = A.I;\n    # tracked being\n    # temporal phatness, per suJ (encap $M surges within)\n    if (my $x = J.phy->{$name}) {\n        sayre \"J.name 's $name was re entrant\";\n        I.d&end,$x;\n        # end - maybe new stuffright as some random part of this process\n        # hold yay minutes of changes in 10 second groups, etc\n    }\n    # bz multicasts\n    my $x = J.phy->{$name} = {};\n    x.begin = hitime();\n    x.name = $name;\n    x.J = $J;\n    x.bb = {};\n    x.ord = [];\n    #x.tim = {};\n    #x.wtf = {}; # F grab\n    #x.ap = sub{}; # bz do aftering\n    x.qui = 1;\n    x.head = J.phl->{$name}->{l}->[-1] if J.phy->{$name};\n    $x;\n};\n"
      sc: 
        acgt: J,name
        args: A,C,G,T,J,name
        code: I 1
        dige: ab1fd2a37714
        gro: Pha
      t: pha
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Pha/Pha
    renc: 
      c: 
        el: 1
        s: "A.I.renc = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    C.c = C.c =~ I.peels ? I.d&peel,C.c\n      : {s => C.c};\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: eae926764058
        gro: SlideEa
      t: renc
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/SlideEa/SlideEa
    rensc: 
      c: 
        el: 1
        s: "A.I.rensc = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    C.sc = C.sc eq '' ? {}\n        : C.sc =~ I.peels\n        ? I.d&peel,C.sc\n        : die \"C sc nostr: C.sc   of I.peels  \".ki $C\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 4e4662544dd1
        gro: SlideEa
      t: rensc
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/SlideEa/SlideEa
    reny: 
      c: 
        el: 1
        s: "A.I.reny = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    C.y = C.y eq '' ? (I.blanky ? I.d&blanky : {})\n        : C.y =~ /^($NUM)$/ ? {cv=>$1}\n        : C.y =~ /^($NUM)-($NUM)$/ ? {in=>$1,out=>$2}\n        : C.y =~ /^($NUM)-($NUM)x($NUM)$/ ? {in=>$1,out=>$2,thi=>$3}\n        : C.y =~ /^([a-zA-Z]+)(?::(.+))?$/ ? do {\n            C.c->{$1} = $2 || C.t;\n            {};\n        }\n        : I.rey ? I.d&rey\n        : die \"C y wtf: C.y\";\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: eba66862923b
        gro: SlideEa
      t: reny
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/SlideEa/SlideEa
    scyvle: 
      c: 
        el: 1
        s: "A.I.scyvle = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    for (qw'in out cv') {\n        if (my $so = C.y->{$_}) {\n            my $i;\n            while (C.y->{$_} <= -1 || C.y->{$_} >= 1) {\n                C.y->{$_} /= 10;\n                die \"Many i chewing on \".ki C.y if $i++ > 10;\n            }\n        }\n    }\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: d054be1e9bda
        gro: SlideEa
      t: scyvle
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/SlideEa/SlideEa
    string: 
      c: 
        el: 1
        s: "A.I.string = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    die \"string: $s\";\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 196a2239898a
        gro: SlideEa
      t: string
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/SlideEa/SlideEa
    us: 
      c: 
        el: 1
        s: "A.I.us = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($D,@Me) = @M;\n    my $I = A.I;\n    my $E = C.c.e || return ();\n    push @M, 'NOGK' if @M == 1;\n    I.d&inDin,E.c.us,@M;\n};\n"
      sc: 
        acgt: D
        args: A,C,G,T,D
        code: I 1
        dige: 0cdebb6cbbf0
        gro: C
      t: us
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    wtfch: 
      c: 
        el: 1
        s: "A.I.wtfch = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($Jb,$Yb,@Me) = @M;\n    my $I = A.I;\n    my $wtf = {};\n    wtf.same = 1;\n    $wtf->{$_} = {} for qw'new diff gone';\n    \n    for (sort keys %$Jb) {\n        if (!exists $Yb->{$_}) {\n            wtf.new->{$_} = $Jb->{$_};\n            wtf.same = 0;\n        } \n        elsif ($Yb->{$_} ne $Jb->{$_}) {\n            wtf.diff->{$_} = $Jb->{$_};\n            wtf.same = 0;\n        }\n        else {\n            wtf.sami++;\n            wtf.still->{$_} = $Jb->{$_};\n        }\n        wtf.tot++;\n    }\n    for (grep { !exists $Jb->{$_} } sort keys %$Yb) {\n        wtf.gone->{$_} = $Yb->{$_};\n        wtf.same = 0;\n    }\n    $wtf;\n};\n"
      sc: 
        acgt: Jb,Yb
        args: A,C,G,T,Jb,Yb
        code: I 1
        dige: 75e75366ec49
        gro: Pha
        l: "#c diff J"
      t: wtfch
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Pha/Pha
    xot: 
      c: 
        el: 1
        s: "A.I.xot = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($s,$c,@Me) = @M;\n    my $I = A.I;\n    while (my($k,$v) = each %$c) {\n        $s->{$k} = ref $v ? {%{$s->{$k}||{}}, %$v} : $v;\n    }\n    $s\n};\n"
      sc: 
        acgt: s,c
        args: A,C,G,T,s,c
        code: I 1
        dige: f8940275bf17
        gro: C
      t: xot
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    z: 
      c: 
        el: 1
        s: "A.I.z = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n        $I->{d}->(\"oseverato\");\n        push @{$A->{M}}, @{$T->{oM}};\n        1\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 85ce5e302f71
        gro: Motion
      t: z
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Motion/Motion
  "0.12": 
    Ci: 
      c: 
        el: 1
        s: "A.I.Ci = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    !ref $s ? I.d&string,$s\n    :\n    ref $s eq 'ARRAY' ? I.d&array,$s\n    :\n    ref $s eq 'HASH' ? I.d&hash,$s\n    :\n    die \"mmtype:$s\";\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: I 12
        dige: 0ae2f062639c
        gro: SlideEa
        its: 1
      t: Ci
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/SlideEa/SlideEa
  "0.18": 
    reasonlock: 
      c: 
        el: 1
        s: "A.I.reasonlock = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    die\"reft\" if ref C.t;\n    my $istf = sub {\n        my $s = shift;\n        exists s.t && !ref s.t && ref s.y && ref s.c && 9 > keys %$s;\n    };\n    # uis a nested wave - falling ]]]]]]]\n    # allow much manufold\n    # knot this not this:\n    if (A.J.name eq 'qq' || A.J.most.J eq A.J) {\n        C.c.W = C.t unless C.c || C.sc || C.y;\n    }\n    # this form: NextWorm=>$C=>$J (C/J swappy)\n    if (ref C.y eq 'HASH' && (C.y.bb || $istf->(C.y))) {\n        if (C.y.bb) {\n            if (ref C.c eq 'HASH' && $istf->(C.c)) {\n                C.c = {e=>C.c};\n            }\n            C.c.s = C.y;\n        }\n        else {\n            if (ref C.c eq 'HASH' && C.c.bb) {\n                C.c = {s=>C.c};\n            }\n            C.c.e = C.y;\n        }\n        C.y = '';\n        C.c.W = C.t;\n    }\n    \n    I.d&renc if !ref C.c;\n    I.d&reny if !ref C.y;\n    I.d&rensc if !ref C.sc;\n    defined C.t && !ref C.t\n    && ref C.y && ref C.c && ref C.sc\n        || die \"reaso fail\".wdump [A.s,$C];\n    I.d&scyvle;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: I 18
        dige: 860ac48a38e1
        gro: SlideEa
        its: 1
        li: "#c"
      t: reasonlock
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/SlideEa/SlideEa
  "0.71": 
    CoM: 
      c: 
        el: 1
        s: "A.I.CoM = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n        push @{$T->{oM}}, $C unless $T->{Z};\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: I 71
        dige: 7a9e6cff36b8
        gro: Motion
        its: 1
      t: CoM
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Motion/Motion
em: 
  "0.21": 
    em_21: 
      c: 
        el: 1
        s: "A.I.em_21 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $em = C.c.em;\n    em.lines || die \"Not lines\";\n    em.hitime = hitime();\n    em.is.W = C.sc.Wid || A.J.id;\n    em.is.M = C.sc.Mid || A.J.name;\n    em.id = em.is.W.'.'.(0+em.i);\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: em 21
        dige: c304cc4fd1ff
        gk: em
        gro: Meta
        nk: c
        v: cem
      t: em_21
      "y": 
        cv: '0.21'
        cvt: 0.21	C.t
        p: qq/Meta/Meta
  "0.3": 
    eve_3: 
      c: 
        el: 1
        s: "A.I.eve_3 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $sc = C.sc;\n    my $eve = C.sc.eve;\n    my $J = C.c.J;\n    my $em = C.c.em;\n    `touch life/W/em.is.W\\.e`;\n    J.mo.s.al.opt.fole = [Followe=>W=>\"life/W/em.is.W\\.e\"];\n    # routes ids[] into All(Oth)\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        cg: J,em
        code: em 3
        dige: 2845d7c631b6
        gk: eve
        gkiss: s
        gro: Meta
        nk: sc
        nov: 1
        nv: sceve
        rg: J,em
        v: sceve
      t: eve_3
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Meta/Meta
    jslines_3: 
      c: 
        el: 1
        s: "A.I.jslines_3 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $sc = C.sc;\n    my $jslines = C.sc.jslines;\n    my $J = C.c.J;\n    my $em = C.c.em;\n    my $N = [@{em.lines||die\"Nop\"}];\n    @$N = Rw humms $J $N wongui _;\n    @$N = Rw humms $J $N notnotjs _;\n    my $S = Rw humms $J $N spots;\n    em.lines = [map{\n        \" a\\.e(\".sjson($_).\");\"\n    }@{S.z}];\n    C.c.os = 1 if !grep {/\\S/} @{S.z};\n    C.sc.Wc = 1;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        cg: J,em
        code: em 3
        dige: a74597f1757e
        gk: jslines
        gkiss: s
        gro: Meta
        nk: sc
        nov: 1
        nv: scjslines
        rg: J,em
        v: scjslines
      t: jslines_3
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Meta/Meta
    ressur_3: 
      c: 
        el: 1
        s: "A.I.ressur_3 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $sc = C.sc;\n    my $ressur = C.sc.ressur;\n    my $J = C.c.J;\n    my $em = C.c.em;\n    saybl \"Ressurrecting $ressur ...\";\n    die \"zomp $ressur\" if $ressur =~ /\\W/;\n    die \"bno JSlines\" unless -e \"life/W/$ressur\";\n    `cd life; ln -s ../W/$ressur J/em.id\\.c`;\n    my $catch = sjson {y=>J=>id=>em.id};\n    I.d&writef,\"life/J\\.s\",$catch,1;\n    T.whack = 1; # out of em\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        cg: J,em
        code: em 3
        dige: bc77ff177d9a
        gk: ressur
        gkiss: s
        gro: Meta
        nk: sc
        nov: 1
        nv: scressur
        rg: J,em
        v: scressur
      t: ressur_3
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Meta/Meta
    ux_3: 
      c: 
        el: 1
        s: "A.I.ux_3 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $sc = C.sc;\n    my $ux = C.sc.ux;\n    my $em = C.c.em;\n    my $J = G.oin;\n    my $M = ['','',{W=>J.id},{z=>em.lines}];\n    em.lines = [\" a\\.om({},\".sjson($M).\",a,{});\"];\n    C.sc.Wc = 1;\n    n GW\n    # ^ router, W with an .e v\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        cg: em
        code: em 3
        dige: 23201747d7da
        gk: ux
        gkiss: s
        gro: Meta
        nk: sc
        nov: 1
        nv: scux
        rg: em
        v: scux
      t: ux_3
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Meta/Meta
