--- 
I: 
  "0.1": 
    array: 
      c: 
        el: 1
        s: "A.I.array = sub {\n    my ($A,$C,$G,$T,$s) = @_;\n    my $I = A.I;\n    return I.d&fourreal,$s if @$s != 1 && !ref $s->[0] || $s->[0] =~ /^\\w+$/;\n    return I.d&fourstring,$s if @$s == 1 && !ref $s->[0];\n    # should stick In in first and M it? \n    # kind of motion that wants to be unsure in the wild\n    unshift @{A.N}, @$s;\n    T.not = 1;\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: e98b49283b58
        gro: EatSlide
      t: array
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/EatSlide/EatSlide
    hash: 
      c: 
        el: 1
        s: "A.I.hash = sub {\n    my ($A,$C,$G,$T,$s) = @_;\n    my $I = A.I;\n    return %$C = %$s if exists s.t && s.y && s.c;\n    # some talking to self - how to C over exactly\n    # the object could be live\n    I.d&servehash,$s;\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 6a85bb9d5fac
        gro: EatSlide
      t: hash
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/EatSlide/EatSlide
    renc: 
      c: 
        el: 1
        s: "A.I.renc = sub {\n    my ($A,$C,$G,$T,$s) = @_;\n    my $I = A.I;\n    C.c = C.c =~ I.peels ? I.d&peel,C.c\n      : {s => C.c};\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 70d3395e3103
        gro: EatSlide
      t: renc
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/EatSlide/EatSlide
    rensc: 
      c: 
        el: 1
        s: "A.I.rensc = sub {\n    my ($A,$C,$G,$T,$s) = @_;\n    my $I = A.I;\n    C.sc = C.sc eq '' ? {}\n        : C.sc =~ I.peels\n        ? I.d&peel,C.sc\n        : die \"C sc nostr: C.sc   of I.peels  \".ki $C\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 00604d1227d3
        gro: EatSlide
      t: rensc
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/EatSlide/EatSlide
    reny: 
      c: 
        el: 1
        s: "A.I.reny = sub {\n    my ($A,$C,$G,$T,$s) = @_;\n    my $I = A.I;\n    C.y = C.y eq '' ? (I.blanky ? I.d&blanky : {})\n        : C.y =~ /^($NUM)$/ ? {cv=>$1}\n        : C.y =~ /^($NUM)-($NUM)$/ ? {in=>$1,out=>$2}\n        : C.y =~ /^($NUM)-($NUM)x($NUM)$/ ? {in=>$1,out=>$2,thi=>$3}\n        : C.y =~ /^([WJ])$/ ? do {\n            C.c->{$1} = C.t;\n            {};\n        }\n        : I.rey ? I.d&rey\n        : die \"C y wtf: C.y\";\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 04261101034d
        gro: EatSlide
      t: reny
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/EatSlide/EatSlide
    scyvle: 
      c: 
        el: 1
        s: "A.I.scyvle = sub {\n    my ($A,$C,$G,$T,$s) = @_;\n    my $I = A.I;\n    for (qw'in out cv') {\n        if (my $so = C.y->{$_}) {\n            my $i;\n            while (C.y->{$_} <= -1 || C.y->{$_} >= 1) {\n                C.y->{$_} /= 10;\n                die \"Many i chewing on \".ki C.y if $i++ > 10;\n            }\n        }\n    }\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 54ae8b834d07
        gro: EatSlide
      t: scyvle
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/EatSlide/EatSlide
    string: 
      c: 
        el: 1
        s: "A.I.string = sub {\n    my ($A,$C,$G,$T,$s) = @_;\n    my $I = A.I;\n    die \"string: $s\";\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 70331f91486a
        gro: EatSlide
      t: string
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/EatSlide/EatSlide
  "0.12": 
    Ci: 
      c: 
        el: 1
        s: "A.I.Ci = sub {\n    my ($A,$C,$G,$T,$s) = @_;\n    my $I = A.I;\n    !ref $s ? I.d&string,$s\n    :\n    ref $s eq 'ARRAY' ? I.d&array,$s\n    :\n    ref $s eq 'HASH' ? I.d&hash,$s\n    :\n    die \"mmtype:$s\";\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: I 12
        dige: 8321990636a8
        gro: EatSlide
        its: 1
      t: Ci
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/EatSlide/EatSlide
  "0.18": 
    reasonlock: 
      c: 
        el: 1
        s: "A.I.reasonlock = sub {\n    my ($A,$C,$G,$T,$s) = @_;\n    my $I = A.I;\n    die\"reft\" if ref C.t;\n    # uis a nested wave\n    # allow much manufold\n    # knot this not this:\n    if (A.J.name eq 'qq' || A.J.most.J eq A.J) {\n        C.c.W = C.t unless C.c || C.sc || C.y;\n    }\n    \n    I.d&renc if !ref C.c;\n    I.d&reny if !ref C.y;\n    I.d&rensc if !ref C.sc;\n    defined C.t && !ref C.t\n    && ref C.y && ref C.c && ref C.sc\n        || die \"reaso fail\".wdump [A.s,$C];\n    I.d&scyvle;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: I 18
        dige: c4d217d4dce2
        gro: EatSlide
        its: 1
      t: reasonlock
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/EatSlide/EatSlide
