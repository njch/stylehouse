--- 
I: 
  "0.1": 
    array: 
      c: 
        el: 1
        s: "A.I.array = sub {\n    my ($A,$C,$G,$T,$s) = @_;\n    my $I = A.I;\n    return I.d&fourreal,$s\n        if @$s != 1 || $s->[0] =~ /^\\w+$/;\n    $s = $s->[0];\n    ref $s && die \"array1ref: \".wdump $s;\n    I.d&fourstring,$s\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 4d349b020a30
        gro: EatSlide
      t: array
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/EatSlide/EatSlide
    carebowl: 
      c: 
        el: 1
        s: "A.I.carebowl = sub {\n    my ($A,$C,$G,$T,$s,$iii,$x,$xrd) = @_;\n    my $I = A.I;\n    for my $ik (sort keys %$iii) {\n        my $D = $iii->{$ik};\n        if (my $nk = D.sc.nk) {\n            my $C = I.nF.C;\n            next if !exists $C->{$nk};\n            if (my $gk = D.sc.gk) {\n                next if !exists $C->{$nk}->{$gk};\n            }\n        }\n        my $act;\n        my $dont;\n        if (D.sc.acgt && D.sc.act) {\n            $act = 1;\n            # acgtsubs can be defined at any cv\n            # run themselves if act\n            # usu. one receiver (Ci) and the rest scheme\n            die \"D.t .act gets... D.sc.act\" if D.sc.act ne '1';\n            $dont = 1 if exists A.I->{D.t};\n        }\n        # way or acgt-setuping-way\n        unless ($dont) {\n            my $paw = join\"_\",'',I.k,I.cv,D.t;\n            $paw =~ s/\\W//g;\n            Rw $paw $A $C $G $T $__D:D;\n        }\n        # most tiny ticks\n        # this ind is all flywheel\n        # it's a kind of unity that wants to be a block of code like this\n        # and c\n        my @is = A.s;\n        @is = I.d&scIfs,D.sc.Ifs if D.sc.Ifs;\n        @is || next;\n        if ($act) {\n            push @$xrd, [I.k,$ik];\n            my $Ds = $x->{I.k}->{$ik} ||= {};\n            Ds.D = $D;\n            Ds.is = \\@is;\n            D.sc.its = @is;\n        }\n        # TreeD\n        $s->{I.k}->{I.cv}->{$ik} = $D;\n    }\n};\n"
      sc: 
        acgt: s,iii,x,xrd
        args: A,C,G,T,s,iii,x,xrd
        code: I 1
        dige: 6a65d4535276
        gro: KowTime
        l: "#c"
      t: carebowl
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/KowTime/KowTime
    ex: 
      c: 
        el: 1
        s: "A.I.ex = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($i,$K,$cv,$av) = @M;\n    my $I = A.I;\n    # was Rw SNat $A $C $G $T $I $i $K $cv;\n    # baseism\n    my $c = 0+(\"0.\".$cv);\n    my $Av = $av || A.cv;\n    my $sp = $av ? \" Flav $av (no A.cv)\" : \"\";\n    \n    my $talk = \"A.talk: $K$sp $Av > $c --- C.t \";\n    \n    my $aim = {$K=>1};\n    if ($aim->{A.am}) {\n        $aim->{$_} = 1 for @{A.Isl||[]};\n        aim.I = 1;\n    }\n    \n    my $yv = {};\n    # make K/cv/t -> cv/K/t\n    for my $k (sort keys %$i) {\n        my $ii = $i->{$k};\n    \n        next if $k eq 'Ii';\n        next if $k eq 'ooI';\n        ref $ii eq 'HASH' || die \"weird $k=$ii\";\n    \n        for my $vc (sort keys %$ii) {\n            my $iii = $ii->{$vc};\n            die'$k !0<$vc<1' unless $vc > 0 && $vc < 1;\n            $yv->{$vc}->{$k} = $iii;\n        }\n    }\n    \n    # do stuff\n    my $vb; # in fractions\n    my $wasSubtle;\n    for my $vc (sort keys %$yv) {\n        my $is = $yv->{$vc};\n        my $s = {};\n        my $x = {};\n        my $xrd = [];\n    \n        next if $vc <= $Av && $vc != $c;\n        next if $vc > $c;\n    \n        # our  osc (stay in K per Subtle ness);\n        my @iz = grep {\n            $aim->{$_} || (aim.I && (A.Iso->{$_} || I.also->{$_}))\n        } sort keys %$is;\n        next if !@iz;\n    \n        # decide inter cv wideness loop\n        if ($wasSubtle) {\n            undef $wasSubtle;\n        }\n        elsif ($vb && $vc > $vb && (\n            @{A.N} || @{A.mo.re->{$vb}||[]}\n            )) {\n            # sincing, wide order\n            # various others want to be around for only some of the process...\n            sayre \"$vb -> $vc  bump, \". @{A.N} if A.J.V > 1;\n            T.Z->{$vb} = 1;\n            A.cv = $vb; # so we dont wind up to 6 on the way out of t\n            return T.not = 1;\n        }\n    \n        # pin down poles\n        I.cv = $vc;\n        I.vb = $vb;\n        # draw curvles as spirals done\n    \n        for my $k (@iz) {\n            my $iii = $is->{$k};\n            I.k = $k;\n            I.d&carebowl,$s,$iii,$x,$xrd;\n        }\n        # suble\n        my $se = Rw TreeD $s $scby=gro \n            if A.J.V > 1 && keys %$s;\n        $c == 0.1 ? saygr $se : say $se if $se;\n    \n        my $o;\n        (o.vc,o.vb) = ($vc,$vb);\n        I.d&exood,$o,$x,$xrd;\n        ($vc,$vb) = (o.vc,o.vb);\n        if (o.Subtle && !o.nonSubtle) {\n            $wasSubtle = 1;\n        }\n    \n        return if T.not;  # will &z, oseve\n        return if delete T.whack;\n    }\n};\n"
      sc: 
        acgt: i,K,cv,av
        args: A,C,G,T,i,K,cv,av
        code: I 1
        dige: 91fa129f8e62
        gro: KowTime
        nois: "#c"
      t: ex
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/KowTime/KowTime
    exood: 
      c: 
        el: 1
        s: "A.I.exood = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($o,$x,$xrd) = @M;\n    my $I = A.I;\n    for my $kik (@$xrd) {\n        my ($k,$ik) = @$kik;\n        A.Subtle && A.Subtle->{$k} ? o.Subtle++ : o.nonSubtle++;\n        my $Ds = $x->{$k}->{$ik};\n        my $D = Ds.D;\n        for my $s (@{Ds.is}) {\n            D.sc.acgt eq 's'||die \"nonacgts\".wdump $D;\n            exists A.I->{D.t}||die \"acgtI D.t not up: \".wdump A.I;\n    \n            I.d&D.t,$s;\n    \n            I.acted and I.d&acted,$s;\n    \n            if (my $ut = T.ut) {\n                if (ut.matchTd) {\n                    my $d = s.d || die \"confuse\";\n                    d.od.s.T.q->{d.e.k} ||= $d;\n                    d.od.s.T.m->{d.e.k} ||= $d\n                        unless delete(T.noTd);\n                }\n                else { die\"utrowhat \".wdump 2, $ut }\n            }\n    \n            # outwave: schools of many fish (not upcv if !@is)\n            o.vb ||= o.vc if D.sc.v;\n    \n            last if T.not || T.whack;\n        }\n        delete T.ut;\n        last if T.not || T.whack;\n    }\n};\n"
      sc: 
        acgt: o,x,xrd
        args: A,C,G,T,o,x,xrd
        code: I 1
        dige: b15d585bb0fa
        gro: KowTime
        l: "#c"
      t: exood
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/KowTime/KowTime
    hash: 
      c: 
        el: 1
        s: "A.I.hash = sub {\n    my ($A,$C,$G,$T,$s) = @_;\n    my $I = A.I;\n    return %$C = %$s if exists s.t && s.y && s.c;\n    # some talking to self - how to C over exactly\n    # the object could be live\n    I.d&servehash,$s;\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 6a85bb9d5fac
        gro: EatSlide
      t: hash
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/EatSlide/EatSlide
    renc: 
      c: 
        el: 1
        s: "A.I.renc = sub {\n    my ($A,$C,$G,$T,$s) = @_;\n    my $I = A.I;\n    C.c = C.c =~ I.peels ? I.d&peel,C.c\n      : {s => C.c};\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 70d3395e3103
        gro: EatSlide
      t: renc
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/EatSlide/EatSlide
    rensc: 
      c: 
        el: 1
        s: "A.I.rensc = sub {\n    my ($A,$C,$G,$T,$s) = @_;\n    my $I = A.I;\n    C.sc = C.sc eq '' ? {}\n        : C.sc =~ I.peels\n        ? I.d&peel,C.sc\n        : die \"C sc nostr: C.sc   of I.peels  \".ki $C\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 00604d1227d3
        gro: EatSlide
      t: rensc
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/EatSlide/EatSlide
    reny: 
      c: 
        el: 1
        s: "A.I.reny = sub {\n    my ($A,$C,$G,$T,$s) = @_;\n    my $I = A.I;\n    $_ = C.y;\n    C.y = C.y eq '' ? (I.blanky ? I.d&blanky : {})\n        : /^($NUM)$/ ? {cv=>$1}\n        : /^($NUM)-($NUM)$/ ? {in=>$1,out=>$2}\n        : /^($NUM)-($NUM)x($NUM)$/ ? {in=>$1,out=>$2,thi=>$3}\n        :/^([WJ])$/ ? do {\n            C.c->{$1} = C.t;\n            {};\n        }\n        : I.rey ? I.d&rey\n        : die \"C y wtf: C.y\";\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 3e0e3b996006
        gro: EatSlide
      t: reny
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/EatSlide/EatSlide
    scyvle: 
      c: 
        el: 1
        s: "A.I.scyvle = sub {\n    my ($A,$C,$G,$T,$s) = @_;\n    my $I = A.I;\n    for (qw'in out cv') {\n        if (my $so = C.y->{$_}) {\n            my $i;\n            while (C.y->{$_} <= -1 || C.y->{$_} >= 1) {\n                C.y->{$_} /= 10;\n                die \"Many i chewing on \".ki C.y if $i++ > 10;\n            }\n        }\n    }\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 54ae8b834d07
        gro: EatSlide
      t: scyvle
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/EatSlide/EatSlide
    string: 
      c: 
        el: 1
        s: "A.I.string = sub {\n    my ($A,$C,$G,$T,$s) = @_;\n    my $I = A.I;\n    die \"string: $s\";\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 70331f91486a
        gro: EatSlide
      t: string
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/EatSlide/EatSlide
  "0.12": 
    Ci: 
      c: 
        el: 1
        s: "A.I.Ci = sub {\n    my ($A,$C,$G,$T,$s) = @_;\n    my $I = A.I;\n    !ref $s ? I.d&string,$s\n    :\n    ref $s eq 'ARRAY' ? I.d&array,$s\n    :\n    ref $s eq 'HASH' ? I.d&hash,$s\n    :\n    die \"mmtype:$s\";\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: I 12
        dige: 8321990636a8
        gro: EatSlide
        its: 1
      t: Ci
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/EatSlide/EatSlide
  "0.18": 
    reasonlock: 
      c: 
        el: 1
        s: "A.I.reasonlock = sub {\n    my ($A,$C,$G,$T,$s) = @_;\n    my $I = A.I;\n    die\"reft\" if ref C.t;\n    # uis a nested wave\n    # allow much manufold\n    # knot this not this:\n    if (A.J.name eq 'qq' || A.J.most.J eq A.J) {\n        C.c.W = C.t unless C.c || C.sc || C.y;\n    }\n    \n    I.d&renc if !ref C.c;\n    I.d&reny if !ref C.y;\n    I.d&rensc if !ref C.sc;\n    defined C.t && !ref C.t\n    && ref C.y && ref C.c && ref C.sc\n        || die \"reaso fail\".wdump $C;\n    I.d&scyvle;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: I 18
        dige: 195466d872ec
        gro: EatSlide
        its: 1
      t: reasonlock
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/EatSlide/EatSlide
