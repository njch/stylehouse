--- 
I: 
  "0.1": 
    Cngk: 
      c: 
        el: 1
        s: "A.I.Cngk = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($s,$D,@Me) = @M;\n    my $I = A.I;\n    ref $A || die \"nmonref A!\";\n    aft { $@ .= \"\\nLookat: \".ki($s).\"\\nWith: \".ki($D) if $@ };\n    return 1 if D.c.any;\n    die \"nonNKnk\".ki$D if !D.c.nk;\n    return 0 if !exists $s->{D.c.nk};\n    return [$s->{D.c.nk}] if !exists D.c.gk;\n    return 0 if !exists $s->{D.c.nk}->{D.c.gk};\n    return [$s->{D.c.nk}->{D.c.gk}];\n};\n"
      sc: 
        acgt: s,D
        args: A,C,G,T,s,D
        code: I 1
        dige: 1ce95658c144
        gro: C
      t: Cngk
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    c: 
      c: 
        el: 1
        s: "A.I.c = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($D,@Me) = @M;\n    my $I = A.I;\n    I.d&inDin,$C,@M;\n};\n"
      sc: 
        acgt: D
        args: A,C,G,T,D
        code: I 1
        dige: a931936381c2
        gro: C
      t: c
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    e: 
      c: 
        el: 1
        s: "A.I.e = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($D,@Me) = @M;\n    my $I = A.I;\n    I.d&inDin,C.c.e,@M;\n};\n"
      sc: 
        acgt: D
        args: A,C,G,T,D
        code: I 1
        dige: 06747ef15695
        gro: C
      t: e
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    fourreal: 
      c: 
        el: 1
        s: "A.I.fourreal = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    (C.t, C.y) = @$s;\n    C.c  = $s->[2] if exists $s->[2];\n    C.sc = $s->[3] if exists $s->[3];\n    die'@>4'.wdump $s if @$s > 4;\n    die\"C.t from \".wdump $s if ref C.t; # dives\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 87baea0c56c8
        gro: C
      t: fourreal
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    fourstring: 
      c: 
        el: 1
        s: "A.I.fourstring = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    I.d&MZu,$1 if $s =~ /^\\s*#?\\s*MZ (.+)$/;\n    $s =~ s/^\\s+//;\n    if ($s =~ /^\\s*(#.*)$/) {\n       T.not = 1;\n       T.com = $1;\n    }\n    elsif ($s eq '') {\n       T.not = T.space = 1;\n    }\n    else {\n       my $ci = $s;\n       for my $nk (qw't y c sc') {\n           if ($ci =~ s/^(\\S+) *//) { # some t are types of space\n               my $v = $1;\n               $v = I.d&peel,$v if $nk ne 't' && $v =~ I.peels;\n               # << consumes more lines into $nk, then ...\n               $v = '' if $v =~ /^(''|\"\")$/;\n               $C->{$nk} = $v;\n           }\n       }\n    }\n    saybl \"4string: $s            \".ki $C if A.V&C;\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: dbd7f1097b0d
        gro: C
      t: fourstring
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    hup: 
      c: 
        el: 1
        s: "A.I.hup = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $CC = {%$s};\n    $CC->{$_} = {%{$CC->{$_}}} for grep {ref $CC->{$_} eq 'HASH'} keys %$CC;\n    $CC;\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 2bc362811316
        gro: C
      t: hup
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    inDin: 
      c: 
        el: 1
        s: "A.I.inDin = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($s,$D,@Me) = @M;\n    my $I = A.I;\n    die'nofA' if !I.nF.A;\n    #\n    return () unless defined $s;\n    return $s if $D eq 'C';\n    #\n    shift @M; # s\n    $D = I.d&interpD,@M if !ref $D;\n    #\n    my $v = I.d&Cngk,$s,$D;\n    #\n    return () unless $v;\n    # blankgk\n    A.note->{D.c.nk}->{D.c.gk} = $v if A.note;\n    #\n    die 'mulitAn' if @$v > 1;\n    if (D.c.as eq 'list') {\n        ref $v eq 'ARRAY' || die 'Cngk not array';\n        return @$v;\n    }\n    return 1;\n};\n"
      sc: 
        acgt: s,D
        args: A,C,G,T,s,D
        code: I 1
        dige: bc7f2cfdcb5f
        gro: C
      t: inDin
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    interpD: 
      c: 
        el: 1
        s: "A.I.interpD = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($nk,$gk,@Me) = @M;\n    my $I = A.I;\n    my $defnk = 'c';\n    return $nk if ref $nk;\n    my $D = {};\n    D.c.as = 'list' if 1 || $nk =~ s/^_//;\n    while ($gk =~ s/^%(.+?):(.+?)(?=%|$)//g) {\n        D.c->{$1} = $2;\n        pop @M if @M == 2;\n    }\n    if (@M == 1 && $nk eq 't') {\n        D.c.nk = $nk;\n    }\n    elsif (@M == 1) { # or from t,,,\n        D.c.nk ||= $defnk;\n        D.c.gk ||= $nk;\n    }\n    elsif (@M == 2) {\n        D.c.nk = $nk;\n        D.c.gk = $gk;\n    }\n    delete D.c.gk if D.c.gk eq 'NOGK';\n    $D\n};\n"
      sc: 
        acgt: nk,gk
        args: A,C,G,T,nk,gk
        code: I 1
        dige: 688db989ec06
        gro: C
      t: interpD
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    mkD: 
      c: 
        el: 1
        s: "A.I.mkD = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($pin,$ar,@Me) = @M;\n    my $I = A.I;\n    my $D;\n    D.point = $pin;\n    if (my $C = ar.__D) {\n        delete ar.__D;\n        D.bab = C.c.s || die \"N s\".ki $C;\n        D.noise .= C.sc.dige if C.sc.dige;\n        D.babnon = 1 if C.sc.bab eq 'non';\n        D.Verb = 1;\n    }\n    D.ar = $ar;\n    D.name = join ' ', D.point, sort keys %{D.ar};\n    D.sign = \"Z\";\n    D.talk = join' ',grep{defined}map{$D->{$_}}qw'sign name noise';\n    $D;\n};\n"
      sc: 
        acgt: pin,ar
        args: A,C,G,T,pin,ar
        code: I 1
        dige: 974b297c1911
        gro: Goodat
      t: mkD
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Goodat/Goodat
    peel: 
      c: 
        el: 1
        s: "A.I.peel = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    $s =~ s/^%// || \n        $s =~ s/^{// && $s =~ s/}$//\n        || die \"unpealable $s\";\n    my $c;\n    for (split ',', $s) {\n        my ($k, $v) = split ':', $_, 2;\n        $v = 1 if !defined $v;\n        $c->{$k} = $v;\n    }\n    $c||{}\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 86d02e052c88
        gro: C
      t: peel
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    peels: 
      c: 
        el: 1
        s: "A.I.peels = (sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    qr/^[\\{\\%]/;\n})->($A,$C,$G,$T);\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 2cef197e1b39
        gro: C
        subpeel: 1
      t: peels
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    pin: 
      c: 
        el: 1
        s: "A.I.pin = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($pin,$way,@Me) = @M;\n    my $I = A.I;\n    I.pwin || die \"nopwin from pin\";\n    I.pwin->($pin,$way);\n};\n"
      sc: 
        acgt: pin,way
        args: A,C,G,T,pin,way
        code: I 1
        dige: 82803a8c20f2
        gro: Goodat
      t: pin
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Goodat/Goodat
    pwin: 
      c: 
        el: 1
        s: "A.I.pwin = sub {\n    my ($pin,$way,@Me) = @_;\n    my $I = A.I;\n    return $way->{$pin} if exists $way->{$pin};\n    my @path = split /\\/|\\./, $pin;\n    my $h = $way;\n    for my $p (@path) {\n        $h = $h->{$p};\n        unless ($h) {\n            undef $h;\n            last;\n        }\n    }\n    return $h if defined $h;\n    \n    return undef unless $pin =~ /\\*/;\n    die \"sat rs findy $pin\";\n};\n"
      sc: 
        acgt: s
        args: pin,way
        code: I 1
        dige: cc43f0214875
        gro: Goodat
      t: pwin
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/Goodat/Goodat
    us: 
      c: 
        el: 1
        s: "A.I.us = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($D,@Me) = @M;\n    my $I = A.I;\n    my $E = C.c.e || return ();\n    push @M, 'NOGK' if @M == 1;\n    I.d&inDin,E.c.us,@M;\n};\n"
      sc: 
        acgt: D
        args: A,C,G,T,D
        code: I 1
        dige: 0cdebb6cbbf0
        gro: C
      t: us
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
    xot: 
      c: 
        el: 1
        s: "A.I.xot = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($s,$c,@Me) = @M;\n    my $I = A.I;\n    while (my($k,$v) = each %$c) {\n        $s->{$k} = ref $v ? {%{$s->{$k}||{}}, %$v} : $v;\n    }\n    $s\n};\n"
      sc: 
        acgt: s,c
        args: A,C,G,T,s,c
        code: I 1
        dige: f8940275bf17
        gro: C
      t: xot
      "y": 
        cv: '0.3'
        cvt: 0.3	C.t
        p: qq/C/C
J: 
  "0.6211": 
    J_6211: 
      c: 
        el: 1
        s: "A.I.J_6211 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    return if exists C.c.pi;\n    \n    if (A.ztime < 9) {\n        if (A.jr&bol) {\n            sayre \"STOPPING \".ki($C) for 1..3;\n            # TODO stop\n        }\n        A.bangdesk.aft.unblocknine = A.jr&bol,9;\n    }\n    A.bangdesk.bang.bang_ts = sub {\n        A.jr&bang_ts,hitime\n    };\n    \n    C.c.pin = J.name;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: J 6211
        dige: 613d690d5559
        gk: J
        gro: Jiterbug
        nk: c
        v: cJ
      t: J_6211
      "y": 
        cv: '0.6211'
        cvt: 0.6211	C.t
        p: qq/Jiterbug/Jiterbug
  "0.6212": 
    J_6212: 
      c: 
        el: 1
        s: "A.I.J_6212 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    return unless exists C.c.pi;\n    \n    die'csnod' if $C ne J.C;\n    J.cv = (C.c.gp && C.c.gp.cv) || C.c.cv || 0.6;\n    my $path = C.sc.pi||die'nopi';\n    if (J.A.d > 9) {\n        $path = 'text';\n        warn \"J.name J.A.d limit to text\";\n    }\n    C.c.pin = \"pi/$path\";\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: J 6212
        dige: dd3968d99abd
        gk: J
        gro: Jiterbug
        nk: c
        v: cJ
      t: J_6212
      "y": 
        cv: '0.6212'
        cvt: 0.6212	C.t
        p: qq/Jiterbug/Jiterbug
  "0.631": 
    J_631: 
      c: 
        el: 1
        s: "A.I.J_631 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    A.coi = I.d&pha,$J,'ako';\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: J 631
        dige: 59b0dc2b2481
        gk: J
        gro: Jiterbug
        nk: c
        v: cJ
      t: J_631
      "y": 
        cv: '0.631'
        cvt: 0.631	C.t
        p: qq/Jiterbug/Jiterbug
  "0.632": 
    J_632: 
      c: 
        el: 1
        s: "A.I.J_632 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    return unless exists C.sc.pi;\n    \n    map { # telephone winch, propaganda (top-er levels receiving stuff)\n         J.A->{$_} = J.Jiter.A->{$_}\n         if J.Jiter && J.Jiter.A->{$_};\n    } qw'ljm ljmo';\n    \n    A.time = sub {\n        my($JJ,$q) = @_;\n        $J eq $JJ || die \"wtfJure  J.name   vs JJ.name\";\n        # wanna A.t&T,2,0 us to difference streams\n        # they could be xot maps or code to run\n        # then all over things \n    \n        if ($q == 2) {\n            Rw Jamroot $J $C:J.C $y:J.oy if J.oy.at;\n    \n            A.ico = I.d&pha,$J,'ico';\n            A.ico.qui = 1;\n            I.d&as,A.ico,A.coi;\n            my $wtf = I.d&exactl,A.ico;\n    \n            if (wtf.last && !wtf.same) {\n                my $uf = join \"\\n\", map{\"$_: \".wdump(1,$wtf->{$_})}\n                    grep {keys %{$wtf->{$_}}} qw'new diff gone';\n                saybl \"T.alk  2222  $uf\";\n            }\n    \n            Rw eighthnot $J\n             ? do { A.ico.wtf.same = 0; }\n             : wtf.same && return 0;\n    \n            # for jamcs screenfly\n            J.A.ljm = [];\n            J.A.ljmo = \"fr  J.name\";\n            return 1;\n        }\n    \n        warn \"T.alk other $q\";\n        if ($q == 8) {\n            # until J.most coord attention evaporates\n            # as in pulling on a list\n        }\n        A.ztime >= $q;\n    };\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: J 632
        dige: 14e6ed2f7f36
        gk: J
        gro: Juperfi
        nk: c
        v: cJ
      t: J_632
      "y": 
        cv: '0.632'
        cvt: 0.632	C.t
        p: qq/Juperfi/Juperfi
  "0.66": 
    J_66: 
      c: 
        el: 1
        s: "A.I.J_66 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    my $M = [];\n    my $y = {o=>$M};\n    my $ar = {%{C.c}};\n    #sayre \"no ars\" if !exists ar.s;\n    ar.s = '' if !exists ar.s;\n    ar.u = ar.s;\n    ar.pin = C.c.pin || die \"nopin\";\n    J.oy = $y;\n    \n    Rw ar.pin + $A $C $G $T $J $M $y;\n    # set our C.c.s to [that], noise probe case, maybe\n    if (@$M) {\n        n z=>$y=>{}\n    }\n    Rw Jamroot $C $J $y if y.at;\n    # T may cause big recoil of Mo/J, miss pha closures:\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: J 66
        dige: 46fbb85075f6
        gk: J
        gro: Jiterbug
        nk: c
        v: cJ
      t: J_66
      "y": 
        cv: '0.66'
        cvt: 0.66	C.t
        p: qq/Jiterbug/Jiterbug
  "0.672": 
    J_672: 
      c: 
        el: 1
        s: "A.I.J_672 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    return unless A.ico && A.ico.wtf.same;\n    # first the superstilled\n    # anything T_D can arrange through time...\n    # wants to join G subtly vis T and so....\n    # should be no M in the first bit\n    # it is just pinpricks of consciousness keeping it alive, like mtime\n    # be nicer to do with an I that can T out of this whole change res patch\n    my $cut = @{A.ico.ord};\n    my @cc = @{A.coi.ord};\n    if (@cc > $cut) {\n        warn\"J.name entered stuff after 2!\".wdump [@cc, \n        '                 =============', @{A.ico.ord}];\n    }\n    I.d&bandon,A.coi;\n    if (my $ljm = J.A.ljm) {\n        for my $s (@$ljm) {\n            s.noR=1;\n            I.d&jamsc,$s;\n        }\n    }\n    sayre \"SKIP T.alk\";# if J.V || J.most.J.V;\n    T.whack = 1; # exit A.t&J\n    T.same = 1; # exit Mo, T.not but not, kind of unlet ztime6->7\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: J 672
        dige: 8a8f5c43f7ab
        gk: J
        gro: Juperfi
        nk: c
        v: cJ
      t: J_672
      "y": 
        cv: '0.672'
        cvt: 0.672	C.t
        p: qq/Juperfi/Juperfi
  "0.677": 
    J_677: 
      c: 
        el: 1
        s: "A.I.J_677 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    if (J.oy.ope) {\n        sayyl \"Leaving J.name open pha...\" if A.V&ope;\n        I.d&end,A.coi;\n        return;\n    }\n    A.coi.qui = 1;\n    my $wt = I.d&exactl,A.coi;\n    if (wt.same) {\n        if (++J.A.wch > 4) {\n            J.A.wch = 0;\n            # ^ rate to avoid v see J 632 eighthnot\n        }\n        else {\n           sayre \"SAME T.alk\" if A.V&SAME;\n           T.same = 1;\n        }\n    }\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: J 677
        dige: fe51018f11a7
        gk: J
        gro: Jiterbug
        nk: c
        v: cJ
      t: J_677
      "y": 
        cv: '0.677'
        cvt: 0.677	C.t
        p: qq/Jiterbug/Jiterbug
