--- 
I: 
  "0.1": 
    Cngk: 
      c: 
        el: 1
        s: "A.I.Cngk = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($s,$D,@Me) = @M;\n    my $I = A.I;\n    ref $A || die \"nmonref A!\";\n    A.bangdesk.bang->{Cngek} = sub {\n        sayre \"was Cngk; \".ki($s).\"\\nWith: \".ki($D)\n    } if 0;\n    return 1 if D.c.any;\n    die \"nonNKnk\".ki$D if !D.c.nk;\n    return 0 if !exists $s->{D.c.nk};\n    return [$s->{D.c.nk}] if !exists D.c.gk;\n    return 0 if !exists $s->{D.c.nk}->{D.c.gk};\n    return [$s->{D.c.nk}->{D.c.gk}];\n};"
      sc: 
        acgt: s,D
        args: A,C,G,T,s,D
        code: I
        dige: 9eff494e71da
        gro: C
      t: Cngk
      "y": 
        cv: '0.1'
    NM: 
      c: 
        el: 1
        s: "A.I.NM = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($J,@Me) = @M;\n    my $I = A.I;\n        my $M = [];\n        my $N = [@Me];\n        $J->{m}->($M, $N);\n        return $M;\n};"
      sc: 
        acgt: J
        args: A,C,G,T,J
        code: I
        dige: 42d1e398a2a7
        gro: Motion
      t: NM
      "y": 
        cv: '0.1'
    ar: 
      c: 
        el: 1
        s: "A.I.ar = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n        my $ar;\n        $ar->{A}=$A;$ar->{G}=$G;$ar->{C}=$C;$ar->{T}=$T;$ar->{I}=$I;\n        $ar;\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: fde161a1fcf1
        gro: Motion
      t: ar
      "y": 
        cv: '0.1'
    c: 
      c: 
        el: 1
        s: "A.I.c = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($D,@Me) = @M;\n    my $I = A.I;\n    I.d&inDin,$C,@M;\n};"
      sc: 
        acgt: D
        args: A,C,G,T,D
        code: I
        dige: 13a11e8517fe
        gro: C
      t: c
      "y": 
        cv: '0.1'
    carebowl: 
      c: 
        el: 1
        s: "A.I.carebowl = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($s,$iii,$x,$xrd,@Me) = @M;\n    my $I = A.I;\n    for my $ik (sort keys %$iii) {\n        my $D = $iii->{$ik};\n        if (my $nk = D.sc.nk) {\n            my $C = I.nF.C;\n            next if !exists $C->{$nk};\n            if (my $gk = D.sc.gk) {\n                next if !exists $C->{$nk}->{$gk};\n            }\n        }\n        my $act;\n        my $dont;\n        if (D.sc.acgt && D.sc.act) {\n            $act = 1;\n            # acgtsubs can be defined at any cv\n            # run themselves if act\n            # usu. one receiver (Ci) and the rest scheme\n            die \"D.t .act gets... D.sc.act\" if D.sc.act ne '1';\n            $dont = 1 if exists A.I->{D.t};\n        }\n        if (!$dont && D.sc.eg) {\n            $dont = I.d&robeg,$D;\n        }\n        # the D.s should be perl expecting ACGT (which become robes to rob)\n        if (!$dont) {\n            my $paw = join\"_\",'',I.k,I.cv,D.t;\n            $paw =~ s/\\W//g;\n            Rw $paw $A $C $G $T $__D:D;\n        }\n        # most tiny ticks\n        # this ind is all flywheel\n        # it's a kind of unity that wants to be a block of code like this\n        # and c\n        my @is = A.s;\n        @is = I.d&scIfs,D.sc.Ifs if D.sc.Ifs;\n        @is || next;\n        if ($act) {\n            push @$xrd, [I.k,$ik];\n            my $Ds = $x->{I.k}->{$ik} ||= {};\n            Ds.D = $D;\n            Ds.is = \\@is;\n            D.sc.its = @is;\n        }\n        # TreeD\n        $s->{I.k}->{I.cv}->{$ik} = $D;\n    }\n};"
      sc: 
        acgt: s,iii,x,xrd
        args: A,C,G,T,s,iii,x,xrd
        code: I
        dige: 8e75568d0fe9
        gro: KnowTime
        l: "#c"
      t: carebowl
      "y": 
        cv: '0.1'
    e: 
      c: 
        el: 1
        s: "A.I.e = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($D,@Me) = @M;\n    my $I = A.I;\n    my $e = I.d&sces,C.c.e||return();\n    I.d&inDin,$e,@M;\n};"
      sc: 
        acgt: D
        args: A,C,G,T,D
        code: I
        dige: a5bd3ac85457
        gro: C
      t: e
      "y": 
        cv: '0.1'
    ex: 
      c: 
        el: 1
        s: "A.I.ex = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($i,$K,$cv,$av,@Me) = @M;\n    my $I = A.I;\n    # was Rw SNat $A $C $G $T $I $i $K $cv;\n    # baseism\n    my $c = 0+(\"0.\".$cv);\n    my $Av = $av || A.cv;\n    my $sp = $av ? \" Flav $av (no A.cv)\" : \"\";\n    \n    my $talk = \"A.talk: $K$sp $Av > $c --- C.t \";\n    \n    my $aim = {$K=>1};\n    if ($aim->{A.am}) {\n        $aim->{$_} = 1 for @{A.Isl||[]};\n        aim.I = 1;\n    }\n    \n    my $yv = {};\n    # make K/cv/t -> cv/K/t\n    for my $k (sort keys %$i) {\n        my $ii = $i->{$k};\n    \n        next if $k eq 'Ii';\n        next if $k eq 'ooI';\n        ref $ii eq 'HASH' || die \"weird $k=$ii\";\n    \n        for my $vc (sort keys %$ii) {\n            my $iii = $ii->{$vc};\n            die'$k !0<$vc<1' unless $vc > 0 && $vc < 1;\n            $yv->{$vc}->{$k} = $iii;\n        }\n    }\n    \n    # do stuff\n    my $vb; # in fractions\n    my $wasSubtle;\n    for my $vc (sort keys %$yv) {\n        my $is = $yv->{$vc};\n        my $s = {};\n        my $x = {};\n        my $xrd = [];\n    \n        next if $vc <= $Av && $vc != $c;\n        next if $vc > $c;\n    \n        # our  osc (stay in K per Subtle ness);\n        my @iz = grep {\n            $aim->{$_} || (aim.I && (A.Iso->{$_} || I.also->{$_}))\n        } sort keys %$is;\n        next if !@iz;\n    \n        # decide inter cv wideness loop\n        if ($wasSubtle) {\n            undef $wasSubtle;\n        }\n        elsif ($vb && $vc > $vb && (\n            @{A.N} || @{A.mo.re->{$vb}||[]}\n            )) {\n            # sincing, wide order\n            # various others want to be around for only some of the process...\n            sayre \"$vb -> $vc  bump, \". @{A.N} if A.J.V > 1;\n            T.Z->{$vb} = 1;\n            A.cv = $vb; # so we dont wind up to 6 on the way out of t\n            return T.not = 1;\n        }\n    \n        # pin down poles\n        I.cv = $vc;\n        I.vb = $vb;\n        # draw curvles as spirals done\n    \n        for my $k (@iz) {\n            my $iii = $is->{$k};\n            I.k = $k;\n            I.d&carebowl,$s,$iii,$x,$xrd;\n        }\n        # suble\n        my $se = Rw TreeD $s $scby=gro \n            if A.J.V > 1 && keys %$s;\n        $c == 0.1 ? saygr $se : say $se if $se;\n    \n        my $o;\n        (o.vc,o.vb) = ($vc,$vb);\n        I.d&exood,$o,$x,$xrd;\n        ($vc,$vb) = (o.vc,o.vb);\n        if (o.Subtle && !o.nonSubtle) {\n            $wasSubtle = 1;\n        }\n    \n        return if T.not;  # will &z, oseve\n        return if delete T.whack;\n    }\n};"
      sc: 
        acgt: i,K,cv,av
        args: A,C,G,T,i,K,cv,av
        code: I
        dige: e83fa1cf7861
        gro: KnowTime
        nois: "#c"
      t: ex
      "y": 
        cv: '0.1'
    exood: 
      c: 
        el: 1
        s: "A.I.exood = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($o,$x,$xrd,@Me) = @M;\n    my $I = A.I;\n    for my $kik (@$xrd) {\n        my ($k,$ik) = @$kik;\n        A.Subtle && A.Subtle->{$k} ? o.Subtle++ : o.nonSubtle++;\n        my $Ds = $x->{$k}->{$ik};\n        my $D = Ds.D;\n        for my $s (@{Ds.is}) {\n            D.sc.acgt eq 's'||die \"nonacgts\".wdump $D;\n            exists A.I->{D.t}||die \"acgtI D.t not up: \".wdump A.I;\n    \n            T.D = $D;\n            I.d&D.t,$s;\n    \n            if (my $ut = T.ut) {\n                if (ut.matchTd) {\n                    my $d = s.d || die \"confuse\";\n                    d.od.s.T.q->{d.e.k} ||= $d;\n                    d.od.s.T.m->{d.e.k} ||= $d\n                        unless delete(T.noTd);\n                }\n                else { die\"utrowhat \".wdump 2, $ut }\n            }\n    \n            # outwave: schools of many fish (not upcv if !@is)\n            o.vb ||= o.vc if D.sc.v;\n    \n            last if T.not || T.whack;\n        }\n        delete T.ut;\n        last if T.not || T.whack;\n    }\n};"
      sc: 
        acgt: o,x,xrd
        args: A,C,G,T,o,x,xrd
        code: I
        dige: 23703206c8e8
        gro: KnowTime
        l: "#c"
      t: exood
      "y": 
        cv: '0.1'
    flywheels: 
      c: 
        el: 1
        s: "A.I.flywheels = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n        # wants to be a six alwayser... ,{code=>'I 6',act=>'all'} # $II->{All}? $II->{Fly}?\n        # its $I->{d}->(\"nded\") and holds things to code, $v a spiral it's filling up\n        # $v could be mounted... aj8 mysteries\n        for my $k (sort keys %{$A->{fl}}) {\n            my $v = $A->{fl}->{$k};\n            #   ^ bus to ride\n            $k = $2 if $k =~ /^(\\d+) (.+)$/;\n            $G->{w}->(\"ym/$k\", {I => $I, J => $A->{J}, A => $A, C => $C, v => $v, G => $G, T => $T}, $G);\n        }\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: c2c034abed60
        gro: Motion
      t: flywheels
      "y": 
        cv: '0.1'
    fourreal: 
      c: 
        el: 1
        s: "A.I.fourreal = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    (C.t, C.y) = @$s;\n    C.c  = $s->[2] if exists $s->[2];\n    C.sc = $s->[3] if exists $s->[3];\n    die'@>4'.wdump $s if @$s > 4;\n    die\"C.t from \".wdump $s if ref C.t; # dives\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 6f121968bdaf
        gro: C
      t: fourreal
      "y": 
        cv: '0.1'
    fourstring: 
      c: 
        el: 1
        s: "A.I.fourstring = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    I.d&MZu,$1 if $s =~ /^\\s*#?\\s*MZ (.+)$/;\n    $s =~ s/^\\s+//;\n    if ($s =~ /^\\s*(#.*)$/) {\n       T.not = 1;\n       T.com = $1;\n    }\n    elsif ($s eq '') {\n       T.not = T.space = 1;\n    }\n    else {\n       my $ci = $s;\n       for my $nk (qw't y c sc') {\n           if ($ci =~ s/^(\\S+) *//) { # some t are types of space\n               my $v = $1;\n               $v = I.d&peel,$v if $nk ne 't' && $v =~ I.peels;\n               # << consumes more lines into $nk, then ...\n               $v = '' if $v =~ /^(''|\"\")$/;\n               $C->{$nk} = $v;\n           }\n       }\n    }\n    saybl \"4string: $s            \".ki $C if A.V&C;\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 690e449c7756
        gro: C
      t: fourstring
      "y": 
        cv: '0.1'
    hup: 
      c: 
        el: 1
        s: "A.I.hup = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $CC = {%$s};\n    $CC->{$_} = {%{$CC->{$_}}} for grep {ref $CC->{$_} eq 'HASH'} keys %$CC;\n    return $CC;\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 6acba1a53366
        gro: C
      t: hup
      "y": 
        cv: '0.1'
    inDin: 
      c: 
        el: 1
        s: "A.I.inDin = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($s,$D,@Me) = @M;\n    my $I = A.I;\n    die'nofA' if !I.nF.A;\n    #\n    return () unless defined $s;\n    return $s if $D eq 'C';\n    #\n    shift @M; # s\n    $D = I.d&interpD,@M if !ref $D;\n    #\n    my $v = I.d&Cngk,$s,$D;\n    saybl \"Got cnkgk: \".wdump 3,[\\@M,$D,$v,$s] if A.V&D;\n    die \"Unhandles any: $v: \".ki $D if $v eq '1';\n    #\n    return () unless $v;\n    # blankgk\n    A.note->{D.c.nk}->{D.c.gk} = $v if A.note;\n    #\n    @$v == 1 || die \"Many somehowed \".wdump 3,[ki($D),$v];\n    ($v) = @$v;\n    if (D.c.as eq 'list') {\n        ref $v eq 'ARRAY' || die 'Cngk for list not array '.ki $D;\n        return @$v;\n    }\n    return $v;\n};"
      sc: 
        acgt: s,D
        args: A,C,G,T,s,D
        code: I
        dige: 2ade69fc6a31
        gro: C
      t: inDin
      "y": 
        cv: '0.1'
    interpD: 
      c: 
        el: 1
        s: "A.I.interpD = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($nk,$gk,@Me) = @M;\n    my $I = A.I;\n    my $defnk = 'c';\n    return $nk if ref $nk;\n    my $D = {};\n    D.c.as = 'list' if $nk =~ s/^_//;\n    while ($gk =~ s/^%(.+?):(.+?)(?=%|$)//g) {\n        D.c->{$1} = $2;\n        pop @M if @M == 2;\n    }\n    if (@M == 1 && $nk eq 't') {\n        D.c.nk = $nk;\n    }\n    elsif (@M == 1) { # or from t,,,\n        D.c.nk ||= $defnk;\n        D.c.gk ||= $nk;\n    }\n    elsif (@M == 2) {\n        D.c.nk = $nk;\n        D.c.gk = $gk;\n    }\n    delete D.c.gk if D.c.gk eq 'NOGK';\n    $D\n};"
      sc: 
        acgt: nk,gk
        args: A,C,G,T,nk,gk
        code: I
        dige: 77817164178e
        gro: C
      t: interpD
      "y": 
        cv: '0.1'
    ip: 
      c: 
        el: 1
        s: "A.I.ip = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($s,$c,@Me) = @M;\n    my $I = A.I;\n    my $pass = 1;\n    for my $I (keys %$s) {\n        !ref $s->{$I} && $s->{$I} ne $c->{$I} && $pass--;\n        ref $s->{$I} eq 'HASH' && do {\n            if (my $not = $s->{$I}->{not}) {\n                $not eq 'def' && do {\n                    defined $c->{$I} && $pass--;\n                } \n                || $not eq $c->{$I} && $pass--;\n            }\n            else {\n                $s->{$I}->{$c->{$I}} eq '1' || $pass--;\n            }\n        };\n    }\n    $pass == 1\n};"
      sc: 
        acgt: s,c
        args: A,C,G,T,s,c
        code: I
        dige: ffe7f805a8ca
        gro: C
      t: ip
      "y": 
        cv: '0.1'
    moy: 
      c: 
        el: 1
        s: "A.I.moy = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n        # groups, spread the moise over A\n        my $i = $A->{mo}->{y}->{$s}||die\"no$s\";\n        my $is = $i->{$C->{y}->{p}}; # things in our C's pool\n        {is=>$is,N=>[map{$is->{$_}}sort keys %$is]};\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 1f468af4a039
        gro: Motion
      t: moy
      "y": 
        cv: '0.1'
    oseverato: 
      c: 
        el: 1
        s: "A.I.oseverato = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n        if ($T->{d}) {\n            $A->{T}->{d} = $T->{d}; # carte\n        }\n        if (my $z = delete $T->{Z}) { # tease out the next times\n            my ($lo) = sort keys %$z; # next one\n            my $v = $z->{$lo};\n            push @{$A->{mo}->{re}->{$lo} ||= []},\n                ref $v eq 'ARRAY' ? @$v :\n                $v ne '1' ? [$A,$C,$v] :\n                [$A,$C];\n            @{$T->{oM}} = ();\n        }\n        if (!@{$A->{mo}->{N}} && $A->{mo}->{re}) {\n            my $ats = $A->{mo}->{re} || {};\n            my @wa = sort keys %$ats;\n            my ($lo) = @wa;\n            if ($lo) {\n                my $ay = delete $ats->{$lo};\n                my @N = map { {AZ=>{$lo=>$_}} } @$ay;\n                push @{$A->{mo}->{N}}, @N;\n                saybl \"Looping \".@N.\" to $lo\" if $A->{J}->{V} > 1;\n            }\n        }\n        # concoi severaliser, for conglom up; merging spiral snips of code\n        if (my $y = $T->{y}) {\n            for my $k (keys %$y) {\n                $A->{mo}->{y}->{$k}->{$C->{y}->{p}}->{$C->{y}->{cvt}} = $C;\n            }\n        }\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 72c4cad60f0a
        gro: Motion
      t: oseverato
      "y": 
        cv: '0.1'
    peel: 
      c: 
        el: 1
        s: "A.I.peel = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    $s =~ s/^%// || \n        $s =~ s/^{// && $s =~ s/}$//\n        || die \"unpealable $s\";\n    my $c;\n    for (split ',', $s) {\n        my ($k, $v) = split ':', $_, 2;\n        $v = 1 if !defined $v;\n        $c->{$k} = $v;\n    }\n    $c||{}\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 4225a00dc1d6
        gro: C
      t: peel
      "y": 
        cv: '0.1'
    peels: 
      c: 
        el: 1
        s: "A.I.peels = (sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    qr/^[\\{\\%]\\w+/;\n})->($A,$C,$G,$T);"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 57ca10502053
        gro: C
        subpeel: 1
      t: peels
      "y": 
        cv: '0.1'
    sces: 
      c: 
        el: 1
        s: "A.I.sces = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $i = 0;\n    while (s.c.e) {\n        $s = s.c.e;\n        $i++ > 9 && die \"HUGE $i recursing CceCceCceCce... by \".ki $s;\n    }\n    return $s;\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 24170784f333
        gro: C
      t: sces
      "y": 
        cv: '0.1'
    t: 
      c: 
        el: 1
        s: "A.I.t = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($K,$cv,$av,@Me) = @M;\n    my $I = A.I;\n    ($K,$cv) = (A.am,$K) if !$cv && $K;\n    $av = 0+(\"0.\".$av) if $av;\n    die \"K$K cv$cv\" unless $K && $cv;\n    my $c = 0+(\"0.\".$cv);\n    my $Av = $av || A.cv;\n    \n    # adapt to much  mergey       extendo  rubble\n    my $i = Rw collaspII $A;\n    die'difAvcol' if $Av ne ($av || A.cv);\n    #\n    my $ncv;\n    my $re;\n    my $dont;\n    if ($Av < 0.6 || $c >= 0.7) {\n        if ($c >= $Av) {\n            $ncv = $c;\n            $re = 1;\n        }\n        else {\n            $re = 0;\n            $dont = 1;\n            say \" deInc $Av - $cv $c\";\n        }\n        die \"pre bigger\" if $cv < $Av;\n    }\n    else {\n        if ($c < $Av) {\n            if ($Av == 0.6) { # scoop up all on entering timezone\n                $re = 1;\n                $dont = 1; # or will II fall away\n            }\n            else {\n                $re = 0;\n                $dont = 1;\n            }\n        }\n        elsif ($c == $Av) {\n            $re = 1;\n        }\n        elsif ($c > $Av) { # and $c < 0.7, is a next time\n            T.Z->{$c} = 1;\n            $re = 0;\n            $dont = 1;\n        }\n        else {die\"nof\"}\n    }\n    undef $ncv if $av; # aux K\n    my $was = A.cv;\n    $dont || I.d&ex,$i,$K,$cv,$av;\n    A.cv = $ncv if defined $ncv && A.cv == $was;\n    $re;\n};"
      sc: 
        acgt: K,cv,av
        args: A,C,G,T,K,cv,av
        code: I
        dige: 2307b8c71873
        gro: KnowTime
        nois: "#c"
      t: t
      "y": 
        cv: '0.1'
    tlM: 
      c: 
        el: 1
        s: "A.I.tlM = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $os = $s;\n    $s = s.M if ref $s eq 'HASH';\n    ref $s eq 'ARRAY' || return \"S not N/M: \".wdump[$os];\n    Rw ZNews $N:s;\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: a7c065e9428f
        gro: Rings
        nov: 1
      t: tlM
      "y": 
        cv: '0.1'
    us: 
      c: 
        el: 1
        s: "A.I.us = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($D,@Me) = @M;\n    my $I = A.I;\n    my $e = I.d&sces,C.c.e||return();\n    my $us = e.c.us||return();\n    push @M, 'NOGK' if @M == 1;\n    I.d&inDin,$us,@M;\n};"
      sc: 
        acgt: D
        args: A,C,G,T,D
        code: I
        dige: 0b65428badf2
        gro: C
      t: us
      "y": 
        cv: '0.1'
    xot: 
      c: 
        el: 1
        s: "A.I.xot = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($s,$c,@Me) = @M;\n    my $I = A.I;\n    ref $c eq 'HASH' && ref $s eq 'HASH' ||\n        die \"Hash up\".wdump 3, [$s,$c];\n    while (my($k,$v) = each %$c) {\n        $s->{$k} = ref $v eq 'HASH' ?\n                    {%{$s->{$k}||{}}, %$v}\n        : ref $v ? \n            die \"Hash a ref v: \".wdump 2, $s\n        : $v;\n    }\n    return $s\n};"
      sc: 
        acgt: s,c
        args: A,C,G,T,s,c
        code: I
        dige: b2f78ed3ea3f
        gro: C
      t: xot
      "y": 
        cv: '0.1'
    xoy: 
      c: 
        el: 1
        s: "A.I.xoy = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($s,$c,@Me) = @M;\n    my $I = A.I;\n    $c = I.d&xot,{},$c;\n    I.d&xot,$c,$s;\n    return $s;\n};"
      sc: 
        acgt: s,c
        args: A,C,G,T,s,c
        code: I
        dige: 9f0e1bca6aff
        gro: C
      t: xoy
      "y": 
        cv: '0.1'
    z: 
      c: 
        el: 1
        s: "A.I.z = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n        $I->{d}->(\"oseverato\");\n        push @{$A->{M}}, @{$T->{oM}};\n        1\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 801e939dc5dc
        gro: Motion
      t: z
      "y": 
        cv: '0.1'
  "0.71": 
    CoM: 
      c: 
        el: 1
        s: "A.I.CoM = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n        push @{$T->{oM}}, $C unless $T->{Z};\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: I
        dige: 26e2f2108493
        gro: Motion
        its: 1
      t: CoM
      "y": 
        cv: '0.71'
J: 
  "0.6211": 
    J_6211: 
      c: 
        el: 1
        s: "A.I.J_6211 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    my $M = [];\n    my $y = {o=>$M};\n    my $qq = I.d&Elj,$J,'qq';\n    A.hqq = qq.A.hqq = I.d&pha,$qq,'hqq';\n    J.oy = $y;\n    J.at ||= G.tie->(Ghoz => {inp=>[qw'oy at'],o=>$J});\n    \n    return if exists C.c.pi;\n    \n    if (A.ztime < 9) {\n        if (A.jr&bol) {\n            sayre \"STOPPING \".ki($C) for 1..3;\n            # TODO stop\n        }\n        A.bangdesk.aft.unblocknine = A.jr&bol,9;\n    }\n    A.bangdesk.bang.bang_ts = sub {\n        A.jr&bang_ts,hitime\n    };\n    \n    C.c.pin = J.name;\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: J
        dige: 5000e7ffd741
        gk: J
        gro: Jiterbug
        nk: c
        v: cJ
      t: J_6211
      "y": 
        cv: '0.6211'
  "0.6212": 
    J_6212: 
      c: 
        el: 1
        s: "A.I.J_6212 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    return unless exists C.c.pi;\n    \n    die'csnod'.wdump 3, [$C, J.C] if $C ne J.C;\n    J.cv = (C.c.gp && C.c.gp.cv) || C.c.cv || 0.6;\n    my $path = C.sc.pi||die'nopi';\n    if (J.A.d > 9) {\n        $path = 'text';\n        warn \"J.name J.A.d limit to text\";\n    }\n    C.c.pin = \"pi/$path\";\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: J
        dige: 4c092f06cacb
        gk: J
        gro: Jiterbug
        nk: c
        v: cJ
      t: J_6212
      "y": 
        cv: '0.6212'
  "0.631": 
    J_631: 
      c: 
        el: 1
        s: "A.I.J_631 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    I.d&exactl,A.hqq;\n    A.coi = I.d&pha,$J,'ako';\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: J
        dige: 9fc77278c51d
        gk: J
        gro: Jiterbug
        nk: c
        v: cJ
      t: J_631
      "y": 
        cv: '0.631'
  "0.632114142": 
    J_632114142: 
      c: 
        el: 1
        s: "A.I.J_632114142 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    return if exists C.sc.pi;\n    A.time = sub {\n        my ($JJ,$q) = @_;\n        $J eq $JJ || die \"wtfJure  J.name   vs JJ.name\";\n        my $r = 1;\n        if ($q == 2) {\n            A.Subtle.time = 1;\n            A.t&time,3,19;\n            $r = 0 if T.pos == 0; # def 1, 0 if no change\n            return $r;\n        }\n    \n        warn \"T.alk other $q\";\n        if ($q == 8) {\n            # until J.most coord attention evaporates\n            # as in pulling on a list\n        }\n        $r\n    }\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: J
        dige: 8e58c05aa2c0
        gk: J
        gro: threJ
        nk: c
        v: cJ
      t: J_632114142
      "y": 
        cv: '0.632114142'
  "0.66": 
    J_66: 
      c: 
        el: 1
        s: "A.I.J_66 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    my $ar = {%{C.c}};\n    ar.s = '' if !exists ar.s;\n    ar.u = ar.s;\n    ar.pin = C.c.pin || die \"nopin\";\n    my $y = J.oy;\n    my $M = y.o;\n    \n    Rw ar.pin + $A $C $G $T $I $J $M $y;\n    \n    Rw Jamroot $J $y if y.at;\n    if (T.iM) {\n        J.Oy || die \"no JOy J.name\";\n        ref J.Oy.o eq 'HASH' || die \"J.name oYo not hash/picked up\";\n        ref J.Oy.o.M eq 'ARRAY' || die \"J.name oYoM not array\";\n        push @{J.oy.o}, @{J.Oy.o.M};\n    }\n    J.Oy = $y;\n    if (@$M) {\n        n z=>$y=>{}\n    }\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: J
        dige: 3e6fa37f448d
        gk: J
        gro: Jiterbug
        nk: c
        v: cJ
      t: J_66
      "y": 
        cv: '0.66'
  "0.677": 
    J_677: 
      c: 
        el: 1
        s: "A.I.J_677 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    if (J.oy.ope) {\n        sayyl \"Leaving J.name open pha...\" if A.V&ope;\n        I.d&end,A.coi;\n        return;\n    }\n    A.coi.qui = 1;\n    my $wt = I.d&exactl,A.coi;\n    if (wt.same) {\n        if (++J.A.wch > 4) {\n            J.A.wch = 0;\n            # ^ rate to avoid v see J 632 eighthnot\n        }\n        else {\n           sayre \"SAME T.alk\" if A.V&SAME;\n           T.same = 1;\n        }\n    }\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: J
        dige: ee25d6341689
        gk: J
        gro: Jiterbug
        nk: c
        v: cJ
      t: J_677
      "y": 
        cv: '0.677'
Mo: 
  "0.3211": 
    J_3211: 
      c: 
        el: 1
        s: "A.I.J_3211 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    C.c.W = $J unless ref C.c.W;\n    ref C.c.W || !ref $J || C.c.W eq J.name || die \"J.name isn't\".ki(C.c);\n    !ref C.c.W || !ref $J || C.c.W eq $J || die \"nzoWJ\".ki(C.c);\n    # avoid 6ing, its doubling orso\n    A.ztime = 3 if A.J.name ne 'qq'; # break off\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo
        dige: 6bbc28157895
        gk: J
        gro: Jlaces
        nk: c
        v: cJ
      t: J_3211
      "y": 
        cv: '0.3211'
  "0.3213": 
    pi_3213: 
      c: 
        el: 1
        s: "A.I.pi_3213 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $pi = C.c.pi;\n    # - c. language is map to some u before 6ing\n    ref $pi && die\"refpi: \".wdump 2, $pi;\n    C.sc.pi = $pi || 'guess';\n    C.c.J = 'pi';\n    my $oJ = A.J;\n    $oJ = C.y.o.J if C.y.o && C.y.o.J;\n    A.jr = Rw Ajr $J:oJ $C;\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo
        dige: 778fbc64c294
        gk: pi
        gro: Jlaces
        nk: c
        v: cpi
      t: pi_3213
      "y": 
        cv: '0.3213'
  "0.3214": 
    W_3214: 
      c: 
        el: 1
        s: "A.I.W_3214 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $W = C.c.W;\n    my $t = $W;\n    $t = W.name if ref $t;\n    my $jr = Rw Ajr $J:G.oin $t $cv=0.3;\n    \n    return C.c.W = die \"SOIDNG RESEAR(pi with W)\".  jr&J\n        if C.c.pi; # doing research\n    A.jr = $jr; # being\n    \n    C.sc.W = $t;\n    C.sc.J = ref $W ? $W : $t;\n    # going over J should be same...\n    C.c.J ||= $W;\n    C.t = $t;\n    C.y.cv ||= 0.3;\n    # and where the thrust (J.A?)\n    if (C.c.vv) {\n        A.ztime = delete C.c.vv;\n        A.jr&vv,'',9\n    }\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo
        dige: 64223e2a9d89
        gk: W
        gro: Jlaces
        nk: c
        v: cW
      t: W_3214
      "y": 
        cv: '0.3214'
  "0.341": 
    J_341: 
      c: 
        el: 1
        s: "A.I.J_341 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    my $f = A.jr&J;\n    my $j = C.sc.J;\n    ref $j && ref $f && ($j eq $f || die \".sc J dif $f $j\");\n    # hilum & tie sc so vis, substrate insecting\n    C.c.J = C.sc.J = $f if $f && ref $f && !f.dead;\n    A.Iso.oJ = 1; # getting pinned into J\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo
        dige: 0abe0dcd68e5
        gk: J
        gro: Joot
        nk: c
        v: cJ
      t: J_341
      "y": 
        cv: '0.341'
  "0.342": 
    X_342: 
      c: 
        el: 1
        s: "A.I.X_342 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $X = C.c.X;\n    my $J = C.sc.J;\n    sayre \"DELING J.name\".ki$C;\n    $J || die \"X no J\";\n    ref $J || die \"Nofound $J  C.t   C.y.cv\";\n    $X eq $J || die \"noovewr X  C.c.X ne $J\";\n    A.jr&J,$J,9;\n    J.dead = 1;\n    # SNat bail, we have balin by now so hole in space this time\n    T.not = 1;\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo
        dige: 266248ca3193
        gk: X
        gro: Joot
        nk: c
        v: cX
      t: X_342
      "y": 
        cv: '0.342'
  "0.436": 
    time_436: 
      c: 
        el: 1
        s: "A.I.time_436 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $time = C.c.time;\n    A.ztime = delete C.c.time;\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo
        dige: 24a569a40c8c
        gk: time
        gro: Jamping
        nk: c
        v: ctime
      t: time_436
      "y": 
        cv: '0.436'
oJ: 
  "0.343": 
    J_343: 
      c: 
        el: 1
        s: "A.I.J_343 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    return if ref $J;\n    $J = Rw Jto $name:J;\n    G.W->{J.id} && G.W->{J.id} ne $J && die \"runup J.name\";\n    G.W->{J.id} = $J;\n    ref $J || die 'watt'.$J;\n    if (exists C.c.pi) {\n        J.Jiter = A.J; # erse rev\n        J.most->{$_} = A.J.most->{$_} for keys %{A.J.most||{}};\n    }\n    # til the I train shows up:\n    J.V = J.most.J.inV || 1 if A.J.V == 2 || J.most.J.inV;\n    J.A.Indo = 2;\n    sayyl \"J33   Made J.name\" unless J.Jiter;\n    C.c.J = C.sc.J = $J;\n    A.jr&J,$J;\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: oJ
        dige: 4854f8e3663c
        gk: J
        gro: Joot
        nk: c
        v: cJ
      t: J_343
      "y": 
        cv: '0.343'
  "0.344": 
    J_344: 
      c: 
        el: 1
        s: "A.I.J_344 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    my $ins = sub { my $J = shift; $J ne J.mo.J ? \"J.mo.J.name ' J.name\" : J.name };\n    if (C.c.e) {\n        my $new = !J.A.first ? \"(first!)\":\"\";\n        say $ins->(A.J).\"   is elvising to  \".$ins->($J).\" $new\\n    \"\n            .\" C.t  \".ki(C.c).\"     \".ki(C.sc);\n        C.c.elv = delete C.c.e if $new;\n        # do over after osc (or time2 could in middle)\n        # donow, may wat\n        A.Iso.th = 1;\n    }\n    else {\n        A.J eq $J && die sayre \"THreJ does Celt A.J.name   \".(C.c.e && ki C.c.e);\n        #saybl $ins->(A.J).\" can create -----> \".$ins->($J);\n        if (J.ev.amb) {\n            my $ar = I.d&ar;\n            Rw J.ev.amb + $J;\n        }\n    }\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: oJ
        dige: b76df083f7b2
        gk: J
        gro: threJ
        nk: c
        v: cJ
      t: J_344
      "y": 
        cv: '0.344'
  "0.434": 
    J_434: 
      c: 
        el: 1
        s: "A.I.J_434 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    $J = C.c.J = C.sc.J;\n    J.name || die \"WNO \".wdump 4, $C;\n    # TODO: soft acuminy over \\d esp. until .bb or something\n    A.mo.Js->{J.name} = $J;\n    # A falls\n    # A.mo exits\n    # J.A persists\n    J.A.first ||= hitime();\n    if (C.sc.W && G.oin ne $J) {\n        my $lev = G.oin.A.tid;\n        if (J.A.tidi && (J.A.tidi + 3) > $lev) {\n            A.ztime ||= 4;\n        }\n        else {\n            J.A.tidi = $lev;\n        }\n    }\n    sayre \"same A.J.name inside J.name\" if A.J eq $J;\n    if (exists C.sc.pi) {\n        sayre \"JiternotAJ J.Jiter.name ne A.J.name\" if J.Jiter ne A.J;\n        die 'pimostJ'if J.most.J eq $J;\n    }\n    else {\n        die 'esel'.wdump [J.C, J.most.J.C] if J.most.J ne $J;\n    }\n    A.ztime ||= 6;\n    A.time && sayre \"Had atime\";\n    A.time = sub { # A.t& cover, serve single digit ad hocs, like 2\n        my ($JJ,$q) = @_; die\"JTIMEJ\" if $JJ ne $J;\n        A.ztime >= $q\n    };\n    if (C.sc.pi) {\n        J.A.d = J.Jiter.A.d + 1;\n        J.ind = join '  ', ('') x J.A.d;\n        J.name = \"J.A.d. C.c.pi*C.t\";\n        J.d = $C;\n        A.ztime = 6 if A.ztime < 6;\n    }\n    J.C = $C;\n    A.talk .= \" J: J.name\";\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: oJ
        dige: 0731e87e1351
        gk: J
        gro: Jamping
        nk: c
        v: cJ
      t: J_434
      "y": 
        cv: '0.434'
  "0.76": 
    elv_76: 
      c: 
        el: 1
        s: "A.I.elv_76 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $elv = C.c.elv;\n    my $J = C.c.J;\n    C.c.e = delete C.c.elv;\n    my $ar = I.d&ar;\n    J.VV.E = J.VV.V = 1;\n    Rw hevt + $J elv76;\n    if (T.oke) {\n        die \"76 thoughtself J.name\" if A.J eq $J;\n        say \"Tanking 76 into J.name\";\n        Rw waited $J;\n        return;\n    }\n    T.pos = 1 unless defined T.pos;\n    T.pos &&\n        Rw waito $J $C;\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: oJ
        dige: 8e2a5848a298
        gk: elv
        gro: threJ
        nk: c
        rg: J
        v: celv
      t: elv_76
      "y": 
        cv: '0.76'
th: 
  "0.36": 
    e_36: 
      c: 
        el: 1
        s: "A.I.e_36 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $e = C.c.e;\n    my $J = C.c.J;\n    $J || warn \"e no J\";\n    # no J being tricks for handulation, event energy, unless T.oke\n    delete A.Iso.oJ;\n    my $ar = I.d&ar;\n    Rw hevt + $J e36;\n    if (T.oke) {\n        die \"thoughts of a thous J.name\" if A.J eq $J;\n        delete A.Iso.th;\n        A.Iso.oJ = 1;\n        A.ztime = 6;\n        return say \"Tanking into J.name\";\n    }\n    T.pos = 1 unless defined T.pos;\n    T.pos &&\n        Rw waito $J $C;\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: th
        dige: 5b129781cdee
        gk: e
        gro: threJ
        nk: c
        rg: J
        v: ce
      t: e_36
      "y": 
        cv: '0.36'
  "0.4": 
    J_4: 
      c: 
        el: 1
        s: "A.I.J_4 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    return;\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: th
        dige: 41578b1024ce
        gk: J
        gro: threJ
        nk: c
        v: cJ
      t: J_4
      "y": 
        cv: '0.4'
  "0.769": 
    e_769: 
      c: 
        el: 1
        s: "A.I.e_769 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $e = C.c.e;\n    my $J = C.c.J;\n    T.oke = 1; # unpin\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: th
        dige: 41f691a92f98
        gk: e
        gro: threJ
        nk: c
        rg: J
        v: ce
      t: e_769
      "y": 
        cv: '0.769'
time: 
  "0.2": 
    elv_2: 
      c: 
        el: 1
        s: "A.I.elv_2 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $elv = C.c.elv;\n    my $J = C.c.J;\n    C.c.e = delete C.c.elv;\n    my $ar = I.d&ar;\n    Rw hevt + $J elv2;\n    #T.oke && warn \"NOTOKE time2 J.name\";\n    T.pos = 1 unless defined T.pos;\n    # time true, complete vector, unless we cat a list\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: time
        dige: f705c7eb3bd5
        gk: elv
        gro: threJ
        nk: c
        rg: J
        v: celv
      t: elv_2
      "y": 
        cv: '0.2'
