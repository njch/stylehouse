--- 
I: 
  "0.1": 
    Act: 
      c: 
        el: 1
        s: "A.I.Act = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n        $A = {%$s};\n        $A->{mo}->{ont} = $A;\n        $A->{s} = shift @{$A->{N}};\n        $T = {};\n        $T->{oM} = [];\n        $I->{d}->(\"n\",$A,{},$G,$T);\n        $I->{d}->(\"An\");\n        $A->{t}->(\"2\");\n        map{$I->{nF}->{$_}}qw'A C T';\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: e24a2c98dffd
        gro: Motion
      t: Act
      "y": 
        cv: '0.3'
        cvt: 0.3	Act
        p: qq/Motion/Motion
    An: 
      c: 
        el: 1
        s: "A.I.An = sub {\n    my ($A,$C,$G,$T,@Me) = @_;\n    my $I = A.I;\n        $A->{note} = {}; # pinging csc\n        $A->{talk} = \"$A->{J}->{name} \".($A->{J}->{le} && $A->{J}->{le}->{name});\n        $A->{c} = sub { $I->{d}->(\"c\",@_); };\n        $A->{e} = sub { $I->{d}->(\"e\",@_); };\n        $A->{us} = sub { $I->{d}->(\"us\",@_); };\n        $A->{t} = sub { $I->{d}->(\"t\",@_); };\n        $A->{V} = sub {\n            my $bl = shift;\n            $A->{J}->{VV} && $A->{J}->{VV}->{$bl}\n            || $A->{J}->{V}\n        };\n        $A\n};A.I.d&An;\n"
      sc: 
        acgt: 1
        args: A,C,G,T
        code: I 1
        dige: fb63d04c1357
        gro: Motion
      t: An
      "y": 
        cv: '0.3'
        cvt: 0.3	An
        p: qq/Motion/Motion
    Cngk: 
      c: 
        el: 1
        s: "A.I.Cngk = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($s,$D,@Me) = @M;\n    my $I = A.I;\n    ref $A || die \"nmonref A!\";\n    A.bangdesk.bang->{Cngek} = sub {\n        sayre \"was Cngk; \".ki($s).\"\\nWith: \".ki($D)\n    } if 0;\n    return 1 if D.c.any;\n    die \"nonNKnk\".ki$D if !D.c.nk;\n    return 0 if !exists $s->{D.c.nk};\n    return [$s->{D.c.nk}] if !exists D.c.gk;\n    return 0 if !exists $s->{D.c.nk}->{D.c.gk};\n    return [$s->{D.c.nk}->{D.c.gk}];\n};\n"
      sc: 
        acgt: s,D
        args: A,C,G,T,s,D
        code: I 1
        dige: fa859012baf2
        gro: C
      t: Cngk
      "y": 
        cv: '0.3'
        cvt: 0.3	Cngk
        p: qq/C/C
    Other: 
      c: 
        el: 1
        s: "A.I.Other = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n        my $ar = $F[0]->{ar};\n        $A = $G->{w}->(\"RB\", {%$ar, t => $s}, $G);\n        $I = $A->{I};\n        # midnight at the oasis\n        $I->{d}->(\"n\",$A,{},$G,{});\n        $I->{d}->(\"An\");\n        $A->{t}->(\"1\");\n        $A->{t}->(\"11111\") || warn \"NO 1\";\n        ($A,$A->{I})\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 9e38e8306a8d
        gro: Motion
      t: Other
      "y": 
        cv: '0.3'
        cvt: 0.3	Other
        p: qq/Motion/Motion
    ar: 
      c: 
        el: 1
        s: "A.I.ar = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n        my $ar;\n        $ar->{A}=$A;$ar->{G}=$G;$ar->{C}=$C;$ar->{T}=$T;$ar->{I}=$I;\n        $ar;\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 9e297269b850
        gro: Motion
      t: ar
      "y": 
        cv: '0.3'
        cvt: 0.3	ar
        p: qq/Motion/Motion
    c: 
      c: 
        el: 1
        s: "A.I.c = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($D,@Me) = @M;\n    my $I = A.I;\n    I.d&inDin,$C,@M;\n};\n"
      sc: 
        acgt: D
        args: A,C,G,T,D
        code: I 1
        dige: a931936381c2
        gro: C
      t: c
      "y": 
        cv: '0.3'
        cvt: 0.3	c
        p: qq/C/C
    carebowl: 
      c: 
        el: 1
        s: "A.I.carebowl = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($s,$iii,$x,$xrd,@Me) = @M;\n    my $I = A.I;\n    for my $ik (sort keys %$iii) {\n        my $D = $iii->{$ik};\n        if (my $nk = D.sc.nk) {\n            my $C = I.nF.C;\n            next if !exists $C->{$nk};\n            if (my $gk = D.sc.gk) {\n                next if !exists $C->{$nk}->{$gk};\n            }\n        }\n        my $act;\n        my $dont;\n        if (D.sc.acgt && D.sc.act) {\n            $act = 1;\n            # acgtsubs can be defined at any cv\n            # run themselves if act\n            # usu. one receiver (Ci) and the rest scheme\n            die \"D.t .act gets... D.sc.act\" if D.sc.act ne '1';\n            $dont = 1 if exists A.I->{D.t};\n        }\n        # way or acgt-setuping-way\n        unless ($dont) {\n            my $paw = join\"_\",'',I.k,I.cv,D.t;\n            $paw =~ s/\\W//g;\n            Rw $paw $A $C $G $T $__D:D;\n        }\n        # most tiny ticks\n        # this ind is all flywheel\n        # it's a kind of unity that wants to be a block of code like this\n        # and c\n        my @is = A.s;\n        @is = I.d&scIfs,D.sc.Ifs if D.sc.Ifs;\n        @is || next;\n        if ($act) {\n            push @$xrd, [I.k,$ik];\n            my $Ds = $x->{I.k}->{$ik} ||= {};\n            Ds.D = $D;\n            Ds.is = \\@is;\n            D.sc.its = @is;\n        }\n        # TreeD\n        $s->{I.k}->{I.cv}->{$ik} = $D;\n    }\n};\n"
      sc: 
        acgt: s,iii,x,xrd
        args: A,C,G,T,s,iii,x,xrd
        code: I 1
        dige: 1e38d8a681fb
        gro: KnowTime
        l: "#c"
      t: carebowl
      "y": 
        cv: '0.3'
        cvt: 0.3	carebowl
        p: qq/KnowTime/KnowTime
    e: 
      c: 
        el: 1
        s: "A.I.e = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($D,@Me) = @M;\n    my $I = A.I;\n    my $e = I.d&sces,C.c.e||return();\n    I.d&inDin,$e,@M;\n};\n"
      sc: 
        acgt: D
        args: A,C,G,T,D
        code: I 1
        dige: 2d0b2e86424f
        gro: C
      t: e
      "y": 
        cv: '0.3'
        cvt: 0.3	e
        p: qq/C/C
    ex: 
      c: 
        el: 1
        s: "A.I.ex = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($i,$K,$cv,$av,@Me) = @M;\n    my $I = A.I;\n    # was Rw SNat $A $C $G $T $I $i $K $cv;\n    # baseism\n    my $c = 0+(\"0.\".$cv);\n    my $Av = $av || A.cv;\n    my $sp = $av ? \" Flav $av (no A.cv)\" : \"\";\n    \n    my $talk = \"A.talk: $K$sp $Av > $c --- C.t \";\n    \n    my $aim = {$K=>1};\n    if ($aim->{A.am}) {\n        $aim->{$_} = 1 for @{A.Isl||[]};\n        aim.I = 1;\n    }\n    \n    my $yv = {};\n    # make K/cv/t -> cv/K/t\n    for my $k (sort keys %$i) {\n        my $ii = $i->{$k};\n    \n        next if $k eq 'Ii';\n        next if $k eq 'ooI';\n        ref $ii eq 'HASH' || die \"weird $k=$ii\";\n    \n        for my $vc (sort keys %$ii) {\n            my $iii = $ii->{$vc};\n            die'$k !0<$vc<1' unless $vc > 0 && $vc < 1;\n            $yv->{$vc}->{$k} = $iii;\n        }\n    }\n    \n    # do stuff\n    my $vb; # in fractions\n    my $wasSubtle;\n    for my $vc (sort keys %$yv) {\n        my $is = $yv->{$vc};\n        my $s = {};\n        my $x = {};\n        my $xrd = [];\n    \n        next if $vc <= $Av && $vc != $c;\n        next if $vc > $c;\n    \n        # our  osc (stay in K per Subtle ness);\n        my @iz = grep {\n            $aim->{$_} || (aim.I && (A.Iso->{$_} || I.also->{$_}))\n        } sort keys %$is;\n        next if !@iz;\n    \n        # decide inter cv wideness loop\n        if ($wasSubtle) {\n            undef $wasSubtle;\n        }\n        elsif ($vb && $vc > $vb && (\n            @{A.N} || @{A.mo.re->{$vb}||[]}\n            )) {\n            # sincing, wide order\n            # various others want to be around for only some of the process...\n            sayre \"$vb -> $vc  bump, \". @{A.N} if A.J.V > 1;\n            T.Z->{$vb} = 1;\n            A.cv = $vb; # so we dont wind up to 6 on the way out of t\n            return T.not = 1;\n        }\n    \n        # pin down poles\n        I.cv = $vc;\n        I.vb = $vb;\n        # draw curvles as spirals done\n    \n        for my $k (@iz) {\n            my $iii = $is->{$k};\n            I.k = $k;\n            I.d&carebowl,$s,$iii,$x,$xrd;\n        }\n        # suble\n        my $se = Rw TreeD $s $scby=gro \n            if A.J.V > 1 && keys %$s;\n        $c == 0.1 ? saygr $se : say $se if $se;\n    \n        my $o;\n        (o.vc,o.vb) = ($vc,$vb);\n        I.d&exood,$o,$x,$xrd;\n        ($vc,$vb) = (o.vc,o.vb);\n        if (o.Subtle && !o.nonSubtle) {\n            $wasSubtle = 1;\n        }\n    \n        return if T.not;  # will &z, oseve\n        return if delete T.whack;\n    }\n};\n"
      sc: 
        acgt: i,K,cv,av
        args: A,C,G,T,i,K,cv,av
        code: I 1
        dige: c1559663dda3
        gro: KnowTime
        nois: "#c"
      t: ex
      "y": 
        cv: '0.3'
        cvt: 0.3	ex
        p: qq/KnowTime/KnowTime
    exood: 
      c: 
        el: 1
        s: "A.I.exood = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($o,$x,$xrd,@Me) = @M;\n    my $I = A.I;\n    for my $kik (@$xrd) {\n        my ($k,$ik) = @$kik;\n        A.Subtle && A.Subtle->{$k} ? o.Subtle++ : o.nonSubtle++;\n        my $Ds = $x->{$k}->{$ik};\n        my $D = Ds.D;\n        for my $s (@{Ds.is}) {\n            D.sc.acgt eq 's'||die \"nonacgts\".wdump $D;\n            exists A.I->{D.t}||die \"acgtI D.t not up: \".wdump A.I;\n    \n            T.D = $D;\n            I.d&D.t,$s;\n    \n            if (my $ut = T.ut) {\n                if (ut.matchTd) {\n                    my $d = s.d || die \"confuse\";\n                    d.od.s.T.q->{d.e.k} ||= $d;\n                    d.od.s.T.m->{d.e.k} ||= $d\n                        unless delete(T.noTd);\n                }\n                else { die\"utrowhat \".wdump 2, $ut }\n            }\n    \n            # outwave: schools of many fish (not upcv if !@is)\n            o.vb ||= o.vc if D.sc.v;\n    \n            last if T.not || T.whack;\n        }\n        delete T.ut;\n        last if T.not || T.whack;\n    }\n};\n"
      sc: 
        acgt: o,x,xrd
        args: A,C,G,T,o,x,xrd
        code: I 1
        dige: 70cff2b97fda
        gro: KnowTime
        l: "#c"
      t: exood
      "y": 
        cv: '0.3'
        cvt: 0.3	exood
        p: qq/KnowTime/KnowTime
    flywheels: 
      c: 
        el: 1
        s: "A.I.flywheels = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n        # wants to be a six alwayser... ,{code=>'I 6',act=>'all'} # $II->{All}? $II->{Fly}?\n        # its $I->{d}->(\"nded\") and holds things to code, $v a spiral it's filling up\n        # $v could be mounted... aj8 mysteries\n        for my $k (sort keys %{$A->{fl}}) {\n            my $v = $A->{fl}->{$k};\n            #   ^ bus to ride\n            $k = $2 if $k =~ /^(\\d+) (.+)$/;\n            $G->{w}->(\"ym/$k\", {I => $I, J => $A->{J}, A => $A, C => $C, v => $v, G => $G, T => $T}, $G);\n        }\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 6a90e0b56807
        gro: Motion
      t: flywheels
      "y": 
        cv: '0.3'
        cvt: 0.3	flywheels
        p: qq/Motion/Motion
    fourreal: 
      c: 
        el: 1
        s: "A.I.fourreal = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    (C.t, C.y) = @$s;\n    C.c  = $s->[2] if exists $s->[2];\n    C.sc = $s->[3] if exists $s->[3];\n    die'@>4'.wdump $s if @$s > 4;\n    die\"C.t from \".wdump $s if ref C.t; # dives\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 87baea0c56c8
        gro: C
      t: fourreal
      "y": 
        cv: '0.3'
        cvt: 0.3	fourreal
        p: qq/C/C
    fourstring: 
      c: 
        el: 1
        s: "A.I.fourstring = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    I.d&MZu,$1 if $s =~ /^\\s*#?\\s*MZ (.+)$/;\n    $s =~ s/^\\s+//;\n    if ($s =~ /^\\s*(#.*)$/) {\n       T.not = 1;\n       T.com = $1;\n    }\n    elsif ($s eq '') {\n       T.not = T.space = 1;\n    }\n    else {\n       my $ci = $s;\n       for my $nk (qw't y c sc') {\n           if ($ci =~ s/^(\\S+) *//) { # some t are types of space\n               my $v = $1;\n               $v = I.d&peel,$v if $nk ne 't' && $v =~ I.peels;\n               # << consumes more lines into $nk, then ...\n               $v = '' if $v =~ /^(''|\"\")$/;\n               $C->{$nk} = $v;\n           }\n       }\n    }\n    saybl \"4string: $s            \".ki $C if A.V&C;\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: dbd7f1097b0d
        gro: C
      t: fourstring
      "y": 
        cv: '0.3'
        cvt: 0.3	fourstring
        p: qq/C/C
    hup: 
      c: 
        el: 1
        s: "A.I.hup = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $CC = {%$s};\n    $CC->{$_} = {%{$CC->{$_}}} for grep {ref $CC->{$_} eq 'HASH'} keys %$CC;\n    return $CC;\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 5c16f3716362
        gro: C
      t: hup
      "y": 
        cv: '0.3'
        cvt: 0.3	hup
        p: qq/C/C
    inDin: 
      c: 
        el: 1
        s: "A.I.inDin = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($s,$D,@Me) = @M;\n    my $I = A.I;\n    die'nofA' if !I.nF.A;\n    #\n    return () unless defined $s;\n    return $s if $D eq 'C';\n    #\n    shift @M; # s\n    $D = I.d&interpD,@M if !ref $D;\n    #\n    my $v = I.d&Cngk,$s,$D;\n    saybl \"Got cnkgk: \".wdump 3,[\\@M,$D,$v,$s] if A.V&D;\n    die \"Unhandles any: $v: \".ki $D if $v eq '1';\n    #\n    return () unless $v;\n    # blankgk\n    A.note->{D.c.nk}->{D.c.gk} = $v if A.note;\n    #\n    @$v == 1 || die \"Many somehowed \".wdump 3,[ki($D),$v];\n    ($v) = @$v;\n    if (D.c.as eq 'list') {\n        ref $v eq 'ARRAY' || die 'Cngk for list not array '.ki $D;\n        return @$v;\n    }\n    return $v;\n};\n"
      sc: 
        acgt: s,D
        args: A,C,G,T,s,D
        code: I 1
        dige: eaa21ce92eb2
        gro: C
      t: inDin
      "y": 
        cv: '0.3'
        cvt: 0.3	inDin
        p: qq/C/C
    interpD: 
      c: 
        el: 1
        s: "A.I.interpD = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($nk,$gk,@Me) = @M;\n    my $I = A.I;\n    my $defnk = 'c';\n    return $nk if ref $nk;\n    my $D = {};\n    D.c.as = 'list' if $nk =~ s/^_//;\n    while ($gk =~ s/^%(.+?):(.+?)(?=%|$)//g) {\n        D.c->{$1} = $2;\n        pop @M if @M == 2;\n    }\n    if (@M == 1 && $nk eq 't') {\n        D.c.nk = $nk;\n    }\n    elsif (@M == 1) { # or from t,,,\n        D.c.nk ||= $defnk;\n        D.c.gk ||= $nk;\n    }\n    elsif (@M == 2) {\n        D.c.nk = $nk;\n        D.c.gk = $gk;\n    }\n    delete D.c.gk if D.c.gk eq 'NOGK';\n    $D\n};\n"
      sc: 
        acgt: nk,gk
        args: A,C,G,T,nk,gk
        code: I 1
        dige: 9d1fccaf5235
        gro: C
      t: interpD
      "y": 
        cv: '0.3'
        cvt: 0.3	interpD
        p: qq/C/C
    ip: 
      c: 
        el: 1
        s: "A.I.ip = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($s,$c,@Me) = @M;\n    my $I = A.I;\n    my $pass = 1;\n    for my $I (keys %$s) {\n        !ref $s->{$I} && $s->{$I} ne $c->{$I} && $pass--;\n        ref $s->{$I} eq 'HASH' && do {\n            if (my $not = $s->{$I}->{not}) {\n                $not eq 'def' && do {\n                    defined $c->{$I} && $pass--;\n                } \n                || $not eq $c->{$I} && $pass--;\n            }\n            else {\n                $s->{$I}->{$c->{$I}} eq '1' || $pass--;\n            }\n        };\n    }\n    $pass == 1\n};\n"
      sc: 
        acgt: s,c
        args: A,C,G,T,s,c
        code: I 1
        dige: 7498f581817c
        gro: C
      t: ip
      "y": 
        cv: '0.3'
        cvt: 0.3	ip
        p: qq/C/C
    moy: 
      c: 
        el: 1
        s: "A.I.moy = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n        # groups, spread the moise over A\n        my $i = $A->{mo}->{y}->{$s}||die\"no$s\";\n        my $is = $i->{$C->{y}->{p}}; # things in our C's pool\n        {is=>$is,N=>[map{$is->{$_}}sort keys %$is]};\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 2fb4d87f09eb
        gro: Motion
      t: moy
      "y": 
        cv: '0.3'
        cvt: 0.3	moy
        p: qq/Motion/Motion
    oseverato: 
      c: 
        el: 1
        s: "A.I.oseverato = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n        if ($T->{d}) {\n            $A->{T}->{d} = $T->{d}; # carte\n        }\n        if (my $z = delete $T->{Z}) { # tease out the next times\n            my ($lo) = sort keys %$z; # next one\n            my $v = $z->{$lo};\n            push @{$A->{mo}->{re}->{$lo} ||= []},\n                ref $v eq 'ARRAY' ? @$v :\n                $v ne '1' ? [$A,$C,$v] :\n                [$A,$C];\n            @{$T->{oM}} = ();\n        }\n        if (!@{$A->{mo}->{N}} && $A->{mo}->{re}) {\n            my $ats = $A->{mo}->{re} || {};\n            my @wa = sort keys %$ats;\n            my ($lo) = @wa;\n            if ($lo) {\n                my $ay = delete $ats->{$lo};\n                my @N = map { {AZ=>{$lo=>$_}} } @$ay;\n                push @{$A->{mo}->{N}}, @N;\n                saybl \"Looping \".@N.\" to $lo\" if $A->{J}->{V} > 1;\n            }\n        }\n        # concoi severaliser, for conglom up; merging spiral snips of code\n        if (my $y = $T->{y}) {\n            for my $k (keys %$y) {\n                $A->{mo}->{y}->{$k}->{$C->{y}->{p}}->{$C->{y}->{cvt}} = $C;\n            }\n        }\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: c2111bfab654
        gro: Motion
      t: oseverato
      "y": 
        cv: '0.3'
        cvt: 0.3	oseverato
        p: qq/Motion/Motion
    peel: 
      c: 
        el: 1
        s: "A.I.peel = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    $s =~ s/^%// || \n        $s =~ s/^{// && $s =~ s/}$//\n        || die \"unpealable $s\";\n    my $c;\n    for (split ',', $s) {\n        my ($k, $v) = split ':', $_, 2;\n        $v = 1 if !defined $v;\n        $c->{$k} = $v;\n    }\n    $c||{}\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 86d02e052c88
        gro: C
      t: peel
      "y": 
        cv: '0.3'
        cvt: 0.3	peel
        p: qq/C/C
    peels: 
      c: 
        el: 1
        s: "A.I.peels = (sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    qr/^[\\{\\%]\\w+/;\n})->($A,$C,$G,$T);\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 1a4b86ada8e3
        gro: C
        subpeel: 1
      t: peels
      "y": 
        cv: '0.3'
        cvt: 0.3	peels
        p: qq/C/C
    sces: 
      c: 
        el: 1
        s: "A.I.sces = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $i = 0;\n    while (s.c.e) {\n        $s = s.c.e;\n        $i++ > 9 && die \"HUGE $i recursing CceCceCceCce... by \".ki $s;\n    }\n    return $s;\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 74601405c36b
        gro: C
      t: sces
      "y": 
        cv: '0.3'
        cvt: 0.3	sces
        p: qq/C/C
    t: 
      c: 
        el: 1
        s: "A.I.t = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($K,$cv,$av,@Me) = @M;\n    my $I = A.I;\n    ($K,$cv) = (A.am,$K) if !$cv && $K;\n    $av = 0+(\"0.\".$av) if $av;\n    die \"K$K cv$cv\" unless $K && $cv;\n    my $c = 0+(\"0.\".$cv);\n    my $Av = $av || A.cv;\n    \n    # adapt to much  mergey       extendo  rubble\n    my $i = Rw collaspII $A;\n    die'difAvcol' if $Av ne ($av || A.cv);\n    #\n    my $ncv;\n    my $re;\n    my $dont;\n    if ($Av < 0.6 || $c >= 0.7) {\n        if ($c >= $Av) {\n            $ncv = $c;\n            $re = 1;\n        }\n        else {\n            $re = 0;\n            $dont = 1;\n            say \" deInc $Av - $cv $c\";\n        }\n        die \"pre bigger\" if $cv < $Av;\n    }\n    else {\n        if ($c < $Av) {\n            if ($Av == 0.6) { # scoop up all on entering timezone\n                $re = 1;\n                $dont = 1; # or will II fall away\n            }\n            else {\n                $re = 0;\n                $dont = 1;\n            }\n        }\n        elsif ($c == $Av) {\n            $re = 1;\n        }\n        elsif ($c > $Av) { # and $c < 0.7, is a next time\n            T.Z->{$c} = 1;\n            $re = 0;\n            $dont = 1;\n        }\n        else {die\"nof\"}\n    }\n    undef $ncv if $av; # aux K\n    my $was = A.cv;\n    $dont || I.d&ex,$i,$K,$cv,$av;\n    A.cv = $ncv if defined $ncv && A.cv == $was;\n    $re;\n};\n"
      sc: 
        acgt: K,cv,av
        args: A,C,G,T,K,cv,av
        code: I 1
        dige: 442c4320522f
        gro: KnowTime
        nois: "#c"
      t: t
      "y": 
        cv: '0.3'
        cvt: 0.3	t
        p: qq/KnowTime/KnowTime
    tlM: 
      c: 
        el: 1
        s: "A.I.tlM = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $os = $s;\n    $s = s.M if ref $s eq 'HASH';\n    ref $s eq 'ARRAY' || return \"S not N/M: \".wdump[$os];\n    Rw ZNews $N:s;\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 26c4c9eceb6f
        gro: Rings
        nov: 1
      t: tlM
      "y": 
        cv: '0.3'
        cvt: 0.3	tlM
        p: qq/Rings/Rings
    us: 
      c: 
        el: 1
        s: "A.I.us = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($D,@Me) = @M;\n    my $I = A.I;\n    my $e = I.d&sces,C.c.e||return();\n    my $us = e.c.us||return();\n    push @M, 'NOGK' if @M == 1;\n    I.d&inDin,$us,@M;\n};\n"
      sc: 
        acgt: D
        args: A,C,G,T,D
        code: I 1
        dige: e8b25536c033
        gro: C
      t: us
      "y": 
        cv: '0.3'
        cvt: 0.3	us
        p: qq/C/C
    xot: 
      c: 
        el: 1
        s: "A.I.xot = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($s,$c,@Me) = @M;\n    my $I = A.I;\n    ref $c eq 'HASH' && ref $s eq 'HASH' ||\n        die \"Hash up\".wdump 3, [$s,$c];\n    while (my($k,$v) = each %$c) {\n        $s->{$k} = ref $v eq 'HASH' ?\n                    {%{$s->{$k}||{}}, %$v}\n        : ref $v ? \n            die \"Hash a ref v: \".wdump 2, $s\n        : $v;\n    }\n    return $s\n};\n"
      sc: 
        acgt: s,c
        args: A,C,G,T,s,c
        code: I 1
        dige: 5b5480545ba0
        gro: C
      t: xot
      "y": 
        cv: '0.3'
        cvt: 0.3	xot
        p: qq/C/C
    xoy: 
      c: 
        el: 1
        s: "A.I.xoy = sub {\n    my ($A,$C,$G,$T,@M)=@_;\n    my ($s,$c,@Me) = @M;\n    my $I = A.I;\n    $c = I.d&xot,{},$c;\n    I.d&xot,$c,$s;\n    return $s;\n};\n"
      sc: 
        acgt: s,c
        args: A,C,G,T,s,c
        code: I 1
        dige: 3bee9aa63385
        gro: C
      t: xoy
      "y": 
        cv: '0.3'
        cvt: 0.3	xoy
        p: qq/C/C
    z: 
      c: 
        el: 1
        s: "A.I.z = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n        $I->{d}->(\"oseverato\");\n        push @{$A->{M}}, @{$T->{oM}};\n        1\n};\n"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I 1
        dige: 85ce5e302f71
        gro: Motion
      t: z
      "y": 
        cv: '0.3'
        cvt: 0.3	z
        p: qq/Motion/Motion
  "0.71": 
    CoM: 
      c: 
        el: 1
        s: "A.I.CoM = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n        push @{$T->{oM}}, $C unless $T->{Z};\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: I 71
        dige: 7a9e6cff36b8
        gro: Motion
        its: 1
      t: CoM
      "y": 
        cv: '0.3'
        cvt: 0.3	CoM
        p: qq/Motion/Motion
J: 
  "0.6211": 
    J_6211: 
      c: 
        el: 1
        s: "A.I.J_6211 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    my $M = [];\n    my $y = {o=>$M};\n    J.oy = $y;\n    J.at ||= G.tie->(Ghoz => {inp=>[qw'oy at'],o=>$J});\n    \n    return if exists C.c.pi;\n    \n    if (A.ztime < 9) {\n        if (A.jr&bol) {\n            sayre \"STOPPING \".ki($C) for 1..3;\n            # TODO stop\n        }\n        A.bangdesk.aft.unblocknine = A.jr&bol,9;\n    }\n    A.bangdesk.bang.bang_ts = sub {\n        A.jr&bang_ts,hitime\n    };\n    \n    C.c.pin = J.name;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: J 6211
        dige: ac38eaf7837d
        gk: J
        gro: Jiterbug
        nk: c
        v: cJ
      t: J_6211
      "y": 
        cv: '0.6211'
        cvt: 0.6211	J_6211
        p: qq/Jiterbug/Jiterbug
  "0.6212": 
    J_6212: 
      c: 
        el: 1
        s: "A.I.J_6212 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    return unless exists C.c.pi;\n    \n    die'csnod'.wdump 3, [$C, J.C] if $C ne J.C;\n    J.cv = (C.c.gp && C.c.gp.cv) || C.c.cv || 0.6;\n    my $path = C.sc.pi||die'nopi';\n    if (J.A.d > 9) {\n        $path = 'text';\n        warn \"J.name J.A.d limit to text\";\n    }\n    C.c.pin = \"pi/$path\";\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: J 6212
        dige: 7d6cf8475ee3
        gk: J
        gro: Jiterbug
        nk: c
        v: cJ
      t: J_6212
      "y": 
        cv: '0.6212'
        cvt: 0.6212	J_6212
        p: qq/Jiterbug/Jiterbug
  "0.631": 
    J_631: 
      c: 
        el: 1
        s: "A.I.J_631 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    A.coi = I.d&pha,$J,'ako';\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: J 631
        dige: 59b0dc2b2481
        gk: J
        gro: Jiterbug
        nk: c
        v: cJ
      t: J_631
      "y": 
        cv: '0.631'
        cvt: 0.631	J_631
        p: qq/Jiterbug/Jiterbug
  "0.66": 
    J_66: 
      c: 
        el: 1
        s: "A.I.J_66 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    my $ar = {%{C.c}};\n    ar.s = '' if !exists ar.s;\n    ar.u = ar.s;\n    ar.pin = C.c.pin || die \"nopin\";\n    my $y = J.oy;\n    my $M = y.o;\n    \n    Rw ar.pin + $A $C $G $T $I $J $M $y;\n    \n    Rw Jamroot $J $y if y.at;\n    if (T.iM) {\n        J.Oy || die \"no JOy J.name\";\n        ref J.Oy.o eq 'HASH' || die \"J.name oYo not hash/picked up\";\n        ref J.Oy.o.M eq 'ARRAY' || die \"J.name oYoM not array\";\n        push @{J.oy.o}, @{J.Oy.o.M};\n    }\n    J.Oy = $y;\n    if (@$M) {\n        n z=>$y=>{}\n    }\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: J 66
        dige: f2377c60d73c
        gk: J
        gro: Jiterbug
        nk: c
        v: cJ
      t: J_66
      "y": 
        cv: '0.66'
        cvt: 0.66	J_66
        p: qq/Jiterbug/Jiterbug
  "0.677": 
    J_677: 
      c: 
        el: 1
        s: "A.I.J_677 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    if (J.oy.ope) {\n        sayyl \"Leaving J.name open pha...\" if A.V&ope;\n        I.d&end,A.coi;\n        return;\n    }\n    A.coi.qui = 1;\n    my $wt = I.d&exactl,A.coi;\n    if (wt.same) {\n        if (++J.A.wch > 4) {\n            J.A.wch = 0;\n            # ^ rate to avoid v see J 632 eighthnot\n        }\n        else {\n           sayre \"SAME T.alk\" if A.V&SAME;\n           T.same = 1;\n        }\n    }\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: J 677
        dige: fe51018f11a7
        gk: J
        gro: Jiterbug
        nk: c
        v: cJ
      t: J_677
      "y": 
        cv: '0.677'
        cvt: 0.677	J_677
        p: qq/Jiterbug/Jiterbug
Mo: 
  "0.3211": 
    J_3211: 
      c: 
        el: 1
        s: "A.I.J_3211 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    C.c.W = $J unless ref C.c.W;\n    ref C.c.W || !ref $J || C.c.W eq J.name || die \"J.name isn't\".ki(C.c);\n    !ref C.c.W || !ref $J || C.c.W eq $J || die \"nzoWJ\".ki(C.c);\n    # avoid 6ing, its doubling orso\n    A.ztime = 3 if A.J.name ne 'qq'; # break off\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo 3211
        dige: cde84b43b42c
        gk: J
        gro: Jlaces
        nk: c
        v: cJ
      t: J_3211
      "y": 
        cv: '0.3211'
        cvt: 0.3211	J_3211
        p: qq/Jlaces/Jlaces
  "0.3213": 
    pi_3213: 
      c: 
        el: 1
        s: "A.I.pi_3213 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $pi = C.c.pi;\n    # - c. language is map to some u before 6ing\n    ref $pi && die\"refpi: \".wdump 2, $pi;\n    C.sc.pi = $pi || 'guess';\n    C.c.J = 'pi';\n    my $oJ = A.J;\n    $oJ = C.y.o.J if C.y.o && C.y.o.J;\n    A.jr = Rw Ajr $J:oJ $C;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo 3213
        dige: 0a4ba152623f
        gk: pi
        gro: Jlaces
        nk: c
        v: cpi
      t: pi_3213
      "y": 
        cv: '0.3213'
        cvt: 0.3213	pi_3213
        p: qq/Jlaces/Jlaces
  "0.3214": 
    W_3214: 
      c: 
        el: 1
        s: "A.I.W_3214 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $W = C.c.W;\n    my $t = $W;\n    $t = W.name if ref $t;\n    my $jr = Rw Ajr $J:G.oin $t $cv=0.3;\n    \n    return C.c.W = die \"SOIDNG RESEAR(pi with W)\".  jr&J\n        if C.c.pi; # doing research\n    A.jr = $jr; # being\n    \n    C.sc.W = $t;\n    C.sc.J = ref $W ? $W : $t;\n    # going over J should be same...\n    C.c.J ||= $W;\n    C.t = $t;\n    C.y.cv ||= 0.3;\n    # and where the thrust (J.A?)\n    if (C.c.vv) {\n        A.ztime = delete C.c.vv;\n        A.jr&vv,'',9\n    }\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo 3214
        dige: 38e2d6e586a5
        gk: W
        gro: Jlaces
        nk: c
        v: cW
      t: W_3214
      "y": 
        cv: '0.3214'
        cvt: 0.3214	W_3214
        p: qq/Jlaces/Jlaces
  "0.341": 
    J_341: 
      c: 
        el: 1
        s: "A.I.J_341 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    my $f = A.jr&J;\n    my $j = C.sc.J;\n    ref $j && ref $f && ($j eq $f || die \".sc J dif $f $j\");\n    # hilum & tie sc so vis, substrate insecting\n    C.c.J = C.sc.J = $f if $f && ref $f && !f.dead;\n    A.Iso.oJ = 1; # getting pinned into J\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo 341
        dige: 2c0ca36cd425
        gk: J
        gro: Joot
        nk: c
        v: cJ
      t: J_341
      "y": 
        cv: '0.341'
        cvt: 0.341	J_341
        p: qq/Joot/Joot
  "0.342": 
    X_342: 
      c: 
        el: 1
        s: "A.I.X_342 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $X = C.c.X;\n    my $J = C.sc.J;\n    sayre \"DELING J.name\".ki$C;\n    $J || die \"X no J\";\n    ref $J || die \"Nofound $J  C.t   C.y.cv\";\n    $X eq $J || die \"noovewr X  C.c.X ne $J\";\n    A.jr&J,$J,9;\n    J.dead = 1;\n    # SNat bail, we have balin by now so hole in space this time\n    T.not = 1;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo 342
        dige: 62f17d0fcd62
        gk: X
        gro: Joot
        nk: c
        v: cX
      t: X_342
      "y": 
        cv: '0.342'
        cvt: 0.342	X_342
        p: qq/Joot/Joot
  "0.436": 
    time_436: 
      c: 
        el: 1
        s: "A.I.time_436 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $time = C.c.time;\n    A.ztime = delete C.c.time;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo 436
        dige: 0997581cf491
        gk: time
        gro: Jamping
        nk: c
        v: ctime
      t: time_436
      "y": 
        cv: '0.436'
        cvt: 0.436	time_436
        p: qq/Jamping/Jamping
oJ: 
  "0.343": 
    J_343: 
      c: 
        el: 1
        s: "A.I.J_343 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    return if ref $J;\n    $J = Rw Jto $name:J;\n    G.W->{J.id} && G.W->{J.id} ne $J && die \"runup J.name\";\n    G.W->{J.id} = $J;\n    ref $J || die 'watt'.$J;\n    if (exists C.c.pi) {\n        J.Jiter = A.J; # erse rev\n        J.most->{$_} = A.J.most->{$_} for keys %{A.J.most||{}};\n    }\n    # til the I train shows up:\n    J.V = J.most.J.inV || 1 if A.J.V == 2 || J.most.J.inV;\n    J.A.Indo = 2;\n    sayyl \"J33   Made J.name\" unless J.Jiter;\n    C.c.J = C.sc.J = $J;\n    A.jr&J,$J;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: oJ 343
        dige: 691a51bac07c
        gk: J
        gro: Joot
        nk: c
        v: cJ
      t: J_343
      "y": 
        cv: '0.343'
        cvt: 0.343	J_343
        p: qq/Joot/Joot
  "0.344": 
    J_344: 
      c: 
        el: 1
        s: "A.I.J_344 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    die \"In self: J.name\" if $J eq A.J;\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: oJ 344
        dige: 0ce5c7c00e29
        gk: J
        gro: Joot
        nk: c
        v: cJ
      t: J_344
      "y": 
        cv: '0.344'
        cvt: 0.344	J_344
        p: qq/Joot/Joot
  "0.434": 
    J_434: 
      c: 
        el: 1
        s: "A.I.J_434 = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $c = C.c;\n    my $J = C.c.J;\n    $J = C.c.J = C.sc.J;\n    J.name || die \"WNO \".wdump 4, $C;\n    # TODO: soft acuminy over \\d esp. until .bb or something\n    A.mo.Js->{J.name} = $J;\n    # A falls\n    # A.mo exits\n    # J.A persists\n    J.A.first ||= hitime();\n    if (C.sc.W && G.oin ne $J) {\n        my $lev = G.oin.A.tid;\n        if (J.A.tidi && (J.A.tidi + 3) > $lev) {\n            A.ztime ||= 4;\n        }\n        else {\n            J.A.tidi = $lev;\n        }\n    }\n    sayre \"same A.J.name inside J.name\" if A.J eq $J;\n    if (exists C.sc.pi) {\n        sayre \"JiternotAJ J.Jiter.name ne A.J.name\" if J.Jiter ne A.J;\n        die 'pimostJ'if J.most.J eq $J;\n    }\n    else {\n        die 'esel'.wdump [J.C, J.most.J.C] if J.most.J ne $J;\n    }\n    A.ztime ||= 6;\n    A.time && sayre \"Had atime\";\n    A.time = sub { # A.t& cover, serve single digit ad hocs, like 2\n        my ($JJ,$q) = @_; die\"JTIMEJ\" if $JJ ne $J;\n        A.ztime >= $q\n    };\n    if (C.sc.pi) {\n        J.A.d = J.Jiter.A.d + 1;\n        J.ind = join '  ', ('') x J.A.d;\n        J.name = \"J.A.d. C.c.pi*C.t\";\n        J.d = $C;\n        A.ztime = 6 if A.ztime < 6;\n    }\n    J.C = $C;\n    A.talk .= \" J: J.name\";\n};\n"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: oJ 434
        dige: e73d6849a814
        gk: J
        gro: Jamping
        nk: c
        v: cJ
      t: J_434
      "y": 
        cv: '0.434'
        cvt: 0.434	J_434
        p: qq/Jamping/Jamping
