--- 
I: 
  "0.1": 
    AZu: 
      c: 
        from: Indular/Servo
        s: "A.I.AZu = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\ndie 'amany' if keys %$s > 1;\nmy ($cv,$ac) = %$s;\nmy ($AA,$CC) = ref $ac eq 'ARRAY' ? @$ac : ($ac,ac.C);\n$AA || $CC || die \"AZ NO A or C: \".wdump 3, $s;\n$AA && $CC && die \"AZ toomuch A or C: \".wdump 3, $s;\nmy $cov;\nif ($AA) {\n    $A = $AA;\n    my $Te = A.T;\n    $cov = delete Te.incv;\n    A.cv = $cov || $cv;\n    unshift @{A.mo.N}, $A;\n    return T.whack = T.isnot = 1;\n}\nelse {\n    A.C = $CC;\n}\nA.cv = $cov || $cv;\nT.whack = 1;\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: b9b209c46e93
        l: Motion/oseverato
        of: I
      t: AZu
      "y": 
        cv: '0.1'
    Cngk: 
      c: 
        from: Indular/C
        s: "A.I.Cngk = sub {\nmy ($A,$C,$G,$T,@M)=@_;\nmy ($s,$D,@Me) = @M;\nmy $I = A.I;\nref $A || die \"nmonref A!\";\nA.bangdesk.bang->{Cngek} = sub {\n    sayre \"was Cngk; \".ki($s).\"\\nWith: \".ki($D)\n} if 0;\nreturn 1 if D.c.any;\ndie \"nonNKnk\".ki$D if !D.c.nk;\nreturn 0 if !exists $s->{D.c.nk};\nreturn [$s->{D.c.nk}] if !exists D.c.gk;\nreturn 0 if !exists $s->{D.c.nk}->{D.c.gk};\nreturn [$s->{D.c.nk}->{D.c.gk}];\n};"
      sc: 
        acgt: s D
        args: A,C,G,T,s,D
        code: I
        dige: 1e50021ad5b4
        of: I
      t: Cngk
      "y": 
        cv: '0.1'
    ECu: 
      c: 
        from: Indular/Servo
        s: "A.I.ECu = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nref $s eq 'ARRAY' || die;\nmy ($N,$c) = @$s;\n$N = [{MZ=>A.fl}, {MZ=>{'3 doex'=>$c}}, @$N];\n# and In could feel our light cone\nRw In $J:A.J $M:T.oM $N;\n# ^but instead push to A.N and A.No, the sister strand Whare Y Whare\n# and A walks through t&Y, d&Whare(6)\n# turns via n&ACGT\n# the time beams mapped... a W concat couldol\nT.not = 1;\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: b669ca6a4ef1
        l: Motion
        of: I
      t: ECu
      "y": 
        cv: '0.1'
    EZu: 
      c: 
        from: Indular/Servo
        s: "A.I.EZu = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $Z = I.d&iZu,$s;\nwarn \"About EZ\";\nfor my $k (sort keys %$Z) {\n    my $N = $Z->{$k};\n    $N = [ map { [$_] } split \"\\n\",$N ] if !ref $N;\n    Rw In $M:T.oM $N;\n}\nT.not = 1;\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 9b484f39fd3c
        l: Motion
        of: I
      t: EZu
      "y": 
        cv: '0.1'
    El: 
      c: 
        from: Modems/Pha
        s: "A.I.El = sub {\nmy ($A,$C,$G,$T,@M)=@_;\nmy ($J,$name,@Me) = @M;\nmy $I = A.I;\nJ.El->{$name} ||= {bb=>{},name=>$name};\n};"
      sc: 
        acgt: J,name
        args: A,C,G,T,J,name
        code: I
        dige: 7d05f4a56f42
        l: "#c without a self"
        of: I
      t: El
      "y": 
        cv: '0.1'
    Elj: 
      c: 
        from: Modems/Pha
        s: "A.I.Elj = sub {\nmy ($A,$C,$G,$T,@M)=@_;\nmy ($J,$name,@Me) = @M;\nmy $I = A.I;\nJ.El->{$name} ||= Rw Jto - $le:J $name;\n};"
      sc: 
        acgt: J,name
        args: A,C,G,T,J,name
        code: I
        dige: 0bd3f0bf8579
        l: "#c with a self"
        of: I
      t: Elj
      "y": 
        cv: '0.1'
    Elvis: 
      c: 
        from: Modems/Pha
        s: "A.I.Elvis = sub {\nmy ($A,$C,$G,$T,@M)=@_;\nmy ($J,$Y,@Me) = @M;\nmy $I = A.I;\nmy $wtf = I.d&wtfch,J.bb,Y.bb;\n\nY.tw ||= {};\nY.lo = {}; # compile\n\nfor my $mo (qw'gone diff new') {\n    for my $r (keys %{$wtf->{$mo}}) {\n        my $j = I.d&rJ,$r,$J;\n        j.r = $r;\n        j.lt = j.cv.\"\\t\".j.t;\n        if (!j.lt=~/\\S/) {\n            die \"Got $r =>   \".ki $j;\n        }\n        if ($mo eq 'gone') {\n            delete Y.bb->{j.r};\n            delete Y.tw->{j.lt}->{j.style};\n        }\n        else {\n            Y.bb->{j.r} = j.s;\n            Y.tw->{j.lt}->{j.style} = j.s;\n        }\n        Y.lo->{j.lt}->{$mo}->{j.style} = j.s;\n    }\n}\n\nY.tv ||= {};\nY.v ||= {};\nY.go = {};\nmy $same = 1;\nfor my $k (keys %{Y.lo}) {\n    my $tf = Y.lo->{$k};\n    my $cs = Y.tw->{$k};\n    if (tf.new && !tf.gone && !tf.diff && keys %{tf.new} == keys %$cs) {\n        $same = 0; # new line to make\n    }\n    if (tf.gone && !keys %$cs) {\n        $same = 0; # line to disappear\n        my $C = Y.go->{$k} = delete Y.tv->{$k};\n        my ($cv,$t) = $k =~ /^(.+?)\\t(.*)$/;\n        delete Y.v->{$cv}->{$t};\n        delete Y.v->{$cv} unless keys %{Y.v->{$cv}};\n    }\n    if (tf.diff || tf.new) {\n        keys %$cs || die 'nokeys';\n        my ($cv,$t) = $k =~ /^(.+?)\\t(.*)$/;\n        defined $cv || die \"twas $k\";\n        my $foam = sub {\n            my $C = shift;\n            %$C = (t=>$t,y=>{cv=>$cv},c=>{},sc=>{%$cs});\n            C.c.s = delete C.sc->{''} if exists C.sc->{''};\n        };\n        $foam->(Y.tv->{$k} ||= {});\n        $foam->(Y.v->{$cv}->{$t} ||= {});\n    }\n}\nif (!$same) {\n    Y.vs = [];\n    Y.kvi = {};\n    Y.cvi = {};\n    Y.te = {};\n    my $i = 0;\n    for my $k (sort keys %{Y.tv}) {\n        my $C = Y.tv->{$k} || die \"wtf $k\";\n        push @{Y.vs}, $C;\n        Y.kvi->{$k} = $i;\n        Y.cvi->{C.y.cv} ||= $i;\n        Y.te->{C.t}->{C.y.cv} = $C;\n        $i++;\n    }\n}\n\nY.ra = I.d&ratio,wtf.sami,wtf.tot;\nY.rato = wtf.tot;\nY.revs = !$same;\n\n$Y;\n};"
      sc: 
        acgt: J,Y
        args: A,C,G,T,J,Y
        code: I
        dige: b524314061c7
        l: "#c"
        of: I
      t: Elvis
      "y": 
        cv: '0.1'
    MZu: 
      c: 
        from: Indular/Servo
        s: "A.I.MZu = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $uM = sub {\n    my ($k,$v) = @_;\n    if (defined $v && $v eq '0') {\n        delete A.fl->{$k}\n    }\n    else {\n        A.fl->{$k} = $v || 1;\n    }\n};\nref $s eq 'HASH' ?\n    map{ $uM->($_,$s->{$_}) } keys %$s\n:   map{\n        /^(.+?)(?::(.+))?$/ || die;\n        $uM->($1,$2);\n    } split /\\s+/, $s;\nT.not = 1;\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 65edd566f8ec
        of: I
      t: MZu
      "y": 
        cv: '0.1'
    NM: 
      c: 
        from: Indular/Motion
        s: "A.I.NM = sub {\nmy ($A,$C,$G,$T,@M)=@_;\nmy ($J,@Me) = @M;\nmy $I = A.I;\nmy $M = [];\nmy $N = [@Me];\nMn($N);\nreturn $M;\n};"
      sc: 
        acgt: J
        args: A,C,G,T,J
        code: I
        dige: 81935b609e73
        of: I
      t: NM
      "y": 
        cv: '0.1'
    Tz: 
      c: 
        from: Indular/Motion
        s: "A.I.Tz = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy ($lo) = sort keys %$s;\nmy $v = $s->{$lo};\nT.incv = $v if $v ne '1';\n$v = [ I.d&sano , undef ];\npush @{A.mo.re->{$lo}||=[]}, $v;\n@{T.oM} = ();\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: f8c6258af864
        of: I
      t: Tz
      "y": 
        cv: '0.1'
    WZu: 
      c: 
        from: Indular/Servo
        s: "A.I.WZu = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $Z = I.d&iZu,$s;\nwarn \"About WZ\";\nfor my $k (sort keys %$Z) {\n    my $s = $Z->{$k};\n    die wdump $s if ref $s ne 'ARRAY';\n    unshift @{A.N}, @$s;\n}\nT.not = 1;\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 088bc643504e
        l: Motion
        of: I
      t: WZu
      "y": 
        cv: '0.1'
    ar: 
      c: 
        from: Indular/Motion
        s: "A.I.ar = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $ar;\nar.A=$A;ar.G=$G;ar.C=$C;ar.T=$T;ar.I=$I;\n$ar;\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 165ec51606e1
        of: I
      t: ar
      "y": 
        cv: '0.1'
    array: 
      c: 
        from: Indular/SlideEa
        s: "A.I.array = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nreturn I.d&fourreal,$s if @$s != 1 && !ref $s->[0] || $s->[0] =~ /^\\w+$/;\nreturn I.d&fourstring,$s->[0] if @$s == 1 && !ref $s->[0];\n# should stick In in first and M it? \n# kind of motion that wants to be unsure in the wild\nunshift @{A.N}, @$s;\nT.not = 1;\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 1fec58dc0439
        of: I
      t: array
      "y": 
        cv: '0.1'
    as: 
      c: 
        from: Modems/Pha
        s: "A.I.as = sub {\nmy ($A,$C,$G,$T,@M)=@_;\nmy ($s,$x,@Me) = @M;\nmy $I = A.I;\nfor (qw'begin bb ord tim wtf') {\n     exists $x->{$_} || next;\n     my $v = $x->{$_};\n     $v = [@$v] if ref $v eq 'ARRAY';\n     $v = {%$v} if ref $v eq 'HASH';\n     $s->{$_} = $v;\n}\n};"
      sc: 
        acgt: s,x
        args: A,C,G,T,s,x
        code: I
        dige: 5033d1e30627
        of: I
      t: as
      "y": 
        cv: '0.1'
    bandon: 
      c: 
        from: Modems/Pha
        s: "A.I.bandon = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\ndelete s.J.phy->{s.name};\ns.abandoned = 1;\nif (my $x = s.head) {\n    I.d&as,$s,$x;\n}\nI.d&end,$s\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: d7e447789ace
        of: I
      t: bandon
      "y": 
        cv: '0.1'
    c: 
      c: 
        from: Indular/C
        s: "A.I.c = sub {\nmy ($A,$C,$G,$T,@M)=@_;\nmy ($D,@Me) = @M;\nmy $I = A.I;\nG&inDin,$C,@M;\n};"
      sc: 
        acgt: D
        args: A,C,G,T,D
        code: I
        dige: 0d3c3af9e72f
        of: I
      t: c
      "y": 
        cv: '0.1'
    e: 
      c: 
        from: Indular/C
        s: "A.I.e = sub {\nmy ($A,$C,$G,$T,@M)=@_;\nmy ($D,@Me) = @M;\nmy $I = A.I;\nmy $e = G&sces,C.c.e||return();\nG&inDin,$e,@M;\n};"
      sc: 
        acgt: D
        args: A,C,G,T,D
        code: I
        dige: 268d2c6fb68f
        of: I
      t: e
      "y": 
        cv: '0.1'
    end: 
      c: 
        from: Modems/Pha
        s: "A.I.end = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $y = s.J.phl->{s.name} ||= {name=>s.name, l=>[]};\ns.ended = hitime();\ndelete s.J.phy->{s.name};\nshift @{y.l} while @{y.l} > 5;\n# layers ^ rolling in time index .r -> the y.l\n# so last phase of $name can be found?\npush @{y.l}, $s;\nif (s.bb) {\n    my $w = @{y.l};\n    y.l_bb->{$_} = $w for keys %{s.bb};\n}\n# somewhere thinks about what happened\n$y\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: c1c0a7f86e83
        of: I
      t: end
      "y": 
        cv: '0.1'
    exactl: 
      c: 
        from: Modems/Pha
        s: "A.I.exactl = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $q = shift;\nmy $y = I.d&end,$s;\nmy $cur = y.l->[-1];\nmy $last = y.l->[-2];\n$cur eq $s || die \"sidf$cur $s\";\nlast.bb ||= {};\n\nmy $wtf = I.d&wtfch,cur.bb,last.bb;\n\ndelete s.J.bb->{$_} for keys %{wtf.gone};\n\n# see s.extill, time passing interesto...\n# churn stats like 30% of last disappear, 20% new\ns.wtf = $wtf;\n$wtf;\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 9e4e811b6cdd
        l: "#c un-ins things from J"
        of: I
      t: exactl
      "y": 
        cv: '0.1'
    flywheels: 
      c: 
        from: Indular/Motion
        s: "A.I.flywheels = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nfor my $k (sort keys %{A.fl||return}) {\n    my $v = A.fl->{$k};\n    $k = $2 if $k =~ /^(\\d+) (.+)$/;\n    Rw ym/$k $I $J:A.J $A $C $v $G $T;\n}\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 91d687815272
        of: I
      t: flywheels
      "y": 
        cv: '0.1'
    fourreal: 
      c: 
        from: Indular/SlideEa
        s: "A.I.fourreal = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\n(C.t, C.y) = @$s;\nC.c  = $s->[2] if exists $s->[2];\nC.sc = $s->[3] if exists $s->[3];\ndie'@>4'.wdump $s if @$s > 4;\nif (ref C.t eq 'SCALAR') {    \n    die \"scalaref Ct had Cc\".wdump 4,$C if C.c;\n    (C.t,C.y) = ('',$s);\n}\ndie\"C.t from \".wdump $s if ref C.t; # dives\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: ce20681b4eb3
        of: I
      t: fourreal
      "y": 
        cv: '0.1'
    fourstring: 
      c: 
        from: Indular/SlideEa
        s: "A.I.fourstring = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nI.d&MZu,$1 if $s =~ /^\\s*#?\\s*MZ (.+)$/;\n$s =~ s/^\\s+//;\nif ($s =~ /^\\s*(#.*)$/) {\n   T.not = 1;\n   T.com = $1;\n}\nelsif ($s eq '') {\n   T.not = T.space = 1;\n}\nelse {\n   my $ci = $s;\n   for my $nk (qw't y c sc') {\n       if ($ci =~ s/^(\\S+) *//) { # some t are types of space\n           my $v = $1;\n           $v = I.d&peel,$v if $nk ne 't' && $v =~ I.peels;\n           # << consumes more lines into $nk, then ...\n           $v = '' if $v =~ /^(''|\"\")$/;\n           $C->{$nk} = $v;\n       }\n   }\n}\nsaybl \"4string: $s            \".ki $C if A.V&C;\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 9a408a2c79fe
        of: I
      t: fourstring
      "y": 
        cv: '0.1'
    givy: 
      c: 
        from: Indular/SlideEa
        s: "A.I.givy = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $y = C.y;\nif (ref $s eq 'SCALAR') {\n    my $z = $s;\n    $s = $$s;\n    $s = '%'.$s if $s !~ /^%/;\n    $s =~ /I.peels/ || die \"scalarnopeel $s\";\n    G&xo,C.c,$_ for G&peel,$s;\n\n}\nelsif (ref $s eq 'ARRAY') {\n    for my $yy (@$s) {\n        C.y = {};\n        G&givy,$yy;\n        ref $y || die \"notash \".ki $y;\n        G&xot,$y,C.y;\n        C.y = $y;\n    }\n}\nelsif (ref $s) {\n    ref $s eq 'HASH' || ref $s eq 'REF'\n        || die \"no $s  ref=\".ref $s;\n    if (G&taJe,$s ) {\n        my $yy = C.y;\n        C.y = {} if ref C.y ne 'HASH';\n        G&givy,$yy;\n    }\n    elsif ($y ne $s) {\n        G&xot,$y,$s;\n    }\n}\nelsif ($s eq '') {\n    my $x = I.blanky ? G&blanky : {};\n    G&xot,C.y,$x if keys %$x;\n}\nelsif ($s =~ /^($G::NUM)$/) {\n    y.cv = $1;\n}\nelsif ($s =~ /^($G::NUM)-($G::NUM)$/) {\n    y.in = $1;\n    y.out = $2;\n}\nelsif ($s =~ /^($G::NUM)-($G::NUM)x($G::NUM)$/) {\n    y.in = $1;\n    y.out = $2;\n    y.thi = $3;\n}\nelsif ($s =~ /^-(\\w+)$/) {\n    C.c.pi = $1;\n    C.c.s = C.t if !exists C.c.s || A.btw.cwass;\n}\nelsif ($s =~ /^([a-zA-Z]+)(?::(.+))?$/) {\n    C.c->{$1} = $2 || C.t;\n}\nelse {\n    die \"C y wtf: $s\";\n}\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: a52d0fae8046
        of: I
      t: givy
      "y": 
        cv: '0.1'
    hash: 
      c: 
        from: Indular/SlideEa
        s: "A.I.hash = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nreturn %$C = %$s if exists s.t && s.y && s.c;\nI.d&servehash,$s;\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 9b00a34a9eb1
        of: I
      t: hash
      "y": 
        cv: '0.1'
    hup: 
      c: 
        from: Indular/C/T
        s: "A.I.hup = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $CC = {%$s};\n$CC->{$_} = {%{$CC->{$_}}} for\n    grep {ref $CC->{$_} eq 'HASH'} keys %$CC;\nreturn $CC;\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 21c3cdef1671
        of: I
      t: hup
      "y": 
        cv: '0.1'
    iZu: 
      c: 
        from: Indular/Servo
        s: "A.I.iZu = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $way = $s =~ s/^\\/// ? 'fund' : 'muck';\nmy $Z = Rw $way - $p:s $dclone=1;\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: c7775099e1d2
        of: I
      t: iZu
      "y": 
        cv: '0.1'
    inDin: 
      c: 
        from: Indular/C
        s: "A.I.inDin = sub {\nmy ($A,$C,$G,$T,@M)=@_;\nmy ($s,$D,@Me) = @M;\nmy $I = A.I;\nreturn () unless defined $s;\nreturn $s if $D eq 'C';\n#\nshift @M; # s\n$D = G&interpD,@M if !ref $D;\n#\nmy $v = G&Cngk,$s,$D;\nsaybl \"Got cnkgk: \".wdump 3,[\\@M,$D,$v,$s] if A.VV.D;\ndie \"Unhandles any: $v: \".ki $D if $v eq '1';\n#\nreturn () unless $v;\n# blankgk\nA.note->{D.c.nk}->{D.c.gk} = $v if A.note;\n#\n@$v == 1 || die \"Many somehowed \".wdump 3,[ki($D),$v];\n($v) = @$v;\nif (D.c.as eq 'list') {\n    ref $v eq 'ARRAY' || die 'Cngk for list not array '.ki $D;\n    return @$v;\n}\nreturn $v;\n};"
      sc: 
        acgt: s D
        args: A,C,G,T,s,D
        code: I
        dige: cba92cd974b7
        of: I
      t: inDin
      "y": 
        cv: '0.1'
    interpD: 
      c: 
        from: Indular/C
        s: "A.I.interpD = sub {\nmy ($A,$C,$G,$T,@M)=@_;\nmy ($nk,$gk,@Me) = @M;\nmy $I = A.I;\nmy $defnk = 'c';\nreturn $nk if ref $nk;\nmy $D = {};\nD.c.as = 'list' if $nk =~ s/^_//;\nwhile ($gk =~ s/^%(.+?):(.+?)(?=%|$)//g) {\n    D.c->{$1} = $2;\n    pop @M if @M == 2;\n}\nif (@M == 1 && $nk eq 't') {\n    D.c.nk = $nk;\n}\nelsif (@M == 1) { # or from t,,,\n    D.c.nk ||= $defnk;\n    D.c.gk ||= $nk;\n}\nelsif (@M == 2) {\n    D.c.nk = $nk;\n    D.c.gk = $gk;\n}\ndelete D.c.gk if D.c.gk eq 'NOGK';\n$D\n};"
      sc: 
        acgt: nk gk
        args: A,C,G,T,nk,gk
        code: I
        dige: f1b27a193502
        of: I
      t: interpD
      "y": 
        cv: '0.1'
    ip: 
      c: 
        from: Indular/C/T
        s: "A.I.ip = sub {\nmy ($A,$C,$G,$T,@M)=@_;\nmy ($s,$c,@Me) = @M;\nmy $I = A.I;\nmy $z;\n$s = G&peel,$$s if ref $s eq 'SCALAR';\nmy $n;\nif (ref $s eq 'REF') {\n    # do s.do\n    $s = $$s;\n    $n = $s;\n    s.ip || die \"sip no ref\";\n    $s = {map{$_=> \\s.ip.>$_ }keys %{s.ip}};\n}\n# n.all keeps going after a pass--\nmy $pass = 1;\nEE: for my $k (keys %$s) {\n    $pass == 1 || n.all || return 0;\n    my $y = $s.>$k;\n    my $x = $c.>$k;\n    if (ref $y eq 'REF') {\n        $y = $$y;\n        if (exists y.nk) {\n            $x = $c;\n            for my $k (grep{defined}y.nk,y.gk,y.tk) {\n                $pass--, next EE unless\n                    ref $x eq 'HASH' && exists $x.>$k;\n                $x = $x.>$k;\n            }\n        }\n        my $wa = $pass;\n        !defined $x || $pass-- if y.ndef;\n        defined $x || $pass-- if y.def;\n        y.is eq $x || $pass-- if exists y.is;\n        y.not ne $x || $pass-- if exists y.not;\n        y.in->{$x} || $pass-- if y.in;\n        !y.nin->{$x} || $pass-- if y.nin;\n        $x > y.gt || $pass-- if exists y.gt;\n        $x < y.lt || $pass-- if exists y.lt;\n        $x >= y.gteq || $pass-- if exists y.gteq;\n        $x <= y.lteq || $pass-- if exists y.lteq;\n        $x =~ y.re || $pass-- if exists y.re;\n        $pass = $pass < $wa ? $wa : $pass-1\n            if y.neg;\n    }\n    elsif ($y ne $c.>$k) {\n        $pass--;\n    }\n}\n$pass == 1\n};"
      sc: 
        acgt: s c
        args: A,C,G,T,s,c
        code: I
        dige: 15ce682807e6
        of: I
      t: ip
      "y": 
        cv: '0.1'
    isC: 
      c: 
        from: Indular/SlideEa
        s: "A.I.isC = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nreturn 0 unless ref $s eq 'HASH';\nexists s.t && defined C.t && !ref s.t\n&& ref s.y && ref s.c && 9 > keys %$s;\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: b7d447464bc7
        of: I
      t: isC
      "y": 
        cv: '0.1'
    isJ: 
      c: 
        from: Indular/SlideEa
        s: "A.I.isJ = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nref $s eq 'HASH' && ref s.bb eq 'HASH';\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: b6d0a657a6f3
        of: I
      t: isJ
      "y": 
        cv: '0.1'
    jamsc: 
      c: 
        from: Modems/Jamsc
        s: "A.I.jamsc = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $ar = $s;\nmy $sc = ar.sc || {};\nmy $J = ar.J || die \"jamsc noj\".ki$s;\nar.C = ar.d if ar.d;\nmy $t = defined ar.t ? ar.t\n    : ar.j ? ar.j.l\n    : ar.C ? ar.C.t : die'not';\nmy $cv = defined ar.cv ? ar.cv\n    : ar.j ? ar.j.cv\n    : ar.C ? ar.C.cv || ar.C.y.cv : die'cvoy';\n\nif (ar.oJ && ar.oJ ne ar.J && !ar.noR) {\n    my $J = ar.oJ;\n    if (my $ljm = J.A.ljm) {\n        my $Me = \"ar.oJ.ind ar.J.name \"\n        .\" J.A.ljmo <<< J.name  sends:\"\n        .\" $t\\t$cv  $ljm\";\n        sayyl $Me if J.V || ar.J.V;\n        push @$ljm, {%$ar};\n    }\n}\n\nmy @fobz;\npush @fobz, [$cv,$t,undef,ar.s] if exists ar.s;\npush @fobz, [$cv,$t,$_,$sc->{$_}] for keys %$sc;\nmy @tobz = map {\n    my ($cv,$t,$s,$v) = @$_;\n    my $r;\n    if (J.tt) { # FUTU\n        $r = $cv.\"\\t\".$t.\"\\t\".$s;\n    }\n    else {\n        my $s = $s;\n        $s = '%'.$s if $s;\n        $r = $t.$s.\"\\t\".$cv;\n    }\n    if ($s) {\n        ar.C.sc->{$s} = $v;\n    }\n    [$r,$v]\n} @fobz;\n\nfor (@tobz) {\n    my ($r,$v) = @$_;\n    J.bz->($r,$v);\n}\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: e10b659b1e49
        l: "#c"
        of: I
      t: jamsc
      "y": 
        cv: '0.1'
    more: 
      c: 
        from: Indular/Motion
        s: "A.I.more = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy ($lo) = sort keys %$s;\nif ($lo) {\n    my $ay = delete $s->{$lo};\n    my @N = map { {AZ=>{$lo=>$_}} } @$ay;\n    push @{A.mo.N}, @N;\n    saybl \"Looping \".@N.\" to $lo\" if A.J.V > 1;\n}\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 773fb5fe6514
        of: I
      t: more
      "y": 
        cv: '0.1'
    moy: 
      c: 
        from: Indular/Motion
        s: "A.I.moy = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\n# groups, spread the moise over A\nmy $i = A.mo.y->{$s}||die\"no$s\";\nmy $is = $i->{C.y.p}; # things in our C's pool\n{is=>$is,N=>[map{$is->{$_}}sort keys %$is]};\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 9894eb3b48fd
        of: I
      t: moy
      "y": 
        cv: '0.1'
    oseverato: 
      c: 
        from: Indular/Motion
        s: "A.I.oseverato = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nA.T.d = T.d if T.d;\nif (my $z = delete T.Z) {\n    I.d&Tz,$z;\n}\n!@{A.mo.N} && A.mo.re &&\n    I.d&more,A.mo.re;\nif (my $y = delete T.y) {\n    I.d&mar,T.y;\n}\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: ad99942695a2
        of: I
      t: oseverato
      "y": 
        cv: '0.1'
    peel: 
      c: 
        from: Indular/C
        s: "A.I.peel = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\n$s =~ s/^%//;\nmy $c = {};\nfor (split ',', $s) {\n    my ($k, $v) = split ':', $_, 2;\n    $v = 1 if !defined $v;\n    $c->{$k} = $v;\n}\n$c\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 20667cf19a01
        of: I
      t: peel
      "y": 
        cv: '0.1'
    peels: 
      c: 
        from: Indular/C
        s: "A.I.peels = (sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nqr/^[\\{\\%]\\w+/;\n})->($A,$C,$G,$T);"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 7d6059b05247
        of: I
        subpeel: 1
      t: peels
      "y": 
        cv: '0.1'
    pha: 
      c: 
        from: Modems/Pha
        s: "A.I.pha = sub {\nmy ($A,$C,$G,$T,@M)=@_;\nmy ($J,$name,@Me) = @M;\nmy $I = A.I;\n# tracked being\n# temporal phatness, per suJ (encap $M surges within)\nif (my $x = J.phy->{$name}) {\n    sayre \"J.name 's $name was re entrant\";\n    I.d&end,$x;\n    # end - maybe new stuffright as some random part of this process\n    # hold yay minutes of changes in 10 second groups, etc\n}\n# bz multicasts\nmy $x = J.phy->{$name} = {};\nx.begin = hitime();\nx.name = $name;\nx.J = $J;\nx.bb = {};\nx.ord = [];\n#x.tim = {};\n#x.wtf = {}; # F grab\n#x.ap = sub{}; # bz do aftering\nx.qui = 1;\nx.head = J.phl->{$name}->{l}->[-1] if J.phy->{$name};\n$x;\n};"
      sc: 
        acgt: J,name
        args: A,C,G,T,J,name
        code: I
        dige: 6a41ebf0d831
        of: I
      t: pha
      "y": 
        cv: '0.1'
    rJ: 
      c: 
        from: Modems/Jamsc
        s: "A.I.rJ = sub {\nmy ($A,$C,$G,$T,@M)=@_;\nmy ($r,$J,@Me) = @M;\nmy $I = A.I;\nmy $j;\nmy $sing;\nif (J.tt) {\n    $sing = 'J_tt';\n    (j.cv,j.t,j.style) = $r =~ /^(.*?)\\t(.*)\\t(.*?)$/;\n    if (!defined j.cv) {\n        sayre \"Hind $r  \" for 1..5;\n        (j.t,j.style,j.cv) = $r =~ /^(.+?)(?:%(.+))?\\s+(.+?)$/;\n    }\n}\nelse {\n    (j.t,j.style,j.cv) = $r =~ /^(.+?)(?:%(.+))?\\s+(.+?)$/;\n}\ndefined j.cv || die \"$sing no $r    \".ki $j;\nj.s = J.bb->{$r} if $J;\nj.nos = 1 if $J && !exists J.bb->{$r};\n$j;\n};"
      sc: 
        acgt: r,J
        args: A,C,G,T,r,J
        code: I
        dige: c21993cdde6e
        l: "#c"
        of: I
      t: rJ
      "y": 
        cv: '0.1'
    ratio: 
      c: 
        from: Modems/Timing
        s: "A.I.ratio = sub {\nmy ($A,$C,$G,$T,@M)=@_;\nmy ($o,$t,@Me) = @M;\nmy $I = A.I;\nmy $ratio = $o / ($t||1);\n0.01 * int(100*$ratio);\n};"
      sc: 
        acgt: o,t
        args: A,C,G,T,o,t
        code: I
        dige: 154102a3aff4
        of: I
      t: ratio
      "y": 
        cv: '0.1'
    renc: 
      c: 
        from: Indular/SlideEa
        s: "A.I.renc = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\n(my $s,C.c) = (C.c,{});\nif (ref $s eq 'REF' || ref $s eq 'SCALAR') {\n    C.c.s = $$s;\n    return;\n}\nif (ref $s eq '' && $s =~ /I.peels/) {\n    # peels for now\n    G&xo,C.c,$_ for G&peel,$s;\n}\nelse {\n    A.btw.cwass = 1 if \"\" eq $s;\n    A.btw.cwasnd = 1 if !defined $s;\n    C.c.s = $s;\n}\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 8b5bae0ceb42
        of: I
      t: renc
      "y": 
        cv: '0.1'
    rensc: 
      c: 
        from: Indular/SlideEa
        s: "A.I.rensc = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nC.sc = '%'.${C.sc} if ref C.sc eq 'SCALAR';\nC.sc = C.sc eq '' ? {}\n    : C.sc =~ I.peels\n    ? G&peel,C.sc\n    : die \"C sc nostr: C.sc   of I.peels  \".ki $C\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: b44dd6753a54
        of: I
      t: rensc
      "y": 
        cv: '0.1'
    sano: 
      c: 
        from: Indular/Motion
        s: "A.I.sano = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nA.C = $C;\nA.T = $T;\nreturn$A\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 768000c91a15
        of: I
      t: sano
      "y": 
        cv: '0.1'
    sca: 
      c: 
        from: Indular/C
        s: "A.I.sca = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\n$s /= 10 while $s > 1 || $s < -1;\nreturn $s\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: cdd56c3308e4
        of: I
      t: sca
      "y": 
        cv: '0.1'
    scd: 
      c: 
        from: Modems/Timing
        s: "A.I.scd = sub {\nmy ($A,$C,$G,$T,@M)=@_;\nmy ($rv,$rl,@Me) = @M;\nmy $I = A.I;\nmy $r;\nr.z = [];\nr.oldz = [];\nundef $rl if $rl && rl.c ne rv.c;\npush @{$rl ? r.oldz : r.z}, @{rv.c};\n\nr.in = @{rl.sc||[]};\nr.out = @{rv.sc};\nif (r.out > r.in) {\n    r.ay = [r.in..(r.out - 1)];\n    push @{r.oldz}, @{rv.sc}[0..r.in] if r.in;\n    push @{r.z}, @{rv.sc}[@{r.ay}];\n}\n$r\n};"
      sc: 
        acgt: rv,rl
        args: A,C,G,T,rv,rl
        code: I
        dige: 3f4381cc6821
        of: I
      t: scd
      "y": 
        cv: '0.1'
    sces: 
      c: 
        from: Indular/C
        s: "A.I.sces = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $i = 0;\nwhile (s.c.e) {\n    $s = s.c.e;\n    $i++ > 9 && die \"HUGE $i recursing CceCceCceCce... by \".ki $s;\n}\nreturn $s;\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: d0c8253ecc14
        of: I
      t: sces
      "y": 
        cv: '0.1'
    scyvle: 
      c: 
        from: Indular/C
        s: "A.I.scyvle = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmap { my$i;\n    C.y->{$_} /= 10 while\n    (C.y->{$_} <= -1 || C.y->{$_} >= 1)\n    &&\n    (++$i < 10 || die \"Many i chewing on $_: \".ki C.y)\n}\ngrep { C.y->{$_} }\nqw'in out cv'\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 731015a47e93
        of: I
      t: scyvle
      "y": 
        cv: '0.1'
    servehash: 
      c: 
        from: Indular/Servo
        s: "A.I.servehash = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\ns.AZ ? I.d&AZu,s.AZ\n    : s.MZ ? I.d&MZu,s.MZ\n    : s.EZ ? I.d&EZu,s.EZ\n    : s.WZ ? I.d&WZu,s.WZ\n    : s.EC ? I.d&ECu,s.EC\n    : s.Elvis ? I.d&Elvisu,s.Elvis\n    : die 'hash: '.wdump($s);\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 8c17605be4d7
        of: I
      t: servehash
      "y": 
        cv: '0.1'
    string: 
      c: 
        from: Indular/SlideEa
        s: "A.I.string = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\ndie \"string: $s \".wdump 5, [A.N];\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: f30652ec746f
        of: I
      t: string
      "y": 
        cv: '0.1'
    taJe: 
      c: 
        from: Indular/SlideEa
        s: "A.I.taJe = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $r = $s = $$s if ref $s eq 'REF';\n$r || G&isC,$s || G&isJ,$s || return;\nif ($r || s.bb) {\n    C.c = {e=>C.c} if G&isC,C.c;\n    C.c.s = $s;\n}\nelse {\n    C.c = {s=>C.c} if G&isJ,C.c;\n    C.c.e = $s;\n}\nC.y = {};\nC.c.W = C.t;\nreturn 1\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: a8688b265402
        of: I
      t: taJe
      "y": 
        cv: '0.1'
    tlM: 
      c: 
        from: Modular/Rings
        s: "A.I.tlM = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $os = $s;\n$s = s.M if ref $s eq 'HASH';\nref $s eq 'ARRAY' || return \"S not N/M: \".wdump[$os];\nRw ZNews $N:s;\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: c91d40efa4a8
        nov: 1
        of: I
      t: tlM
      "y": 
        cv: '0.1'
    us: 
      c: 
        from: Indular/C
        s: "A.I.us = sub {\nmy ($A,$C,$G,$T,@M)=@_;\nmy ($D,@Me) = @M;\nmy $I = A.I;\nmy $e = G&sces,C.c.e||return();\nmy $us = e.c.us||return();\npush @M, 'NOGK' if @M == 1;\nG&inDin,$us,@M;\n};"
      sc: 
        acgt: D
        args: A,C,G,T,D
        code: I
        dige: 9c32a0a00a75
        of: I
      t: us
      "y": 
        cv: '0.1'
    wtfch: 
      c: 
        from: Modems/Pha
        s: "A.I.wtfch = sub {\nmy ($A,$C,$G,$T,@M)=@_;\nmy ($Jb,$Yb,@Me) = @M;\nmy $I = A.I;\nmy $wtf = {};\nwtf.same = 1;\n$wtf->{$_} = {} for qw'new diff gone';\n\nfor (sort keys %$Jb) {\n    if (!exists $Yb->{$_}) {\n        wtf.new->{$_} = $Jb->{$_};\n        wtf.same = 0;\n    } \n    elsif ($Yb->{$_} ne $Jb->{$_}) {\n        wtf.diff->{$_} = $Jb->{$_};\n        wtf.same = 0;\n    }\n    else {\n        wtf.sami++;\n        wtf.still->{$_} = $Jb->{$_};\n    }\n    wtf.tot++;\n}\nfor (grep { !exists $Jb->{$_} } sort keys %$Yb) {\n    wtf.gone->{$_} = $Yb->{$_};\n    wtf.same = 0;\n}\n$wtf;\n};"
      sc: 
        acgt: Jb,Yb
        args: A,C,G,T,Jb,Yb
        code: I
        dige: a0a901d4f11b
        l: "#c diff J"
        of: I
      t: wtfch
      "y": 
        cv: '0.1'
    xo: 
      c: 
        from: Indular/C/T
        s: "A.I.xo = sub {\nmy ($A,$C,$G,$T,@M)=@_;\nmy ($s,$c,@Me) = @M;\nmy $I = A.I;\nref $c eq 'HASH' && ref $s eq 'HASH'\n    || die \"Hash up\".wdump 3, [$s,$c];\nwhile (my($k,$v) = each %$c) {\n    $s->{$k} = $v;\n}\nreturn $s\n};"
      sc: 
        acgt: s c
        args: A,C,G,T,s,c
        code: I
        dige: 3fe77b2bee02
        of: I
      t: xo
      "y": 
        cv: '0.1'
    xot: 
      c: 
        from: Indular/C/T
        s: "A.I.xot = sub {\nmy ($A,$C,$G,$T,@M)=@_;\nmy ($s,$c,@Me) = @M;\nmy $I = A.I;\nref $c eq 'HASH' && ref $s eq 'HASH'\n    || die \"Hash up\".wdump 3, [$s,$c];\nwhile (my($k,$v) = each %$c) {\n    $s->{$k} = ref $v eq 'HASH' ?\n                {%{$s->{$k}||{}}, %$v}\n    : $v;\n}\nreturn $s\n};"
      sc: 
        acgt: s c
        args: A,C,G,T,s,c
        code: I
        dige: f563a13757f0
        of: I
      t: xot
      "y": 
        cv: '0.1'
    xoy: 
      c: 
        from: Indular/C/T
        s: "A.I.xoy = sub {\nmy ($A,$C,$G,$T,@M)=@_;\nmy ($s,$c,@Me) = @M;\nmy $I = A.I;\n$c = G&xot,{},$c;\nG&xot,$c,$s;\nreturn $s;\n};"
      sc: 
        acgt: s c
        args: A,C,G,T,s,c
        code: I
        dige: c7efffb7d7d5
        of: I
      t: xoy
      "y": 
        cv: '0.1'
    z: 
      c: 
        from: Indular/Motion
        s: "A.I.z = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nI.d&oseverato;\npush @{A.M}, @{T.oM};\ndelete T.not;\n1\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: aac5b6b6d05e
        of: I
      t: z
      "y": 
        cv: '0.1'
  "0.11": 
    after: 
      c: 
        from: Indular/Bangdesk
        s: "A.I.after = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nA.bangdesk = {};\nA.bangdesk.main = sub {\n    $_->() for values %{A.bangdesk.aft};\n    $@ || return;\n    A.bang && return;\n    A.bang = 21;\n    $_->() for values %{A.bangdesk.bang};\n    # want to sus $@ and hang vectors of what, should be autoish\n    my $m = \"J: A.mo.ont.talk        A.mo.ont.cv\";\n    $m .= \"\\nC: \".k2 A.mo.ont.C;\n    $m .= \"\\ns: \".wdump 3, A.mo.ont.s unless length $m > 20;\n    sayre \" * bangdesk: \\n$m\";\n    return $m;\n};\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: I
        dige: 144c7ec694d2
        of: I
      t: after
      "y": 
        cv: '0.11'
  "0.12": 
    Ci: 
      c: 
        from: Indular/SlideEa
        s: "A.I.Ci = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $r = ref $s;\n!$r ? G&string,$s :\n'ARRAY'eq$r ? G&array,$s :\n'HASH'eq$r ? G&hash,$s :\n'SCALAR'eq$r ? do {\n    C.t ||= '';\n    C.y = $s;\n} :\ndie \"mmtype:$r for $s\"\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: I
        dige: 2f79ac554527
        of: I
      t: Ci
      "y": 
        cv: '0.12'
  "0.18": 
    reasonlock: 
      c: 
        from: Indular/SlideEa
        s: "A.I.reasonlock = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\ndie\"reft\" if ref C.t;\nif (A.J && (A.J.name eq 'qq' || A.J.most.J eq A.J)) {\n    C.c.W = C.t unless C.c || C.sc || C.y;\n}\nI.d&renc if ref C.c ne 'HASH';\n\nmy $yy = C.y;\nC.y = {} if ref C.y ne 'HASH';\nI.d&givy,$yy;\n\nI.d&rensc if ref C.sc ne 'HASH';\n\nI.d&isC,$C && ref C.sc\n    || die \"reaso fail\".wdump [A.s,$C];\nI.d&scyvle;\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: I
        dige: 48c2d4c4aa50
        of: I
      t: reasonlock
      "y": 
        cv: '0.18'
  "0.71": 
    CoM: 
      c: 
        from: Indular/Motion
        s: "A.I.CoM = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\npush @{T.oM}, $C unless T.Z;\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: I
        dige: c801cbee70c2
        of: I
      t: CoM
      "y": 
        cv: '0.71'
  "0.9": 
    erg: 
      c: 
        from: Indular/Bangdesk
        s: "A.I.erg = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\n# must pre compile, see D severators\nmy $m = \"J: A.talk\";\n$m .= \"\\nC: \".ki $C;\n$m .= \"\\ns: \".wdump 3, A.s unless length $m > 20;\n$@ = \"$m\\n$@\";\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: dda79d817d59
        of: I
      t: erg
      "y": 
        cv: '0.9'
Ii: Indular vers:HASH + Jing vers:HASH + Modems vers:HASH + Modular vers:HASH
J: 
  "0.6211": 
    J_6211: 
      c: 
        from: Jing/Jiterbug
        s: "A.I.J_6211 = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $c = C.c;\nmy $J = C.c.J;\nmy $y;\nmy $M = y.o.M = [];\nmy $qq = I.d&Elj,$J,'qq';\nA.hqq = qq.A.hqq = I.d&pha,$qq,'hqq';\nJ.oy = $y;\nJ.at ||= G&tie,Ghoz=>{inp=>['oy','at'],o=>$J};\n\nreturn if exists C.c.pi;\n\nif (A.ztime < 9) {\n    if (A.jr&bol) {\n        sayre \"STOPPING \".ki($C) for 1..3;\n        # TODO stop\n    }\n    A.bangdesk.aft.unblocknine = A.jr&bol,9;\n}\nA.bangdesk.bang.bang_ts = sub {\n    A.jr&bang_ts,hitime\n};\n\nC.c.pin ||= J.name;\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: J
        dige: a0a30f4d39ac
        gk: J
        nk: c
        of: J
        v: cJ
      t: J_6211
      "y": 
        cv: '0.6211'
  "0.621121": 
    J_6211211: 
      c: 
        from: Jing/Foli
        s: "A.I.J_6211211 = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $c = C.c;\nmy $J = C.c.J;\nJ.le && return;\nmy $x = [];\nfor my $j (A.J, J.mo.J) {\n    my $pix = j.pix;\n    push @$x, ref $pix eq 'ARRAY' ? @$pix : $pix if $pix;\n    if (my $pich = j.pich) {\n        push @$x, ref $_ eq 'ARRAY' ? @$_ : $_ for values %$pich;\n    }\n}\n@$x || return;\nmy @m = ref $x eq 'ARRAY' ? @$x : $x;\nfor my $x (@m) {\n    if (x.pi ? C.c.pi eq x.pi : \n        x.any ? 1 :\n        0) {\n        saygr \"matched: J.name ::: \".ki $x if A.V&T;\n        \n        x.u &&\n        u x.u\n        \n        C.c.pi = C.sc.pi = x.pito if x.pito;\n        \n        x.Rw &&\n            Rw x.Rw $J $y:J.oy;\n    }\n    # up!\n}\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: J
        dige: 9cd64e24f88c
        gk: J
        nk: c
        of: J
        v: cJ
      t: J_6211211
      "y": 
        cv: '0.621121'
  "0.6212": 
    J_6212: 
      c: 
        from: Jing/Jiterbug
        s: "A.I.J_6212 = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $c = C.c;\nmy $J = C.c.J;\nreturn unless exists C.c.pi;\n\n#sayre'csnod'.wdump 2, [$C, J.C] if $C ne J.C;\n#J.C = $C;\nJ.cv = (C.c.gp && C.c.gp.cv) || C.c.cv || 0.6;\nmy $path = C.sc.pi||die'nopi';\nif (J.A.d > 9) {\n    $path = 'text';\n    warn \"J.name J.A.d limit to text\";\n}\nC.c.pin = \"pi/$path\";\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: J
        dige: e2503466fa2d
        gk: J
        nk: c
        of: J
        v: cJ
      t: J_6212
      "y": 
        cv: '0.6212'
  "0.631": 
    J_631: 
      c: 
        from: Jing/Jiterbug
        s: "A.I.J_631 = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $c = C.c;\nmy $J = C.c.J;\nI.d&exactl,A.hqq;\nA.coi = I.d&pha,$J,'ako';\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: J
        dige: 2f3501b303de
        gk: J
        nk: c
        of: J
        v: cJ
      t: J_631
      "y": 
        cv: '0.631'
  "0.632": 
    J_632: 
      c: 
        from: Jing/Juperfi
        s: "A.I.J_632 = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $c = C.c;\nmy $J = C.c.J;\n#return 1 unless exists C.sc.pi;\n\nmap { # telephone winch, propaganda (top-er levels receiving stuff)\n     J.A->{$_} = J.Jiter.A->{$_}\n     if J.Jiter && J.Jiter.A->{$_};\n} qw'ljm ljmo';\n\nA.time = sub {\n    my($JJ,$q) = @_;\n    $J eq $JJ || die \"wtfJure  J.name   vs JJ.name\";\n    # wanna A.t&T,2,0 us to difference streams\n    # they could be xot maps or code to run\n    # then all over things \n    \n    if ($q == 2) {\n        my $sc = Rw Jamroot $J $C:J.C $y:J.oy if J.oy.at;\n        \n        A.ico = I.d&pha,$J,'ico';\n        A.ico.qui = 1;\n        I.d&as,A.ico,A.coi;\n        my $wtf = I.d&exactl,A.ico;\n        say \"Jump32: \". wdump 3, $wtf;\n        \n        if (wtf.last && !wtf.same) {\n            my $uf = join \"\\n\", map{\"$_: \".wdump(1,$wtf->{$_})}\n                grep {keys %{$wtf->{$_}}} qw'new diff gone';\n            saybl \"T.alk  2222  $uf\";\n        }\n        \n        my $iM = 1 if sc.osci && J.mo.J.act;\n        my $stick = !J.mo.J.act && !$iM && # travel part\n            Rw eighthnot $J;\n        if (!$stick) { # am sticking\n            my ($o,$O) = (J.oy,J.Oy);\n            for (grep{$o->{$_} ne $O->{$_}} \n                grep{!ref $o->{$_}} keys %$o) {\n                $stick = 1; # unless y.? nonref changed, or wider spacer\n                saybl \"J.name unstuck due to ychange: $_:\"\n                    .\" $o->{$_} ne $O->{$_}\";\n            }\n        }\n        # rhythm^\n        if ($stick) {\n            A.ico.wtf.same = 0;\n        }\n        elsif (wtf.same) {\n            T.iM = $iM if $iM;\n            return 0;\n        }\n        \n        # for the lift, osc should Jiter ne A.J and pd it\n        J.A.ljm = [];\n        J.A.ljmo = \"fr  J.name\";\n        return 1;\n    }\n    \n    warn \"T.alk other $q\";\n    if ($q == 8) {\n        # until J.most coord attention evaporates\n        # as in pulling on a list\n    }\n    A.ztime >= $q;\n};\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: J
        dige: f785a635c1b7
        gk: J
        nk: c
        of: J
        v: cJ
      t: J_632
      "y": 
        cv: '0.632'
  "0.66": 
    J_66: 
      c: 
        from: Jing/Jiterbug
        s: "A.I.J_66 = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $c = C.c;\nmy $J = C.c.J;\nmy $ar = {%{C.c}};\nar.s = '' if !exists ar.s;\nar.u = ar.s;\nar.pin = C.c.pin || die \"nopin\";\nmy $y = J.oy;\nmy $M = y.o.M;\n\nRw ar.pin + $A $C $G $T $I $J $M $y;\n\nRw Jamroot $J $y if y.at;\nif (T.iM) {\n    J.Oy || die \"no JOy J.name\";\n    ref J.Oy.o eq 'HASH' || die \"J.name oYo not hash/picked up\";\n    ref J.Oy.o.M eq 'ARRAY' || die \"J.name oYoM not array\";\n    push @$M, @{J.Oy.o.M};\n}\nJ.Oy = $y;\nif (@$M) {\n    n z=>$y=>{}\n}\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: J
        dige: d3a2b1aaa534
        gk: J
        nk: c
        of: J
        v: cJ
      t: J_66
      "y": 
        cv: '0.66'
  "0.672": 
    J_672: 
      c: 
        from: Jing/Juperfi
        s: "A.I.J_672 = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $c = C.c;\nmy $J = C.c.J;\nreturn unless A.ico && A.ico.wtf.same;\nmy $cut = @{A.ico.ord};\nmy @cc = @{A.coi.ord};\nif (@cc > $cut) {\n    warn\"J.name entered stuff after 2!\".wdump [@cc, \n    '                 =============', @{A.ico.ord}];\n}\nI.d&bandon,A.coi;\nif (my $ljm = J.A.ljm) {\n    for my $s (@$ljm) {\n        s.noR=1;\n        I.d&jamsc,$s;\n    }\n}\nsayre \"SKIP T.alk\";# if J.V || J.most.J.V;\nT.whack = 1; # exit A.t&J\nT.same = 1; # exit Mo, T.not but not, kind of unlet ztime6->7\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: J
        dige: 00368ebcb8c2
        gk: J
        nk: c
        of: J
        v: cJ
      t: J_672
      "y": 
        cv: '0.672'
  "0.677": 
    J_677: 
      c: 
        from: Jing/Jiterbug
        s: "A.I.J_677 = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $c = C.c;\nmy $J = C.c.J;\nmy $y = J.oy;\nRw Jamroot $J $y if y.at;\n# leaving the above\nif (J.oy.ope) {\n    sayyl \"Leaving J.name open pha...\" if A.V&ope;\n    I.d&end,A.coi;\n    return;\n}\nA.coi.qui = 1;\nmy $wt = I.d&exactl,A.coi;\nif (wt.same) {\n    if (++J.A.wch > 4) {\n        J.A.wch = 0;\n        # ^ rate to avoid v see J 632 eighthnot\n    }\n    else {\n       sayre \"SAME T.alk\" if A.V&SAME;\n       T.same = 1;\n    }\n}\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: J
        dige: 110e11e55fd4
        gk: J
        nk: c
        of: J
        v: cJ
      t: J_677
      "y": 
        cv: '0.677'
Mo: 
  "0.201": 
    bals_201: 
      c: 
        from: Modular/Wrinkles
        s: "A.I.bals_201 = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $c = C.c;\nmy $bals = C.c.bals;\n# a non-s\nmy $N = C.c.bals;\n$N = [ map { [$_] } split \"\\n\",$N ] if !ref $N;\nmy $y = C.y || die\"noy\";\ny.o && return sayre \"bals y o already\".wdump[ki $C, $y, I.d&tlM,y.o ];\ny.bal && return sayre \"bals y bal already\".wdump[ki $C, $y, I.d&tlM,y.bal ];\ny.bal = [];\n# have some minions to od thi:\nA.oA || die \"wanting to s bab, no oA\";\nRw In $J:A.J $M:y.bal $N;\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo
        dige: f8129affbbad
        gk: bals
        nk: c
        of: Mo
        v: cbals
      t: bals_201
      "y": 
        cv: '0.201'
  "0.21": 
    yo_: 
      c: 
        from: Modular/Space
        s: "A.I.yo_ = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $y = C.y;\nmy $o = C.y.o;\n$o = C.y.o = {M=>$o} if ref $o eq 'ARRAY';\no.M ||= [$C];\n# 4d jelly slower-downer\n# so we should acquire many A.t&\n# this is an EC into our C's T.oM, as s.M now\n# stackable A with stitchable others interleaved in time\n# 6 FLIES\no.M = [grep{defined}map{\n    my $d;\n    ref $_ || die \"oM nonhashi \".wdump 2, o.M;\n    d.t = _.t;\n    d.y = {%{_.y}};\n    d.c = {%{_.c}};\n    delete d.y.cv if y.ecv;\n    # allow any cv to wander from yarNgrid:\n    #y.cvil = 1 if defined d.y.cv;\n    d.sc = {%{_.sc||{}}};\n    # TRansituio, soul spread\n    if (o.ou) {\n        # inside our, change slightly how we see\n        # spread compound\n        d.c.pi = o.ou;\n        d.c.s = $_;\n    }\n    d.sc.oJ = o.oJ if o.oJ;\n    # travel agent ^\n    # traveli\n    Rw C14 $I $A $C:d;\n    #\n    A.J.V && say \"AH A.J.name  ::: d.t   \".ki d.sc;\n    keys %$d ? $d : undef\n}@{o.M}];\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo
        dige: 13e36e6b6035
        gk: o
        nk: 'y'
        of: Mo
        v: yo
      t: yo_
      "y": 
        cv: '0.21'
  "0.22": 
    yon_: 
      c: 
        from: Modular/Space
        s: "A.I.yon_ = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $y = C.y;\nmy $o = C.y.o;\nmy $J = A.J;\nmy $Jy = J.C.y; # pi's sea\n# surface tesion, lum\nif (my $lt = C.y.limn) {\n    Jy.spc || die \"no space ! J.name - C.t keep more numbers\";\n    my $rl = int(9 * $lt * Jy.spc);\n    my $was = @{o.M};\n    C.y.rowlisp = $rl;\n    C.y.rowas = $was;\n    C.y.Jyspc = Jy.spc;\n    if ($was > $rl) {\n        my @um = @{o.M};\n        @um = @um[0..$rl-1];\n        @{o.M} = @um;\n        # space mod\n        my $s = $was;\n        n limo=>0.7,\"$was>$rl\",'%fs:7,hs:7487';\n    }\n}\nC.y.bal = o.M || die\"nomo\";\n# unless y unlimited...until\no.J = J.most.J if $Jy && Jy.o && Jy.spc > 0.1;\ndelete o.J if y.clos;\nmy $shut = $Jy && Jy.o && !o.J;\nC.y.over = (Jy.o && Jy.over && Jy.over || 0) + 0.06 if y.o.J;\n#sayre \"Jyspace: spc:  J.d.y.spc  or aspace: Jy.aspace\" if $Jy;\n# divvy space inside parent's share most J or in 3-4 of the pi\nmy $sl = Jy.spc * 0.01;\n$sl = 0.02 if $sl < 0.02;\nC.y.in ||= $shut ? 0.3 : $Jy ? Jy.cv + $sl : 0.1;\nC.y.out ||= $shut ? 0.4 : $Jy ? Jy.ov - $sl : 0.9;\nC.y.lum = y.lumfa if y.lumfa;\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo
        dige: 95e1a3198c2b
        gk: o
        nk: 'y'
        of: Mo
        v: yo
      t: yon_
      "y": 
        cv: '0.22'
  "0.223": 
    bal_0223: 
      c: 
        from: Modular/bal
        s: "A.I.bal_0223 = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $y = C.y;\nmy $bal = C.y.bal;\ny.thi = @$bal;\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo
        dige: 6f384294c128
        gk: bal
        nk: 'y'
        of: Mo
        v: ybal
      t: bal_0223
      "y": 
        cv: '0.223'
  "0.23": 
    yin_023: 
      c: 
        from: Modular/Spaci
        s: "A.I.yin_023 = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $y = C.y;\ny.cv ||= 0.1 if !defined y.cv && !defined y.in;\ny.in = y.cv if defined y.cv;\ny.in ||= 0.1;\ny.out = y.in + y.space if defined y.space;\ny.out ||= 0.9;\ny.thi ||= 1;\nif (my $mk = y.ert) {\n    $mk += y.ert while y.thi > $mk;\n    y.thi = $mk;\n}\ny.space = y.out - y.in;\ny.space *= -1 unless y.space > 0;\ny.aspace = y.space / y.thi;\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo
        dige: 09bfa8f4b59f
        nk: 'y'
        of: Mo
        v: 'y'
      t: yin_023
      "y": 
        cv: '0.23'
  "0.233": 
    lum_0233: 
      c: 
        from: Modular/lum
        s: "A.I.lum_0233 = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $y = C.y;\nmy $lum = C.y.lum;\nmy $bal = C.y.bal;\nmy $um = {};\n(um.l,um.r) = split ',', $lum;\n$um->{$_} =\n    $um->{$_} =~ /^(?:(\\d+)-)??(?:(\\d)+)(?:-(\\d)+)?$/\n    ? {i=>$1,um=>$2,o=>$3}\n    : die \"notunder: \".wdump 2, $um\n    for grep{defined $um->{$_}} keys %$um;\nsaybl \"Lum C.t: \". wdump 2, $um;\num.l.um ||= 3;\nmy $lumhalvesby = (um.l.um / 2) / (um.r.um || 3);\nmy $i = 0;\nfor (@$bal) {\n    _.y.thy+=um.l.um;\n    $i++;\n    if ($i > um.l.o) {\n        um.l.um -= $lumhalvesby if um.l.um > 0.1;\n    }\n}\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo
        dige: 2d41d806321b
        gk: lum
        nk: 'y'
        of: Mo
        rg: bal
        v: ylum
      t: lum_0233
      "y": 
        cv: '0.233'
  "0.241": 
    bal_0241: 
      c: 
        from: Modular/bal
        s: "A.I.bal_0241 = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $y = C.y;\nmy $bal = C.y.bal;\nmy $total = sum(map { y.thy||1 } @$bal) || 1;\nmy $over = @$bal || 1;\ny.u.muav = $over / $total;\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo
        dige: fdf2000554e0
        gk: bal
        nk: 'y'
        of: Mo
        v: ybal
      t: bal_0241
      "y": 
        cv: '0.241'
  "0.26": 
    yarN_026: 
      c: 
        from: Modular/Spaci
        s: "A.I.yarN_026 = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $y = C.y;\nref $y eq 'HASH' || die \"Notash: \".wdump 2, $C;\n!defined y.u || ref y.u eq 'HASH' || die \"Nou : y.u \".wdump 2, $y;\ny.u.v = defined y.cv ? y.cv\n    : defined y.in ? y.in\n    : die \"no yiny\".ki$y;\ny.thi || die \"Whythi\".ki$C;\ndie \":idify\" if $y ne C.y;\nmy @lot = map {\n    my $C = eval { I.d&xot,{},$C };\n    C.y.i = $_-1;\n    $@ && die \"Tpp \".wdump 2, $C;\n    $C\n} 1..y.thi;\nif (@lot > 1) {\n    push @{A.mo.re->{0.29}||=[]}, map{[undef,$_]}@lot;\n    T.not = 1;\n}\nelse {\n    my ($CC) = @lot;\n    ref $CC eq 'HASH' || die \"not one? $CC\";\n    %$C = %$CC;\n}\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo
        dige: 8cd2d2451b2c
        nk: 'y'
        of: Mo
        v: 'y'
      t: yarN_026
      "y": 
        cv: '0.26'
  "0.3": 
    yinvout_03: 
      c: 
        from: Modular/Spaci
        s: "A.I.yinvout_03 = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $y = C.y;\ny.mu = 1;\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo
        dige: ad46585553f0
        nk: 'y'
        of: Mo
        v: 'y'
      t: yinvout_03
      "y": 
        cv: '0.3'
  "0.301": 
    bal_0301: 
      c: 
        from: Modular/bal
        s: "A.I.bal_0301 = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $y = C.y;\nmy $bal = C.y.bal;\nmy $CC = $bal->[y.i];\nreturn T.not = 1 if ref $CC ne 'HASH';\n$CC ||= {};\nI.d&xot,$C,$CC;\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo
        dige: 4abc5e4585e9
        gk: bal
        nk: 'y'
        of: Mo
        v: ybal
      t: bal_0301
      "y": 
        cv: '0.301'
  "0.3211": 
    J_3211: 
      c: 
        from: Jing/Jlaces
        s: "A.I.J_3211 = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $c = C.c;\nmy $J = C.c.J;\nC.c.W = $J unless ref C.c.W;\nref C.c.W || !ref $J || C.c.W eq J.name || die \"J.name isn't\".ki(C.c);\n!ref C.c.W || !ref $J || C.c.W eq $J || die \"nzoWJ\".ki(C.c);\n# avoid 6ing, its doubling orso\nA.ztime = 3 if A.J.name ne 'qq'; # break off\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo
        dige: 9c005808c442
        gk: J
        nk: c
        of: Mo
        v: cJ
      t: J_3211
      "y": 
        cv: '0.3211'
  "0.3213": 
    pi_3213: 
      c: 
        from: Jing/Jlaces
        s: "A.I.pi_3213 = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $c = C.c;\nmy $pi = C.c.pi;\n# - c. language is map to some u before 6ing\nref $pi && die\"refpi: \".wdump 2, $pi;\nC.sc.pi = $pi || 'guess';\nC.c.J = 'pi';\nmy $oJ = A.J;\n$oJ = C.y.o.J if C.y.o && C.y.o.J;\nA.jr = Rw Ajr $J:oJ $C;\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo
        dige: b46c8d6e71da
        gk: pi
        nk: c
        of: Mo
        v: cpi
      t: pi_3213
      "y": 
        cv: '0.3213'
  "0.3214": 
    W_3214: 
      c: 
        from: Jing/Jlaces
        s: "A.I.W_3214 = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $c = C.c;\nmy $W = C.c.W;\nmy $t = $W;\n$t = W.name if ref $t;\nmy $jr = Rw Ajr $J:G.oin $t $cv=0.3;\n\nreturn C.c.W = die \"SOIDNG RESEAR(pi with W)\".ki $C\n    if C.c.pi; # doing research\nA.jr = $jr; # being\n\nC.sc.W = $t;\nC.sc.J = ref $W ? $W : $t;\n# going over J should be same...\nC.c.J ||= $W;\nC.t = $t;\nC.y.cv ||= 0.3;\n# and where the thrust (J.A?)\nif (C.c.vv) {\n    A.ztime = delete C.c.vv;\n    A.jr&vv,'',9\n}\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo
        dige: 27d7deb9f55c
        gk: W
        nk: c
        of: Mo
        v: cW
      t: W_3214
      "y": 
        cv: '0.3214'
  "0.337": 
    bal_0337: 
      c: 
        from: Modular/bal
        s: "A.I.bal_0337 = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $y = C.y;\nmy $bal = C.y.bal;\ny.mu = y.thy if exists y.thy;\ny.mu = y.mu * y.u.muav if y.u.muav;\n#\nsay \"A.J.C.t  /  T.t ist y.mu  among y.u.muav\"\n    if A.J.V && y.u.muav != 1;\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo
        dige: 961c52ddca78
        gk: bal
        nk: 'y'
        of: Mo
        v: ybal
      t: bal_0337
      "y": 
        cv: '0.337'
  "0.34": 
    black_034: 
      c: 
        from: Modular/Spaci
        s: "A.I.black_034 = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $y = C.y;\nmy $was = y.u.v;\ndefined $was || die\"noAv\".ki$C;\n# in:\ny.cv = 0+sprintf '%.6f', y.u.v unless y.cvil && defined y.cv;\ny.pcv = 0+sprintf '%.6f', y.i / C.y.thi;\n# over:\nmy $in = y.aspace * y.mu;\ny.u.v += $in;\n# out: \ny.ov = sprintf '%.6f', y.u.v;\ny.spc = y.ov - y.cv;\n#\nsayyl \"Bend: C.t   $was += $in       y.aspace * y.mu       muav:y.u.muav\"\n    if A.J.V && y.u.muav && y.u.muav != 1;\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo
        dige: 780c2d1c9cc0
        nk: 'y'
        of: Mo
        v: 'y'
      t: black_034
      "y": 
        cv: '0.34'
  "0.341": 
    J_341: 
      c: 
        from: Jing/Joot
        s: "A.I.J_341 = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $c = C.c;\nmy $J = C.c.J;\nmy $f = A.jr&J;\nmy $j = C.sc.J;\nref $j && ref $f && ($j eq $f || die \".sc J dif $f $j\");\n# hilum & tie sc so vis, substrate insecting\nC.c.J = C.sc.J = $f if $f && ref $f && !f.dead;\nA.Iso.oJ = 1; # getting pinned into J\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo
        dige: f40a712d52d2
        gk: J
        nk: c
        of: Mo
        v: cJ
      t: J_341
      "y": 
        cv: '0.341'
  "0.342": 
    X_342: 
      c: 
        from: Jing/Joot
        s: "A.I.X_342 = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $c = C.c;\nmy $X = C.c.X;\nmy $J = C.sc.J;\nsayre \"DELING J.name\".ki$C;\n$J || die \"X no J\";\nref $J || die \"Nofound $J  C.t   C.y.cv\";\n$X eq $J || die \"noovewr X  C.c.X ne $J\";\nA.jr&J,$J,9;\nJ.dead = 1;\n# SNat bail, we have balin by now so hole in space this time\nT.not = 1;\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo
        dige: b6d1c5cd5b62
        gk: X
        nk: c
        of: Mo
        v: cX
      t: X_342
      "y": 
        cv: '0.342'
  "0.37": 
    ent_037: 
      c: 
        from: Modular/Spaci
        s: "A.I.ent_037 = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $y = C.y;\n$y->{$_} = 0+sprintf('%.6f',$y->{$_}) for qw'cv ov aspace spc';\nC.sc.yspc = y.spc if C.sc.nspc;\nC.sc.ml = (C.y.over * 40).\"%\" if y.over;\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo
        dige: e5e45151c9a6
        nk: 'y'
        of: Mo
        v: 'y'
      t: ent_037
      "y": 
        cv: '0.37'
    lum_037: 
      c: 
        from: Modular/lum
        s: "A.I.lum_037 = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $y = C.y;\nmy $lum = C.y.lum;\nmy $spc = C.y.spc;\n# feel effects of... f eel\nmy $upt = 0;\n$spc = $upt if $spc < $upt;\n# t-rewirey formulae:\nmy $fs = ($spc / 0.02) * 4;\nC.sc.fs = $fs;# if $fs < 9;\nC.y.spc = $spc;\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo
        dige: 9f7d2692b241
        gk: lum
        nk: 'y'
        of: Mo
        rg: spc
        v: ylum
      t: lum_037
      "y": 
        cv: '0.37'
  "0.42": 
    id_42: 
      c: 
        from: Modular/Wrinkles
        s: "A.I.id_42 = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $c = C.c;\nmy $id = C.c.id;\nC.sc.id = $id;\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo
        dige: 978d6868350b
        gk: id
        nk: c
        of: Mo
        v: cid
      t: id_42
      "y": 
        cv: '0.42'
    idly_42: 
      c: 
        from: Modular/Wrinkles
        s: "A.I.idly_42 = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $c = C.c;\nmy $idly = C.c.idly;\nC.sc.id = mkuid();\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo
        dige: 2e6df5bb59f8
        gk: idly
        nk: c
        of: Mo
        v: cidly
      t: idly_42
      "y": 
        cv: '0.42'
    pwar_42: 
      c: 
        from: Modular/Wrinkles
        s: "A.I.pwar_42 = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $c = C.c;\nmy $pwar = C.c.pwar;\nC.sc.pwar = $pwar;\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo
        dige: 0863a0af13cb
        gk: pwar
        nk: c
        of: Mo
        v: cpwar
      t: pwar_42
      "y": 
        cv: '0.42'
    pwth_42: 
      c: 
        from: Modular/Wrinkles
        s: "A.I.pwth_42 = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $c = C.c;\nmy $pwth = C.c.pwth;\n# 8case, to way\n$pwth =~ s/^(?!!)/!/s;\nC.c.path = $pwth;\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo
        dige: 19fac008cf29
        gk: pwth
        nk: c
        of: Mo
        v: cpwth
      t: pwth_42
      "y": 
        cv: '0.42'
  "0.421": 
    path_421: 
      c: 
        from: Modular/Wrinkles
        s: "A.I.path_421 = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $c = C.c;\nmy $path = C.c.path;\n# install sc path, wants idlyness (indexedness)\nC.sc.path = $path;\nC.sc.idly = 1 if !C.c.fo;\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo
        dige: c863eeeded28
        gk: path
        nk: c
        of: Mo
        v: cpath
      t: path_421
      "y": 
        cv: '0.421'
  "0.436": 
    time_436: 
      c: 
        from: Jing/Jamping
        s: "A.I.time_436 = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $c = C.c;\nmy $time = C.c.time;\nA.ztime = delete C.c.time;\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo
        dige: cf0ab9d99e43
        gk: time
        nk: c
        of: Mo
        v: ctime
      t: time_436
      "y": 
        cv: '0.436'
  "0.77": 
    pin_077: 
      c: 
        from: Modular/Spaci
        s: "A.I.pin_077 = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $y = C.y;\nreturn if delete T.oke;\nmy $oJ = A.J;\nmy $J = C.y.o && C.y.o.J || $oJ;\nmy $ar = {};\nar.s = C.c.s if exists C.c.s;\nRw jamsc + $J $oJ $C $sc:C.sc;\nsayyl \"Hamsc! A.talk: C.t C.y.cv     \".ki(1,{c=>C.c,sc=>C.sc})\n    if A.J.V;\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: Mo
        dige: ab93cceef46a
        nk: 'y'
        of: Mo
        v: 'y'
      t: pin_077
      "y": 
        cv: '0.77'
oJ: 
  "0.343": 
    J_343: 
      c: 
        from: Jing/Joot
        s: "A.I.J_343 = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $c = C.c;\nmy $J = C.c.J;\nreturn if ref $J;\n$J = Rw Jto $name:J;\n# DROP\nG.Wids->{J.id} && G.W->{J.id} ne $J && die \"runup J.name\";\nG.Wids->{J.id} = $J;\nref $J || die 'watt'.$J;\nif (exists C.c.pi) {\n    J.Jiter = A.J; # erse rev\n    J.most->{$_} = A.J.most->{$_} for keys %{A.J.most||{}};\n}\n# til the I train shows up:\nJ.V = J.most.J.inV || 1 if A.J.V == 2 || J.most.J.inV;\nJ.A.Indo = 2;\nsayyl \"J33   Made J.name\" unless J.Jiter;\nC.c.J = C.sc.J = $J;\nA.jr&J,$J;\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: oJ
        dige: 9449535e2f54
        gk: J
        nk: c
        of: oJ
        v: cJ
      t: J_343
      "y": 
        cv: '0.343'
  "0.344": 
    J_344: 
      c: 
        from: Jing/Joot
        s: "A.I.J_344 = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $c = C.c;\nmy $J = C.c.J;\ndie \"In self: J.name\" if $J eq A.J;\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: oJ
        dige: 896d8c8c5a1f
        gk: J
        nk: c
        of: oJ
        v: cJ
      t: J_344
      "y": 
        cv: '0.344'
  "0.434": 
    J_434: 
      c: 
        from: Jing/Jamping
        s: "A.I.J_434 = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $c = C.c;\nmy $J = C.c.J;\n$J = C.c.J = C.sc.J;\nJ.name || die \"WNO \".wdump 4, $C;\n# TODO: soft acuminy over \\d esp. until .bb or something\nA.mo.Js->{J.name} = $J;\n# A falls\n# A.mo exits\n# J.A persists\nJ.A.first ||= hitime();\nif (C.sc.W && G.oin ne $J) {\n    my $lev = G.oin.A.tid;\n    if (J.A.tidi && (J.A.tidi + 3) > $lev) {\n        A.ztime ||= 4;\n    }\n    else {\n        J.A.tidi = $lev;\n    }\n}\nsayre \"same A.J.name inside J.name\" if A.J eq $J;\nif (exists C.sc.pi) {\n    sayre \"JiternotAJ J.Jiter.name ne A.J.name\" if J.Jiter ne A.J;\n    die 'pimostJ'if J.most.J eq $J;\n}\nelse {\n    die 'esel'.wdump [J.C, J.most.J.C] if J.most.J ne $J;\n}\nA.ztime ||= 6;\nA.time && sayre \"Had atime\";\nA.time = sub { # A.t& cover, serve single digit ad hocs, like 2\n    my ($JJ,$q) = @_; die\"JTIMEJ\" if $JJ ne $J;\n    A.ztime >= $q\n};\nif (C.sc.pi) {\n    J.A.d = J.Jiter.A.d + 1;\n    J.ind = join '  ', ('') x J.A.d;\n    J.name = \"J.A.d. C.c.pi*C.t\";\n    J.d = $C;\n    A.ztime = 6 if A.ztime < 6;\n}\nJ.C = $C;\nA.talk .= \" J: J.name\";\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: oJ
        dige: bdf367f1f78b
        gk: J
        nk: c
        of: oJ
        v: cJ
      t: J_434
      "y": 
        cv: '0.434'
  "0.61": 
    J_61: 
      c: 
        from: Jing/Jumps
        s: "A.I.J_61 = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $c = C.c;\nmy $J = C.c.J;\nT.alk = \"A.talk  TT  A.ztime\";\nAtime(6) || return do {\n    say \"SKive! T.alk\" if A.V&skive;\n    T.nose = 1;\n};\nsayyl \"J6 ! T.alk\" unless !A.V&sixes || C.sc.pi || T.alk =~ /^all/;\nA.Subtle.J = 1;\nA.t&J,9,1;\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: oJ
        dige: 50ec84fc7ec6
        gk: J
        nk: c
        of: oJ
        v: cJ
      t: J_61
      "y": 
        cv: '0.61'
  "0.71": 
    J_71: 
      c: 
        from: Jing/Jumps
        s: "A.I.J_71 = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $c = C.c;\nmy $J = C.c.J;\nT.nose && return A.V&nose && sayre \"nose T.alk\";\nif (!J.A.II.Sev) {\n    my $A = {J=>$J,G=>$G};\n    Rw collaspII $A;\n}\nJ.most.eo = 'Sev' if J.A.II.Sev;\nsay \"oJ77 77 T.alk     -> J.most.eo\"\n    unless J.most.eo ne 'Sev' || !A.V&sevens\n        || J.yt.quiet || C.sc.pi || T.alk =~ /^all/;\nRw J.most.eo $J $A;\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: oJ
        dige: 3c5d8320c1ca
        gk: J
        nk: c
        of: oJ
        v: cJ
      t: J_71
      "y": 
        cv: '0.71'
