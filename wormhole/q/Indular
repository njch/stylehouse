--- 
I: 
  "0.1": 
    AZu: 
      c: 
        from: Servo
        s: "A.I.AZu = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\ndie 'amany' if keys %$s > 1;\nmy ($cv,$ac) = %$s;\nmy ($AA,$CC) = ref $ac eq 'ARRAY' ? @$ac : ($ac,ac.C);\n$AA || $CC || die \"AZ NO A or C: \".wdump 3, $s;\n$AA && $CC && die \"AZ toomuch A or C: \".wdump 3, $s;\nmy $cov;\nif ($AA) {\n    $A = $AA;\n    my $Te = A.T;\n    $cov = delete Te.incv;\n    A.cv = $cov || $cv;\n    unshift @{A.mo.N}, $A;\n    return T.whack = T.isnot = 1;\n}\nelse {\n    A.C = $CC;\n}\nA.cv = $cov || $cv;\nT.whack = 1;\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: b9b209c46e93
        l: Motion/oseverato
        of: I
      t: AZu
      "y": 
        cv: '0.1'
    Cngk: 
      c: 
        from: C
        s: "A.I.Cngk = sub {\nmy ($A,$C,$G,$T,@M)=@_;\nmy ($s,$D,@Me) = @M;\nmy $I = A.I;\nref $A || die \"nmonref A!\";\nA.bangdesk.bang->{Cngek} = sub {\n    sayre \"was Cngk; \".ki($s).\"\\nWith: \".ki($D)\n} if 0;\nreturn 1 if D.c.any;\ndie \"nonNKnk\".ki$D if !D.c.nk;\nreturn 0 if !exists $s->{D.c.nk};\nreturn [$s->{D.c.nk}] if !exists D.c.gk;\nreturn 0 if !exists $s->{D.c.nk}->{D.c.gk};\nreturn [$s->{D.c.nk}->{D.c.gk}];\n};"
      sc: 
        acgt: s D
        args: A,C,G,T,s,D
        code: I
        dige: 1e50021ad5b4
        of: I
      t: Cngk
      "y": 
        cv: '0.1'
    ECu: 
      c: 
        from: Servo
        s: "A.I.ECu = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nref $s eq 'ARRAY' || die;\nmy ($N,$c) = @$s;\n$N = [{MZ=>A.fl}, {MZ=>{'3 doex'=>$c}}, @$N];\n# and In could feel our light cone\nRw In $J:A.J $M:T.oM $N;\n# ^but instead push to A.N and A.No, the sister strand Whare Y Whare\n# and A walks through t&Y, d&Whare(6)\n# turns via n&ACGT\n# the time beams mapped... a W concat couldol\nT.not = 1;\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: b669ca6a4ef1
        l: Motion
        of: I
      t: ECu
      "y": 
        cv: '0.1'
    EZu: 
      c: 
        from: Servo
        s: "A.I.EZu = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $Z = I.d&iZu,$s;\nwarn \"About EZ\";\nfor my $k (sort keys %$Z) {\n    my $N = $Z->{$k};\n    $N = [ map { [$_] } split \"\\n\",$N ] if !ref $N;\n    Rw In $M:T.oM $N;\n}\nT.not = 1;\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 9b484f39fd3c
        l: Motion
        of: I
      t: EZu
      "y": 
        cv: '0.1'
    MZu: 
      c: 
        from: Servo
        s: "A.I.MZu = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $uM = sub {\n    my ($k,$v) = @_;\n    if (defined $v && $v eq '0') {\n        delete A.fl->{$k}\n    }\n    else {\n        A.fl->{$k} = $v || 1;\n    }\n};\nref $s eq 'HASH' ?\n    map{ $uM->($_,$s->{$_}) } keys %$s\n:   map{\n        /^(.+?)(?::(.+))?$/ || die;\n        $uM->($1,$2);\n    } split /\\s+/, $s;\nT.not = 1;\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 65edd566f8ec
        of: I
      t: MZu
      "y": 
        cv: '0.1'
    NM: 
      c: 
        from: Motion
        s: "A.I.NM = sub {\nmy ($A,$C,$G,$T,@M)=@_;\nmy ($J,@Me) = @M;\nmy $I = A.I;\nmy $M = [];\nmy $N = [@Me];\nMn($N);\nreturn $M;\n};"
      sc: 
        acgt: J
        args: A,C,G,T,J
        code: I
        dige: 81935b609e73
        of: I
      t: NM
      "y": 
        cv: '0.1'
    Tz: 
      c: 
        from: Motion
        s: "A.I.Tz = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy ($lo) = sort keys %$s;\nmy $v = $s->{$lo};\nT.incv = $v if $v ne '1';\n$v = [ I.d&sano , undef ];\npush @{A.mo.re->{$lo}||=[]}, $v;\n@{T.oM} = ();\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: f8c6258af864
        of: I
      t: Tz
      "y": 
        cv: '0.1'
    WZu: 
      c: 
        from: Servo
        s: "A.I.WZu = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $Z = I.d&iZu,$s;\nwarn \"About WZ\";\nfor my $k (sort keys %$Z) {\n    my $s = $Z->{$k};\n    die wdump $s if ref $s ne 'ARRAY';\n    unshift @{A.N}, @$s;\n}\nT.not = 1;\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 088bc643504e
        l: Motion
        of: I
      t: WZu
      "y": 
        cv: '0.1'
    ar: 
      c: 
        from: Motion
        s: "A.I.ar = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $ar;\nar.A=$A;ar.G=$G;ar.C=$C;ar.T=$T;ar.I=$I;\n$ar;\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 165ec51606e1
        of: I
      t: ar
      "y": 
        cv: '0.1'
    array: 
      c: 
        from: SlideEa
        s: "A.I.array = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nreturn I.d&fourreal,$s if @$s != 1 && !ref $s->[0] || $s->[0] =~ /^\\w+$/;\nreturn I.d&fourstring,$s->[0] if @$s == 1 && !ref $s->[0];\n# should stick In in first and M it? \n# kind of motion that wants to be unsure in the wild\nunshift @{A.N}, @$s;\nT.not = 1;\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 1fec58dc0439
        of: I
      t: array
      "y": 
        cv: '0.1'
    c: 
      c: 
        from: C
        s: "A.I.c = sub {\nmy ($A,$C,$G,$T,@M)=@_;\nmy ($D,@Me) = @M;\nmy $I = A.I;\nG&inDin,$C,@M;\n};"
      sc: 
        acgt: D
        args: A,C,G,T,D
        code: I
        dige: 0d3c3af9e72f
        of: I
      t: c
      "y": 
        cv: '0.1'
    e: 
      c: 
        from: C
        s: "A.I.e = sub {\nmy ($A,$C,$G,$T,@M)=@_;\nmy ($D,@Me) = @M;\nmy $I = A.I;\nmy $e = G&sces,C.c.e||return();\nG&inDin,$e,@M;\n};"
      sc: 
        acgt: D
        args: A,C,G,T,D
        code: I
        dige: 268d2c6fb68f
        of: I
      t: e
      "y": 
        cv: '0.1'
    flywheels: 
      c: 
        from: Motion
        s: "A.I.flywheels = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nfor my $k (sort keys %{A.fl||return}) {\n    my $v = A.fl->{$k};\n    $k = $2 if $k =~ /^(\\d+) (.+)$/;\n    Rw ym/$k $I $J:A.J $A $C $v $G $T;\n}\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 91d687815272
        of: I
      t: flywheels
      "y": 
        cv: '0.1'
    fourreal: 
      c: 
        from: SlideEa
        s: "A.I.fourreal = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\n(C.t, C.y) = @$s;\nC.c  = $s->[2] if exists $s->[2];\nC.sc = $s->[3] if exists $s->[3];\ndie'@>4'.wdump $s if @$s > 4;\nif (ref C.t eq 'SCALAR') {    \n    die \"scalaref Ct had Cc\".wdump 4,$C if C.c;\n    (C.t,C.y) = ('',$s);\n}\ndie\"C.t from \".wdump $s if ref C.t; # dives\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: ce20681b4eb3
        of: I
      t: fourreal
      "y": 
        cv: '0.1'
    fourstring: 
      c: 
        from: SlideEa
        s: "A.I.fourstring = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nI.d&MZu,$1 if $s =~ /^\\s*#?\\s*MZ (.+)$/;\n$s =~ s/^\\s+//;\nif ($s =~ /^\\s*(#.*)$/) {\n   T.not = 1;\n   T.com = $1;\n}\nelsif ($s eq '') {\n   T.not = T.space = 1;\n}\nelse {\n   my $ci = $s;\n   for my $nk (qw't y c sc') {\n       if ($ci =~ s/^(\\S+) *//) { # some t are types of space\n           my $v = $1;\n           $v = I.d&peel,$v if $nk ne 't' && $v =~ I.peels;\n           # << consumes more lines into $nk, then ...\n           $v = '' if $v =~ /^(''|\"\")$/;\n           $C->{$nk} = $v;\n       }\n   }\n}\nsaybl \"4string: $s            \".ki $C if A.V&C;\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 9a408a2c79fe
        of: I
      t: fourstring
      "y": 
        cv: '0.1'
    givy: 
      c: 
        from: SlideEa
        s: "A.I.givy = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $y = C.y;\nif (ref $s eq 'SCALAR') {\n    my $z = $s;\n    $s = $$s;\n    $s = '%'.$s if $s !~ /^%/;\n    $s =~ /I.peels/ || die \"scalarnopeel $s\";\n    G&xo,C.c,$_ for G&peel,$s;\n\n}\nelsif (ref $s eq 'ARRAY') {\n    for my $yy (@$s) {\n        C.y = {};\n        G&givy,$yy;\n        ref $y || die \"notash \".ki $y;\n        G&xot,$y,C.y;\n        C.y = $y;\n    }\n}\nelsif (ref $s) {\n    ref $s eq 'HASH' || ref $s eq 'REF'\n        || die \"no $s  ref=\".ref $s;\n    if (G&taJe,$s ) {\n        my $yy = C.y;\n        C.y = {} if ref C.y ne 'HASH';\n        G&givy,$yy;\n    }\n    elsif ($y ne $s) {\n        G&xot,$y,$s;\n    }\n}\nelsif ($s eq '') {\n    my $x = I.blanky ? G&blanky : {};\n    G&xot,C.y,$x if keys %$x;\n}\nelsif ($s =~ /^($G::NUM)$/) {\n    y.cv = $1;\n}\nelsif ($s =~ /^($G::NUM)-($G::NUM)$/) {\n    y.in = $1;\n    y.out = $2;\n}\nelsif ($s =~ /^($G::NUM)-($G::NUM)x($G::NUM)$/) {\n    y.in = $1;\n    y.out = $2;\n    y.thi = $3;\n}\nelsif ($s =~ /^-(\\w+)$/) {\n    C.c.pi = $1;\n    C.c.s = C.t if !exists C.c.s || A.btw.cwass;\n}\nelsif ($s =~ /^([a-zA-Z]+)(?::(.+))?$/) {\n    C.c->{$1} = $2 || C.t;\n}\nelse {\n    die \"C y wtf: $s\";\n}\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: a52d0fae8046
        of: I
      t: givy
      "y": 
        cv: '0.1'
    hash: 
      c: 
        from: SlideEa
        s: "A.I.hash = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nreturn %$C = %$s if exists s.t && s.y && s.c;\nI.d&servehash,$s;\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 9b00a34a9eb1
        of: I
      t: hash
      "y": 
        cv: '0.1'
    hup: 
      c: 
        from: C/T
        s: "A.I.hup = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $CC = {%$s};\n$CC->{$_} = {%{$CC->{$_}}} for\n    grep {ref $CC->{$_} eq 'HASH'} keys %$CC;\nreturn $CC;\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 21c3cdef1671
        of: I
      t: hup
      "y": 
        cv: '0.1'
    iZu: 
      c: 
        from: Servo
        s: "A.I.iZu = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $way = $s =~ s/^\\/// ? 'fund' : 'muck';\nmy $Z = Rw $way - $p:s $dclone=1;\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: c7775099e1d2
        of: I
      t: iZu
      "y": 
        cv: '0.1'
    inDin: 
      c: 
        from: C
        s: "A.I.inDin = sub {\nmy ($A,$C,$G,$T,@M)=@_;\nmy ($s,$D,@Me) = @M;\nmy $I = A.I;\nreturn () unless defined $s;\nreturn $s if $D eq 'C';\n#\nshift @M; # s\n$D = G&interpD,@M if !ref $D;\n#\nmy $v = G&Cngk,$s,$D;\nsaybl \"Got cnkgk: \".wdump 3,[\\@M,$D,$v,$s] if A.VV.D;\ndie \"Unhandles any: $v: \".ki $D if $v eq '1';\n#\nreturn () unless $v;\n# blankgk\nA.note->{D.c.nk}->{D.c.gk} = $v if A.note;\n#\n@$v == 1 || die \"Many somehowed \".wdump 3,[ki($D),$v];\n($v) = @$v;\nif (D.c.as eq 'list') {\n    ref $v eq 'ARRAY' || die 'Cngk for list not array '.ki $D;\n    return @$v;\n}\nreturn $v;\n};"
      sc: 
        acgt: s D
        args: A,C,G,T,s,D
        code: I
        dige: cba92cd974b7
        of: I
      t: inDin
      "y": 
        cv: '0.1'
    interpD: 
      c: 
        from: C
        s: "A.I.interpD = sub {\nmy ($A,$C,$G,$T,@M)=@_;\nmy ($nk,$gk,@Me) = @M;\nmy $I = A.I;\nmy $defnk = 'c';\nreturn $nk if ref $nk;\nmy $D = {};\nD.c.as = 'list' if $nk =~ s/^_//;\nwhile ($gk =~ s/^%(.+?):(.+?)(?=%|$)//g) {\n    D.c->{$1} = $2;\n    pop @M if @M == 2;\n}\nif (@M == 1 && $nk eq 't') {\n    D.c.nk = $nk;\n}\nelsif (@M == 1) { # or from t,,,\n    D.c.nk ||= $defnk;\n    D.c.gk ||= $nk;\n}\nelsif (@M == 2) {\n    D.c.nk = $nk;\n    D.c.gk = $gk;\n}\ndelete D.c.gk if D.c.gk eq 'NOGK';\n$D\n};"
      sc: 
        acgt: nk gk
        args: A,C,G,T,nk,gk
        code: I
        dige: f1b27a193502
        of: I
      t: interpD
      "y": 
        cv: '0.1'
    ip: 
      c: 
        from: C/T
        s: "A.I.ip = sub {\nmy ($A,$C,$G,$T,@M)=@_;\nmy ($s,$c,@Me) = @M;\nmy $I = A.I;\nmy $z;\n$s = G&peel,$$s if ref $s eq 'SCALAR';\nmy $n;\nif (ref $s eq 'REF') {\n    # do s.do\n    $s = $$s;\n    $n = $s;\n    s.ip || die \"sip no ref\";\n    $s = {map{$_=> \\s.ip.>$_ }keys %{s.ip}};\n}\n# n.all keeps going after a pass--\nmy $pass = 1;\nEE: for my $k (keys %$s) {\n    $pass == 1 || n.all || return 0;\n    my $y = $s.>$k;\n    my $x = $c.>$k;\n    if (ref $y eq 'REF') {\n        $y = $$y;\n        if (exists y.nk) {\n            $x = $c;\n            for my $k (grep{defined}y.nk,y.gk,y.tk) {\n                $pass--, next EE unless\n                    ref $x eq 'HASH' && exists $x.>$k;\n                $x = $x.>$k;\n            }\n        }\n        my $wa = $pass;\n        !defined $x || $pass-- if y.ndef;\n        defined $x || $pass-- if y.def;\n        y.is eq $x || $pass-- if exists y.is;\n        y.not ne $x || $pass-- if exists y.not;\n        y.in->{$x} || $pass-- if y.in;\n        !y.nin->{$x} || $pass-- if y.nin;\n        $x > y.gt || $pass-- if exists y.gt;\n        $x < y.lt || $pass-- if exists y.lt;\n        $x >= y.gteq || $pass-- if exists y.gteq;\n        $x <= y.lteq || $pass-- if exists y.lteq;\n        $x =~ y.re || $pass-- if exists y.re;\n        $pass = $pass < $wa ? $wa : $pass-1\n            if y.neg;\n    }\n    elsif ($y ne $c.>$k) {\n        $pass--;\n    }\n}\n$pass == 1\n};"
      sc: 
        acgt: s c
        args: A,C,G,T,s,c
        code: I
        dige: 15ce682807e6
        of: I
      t: ip
      "y": 
        cv: '0.1'
    isC: 
      c: 
        from: SlideEa
        s: "A.I.isC = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nreturn 0 unless ref $s eq 'HASH';\nexists s.t && defined C.t && !ref s.t\n&& ref s.y && ref s.c && 9 > keys %$s;\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: b7d447464bc7
        of: I
      t: isC
      "y": 
        cv: '0.1'
    isJ: 
      c: 
        from: SlideEa
        s: "A.I.isJ = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nref $s eq 'HASH' && ref s.bb eq 'HASH';\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: b6d0a657a6f3
        of: I
      t: isJ
      "y": 
        cv: '0.1'
    more: 
      c: 
        from: Motion
        s: "A.I.more = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy ($lo) = sort keys %$s;\nif ($lo) {\n    my $ay = delete $s->{$lo};\n    my @N = map { {AZ=>{$lo=>$_}} } @$ay;\n    push @{A.mo.N}, @N;\n    saybl \"Looping \".@N.\" to $lo\" if A.J.V > 1;\n}\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 773fb5fe6514
        of: I
      t: more
      "y": 
        cv: '0.1'
    moy: 
      c: 
        from: Motion
        s: "A.I.moy = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\n# groups, spread the moise over A\nmy $i = A.mo.y->{$s}||die\"no$s\";\nmy $is = $i->{C.y.p}; # things in our C's pool\n{is=>$is,N=>[map{$is->{$_}}sort keys %$is]};\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 9894eb3b48fd
        of: I
      t: moy
      "y": 
        cv: '0.1'
    oseverato: 
      c: 
        from: Motion
        s: "A.I.oseverato = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nA.T.d = T.d if T.d;\nif (my $z = delete T.Z) {\n    I.d&Tz,$z;\n}\n!@{A.mo.N} && A.mo.re &&\n    I.d&more,A.mo.re;\nif (my $y = delete T.y) {\n    I.d&mar,T.y;\n}\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: ad99942695a2
        of: I
      t: oseverato
      "y": 
        cv: '0.1'
    peel: 
      c: 
        from: C
        s: "A.I.peel = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\n$s =~ s/^%//;\nmy $c = {};\nfor (split ',', $s) {\n    my ($k, $v) = split ':', $_, 2;\n    $v = 1 if !defined $v;\n    $c->{$k} = $v;\n}\n$c\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 20667cf19a01
        of: I
      t: peel
      "y": 
        cv: '0.1'
    peels: 
      c: 
        from: C
        s: "A.I.peels = (sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nqr/^[\\{\\%]\\w+/;\n})->($A,$C,$G,$T);"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 7d6059b05247
        of: I
        subpeel: 1
      t: peels
      "y": 
        cv: '0.1'
    renc: 
      c: 
        from: SlideEa
        s: "A.I.renc = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\n(my $s,C.c) = (C.c,{});\nif (ref $s eq 'REF' || ref $s eq 'SCALAR') {\n    C.c.s = $$s;\n    return;\n}\nif (ref $s eq '' && $s =~ /I.peels/) {\n    # peels for now\n    G&xo,C.c,$_ for G&peel,$s;\n}\nelse {\n    A.btw.cwass = 1 if \"\" eq $s;\n    A.btw.cwasnd = 1 if !defined $s;\n    C.c.s = $s;\n}\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 8b5bae0ceb42
        of: I
      t: renc
      "y": 
        cv: '0.1'
    rensc: 
      c: 
        from: SlideEa
        s: "A.I.rensc = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nC.sc = '%'.${C.sc} if ref C.sc eq 'SCALAR';\nC.sc = C.sc eq '' ? {}\n    : C.sc =~ I.peels\n    ? G&peel,C.sc\n    : die \"C sc nostr: C.sc   of I.peels  \".ki $C\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: b44dd6753a54
        of: I
      t: rensc
      "y": 
        cv: '0.1'
    sano: 
      c: 
        from: Motion
        s: "A.I.sano = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nA.C = $C;\nA.T = $T;\nreturn$A\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 768000c91a15
        of: I
      t: sano
      "y": 
        cv: '0.1'
    sca: 
      c: 
        from: C
        s: "A.I.sca = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\n$s /= 10 while $s > 1 || $s < -1;\nreturn $s\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: cdd56c3308e4
        of: I
      t: sca
      "y": 
        cv: '0.1'
    sces: 
      c: 
        from: C
        s: "A.I.sces = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $i = 0;\nwhile (s.c.e) {\n    $s = s.c.e;\n    $i++ > 9 && die \"HUGE $i recursing CceCceCceCce... by \".ki $s;\n}\nreturn $s;\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: d0c8253ecc14
        of: I
      t: sces
      "y": 
        cv: '0.1'
    scyvle: 
      c: 
        from: C
        s: "A.I.scyvle = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmap { my$i;\n    C.y->{$_} /= 10 while\n    (C.y->{$_} <= -1 || C.y->{$_} >= 1)\n    &&\n    (++$i < 10 || die \"Many i chewing on $_: \".ki C.y)\n}\ngrep { C.y->{$_} }\nqw'in out cv'\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 731015a47e93
        of: I
      t: scyvle
      "y": 
        cv: '0.1'
    servehash: 
      c: 
        from: Servo
        s: "A.I.servehash = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\ns.AZ ? I.d&AZu,s.AZ\n    : s.MZ ? I.d&MZu,s.MZ\n    : s.EZ ? I.d&EZu,s.EZ\n    : s.WZ ? I.d&WZu,s.WZ\n    : s.EC ? I.d&ECu,s.EC\n    : s.Elvis ? I.d&Elvisu,s.Elvis\n    : die 'hash: '.wdump($s);\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 8c17605be4d7
        of: I
      t: servehash
      "y": 
        cv: '0.1'
    string: 
      c: 
        from: SlideEa
        s: "A.I.string = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\ndie \"string: $s \".wdump 5, [A.N];\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: f30652ec746f
        of: I
      t: string
      "y": 
        cv: '0.1'
    taJe: 
      c: 
        from: SlideEa
        s: "A.I.taJe = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $r = $s = $$s if ref $s eq 'REF';\n$r || G&isC,$s || G&isJ,$s || return;\nif ($r || s.bb) {\n    C.c = {e=>C.c} if G&isC,C.c;\n    C.c.s = $s;\n}\nelse {\n    C.c = {s=>C.c} if G&isJ,C.c;\n    C.c.e = $s;\n}\nC.y = {};\nC.c.W = C.t;\nreturn 1\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: a8688b265402
        of: I
      t: taJe
      "y": 
        cv: '0.1'
    us: 
      c: 
        from: C
        s: "A.I.us = sub {\nmy ($A,$C,$G,$T,@M)=@_;\nmy ($D,@Me) = @M;\nmy $I = A.I;\nmy $e = G&sces,C.c.e||return();\nmy $us = e.c.us||return();\npush @M, 'NOGK' if @M == 1;\nG&inDin,$us,@M;\n};"
      sc: 
        acgt: D
        args: A,C,G,T,D
        code: I
        dige: 9c32a0a00a75
        of: I
      t: us
      "y": 
        cv: '0.1'
    xo: 
      c: 
        from: C/T
        s: "A.I.xo = sub {\nmy ($A,$C,$G,$T,@M)=@_;\nmy ($s,$c,@Me) = @M;\nmy $I = A.I;\nref $c eq 'HASH' && ref $s eq 'HASH'\n    || die \"Hash up\".wdump 3, [$s,$c];\nwhile (my($k,$v) = each %$c) {\n    $s->{$k} = $v;\n}\nreturn $s\n};"
      sc: 
        acgt: s c
        args: A,C,G,T,s,c
        code: I
        dige: 3fe77b2bee02
        of: I
      t: xo
      "y": 
        cv: '0.1'
    xot: 
      c: 
        from: C/T
        s: "A.I.xot = sub {\nmy ($A,$C,$G,$T,@M)=@_;\nmy ($s,$c,@Me) = @M;\nmy $I = A.I;\nref $c eq 'HASH' && ref $s eq 'HASH'\n    || die \"Hash up\".wdump 3, [$s,$c];\nwhile (my($k,$v) = each %$c) {\n    $s->{$k} = ref $v eq 'HASH' ?\n                {%{$s->{$k}||{}}, %$v}\n    : $v;\n}\nreturn $s\n};"
      sc: 
        acgt: s c
        args: A,C,G,T,s,c
        code: I
        dige: f563a13757f0
        of: I
      t: xot
      "y": 
        cv: '0.1'
    xoy: 
      c: 
        from: C/T
        s: "A.I.xoy = sub {\nmy ($A,$C,$G,$T,@M)=@_;\nmy ($s,$c,@Me) = @M;\nmy $I = A.I;\n$c = G&xot,{},$c;\nG&xot,$c,$s;\nreturn $s;\n};"
      sc: 
        acgt: s c
        args: A,C,G,T,s,c
        code: I
        dige: c7efffb7d7d5
        of: I
      t: xoy
      "y": 
        cv: '0.1'
    z: 
      c: 
        from: Motion
        s: "A.I.z = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nI.d&oseverato;\npush @{A.M}, @{T.oM};\ndelete T.not;\n1\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: aac5b6b6d05e
        of: I
      t: z
      "y": 
        cv: '0.1'
  "0.11": 
    after: 
      c: 
        from: Bangdesk
        s: "A.I.after = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nA.bangdesk = {};\nA.bangdesk.main = sub {\n    $_->() for values %{A.bangdesk.aft};\n    $@ || return;\n    A.bang && return;\n    A.bang = 21;\n    $_->() for values %{A.bangdesk.bang};\n    # want to sus $@ and hang vectors of what, should be autoish\n    my $m = \"J: A.mo.ont.talk        A.mo.ont.cv\";\n    $m .= \"\\nC: \".k2 A.mo.ont.C;\n    $m .= \"\\ns: \".wdump 3, A.mo.ont.s unless length $m > 20;\n    sayre \" * bangdesk: \\n$m\";\n    return $m;\n};\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: I
        dige: 144c7ec694d2
        of: I
      t: after
      "y": 
        cv: '0.11'
  "0.12": 
    Ci: 
      c: 
        from: SlideEa
        s: "A.I.Ci = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $r = ref $s;\n!$r ? G&string,$s :\n'ARRAY'eq$r ? G&array,$s :\n'HASH'eq$r ? G&hash,$s :\n'SCALAR'eq$r ? do {\n    C.t ||= '';\n    C.y = $s;\n} :\ndie \"mmtype:$r for $s\"\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: I
        dige: 2f79ac554527
        of: I
      t: Ci
      "y": 
        cv: '0.12'
  "0.18": 
    reasonlock: 
      c: 
        from: SlideEa
        s: "A.I.reasonlock = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\ndie\"reft\" if ref C.t;\nif (A.J && (A.J.name eq 'qq' || A.J.most.J eq A.J)) {\n    C.c.W = C.t unless C.c || C.sc || C.y;\n}\nI.d&renc if ref C.c ne 'HASH';\n\nmy $yy = C.y;\nC.y = {} if ref C.y ne 'HASH';\nI.d&givy,$yy;\n\nI.d&rensc if ref C.sc ne 'HASH';\n\nI.d&isC,$C && ref C.sc\n    || die \"reaso fail\".wdump [A.s,$C];\nI.d&scyvle;\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: I
        dige: 48c2d4c4aa50
        of: I
      t: reasonlock
      "y": 
        cv: '0.18'
  "0.71": 
    CoM: 
      c: 
        from: Motion
        s: "A.I.CoM = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\npush @{T.oM}, $C unless T.Z;\n};"
      sc: 
        acgt: s
        act: 1
        args: A,C,G,T,s
        code: I
        dige: c801cbee70c2
        of: I
      t: CoM
      "y": 
        cv: '0.71'
  "0.9": 
    erg: 
      c: 
        from: Bangdesk
        s: "A.I.erg = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\n# must pre compile, see D severators\nmy $m = \"J: A.talk\";\n$m .= \"\\nC: \".ki $C;\n$m .= \"\\ns: \".wdump 3, A.s unless length $m > 20;\n$@ = \"$m\\n$@\";\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: dda79d817d59
        of: I
      t: erg
      "y": 
        cv: '0.9'
Ii: Bangdesk vers:HASH + C vers:HASH + Motion vers:HASH + Servo vers:HASH + SlideEa vers:HASH
