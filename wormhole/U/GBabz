--- 
I: 
  "0.1": 
    bitsof_babble: 
      c: 
        s: "A.I.bitsof_babble = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $p;\np.alive = qr/\\$[\\w]*[\\w\\->\\{\\}]+/;\np.dotha = qr/[A-Za-z_]\\w{0,3}(?:\\.[\\w-]*\\w+)+/;\np.oing = qr/\\w*p.alive|p.dotha|[-\\w]{8,}/;\np.oint = qr/[\\w\\$\\/\\->\\{\\}\\*]*[\\w\\$\\/\\->\\.\\}\\*]+/;\np.mwall = qr/(?:= |if |unless |^\\s*)/;\np.sur = qr/ if| unless| for| when|,?\\s*$|;\\s*/;\n$p\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 153c29755879
        of: I
      t: bitsof_babble
      "y": 
        cv: '0.1'
    parse_babbl: 
      c: 
        s: "A.I.parse_babbl = sub {\nmy ($A,$C,$G,$T,$s,@Me) = @_;\nmy $I = A.I;\nmy $p = G.bitsof_babble ||= I.d&bitsof_babble;\n# gone:\nmy $Jsrc = qr/(J\\d*(?:\\.\\w+)?) (\\w+)/;\nmy $Jlump = qr/(\\S+) (\\S+)\\s+(\\S.+)/;\n$s =~ s/p.mwall$Jsrc $Jlump$/$1.$2->(\"$3\\\\t$4\" => $5);/smg;\n\n\nmy @s;\nmy $indbe;\nmy $inend;\nmy $indun;\nmy $angt = '<'.'<';\nfor my $l (split \"\\n\", $s) {\n    my $s = $l;\n    # things:\n    $s =~ s/^(\\w+)(?: (-?\\w+))?:(?: (%.+))?$/n $1 =>'$2',$angt'',\"$3\"/smg;\n    if ($indbe) {\n        if ($indun eq 'NEXT') {\n            $s =~ /^(\\s+)/ || die \"Must Indunext:\\n$s[-1]\\n$s\";\n            $indun = $1;\n        }\n        if ($s =~ $indbe) {\n            $s =~ s/^(\\s*)\\.(\\s*)$/$1$2/;\n            $s =~ s/^$indun//\n                if defined $indun;\n            push @s, $s;\n            next;\n        }\n        else {\n            undef $indbe;\n            undef $indun;\n            if ($s !~ /^\\s*$/) {\n                if ($inend) {\n                    pop @s  if $s[-1] eq '';\n                    push @s, $inend;\n                }\n            }\n            else {\n                $s = $inend if $inend;\n            }\n            undef $inend;\n        }\n    }\n    my $ze = qr/$angt['\"](\\w*)['\"]/;\n    if ($s =~ /^(\\s*)(?!#)\\S.*$ze/) {\n        if ($2) {\n            # for <#<'EOD' til ^EOD, etc\n            $indbe = qr/^(?!\\Q$1\\E)/;\n        }\n        else {\n            $indbe = qr/^($1\\s+|\\s*$)/;\n            $indun = 'NEXT';\n            $s =~ s/$ze/$angt.($1?\"'$1'\":\"'STEVE'\")/e;\n            $inend = 'STEVE' if !$1;\n        }\n    }\n    \n    #c babable # expect closing brackets and insert J\n\n    # eg Atime(2) = A.time->($J, 2)\n    $s =~ s/(p.mwall)(\\w*A)(\\w+)\\(/$1$2\\.$3->(\\$J, /smg;\n    $s =~ s/(p.mwall)(\\w*G)(\\w+)\\(/${1}G\\.$3->(\\$A,\\$C,\\$G,\\$T, /smg;\n    $s =~ s/(p.mwall)(\\w*J)(\\w+)\\(/$1$2\\.$3->(\\$A,\\$C,\\$G,\\$T, /smg;\n    $s =~ s/(p.mwall)(\\w*[MN])(\\w+)\\(/\n        ${1}J\\.m->(\\$A,\\$C,\\$G,\\$T, \\$$2, /smg;\n\n    $s =~ s/(p.mwall)(u|n) (.+?)(;| for(\\s*$| .+?))?$/\n        \"${1}J\\.$2->(\\$A,\\$C,\\$G,\\$T,$3=>'')\".($4||';')/smeg;\n\n    $s =~ s/(p.mwall)(m) (.+?)(;| for .+?)?$/\n        \"${1}J\\.$2->(\\$A,\\$C,\\$G,\\$T,\\$M,$3=>'')\".($4||';')/smeg;\n\n    $s =~ s/I\\.d\\&(p.oint)/G\\&$1/g;\n\n    # C&hs = 388 # C.sc.>hs\n    $s =~ s/\\bC&(\\w+)\\b/C\\.sc\\.$1/g;\n    $s =~ s/\\bc&(\\w+)\\b/C\\.c\\.$1/g;\n    $s =~ s/\\b([e])&(\\w+)\\b/G\\&$1,\"$2\"/g;\n\n    # also e&so -> G&e,\"so\"...  generalised name pickup, spiral slumping\n    # us&hJ works sometimes somehow?\n    $s =~ s/ ((?!G)\\w+)\\&(p.oint)/ G\\&$1,\"$2\"/g;\n\n    # lma quack $not->('tag');? from I.d&pui,$s\n    $s =~ s/(p.oing|\\w+)\\&(p.oint)(,[^\\s;]+)?(;)?/\n        my ($on,$p,$e,$t) = ($1,$2,$3,$4);\n        my $in;\n        ($on,$in) = (\"G\\.h\",'$A,$C,$G,$T,')\n            if $on eq 'G';\n        my $s = $on.\"->($in\\\"$p\\\"$e)$t\";\n        $s = '$'.$s if $on !~ m{\\.};\n        $s\n    /smge;\n    # $sc.>$k -> $sc->{$k}\n    $s =~ s/(p.oing)((?:\\.>p.oing)+)/\n        join '->', $1, map {'{\"'.$_.'\"}'}\n        grep {$_} split m{\\.>}, $2;\n    /smge;\n\n    #c Rw\n    while ($s =~ /(Rw (p.oint)(?:(?!p.sur) (.+?))?)p.sur/gsm) {\n        my ($old, $op, $oa) = ($1, $2, $3);\n        my $g;\n        $g ||= '$G';\n        \n        my $ne = \"\"; # hidden reverse\n        $ne = $1 if $oa =~ s/(p.sur)$//;\n        \n        my @n;\n        my @m;\n        # want to mix {m m m %$ar m m} whereever + is\n        my $wanr = $oa =~ s/^\\+ ?//;\n        $wanr = 'stick' if $oa =~ s/^- ?//;\n        for (split /\\,| |\\, /, $oa) {\n            # sweet little pool... $J:geo etc\n            if (/^\\$((\\w+(:|=))?\\S+)$/) {\n                my ($na, $fa, $wa) = ($1, $2, $3);\n                if (!$fa) { # fake name, to ar\n                    $fa = $na;\n                }\n                else {\n                    $na =~ s/^\\Q$fa\\E//;\n                    $fa =~ s/(:|=)$//;\n                    if ($wa eq '=') {\n                        $na = '\"'.$na.'\"';\n                    }\n                }\n                $na = '$'.$na unless\n                    $wa eq '=' || $na =~ /^\\S+\\.\\S/;\n                push @n, \"$fa=>$na\" ; # also avail a listy position\n            }\n            else {\n                push @m, $_;\n            }\n        }\n        unshift @n, '$ar' if (!@n || $wanr) && $wanr ne \"stick\";\n        push @n, \"m=>[\".join(',',map{'\"'.$_.'\"'}@m).']'\n            if @m;\n        \n        my @e;\n        push @e, '\"'.$op.'\"';\n        push @e, join(\",\",@n);\n        my $en = join \",\", @e;\n        \n        my $wa = $g.'->{w}->($A,$C,$G,$T,'.$en.')'.$ne;\n        $s =~ s/\\Q$old\\E/$wa/          || die \"Ca't replace $1\\n\\n $s\";\n    }\n    \n    # sc.k -> $sc->{k};\n    $s =~ s/([A-Za-z_]\\w*)((?:\\.\\w+)+)/\"\\$$1\".join\"\",map {\"->{$_}\"} grep {length} split '\\.', $2;/segm;\n    # \n    $s =~ s/aft \\{/acum \\$F[0] => _after_do => sub {/sg;\n    #\n    \n    push @s, $s;\n}\npush @s, $inend if $indbe && $inend;\n$s = join \"\\n\", @s;\n\n$s;\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: bc9e7fef8017
        of: I
      t: parse_babbl
      "y": 
        cv: '0.1'
Ii: bitsof_babble 0.1 ARRAY 0:HASH + parse_babbl 0.1 ARRAY 0:HASH
