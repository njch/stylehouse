u allvy
# ^ always wants a new one somewhere
# 6* thingalloveries (tangled in self)
# so v=yo limits C ope to C.y.o existence 
# things can complain about not matching somewhere
# resuming back into itselves repeatedly
# kind of go yonder, certain travelishing

n yo =>''=>{s=><<''},{code=>'Mo 21',v=>'o'}
    $o = C.y.o = {M=>$o} if ref $o eq 'ARRAY';
    o.M ||= [$C];
    # 4d jelly slower-downer
    # so we should acquire many A.t&
    # this is an EC into our C's T.oM, as s.M now
    # stackable A with stitchable others interleaved in time
    # 6 FLIES
    o.M = [grep{defined}map{
        my $d;
        ref $_ || die "oM nonhashi ".wdump 2, o.M;
        d.t = _.t;
        d.y = {%{_.y}};
        d.c = {%{_.c}};
        delete d.y.cv if y.ecv;
        # allow any cv to wander from yarNgrid:
        #y.cvil = 1 if defined d.y.cv;
        d.sc = {%{_.sc||{}}};
        # TRansituio, soul spread
        if (o.ou) {
            # inside our, change slightly how we see
            # spread compound
            d.c.pi = o.ou;
            d.c.s = $_;
        }
        d.sc.oJ = o.oJ if o.oJ;
        # travel agent ^
        # traveli
        Rw C14 $I $A $C:d;
        #
        A.J.V && say "AH A.J.name  ::: d.t   ".ki d.sc;
        keys %$d ? $d : undef
    }@{o.M}];

# deliver news of yonderness
# having the .o is not so important
# just somehow the surroundings
# since they want to effect how we nest about them
n yon =>''=>{s=><<''},{code=>'Mo 22',v=>'o'}
    my $J = A.J;
    my $Jy = J.C.y; # pi's sea
    # surface tesion, lum
    if (my $lt = C.y.limn) {
        Jy.spc || die "no space ! J.name - C.t keep more numbers";
        my $rl = int(9 * $lt * Jy.spc);
        my $was = @{o.M};
        C.y.rowlisp = $rl;
        C.y.rowas = $was;
        C.y.Jyspc = Jy.spc;
        if ($was > $rl) {
            my @um = @{o.M};
            @um = @um[0..$rl-1];
            @{o.M} = @um;
            # space mod
            my $s = $was;
            n limo=>0.7,"$was>$rl",'%fs:7,hs:7487';
        }
    }
    C.y.bal = o.M || die"nomo";
    # unless y unlimited...until
    o.J = J.most.J if $Jy && Jy.o && Jy.spc > 0.1;
    delete o.J if y.clos;
    my $shut = $Jy && Jy.o && !o.J;
    C.y.over = (Jy.o && Jy.over && Jy.over || 0) + 0.06 if y.o.J;
    #sayre "Jyspace: spc:  J.d.y.spc  or aspace: Jy.aspace" if $Jy;
    # divvy space inside parent's share most J or in 3-4 of the pi
    my $sl = Jy.spc * 0.01;
    $sl = 0.02 if $sl < 0.02;
    C.y.in ||= $shut ? 0.3 : $Jy ? Jy.cv + $sl : 0.1;
    C.y.out ||= $shut ? 0.4 : $Jy ? Jy.ov - $sl : 0.9;
    C.y.lum = y.lumfa if y.lumfa;
