my $N = [];
if ('fo'eq'amer') {
    my $f = "w/J.name\.yml";
    $N = -f $f ? LoadFile($f) : do {
        J.at.isle && die "Run without isle";
        my $ay = 
        n Dwight
        my $N = Rw getJN $J:ay.nj $I:ay.I $pi=clife;
        # for cfile drop cache by mtime
        delete _.c.from for @$N;
        DumpFile($f,$N);
        $N
    };
}
my $fi = 'w/c66';
if ('a'eq'bandonment') {
    `cat /dev/null > $fi`;
    for (@$N) {
        my $style = " # %style:_.sc.style"
            if _.sc.style ne 'func';
        G&wraf,$fi,$_ for "_.t: |$style\n".ind('    ', _.c.s)."\n";
    }
}
$N = [];
    my @lino = `cat $fi`;
    my $ya = LoadFile($fi);
    for (@lino) {
        /^\s/ && next;
        /^(\S+): \|.*?(%style:(.*))?\s*$/ || next;
        $1 eq 'wayup' && next;
        my $c;
        c.t = $1;
        exists $ya.>$1 || die "NMoti o $1: $_";
        c.c.s = $ya.>$1;
        c.sc.style = $3||'func';
        c.y.cv = 0.1;
        push @$N, $c;
    }



return sayyl "isleless J.name, assume stop" if !J.at.isle;

Nn(enth=>''=><<'','%style:func');
    encode_entities(decode_utf8(shift));

for my $D (@$N) {
    my $s = D.sc.style;
    D.sc.head = 1         if D.t eq 'head';
    D.sc.bab = 'non'     if $s eq 'nonbabble';
    D.sc.subis = 1         if $s eq 'func' || $s eq '';
    D.sc.export = 1     if $s eq 'func';
    if (D.sc.head && !D.sc.export) {
        # G re-exports subs G imports
        my $e = [];
        push @$e, $1 while D.c.s =~
            /use \S+ (?:qw)?\W([\w\s]+)\W;/sgm;
        D.sc.export = join ' ', @$e;
    }
    D.c.s = "my \$G = shift;\n".D.c.s if $s eq '';
    D.c.s = "sub D.t {\n".D.c.s."\n}" if D.sc.subis;
    D.c.from = "G";
}
@$N = reverse I.d&sorp,'sc/head',@$N;
if (0) {
    my $E = {};
    for (@$N) {
        my $kip = join ' ', sort keys %{_.sc};
        E.tisc->{$kip}++;
        E.styles->{_.sc.head} .= "_.t ";
        E.subi->{_.sc.subis} .= "_.t ";
    }
    say wdump [$E];
}
@$N = grep{_.t ne 'wag'} @$N; # anything with H... 
u allcode
Mn($N);
