u alljs
# only one vid/playlist via iframe, make it end
# the bigger js for it does everything
# s = tap wanting time to piece stream of lines into C.sc.z tree
sand:
    s.tlas ||= a.nw();
    s.next ||= G&land,s;
    n = s.next;
    !n and ~die~nonext: s
    $i = n.sc.int;
    i == undefined and i = 1.3;
    a.timesmoving ||= 1;
    i = i / a.timesmoving;
    s.fut = s.tlas + i * 1;
    $gap = a.rnd(s.fut - s.tlas);
    $til = a.rnd(s.fut - a.nw());
    $ii = '+'+n.sc.ini;
    ~gaptiltz: gap, til, n.t, ii
    til > 0 and return

    s.last = s.next;
    s.tlas = a.nw();
    delete s.next;
    $z = [];
    $last;
    while (!s.next && !last) {
        $l = G&land,s;
        !l and last = 1;
        else
        l.c.ind == s.last.c.ind and s.next = l;
        else {
            z.push(l);
        }
    }
    $iz = {};
    z.unshift(s.last);
    while (z.length) {
        $l = z.shift();
        $d = l.c.ind;
        delete l.c.ind;
        if (d) {
            iz[d-1].sc.z ||= [];
            iz[d-1].sc.z.push(l);
        }
        iz[d] = l;
    }
    $l = s.last
    return s.last;

land:
    $l = G&pull,s.t;
    l = l.split("\t");
    $ind = l.shift();
    l = G&inC,l;
    l.c.ind = ind.length;
    return l;

# the I-need
mindu:
    $waits = [];
    $.each(s, &i,t{ a.zet('cur',t).l || waits.push(t) });
    !waits.length and return 1
    ~needu: C.t, waits.join(',')
    a.yl(231, &{ a.om(A,C,a,{}) });
    T.not = 1;
    return 0;

# return c.r recurring path back to a real C thing from thrown event C things
# like elvis, which comes from an event/lineaction C, grows/finds more event/whatever until its goal/real C thing emerges/happens
# metaphysical fishing rods, also
ge:
    $r = C.c[s];
    $l = [r];
    while (r && r.c && r.c[s]) {
        r = r.c[s];
        l.push(r);
    }
    C.c[s+'eel'] = l;
    return r

#c#c read,zet,get,pull
read: %args:f t e
    t ||= [];
    $o = [];
    $.each(f, &i,v{
        !v.length and return
        o.push(v);
    });
    $.each(o, &i,v{
        e && !e(i,v) and return
        t.push(v);
    });
    !t.length and t.push(o[o.length - 1]);
    return t

# circle back into A z #1
# cache sources #
zet: %args:K t
    a.WW ||= {};
    a.WW[K] ||= {};
    a.WW[K][t] ||= {};
    $s = a.WW[K][t];
    s.t ||= t;
    return s;

get:
    $Was = a.zet('Wa',s);
    $izoo = s.match('\\\.sc$');
    if (Was.last + 90 < a.nw()) {
        ~cached: s
        izoo and s&zoo = Was.l;
        return Was
    }
    $cb = &e{
        Was.l = [];
        a.read(e.split("\n"), Was.l);
        Was.t = s;
        Was.last = a.nw();
        izoo and s&zoo = Was.l;
        a.om(A,C,a,{});
    };
    ~get: s
    $.ajax('/W/'+s).done(cb);
    return 0;

# pull onliners to solution, wandering like
pull:
    $sol = a.zet('sol',s);
    sol.i ||= 0;
    sol.ii ||= 0;
    sol.i++;
    if (s == 'Viow' && sol.fs && sol.fs.length > 9
        && (sol.i % 3) < 2) {
        sol.ii > sol.fs.length and sol.ii = 0;
        return sol.fs[sol.ii++]
    }
    $cur = a.zet('cur',s);
    !cur and ~NO CUR: s
    !cur.l || !cur.l.length and ~NO CURl: s
    if (!cur.ol) {
        cur.ol = [];
        $.each(cur.l, &i,v{
            $Wa = a.WW.Wa[v];
            !Wa.l and ~die~toprelo: v
            cur.ol.push(Wa)
        });
    }
    cur.i ||= 0;
    $ol = cur.ol[cur.i];
    cur.i++;
    cur.i >= cur.ol.length and cur.i = 0

    ol.i ||= 0;
    $f = '';
    $uh = 0;
    while (!f.length && uh < 5) {    
        uh++;
        !ol.l and ~borknine: ol.t, ol.i
        f = ol.l[ol.i];
        //~seek: ol.t, cur.i, ol.i
        ol.i++;
        ol.i >= ol.l.length and ol.i = 0;
    }
    ~many pul: cur.t, ol.t, C.t, ol.i, f
    sol.fs ||= [];
    sol.fs.push(f);
    a.lim(sol.fs,49)
    return f
