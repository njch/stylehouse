my @h = e&_hC;
my $p = shift @h; # J
my ($ic,$edr,@etc) = reverse @h;
# ic is clicked, edr may not be edr...
p.c.J.mo.J eq p.c.J || die "Nomop: ".ki $p;
$edr = edr.c.J.C if edr.y.cv == 0.9;
shift @etc if $etc[0] == $edr; # ^ yeah
sayyl " HAs: ".ki $ic;
saybl "Se edr: ".ki $edr;

# broke since hiding all outgoing ids
my $jugs = sub {
    my $u = shift;
    my @f = grep{ _.sc.id eq u.sc.id}@{J.UG};
    $f[0];
};
my $co = $jugs->($edr);
sayyl "Self: ".ki $co;

my ($it) = grep { _.c.s eq ic.c.s } @{J.UG};

my $rm;
if (ic.t eq 'for') {
    $rm = $it;
}
elsif (ic.t eq 'instr') {
    it.sc.etc++;
    sayyl "Shifted  to it.sc.etc: ".ki$it;
}
else {
    die "no doing for a: ".ki$ic;
}
@{J.UG} = grep { _.c.s ne ic.c.s } @{J.UG};

saybl " _ _ _ ".ki $_ for $p,$edr,$ic;
sayre " _ _ _ ".ki $_ for @etc;
# Rw UnPreDuv $J; # opposite of help until c/sc inner properly VOD
