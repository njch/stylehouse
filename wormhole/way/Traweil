u allvse
#n DiskTravel
n Pugwei
n Plugs
# ye
# wants to be a left-right by now, regarding the isles and meta (stop, src)

n \'of:Mo'
# This.c.isle <-> More.c.isle:
W 3215:
    #G.glomp++ || G&Pugweidb;
    my $ab = A.J.C;
    c&isle ||= ab.c.isle || die "Noisle top? ".wdump 3,[$C, $ab];
    my $i = T.isle ||= {};
    ab.c.iZle.>C.t = $i;

    i.stop = 1 if !ab.c.isle && c&isle; # ab only involking

    i.src = c&isle if ab.c.isle && c&isle ne ab.c.isle;

    my $tr = G&shouldWe,$ab;

    $tr || delete(c&J), delete(C&J);
    $tr && sayre "C.t travels";
    $tr && i.src && die "Cannot diff src s.c.isle/s.t -> c&isle/C.t";
    C.c.time = 6 if $tr;

# ^ or c&ov = 0.8, so it can fall in, general W only mean
# ov=8 will resume, to give This'W correct link to More'W all the time

J 63: %code:J
    u Traweil

# c to be spires continuing,
# 
# st should know about making new D for us,
#we 8 everyWing already, know where to isle it
# This'W should look normal

# Every'W should just point to Other'W (+ version, maybe), requiring it 8 somewhere
# humming clients must attach other trees (they would kMow how)
# probably embedding in time, universals to bend it together

# exist for a point
# connects Wscaping/versioning
#for moving any o 7 out
#and hitching at the 2 onto another
## retreieves header
#how it is currently held (symp isle, makes aware as you like)
# the isle/This'W is indexed whole/Wc as opposed to Wsc
# for the thing applying at a distance, little updates way-cpu asap

# so W underneath sprawls & tidies, convopool
# isle hoisted off flattens all the time, possible meta:
#   the bunch of Wags hoisted into one, clients can dive isle for update
#   if nothing else gets built in the aggregation

# here in the osc meta wander region,
# having willed, having it one way or another

scW 74:
    if (my $J = C.sc.J) {
        # make N the recoverable inners if J,
        die wdump 3, $C if !ref $J;
        my ($Y,$V) = map{ J.El.>$_ } Pre=>'Duv';
        my @lv = map { V.rv.do.>$_ } sort keys %{V.rv.do};
        my ($root,@C) = map{_.C} V.rv, @lv;
        C.c.N = [map{
            my $D = G&hup,$_;
            # make normal
            delete D.c.>$_ for qw'J Y V';
            #sayre "D.t came out of osc with X: ".ki D.sc.X if D.sc.X;
            $D
        }@C];
    }
    else {
        # or just point, get W outer/root/rv/C, versioneddie
        # then that can acquire inners later or isle away
        #   (noticing if isle v < W v, maybe)
        #say "Re,member W: C.t ".ki C.c;
    }

# the art shader as a post osc index builder
# here making code more perl etc.
isle 747:
    my $sco = $isle =~ /^j/ ? {js=>'ym/jscoi'} : {code=>'ym/conoi'};
    my $i = T.isle;

    if (C.c.N) { # we are awake inside
    sayyl " C.t   ist ... ".ki {N=>C.c.N};

    my $src = [];
    for my $D (@{C.c.N}) {
        D.y = D.y.cv;
        for (grep{ D.sc.>$_ }keys %$sco) {
            my $coder = $sco.>$_;
            my $v = {};
            my $C = G&hup,$D;
            Rw $coder $C $v;
            D.sc.X && die "D.t al; $_";
            D.sc.X = $v;
        }
        #D.sc.X && D.sc.W && sayre "DscW already had X: ".ki $D;
        if (my $n = D.sc.W) {
            D.t eq $n || die "yuou";
            my $is = C.c.iZle.>$n || die "No $n on iZle: ".ki C.c;
            is.f && is.j || die "Noise ".ki $is;

            my $X = G&fli,$is;
            # land Toin but not W
            G&jound,$is;

            # wants to be post-spiral-together for our C 
            # knowing which src - now here=C.t is missing
            my $N = Rw sumX $X;
            _.c.from = join'/',grep{defined} D.t, _.c.from
                for @$N;

            D.sc.X = $X;
        }
        D.sc.noXup && sayre("No hoist D.t") && next;
        my $k = "D.t vers";
        push @$src, [$k,D.sc.X];
    }

    my $II = C.sc.X ||= {};
    Rw spII $A $II $src;
    }

    if (!C.c.N) {
        C.sc.X && die "!N ended up with X.".ki$C;
        C.sc.X = G&fli,$i;
    }
    my $X = C.sc.X;
    my $J = C.c.J;
    if (ref $J) {
        if (my $o = J.at.coil) {
            my $N = Rw sumX $X;
            for my $D (grep{ _.sc.>$o }@$N) {
                my $way = D.sc.>$o;
                saybl "C.t Coils D.t via $way";
                Rw $way $D $N;
            }
        }
    }
    else {
    }
    if (C.c.N) {
        G&fown,$i;
    }

    G&joined,$i;
