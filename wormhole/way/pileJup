# not =>$E properly, C is first C,c.e $E is from before $E
my @Js = I.d&inDin,$E,'_hJ';
@Js == 3 || return sayre("WEird look") &&
    Rw talkzyh;
my ($tW,$tJ,$tl) = @Js;
tW.mo.J eq $tW
    || die "not most 1: ".ki $tW;
tJ.C.sc.pi =~ /^J/
    || die "not /^J/oinish 2: ".ki($tJ).saybl(wdump 2, tJ.C);
tl.C.sc.pi =~ /^(bl|gee)$/
    || sayre "not bl/gee 3: ".ki $tl;
my $jes = tJ.mo.jes;
my $to = jes.tower;
my @up = tl.C.t;
while (1) {
    my $l = $up[0];
    die "if $l" if $l =~ / or /;
    my $o = $to->{$l} || die "No tower: $l ".wdump 2, $to;
    my $u = o.u || last;
    my @ops = sort keys %$u;
    if (@ops > 1) {
        my ($C,@oC) = map {jes.teeps->{$_}} $l,@ops;
        @oC = I.d&norp,'c/ind',@oC;
        @ops = map{_.t} shift @oC;
    }
    unshift @up, join(" or ", @ops);
}
my $path = join';',@up;
say "Find path to tl.C.t    whichis:   $path";
my $M = E.c.us.pick ||= [];
my $mean = tW.at.mean || 'Jiter';
Mn(founde=>-edr=>$path,{mean=>$mean=>onto=>tJ.C.c.s});
n Dug =>$E
T.pos = 0;
