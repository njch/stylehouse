# wants to reach qq... do ^qq/(.+) root reacumin
# u pi is I art
# sinky massive spiral space, name system of
# this is the thin osc superfactor
# could climb in by V.cvi and atom or blend geos
#n 'allovse'=>2,<<'','%code:In 4189'
u allvse
n '','','%of:Sev'
n J =>3212=><<'',{rg=>'J,Y,ylv,yvl'}
    # eat, rob, art
    return sayre "J.name is not mo: J.mo.J.name but is trying to have curve"
        if $J ne J.mo.J;
    my $host;
    if (C.c.root) {
        $host = C.sc.anch || 'TeCurve';
        return $host eq 'TeCurve' || sayre "topleve C.t is self"
            if $host eq C.t;
        return saygr "top C.t is blank anch, C.sc.geo" if $host eq '1';
        my ($cur) = map {_.nj}
        n $host =>$C
        my $wat = cur.El.Duv.ids->{C.sc.id};
        C.sc.geo = wat.sc.geo || die 
        "not foundcurve A.J.name fo J.name fo C.t ion $host: ".wdump [
            $cur,
            (IDD=>map{ki $_} values %{cur.El.Duv.ids}),
            cur.El.Duv.tv
        ];
    }
    else {
        $host = 'Claw';
        my $st;
        $st = Y.stackurv ||= do {
            st.J = Rw findupi $I $J curv;
            st.l = 'self curv';
            st.J ||= do {
                st.l = "$host curv";
                Rw findupi $I $J:host curv;
            };
            $st
        };
        my $cJ = st.J;
        $host = "st.l";
        Rw curre $I $J:cJ $Y:cJ.El.Pre $V:cJ.El.Duv $C;
    }
    saybl "$host: C.y.cv       C.t   found  C.sc.geo" if J.V;
    # might wanna crawl
