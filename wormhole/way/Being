u allacgts
n Augen
n Bubble

# An grows N ordered C in as an An for a.mo

# stamp C there ( or read sc style 
g:
    ($s,@Me) = ref $s eq 'SCALAR' ? ($$s,@Me) : (6,$s,@Me);
    # ^ \4 for sublatio, cs {set}/{suck}<-'J'
    G&zs,g=>$s,@Me

# n=introversio, each oif these loaf out around a different basic angle
zs:
    my ($n,$cs,$t,$cv) = (@Me);
    $t = C.t if !defined $t;
    $cv = C.y.cv if !defined $cv;
    # cs is stalk about how to move sc in/out
    # one string as one value if pos
    my $c = A.c.>$s ||= {};
    my $sc = A.sc.>$s ||= {};
    $cs = {$cs=>1} if !ref $cs && defined $cs;
    for ($t,$cv) {
        $sc = sc.K.>$_ ||= $n >= 5 ? return : {};
        $c = c.K.>$_ ||= {};
        # plucks t if 2
    }
    # c.L++ if change within
    if ($n == 6) {
        my $v = {map{ $_=>$sc.>$_ } keys %$cs};
        my ($o) = keys %$cs if 1 == keys %$cs;
        return $v->{$o} if $o;
        return $v;
    }
    else {
        die "Handool $n";
        G&st,$A,$s=>{s=>$C,mk=>[$t,$cv]};
        # 1 start is
        # 2 start is or uniq t or above ~ things
        # ^ complete t/y/c/sc
        # 3 sync sc
        # 4 sync sc and name(8)s all z
        # 5 lum/bal
        # 6 retrieval from branches
        # 7 compression (into time) 
        #   - writes up unless up is over whole/Cmudge join minded
        # start over - bunch zs layers
        # carry ray around, seal bits
    }
    # immediate upspiral m-om unless blocked by later sc/vote

stmk: %com:#c make marks (connects synapse)
    my $R = C.c.R;
    # when some splits from A.mo=A  (lowovsorts An)
    # or as al possibles also al lowcvs A.ovs 
    # R lives in mo.c.$t, c differ all A
    # can use R to find ways to ways, those kinds would be setup by the m
    # m has most space input, a pool of magnetics to the outside, each one
    # also the same thing within, just as A.I should return the sub nearest us
    # we have glues to exchange on a glue exchange channel
    die wdump 3, $C;
    if (my $n = C.c.mk) {
        C.c.nos = 1;
        C.c.notw = 1;
        n.y eq $n || die "An so A";

        my $id = C.c.Ant ? n.t : "$n";

        my $ov = n.ov || 0;

        my $tw = C.sc.tw = R.sc.tw || {};
        my $new = !exists $tw->{$id};
        $tw->{$id} = $n;

        my $de = C.sc.N = R.sc.N || [];
        push @$de, $n if $new;

        my $tt = C.sc.tt = R.sc.tt || {};
        my $old = $tt->{$id};
        $tt->{$id} = $ov;

        my $sl = C.sc.sl = R.sc.sl || [];
        my $tv = C.sc.tv = R.sc.tv || {};
        my $done;
        if (defined $old && $old ne $ov) {
            my $o = $tv->{$old};
            delete $o->{$id};
            if (!keys %$o) {
                my $done;
                for (0..6) {
                    $old eq $sl->[$_] || next;
                    splice @$sl, $_, 1;
                    $done = $_;
                    last;
                }
                if (!defined $done) {
                    @$sl = sort keys %$tv;
                    saybl "n.t n.cv n.ov @@ C.t sl rm Resorted to rm $old, s.t   @$sl";
                }
            }
        }
        if (!defined $old || $old ne $ov) {
            my $o = $tv->{$ov} ||= {};
            my $vnew = !keys %$o;
            $o->{$id} = $n;
            if ($vnew) {
                # must insert o
                my $i = 0;
                $i++ until !@$sl || !exists $sl->[$i] || $sl->[$i] >= $ov;
                @$sl && $sl->[$i] == $ov && die "Thought $i would new $ov ".wdump 3, $sl;
                splice @$sl, $i, 0, ($ov);
                sayre "n.t n.cv n.ov @@ C.t sl $i" if $i != 0 && $i != 1;
            }
        }
        # sc.tw.$id = sc.tv.$ov.$id = $n
        # sc.sl[0] = lowest $ov, etc
    }


# simple .$k.$t = C from Cs
# queue a push like a n does, substrate fromity from substrate
# A would have no c, giving itself as idea
# some over would batchify sources on supplied s
#  that reaches for store around history baggage selved
#  (actuaets history)
#  so to create indices of same t, etc
ow:
    my $k = shift @Me;
    my $c = s.c || {};
    my $sc = s.sc || $s;
    my $d = $sc->{$k}||={};
    #my $ot = $sc->{"hst_$k"};
    #($ot,my $to) = ({},$ot) if $ot;
    my $tw = {};
    for (@Me) {
        # could t=>s out and t-<s in, jamming many t
        my $K = _.t;
        if (my $al = $tw->{$K}) {
            die "Already loded a $K ".wdump [ @Me ];
        }
        $tw->{$K} = $_;
        my $o = $d->{$K};
        $d->{$K} = $_;
        #$ot->{$K} = $o if $ot && $o ne $_;
    }
    # %$ot && send c.w, qs edge of tex
    # C riplets 
