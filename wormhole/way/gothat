for my $AA (@{A.AAAA}) {
    my @D = map{values%$_} map{values%$_} values %{AA.II};
    my $ne = {map{$_=>1}keys%{AA.I}};
    for my $D (@D) {
        unless ($ne->{D.t}) {
            D.sc.eg || die "notI sub not .eg".ki$D;
            AA.symb ||= eval'\%'.D.sc.eg.'::';
            AA.I->{D.t} = $ne->{D.t} = AA.symb->{D.t};
        }
        delete $ne->{D.t} || sayre("II index for not in I: ".ki$D) && next;
        A.I->{D.t.'_dige'} = D.sc.dige;
        A.I->{D.t} = AA.I->{D.t};
        A.tople->{D.t} = 1;
    }
}
my $G;
G.up = hitime();
G.id = mkuid();
G.I = A.I;
G.A = $A;
A.talk = "G";
A.mo = $A;
our $G = $G;
our $KA = {};
$G::KA->{"$A"} = $A;
my $C = {};
my $T = {};
for my $sn (qw'pwin tie h w airlock') {
    $G->{$sn} = G.I->{$sn} || die "No $sn from G I";
}
$SIG{__DIE__} = G.I.sigstackend || die "NO sigstackend";
$SIG{__WARN__} = G.I.sigstackwarn || die "NO sigstackwarn";
G.IIII = [map{'G/T/'.$_}qw'H/Boat H/Rest p/Ang K/Stable'];

G&init;

Rw Run $A $C $G $T i;

G.clockon && G.clockon->() ||
    Mojo::IOLoop->is_running || Mojo::IOLoop->start;
