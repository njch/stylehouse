u alljs

# A falls, A.on taps each-for thing, A.W holst selves, usu not
A:
    var V = $.extend({},A);
    delete V.C;
    V.up = A;
    var A = V;
    A.I = {};
    A.om ||= A;
    A.om == A.up and A.mo = A;
    T.d ||= 1;
    s and var k = 'e_'+s; A.e = G[k];
    return A

# on last A.b
nn:
    !A.W and a.c("no aW",[A,C]);
    A.W.b ||= {};
    A.b ||= A.W.b;
    A.b[C.y.cv] ||= {};
    A.b[C.y.cv][C.t] ||= {};
    A.b.t ||= {};
    A.b.t[C.t] ||= {};
    A.b.t[C.t][C.y.cv] ||= A.b[C.y.cv][C.t];
    var b = A.b[C.y.cv][C.t];
    b.A = A;
    return b;

sca:
    while (s > 1) { s = s / 10 }
    return s;

h: %acgt:way s
    !G[way] and throw "No way: "+way
    return G[way](A,C,G,T,s);

# persona perforthe webclient channels
# so the G copies and lives from/to W
# h reach up/down to applied layers of you
# top level mirage is o(ww,Wid,$s) 
# which ins ww (G.Wid for Oth), J.id (Wid)
# and the difference is you

om:
    A = G&A,'om';
    C = G&inC,C;
    t&2;
    T.alk = 'w'+T.d+' '+C.t+' '+a.ks(C.c)+'%'+a.ks(C.sc);
    C.sc ||= {};
    C.sc.css ||= {};
    C.sc.anc ||= {};
    t&7;

t:
    T.not and return 0;
    A.I.cv = G&sca,s;
    G&ex,A.I;
    return !T.not;

# wants to sort in
eine:
    var K = s[0];
    var e = s[1];
    var k = 'e_'+K;
    G[k] = e;

ex:
    s.ei ||= 0;
    while (1) {
        T.not and return
        var v = A.e[s.ei];
        !v and return
        v[0] > s.cv and return
        s.ei++;
        $.each(v[1],function(i,D){
            T.not and return
            var t = D[0];
            var sc = D[1];
            sc.nk and !C[sc.nk] and return
            sc.gk and !C[sc.nk][sc.gk] and return
            var es;
            sc.gk and es = C[sc.nk][sc.gk];
            sc.s and es = sc.s;
            G&$t,es;
        });
    }

tcl: %com:#cplace
    var t = C.t.replace(/\W/g,'e');
    t = 'n'+t+'n';
    return t;

f:
    var t = '';
    s and t=s
    var at = '';
    C.y.cv and at += "[cv='"+C.y.cv+"']";
    t || at || console.log("No attach: "+T.alk);
    return $(A.on).find('> '+t+at);

#
inC:
    C = s;
    if (C.constructor == Array) {
        C = {t:C[0],y:C[1],c:C[2],sc:C[3]};
        typeof C.c  === 'string' and C.c =  G&peel,C.c;
        typeof C.sc === 'string' and C.sc = G&peel,C.sc;
    }
    else
    if (C.constructor == Object &&
        !C.t && !C.y && !C.c && !C.sc) {
        $.each(C, &k,v{ G&$k,v }); T.not = 1;
    }
    else
    typeof C === 'string' and C = {c: {s: C}};
    typeof C.c === 'string' and C.c = {s: C.c};
    typeof C.y === 'string' || typeof C.y === 'number' and C.y = {cv: G&sca,C.y };
    !typeof C.t === 'string' and console.log('queda',C);
    C.c ||= {};
    C.sc ||= {};
    return C;

Xi:
    !s and s = C.c.W;
    !s and s = C.c.M;
    $W = ww[s];
    W ||= mm[s];
    !(W && W.W && W.W.on) and ~die~nottunedin: s
    return W;

Xin:
    $W = ww[s];
    W ||= G&Win;
    return W;

Win:
    !(c&Wid && c&Mid) and ~die~noWMC: C
    $W = ww[c&Wid] = {};
    W.id = c&Wid;
    W.t = c&Mid;
    mm[W.t] = W;
    W.A = {};
    W.A.W = W;
    ~newW: W.t, W.id, W
    return W

Wout:
    var W = ww[A.W.id];
    W.t and mm[W.t] = W;
    delete ww[W.id];
    ~leaves W.t, W.id

die: %args:A C G T s etc
    ~dead: s, etc, A, C
    throw s
