--- 
I: 
  "0.1": 
    bitsof_babble: 
      c: 
        s: "A.I.bitsof_babble = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $p;\n    p.alive = qr/\\$[\\w]*[\\w\\->\\{\\}]+/;\n    p.dotha = qr/[A-Za-z_]\\w{0,3}(?:\\.[\\w-]*\\w+)+/;\n    p.oing = qr/p.alive|p.dotha|[-\\w]{8,}/;\n    p.oint = qr/[\\w\\$\\/\\->\\{\\}\\*]*[\\w\\$\\/\\->\\.\\}\\*]+/;\n    p.mwall = qr/(?:= |if |unless |^\\s*)/;\n    p.sur = qr/ if| unless| for| when|,?\\s*$|;\\s*/;\n    $p\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: 1cb90e1d550a
      t: bitsof_babble
      "y": 
        cv: '0.1'
    parse_babbl: 
      c: 
        s: "A.I.parse_babbl = sub {\n    my ($A,$C,$G,$T,$s,@Me) = @_;\n    my $I = A.I;\n    my $p = G.bitsof_babble ||= I.d&bitsof_babble;\n    # gone:\n    my $Jsrc = qr/(J\\d*(?:\\.\\w+)?) (\\w+)/;\n    my $Jlump = qr/(\\S+) (\\S+)\\s+(\\S.+)/;\n    $s =~ s/p.mwall$Jsrc $Jlump$/$1.$2->(\"$3\\\\t$4\" => $5);/smg;\n    \n    # :\n    my @s;\n    my $indbe;\n    my $inend;\n    for my $l (split \"\\n\", $s) {\n        my $s = $l;\n        if ($indbe) {\n            if ($indbe eq 'nextind') {\n                $s =~ /^(\\s+)/;\n                $indbe = qr/^$1/;\n            }\n            if ($s =~ $indbe) {\n                $s =~ s/^(\\s*)\\.(\\s*)$/$1$2/;\n                push @s, $s;\n                next;\n            }\n            else {\n                undef $indbe;\n                if ($s !~ /^\\s*$/) {\n                    if ($inend) {\n                        pop @s  if $s[-1] eq '';\n                        push @s, $inend;\n                    }\n                }\n                else {\n                    $s = $inend if $inend;\n                }\n                undef $inend;\n            }\n        }\n        my $ze = qr/<<['\"](\\w*)['\"]/;\n        if ($s =~ /^(\\s*)\\S.*$ze/) {\n            $indbe = $2 ?\n                qr/^(?!\\Q$1\\E)/ # for <<'EOD' til ^EOD, etc\n              : qr/^($1\\s+|\\s*$)/; # some space in or no nonspace = quote\n            $s =~ s/$ze/'<<'.($1?\"'$1'\":'STEVE')/e;\n            $inend = 'STEVE' if !$1;\n        }\n    \n        # babable # expect closing brackets and insert J\n        # eg Atime(2) = A.time->($J, 2)\n        $s =~ s/(p.mwall)(\\w*A)(\\w+)\\(/$1$2\\.$3->(\\$J, /smg;\n        $s =~ s/(p.mwall)(\\w*G)(\\w+)\\(/${1}G\\.$3->(\\$A,\\$C,\\$G,\\$T, /smg;\n        $s =~ s/(p.mwall)(\\w*J)(\\w+)\\(/$1$2\\.$3->(\\$$2, /smg;\n        $s =~ s/(p.mwall)(\\w*M)(\\w+)\\(/${1}J\\.m->(\\$$2, /smg;\n    \n        # close side ourselves, likely to gobble suro if, etc.\n        $s =~ s/(p.mwall)(u|n) (.+?);?$/${1}J\\.$2->($3=>'');/smg;\n        #$s =~ s/(p.mwall)(m) (\\w+)\\(/${1}J\\.$3->(\\$M, /smg;\n    \n        s/I\\.d\\&(p.oint)/G\\&$1/sg;\n        # lma quack $not->('tag');? from I.d&pui,$s\n        $s =~ s/(p.oing|\\w+)\\&(p.oint)(,[^\\s;]+)?(;)?/\n            my ($on,$p,$e,$t) = ($1,$2,$3,$4);\n            my $in;\n            ($on,$in) = (\"G\\.h\",'$A,$C,$G,$T,')\n                if $on eq 'G';\n            my $s = $on.\"->($in\\\"$p\\\"$e)$t\";\n            $s = '$'.$s if $on !~ m{\\.};\n            $s\n        /smge;\n        # $sc>$k -> $sc->{$k}\n        $s =~ s/(p.oing)((?:\\.>p.oing)+)/\n            join '->', $1, map {'{\"'.$_.'\"}'}\n            grep {$_} split m{\\.>}, $2;\n        /smge;\n    \n        while ($s =~ /(Rw (p.oint)(?:(?!p.sur) (.+?))?)p.sur/gsm) {\n            my ($old, $op, $oa) = ($1, $2, $3);\n            my $g;\n            $g ||= '$G';\n    \n            my $ne = \"\"; # hidden reverse\n            $ne = $1 if $oa =~ s/(p.sur)$//;\n    \n            my @n;\n            my @m;\n            # want to mix {m m m %$ar m m} whereever + is\n            my $wanr = $oa =~ s/^\\+ ?//;\n            $wanr = 'stick' if $oa =~ s/^- ?//;\n            for (split /\\,| |\\, /, $oa) {\n                # sweet little pool... $J:geo etc\n                if (/^\\$((\\w+(:|=))?\\S+)$/) {\n                    my ($na, $fa, $wa) = ($1, $2, $3);\n                    if (!$fa) { # fake name, to ar\n                        $fa = $na;\n                    }\n                    else {\n                        $na =~ s/^\\Q$fa\\E//;\n                        $fa =~ s/(:|=)$//;\n                        if ($wa eq '=') {\n                            $na = '\"'.$na.'\"';\n                        }\n                    }\n                    $na = '$'.$na unless\n                        $wa eq '=' || $na =~ /^\\S+\\.\\S/;\n                    push @n, \"$fa => $na\" ; # also avail a listy position\n                }\n                else {\n                    push @m, $_;\n                }\n            }\n            unshift @n, '%$ar' if (!@n || $wanr) && $wanr ne \"stick\";\n            push @n, \"m => [\".join(',',map{'\"'.$_.'\"'}@m).']'\n                if @m;\n    \n            my @e;\n            push @e, '\"'.$op.'\"';\n            push @e, \"{\".join(\", \",@n).\"}\";\n            my $en = join \", \", @e;\n    \n            my $wa = $g.'->{w}->('.$en.')'.$ne;\n            $s =~ s/\\Q$old\\E/$wa/          || die \"Ca't replace $1\\n\\n $s\";\n        }\n    \n        # sc.k -> $sc->{k};\n        $s =~ s/(?:(?<=\\W)|^)(?<!\\\\)([A-Za-z_]\\w{0,3})((?:\\.[\\w-]*\\w+)+)/\"\\$$1\".join\"\",map {\"->{$_}\"} grep {length} split '\\.', $2;/seg;\n        # \n        $s =~ s/aft \\{/acum \\$F[0] => _after_do => sub {/sg;\n        #\n    \n        push @s, $s;\n    }\n    push @s, $inend if $indbe && $inend;\n    $s = join \"\\n\", @s;\n    \n    $s;\n};"
      sc: 
        acgt: s
        args: A,C,G,T,s
        code: I
        dige: d6de9292ea1c
      t: parse_babbl
      "y": 
        cv: '0.1'
Ii: bitsof_babble 0.3 ARRAY 0:HASH + parse_babbl 0.3 ARRAY 0:HASH
