
C:            # W M ux ...
  - K: W #c us
    flows_D: |
      my $W = S.W;
      w stylespawn[$S, $W];
    Ss: [u, x, X]
    print: |
      "W=".S.W.G.name #Bthing, u is $S
    S: # TODO with Gw S things we go w.S.t_D then w.S.t then Gw.S.t_D then Gw.S.t
      styles: OxO nopoi
      tag: ww 
      id_D: |
        ( W.id =~ /-(\w+)$/ )[0]
  
  - K: M #c themmmmmmm from an R
    flows_D: |
      my $W = S.W;
      w stylespawn[$S, $W];
    print: |
      "MMMM=".S.W.G.name
    Ss: *
    S:
      styles: OxO poi
      tag: MMMM
        
  - K: style #c redis
    conor: -1.5
    ishtml: 1
    S:
      attr:
        scoped: undef
        type: text/css
      content_D: |
        my ($WM) = map{_.i} @{S.A.u_y};
        my $GG = WM.W.G;
        my $sheet = w stylesheet[$GG, $K];
        die "GG.name has style $K ? " unless length($sheet);
        # may need to careful order new appendages too?
        $sheet ? "\n$sheet\n" : "";
     
  - K: ux #c
    O: ux
    spawn: []
    S:
      tag: ux
    styles: te
    conor: 1
    print: |
       "S.K S.id  (".S.i->pi
       
hooks:
  fresh_init: |
    G.TV = {};
    G.R->phat(G.TV);
    G.V = {};
    G.R->phat(G.V);
  percolate: |
    my $uWa = {K => 'W', W => G.R};
    G.W = w G.R fuu(u => $uWa); # the unified into wormhole
  recoded_init: |
      #H.G w reexec;
      #G.A.u.i->w(uxd=>{});
  stylespawn: |
    my $GG = W.G;
    my $SsKs = S.Ss ||= [];
    
    if ($SsKs eq "*") {
        my $eS = $GG->anyway('S');
        $SsKs = [ map { _.K } @$eS ];
    }
    for my $K (@$SsKs) {
        push @{S.spawn||=[]}, {
            K => 'style',
            B => {K=>$K},
        };
        w styleup[$GG, $K];
    }
  styleup: |
    my $SS = w styleway[$GG, $K];
    $SS || die sw(["style $K not found", $K, $SS, $GG]);
    H.G w wayray(wa => SS.Ss, S=>$G);
    
    #sayre "style up GG.name $K  got ".@{SS.Ss};;
    
    my @SSSs = @{SS.Ss};
    for my $S (@SSSs) { # mix the stylebits together
        if (S.spawns) {
            for my $w (w $S spawns) {
                w._spawns = delete w.spawns;
                push @{SS.Ss}, $w unless grep { _.K eq w.K } @{SS.Ss};
            }
        }
    }
    for my $S (@{SS.Ss}) { # mix the stylebits together
        G.h->{S.K} = $S;
    }
  styleway: |
    for my $tryG ($GG, $G) {
        my $SS = $tryG->CsK({s=>'S', K=>$K});
        return $SS if $SS;
    }
  stylesheet: |
    $K ||= "S";
    my $SS = w styleway[$GG, $K];
    $SS || die "NoiSSSS $K on ux or GG.name";
    my $Ss = SS.Ss;
    my ($c, @s);
    my $san = sub {
        my $props = shift;
        join ";", map {
            ref $_ eq "HASH" && die
                "oi c.K from GG.name's $K _S !"
                ." css line got YAML-munted into HASH !"
                ." remove the space after the colon?";
            $_
        } @$props
    };
    join "\n", grep {defined}
    map{
        $c = $_;
        if (c.css) {
            ".".c.K."{".$san->(c.css)."}"
        }
        elsif (c.keif) {
            my $keif = join "\n", map {
                _.K."{".$san->(_.css)."}"
            } @{c.keif};
            my $yep = "@"."-webkit-keyframes ".c.K."{\n"
                .ind('  ', $keif)
            ."\n}";
            $yep
        }
    } @{SS.Ss};
    
  stylezo: |
    # u at->attribute traslator
    # kind of an argument resolver
    # everything should be styleup'd to G.h
    # making this a G1 function we call from ux with M's W.G
    # some $style has space(s), leads through D to other style
    # speaking of style
    # which is what these capital letter concepts as individuals speak
    # which is our language held nicely
    my $GG = $G; # having said G1 etc we shove it all into G(ux) for now
    my $apply;
    my @deply;
    $apply = sub {
        my $style = shift;
        return if $style !~ /./;
        return map { $apply->($_) } split ' ', $style if $style =~ / /;
        
        my $S = GG.h->{$style};
        if (!$S) {
            return push @deply, $1 if $style =~ /^-(.+)$/;
            my $DS = GG.h->{$1."_n"} if $style =~ /^(\w+)(\d+)$/;
            if ($DS) {
                DS.D || die sw["D found style not have D", $DS];
                $G->w(D => {%$ar, n => $2}, $DS);
            }
            else {
                 warn "no ifndo $style";
            }
        }
        else {
            # lingosa
            if (S.styles) {
                $apply->(S.styles);
            }
            S.css ? do{ 
                at.attr.class .= " $style";
            }:
            S.D ? do{
                my $ysty = $G->w("D", $ar, $S); # ux or whatever models joints here
                $apply->($ysty) if $ysty;
            }:
            do {
                sayre "wtf '$style'" unless $style =~ /^(yi|te)$/;
            };
        }
    };
    $apply->($styles);
    for my $d (@deply) {
        at.attr.class =~ s/$d//;
    }
    at.attr.class =~ s/^\s+|\s+$|\s\s+//sg;
    
    if (u.K eq "W") { # class to style="" outside <style> scope 
        my $clastyle = delete at.attr.class;
        for my $style (split ' ', $clastyle) {
            my $S = GG.h->{$style};
            for my $css (@{S.css}) {
                my ($k, $v) = split ":", $css;
                at.Z->{$k} ||= $v;
            }
            if (!@{S.css} || S.classy) {
                at.attr.class .= " $style"; # secret meaning
            }
        }
    }
    
    

  mux: |
      my $M = w Mr[$MR];
      my $TV = G.TV;
      my $u = ar.u || [];
      
      my $us = [ref $u eq 'ARRAY' ? @$u : $u];
      
      $a = {k=>$a} if !ref $a;
      
      TV.bz->('W 4', G.W) if a.full;
      
      TV.bz->("M/M.id 6", $M);
      
      my $v = a.v if defined a.v;
      $v ||= 4;
      # 1-9 -> humm/links/etc
      
      for my $u (@$us) {
          next unless defined $u;
          die wdump($u) unless ref $u eq 'C';
          say "mux $v ".$u->pi;
          TV.bz->("i/u.id $v", $u); # v maybe subtle
          TV.bz->("i/u.id%M 4", $M); # two divides - then M can optimise 7
      }
      
      0->sing(uxd => sub { w uxd; }, again=>1, begin=>0.2);
  remux: | # upgrading the rubble
    my $TV = G.TV;
    my ($goner) = grep { _.s eq $u } w JV[$TV];
    my $s = delete TV.bb->{goner.r};
    $s eq $goner || die;
    my $v = ar.v;
    $v ||= 9;
    TV.bz->(goner.T."\t".$v => goner.s);
  uxd: |
    my $TV = G.TV;
    G.TV = {};
    G.R->phat(G.TV);
    
    w ux[$TV];
  Mr: |
      my $Ma = {K => 'M', W => $MR};
      my $M = w G.R fuu(u => $Ma, q=>1); # the lines' W mirrored
      M.A->umk(G.W, 'M');
      M.A->umk($MR,'W'); # our long wave of the origin W (R/J)
      $M
  JV: |
    my @J;
    my $TV = ar.TV || ar.V;
    my $bb = TV.bb;
    for my $k (keys %$bb) {
        my $j = $bb->{$k};
        undef $j unless ref $j eq 'HASH' && j.t; # go round
        $j ||= $bb->{$k} = G.R->shj($k, $bb);
        j.T ||= j.t;
        (j.t,j.l) = ($1,$2) if j.t =~ /^(.+?)(%.+)$/;# pooling pull of lingo
        j.to ||= (j.t =~ /^(\w+)/)[0]; # ^
        
        if (ar.les) {
            if (ar.les eq '*') {
            }
            elsif (ar.les eq '%') {
                next if !defined j.l;
            }
            else {
                next if ar.les ne j.l;
            }
        }
        else {
            next if defined j.l;
        }
        
        push @J, $j;
    }
    @J
  orde: | # group by t or so ($k) and sort in by voltage
    my ($k, $v) = %$ar;
    my $by = {};
    $by->{"$_->{$k}"}->{_.r} = $_ for @$v;
    my @m = sort keys %$by;
    my $mi = 0;
    sub {
        my $t = $m[$mi++];
        return if !defined $t;
        $t = $by->{$t};
        
        # and bab clone sorting cv over T # already grouped by t or so
        # should come out same as style flows round that %ish place: /
        my @mm = sort { a.r cmp b.r } values %$t;
        
        #saybl "sort hop: _.r" for @mm;
        
        return \@mm;
    };
  ordey: |
    my $to = delete ar.to;
    my $ew = w orde;
    my $or;
    $or = sub {
        my $mw = $ew->() || return;
        my $am = {m=>$mw,t=>[],l=>[]};
        for my $m (@$mw) {
            my $at = m.l ? am.l : am.t;
            push @$at, $m;
        }
        #sayyl "$to lives: _.r => ".(ref _.s eq 'C' ? _.s->pi : _.s) for @{am.t};
        #saygr "$to styles: _.r => ".(ref _.s eq 'C' ? _.s->pi : _.s) for @{am.l};
        if (!@{am.t}) {
            warn "^ no things, next";
            return $or->();
        }
    
        $am;
    }
  orderv: |
    my $TV = ar.TV || ar.V;
    my $les = '*';
    my @J = w JV[$TV, $les];
    my @WJ = grep{_.to eq $to} @J;
    my $ew = w ordey(t=>\@WJ, to=>$to);
    return { ew => $ew, wj => \@WJ };

  pv: |
    my $n = ar.n || 1;
    my $name = "RD$n";
    sayre "            Daving $name => ".gp($i) for 1..2;
    my $dg = H.G K G:C;
    $dg w Dave(K=>"C",Dname=>$name,i=>$i);
              
    
  Tw: | # copy vertices and drop voltages accordingly
    my $e = w orderv(%$ar);
    while (defined(my $m = e.ew->())) {
        # 4 # response curves near
        my ($low) = @{m.t};
        my $s = low.s;
        my $cv = low.cv;
        
        $cv = 1 if $cv <= 3; # non hummed drops?
        if ($to eq 'i') {
            my $u = V.bb->{"i/s.id%u 3"};
            $cv = 1 if !$u || !u.s.at; # sat in
        }
        else {
            $cv = 1 if !s.at; # sat in
        }
        
        $p->{$cv}->{"$to/s.id"} = $s;
        sayre "low.r\t->\t [ $cv";
    }
    
  three: |
    if ($to eq 'i') {
        my $i = $s;
        ref $s eq 'C' || die $s;
        my $M = (TV.bb->{"i/i.id%M 4"}||die)->{s};
        my $ux = (V.bb->{"i/i.id%u 3"}||{})->{s};
        $p->{4}->{"M/M.id"} = $M;
        # also in M n_ux
        # also fuu might find the swaying identity (.K & .B) and return it
        say "for i i.id ".$i->pi;
        if ($ux) {
            say "Found u~! ux.i.id ".$ux->pi if $ux;
            die if ux.i ne $i;
        }
        else {
            # add C.Bs override for little B schemas not in .B.?
            my $uxa = {K => 'ux', i => $i};
            uxa.B.i = uxa.i;
            $ux = w G.R fuu(u => $uxa, q=>1);
        }
        ux.A->umk($M, 'ux');
        ux.A->umk(ux.i, 'U'); # into alien space
        V.bz->("i/i.id%u 3", $ux);
    }
  four: |
            if ($to eq 'i') {
                saybl "Four i";
                # the 374 coil, ux set must be complete
                # ux nests under another ux like origin
                # and M must humm after (reversal after 3
                my $ux = (V.bb->{"i/s.id%u 3"} || die)->{s};
                my $M = (TV.bb->{"i/s.id%M 4"} || die "no i/s.id.'%M 4'")->{s};
                
                push @{M.tohu||=[]}, $ux;
                
                for my $iu (@{ux.i.A.u_S||[]}) { # or whatever
                    my $u = (V.bb->{"i/iu.id%u 3"} || next)->{s};
                    die if $iu ne u.i;
                    $p->{5}->{"i/iu.id"} = $iu; # must go through to get here
                    ux.A->umk($u, 'uS'); # relatable
                }
            }
            elsif ($to eq 'M') {
                my $M = $s;
                my $got = M.vom; # before
                my $needmore = 0;
                for my $ux (@{M.tohu||[]}) {
                    next if $got->{ux.id};
                    $needmore = 1;
                }
                if ($needmore) {
                    my $j = {};
                    my $jp = w Usurf(j=>$j, i=>$M);
                    my $vom = {reverse %$jp};
                    keys %$jp == keys %$vom
                    || die wdump[[sort keys %$jp], [sort values %$vom]];
                    M.vom = $vom;
                }
                M.tom = {}; # < ^ others 5s put moves forth to 6
            }
  five: |
  
            if ($to eq 'i') {
                my $i = $s;
                my $ux = (V.bb->{"i/s.id%u 3"} || die)->{s};
                my $M = (TV.bb->{"i/s.id%M 4"} || die)->{s};
                my $vom = M.vom;
                my $tom = M.tom;
                
                my $mv = $vom->{ux.id} || die;
                $tom->{$mv} = $ux;
                #say "for ".$ux->pi." has top go through $mv";
            }
  six: |
    my @mm;
            if ($to eq 'W') {
                push @mm, $s;
            }
            if ($to eq 'M') {
                my $M = $s;
                push @mm, $M;
                
                my $vom = M.vom;
                my $to = M.tom;
                my $pat = [];
                for my $k (sort keys %$to) {
                    push @mm, $to->{$k};
                    push @$pat, {k=>$k, ux=>$to->{$k}};
                }
                M.pat = $pat;
            }
    for my $i (@mm) {
        #next if i.K eq 'ux' && !$p->{5}->{"i/i.i.id"};
        #sayyl "SPAWN ".$i->pi;
    }
  seven: |
    my @mm;
            if ($to eq 'W') {
                push @mm, $s;
            }
            
            if ($to eq 'M') {
                my $M = $s;
                
                my $pat = M.pat;
                
                push @mm, map {_.ux} reverse @$pat;
                
                push @mm, $M; # after desc lines come back
            }
    for my $i (@mm) {
        sayyl "ARR ".$i->pi;
        w compile_figure[$i, $j];
        w wayout_sendo[$i, $j];
    }
  pto: |
    my @m;
    for my $cv (sort keys %$p) {
        if ($cv <= $lcv) {
            my @ere = sort keys %{$p->{$cv}};
            @ere = reverse @ere if ar.rev;
            for my $el (@ere) {
                my ($to) = split '/', $el;
                my $s = $p->{$cv}->{$el};
                push @m, {
                    r=>{p=>$p,V=>$V,TV=>$TV,s=>$s,to=>$to}, # to do
                    aft=>{cv=>$cv,lcv=>(ar.rcv||$lcv),el=>$el,s=>$s}, # to move
                };
            }
        }
    }
    my $i=0;
    sub {
        my $r = ($m[$i]||{})->{r};
        if ($i>0) {
            my $aft = $m[$i-1]->{aft};
            if (aft.lcv < 9) {
                delete $p->{aft.cv}->{aft.el};
                $p->{aft.lcv}->{aft.el} = aft.s;
            }
        }
        return undef unless $r;
        $i++;
        return $r;
    };
  ux: |
    # 1
    # very left of the dome, heading into micro peaks
    # we get more likely to fork
    #   as we go out along things that already exist
    #   they humm back to themselves at 8s
    #     where we can either switch to it as master
    #     or drop it if the thing wants a new 4 or so already
    
    # the W is what we propagate, where ux # slight singley for now
    # the M is Random input grouper - upstream patch panel to C
    # the i is a sack of i, somewhere under M
    
    sayyl "\n ixomg ".$G->pi."    ".G.W->pi;
    my $W = G.W; # not really singular, crazy patchwork though
    my $V = G.V;
    my $les = '*';
    
    my @ONTV = w JV[$TV];
    my ($M) = map {_.s.W} grep {_.to eq 'M'} @ONTV;
        
    TV.bz->("W 6", $W) if !grep{_.to eq 'W'} @ONTV; # W always there
    
    my $p = {};
    # 2
    saybl "\n\n# 2";
    @ONTV = w JV[$TV];
    for my $j (@ONTV) {
        my $to = j.to;
        my $s = j.s;
        my $cv = j.cv;
        # 4 # response curves near
        
        $cv = 1 if $cv <= 3; # non hummed drops?
        if ($to eq 'i') {
            my $u = V.bb->{"i/s.id%u 3"};
            if (s.dead) {
                w G.R del[$u];
                delete V.bb->{"i/s.id%u 3"};
                sayre "SOMETHING DIED: ".$u->pi;
            }
            $cv = 1 if !$u || !u.s.at; # sat in
        }
        else {
            $cv = 1 if !s.at; # sat in
        }
        
        $p->{$cv}->{"$to/s.id"} = $s;
        sayre "j.r\t->\t [ $cv";
    }
    
    my $tvp = { V=>$V, TV=>$TV, p=>$p };
    
    my $threes = w pto(%$tvp, lcv => 3);
    while (defined(my $r = $threes->())) {
        w three(%$r);
    }
    
    w JV[$V]; # V ups for %u 3
    
    my $fours = w pto(%$tvp, lcv => 4, rev=>1);
    while (defined(my $r = $fours->())) {
        w four(%$r);
    }
    

    my $fives = w pto(%$tvp, lcv => 7, rcv=>5);
    while (defined(my $r = $fives->())) {
        w five(%$r);
    }
    
    my $j = $G->nw(K=>'j', s=>[], c=>[], W=>$W, M=>$M);
    
    my $sixes = w pto(%$tvp, lcv => 6);
    while (defined(my $r = $sixes->())) {
        w six(%$r, j=>$j);
    }
                    
    my $sevens = w pto(%$tvp, lcv => 6);
    while (defined(my $r = $sevens->())) {
        w seven(%$r, j=>$j);
    }
    
    H.G w aj[$j];
    
    sayre "ux -------- G.K done\t\t".F_delta."  load ".$H->la;
    
    my $ou = G.A.u.i;
    $ou w aj[$j];
    
    if (0) {
                    my $abb = { map { $_ => TV.bb->{$_}->{s} } keys %{TV.bb} };
                    w pv(i=>$p,n=>2);
    my @JJJ = w JV[$V];
    my $ab = { map { $_ => V.bb->{$_}->{s} } keys %{V.bb} };
    w pv(i=>$ab,n=>1);
    }
    
    G.TV;
    G.R->phat(G.TV);
    
  Usurf: |
    j.seenid->{i.id} = $i;
    my $jp = j.p ||= {};
    $j = {%$j};
    j.p = {};
    my $here = "i.id";
    $jp->{$here} = $here;
    my @down = w Udown;
    ar.d++;
    die if ar.d > 10;
    for my $d (@down) {
        my $jpp = w Usurf(j=>$j, i=>$d, d=>ar.d);
        for my $k (keys %$jpp) {
            $jp->{"$here/$k"} = $jpp->{$k};
        }
    }
    $jp;
    
    
    
    
    
  Udown: |
    # W->M->uxs, then uxs S amongst, y projects
    my $okn = { map {$_=>1} map {"n_$_"} qw'M ux S y' };
    my @ks = grep { $okn->{$_} } keys %{i.A};
    my @As = map { @{i.A->{$_}||[]} } @ks;
    my @down = map{_.i} @As;
    @down = grep {!ar.j.seenid->{_.id}} @down unless !ar.j || ar.allseeing;
    die if grep {_.dead} @down;
    uniq @down;
    
  compile_figure: |
        my $u = $i;
        my $ui = u.i if u.i;
        
        my $at = u.at = {};
        
        if (u.K eq "uW") {
            u.at = ui.at;
            sayre $ui->pi." wtf wtf ".$u->pi for 1..5;
            return;
        }
        
        # v the look-around-for-style-etc vortex v
        at.id = u.id; # probly... rest good to T
        at.tag = 0->uiuS($u => 'tag') || u.tag || u.K;
        at.ishtml = 0->uiuS($u => 'ishtml');
        at.class = 0->uiuS($u => 'class');
        
        my @styles;
        push @styles, u.styles, u.S.styles;
        push @styles, ui.styles, ui.S.styles if $ui;
        
        at.styles = join " ", grep {defined} @styles;
        
        
        at.tag ||= u.K;
        die "no tag" .sw($u) if !at.tag;
        
        at.conty = 0->uiuS($u => 'content');
        
        at.conty = "" if !defined at.conty;
        at.conty = encode_entities(at.conty) unless at.ishtml;
        
        
        my @down = w Udown(+ allseeing => 1);
        @down = sort { a.conor <=> b.conor } @down;
        at.ooze = \@down;
  wayout_sendo: |
        my $u = $i;
        my $ui = u.i if u.i && u.K eq 'ux';
        
        my $at = u.at;
        my $sendo = u.sendo = [];
        
        my ($s,$c) = ([],[]);
        my $do_S = sub { push @$s, shift };
        my $doj_S = sub {
            my ($id, $sp, @int) = @_;
            $do_S->("\$('#$id')".sprintf($sp, @int).";");
        };
        my $do_C = sub { push @$c, shift };
        # S is innards, C is complete (send all S before all C)
        # further thinking running on wholeness
        # order important
        my $_t = u._at;
        
        my $attr = at.attr = {
            id => at.id,
            class => at.class,
            %{ 0->uiuS($u => "attr") || {} },
        };
        
        my $conty = defined at.conty ? at.conty : "";
        my $oozs = [ grep { defined } map { _.html } @{ at.ooze } ];
        my $content = join "\n", @$oozs;
        
        at.Z = {}; # zip v
        
        at.Z = { %{at.Z}, %{u.Z} } if u.Z; # from u
        
        my $styles = at.styles;
        w stylezo[$u, $ui, $styles, $at];
        
        my $Z = 0->uiuS($u => "Z"); # from ui S/Z(_D)
        at.Z = { %{at.Z}, %$Z } if $Z;
        
        $Z && attr.style && die "got uiu $Z\t\tattr.style already";
        
        at.css = at.Z;
        for my $k (keys %{at.css}) {
            my $v = at.css->{$k};
            if (ref $v eq 'HASH') {
                delete at.css->{flit} if $k eq 'flit';
                at.css->{'-webkit-filter'} = join " ",
                    map{ "$_($v->{$_})" } sort keys %$v;
            }
        }
        attr.title = "H.style/H.name/H.id" if u.K eq "W";
        my $late = []; #c
        if (!$_t) {
            if ( $conty && $content ){
                warn "conty and ooze ".$u->pint;
                #sw(["contooz", $u, $conty, $content]);
                $conty = ",";
            }
            if (length($conty . $content) > 25000) {
                $content = "";
                $do_S->("\$('#at.id').append('$_');") for @$oozs;
            }
            for my $i ($u, $ui) {
                next unless 0;#$i && (i.S.sendo_init_D || i.Gw);
                #say "Snedoing ".$i->pi;
                my $Ce = w $i S/sendo_init_D[$u];
                $do_C->($Ce) if $Ce;
            }
            
            if ($u eq G.W) { # unified field of this W
                push @$late, sub {
                    $do_S->(
                        "\$('#ux > #at.id').remove();"
                    );
                    $do_S->(
                        "\$('#ux').append('".0->jsq(u.html)."');"
                    );
                };
                
                j._ && die "Already unified!?";
                j._ = $u; # TODO diffy for the J
            }
        }
        else {
            my $ino = sub { my ($u, $in) = @_; grep { $_ eq $u } @$in; };
            
            for my $newu (grep { !$ino->($_, u._at.ooze) } @{at.ooze}) {
                $doj_S->(at.id, q{.append('%s')}, 0->jsq(newu.html));
            }
            for my $gonu (grep { !$ino->($_, at.ooze) } @{u._at.ooze}) {
                $doj_S->(gonu.at.id, q{.remove()});
            }
            if (at.conty ne _t.conty) {
                my $s = 0->jsq(at.conty);
                $s =~ s/\\ \\ n/\n/x;
                $doj_S->(at.id, q{.html("%s")}, 0->jssq($s));
            }
            while (my ($k, $v) = each %{ at.attr }) {
                next if $v eq _t.attr->{$k};
                $doj_S->(at.id, q{.attr('%s', '%s')}, 0->jsq($k, $v));
            }
            if (at.css) {
                my $anima;
                #saybl $u->pi."    ".wdump(at.css) if %{at.css};
                while (my($k,$v) = each %{at.css}) {
                    next if $v eq _t.css->{$k};
                    my $isa = '++';
                    # an uiuS for mergins Anim/* ?
                    
                    my $anim = 1 if ui.K eq 'Im';
                    #;#ui.K eq 'Do' && ($k eq 'left' || $k eq 'top');
                    if ($anim) {
                        $anima->{$k} = $v; # BB
                    }
                    else {
                        $doj_S->(at.id, q{.css('%s', '%s')}, 0->jsq($k, $v));
                    }
                }
                if ($anima && %$anima) {
                    $anima = $H->ejson($anima);
                    $doj_S->(at.id, q".animate(%s, %s)", $anima, 1000);
                }
            }
        }
        attr.style .= shtocss(at.css) if at.css;
        my $tag = at.tag;
        my $mkat = sub {
            my $a = shift;
            my $v = $attr->{$a};
            return $a if $v eq "undef";
            return $a.'="'.$attr->{$a}.'"'
        };
        # style/class gets misccss/Wcss
        $attr = join " ", map { $mkat->($_) }
            grep { defined $attr->{$_} && $attr->{$_} ne "" } sort keys %$attr;
            
        u.html = "<$tag $attr>$conty$content</$tag>";
        $_->() for @$late; # what needs u.html
        
        u._at = $at;
        
        push @{j.s}, reverse @$s;
        push @{j.c}, reverse @$c;
  event: |
    my $uy = $i if $i ne $ux;
    my $i = ux.i if $ux;
    $i = undef if !$ux;
    my $E = {
        e => $e,
        W => $W,
        i => $i,
        ux => $ux,
        uy => $uy,
    };
    
    saybl " UX ". $ux->pi if $ux;
    saybl " Uy ". $uy->pi if $uy;
    return saygr "ungrasped line" unless $i;
    saybl " i ". $i->pi;
    
    # TODO make a pattern about y=to match against Eways...
    i.G w event(%$E);

