R_Jz:
 - K: domi #c Doofer
   n_D:
     any_init: |
       delete G.drop.conv;
       delete G.drop.vonc; # TODO drop all
       Rw conv;
       Rw vonc;
       
       Rw suck */dosc;
 - K: conv #c know about elemental stuff
   D: |
     my $pway = {qw'1 YIN 2 YANG 3 CARBON 7 CITOZINE 9 RETURN'};
     G.drop.conv = sub {
          my $v = shift;
         my $dig = $1 if $v =~ /^(\d)/;
         $pway->{$dig} || die " not convable $dig from $v";
     };
     G.drop.conv->(ar.v) if ar.v;
 - K: vonc #c elemental
   D: |
     G.drop.vonc = sub {
          my $v = shift;
         my $dig = $1 if $v =~ /^(\d)/;
         return $1;
     };
     G.drop.vonc->(ar.v) if ar.v;
 - K: Con #c the shunt, suck, J maint wayfile story # OSCILATE FUNCS, test frequencies tuned synapse
   D: |
     my ($the, $src, $path) = @$m;
     $src ||= "$the/u";
     $path ||= "$the/n";
     # or wherever thi src + carbon quags into existence
     # root l=$the := $the/n, otherwis whatever is l
     # so $the/X for subhash X, yin require of user
     # similar smush in G.drop.$the
     my $p = "$the c";
     my $J = Rw Carbonja $p $the;
     
       # shove togeth modn
       # get a cv sorter  that puts 3 > 32, since 3 is 3 all the way down > 3232323...
       # tesalation
       my $ljs = Rw tlv $J;
       # ^ hash styles, things are l+com, like $tks
       my $wtf;
       my $coms = {};
       for my $lj (@$ljs) {
           my $j = lj.j;
           
           if (!%$j) {
               warn "not j: ".wdump(2,$lj);
               next;
           }
           
           lj.sc && die "wop";
           
           acum $coms, j.cv => j.com;
           
           
           my $cvit = G.drop.vonc->(j.cv);
           my $was = $wtf->{j.l} ||= {};
           acum $was, $cvit, j.s; # <<<<<<< cv collapse unto elements
       } 
       
       my $real = {};
       $real->{$the} = R.way->find($src) || die "no $src";
       my $imag = {};
       my $tl = {};
       for my $l (sort keys %$wtf) {
           my $was = $wtf->{$l};
           for my $cvit (sort keys %$was) {
               my $v = $was->{$cvit};
               my $type = G.drop.conv->($cvit); # con cvit
               $tl->{$type} = @$v; # diagsum
               
               $v = join "\n", @$v;        # # <<<<<<<
               
               if ($real->{$l}) {
                   # after an elemental aggregation...
                   # these'll be top posting after cv sort?
                   $real->{$l} =~ s/(# $type.*?)$/$1\n$v/sm
                   
                   || die "no $type in ...";
               }
               else {
                   $imag->{$l} .= "\n$v";
               }
           }
       }
       
       my $all = {%$real, %$imag};
       die wdump[[sort keys %$real],[sort keys %$imag],[sort keys %$all]]
       if keys(%$real) + keys(%$imag) != keys %$all;
       for my $pin (sort keys %$all) {
           my $www = $all->{$pin};
           
           $pin = $path if $pin eq $the; # $the/n
           my $ac = join'',map{"{$_"}split'/',$pin;
           
           say "Injecting   $pin  $ac   with:";
           sayre ind '   ', slim 300, $www
               if 0 && $the eq 'esc'; # db
           $R->loadup(R.way.hooks, $ac, $www);
       }
       
       G.jumb.ConJ->{$the} = $J;
     

       
       #talkyelemental 
       my $sl; # elemental spawn coms
       my $cl = "";
       for (sort keys %$coms) {
           my $c = $coms->{$_};
           my $v = G.drop.conv->($_);
           my $fr = " ";
           if ($v ne $cl) {
               $fr = "";
               $cl = $v;
               $sl .= ") " if $sl;
               $sl .= "$v*$tl->{$v}("; # sum
           }
           $sl .= ${fr}.join " ", @$c;
       }
       $sl.=")";
       #saybl " _________________  $mw" if $the eq 'esc';
       sayyl "$path <- $the     $sl";
       # nice thing to print ^
       
 - K: Carbonja #c 3ish
   D: |
       my $tw = Rw fund $p;
       # per way file every $s, each one can be homeo, have some art for zip
       # where to suck local protocols
       die "no '$p'" if !%$tw;
       
       my $J = {};
       Rw suJ $J;
       
       my $p = "$the/el/*";
       my $ty = Rw huck $p;
       $ty = {map{
            my $type = $1 if /el\/(.+)$/ || die;
            my $an = $ty->{$_};
            die if @$an > 1;
            $type => $an->[0];
       }keys %$ty};
       
       for my $file (sort keys %$tw) {
           my $Cs = $tw->{$file};
           my $coi = Rw pha $J $k:file;
           
           if (my ($MZ) = grep{_.K eq 'MZ'}@$Cs) {
               # homex ty, local modulation, the radio
               # some carbon fits
               # also from $the/somemeta
           }
           
           for my $c (@$Cs) {
               my @wsy = grep {m/\S\s\S/} keys %$c;
               for my $zk (@wsy) {
                   my $D = $c->{$zk};
                   my ($k, $v) = split m/\s/, $zk;
                   my $ome = c.K;
                   my $com = "# $zk @ $ome  ";

                   Rw Nucleous $file $ty $c $com $ome $k $v $the $J $D;
               }
           }
           coi.end->();
       }
       $J
 - K: Nucleous #c
   D: |
          my (@l,@lr,@r); 
          
          $ome = "#$ome" if $ome;

          # if for c.cs, for implant condits # sche
          my $type = G.drop.conv->($v);
          # z downgrasp
          my $sc = c.MZ if c.MZ; # per $k if maybe ?? emberd whatsits
          # some special K of c may have meta for this too
          $sc ||= $ty->{$type};
          
               if (my $sub = sc.subhash) {
                   unshift @l, "G\.drop\.$the\.$sub\.c.K = sub {";
                   push @lr, '    my ($v,$tks,$'.$sub.') = @_;'; # gets $X, etc
                   $D = ind '     ', $D;
                   push @r, '};';
                   if (my $list = sc.droplist) {
                       push @r, "push \@{G\.drop\.$the\.$list}, 'c.K';";
                       J bz $k/$sub#rese$list 1 "G\.drop\.$the\.$list = [];"
                   }
                   my $haD = join "\n", $com, @l, @lr, $D, @r;
                   @l = (); @lr = (); @r = ();
                   J bz $k/$sub$ome $v $haD
                   J bz $k/$sub#rese 1 "G\.drop\.$the\.$sub = {};"
                   J bz $k/$sub#return 9 "G\.drop\.$the\.$sub;"
                   J bz $k#upsubhash-$sub 1 "my \$$sub = G\.drop\.$the\.$sub || Rw $k/$sub;"
                   return; #
               }
          
          # : EXPR ? DO +
          # or they want elsif
          # see what the cv wants to land on/through
          # see twisty ops in lightcones
          if (my $cs = sc.qmco) {
              push @l, ':', "\$tk eq 'c.K' ? do {";
              if (my $sub = sc.subhash) {
                  $D = "G\.drop\.$the\.$sub\.c.K->(\$v, \$tks)";
              }
              $D = ind '     ', $D;
              push @r, '}';
          }
          
          # if (sc.this) { DO } +
               if (my $cs = sc.csfrm) {
                   $cs = c.K if $cs eq 'cK';
                   $com .= "cs=$cs  ";
                   unshift @l, 'if (my $cs = c.'.$cs.') {';
                   $D = ind '     ', $D;
                   push @r, '}';
               }
               
               $D = join "\n", $com, @l, @lr, $D, @r;
               J bz $k$ome $v $D

