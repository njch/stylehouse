R_Jz:

 - K: ou/dire #c 
   D: |
     # LOOK FOR KNOWNS, scoped in wormhole
     die 'ref' if ref $u;
     -d $u || die "not found: $u pwd=".`pwd`;
     my @r = Rw globdir $dir:u;
     for my $n (@r) {
         my $r;
         r.r = n.r;
         r.s = n.full;
         # $x power percolates
         # track J.most.J etcs...
         # shway by Jhead the ou/dire culture suggestions
         # to be chucked on and off, little nonmuxing pi swimming events
         r.c.path = "!pat/dire:/r.r";
         r.c.pi = 'dire';
         r.lab_c.pi = 'direlab';
         push @{o.r}, $r;
         if (@{o.r} >= $thi) {
             o.more = @r - @{o.r};
             last;
         }
     }
 - K: pi/dire #c
   D: |
     my $x = J.d.g.x;
     my $dir = -d $u;
     my $file = -f $u;
     if ($dir) {
         if (J.fop->()) {
             Rw pi/direst $J $dir:u;
         }
     }
     elsif ($file) {
         
         return if J.cv < 0.2;
         
         if (J.cv >= 0.3) {
             my $sp = x.imspin++;
             x.imspin = 0 if $sp > 3;
             my $left = (($sp * 5)-4).'em';
             
             J.no->($J, thumb => 0.3,
                 {pi=>'thumbnail',s=>$u,gp=>{cv=>J.cv}},
                "{opa:0.5,left:$left,top:-5em,ab:1,rad:0.4,sat:4}");
         }
     }
     else {
         Rw wtf wtf 1 $J;
     }
 - K: pi/direlab #c round corner, where one bit/type/hum of noise splits others
   D: |
     my $s = $u;
     my $r = J.d.g.r;
     
     my $fi = {pi=>'fileinfo', s=>r.s, label=>$u};
     
     Jn(fileinfo => 0.3, $fi,
            '{hs:6.7.2.9,ab:1,top:1em,right:1em}');
     
     my $s = fi.label; # may change just then ^
     
     Jn('label', '', $s, '{zi:15,sha:2 3 6 ccf,fw:6,co:3f4}');
     
 - K: ou/image #c
   D: |
     -f $u || die 'not file';
     
     my $j = x.j;
     #Rw cruxal $x lala wagga;
     my $r;
     r.r = $u;
     r.s = $u;
     r.c.path = "!nowhere";
     r.c.pi = 'image';
     r.c.file = $u;
     push @{o.r}, $r;
 - K: pi/emb #c right
   D: |
     Jn(J.r, 0.2, "$u", '{fs:15}');
 - K: pi/fileinfo #c 0.3ish under dirlab
   D: |
     if (-d $u) {
         Jn(isdir => 0.4,
            {pi=>'emb', s=>'𐏓'},
            '{hs:3.7.5.9}');
     }
     if (-f $u) {
         Jn(isfile => 0.2,
         {pi=>'emb', s=>'f'},
            '{hs:6.7.2.9}');
         
         if (!defined J.d.c.fileext) {
             J.d.c.fileext = $1
                 if J.d.c.label =~ s/\.([^\.]+)$//;
         }
         if (defined J.d.c.fileext) {
             Jn(ext => 0.2, J.d.c.fileext, 
                 '{co:fff,sha:2 3 4 ccf,fs:8,zi:3,deco:1}');
         }
     }
     
     return unless J.fop->();
     
     if (-f $u) {
         Jn(filesiz => 0.3,
             {pi=>'filesiz', s=>$u}, # full
                '{hs:6.7.2.9}');
     }
     
 - K: pi/filesiz #c the vague know something about files disjoint
   D: |
     my $s = (stat $u)[7];
     say "$u is $s";
     my @t = qw'b kB MB GB';
     while ($s > 666) {
         shift @t || last;
         $s /= 1024;
     }
     $s = sprintf '%.1f', $s;
     my ($co) = @t;
     J.d.sc.fs = 7;
     Jn(size => 0.2, $s, '{hs:8.3.1.8}');
     Jn(co => 0.3, $co);
     
     
     #e
 - K: pi/direst #c shadowing fs
   D: |
     my @r = Rw globdir $dir;
     my @d = grep { -d _.full } @r;
     for my $r (@d) {
         J.no->($J, r.r, '',
             {s=>$r,pi=>'dierfi'},
             '{co:33f,sha:3 3 5 fff,ml:0.5em}');
     }
     my $ts;
     ts.d = @d;
     ts.files = @r - @d;
     Rw Mn + $n:_ for
         ['more', 0.88, {s=>$ts,pi=>'n_tal'}, {fs=>13,co=>'e9a7'}];
 - K: pat/dire #c pat a physical, in a directory
   D: |
     my $ex = join ' ', @$m;
     my $ul = J.onei.i.$ex;
     if (-d $ul) {
         J.onei.i = $ul
     }
     elsif (-f $ul) {
         w demux[$J];
         my $J = Rw jin mash;
         # & over there
         Rw ein/image $J $i:ul;
     }
     else{ die "no see $ul" }
 - K: globdir #c
   D: |
     my @ma = map{$H->fixutf8($_);chomp;$_}`ls -1 '$dir'`;
     my @r;
     for my $f (@ma) {
         my $r;
         r.full = "$dir/$f";
         r.r = $f;
         push @r, $r;
     }
     @r;
 - K: pi/image #c
   D: |
     -f $u || die;
     my $sc;
     sc.width = "44em";
     sc.height = "27em";
     sc.hue = 36;
     sc.con = 6;
     sc.left = "0em";
     J.d.sc.mw = "20em";
     Rw pi/thumbnail $u $J $sc;
 - K: pi/thumbnail #c image/video
   D: |
     my $size = -s $u;
     return "nontypeimage: $u" unless $u =~ /(png|gif|jpe?g)$/i;
     my $mou = "public/";
     #return if $size > 3_000_000;
     my ($first) = split '/', $u;
     die "$first not $mou?" unless -e "$mou$first";
     
     my $thl = "th/$u";
     my $th = "$mou$thl";
     
     # TODO mod slowness
     # make this thumbnail J even more forky than usual
     # TODO wander 90deg radial over phatness...
     # tape twist effect coming from somewhere
     
     if (!-f $th && J.fop->()) {
         sayyl " thumbnail++$u";
         my $thd = $1 if $th =~ /^(.+)\/(.+)$/ || die $th;
         if (!-d $thd) {
             run 'mkdir', '-p', $thd;
         }
         if ($u =~ /(mov|avi|mp4)$/i) {
             run 'ffmpegthumbnailer -s 420 -t 20% -i '.$u.' -o '.$th
         }
         else {
             run 'convert', $u, '-thumbnail','500x500', $th
         }
     }
     if (-f $th) {
         my $sc = {
             tag => 'img',
             zom=>{at => {src => $thl}},
             width=>'27em',
             height=>'27em',
             ab=>1,
             zi=>2,
             %{ar.sc||{}}
         };
         my $s = "";
         Rw wtf $J yowl 3 $s $sc;
     }
     delete J.mod.sc.over;
     #J.mod.sc.bgi = $thl;
 - K: pi/dierfi #c
   D: |
     Rw Mn + $n:_ for
     ['name', '', {s=> u.r }, {ml=>'2em'}];
     
     if (-d u.full) {
         Rw Mn + $n:_ for
         ['symbol', '', {s=>'/'}, {sha=>'3 3 4 af8',co=>'afa'}];
     }
     
 - K: pi/n_tal #c
   D: |
     my $i = 0;
     for my $k (sort keys %$u) {
         J.no->($J, count => '', "$u->{$k}", '{fs:9,co:39a7}');
         
         J.no->($J, k => '', "$k", '{fs:7,co:e9a7}');
         J.no->($J, Bs => '', ',', {}) if $i++ > 0;
     }

