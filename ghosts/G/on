Ds:
 - K: wag #c
   style: func
   D: |
     $H ||= {up=>hitime()};
     my $G = bless {}, 'G';
     G.id = mkuid();
     G.name = "theG";
     $G->catchings;
     $G->wayup("wormhole/yb\.yml");
     $G->w('expro');
     
     
     
 - K: catchings #c
   D: |
     $SIG{__WARN__} = sub {
        my $ing = shift;
        warn$ing unless $ing =~ /^Use of uninitialized/;
     };
     

     
 - K: wayup #c
   D: |
     G.way = G::LoadFile(shift);
 - K: fwind #c
   style: func
   D: |
      my $way = shift;
            my $point = shift;
            my @path = split /\/|\./, $point;
            my $h = $way;
            for my $p (@path) {
                $h = $h->{$p};
                unless ($h) {
                    undef $h;
                    last;
                }
            }
            return $h if defined $h;
            
            return undef unless $point =~ /\*/;
            die "sat rs findy $point";

     
 - K: g_w #c
   D: |
      my $am;
      #die wdump [@_] if @_ > 1;
      am.point = shift;
      am.ar = shift;
      
      am.name = join ' ', am.point, sort keys %{am.ar};
      am.sign = "Z";
      am.talk = "am.sign am.name";
      
      am.bab = G::fwind(G.way, am.point);
      
      if (!defined am.bab) {
          warn $G->pi."    way miss am.talk"
              if !(G.misslesswa ||= {map{$_=>1} qw'
                  fresh_init any_init recoded_init
                  percolate_R percolate load_ways_post aj event
              '})->{am.point};
          return;
      }
      
      my $Z = $G->Doming($am);
      my $r;
      eval { $r = [ $G->D($am) ] };
      $G->Done($Z);
      
      if ($@) {
          my $ne = "Z";
          $ne .= Z.inter if Z.inter;
          $ne .= "\n";
          $ne .= "$@";
          $@ = $ne;
          die $@ unless am.nodie;
          $@ = "";
      }
      return wantarray ? @$r : $r->[0];
 - K: g_pyramid #c
   D: |
      my $am = shift;
      confess "Ba" if ref $am ne 'HASH';
      
      my ($last) = @F;
      my $u = {%$am};
      if ($last) {
          push @{last.Lo||=[]}, $u;
          u.Li = $last;
      }
      else {
          push @{G.East||=[]}, $u;
      }
      
      u.G = $G;
      u.K = u.name || die;
      u.hitime = hitime;
      u.order = H.pyramiding++;
      u.stack = stack(2,7);
      u.F = [@F];
      u.depth = 0+@F;
      u.Error = $@ if $@; #?
      
      $u
      
 - K: g_Dm #c
   D: |
        my $am = shift;
        
        am.talk || confess wdump 2, $am;
        my $Ds = G.drop.Dscache->{am.talk};
        return $Ds if $Ds;
        
        confess "SOMEONENONE".wdump 1, $am if ref am.bab || !am.point;
        
        my $eval = $G->parse_babble(am.bab, am.point);
        
        my $ar = am.ar || {};
        ar.R ||= $G;
        my $download = join("", map {
            'my$'.$_.'=$ar->{'.$_."}; "
            } keys %$ar)
            if %$ar;
        my $upload = join("", map {
            '$ar->{'.$_.'}=$'.$_."; "
            } keys %$ar)
            if %$ar;
            
        my @warnings;
        my $sub = "bollox";
        my $evs = 'sub { my $ar = shift; '.
        "@warnings $download\n".

        "my \@doo_return = (sub { \n\n$eval\n })->();\n"

        ."$upload"
        .'return @doo_return };';

        
        $sub = $G->Doe($evs, $ar);
            
        $@ = "nicht kompilieren!\n\n$@" if $@;
        
        $Ds = {evs=>$evs, sub=>$sub, talk=>am.talk};

        if (!$@ && ref $sub eq "CODE") {
            G.drop.Dscache->{am.talk} = $Ds;
        }
        else {
            am.bungeval = $evs;
        }
        $Ds
 - K: g_D #c
   D: |
      my $D = shift;
            my $ar = D.ar || {};
            
            die "RECURSION ".@F if @F > $MAX_FCURSION; 
            
            my $Ds = $G->Dm($D);
            D.Ds = $Ds;
            my ($evs, $sub) = (Ds.evs, Ds.sub);
                
            # TODO getonwithitnciousness
            D.sign = 'D';
            D.talk = "D.sign D.name";
            $D = $G->Doming($D);
            
            G.sigstackend ||= sub {
                local $@;
                eval { confess( '' ) };
                my @stack = split m/\n/, $@;
                shift @stack for 1..1; # hide above this sub, G eval & '  at G...';
                my @stackend;
                push @stackend, shift @stack until $stack[0] =~ /G::(g_)?D/ || !@stack && die;
                s/\t//g for @stackend;

                # write on the train thats about to derail
                my $wall = $G::F[0]->{SigDieStack}||=[];

                push @$wall, \@stackend;
            };
            G.sigstackwa ||= sub {
                return 1 if $_[0] =~ /^Use of uninitialized value/;
                my @loc = caller(1);
                sayre join "\n", "warn from ".$F[0]->{G}->{name}
                    ."  way $F[0]->{point}"
                    ."       at line $loc[2] in $loc[1]:", @_;
                return 1;
            };
            
            my @return;
            if (ref $sub eq "CODE" && !$@) {
                local $SIG{__DIE__} = G.sigstackend;
                local $SIG{__WARN__} = G.sigstackwa;
                
                #sub ggggggg {eval{shift->(@_)}}
                wantarray ? 
                do { @return = ggggggg($sub, D.ar) }
                : do { $return[0] = ggggggg($sub, D.ar) };
                #eval {  = $sub->(a.ar) }
            }
            
            $G->Done($D); # Ducks
            D.r = [@return];
            
            
            return wantarray ? @return : shift @return
 - K: g_Duck #c do fuckup printout
   D: |
     my $D = shift;
     my $evs = D.Ds.evs;
     my $ar = D.ar;
     
     my $DOOF; 
     my $first = 1 unless $@ =~ /DOOF/;
                
                $DOOF .= "DOOF D.talk\n";
                $DOOF .= "  D.inter" if D.inter;
                
                if ($first) {
                    my $x = $1 if $@ =~ /syntax error .+ line (\d+), near/
                        || $@ =~ /line (\d+)/;

                    my $file = $1 if $@ =~ /at (\S+) line/;

                    undef $file if $file && $file =~ /\(eval \d+\)/;
                    undef $file if $file && !-f $file;

                    my $code = $file ? 
                    read_file($file)
                    : $evs;
                    
                    my $eval = $G->Duckling($x, $code, $D);
                    
                    if (exists $D->{SigDieStack}) {
                        warn "MALTY SIGGI" if @{$D->{SigDieStack}} > 1;
                        $DOOF .= "\n";
                        my $i = "  ";
                        for my $s ( reverse flatline($D->{SigDieStack}) ) {
                            $DOOF .= "$i- $s\n";
                            $i .= "  ";
                        }
                    }        
                    $DOOF .= "\n$eval\n";
                }
                
                if ($first) {
                    $DOOF .= ind("E    ", "\n$@\n\n")."\n\n";
                }
                
                if (!$first) {
                    my $in = D.sign eq 'D' ? "! " : "";
                    $DOOF .= ind($in, "$@")."\n";
                }
                if ($first) {
                    $DOOF .= ind('ar.', join "\n",
                        map{
                         my $e = $ar->{$_};
                         my $s = "$e";
                         $s .= "(name=$e->{name})"
                             if ref $e && ref $e ne 'ARRAY'
                            && $e->{name};
                        "$_ = ". $s;
                        }keys %$ar); 
                }
                
                D.Error = $DOOF;
                $@ = $DOOF;
                
                if (@F == 1) {
                    # send it away
                    sayre $DOOF;
                    G.dooftip && G.dooftip->($@);
                    $@ = "";
                    $_->() for @{G._aft_err_do||[]};
                }
                else {
                    die $@;
                }

