Ds:
 - K: wag #c
   style: func
   D: |
     $H ||= {up=>hitime()};
     my $G = bless {}, 'G';
     G.id = mkuid();
     G.name = "theG";
     $G->catchings;
     $G->wayup("wormhole/yb\.yml");
     $G->w('expro');
     sayre "exporop...";
     Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
     
     
     
 - K: catchings #c
   D: |
     $SIG{__WARN__} = sub {
        my $ing = shift;
        warn$ing unless $ing =~ /^Use of uninitialized/;
     };
     

     
 - K: wayup #c
   D: |
     my $way = read_file(shift);
     G.way = Load($way); 
 - K: g_parse_babble #c
   style: nonbabble
   D: |
            my $eval = shift;
            
            my $AR = qr/(?:\[(.+?)\]|(?:\((.+?)\)))/;
            my $G_name = qr/[\/\w]+/;
            my $Gnv = qr/\$?$G_name/;
            my $mwall = qr/(?:= |if |^\s*)/m;
            
            
            
            
            # word or scalar
            my $point = qr/[\w\$\/\->\{\}\*]*[\w\$\/\->\.\}\*]+/;
            
            my $alive = qr/\$[\w]*[\w\->\{\}]+/;
            # a.b.c
            my $dotha = qr/[A-Za-z_]\w{0,3}(?:\.[\w-]*\w+)+/;
            
            my $poing = qr/$alive|$dotha|[-\w]{8,}/;
            
            # [...]
            my $sqar = qr/\[.+?\]|\(.+?\)/; 
            
            # timer
            
            $eval =~ s/(timer|recur) ($NUM) \{/$1 \$G, $2, sub{/sg;
            
            $eval =~ s/aft \{/accum \$G, \$F[0] => _after_do => sub {/sg;
            
            
            my $Jsrc = qr/(J\d*(?:\.\w+)?) (\w+)/;
            # thingy, cv => thing
            my $Jlump = qr/(\S+) (\S+)\s+(\S.+)/;
            $eval =~ s/$mwall$Jsrc $Jlump$/$1.$2->("$3\\t$4" => $5);/smg;
            
            # oJn -> oJ.n->( ish
            $eval =~ s/($mwall)(\w*J)(\w+)\(/$1$2\.$3->(\$$2, /smg;
            $eval =~ s/($mwall)(\w*M)(\w+)\(/${1}J\.$3->(\$$2, /smg;
            
            # lma quack $not->('tag');
            $eval =~ s/(\w+)\&($point)/\$$1->("$2")/smg;
            
            
            # $sc>$k -> $sc->{$k}
            $eval =~ s/($poing)\.>($poing)/$1\->{"$2"}/smg;
            
            
            #$eval =~ s/waylay (?:($NUM) )?(\w.+?);/\$G->timer("$1",sub { w $2; },"waylay $2");/sg;
            
            # wholeness Rwish #
            
            my $sur = qr/ if| unless| for| when|,\s*$|;\s*/;
            my $surn = qr/(?>! if)|(?>! unless)|(?>! for)/;
            my $suro = qr/(?:$sur|(?>!$sur))/;
            
            my $_m = qr/(?: (.+))?/;
            my $_u = qr/(?: ($poing))?/;
            my $ylay = qr/(yl(?: $NUM)?)?/;
            my $_g = qr/($poing )?/;
            
            while ($eval =~ /(?:^| )()(Rw$ylay() ((?:\*\/)?$point)$_m?)$sur?$/gsm) {
                my ($g, $old, $delay, $u, $p, $a, $un) = ($1, $2, $3, $4, $5, $6, $7);
                #say wdump[($1, $2, $3, $4, $5, $6, $7)];
                $g ||= $u.'->{G}' if $u;
                $g ||= '$G';
                $u ||= '$R';
                
                my $ne = ""; # hidden reverse
                $ne = $1 if $a =~ s/($sur)$//;
                
                my @n;
                my @m;
                my $wanr = $a =~ s/^\+ ?//;
                $wanr = 'stick' if $a =~ s/^- ?//;
                for (split /\,| |\, /, $a) {
                    # sweet little pool... $J:geo etc
                    if (/^\$((\w+(:|=))?\S+)$/) {
                        my ($na, $fa, $wa) = ($1, $2, $3);
                        if (!$fa) { # fake name, to ar
                            $fa = $na;
                        }
                        else {
                            $na =~ s/^\Q$fa\E//;
                            $fa =~ s/(:|=)$//;
                            if ($wa eq '=') {
                                $na = '"'.$na.'"';
                            }
                        }
                        $na = '$'.$na unless
                            $wa eq '=' || $na =~ /^\S+\.\S/;
                        #saygr "from: $a          na: $na";
                        push @n, "$fa => $na" ; # also avail a listy position
                    }
                    else {
                        push @m, $_;
                    }
                }
                unshift @n, '%$ar' if (!@n || $wanr) && $wanr ne "stick"; 
                
                # could use ^ here # edpeak?
                push @n, "m => [".join(',',map{'"'.$_.'"'}@m).']'
                    if @m;
                
                my @e;
                push @e, '"'.$p.'"';
                push @e, "{".join(", ",@n)."}";
                push @e, $u if $u;
                my $en = join ", ", @e;
                
                my $wa = $g.'->w('.$en.')'.$ne;
                
                if ($delay) {
                    $delay =~ /yl ($NUM)/;
                    $delay = $1 || "";
                    $wa = '$G->timer("'.$delay.'",sub { '.$wa.' })';
                }
                
                #saygr " $old \t=>\t$wa \t\t\tg$g \tu$u \tp$p \ta$a \tun$un";
                
                $eval =~ s/\Q$old\E/$wa/          || die "Ca't replace $1\n\n in\n\n$eval";
            }
            
            # way
            while ($eval =~ 
            /\${0}($poing )?((?<![\$\w])w(aylay(?: $NUM)?)?(?: ($poing))? ($point)( ?$sqar| ?$point|))($sur)?/sg) {
                my ($g, $old, $delay, $u, $p, $a, $un) = ($1, $2, $3, $4, $5, $6, $7);
                die wdump[$old,$eval];
            } 
            
            # 8/9
            
            $eval =~ s/\${0}($poing)? K ($point)(?::($point))?(;| )/
            ($1 || '$G')
            .qq {->K("$2","$3")$4}/seg;
            
            $eval =~ s/(?<!G)0->(\w+)\(/\$G->$1(/sg; 

            $eval =~ s/(?:(?<=\W)|^)(?<!\\)([A-Za-z_]\w{0,3})((?:\.[\w-]*\w+)+)/"\$$1".join"",map {"->{$_}"} grep {length} split '\.', $2;/seg;


            $eval;
 - K: fwind #c
   style: func
   D: |
      my $way = shift;
            my $point = shift;
            my @path = split /\/|\./, $point;
            my $h = $way;
            for my $p (@path) {
                $h = $h->{$p};
                unless ($h) {
                    undef $h;
                    last;
                }
            }
            return $h if defined $h;
            
            return undef unless $point =~ /\*/;
            die "sat rs findy $point";

     
 - K: g_w #c
   D: |
      my $am;
      #die wdump [@_] if @_ > 1;
      am.point = shift;
      am.ar = shift;
      
      am.name = join ' ', am.point, sort keys %{am.ar};
      am.sign = "Z";
      am.talk = "am.sign am.name";
      
      am.bab = fwind(G.way, am.point);
      
      if (!defined am.bab) {
          warn $G->pi."    way miss am.talk"
              if !(G.misslesswa ||= {map{$_=>1} qw'
                  fresh_init any_init recoded_init
                  percolate_R percolate load_ways_post aj event
              '})->{am.point};
          return;
      }
      
      my $Z = $G->Doming($am);
      my $r;
      eval { $r = [ $G->D($am) ] };
      $G->Done($Z);
      
      if ($@) {
          my $ne = "Z";
          $ne .= Z.inter if Z.inter;
          $ne .= "\n";
          $ne .= "$@";
          $@ = $ne;
          die $@ unless am.nodie;
          $@ = "";
      }
      return wantarray ? @$r : $r->[0];
 - K: g_pyramid #c
   D: |
      my $am = shift;
      confess "Ba" if ref $am ne 'HASH';
      
      my ($last) = @F;
      my $u = {%$am};
      if ($last) {
          push @{last.Lo||=[]}, $u;
          u.Li = $last;
      }
      else {
          push @{G.East||=[]}, $u;
      }
      
      u.G = $G;
      u.K = u.name || die;
      u.hitime = hitime;
      u.order = H.pyramiding++;
      u.stack = stack(2,7);
      u.F = [@F];
      u.depth = 0+@F;
      u.Error = $@ if $@; #?
      
      $u
      
 - K: g_Dm #c
   D: |
        my $am = shift;
        
        am.talk || confess wdump 2, $am;
        my $Ds = G.drop.Dscache->{am.talk};
        return $Ds if $Ds;
        
        die "SOMEONENONE".wdump 2, $am if ref am.bab;
        
        my $eval = $G->parse_babble(am.bab, am.point);
        
        my $ar = am.ar || {};
        ar.R ||= $G;
        my $download = join("", map {
            'my$'.$_.'=$ar->{'.$_."}; "
            } keys %$ar)
            if %$ar;
        my $upload = join("", map {
            '$ar->{'.$_.'}=$'.$_."; "
            } keys %$ar)
            if %$ar;
            
        my @warnings;
        my $sub = "bollox";
        my $evs = 'sub { my $ar = shift; '.
        "@warnings $download\n".

        "my \@doo_return = (sub { \n\n$eval\n })->();\n"

        ."$upload"
        .'return @doo_return };';

        
        $sub = $G->Doe($evs, $ar);
            
        $@ = "nicht kompilieren!\n\n$@" if $@;
        
        $Ds = {evs=>$evs, sub=>$sub, talk=>am.talk};

        if (!$@ && ref $sub eq "CODE") {
            G.drop.Dscache->{am.talk} = $Ds;
        }
        else {
            am.bungeval = $evs;
        }
        $Ds
 - K: g_D #c
   D: |
      my $D = shift;
            my $ar = D.ar || {};
            
            die "RECURSION ".@F if @F > $MAX_FCURSION;
            my $sub = D.D || do {
                 D.Ds = $G->Dm($D);
                 D.Ds.sub;
            };
            #ref $sub eq 'CODE' || die wdump [ $@, $D ];
                
            # TODO getonwithitnciousness
            D.sign = 'D';
            D.talk = "D.sign D.name";
            $D = $G->Doming($D);
            
            G.sigstackend ||= sub {
                local $@;
                eval { confess( '' ) };
                my @stack = split m/\n/, $@;
                shift @stack for 1..3; # hide above this sub, G eval & '  at G...';
                my @stackend;
                push @stackend, shift @stack until $stack[0] =~ /g::ggggggg/ || !@stack && die;
                s/\t//g for @stackend;

                # write on the train thats about to derail
                my $wall = $G::F[0]->{SigDieStack}||=[];

                push @$wall, \@stackend;
            };
            G.sigstackwa ||= sub {
                return 1 if $_[0] =~ /^Use of uninitialized value/;
                my @loc = caller(1);
                sayre join "\n", "warn from $F[0]->{talk}"
                    ."       at line $loc[2] in $loc[1]:", @_;
                return 1;
            };
            
            my @return;
            if (ref $sub eq "CODE" && !$@) {
                local $SIG{__DIE__} = G.sigstackend;
                local $SIG{__WARN__} = G.sigstackwa;
                
                #sub ggggggg {eval{shift->(@_)}}
                wantarray ? 
                do { @return = ggggggg($sub, D.ar) }
                : do { $return[0] = ggggggg($sub, D.ar) };
                #eval {  = $sub->(a.ar) }
            }
            
            $G->Done($D); # Ducks
            D.r = [@return];
            
            
            return wantarray ? @return : shift @return
 - K: g_Duck #c do fuckup printout
   D: |
     my $D = shift;
     my $evs = D.Ds.evs;
     my $ar = D.ar;
     
     my $DOOF; 
     my $first = 1 unless $@ =~ /DOOF/;
                
                $DOOF .= "DOOF D.talk\n" if D.sign eq 'D';
                $DOOF .= "  D.inter" if D.inter;
                
                if ($first) {
                    my $x = $1 if $@ =~ /syntax error .+ line (\d+), near/
                        || $@ =~ /line (\d+)/;

                    my $file = $1 if $@ =~ /at (\S+) line/;

                    undef $file if $file && $file =~ /\(eval \d+\)/;
                    undef $file if $file && !-f $file;

                    my $code = $file ? 
                    read_file($file)
                    : $evs;
                    
                    my $eval = $G->Duckling($x, $code, $D);
                    
                    if (exists $D->{SigDieStack}) {
                        warn "MALTY SIGGI" if @{$D->{SigDieStack}} > 1;
                        $DOOF .= "\n";
                        my $i = "  ";
                        for my $s ( reverse flatline($D->{SigDieStack}) ) {
                            $DOOF .= "$i- $s\n";
                            $i .= "  ";
                        }
                    }        
                    $DOOF .= "\n$eval\n";
                }
                
                if ($first) {
                    $DOOF .= ind("E    ", "\n$@\n\n")."\n\n";
                }
                
                if (!$first) {
                    my $in = D.sign eq 'D' ? "! " : "";
                    $DOOF .= ind($in, "$@")."\n";
                }
                if ($first) {
                    $DOOF .= ind('ar.', join "\n",
                        map{
                         my $e = $ar->{$_};
                         my $s = "$e";
                         $s .= "(name=$e->{name})"
                             if ref $e && ref $e ne 'ARRAY'
                            && $e->{name};
                        "$_ = ". $s;
                        }keys %$ar); 
                }
                
                D.Error = $DOOF;
                $@ = $DOOF;
                
                if (@F == 1) {
                    # send it away
                    sayre $DOOF;
                    G.dooftip && G.dooftip->($@);
                    $@ = "";
                    $_->() for @{G._aft_err_do||[]};
                }
                else {
                    die $@;
                }

