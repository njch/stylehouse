Ds:
  - K: Flab #c too dry
    D: |
        wish(G=>$G) || die "send G";
        say join("", "$G->{db} + $db", ("_") x scalar(@F))."$G->{name}  $_[0]"
            if $G->deeby && $_[0] !~ /^\w\ Error/;
        $G->ob(@_);
        my $s = $G->pyramid(@_);
        unshift @Flab, $s;
        $s->{Flab} = [@Flab];
        $s;
        
  - K: fla
    D: |
        $F[0]->{G}->Flab(@_);
        
  - K: ways
    D: |
        grep { !$_->{_disabled} } @{$G->{ways}}
    
  - K: findway
    D: |
        my $point = shift;
        my @w = grep { defined $_ } map { $_->find($point) } $G->ways;
        wantarray ? @w : shift @w;
        
  - K: anyway
    D: |
        my $point = shift;
        my @a = grep { defined $_ } map { $_->find($point, 1) } $G->ways;
        wantarray ? @a : shift @a
        
  - K: load_ways #c
    D: |
        my @ways = @_;
        G.ways ||= [];
        G.wayfiles ||= [];
        G.load_ways_count++;

        my $ldw = [];
        while (defined( my $name = shift @ways )) {
            my @files;

            my $base = "ghosts/$name";
            push @files, $base if -f $base;
            push @files, grep { /\/\d+$/ }
                map { $H->fixutf8($_) } glob("$base/*");

            for my $file (@files) {
                # TODO pass an If object selector to 0->deaccum
                @{G.ways} = grep { _._wayfile ne $file } @{G.ways};
                $G->deaccum($G, wayfiles => $file);
                
                my ($w) = grep { _._wayfile eq $file } @{G.ways};

                my ($wn) = $file =~ /ghosts\/(.+)$/;
                $wn ||= $file;
                my $nw = $G->nw(name=>$wn);
                nw.A->umv('', 'way');
                $nw->load($file);

                say "G G.name w+ nw.name";
                push @{G.wayfiles}, $file;
                push @{G.ways}, $nw;
            }
            
            G.name =~ s/\+$name// && warn "no wayfiles from $name" || die
            unless @files; # ^ dies if was first way name
        }

        $G->_0('_load_ways_post', {w=>G.ways});
  - K: Dm #c
    D: |
        my $a = shift;
        
        if (a.D) {
            die unless ref a.D eq "CODE";
            return ["???", a.D];
        }
        
        my $uuname = join " ",
            $G->{id},
            $H->dig(a.bab),
            a.point,
            " ar%".join(",",sort keys %{a.ar}),
        ;        
        my $ha = $H->dig($uuname);
        die unless length($ha) == 40;
            
        my $Ds = $D_cache{$ha};
        return $Ds if $Ds;
        
        my $eval = $G->parse_babble(a.bab, a.point);
        
        my $ar = a.ar || {};
        my $download = join("", map {
            'my$'.$_.'=$ar->{'.$_."}; "
            } keys %$ar)
            if %$ar;
        my $upload = join("", map {
            '$ar->{'.$_.'}=$'.$_."; "
            } keys %$ar)
            if %$ar;
          # there is
        my @warnings = ("no warnings 'experimental';");

        my $sub = "bollox";
        my $evs = '$sub = sub { my $ar = shift; '.
        "@warnings $download\n".

        "my \@doo_return = (sub { \n\n$eval\n })->();\n"

        ."$upload"
        .'return @doo_return };';

        eval $evs;

        $Ds = [ $evs, $sub ];
        if (!$@ && ref $sub eq "CODE") {
            $D_cache{$ha} = $Ds;
        }
        else {
            a.bungeval = $evs;
        }
        $Ds
  - K: D #c
    D: |
            my $a;
            $a = shift;
            my $ar = a.ar || {};
            
            die "RECURSION ".@F if @F > $MAX_FCURSION; 
            
            # also a.D can be CODE, $Ds viv
            if (ref a.bab eq "C") {
                my $b = a.bab;
                die unless b.K eq "Disc";
                return b.G->w('D', a.ar, $b);
            }

            my $Ds = $G->Dm($a);
            my ($evs, $sub) = @$Ds;
                
            # TODO rewayen
            a.name = "D";
            my $D = $G->Doming($a);
            
            my $komptalk = "nicht kompilieren! nicht kompilieren!\n $@" if $@;
            
            H.sigstackend ||= sub {
                local $@;
                eval { confess( '' ) };
                my @stack = split m/\n/, $@;
                shift @stack for 1..3; # hide above this sub, G eval & '  at G...';
                my @stackend;
                push @stackend, shift @stack until $stack[0] =~ /G::D/ || !@stack && die;
                s/\t//g for @stackend;

                # write on the train thats about to derail
                my $wall = $G::F[0]->{SigDieStack}||=[];

                push @$wall, \@stackend;
            };
            my @return;
            if (ref $sub eq "CODE" && !$@) {
                local $SIG{__DIE__} = H.sigstackend;
                eval { @return = $sub->(a.ar) }
            }
            
            $G->Done($D); #c D
            D.Returns = [@return];
            
            if ($@) { #     DOO DOO # # TODO di, 0ish
                my ($x) = $@ =~ /line (\d+)/;
                $x = $1 if $@ =~ /syntax error .+ line (\d+), near/;
                my $file = $1 if $@ =~ /at (\S+) line/;
                undef $file if $file && $file =~ /\(eval \d+\)/;
                undef $file if $file && !-f $file;
                my $perl = $H->slurp($file) if $file;
                $perl ||= $evs;
                
                my $eval = "";
                $eval .= "$file\n" if $file;
                my @eval = split "\n", $perl;
                my $xx = 0;
                $x -= 3 if $x;
                shift @eval for 1..3;
                pop @eval for 1..3;
                my $whole = @eval < 20;
                for (@eval) {
                    $xx++;
                    
                        if (!defined $x) {
                            $eval .= ind("⊘  ", $_)."\n"
                        }
                        elsif ($xx == $x) {
                            $eval .= ind("⊘  ", $_)."\n";
                            my $bab = (split"\n",a.bab)[$x -1];
                            if ($bab ne $_) {
                                $eval .= ind("⊖r ", $bab)."\n";
                            }
                        }
                        elsif (!$whole && $xx > $x-5 && $xx < $x+5) {
                            $eval .= ind("|  ", $_)."\n"
                        }
                        elsif ($whole) {
                            $eval .= ind("|  ", $_)."\n"
                        }
                }
                my $DOOF; 
                my $first = 1 unless $@ =~ /DOOF/;
                
                $DOOF .= "DOOF ".sprintf("%-24s",
                    $G->{name}." ".(ar.S ? "S=".gpty(ar.S) :"")
                );
                $DOOF .= " w"." a.point  ".join(", ", keys %$ar)."\n";;
                if ($first) {
                    if (exists $D->{SigDieStack}) {
                        warn "MALTY SIGGI" if @{$D->{SigDieStack}} > 1;
                        $DOOF .= "\n";
                        my $i = "  ";
                        for my $s ( reverse flatline($D->{SigDieStack}) ) {
                            $DOOF .= "$i- $s\n";
                            $i .= "  ";
                        }
                    }        
                    $DOOF .= "\n$eval\n";
                }
                $DOOF .= ind("E    ", "\n$komptalk$@\n\n")."\n\n"     if $first;
                $DOOF .= ind("!   ", "$@")."\n"             if !$first;
                $DOOF .= ind("ar  ",wdump(1,$ar))             if $first;
                
                my $OOF = $G->Flab("D Error $@", $DOOF, $D);
                if ($first) {
                    #$H->error($OOF);
                }
                $D->{Error} = $DOOF;
                $@ = $DOOF;
                die "$@";
            }
            
            return wantarray ? @return : shift @return
  - K: Doming #c
    D: |
        my $a = shift;
        die if @_;
        
        my $s = $G->pyramid($a);

        unshift @F, $s;
        s.F = [@F];

        return $s;
  - K: Done #c
    D: |
        my $D = shift;
        sayre join"", ("BATS  ")x 23 if $F[0] ne $D;
        D.Error = $@ if $@;
        
        if (D._after_do) {
            $_->() for @{D._after_do};
        }
        
        @Flab = ();
        shift @F;
        
        $D
  - K: timer #c coming, going
    D: |
            my $time = shift || 0.001;
            my $D = shift;
            my $a;
            a.name = "t";
            a.time = $time;
            a.D = $D; # maybe sub or Disc like thing
            a.stuff = [@_];
            my $Dome = $G->Doming($a);
            
            Mojo::IOLoop->timer($time, sub {
                $G->comeback($Dome);
            });
            
            $G->Done($Dome);
            
            return $Dome;
  - K: comeback #c
    D: |
        my $Dome = shift;
        my $a;
        a.name = Dome.name;
        a.name eq 't' || die 'wei';
        a.name = 'r';
        a.from = $dome;
        
        my $Doing = $G->Doming($a);
        
        $G->D({D=>a.from.D, toplevel=>1});
        
        $G->Done($Doing);
        
  - K: waystacken #c # TODO going in favour of flablessness, Rish sa*
    style: nonbabble
    D: |
            my $s = $G->pyramid(@_);
            push @{ $F[0]->{undies} ||= [] }, $s if @F;
            unshift @F, $s;
            $s->{F} = [@F],
            $G->ob("\\", $s);
            my $unway = sub {
                my @FF;
                if ($F[0] ne $s) {
                    my $E = "BATS ";
                    if (!grep {$_ eq $s} @F) {
                        $E .= "self nowhere in \@F"
                    }
                    else {
                        unshift @FF, shift @F until $FF[0] && $FF[0] eq $s || !@F;
                        $E .= " - from $_->{name}\n" for shift @FF;
                    }
                    $H->error(BATS => $G->Flab($E, $s, [[@FF], [@F]]));
                }
                else {
                    shift @F;
                }
                
                if ($@) {
                    #$G->Flab("Stack Return Error", $s, $@);
                    $s->{Error} = $@;
                }
                $s->{Flab} = [@Flab];
                
                if ($s->{_after_do}) {
                    $_->() for @{$s->{_after_do}};
                }
                
                my $te = $@; $@ = "";
                $G->ob("/", $s);
                $@ = $te;
                @Flab = ();
                $s
            };
            wantarray ? ($unway, $s) : $unway;
  - K: nw #c G ways
    D: |
      my $C = G.A->spawn('C');  
      
      $C->from({@_}) if @_;
      # etc
      $C 
      
  - K: wayb #c TODO way bending, other G stuff
    D: |
      my ($GG, $atu) = @_;
      
      atu.way || die "needs a way".wdump($atu);
      
      my $suway = join "", map {"{$_"} split /\//, atu.way;
      
      G.R->loadup($atu, "{hooks$suway", $atu);
      
      push @{GG.ways}, $atu; # A etc
      # A drop old G+K+name
      # replay dep on perc state of origin $G
      
  - K: w #c
    style: nonbabble
    D: |
      my $point = shift; 
      my $ar = shift;
      my $Sway = shift;
      my @ways;

      die "What do you MEAN $G->{name} $point $ar $Sway !?  ".wdump($ar) if defined $ar && ref $ar ne "HASH";
      my $talk = "w $point";
      my $watch;

      if ($Sway) {
          $talk .= " S";
          if (ref $Sway eq 'Ghost' || ref $Sway eq "G") {
              @ways = $Sway->ways;
              $talk .= " G";
          }
          elsif (ref $Sway eq 'Way' || ref $Sway eq "C") {
              if ($Sway->{ofways}) {
                  @ways = @{$Sway->{ofways}};
              }
              elsif ($Sway->{Gw}) {
                  my $SG = $Sway->{G} || die "no Sway G!?";
                  my $CodeK = $Sway->{Gw};
                  $CodeK = $Sway->{K} if $CodeK eq "1";
                  $point = "$CodeK/$point" unless $point =~ /^$CodeK/;
                  if ($G eq $SG) {
                      @ways = $G->ways; # ------------------
                  }
                  else {
                      return $SG->w($point, $ar, $Sway); # G pass
                  }
              }
              else {
                  @ways = $Sway; #---------------------
              }
          }
          elsif (ref $Sway eq 'ARRAY') {
              die "NO MORE ARRAY WAYS --- $point ".slim(100,80,ki($ar))."\n"."$Sway - ".ki($Sway);
          }
          my $b = {};
          %$b = (%{$Sway->{B}}, B => $Sway->{B}) if $Sway->{B};
          $ar = {%$ar, %$b, S => $Sway};
          $ar->{S} = $G->{S} if $G->{S};
      }
      else {
          @ways = $G->ways;
      }

      my $l = [];
      for my $w (@ways) {
      
          my $h = $w->find($point) || next;
          
          my $a = {
            name => "Z",
            stuff => [$talk],
            bab => $h,
            ar => $ar,
            point => $point,
            Sway => $Sway,
            w => $w,
          };
          
          my $Z = $G->Doming($a);
          
          Z.l = $l;
          push @$l, $Z;
          
          my $r;
          
          eval { $r = [ $G->D($a) ] };

          Z.r = $r;
          
          $G->Done($Z);

          if ($@) {
              my $ne = "Z";
              $ne .= Z.inter} if Z.inter;
              $ne .= "\n";
              $ne .= "S: ".ki($Sway)."\n" if $Sway;
              $ne .= "$@";
              $@ = $ne;
              $G->Flab("Z Error $@");
              die $@;
          }
      }
      
      if (!@$l) {
          $G->Flab("way miss $talk", \@ways, $Sway) if $G->deeby > 3;
          return;
      }
      
      if (@$l > 1) {
            warn "multiple returns from $point";
      }
      
      my ($z) = @$l;
      my @r = @{z.r};
      return wantarray ? @r : shift @r;
  - K: pyramid #c
    D: |
      my $a = shift if @_ == 1;
      if (!ref $a) {
          a.name = $a;
          a.stuff = [@_];
      }
      my $u;
      my ($last) = @F;
      # spawn the shadows of actions
      # could want more complexity per G
      # A hooks?
      $u = last.A->spawn('C') if $last;
      $u ||= G.A->spawn('C');
      u.G = $G if $G ne u.G;
      
      G.A->An($u, 'pyramid');
      G.A->An($u, 'pyramid_tip') if !$last;
      
      # TODO ^ set A u words to 'pyramid'
      
      my $stack = $H->stack(2,7);# short
      
      
      
      my $from; # FUZZ!
      if ($stack->[0] =~ /G::timer/) {
          $from = "time"
      }
      elsif ($stack->[1] =~ /G.+eval.+/
          && $stack->[2] =~ /G::doo/) {
          $from = "some doing..."
      }
      else {
          ($from) = $stack->[0] =~ / (\S+::\S+) /;
          $from =~ s/.*G::(Fl|wa).*/$1/ && do {
              $from =~ s/^wa$/Dᣝ/ ||
              $from =~ s/^Fl$/ᣜD/
          }
          || $from =~ s/G::/G\:/;
      }
      my $dir = ($last ? "last.id>" : "").u.id;
      #say "pyra $dir $from  $thing->[0]";
      $from ||= "stackw\ $stack->[0]";
      shift @$stack;

      $u->from({
          K => "$from",
          hitime => $H->hitime(),
          stack => $stack,
          Flab => [@Flab],
          F => [@F],
          depth => 0+@F,
          thing => $thing,
       #   print => 'S.name;',
      });
      $u->from({Error=>$@}) if $@;
      #u.name = join " ", grep {defined $_} u.G.name, u.K, gpty(@{u.thing});
      $u
      

