Ds:
  - K: load_ways #c
    D: |
        my @ways = split /\+/, G.way;
        
        my $base = 'ghosts';
        $base = "G.stylebase/$base" if G.stylebase;
        
        my @Aways = map{_.i}@{G.A.n_way};
        
        my $Awns = join '+', sort map{_.name}@Aways;
        my $Gwns = join '+', sort map{_.name}@{G.ways};
        $Awns eq $Gwns || sayre "tons of A way building up for G way....?";
        
        my $Aways = {map{_.name=>$_}@Aways};
        
        G.ways ||= [];
        G.wayfiles ||= [];
        H.load_ways_count->{G.id}++;
        my $ldw = [];
        for my $ghost (@ways) {
            my @files;

            my $where = "$base/$ghost";
            push @files, $where if -f $where;
            push @files, grep { /\/\d+$/ }
            # only glob numbery, so C/name will file further than C ways
                map { fixutf8($_) }
                grep {-f $_}
                glob("$where/*") if -d $where;

            for my $file (@files) {
                my ($name) = $file =~ /ghosts\/(.+)$/;
                
                @{G.ways} = grep { _.name ne $name } @{G.ways}; # TOGO
                if (my $old = $Aways->{$name}) {
                    0->deaccum(G.A, 'n_way', $old);
                    # w G.R del(u=>$old) if G.R; # held by pyramid...
                }
                
                $G->deaccum($G, wayfiles => $file);
                
                my ($w) = grep { _._wayfile eq $file } @{G.ways};

                my $nw = $G->nw(name=>$name);
                nw.A->umv('', 'way');
                $nw->load($file);

                push @$ldw, $nw;
                push @{G.wayfiles}, $file;
                push @{G.ways}, $nw;
            }
            
            die "no wayfiles from $ghost" unless @files;
        }
        
        say "G G.name w+ ".join"  ", map{_.name}@$ldw;

        return $G->w("load_ways_post") if !$G0;
        
        $G0 w _load_ways_post(S=>$G,w=>G.ways);
  - K: ways #c
    D: |
        grep { !$_->{_disabled} } @{$G->{ways}}
    
  - K: findway #c
    D: |
        my $point = shift;
        my @w = grep { defined $_ } map { $_->find($point) } $G->ways;
        wantarray ? @w : shift @w;
        
  - K: anyway #c
    D: |
        my $point = shift;
        my @a = grep { defined $_ } map { $_->find($point, 1) } $G->ways;
        wantarray ? @a : shift @a
        

  - K: Dm #c
    D: |
        my $a = shift;
        
        if (a.D) {
            die unless ref a.D eq "CODE";
            return {evs=>"?????????????????", sub=>a.D};
        }
        
        my $uuname = join " ",
            $G->{id},
            dig(a.bab),
            a.point,
            " ar%".join(",",sort keys %{a.ar}),
        ;        
        my $ha = dig($uuname);
        die unless length($ha) == 40;
            
        my $Ds = G0.Dscache->{$ha};
        return $Ds if $Ds;
        
        my $eval = $G->parse_babble(a.bab, a.point);
        
        my $ar = a.ar || {};
        my $download = join("", map {
            'my$'.$_.'=$ar->{'.$_."}; "
            } keys %$ar)
            if %$ar;
        my $upload = join("", map {
            '$ar->{'.$_.'}=$'.$_."; "
            } keys %$ar)
            if %$ar;
          # there is
        my @warnings;

        my $sub = "bollox";
        my $evs = 'sub { my $ar = shift; '.
        "@warnings $download\n".

        "my \@doo_return = (sub { \n\n$eval\n })->();\n"

        ."$upload"
        .'return @doo_return };';

        $sub = $G->Doe($evs, $ar);
            
        $@ = "nicht kompilieren!\n\n$@" if $@;
        
        $Ds = {evs=>$evs, sub=>$sub, ha=>$ha};

        if (!$@ && ref $sub eq "CODE") {
            G0.Dscache->{$ha} = $Ds;
        }
        else {
            a.bungeval = $evs;
        }
        $Ds
  - K: Doe #c
    D: |
      my $D_eval_string = shift;
      my $ar = shift;
      return eval $D_eval_string;
      
  - K: D #c
    D: |
            my $a;
            $a = shift;
            my $ar = a.ar || {};
            
            die "RECURSION ".@F if @F > $MAX_FCURSION; 
            
            # also a.D can be CODE, $Ds viv
            if (ref a.bab eq "C") {
                my $b = a.bab;
                die unless b.K eq "Disc";
                return b.G->w('D', a.ar, $b);
            }

            my $Ds = $G->Dm($a);
            a.Ds = $Ds;
            my ($evs, $sub) = (Ds.evs, Ds.sub);
                
            # TODO rewayen
            a.name = "D";
            my $D = $G->Doming($a);
            
            G.sigstackend ||= sub {
                local $@;
                eval { confess( '' ) };
                my @stack = split m/\n/, $@;
                shift @stack for 1..3; # hide above this sub, G eval & '  at G...';
                my @stackend;
                push @stackend, shift @stack until $stack[0] =~ /G::D/ || !@stack && die;
                s/\t//g for @stackend;

                # write on the train thats about to derail
                my $wall = $G::F[0]->{SigDieStack}||=[];

                push @$wall, \@stackend;
            };
            G.sigstackwa ||= sub {
                return 1 if $_[0] =~ /^Use of uninitialized value/;
                my @loc = caller(1);
                sayre join "\n", "warn from ".$F[0]->{G}->{name}
                    ."  way $F[0]->{point}"
                    ."       at line $loc[2] in $loc[1]:", @_;
                return 1;
            };
            my @return;
            if (ref $sub eq "CODE" && !$@) {
                local $SIG{__DIE__} = G.sigstackend;
                local $SIG{__WARN__} = G.sigstackwa;
                
                
                eval { @return = $sub->(a.ar) }
            }
            
            $G->Done($D); # Ducks
            D.r = [@return];
            
            
            return wantarray ? @return : shift @return
  - K: Doming #c
    D: |
        my $D = shift;
        die if @_;
        
        $D = $G->pyramid($D);

        unshift @F, $D;
        D.F = [@F];

        return $D;
  - K: Done #c
    D: |
        my $D = shift;
        sayre join"", ("BATS  ")x 23 if $F[0] ne $D;
        D.dolat = $@ if $@;
        
        $_->() for @{D._after_do||[]};
        
        shift @F;
        
        $G->Duck($D) if $@;
        
        $_->() for @{D._aft_etc_do||[]};
        
        
        $D
  - K: Duck #c do fuckup printout
    D: |
        my $D = shift;
        my $evs = D.Ds.evs;
        my $ar = D.ar;
                my $DOOF; 
                my $first = 1 unless $@ =~ /DOOF/;
                $DOOF .= " ". $D;
                $DOOF .= "DOOF D.K".sprintf("%-24s",
                    $G->{name}."  D.K  ".(ar.S ? "S=".gpty(ar.S) :"")
                );
                $DOOF .= " w"." D.point  ".join(", ", keys %$ar)."\n";
                
                if (D.K ne 'Dᣝ') {
                    $DOOF =  "D.K"; 
                    $DOOF .= "  D.inter" if D.inter;
                    $DOOF .= "\n";
                }  
                
                
                
                if ($first) {
                    my $x = $1 if $@ =~ /syntax error .+ line (\d+), near/
                        || $@ =~ /line (\d+)/;

                    my $file = $1 if $@ =~ /at (\S+) line/;

                    undef $file if $file && $file =~ /\(eval \d+\)/;
                    undef $file if $file && !-f $file;

                    my $code = $file ? read_file($file) : $evs;
                    
                    my $eval = $G->Duckling($x, $code, $D);
                    
                    if (exists $D->{SigDieStack}) {
                        warn "MALTY SIGGI" if @{$D->{SigDieStack}} > 1;
                        $DOOF .= "\n";
                        my $i = "  ";
                        for my $s ( reverse flatline($D->{SigDieStack}) ) {
                            $DOOF .= "$i- $s\n";
                            $i .= "  ";
                        }
                    }        
                    $DOOF .= "\n$eval\n";
                }
                
                if ($first) {
                    $DOOF .= ind("E    ", "\n$@\n\n")."\n\n";
                }
                
                if (!$first) {
                    my $in = (D.K ? D.K eq 'Dᣝ' : D.sign eq 'D') ? "! " : "";
                    $DOOF .= ind($in, "$@")."\n";
                }
                if ($first) {
                    $DOOF .= ind('ar.', join "\n",
                        map{
                         my $e = $ar->{$_};
                         my $s = "$e";
                         $s .= "(name=$e->{name})"
                             if ref $e && ref $e ne 'ARRAY'
                            && $e->{name};
                        "$_ = ". $s;
                        }keys %$ar); 
                }
                
                D.Error = $DOOF;
                $@ = $DOOF;
                
                if (@F == 1) {
                    # send it away
                    sayre $@;
                    G.dooftip && G.dooftip->($@);
                    $@ = "";
                    $_->() for @{G0._aft_err_do||[]};
                }
                else {
                    die $@;
                }
  - K: Duckling #c the code look
    D: |
        my ($line, $code, $D) = @_;
        
        my $diag = "";
        my @code = split "\n", $code;
        my $whole = @code < 18;
        
        
        if (!D.Verb && $code =~ /^sub \{ my \$ar = shift/
            && $code =~ /return \@doo_return \};/) {
            $line -= 2 if $line;
            shift @code for 1..2;
            pop @code for 1..2;
        }
        
        
        my $xx = 0;
        my $lci;
        for my $c (@code) {
            $xx++;
            $lci = $1 if $xx < $line && $c =~ /^\s*(#\s*\d.*)$/;
            if (!defined $line) {
                $diag .= ind("⊘  ", $c)."\n"
            }
            elsif ($xx == $line) {
                $diag .= ind("⊘  ", $c)."\n";
                
                my $bab = (split"\n",D.bab)[$line-2];
                if ($bab ne $c) {
                    $diag .= ind("⊖r ", $bab)."\n";
                }
            }
            elsif (!$whole && $xx > $line-5 && $xx < $line+5) {
                $diag .= ind("|  ", $c)."\n"
            }
            elsif ($whole) {
                $diag .= ind("|  ", $c)."\n"
            }
        }
        
        $diag = "$diag\n#~~~$lci" if $lci && $lci !~ /^# 0.01/;
        $diag
      
  - K: stack #c
    style: func
    D: |
      my $b = shift;
      my $for = shift || 1024;
      $b = 1 unless defined $b;
      my @from;
      while (my $f = join " ", (caller($b))[0,3,2]) {
          last unless defined $f;
          my $surface = $f =~ s/(Mojo)::Server::(Sand)Box::\w{24}/$1$2/g
              || $f =~ m/^Mojo::IOLoop/
              || $f =~ m/^Mojolicious::Controller/;
          $f =~ s/(MojoSand\w+) (MojoSand\w+)::/$2::/;
          push @from, $f;
          last if $surface;
          last if !--$for;
          $b++;
      }
      return [@from];
      
  - K: timer #c coming, going
    D: |
            my $time = shift || 0.001;
            my $D = shift;
            
            my $B; 
            B.name = "t";
            B.talk = "Ze timer from ".$F[0]->{talk};
            B.time = $time;
            B.D = $D; # maybe sub or Disc like thing
            B.stuff = [@_];
            my $Dome = $G->Doming($B);
            
            Mojo::IOLoop->timer($time, sub {
                $G->comeback($Dome);
            });
            
            $G->Done($Dome);
            
            return $Dome;
  - K: para #c TODO for pushing into future light cone, paranoi
    D: |
        # we can guess what to do and do it before the user
        #    has to squeeze right in there...
        # use Mojo::IOLoop::ForkCall;
        die "install it";
        # TODO get better paraphernalia
        # ram and cpus
        # new OS to get latest mojo things working in
        # such as this and Mojo::Redis2 for better eventing of sub
        my $fc = Mojo::IOLoop::ForkCall->new;
        $fc->run(
           sub {},
           ['arg', 'list'], 
           sub { my ($fc, $err, @return) = @_; ... }
        );
  - K: comeback #c
    D: |
        my $Dome = shift;
        
        my $a;
        a.name = 'r';
        a.from = $Dome;
        my $Doing = $G->Doming($a); 
        
        $G->D({D=>Dome.D, toplevel=>1, talk=>"351 dollars",name=>"comeback"});
        
        $G->Done($Doing);
        
        sayre $@ if $@; # TODO toplevely
        $@ = "";
        
  - K: waystacken #c # TODO going in favour of flablessness, Rish sa*
    style: nonbabble
    D: |
            my $s = $G->pyramid(@_);
            push @{ $F[0]->{undies} ||= [] }, $s if @F;
            unshift @F, $s;
            $s->{F} = [@F],
            my $unway = sub {
                my @FF;
                if ($F[0] ne $s) {
                    my $E = "BATS ";
                    if (!grep {$_ eq $s} @F) {
                        $E .= "self nowhere in \@F"
                    }
                    else {
                        unshift @FF, shift @F until $FF[0] && $FF[0] eq $s || !@F;
                        $E .= " - from $_->{name}\n" for shift @FF;
                    }
                    warn "BATS: $E     s.point";
                }
                else {
                    shift @F;
                }
                
                if ($@) {
                    $s->{Error} = $@;
                }
                
                if ($s->{_after_do}) {
                    $_->() for @{$s->{_after_do}};
                }
                
                my $te = $@; $@ = "";
                $@ = $te;
                $s
            };
            wantarray ? ($unway, $s) : $unway;
  - K: nw #c G ways
    D: |
      my $C = G.A->spawn('C');
      
      $C->from({@_}) if @_;
      # etc
      $C 
      
  - K: wayb #c TODO way bending, other G stuff
    D: |
      my ($GG, $atu) = @_;
      
      atu.way || die "needs a way".wdump($atu);
      
      my $suway = join "", map {"{$_"} split /\//, atu.way;
      
      G.R->loadup($atu, "{hooks$suway", $atu);
      
      push @{GG.ways}, $atu; # A etc
      # A drop old G+K+name
      # replay dep on perc state of origin $G
      
  - K: w #c
    D: |
      my $point = shift; 
      my $ar = shift;
      my $S = shift; # some kinda C subject
      my $a = shift;
      my @ways;
      
      die wdump($ar) if $ar && ref $ar ne 'HASH';
      ar.R = undef if !defined ar.R;
      
      my $talk = "w\ $point";
      my $watch;

      if ($S) {
          my $y = 'S';
          $talk .= " $y";
          if (ref $S eq "G") {
              $talk .= " G";
          }
          elsif (ref $S eq "C") {
              if (my $of = S.ofways) { # TODO 
                  @ways = @$of;
              }
              elsif (S.Gw) {
                  my $SG = S.G || die "no way G!?";
                  my $CodeK = S.Gw;
                  $CodeK = S.K if $CodeK eq "1";
                  $point = "$CodeK/$point" unless $point =~ /^$CodeK/;
                  if ($G eq $SG) {
                      @ways = $G->ways; # ------------------
                  }
                  else {
                      return $SG->w($point, $ar, $S); # G pass
                  }
              }
              else {
                  @ways = $S; #---------------------
              }
          }
          elsif (ref $S eq "R") {
              @ways = S.way;
              $G = S.G;
              $y = 'R';
          }
          
          if (my $B = S.B) {
              # we dont upload variables from B
              # change B.whatever to set
              # good verboz code clarity for scheming
              %$ar = (%$ar, %$B, B => $B);
          }
          $ar->{$y} = $S;
      }
      else {
          @ways = $G->ways;
      }

      my $l = [];
      for my $w (@ways) {
      
          my $h = $w->find($point) || next;
          
          my $a = {
            name => "Z",
            stuff => [$talk],
            bab => $h,
            ar => $ar,
            point => $point,
            way => $S,
          };
          a.w = $w;
          
          my $Z = $G->Doming($a);
          
          Z.l = $l;
          push @$l, $Z;
          
          my $r;
          
          eval { $r = [ $G->D($a) ] };

          Z.r = $r; # TODO many awkward
          
          $G->Done($Z);

          if ($@) {
              my $ne = "Z";
              $ne .= Z.inter if Z.inter;
              $ne .= "\n";
              $ne .= "S: ".ki($S)."\n" if $S;
              $ne .= "$@";
              $@ = $ne;
              die $@ unless a.nodie;
              $@ = "";
          }
      }
      
      if (!@$l) {
          my ($wa) = $talk =~ /^w\ (\w+)/;
          
          warn $G->pi."    way miss $talk"
          if !(G.misslesswa ||= {map{$_=>1}
              qw'print humms_D flows_D fresh_init any_init recoded_init percolate_R percolate load_ways_post pv aj uxyou_D event life_D'}
            )->{$wa};
          return;
      }
      
      if (@$l > 1) {
            warn "multiple returns from $point";
      }
      
      my ($z) = @$l;
      my @r = @{z.r};
      return wantarray ? @r : shift @r;
  - K: pyramid #c
    D: |
      my $a = shift;
      
      my ($last) = @F;
      # spawn the shadows of actions
      # could want more complexity per G
      # A hooks?
      my $u = last.A->spawn('C') if $last && do{
          last.A ||  do {
              sayre  "finish!";
              exec "nice perl $0 @ARGV";
          };
          last.A;
      };
      if (!$u) {
            $u = G.A->spawn('C');
          u.A->umv('','pyramid');
      }
      u.G = $G if $G ne u.G;
      
      confess "Ba" if !ref $a;
      
      $u->from($a);
      u.K = u.name || die;
      u.K .= 'ᣝ';
      u.hitime = hitime();
      u.order = H.pyramiding++;
      u.stack = $H->stack(2,7);
      u.F = [@F];
      u.depth = 0+@F;
      u.Error = $@ if $@; #?
      
      G.A->An($u, 'pyramid');
      
      $u
      
  - K: F_delta #c
    style: func
    D: |
      my $now = hitime();
      my $then = $F[0]->{hitime};
      my $d = sprintf("%.3f",$now-$then);
      $d = $d<1 ? ($d*1000).'ms' : $d.'s';
  - K: inter #c
    style: func
    D: |
      my $thing = shift;
      my $ki = ki($thing);
      $ki =~ s/^\s+//;
      $F[1]->{inter} .= " -{".$ki."}\n";
  - K: intr #c as above... but on D
    style: func
    D: |
      my ($k, $v) = @_;
      $F[0]->{intr}->{$k} = $v;

