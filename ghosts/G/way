Ds:
  - K: Flab #c too dry
    D: |
        wish(G=>$G) || die "send G";
        say join("", "$G->{db} + $db", ("_") x scalar(@F))."$G->{name}  $_[0]"
            if $G->deeby && $_[0] !~ /^\w\ Error/;
        $G->ob(@_);
        my $s = $G->pyramid(@_);
        unshift @Flab, $s;
        $s->{Flab} = [@Flab];
        $s;
        
  - K: fla
    D: |
        $F[0]->{G}->Flab(@_);
        
  - K: ways
    D: |
        grep { !$_->{_disabled} } @{$G->{ways}}
    
  - K: findway
    D: |
        my $point = shift;
        my @w = grep { defined $_ } map { $_->find($point) } $G->ways;
        wantarray ? @w : shift @w;
        
  - K: anyway
    D: |
        my $point = shift;
        my @a = grep { defined $_ } map { $_->find($point, 1) } $G->ways;
        wantarray ? @a : shift @a
        
  - K: load_ways #c
    D: |
        my @ways = @_;
        G.ways ||= [];
        G.wayfiles ||= [];
        G.load_ways_count++;

        my $ldw = [];
        while (defined( my $name = shift @ways )) {
            my @files;

            my $base = "ghosts/$name";
            push @files, $base if -f $base;
            push @files, grep { /\/\d+$/ }
                map { $H->fixutf8($_) } glob("$base/*");

            for my $file (@files) {
                # TODO pass an If object selector to 0->deaccum
                @{G.ways} = grep { _._wayfile ne $file } @{G.ways};
                $G->deaccum($G, wayfiles => $file);
                
                my ($w) = grep { _._wayfile eq $file } @{G.ways};

                my ($wn) = $file =~ /ghosts\/(.+)$/;
                $wn ||= $file;
                my $nw = $G->nw(name=>$wn);
                nw.A->umv('', 'way');
                $nw->load($file);

                say "G G.name w+ nw.name";
                push @{G.wayfiles}, $file;
                push @{G.ways}, $nw;
            }
            
            G.name =~ s/\+$name// && warn "no wayfiles from $name" || die
            unless @files; # ^ dies if was first way name
        }

        $G->_0('_load_ways_post', {w=>G.ways});
  - K: timer #c coming, going
    D: |
            my $time = shift || 0.001;
            my $doing = shift;
            my $st = " ".$_[0] if $_[0] && !ref $_[0];
            $st ||= "";
            my $last = $G->Flab("G Timer$st", @_);
            
            my $doings;
            $doings = sub { $G->comeback($last, $doings, $doing, @_); };
            Mojo::IOLoop->timer( $time, $doings );
            return $last
  - K: comeback
    D: |
            my $last = shift;
            my $doings = shift;
            my $doing = shift;
            my @saying = @{ $last->{thing} };
            $saying[0] =~ s/G Timer/G remiT/ || unshift @saying, "G remiT";
            my ($u, $s) = $G->waystacken(@saying, @_);
            $s->{doings} = $doings;
            $s->{timer_from} = $last;
            $last->{timer_back} = $s;
            eval { $doing->(); };
            # start serving code and stuff through H/0!
            $u->();
            if ($@) {
                $@ =~ s/^(!   )+Z\n//sgm;
                sayre(ind("Error ", $@));
            }
  - K: wayb #c # TODO way bending, other G stuff
    D: |
      my ($GG, $atu) = @_;
      my $suway = join "", map {"{$_"} split /\//, atu.way;
      G.R->loadup($atu, "{hooks$suway", $atu);
      
      
      push @{GG.ways}, $atu; # A etc
      
  - K: w #c
    style: nonbabble
    D: |
      my $point = shift; 
      my $ar = shift;
      my $Sway = shift;
      my @ways;

      die "What do you MEAN $G->{name} $point $ar $Sway !?  ".wdump($ar) if defined $ar && ref $ar ne "HASH";
      my $talk = "w $point";
      my $watch;

      if ($Sway) {
          $talk .= " S";
          if (ref $Sway eq 'Ghost' || ref $Sway eq "G") {
              @ways = $Sway->ways;
              $talk .= " G";
          }
          elsif (ref $Sway eq 'Way' || ref $Sway eq "C") {
              if ($Sway->{ofways}) {
                  @ways = @{$Sway->{ofways}};
              }
              elsif ($Sway->{Gw}) {
                  my $SG = $Sway->{G} || die "no Sway G!?";
                  my $CodeK = $Sway->{Gw};
                  $CodeK = $Sway->{K} if $CodeK eq "1";
                  $point = "$CodeK/$point" unless $point =~ /^$CodeK/;
                  if ($G eq $SG) {
                      @ways = $G->ways; # ------------------
                  }
                  else {
                      return $SG->w($point, $ar, $Sway); # G pass
                  }
              }
              else {
                  @ways = $Sway; #---------------------
              }
          }
          elsif (ref $Sway eq 'ARRAY') {
              die "NO MORE ARRAY WAYS --- $point ".slim(100,80,ki($ar))."\n"."$Sway - ".ki($Sway);
          }
          my $b = {};
          %$b = (%{$Sway->{B}}, B => $Sway->{B}) if $Sway->{B};
          $ar = {%$ar, %$b, S => $Sway};
          $ar->{S} = $G->{S} if $G->{S};
      }
      else {
          @ways = $G->ways;
      }

      my @returns;
      for my $w (@ways) {
      
          my $h = $w->find($point) || next;
          
          my $u = $G->waystacken(Z => "$talk", $G, $w, $Sway, bless {h=>$h}, 'h');
          my ($Z) = @F;
          my $a = {
              bab => $h,
            ar => $ar,
            point => $point,
            Sway => $Sway,
            w => $w,
            Z => $Z,
          };
          my $r;
          
          eval { $r = [ $G->D($a) ] };

          push @returns, $r;
          my $ZZ = $u->();
          die "MISM" unless $Z eq $ZZ;
          $Z->{Returns} = $r;

          if ($@) {
              my $ne = "Z";
              $ne .= $Z->{inter} if $Z->{inter};
              $ne .= "\n";
              $ne .= "S: ".ki($Sway)."\n" if $Sway;
              $ne .= "$@";
              $@ = $ne;
              $G->Flab("Z Error $@");
              die $@;
          }
      }
      unless (@returns) {
          $G->Flab("way miss $talk", \@ways, $Sway) if $G->deeby > 3;
      }
      return warn "Multiple returns from ".($point||'some?where')
                              if @returns > 1;    
      return
                              if @returns < 1;
      my @return = @{$returns[0]};
      if (wantarray) {
          return @return
      }
      else {
          my $one = shift @return;
          return $one;
      }
  - K: pyramid #c
    D: |
      my $thing = [@_];
      
      my $u;
      my ($last) = @F;
      $u = last.A->spawn('C') if $last;
      
      $u = G.A->spawn('C') if !$u;
      
      G.A->An($u, 'pyramid');
      G.A->An($u, 'pyramid_tip') if !$last;
      
      # TODO ^ set A u words to 'pyramid'
      
      my $stack = $H->stack(2,7);# short
      
      my $from; # FUZZ!
      if ($stack->[0] =~ /G::timer/) {
          $from = "time"
      }
      elsif ($stack->[1] =~ /G.+eval.+/
          && $stack->[2] =~ /G::doo/) {
          $from = "some doing..."
      }
      else {
          ($from) = $stack->[0] =~ / (\S+::\S+) /;
          $from =~ s/.*G::(Fl|wa).*/$1/ && do {
              $from =~ s/^wa$/_á£/ ||
              $from =~ s/^Fl$/á£œ_/
          }
          || $from =~ s/G::/G\:/;
      }
      my $dir = ($last ? "last.id>" : "").u.id;
      #say "pyra $dir $from  $thing->[0]";
      $from ||= "stackw\ $stack->[0]";
      shift @$stack;

      $u->from({
          K => "$from",
          G => $G,
          hitime => $H->hitime(),
          stack => $stack,
          Flab => [@Flab],
          F => [@F],
          depth => 0+@F,
          thing => $thing,
          print => 'S.name;',
      });
      $u->from({Error=>$@}) if $@;
      u.name = join " ", grep {defined $_} u.G.name, u.K, gpty(@{u.thing});
      $u
      
  - K: waystacken #c
    style: nonbabble
    D: |
            my $s = $G->pyramid(@_);
            push @{ $F[0]->{undies} ||= [] }, $s if @F;
            unshift @F, $s;
            $s->{F} = [@F],
            $G->ob("\\", $s);
            my $unway = sub {
                my @FF;
                if ($F[0] ne $s) {
                    my $E = "BATS ";
                    if (!grep {$_ eq $s} @F) {
                        $E .= "self nowhere in \@F"
                    }
                    else {
                        unshift @FF, shift @F until $FF[0] && $FF[0] eq $s || !@F;
                        $E .= " - from $_->{name}\n" for shift @FF;
                    }
                    $H->error(BATS => $G->Flab($E, $s, [[@FF], [@F]]));
                }
                else {
                    shift @F;
                }
                
                if ($@) {
                    #$G->Flab("Stack Return Error", $s, $@);
                    $s->{Error} = $@;
                }
                $s->{Flab} = [@Flab];
                
                if ($s->{_after_do}) {
                    $_->() for @{$s->{_after_do}};
                }
                
                my $te = $@; $@ = "";
                $G->ob("/", $s);
                $@ = $te;
                @Flab = ();
                $s
            };
            wantarray ? ($unway, $s) : $unway;

