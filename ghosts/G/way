Ds:
  - K: Flab #c
    D: |
        wish(G=>$G) || die "send G";
        
        # like sa*
        # throws up little con tent # F jointed sa*
        # also like di, has this db vector
        # for punching out with helpful quality
        
        say join("", "G.db + $db", ("_") x scalar(@F))."G.name  $_[0]"
            if $G->deeby && $_[0] !~ /^\w\ Error/;
            
        my $a;
        a.name = "f";
        a.stuff = [@_];
        a.igGA = 1;
        
        $G->pyramid($a);
  - K: fla #c
    D: |
        $F[0]->{G}->Flab(@_);
        

  - K: ways #c
    D: |
        grep { !$_->{_disabled} } @{$G->{ways}}
    
  - K: findway #c
    D: |
        my $point = shift;
        my @w = grep { defined $_ } map { $_->find($point) } $G->ways;
        wantarray ? @w : shift @w;
        
  - K: anyway #c
    D: |
        my $point = shift;
        my @a = grep { defined $_ } map { $_->find($point, 1) } $G->ways;
        wantarray ? @a : shift @a
        
  - K: load_ways #c
    D: |
        my @ways = @_;
        G.ways ||= [];
        G.wayfiles ||= [];
        G.load_ways_count++;

        my $ldw = [];
        while (defined( my $name = shift @ways )) {
            my @files;

            my $base = "ghosts/$name";
            push @files, $base if -f $base;
            push @files, grep { /\/\d+$/ }
                map { $H->fixutf8($_) } glob("$base/*");

            for my $file (@files) {
                # TODO pass an If object selector to 0->deaccum
                @{G.ways} = grep { _._wayfile ne $file } @{G.ways};
                $G->deaccum($G, wayfiles => $file);
                
                my ($w) = grep { _._wayfile eq $file } @{G.ways};

                my ($wn) = $file =~ /ghosts\/(.+)$/;
                $wn ||= $file;
                my $nw = $G->nw(name=>$wn);
                nw.A->umv('', 'way');
                $nw->load($file);

                say "G G.name w+ nw.name";
                push @{G.wayfiles}, $file;
                push @{G.ways}, $nw;
            }
            
            G.name =~ s/\+$name// && warn "no wayfiles from $name" || die
            unless @files; # ^ dies if was first way name
        }

        return $G->w("load_ways_post") if !$G0;
        
        $G0 w _load_ways_post(S=>$G,w=>G.ways);
  - K: u #c u, sway, Bu # 
    D: |
        my ($K, $s) = @_;
        0->sway({K=>$K}, $s);
  - K: sway #c
    D: |
        # sucks way matching $p # only supports matching K for now
        my ($p, $s, $P) = @_;
        my ($from) = p.from || 0->CsK($p);
        
        $from || defined P.e || die "no C: p.K (G.name)".wdump([$p,$s]);
        
        my $w = $G->nw();
        $w->from($from) if $from;
        $w->from($p) unless $from;
        $w->from($s) if $s && %$s; # merges in B :D
        
        return $w
  - K: Bu #c
    D: |
        my($K,$B)=@_;
        my $u = 0->sway({K=>$K},{B=>$B});
        my $a = {};
        $G w $u Bu_D[$a] if u.Gw || u.Bu_D;#opopopopop
        $u
  - K: CsK #c TODO C vortex reading # TODO
    D: |
        my ($p, $GG) = @_;
        $GG ||= $G;
        p.s ||= 'Cs C';
        my @topK = split ' ', delete p.s;
        my @Cs = map { flatline($_) } map { $GG->anyway($_) } @topK;
        @Cs = grep { 0->ip($p, $_) } @Cs if %$p;
        return wantarray ? @Cs : shift @Cs;
  - K: di #c
    style: func
    D: |
      # attaches meaning and dies
      
      # throwing back to D hopefully enriching
      
      # @_:
      #   bunch of vectors to topiarise the explotion
      #   bunch of data/messages
      
      my @vec;
      push @vec, shift while $_[0] =~ /^[\.\d]+$/;
      my $a = $F[0]->{di} = {};
      (a.mag, a.dir, a.etc) = @vec;
      a.tip = [@_];
      die @_;
      
      
      
      
  - K: Dm #c
    D: |
        my $a = shift;
        
        if (a.D) {
            die unless ref a.D eq "CODE";
            return ["???", a.D];
        }
        
        my $uuname = join " ",
            $G->{id},
            $H->dig(a.bab),
            a.point,
            " ar%".join(",",sort keys %{a.ar}),
        ;        
        my $ha = $H->dig($uuname);
        die unless length($ha) == 40;
            
        my $Ds = $D_cache{$ha};
        return $Ds if $Ds;
        
        my $eval = $G->parse_babble(a.bab, a.point);
        
        my $ar = a.ar || {};
        my $download = join("", map {
            'my$'.$_.'=$ar->{'.$_."}; "
            } keys %$ar)
            if %$ar;
        my $upload = join("", map {
            '$ar->{'.$_.'}=$'.$_."; "
            } keys %$ar)
            if %$ar;
          # there is
        my @warnings = ("no warnings 'experimental';");

        my $sub = "bollox";
        my $evs = 'sub { my $ar = shift; '.
        "@warnings $download\n".

        "my \@doo_return = (sub { \n\n$eval\n })->();\n"

        ."$upload"
        .'return @doo_return };';

        $sub = $G->Doe($evs, $ar);

        $Ds = [ $evs, $sub ];
        if (!$@ && ref $sub eq "CODE") {
            $D_cache{$ha} = $Ds;
        }
        else {
            a.bungeval = $evs;
        }
        $Ds
  - K: Doe #c
    D: |
      my $D_eval_string = shift;
      my $ar = shift;
      return eval $D_eval_string;
      
  - K: D #c
    D: |
            my $a;
            $a = shift;
            my $ar = a.ar || {};
            
            die "RECURSION ".@F if @F > $MAX_FCURSION; 
            
            # also a.D can be CODE, $Ds viv
            if (ref a.bab eq "C") {
                my $b = a.bab;
                die unless b.K eq "Disc";
                return b.G->w('D', a.ar, $b);
            }

            my $Ds = $G->Dm($a);
            my ($evs, $sub) = @$Ds; 
                
            # TODO rewayen
            a.name = "D";
            my $D = $G->Doming($a);
            
            my $komptalk = "nicht kompilieren! nicht kompilieren!\n $@" if $@;
            
            H.sigstackend ||= sub {
                local $@;
                eval { confess( '' ) };
                my @stack = split m/\n/, $@;
                shift @stack for 1..3; # hide above this sub, G eval & '  at G...';
                my @stackend;
                push @stackend, shift @stack until $stack[0] =~ /G::D/ || !@stack && die;
                s/\t//g for @stackend;

                # write on the train thats about to derail
                my $wall = $G::F[0]->{SigDieStack}||=[];

                push @$wall, \@stackend;
            };
            H.sigstackwa ||= sub {
                return 1 if $_[0] =~ /^Use of uninitialized value/;
                my @loc = caller(1);
                sayre join "\n", "warn from ".$F[0]->{G}->{name}
                    ."  way $F[0]->{point}"
                    ."       at line $loc[2] in $loc[1]:", @_;
                return 1;
            };
            my @return;
            if (ref $sub eq "CODE" && !$@) {
                local $SIG{__DIE__} = H.sigstackend;
                local $SIG{__WARN__} = H.sigstackwa;
                eval { @return = $sub->(a.ar) }
            }
            
            $G->Done($D); #c D
            D.r = [@return];
            
            if ($@) { #     DOO DOO # # TODO di, 0ish
                my ($x) = $@ =~ /line (\d+)/;
                $x = $1 if $@ =~ /syntax error .+ line (\d+), near/;
                my $file = $1 if $@ =~ /at (\S+) line/;
                undef $file if $file && $file =~ /\(eval \d+\)/;
                undef $file if $file && !-f $file;
                my $perl = $H->slurp($file) if $file;
                $perl ||= $evs;
                
                my $eval = "";
                $eval .= "$file\n" if $file;
                my @eval = split "\n", $perl;
                my $xx = 0;
                $x -= 3 if $x;
                shift @eval for 1..3;
                pop @eval for 1..3;
                my $whole = @eval < 20;
                for (@eval) {
                    $xx++;
                    
                        if (!defined $x) {
                            $eval .= ind("⊘  ", $_)."\n"
                        }
                        elsif ($xx == $x) {
                            $eval .= ind("⊘  ", $_)."\n";
                            my $bab = (split"\n",a.bab)[$x -1];
                            if ($bab ne $_) {
                                $eval .= ind("⊖r ", $bab)."\n";
                            }
                        }
                        elsif (!$whole && $xx > $x-5 && $xx < $x+5) {
                            $eval .= ind("|  ", $_)."\n"
                        }
                        elsif ($whole) {
                            $eval .= ind("|  ", $_)."\n"
                        }
                }
                my $DOOF; 
                my $first = 1 unless $@ =~ /DOOF/;
                
                $DOOF .= "DOOF ".sprintf("%-24s",
                    $G->{name}." ".(ar.S ? "S=".gpty(ar.S) :"")
                );
                $DOOF .= " w"." a.point  ".join(", ", keys %$ar)."\n";;
                if ($first) {
                    if (exists $D->{SigDieStack}) {
                        warn "MALTY SIGGI" if @{$D->{SigDieStack}} > 1;
                        $DOOF .= "\n";
                        my $i = "  ";
                        for my $s ( reverse flatline($D->{SigDieStack}) ) {
                            $DOOF .= "$i- $s\n";
                            $i .= "  ";
                        }
                    }        
                    $DOOF .= "\n$eval\n";
                }
                $DOOF .= ind("E    ", "\n$komptalk$@\n\n")."\n\n"     if $first;
                $DOOF .= ind("!   ", "$@")."\n"             if !$first;
                $DOOF .= ind("ar  ",wdump(1,$ar))             if $first;
                
                my $OOF = $G->Flab("D Error $@", $DOOF, $D);
                if ($first) {
                    #$H->error($OOF);
                }
                $D->{Error} = $DOOF;
                $@ = $DOOF;
                die "$@";
            }
            
            return wantarray ? @return : shift @return
  - K: Doming #c
    D: |
        my $a = shift;
        die if @_;
        
        my $s = $G->pyramid($a);

        unshift @F, $s;
        s.F = [@F];

        return $s;
  - K: Done #c
    D: |
        my $D = shift;
        sayre join"", ("BATS  ")x 23 if $F[0] ne $D;
        D.Error = $@ if $@;
        
        $_->() for @{D._after_do||[]};
        
        @Flab = ();
        shift @F;
        
        $D
  - K: timer #c coming, going
    D: |
            my $time = shift || 0.001;
            my $D = shift;
            
            my $a;
            a.name = "t";
            a.time = $time;
            a.D = $D; # maybe sub or Disc like thing
            a.stuff = [@_];
            my $Dome = $G->Doming($a);
            
            Mojo::IOLoop->timer($time, sub {
                $G->comeback($Dome);
            });
            
            $G->Done($Dome);
            
            return $Dome;
  - K: para #c
    D: |
        die "install it";
        # TODO get better paraphernalia
        # ram and cpus
        # new OS to get latest mojo things working in
        # such as this and Mojo::Redis2 for better eventing of sub
        my $fc = Mojo::IOLoop::ForkCall->new;
        $fc->run(
           sub {},
           ['arg', 'list'], 
           sub { my ($fc, $err, @return) = @_; ... }
        );
  - K: comeback #c
    D: |
        my $Dome = shift;
        
        my $a;
        a.name = 'r';
        a.from = $Dome;
        my $Doing = $G->Doming($a);
        
        $G->D({D=>Dome.D, toplevel=>1});
        
        $G->Done($Doing);
        
        sayre $@ if $@; # TODO toplevely
        $@ = "";
        
  - K: waystacken #c # TODO going in favour of flablessness, Rish sa*
    style: nonbabble
    D: |
            my $s = $G->pyramid(@_);
            push @{ $F[0]->{undies} ||= [] }, $s if @F;
            unshift @F, $s;
            $s->{F} = [@F],
            $G->ob("\\", $s);
            my $unway = sub {
                my @FF;
                if ($F[0] ne $s) {
                    my $E = "BATS ";
                    if (!grep {$_ eq $s} @F) {
                        $E .= "self nowhere in \@F"
                    }
                    else {
                        unshift @FF, shift @F until $FF[0] && $FF[0] eq $s || !@F;
                        $E .= " - from $_->{name}\n" for shift @FF;
                    }
                    $H->error(BATS => $G->Flab($E, $s, [[@FF], [@F]]));
                }
                else {
                    shift @F;
                }
                
                if ($@) {
                    #$G->Flab("Stack Return Error", $s, $@);
                    $s->{Error} = $@;
                }
                $s->{Flab} = [@Flab];
                
                if ($s->{_after_do}) {
                    $_->() for @{$s->{_after_do}};
                }
                
                my $te = $@; $@ = "";
                $G->ob("/", $s);
                $@ = $te;
                @Flab = ();
                $s
            };
            wantarray ? ($unway, $s) : $unway;
  - K: nw #c G ways
    D: |
      my $C = G.A->spawn('C');  
      
      $C->from({@_}) if @_;
      # etc
      $C 
      
  - K: wayb #c TODO way bending, other G stuff
    D: |
      my ($GG, $atu) = @_;
      
      atu.way || die "needs a way".wdump($atu);
      
      my $suway = join "", map {"{$_"} split /\//, atu.way;
      
      G.R->loadup($atu, "{hooks$suway", $atu);
      
      push @{GG.ways}, $atu; # A etc
      # A drop old G+K+name
      # replay dep on perc state of origin $G
      
  - K: w #c
    D: |
      my $point = shift; 
      my $ar = shift;
      my $S = shift; # some kinda C subject
      my $a = shift;
      my @ways;
      
      die wdump($ar) if $ar && ref $ar ne 'HASH';
      
      my $talk = "w\ $point";
      my $watch;

      if ($S) {
          $talk .= " S";
          if (ref $S eq "G") {
              $talk .= " G";
          }
          elsif (ref $S eq "C") {
              if (my $of = S.ofways) { # TODO 
                  @ways = @$of;
              }
              elsif (S.Gw) {
                  my $SG = S.G || die "no way G!?";
                  my $CodeK = S.Gw;
                  $CodeK = S.K if $CodeK eq "1";
                  $point = "$CodeK/$point" unless $point =~ /^$CodeK/;
                  if ($G eq $SG) {
                      @ways = $G->ways; # ------------------
                  }
                  else {
                      return $SG->w($point, $ar, $S); # G pass
                  }
              }
              else {
                  @ways = $S; #---------------------
              }
          }
          
          if (my $B = S.B) {
              # we dont upload variables from B
              # change B.whatever to set
              # good verboz code clarity for scheming
              %$ar = (%$ar, %$B, B => $B);
          }
          ar.S = $S;
      }
      else {
          @ways = $G->ways;
      }

      my $l = [];
      for my $w (@ways) {
      
          my $h = $w->find($point) || next;
          
          my $a = {
            name => "Z",
            stuff => [$talk],
            bab => $h,
            ar => $ar,
            point => $point,
            way => $S,
          };
          a.w = $w;
          
          my $Z = $G->Doming($a);
          
          Z.l = $l;
          push @$l, $Z;
          
          my $r;
          
          eval { $r = [ $G->D($a) ] };

          Z.r = $r;
          
          $G->Done($Z);

          if ($@) {
              my $ne = "Z";
              $ne .= Z.inter if Z.inter;
              $ne .= "\n";
              $ne .= "S: ".ki($S)."\n" if $S;
              $ne .= "$@";
              $@ = $ne;
              $G->Flab("Z Error $@");
              die $@ unless a.nodie;
              $@ = "";
          }
      }
      
      if (!@$l) {
          $G->Flab("way miss $talk", \@ways, $S) if $G->deeby > 3;
          return;
      }
      
      if (@$l > 1) {
            warn "multiple returns from $point";
      }
      
      my ($z) = @$l;
      my @r = @{z.r};
      return wantarray ? @r : shift @r;
  - K: pyramid #c
    D: |
      my $a = shift;
      
      my ($last) = @F;
      # spawn the shadows of actions
      # could want more complexity per G
      # A hooks?
      my $u = last.A->spawn('C') if $last;
      $u ||= G.A->spawn('C');
      u.G = $G if $G ne u.G;
      
      confess "Ba" if !ref $a;
      
      $u->from($a);
      u.K = u.name || die;
      u.K .= 'ᣝ';
      u.hitime = $H->hitime();
      u.stack = $H->stack(2,7);
      u.F = [@F];
      u.depth = 0+@F;
      u.Error = $@ if $@; #?
      
      G.A->An($u, 'pyramid');
      G.A->An($u, 'pyramid_tip') if !$last;
      
      $u
      

