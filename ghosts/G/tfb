Ds:


  - K: Bu #c
    D: |
        my($K,$B)=@_;
        my $u = 0->sway({K=>$K},{B=>$B});
        my $a = {};
        $G w $u Bu_D[$a] if u.Gw || u.Bu_D;#opopopopop
        $u
  - K: TafuBl #c TafuBl, TafuB, TB, Tafu, Taful
    D: |
        #STICKSSTICKSSTICKSSTICKSSTICKSSTICKSSTICKSSTICKSSTICKSSTICKS
        0->l( 0->TafuB(@_) );
  - K: TafuB #c
    D: |
        my($K,$B)=@_;
        my $ca = $G->W->{ca}->{K}->{$K}->{B_ki}->{ki($B)};
        if ($ca && !ca.dead) {
            return $ca;
        }
        0->Tafu(0->Bu($K, $B))
  - K: TB #c
    D: |
        my ($K, $B) = @_;
        my $u = 0->Bu($K, $B);
        0->T({i=>$u});
  - K: Tafu #c
    D: |
        my($uu)=@_;
        0->fu($uu) || 0->T({i => $uu});
  - K: Taful #c
    D: |
        my($uu)=@_;
        0->l( 0->Tafu($uu) );
  - K: visTp_TafuBlA #c
    D: |
        my ($Tp, $Bup, $A) = @_;
        my $old = 0->visTp($Tp); # could be Fun, wire into end
        my $uu = 0->Bu(@$Bup); 
        my $u = 0->fu($uu);
        
        A.old ||= [] if $A;
        A.new ||= [] if $A;
        if ($u) {
            push @{A.old}, $u if $A;
        }
        else {
            push @{A.new}, $u if $A;
            $u = 0->T({i => $uu});
        }
        
        0->l($u);
        $T= $old;
        $u;
  - K: visTp_l_u #c
    D: |
        my ($Tp, $u) = @_; # get in to a T place and make links
        my $old = 0->visTp($Tp);
        0->l($u);
        $T= $old;
        $u;
  - K: visTp_TafuBl # get in Tp,  #c
    D: |
        my ($Tp, $Bp) = @_;
        my $old = 0->visTp($Tp);
        my $u = 0->TafuBl(@$Bp);
        $T= $old;
        $u;
  - K: visTp #c
    D: |
        my ($p, $fun) = @_;
        
        # are in Ghost right now?
        my $tish = $T && (ref $T eq 'Way' || ref $T eq 'C');
        my $old = $T;
        if (!$tish) {
            $T = $G->nw();
        }
        elsif (T.G ne $G) {
            # loses hair? we never care?
            $T = $G->nw();
        }
        else {
            $T = $G->nw();
        }
        T.A->umv('' => 'Tp');
        
        $p = {i=>$p} if ref $p =~ /^(Way|C)$/;
        my $moved = p.i || p.L;
        if ($moved) {
            delete $T->{$_} for qw'i L t o';
        }
        
        $T->from($p);
        
        T.i ||= T.L.i;
        T.L ||= T.i.Li;
        T.t ||= T.L.t;
        T.o ||= T.L.o;
        T.o ||= [];
        
        T.print = '"Tp = ".S'.'.i->pi;';
        
        if ($old) {
            T._T = $old;
            #push @{old.T_||=[]}, $T;
        }
        if (my $r = T.r) {
            if ($moved && r.ih->{T.i.id} && r.noo) {
                # recursion q factor # can rebraid things to go on forever etc.
                die "not allowed circular travel, "
                    .sw({here_before => $T});
            }
            $r = T.r = {%$r};
            r.ih = {%{r.ih||{}}};
            r.is = [@{r.is||[]}, T.i];
            r.ih->{T.i.id} = $T;
        }
        
        if (ref $fun eq "CODE") {
            return $fun->();
            $T = $old;
        }
        elsif ($fun eq "Fun") {
            push @{ $F[0]->{_after_do} }, sub {
                $T = $old;
            }
        }
        return $old;
  - K: l # draw arcs #c
    D: |
        die "HERE";
        my ($n) = @_;
        my $u = T.i; # up;
        $G->L($n, $u);
        0->accum($n, 'Lo', T.L);
        0->accum($T, 'o', $n);
        $n;
  - K: L #c
    D: |
      die "HERE";
      my ($n, $u) = @_;
      u.A->An($n);
      n.A->Au($u);
      
  - K: scGre #c TODO A sess # scGre, rei, ei
    D: |
        my ($ip) = @_;
        # or something was somehow, tractioning v
        my @a = grep { 0->ip($ip, _.i) } @{ G.W.script };
        @a
  - K: rei #c
    D: |
        my ($ip) = @_;
        map {_.i} 0->scGre($ip);
  - K: ei #c
    D: |
        my $ip = {};
        ip.K = shift; # lookup BcS for more, we could want to create
        map {_.i} 0->scGre($ip);
  - K: fu #c TODO A sess
    D: |
        my $u = shift;
        
        my $fo = $G->W->{ca}->{K}->{u.K}->{B_ki}->{ki(u.B)};
        if ($fo && fo.dead) {
            say "u.K found but dead";
            $fo = undef;
        }
        return $fo if $fo;
        
        for my $LL (@{$G->W->{script}}) {
            my $i = LL.i;
            my $yup = $i eq $u
                || (!exists u.K || i.K eq u.K)
                && 0->B_same($u => $i);
            if ($yup) {
               say "found i.K in script";
                return $i;
            }
        }
        return undef;
  - K: fu_cache
    D: |
        my $u = shift;
        u.B ||= {};
        $G->W->{ca}->{K}->{u.K}->{B_ki}->{ki(u.B)} = $u;
  - K: T #c
    D: |
        my ($p) = @_;
        die "hi";
        
        # 1/9
        
        my $giu = T.i;
        my $old = 0->visTp($p); # 1
        die "no old!".wdump($T) if !$old;
        T.i || die " no way in! ".wdump($p);
        
        0->fu_cache(T.i);
        
        # set up this dimension - allele tower
        # maths stapler - clown shoes - RNA
        
        my $beg = T.i;
        my $sge = sub {
            die "Lost i somewhere before ".shift."... "
            .wdump(2, [$beg, T.i]) unless T.i eq $beg;
        };
        G.A->An($beg, 'T0');
        
        # 2/9
        
        say "HAUNT HAUNT HAUNT ".T.i->pi if $G->deeby;
        #$G0->{travels_of}->{$G->{name}} ++;
        $G->ob("haunt");
        # so crawl is like an expanding awareness thing
        # see the whole structure
        
        # 3/9
         $G->w("T/flows");
           $G->w('flows_D', {}, T.i);
        #$G->Flab("flows ", $T);
          $sge->("flows");
          
        # 4/9
        T.L = $G->W->continues($G); # %
        
          $sge->("humms W being"); # eg travelling sw eval
        G.W.A->An(T.i, 'humm');
         $G->w("T/humms");
           $G->w('humms_D', {}, T.i);
        #$G->Flab("humms", $T);
          $sge->("humms");
          
        # 5/9
        T.L.i eq T.i || die "5 eye swamp gone wrong".sw($T);
        0->accum(T.L.i, 'Li', T.L); # just right
        
         $G->w("T/links", {u=>T.i});
           $G->w('links_D', {}, T.i);
        #$G->Flab("links", $T);
          $sge->("links");
        # rounds_D? replayable when recoded?
        # assume 6/7 will continue the process...
        # 6/9
         $G->w("T/travels");
           $G->w('travels_D', {}, T.i);
        #$G->Flab("travels", $T);
          $sge->("travels");
        die "Lost i somewhere before 7... "
        .wdump(2, [$beg, T.i])unless T.i eq $beg;
        
        # 7/9
        
        $G->w("T/traction", {u=>T.i});
        $G->w('traction_D', {}, T.i);
        #$G->Flab("travels", $T);
          $sge->("travels");
        
        # 8/9
        
        #Info "HAUNTED ".sw($T) if $G->{name} =~ /braid|ux|odon/;
        
        # 9/9
        
        die "Lost i somewhere before 9... "
        .wdump(2, [$beg, T.i])unless T.i eq $beg;
        
        my $L = T.L;
        $T = $old;
        die "dumb".wdump([$T, $old, $giu]) unless T.i eq $giu;
        return L.i;
  - K: Ato #c
    D: |
        my ($w, $to) = @_;
        grep { _.K =~ /^$to$/ } @{w.Li.o}
  - K: RW #c
    D: |
        my ($GG) = @_;
        say "RW RW RW RW RW GG.name\t\t GG.K";
        _.dead = $F[0] for 0->rei($GG, {});
        my $W = GG.W;
        delete GG.Vu; # vortex will start over
        my $deadscript = W.script;
        W.script = [];
        W.n = 0;
        delete W.ca;
        $deadscript;
  - K: delfrom #c
    D: |
        my ($u) = @_;
        for my $uu (0->Io($u)) {
            0->del($uu);
        }
  - K: del #c
    D: |
        my ($u) = @_;
        my $L = u.Li || die "wasnt";
        #say "deleting ".$u->pint;
        $G->w('v/ch'=>{u=>$u});

        0->deaccum(u.Lo, 'o', $u);
        0->deaccum(u.Li.W, 'script', $L);
        u.dead = 1;

        0->del($_) for @{u.Li.o};
    
  - K: Io #c
    D: |
        my ($u) = @_;
        grep { _.G eq $G } @{u.Li.o};

