
name: Ghost

hooks:
  recoded_init: | # G/0 recode
    #H.G->w('reexec'); #DANG
  _load_ways_post: | # G/0 manages some other G's way startup ripples
    $S->w("load_ways_post");
    $G->Flab("$S->{name} +$S->{load_ways_count}+   ".
        join" , ", map { $_->{_wayfile} } @$w);
    
    if (S.load_ways_count == 1) {
        w _init/fresh;
    }
    else {
        w _init/recoded;
    }
      
    $S->w("any_init");
    
  _init:
    recoded: |
        say "Recode calles ".@{G.recoded_cbs};
        for my $cb (@{G.recoded_cbs}) {
            $G->timer(0.1, sub { say "Balllgej!"; $cb->($S) });
        }
        
        w _init/wayrays[$S];
        
        w _init/recoded_Cways[$S] if $S->anyway('recoded_Cways');
        
        $S->w("recoded_init");
        
        w _init/recoded_care_parents[$S];
        
    recoded_Cways: | # TODO reinject
      for my $i (map {_.i} G.U.scGre->($S)) {
          my $up = G.U.CsK->($S,{K=>i.K});
          $i->from($up);
      }
        
    fresh: |
      w _init/keys[$S];
      
      w _init/GG[$S];
      
      w _init/wayrays[$S];
      
      $S->w("fresh_init");

    wayrays: |
      for my $s (qw'S C') { # C too?
          if (my $ws = $S->anyway($s)) {
              0->wayray($ws, $S);
          }
      }
      
    GG: |
      my $GGs = $S->anyway('GG');
      return unless $GGs;
      for my $GG (@$GGs) {
          my $way = GG.way || GG.K;
          my $g = S.GG->{GG.K} || $H->TT($S)->G($way);
          $g || die "no $way? GG $way from S.name = GG.K";
          g.K = GG.K;
          S.GG->{g.K} = $g;
          0S->InjC($g, GG.In) if GG.In;
      }
      
    keys: |
      return unless $S->findway("keys");
      if (my $keys = G:keys) {
          push @{keys.subs}, $S unless
            grep {$_ eq $S} @{keys.subs};
      }
      else {
          sayre "G L Waiting for G keys";
          $G->timer(0.5 => sub { w keyub[$S]; });
      } 
  _gitdission: |
    my $ghosts = H.h ? H.G.GGs : $H->data->{Ghost};
    sayyl "0 0 0 dission fo ".join" ", keys %$Gd;
    my @rG;
    for my $S (@$ghosts) {
        my $in = [grep{$Gd->{$_}} @{S.wayfiles}];
        next unless @$in;
        push @rG, $S;
        # sort stream to avoid small before big?
        waylay recode_ways[$S, $in];
    }
    say " Recoded: ".join"\t\t", map { $_->pi } @rG;
  recode_ways: |
    sayyl "recoding S.id S.name";
    eval {
        $S->load_ways(split /\+/, S.way); # TODO all ways on any recoded or..?
    };
    if ($@) {
        Err "Load ways fuckup: $@";
        return $@ = "";
    }
    say "S.name !  ! ! ! S.id recoded  S.way, intersects git diffage at:";
    say " - $_" for @$in; 
        
        
  any_init: |
    G.recoded_cbs||=[];

