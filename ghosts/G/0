
name: Ghost
hooks:
  _load_ways_post: |
    $S->w("load_ways_post");
    $G->Flab("$S->{name} +$S->{load_ways_count}+   ".
        join" , ", map { $_->{_wayfile} } @$w);
    
    w _fresh_init if $S->{load_ways_count} == 1;
    w _recoded_init if $S->{load_ways_count} != 1;
    $S->w("any_init");
    
  _recoded_init: |
    $S->w("recoded_init");
    my $g = $S;
    while ($g->{O} && ref $g->{O} eq "Ghost") {
        $g->w("child_recoded_init", {S => $S}) if $g eq $S;
        $g = $g->{O};
        $g->w("any_child_recoded_init", {S => $S});
    }
  _fresh_init: |
    $G->{S} = $S;
    say "init for $S->{name}";
    w V/init[$S];
    w include_init[$S];
    w GG_init[$S];
    $S->w("fresh_init");
  V: 
    spawn: |
      my $V;
      my $style = w styles[$S, $styles];
      if ($ar->{from}) {
          $V = $from->spawn_floozy($S, $name, $style);
      }
      else {
          $V = View->new($H->intro, $S,  $name, $style);
      }
      $S->{V}->{$name} = $V;
      
    init: |
      for my $V ($S->findway('V')) {
          my $from = $S->{floozal} || $H->{sky};
          while (my ($name, $t) = each %$V) {
                my $styles = $t->{styles};
                w V/spawn[$S, $name, $styles, $from];
          }
      }
    blur: |
      my $blur = ++$G->{_blur} % 2 ? 'blur(8px) brightness(0.7)' : '';
      $H->JS($_, "css('-webkit-filter', '$blur');") for values %{G.V};

    toginvis: |
      $_->togcl('invis') for values %{G.V};
      
  GG_init: |
    my $GG = $S->findway("GG");
    while (my ($way, $t) = each %$GG) {
        my $GG = $H->TT($S)->G($way);
    }
  include_init: |
    for my $include ($S->anyway('include')) {
        for my $in (split ' ', $include) {
            next if grep { $_->{_wayfile} =~ /$in/ } $S->ways;
            $S->{load_ways_count}--;
            $S->load_ways($in);
        }
    }
  styles: |
    my @styles;
    for my $style (split ' ', $styles) {
          push @styles, w style[$S, $style];
    }
    join ' ', @styles;
  style: |
    join "", map { /;$/ ? $_ : "$_;" } $S->w("styles/$style")
  sing: |
    $G->{singing} ||= {};
    return say "$name BLOCKED" if $G->{singing}->{$name} && $G->{singing}->{$name}++; # ignore sing until...
    $G->{singing}->{$name} = 1;
    my $t = $ar->{block_for} || $ar->{again_after} || 0.04;
    my $d = $ar->{begin_after} || 0.001;
    $G->timer($d, sub {
        $G->timer($t, sub {
            my $splatter = delete $G->{singing}->{$name};
            if ($splatter > 1 && $ar->{again_after}) {
                $S->Flab("Sig reps $splatter... "
                    .($ar->{again_after} ? "again!" : ".")
                    ."  $name");
                w sing(%$ar);
            }
        }, "sing-block        $name");
        $G->{singing}->{$name} = 1;
        $code->();
    }, "pre-sing     $name");
    
    

