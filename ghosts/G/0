
name: Ghost
hooks:
  _load_ways_post: |
    $S->w("load_ways_post");
    $G->Flab("$S->{name} +$S->{load_ways_count}+   ".
        join" , ", map { $_->{_wayfile} } @$w);
    
    w _fresh_init if $S->{load_ways_count} == 1;
    w _recoded_init if $S->{load_ways_count} != 1;
    $S->w("any_init");
    
  _recoded_init: |
    $S->w("recoded_init");
    my $g = $S;
    while ($g->{O} && ref $g->{O} eq "Ghost") {
        $g->w("child_recoded_init", {S => $S}) if $g eq $S;
        $g = $g->{O};
        $g->w("any_child_recoded_init", {S => $S});
    }
  _fresh_init: |
    $G->{S} = $S;
    say "init for $S->{name}";
    w V/init[$S];
    w GG_init[$S];
    $S->w("fresh_init");
  any_init: |
    G.U.sing = sub {#c
        my $S = shift;
        my $p;
        p.name = shift;
        p.code = shift;
        $p = {%$p, @_};
        p.again = 0.5 if !defined p.again;
        p.begin = 0.2 if !defined p.begin;
        w sing(%$p);
    };
    G.U.loquate = sub {#c
        my ($S, $source, $path, $def) = @_;
        my @moves = split '/', $path;
        my $s = $source;
        until (@moves == 1) {
            my $m = shift @moves;
            $s = $s->{$m};
        }
        my $m = shift @moves;
        my $thing = $s->{$m} ||= $def;
        !ref $thing && die "Oh no! $path led to non-ref $thing from $source";
        return $thing;
    };
    G.U.accum = sub {#c # TODO path loquation doesn't stretch far re policy, no prob for now.
        my ($S, $source, $ac, $t) = @_;
                
        if ($ac eq "Lo" || $ac eq "Li") {
            $source->{$ac} = $t;
            return;
        }
        
        my $a = 0S->loquate($source, $ac, []);

        if (!grep { $_ eq $t } @$a) {
            push @$a, $t
        }
    };
    G.U.deaccum = sub {#c
        my ($S, $source, $ac, $t) = @_;
        my $a = $source->{$ac} ||= [];
        my $i = 0;
        for (@$a) {
            return splice(@$a, $i, 1) if $_ eq $t;
            $i++;
        }
    };
    G.U.wdif = sub {#c
        my ($S, $h, $w) = @_;
        if ($w->{$h}) {
            $S->w($h, {}, $w);
            delete $w->{$h};
        }
    };
    G.U.sway = sub {#c # sucks way matching $p # only supports matching K for now
        my ($S, $p, $s) = @_;
        
        p.CsK ||= 'chains C';
        my $from;
        ($from) = 0S->CsK($p);
        $from || die "no findo way called p.K (S.name)".wdump($p);
        
        my $w = $S->nw();
        $w->from($from);
        $w->from($s) if $s && %$s; # merges in B
        
        return $w
    };
    G.U.CsK = sub {#c # sucks way from space
        my ($S, $p) = @_;
        
        # p.CsK locates the Cs
        #   qw paths for anyway
        # p.K maybe greps the Cs for p.K
        p.CsK || die "pass p.CsK to CsK"; # not sposed $p
        
        my @Cs = map { flatline($_) } map { $S->anyway($_) }  split ' ', delete p.CsK;
        
        if (p.K) {
            @Cs = grep { _.K eq p.K } @Cs;
        }
        die "more p to CsK".sw($p) if !p.K || 1 < keys(%$p);
        
        
        return @Cs;
    };
    G.U.TafuBl = sub {#c # slightly travel this kinda u
        my $S = shift;
        my $u = 0S->TafuB(@_);
        u.Li || die "no u Li ".wdump(2,$u);
        0S->l($u);
        $u
    };
    G.U.TafuB = sub {#c # lightly travel or retract this kinda u
        my $S = shift;
        my $p = { K => shift };
        my $s = { B => shift };
        my $uu = 0S->sway($p, $s);
        0S->Tafu($uu);
    };
    G.U.Tafu = sub {#c
        my ($S, $uu) = @_;
        my $u = 0S->fu($uu);
        return $u if $u;
        0S->T({i => $uu});
        return $uu
    };
    G.U.Taful = sub {#c # slightly travel this u
        my ($S, $uu) = @_;
        my $u = 0S->Tafu($uu);
        u.Li || die "no u Li Taful ".wdump(2,$u);
        0S->l($u);
        $u
    };
    G.U.visTp_l_u = sub {#c get in to a Tp and l u
        my ($S, $Tp, $u) = @_;
        my $old = 0S->visTp($Tp);
        0S->l($u);
        $T= $old;
        $u;
    };
    G.U.l = sub {#c draw arcs
        my ($S, $u) = @_;
        0S->accum($u, 'Lo', T.L);
        0S->accum($T, 'o', $u);
    };
    G.U.visTp_TafuBl = sub {#c # get in Tp, 
        my ($S, $Tp, $Bp) = @_;
        my $old = 0S->visTp($Tp);
        my $u = 0S->TafuBl(@$Bp);
        $T= $old;
        $u;
    };
    G.U.T= sub {#c
        my ($S, $p) = @_;
        my $old = 0S->visTp($p);
        
        say "HAUNT HAUNT HAUNT ".pint(T.i);
        0S->haunt_swoop();
        
        0S->haunt_wooo();
        
        my $L = T.L;
        $T = $old;
        return $L;
    };
    G.U.visTp= sub { #c
        my ($S, $p, $fun) = @_;
        
        my $old;
        if ($T && ref $T eq "Way") {
            $old = $T;
        }
        else {
            warn "T was ".wdump(2,$T);
            $T = $S->nw();
        }
        
        $T = $T->spawn;
        
        my $moved = p.i || p.L;
        if ($moved) {
            delete $T->{$_} for qw'i L t o';
        }
        
        $T->from($p);
        
        T.i ||= T.L.i;
        T.L ||= T.i.Li;
        T.t ||= T.L.t;
        T.o ||= T.L.o;
        T.o ||= [];
        
        if ($old) {
            T._T = $old;
            
            push @{old.T_||=[]}, $T;
            
            if (old.i.T_remembers_last) {
                T._last->{old.i.K} = old.i;
            }
        }
        
        if (my $t = T._trail) {
            $t = T._trail = {%$t};
            t.i = [@{t.i||[]}, T.i];
            t.ih = {%{t.ih||{}}};
            if ($moved && t.ih->{T.i.id}) {
                # here before
                if (t._no_circles) {
                    die "not allowed circular travel, "
                        .sw({here_before => T.i,T=>$T});
                }
            }
            t.ih->{T.i.id} = $T;
        }
        
        # backwards compat
        $S->{$_} = $T->{$_} for qw'i L t o';
        
        if ($fun eq "Fun") {
            push @{ $F[0]->{_after_do} }, sub { $T = $old }
        }
        return $old;
    };
    G.U.haunt = sub {#c
        my $S = shift;
        my $Travel = shift;
        my $t = {
            depth => shift,
            t => shift,
            i => shift,
            o => [],
            _Travel => $Travel, # non
        };
        say " 0 haunt  d=t.depth   i=".pint(t.i)."   t=t.t";
        my $L = 0S->T($t);
        return @{L.i.returns} if L.i.returns;
        return $L;
    };
    G.U.haunt_swoop = sub {#c
        my $S = shift;
        my $i = T.i;
        $S->ob("haunt");
        $S->w("T_begin");
        
        $S->w("arr") unless T._noarr;
        # ow
        $S->doo(i.flows_D, {}) if i.flows_D;
        
        # all this stuff is shaking
        # catch a braid
        T.L = $S->W->continues($S); # %
        $S->ob("continues...", T.L);
        
        T.L.i eq T.i || die "tli not ni!?!?!";
        
        # [o  get Lo = L
        0S->accum($_, 'Lo', T.L) for @{T.L.o};
        0S->accum(T.L.i, 'Li', T.L); # just right
    };
    G.U.haunt_wooo = sub {#c
        my $S = shift;
        my $R = [T.L];
        for my $c (@{T.o}) {
            if (exists c.travel_this) {
                T._Travel->T(c.travel_this, $S, $c, T.depth+1);
            }
            elsif (exists c.travel) {
                T._Travel->T(c.travel, $S, $c, T.depth+1);
                delete c.travel if !defined c.travel;
            }
            elsif (exists c.arr_returns) { # ded?
                $R = c.arr_returns;
            }
            elsif (exists c.travels) {
                0S->T($S, {i => $c});
            }
            elsif (exists c.B.s || exists c.O) {
                # sweet
            }
            else {
                Say "what kind of way out is
                S.name \n".wdump(2,$c);
            }
        }
        
        $S->doo(T.i.extract_D, {}) if T.i.extract_D;
        
        $S->w("T_end", {L=>T.L, r=>$R});
        T.i.returns = $R;
    };
    
    G.U.fu = sub {#c
        my $S = shift;
        my $u = shift;
        for my $LL (@{$S->W->{script}}) {
            my $i = LL.i;
            if ($i eq $u || (!exists u.K || i.K eq u.K) && 0S->B_same($u => $i)) {
                return $i;
            }
        }
        return undef;
    };
    G.U.B_same = sub {#c
        my ($S, $u, $i) = @_;
        
        return 1 if exists u.B._ && exists i.B._ && u.B._ eq i.B._;
        
        my @ks = keys %{u.B};
        for my $k (@ks) {
            u.B->{$k} eq i.B->{$k} || return 0;
            next if $k eq "Codon";
        }
            $G->timer(2,sub {
            Say " u has no B, mind  you...".ki($u);
            }) unless keys %{u.B};
        return 1;
    };
    
    
    
  V: 
    spawn: |
      my $V;
      my $style = $S->styles($styles);
      if (ar.from) {
          $V = ar.from->spawn_floozy($S, $name, $style);
      }
      else {
          $V = View->new($H->intro, $S,  $name, $style);
      }
      S.V->{$name} = $V;
      
    init: |
      for my $V ($S->findway('V')) {
          my $from = $S->{floozal} || $H->{sky};
          while (my ($name, $t) = each %$V) {
                my $styles = $t->{styles};
                w V/spawn[$S, $name, $styles, $from];
          }
      }
    blur: |
      my $blur = ++$S->{_blur} % 2 ? 'blur(8px) brightness(0.7)' : '';
      $H->JS($_, "css('-webkit-filter', '$blur');") for values %{S.V};

    toginvis: |
      my @Vs = values %{S.V};
      if (ar.k) {
            @Vs = grep { defined } S.V->{ar.k}
      }
      
      $_->togcl('invis') for @Vs;
      
  GG_init: |
    my $GG = $S->findway("GG");
    while (my ($way, $t) = each %$GG) {
        my $GG = $H->TT($S)->G($way);
    }
  sing: |
    G.singing ||= {};
    return say "\t\t\t\t $name BLOCKED"
        if G.singing->{$name}
            && G.singing->{$name}++; # ignore sing until...
    G.singing->{$name} = 1;
    my $t = ar.block || ar.again || 0.04;
    my $d = ar.begin || 0.001;
    $G->timer($d, sub {
        $G->timer($t, sub {
            my $splatter = delete G.singing->{$name};
            if ($splatter > 1 && ar.again) {
                $G->Flab("Sig reps $splatter... again!  $name");
                w sing(%$ar);
            }
        }, "sing-block        $name");
        G.singing->{$name} = 1;
        $code->();
    }, "pre-sing     $name");
    
    

