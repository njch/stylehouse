
name: Ghost
hooks:
  _load_ways_post: |
    $S->w("load_ways_post");
    $G->Flab("$S->{name} +$S->{load_ways_count}+   ".
        join" , ", map { $_->{_wayfile} } @$w);
    
    w _fresh_init if $S->{load_ways_count} == 1;
    w _recoded_init if $S->{load_ways_count} != 1;
    $S->w("any_init");
    
  _recoded_init: |
    $S->w("recoded_init");
    my $g = $S;
    while ($g->{O} && ref $g->{O} eq "Ghost") {
        $g->w("child_recoded_init", {S => $S}) if $g eq $S;
        $g = $g->{O};
        $g->w("any_child_recoded_init", {S => $S});
    }
  _fresh_init: |
    $G->{S} = $S;
    say "init for $S->{name}";
    w V/init[$S];
    w include_init[$S];
    w GG_init[$S];
    $S->w("fresh_init");
  any_init: |
    G.U.mk_or_match = sub {
    
    };
    G.U.replace_o = sub {
        my ($S, $u) = @_;
        u.Li ? do {
            
        } :
         die;
    };
    G.U.match = sub {
        my $S = shift;
        
    };
    G.U.findA = sub {#c
        my $S = shift;
        my $ar = shift;
        my @wheres;
        while (my ($k, $v) = each %$ar) {
            push @wheres, [ $k, $v ];
        }
        for my $line (@{ $S->W->{script} }) {
            next if ref $line eq "ARRAY" && @$line == 0; # wtf case
            my $A = $line->{t};
            say "Looking at $_->[0] = $A->{B}->{$_->[0]}  .... $_->[1]";
            return $A if @wheres == grep {
                !exists $A->{B}->{$_->[0]} ||
                    $A->{B}->{$_->[0]} eq $_->[1]          } @wheres
        }
    };
    G.U.andwhendo = sub { #c
        my $S = shift;
        for my $and (@{S.andwhen}) {
            my ($when, $doing) = %$and;
            $when eq "asap" || die || next;
            my ($func, $etc) = %$doing;
            $func eq "oway_D" ? do {
                my ($w) = grep { _.K eq $etc } @{S.o};
                $w || die "no such oway K=$etc";
                $G->doo(w.D, {}) if w.D;
            } : die "no func $func";
            U->deaccum($S, 'andwhen', $and);
        }
    };
    G.U.accum = sub {#c
        my ($S, $a, $t) = @_;
        if (!grep { $_ eq $t } @$a) {
            push @$a, $t
        }
    };
    G.U.deaccum = sub {#c
        my ($S, $source, $ac, $t) = @_;
        my $a = $source->{$ac};
        my $i = 0;
        for (@$a) {
            return splice(@$a, $i, 1) if $_ eq $t;
            $i++;
        }
    };
    G.U.Tafu = sub {#c # lightly travel this kinda u
        my $S = shift;
        
        my $uu = G.U.sktcu->($S,@_);
        my $u = G.U.fu->($S, $uu);
        !u.Li ? do {
            G.U.T->(i => $u, e => 0.3);
        } : do{
            
        };
    };
    G.U.sets_any_k = sub {
        my ($S, $set, $true) = @_;
        for my $k (keys %$set) {
            return 1 if $true->{$k};
        }
    };
    G.U->{T} = sub {
        my $S = shift;
        my $t = $T;
        my $sets = {@_};
        
        my $tbl = {map{$_=>1}qw"i o L t"};
        if (G.U.sets_any_k->($S,$sets, $tbl)) {
            delete $t->{$_} for keys %$tbl;
        }
        $T= $T->spawn();
        $T->from($sets);
        T.L ||= T.i ||= G.U
        # when to replace oeoell with other values...
        #$G->T
        
        
        
        
    };
    G.U.haunt = sub { # non Li call
        my $S = shift;
        my $Travel = shift;
        my $s;
        s.depth = shift;
        s.t = shift;
        s.i = shift;
        s.o = [];
        
        $S->{$_} = $s->{$_} for keys %$s;
        
        $S->ob("haunt");
        $S->w("T_begin");

        s.i.arr_hook ? do {
            my @r = $S->w(s.i.arr_hook, s.i.arr_ar);
            s.i.returns = \@r;
        }
        : do {
            $S->w("arr");
        };

        my $L;
        if (exists $S->{t}) {
            $L = $S->W->continues($S); # %
            $S->ob("continues...", $L);
        }

        for my $o (@{$L->{o}}) {
            $o->{Lo} = $L;
        }
        s.i->{Li} = $L;

        my @r = $L;
        for my $c (@{$S->{o}}) {
            if (exists $c->{travel_this}) {
                $Travel->T($c->{travel_this}, $S, $c, $L->{depth}+1);
            }
            elsif (exists $c->{travel}) {
                $Travel->T($c->{travel}, $S, $c, $L->{depth}+1);
                delete $c->{travel} if !defined $c->{travel};
            }
            elsif (exists $c->{arr_returns}) {
                @r = @{$c->{arr_returns}};
            }
            elsif (exists $c->{B}->{s} || exists $c->{O}) {
                # sweet
            }
            else {
                $H->error("what kind of way out is",$S,$c)
            }
        }
        @r = @{s.i.returns} if s.i.arr_hook;
        $S->w("T_end", {L=>$L, r=>\@r});

        return @r
    };
    G.U.sktcu = sub {#c
        my ($S, $way, $B) = @_; 
        die  "B B" if B.B;
        my $w = $G->nw()->from(
            $G->findway('ways/'.$way)
        )->from({ B => {%$B} });
        die "makedad".wdump($w) if w.Lu && w.O ne "ux";
        $w
    };
    G.U.ul = sub {#c # look for u way
        my $S = shift;
        my $z = {@_};
        my $u = z.u;
        $u = G.U.fu->(z.u)                  unless u.Li;
        
        if (z.p){
            if (u.O eq "uy") {
                0->accum(z.p.o => $u);
                0->accum((u.Loose||=[]), z.p); # .B.Lo many
            }
            else {
                0->accum(z.p.o => $u);
                G.u.Lo = z.p
            }
        }
        unless (u.Li) {
              G.U.h.ul.creating_that_u->($u)
              if G.U.h.ul.creating_that_u;
             
            $G->T("anu: ".pint($u), undef, $u) unless u.Li;
        }
        die "no Li after T"                   unless u.Li;
           
        G.U.h.ul.done->($u) if G.U.h.ul.done;
        $u
    };
    G.U.fu = sub {#c
        my $S = shift;
        my $u = shift;
        for my $LL (@{$G->W->{script}}) {
            my $i = LL.i;
            if ($i eq $u || i.K eq u.K && G.U.B_same($u => $i)) {
                return LL.i;
            }
        }
    };
    G.U.B_same = sub {
        my ($S, $u, $uu) = @_;
        while (my ($k, $v) = each %{u.B}) {
            u.B->{$k} eq uu.B->{$k} || return 0;
        }
    };
    
    
    
  V: 
    spawn: |
      my $V;
      my $style = $S->styles($styles);
      if ($ar->{from}) {
          $V = $ar->{from}->spawn_floozy($S, $name, $style);
      }
      else {
          $V = View->new($H->intro, $S,  $name, $style);
      }
      $S->{V}->{$name} = $V;
      
    init: |
      for my $V ($S->findway('V')) {
          my $from = $S->{floozal} || $H->{sky};
          while (my ($name, $t) = each %$V) {
                my $styles = $t->{styles};
                w V/spawn[$S, $name, $styles, $from];
          }
      }
    blur: |
      my $blur = ++$G->{_blur} % 2 ? 'blur(8px) brightness(0.7)' : '';
      $H->JS($_, "css('-webkit-filter', '$blur');") for values %{S.V};

    toginvis: |
      my @Vs = values %{S.V};
      if ($ar->{k}) {
          @Vs = S.V->{$ar->{k}};
      }
      $_->togcl('invis') for @Vs;
      
  GG_init: |
    my $GG = $S->findway("GG");
    while (my ($way, $t) = each %$GG) {
        my $GG = $H->TT($S)->G($way);
    }
  include_init: |
    for my $include ($S->anyway('include')) {
        for my $in (split ' ', $include) {
            w do_include[$S, $in];
        }
    }
  do_include: |
    next if grep { $_->{_wayfile} =~ /$in/ } $S->ways;
    $S->{load_ways_count}--;
    $S->load_ways($in);
    
    
  sing: |
    $G->{singing} ||= {};
    return say "$name BLOCKED" if $G->{singing}->{$name} && $G->{singing}->{$name}++; # ignore sing until...
    $G->{singing}->{$name} = 1;
    my $t = $ar->{block_for} || $ar->{again_after} || 0.04;
    my $d = $ar->{begin_after} || 0.001;
    $G->timer($d, sub {
        $G->timer($t, sub {
            my $splatter = delete $G->{singing}->{$name};
            if ($splatter > 1 && $ar->{again_after}) {
                $S->Flab("Sig reps $splatter... "
                    .($ar->{again_after} ? "again!" : ".")
                    ."  $name");
                w sing(%$ar);
            }
        }, "sing-block        $name");
        $G->{singing}->{$name} = 1;
        $code->();
    }, "pre-sing     $name");
    
    

