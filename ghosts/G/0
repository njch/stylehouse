
name: Ghost
hooks:
  _load_ways_post: |
    $S->w("load_ways_post");
    $G->Flab("$S->{name} +$S->{load_ways_count}+   ".
        join" , ", map { $_->{_wayfile} } @$w);
    
    w _fresh_init if $S->{load_ways_count} == 1;
    w _recoded_init if $S->{load_ways_count} != 1;
    $S->w("any_init");
    
  _recoded_init: |
    $S->w("recoded_init");
    my $g = $S;
    while ($g->{O} && ref $g->{O} eq "Ghost") {
        $g->w("child_recoded_init", {S => $S}) if $g eq $S;
        $g = $g->{O};
        $g->w("any_child_recoded_init", {S => $S});
    }
  _fresh_init: |
    $G->{S} = $S;
    say "init for $S->{name}";
    w V/init[$S];
    w include_init[$S];
    w GG_init[$S];
    $S->w("fresh_init");
  any_init: |
    G.U.sing = sub {#c
        my $S = shift;
        my $p;
        p.name = shift;
        p.code = shift;
        $p = {%$p, @_};
        p.again = 0.5 if !defined p.again;
        p.begin = 0.2 if !defined p.begin;
        w sing(%$p);
    };
    G.U.loquate = sub {#c
        my ($S, $source, $path, $def) = @_;
        my @moves = split '/', $path;
        my $s = $source;
        until (@moves == 1) {
            my $m = shift @moves;
            $s = $s->{$m};
        }
        my $m = shift @moves;
        my $thing = $s->{$m} ||= $def;
        !ref $thing && die "Oh no! $path led to non-ref $thing from $source";
        return $thing;
    };
    G.U.accum = sub {#c # TODO path loquation doesn't stretch far re policy, no prob for now.
        my ($S, $source, $ac, $t) = @_;
                
        if ($ac eq "Lo" || $ac eq "Li") {
            $source->{$ac} = $t;
            return;
        }
        
        my $a = 0S->loquate($source, $ac, []);

        if (!grep { $_ eq $t } @$a) {
            push @$a, $t
        }
    };
    G.U.deaccum = sub {#c
        my ($S, $source, $ac, $t) = @_;
        my $a = $source->{$ac} ||= [];
        my $i = 0;
        for (@$a) {
            return splice(@$a, $i, 1) if $_ eq $t;
            $i++;
        }
    };
    G.U.sktcu = sub {#c skatch a way + B{
        my ($S, $way, $B) = @_;
        die  "B contains B:".wdump($B) if B.B;
        my $w = 0S->scrape_way($way);
        die "w_B not hash" if w.B && ref w.B ne "HASH";
        w.B = { %{w.B||{}}, %$B };
        die "makedad".wdump($w) if w.Lu && w.O ne "ux";
        0S->wdif(_postsketch => $w);
        $w
    };
    G.U.wdif = sub {
        my ($S, $h, $w) = @_;
        if ($w->{$h}) {
            $S->w($h, {}, $w);
            delete $w->{$h};
        }
    };
    G.U.scrape_way = sub {
        my ($S, $way) = @_;
        die "S not Ghost" unless ref $S eq "Ghost";
        my $nw = $S->nw();
        my $from = $S->findway('ways/'.$way);
        $from ||= do {
            my @chainway = grep { _.K eq $way } $S->chains;
            shift @chainway
        };
        $from || die "no findo way called $way (S.name)".wdump($S->findway('chains'));
        $nw->from($from);
        $nw;
    };
    G.U.TafuB = sub {#c # lightly travel or retract this kinda u
        my $S = shift;
        my $uu = 0S->sktcu(@_);
        0S->Tafu($uu);
    };
    G.U.Tafu = sub {
        my ($S, $uu) = @_;
        my $u = 0S->fu($uu);
        return $u if $u;
        0S->T({i => $uu});
        return $uu
    };
    G.U.TafuBl = sub {#c # slightly travel this kinda u
        my $S = shift;
        my $u = 0S->TafuB(@_);
        u.Li || die "no u Li ".wdump(2,$u);
        0S->l($u);
        $u
    };
    G.U.visTp_l_u = sub {#c
        my ($S, $u, $Tp) = @_;
        my $old = 0S->visTp($Tp);
        0S->l($u);
        $T= $old;
        $u;
    };
    G.U.l = sub {#c
        my ($S, $u) = @_;
        0S->accum($u, 'Lo', T.L);
        0S->accum($T, 'o', $u);
    };
    G.U.visTp_TafuBl = sub {#c
        my ($S, $Tp, $Bp) = @_;
        my $old = 0S->visTp($Tp);
        my $u = 0S->TafuBl(@$Bp);
        $T= $old;
        $u;
    };
    G.U.T= sub {#c
        my ($S, $p) = @_;
        my $old = 0S->visTp($p);
        
        0S->haunt_swoop();
        
        0S->haunt_wooo();
        
        my $L = T.L;
        $T = $old;
        return $L;
    };
    G.U.visTp= sub {
        my ($S, $p, $fun) = @_;
        
        my $old;
        if ($T && ref $T eq "Way") {
            $old = $T;
        }
        else {
            warn "T was ".wdump(2,$T);
            $T = $S->nw();
        }
        $T = $T->spawn;
        T._To = $old if $old;
        
        if (p.i || p.L) {
            delete $T->{$_} for qw'i L t o';
        }
        $T->from($p);
        T.i ||= T.L.i;
        T.L ||= T.i.Li;
        T.t ||= T.L.t;
        T.o ||= T.L.o;
        T.o ||= [];
        # backwards compat
        $S->{$_} = $T->{$_} for qw'i L t o';
        
        # zand
        if (old.i.T_remembers_last) {
            T._last->{old.i.K} = old.i
        }
        
        if ($fun eq "Fun") {
            push @{ $F[0]->{_after_do} }, sub {
                $T = $old
            };
        }
        return $old;
    };
    G.U.haunt = sub {
        my $S = shift;
        my $Travel = shift;
        my $t = {
            depth => shift,
            t => shift,
            i => shift,
            o => [],
            _Travel => $Travel, # non
        };
        say " 0 haunt  d=t.depth   i=".pint(t.i)."   t=t.t";
        my $L = 0S->T($t);
        return @{L.i.returns} if L.i.returns;
        return $L;
    };
    G.U.haunt_swoop = sub {#c
        my $S = shift;
        my $i = T.i;
        $S->ob("haunt");
        $S->w("T_begin");
        
        $S->w("arr") unless T._noarr;
        
        $S->doo(i.flows_D, {}) if i.flows_D;
        
        0S->continues();
        
        T.L.i eq T.i || die "tli not ni!?!?!";
        
        # [o  get Lo = L
        0S->accum($_, 'Lo', T.L) for @{T.L.o};
        0S->accum(T.L.i, 'Li', T.L); # just right
    };
    G.U.continues = sub {
        my $S = shift;
        T.L = $S->W->continues($S); # %
        $S->ob("continues...", T.L);
    };
    G.U.haunt_wooo = sub {
        my $S = shift;
        my $R = [T.L];
        for my $c (@{T.o}) {
            if (exists c.travel_this) {
                T._Travel->T(c.travel_this, $S, $c, T.depth+1);
            }
            elsif (exists c.travel) {
                T._Travel->T(c.travel, $S, $c, T.depth+1);
                delete c.travel if !defined c.travel;
            }
            elsif (exists c.arr_returns) { # ded?
                $R = c.arr_returns;
            }
            elsif (exists c.travels) {
                0S->T($S, {i => $c});
            }
            elsif (exists c.B.s || exists c.O) {
                # sweet
            }
            else {
                Say "what kind of way out is
                S.name \n".wdump(2,$c);
            }
        }
        
        $S->doo(T.i.extract_D, {}) if T.i.extract_D;
        
        $S->w("T_end", {L=>T.L, r=>$R});
        T.i.returns = $R;
    };
    
    G.U.fu = sub {#c
        my $S = shift;
        my $u = shift;
        for my $LL (@{$S->W->{script}}) {
            my $i = LL.i;
            if ($i eq $u || (!exists u.K || i.K eq u.K) && 0S->B_same($u => $i)) {
                return $i;
            }
        }
        return undef;
    };
    G.U.B_same = sub {
        my ($S, $u, $i) = @_;
        
        return 1 if exists u.B._ && exists i.B._ && u.B._ eq i.B._;
        
        my @ks = keys %{u.B};
        for my $k (@ks) {
            u.B->{$k} eq i.B->{$k} || return 0;
            next if $k eq "Codon";
        }
            $G->timer(2,sub {
            Say " u has no B, mind  you...".ki($u);
            }) unless keys %{u.B};
        return 1;
    };
    
    
    
  V: 
    spawn: |
      my $V;
      my $style = $S->styles($styles);
      if ($ar->{from}) {
          $V = $ar->{from}->spawn_floozy($S, $name, $style);
      }
      else {
          $V = View->new($H->intro, $S,  $name, $style);
      }
      $S->{V}->{$name} = $V;
      
    init: |
      for my $V ($S->findway('V')) {
          my $from = $S->{floozal} || $H->{sky};
          while (my ($name, $t) = each %$V) {
                my $styles = $t->{styles};
                w V/spawn[$S, $name, $styles, $from];
          }
      }
    blur: |
      my $blur = ++$S->{_blur} % 2 ? 'blur(8px) brightness(0.7)' : '';
      $H->JS($_, "css('-webkit-filter', '$blur');") for values %{S.V};

    toginvis: |
      $_->togcl('invis') grep { defined } ar.k ? S.V->{ar.k} values %{S.V};
      
  GG_init: |
    my $GG = $S->findway("GG");
    while (my ($way, $t) = each %$GG) {
        my $GG = $H->TT($S)->G($way);
    }
  include_init: |
    for my $include ($S->anyway('include')) {
        for my $in (split ' ', $include) {
            w do_include[$S, $in];
        }
    }
  do_include: |
    next if grep { $_->{_wayfile} =~ /$in/ } $S->ways;
    $S->{load_ways_count}--;
    $S->load_ways($in);
    
    
  sing: |
    G.singing ||= {};
    return say "\t\t\t\t $name BLOCKED"
        if G.singing->{$name}
            && G.singing->{$name}++; # ignore sing until...
    G.singing->{$name} = 1;
    my $t = ar.block || ar.again || 0.04;
    my $d = ar.begin || 0.001;
    $G->timer($d, sub {
        $G->timer($t, sub {
            my $splatter = delete G.singing->{$name};
            if ($splatter > 1 && ar.again) {
                $G->Flab("Sig reps $splatter... again!  $name");
                w sing(%$ar);
            }
        }, "sing-block        $name");
        G.singing->{$name} = 1;
        $code->();
    }, "pre-sing     $name");
    
    

