
name: Ghost

hooks:
  recoded_init: | # G/0 recode
    #H.G->w('reexec'); #DANG
  _load_ways_post: | # G/0 manages some other G's way startup ripples
    $S->w("load_ways_post");
    $G->Flab("$S->{name} +$S->{load_ways_count}+   ".
        join" , ", map { $_->{_wayfile} } @$w);
    
    if ($S->{load_ways_count} == 1) {
        w _init/fresh;
    }
    else {
        w _init/recoded;
    }
      
    $S->w("any_init");
    
  _init:
    recoded: |
        say "Recode calles ".@{G.recoded_cbs};
        for my $cb (@{G.recoded_cbs}) {
            $G->timer(0.1, sub { say "Balllgej!"; $cb->($S) });
        }
        
        w _init/wayrays[$S];
        
        w _init/recoded_Cways[$S] if $S->anyway('recoded_Cways');
        
        $S->w("recoded_init");
        
        w _init/recoded_care_parents[$S];
        
    recoded_Cways: |
      for my $i (map {_.i} G.U.scGre->($S)) {
          my $up = G.U.CsK->($S,{K=>i.K});
          $i->from($up);
      }
      
    recoded_care_parents: |
        my $g = $S;
        while ($g->{O} && ref $g->{O} =~ /^G/) {
            $g->w("child_recoded_init", {S => $S}) if $g eq $S;
            $g = $g->{O};
            $g->w("any_child_recoded_init", {S => $S});
        }
        
    fresh: |
      w _init/keys[$S];
      
      w _init/GG[$S];
      
      w _init/wayrays[$S];
      G.S = $S; # at
      w V/init[$S];
      $S->w("fresh_init");

    wayrays: |
      for my $s (qw'S C') { # C too?
          if (my $ws = $S->anyway($s)) {
              0->wayray($ws, $S);
          }
      }
      
    GG: |
      my $GGs = $S->anyway('GG');
      return unless $GGs;
      for my $GG (@$GGs) {
          my $way = GG.way || GG.K;
          my $g = S.GG->{GG.K} || $H->TT($S)->G($way);
          $g || die "no $way? GG $way from S.name = GG.K";
          g.K = GG.K;
          S.GG->{g.K} = $g;
          0S->InjC($g, GG.In) if GG.In;
      }
      
    keys: |
      return unless $S->findway("keys");
      if (my $keys = G:keys) {
          push @{keys.subs}, $S unless
            grep {$_ eq $S} @{keys.subs};
      }
      else {
          sayre "G L Waiting for G keys";
          $G->timer(0.5 => sub { w keyub[$S]; });
      } 
  _gitdission: |
    my $ghosts = H.h ? H.G.GGs : $H->data->{Ghost};
    sayyl "0 0 0 dission fo ".join" ", keys %$Gd;
    my @rG;
    for my $S (@$ghosts) {
        my $in = [grep{$Gd->{$_}} @{S.wayfiles}];
        next unless @$in;
        push @rG, $S;
        # sort stream to avoid small before big?
        waylay recode_ways[$S, $in];
    }
    say " Recoded: ".join"\t\t", map { $_->pi } @rG;
  recode_ways: |
    sayyl "recoding S.id S.name";
    eval {
        $S->load_ways(split /\+/, S.way); # TODO all ways on any recoded or..?
    };
    if ($@) {
        Err "Load ways fuckup: $@";
        return $@ = "";
    }
    say "S.name !  ! ! ! S.id recoded  S.way, intersects git diffage at:";
    say " - $_" for @$in; 
        
        
  any_init: |
    G.recoded_cbs||=[];
    G.U.uiuS = sub { #c
        my $S = shift;
        my ($u, $b) = @_;
        my $a = "S";
        my $ui = u.B.Lu.i if u.B.Lu; # even if below thingy?
        
        for my $w ($ui, $u) {
            next if !$w;
            
            my $Gw = w.G->findway(w.K) if w.Gw;
            
            for my $ww ($Gw, $w) {
                next if !$ww;
                next if !$ww->{$a};
                if ($ww->{$a}->{"${b}_D"}) {
                    $S->Flab("got a $a $b _D  ", $u);
                    my $some = w.G->w("$a/${b}_D", {u=>$u}, $w);
                    return $some if $some;
                }
                my $some = $ww->{$a}->{$b};
                return $some if $some;
            }
        }
    };
    G.U.InjC = sub {#c
        my ($S, $g, $In) = @_;
        while (my ($s, $etc) = each %$In) {
            while (my ($K, $win) = each %$etc) {
                my $C = G.U.CsK->($g, {K=>$K, s=>$s});
                $C->from($win);
            }
        }
    };
    G.U.GAK = sub {#c
        my ($S, $K, $g) = @_;
        g.K = $K;
        S.GG->{g.K} = $g;
        $g;
    };
  V: 
    spawn: |
      my $V;
      my $style = $S->styles($styles);
      if (ar.from) {
          $V = ar.from->spawn_floozy($S, $name, $style);
      }
      else {
          $V = View->new($H->intro, $S,  $name, $style);
      }
      S.V->{$name} = $V;
      
    init: |
      for my $V ($S->findway('V')) {
          my $from = $S->{floozal} || $H->{sky};
          while (my ($name, $t) = each %$V) {
                my $styles = $t->{styles};
                w V/spawn[$S, $name, $styles, $from];
          }
      }
    blur: |
      my $blur = ++$S->{_blur} % 2 ? 'blur(8px) brightness(0.7)' : '';
      $H->JS($_, "css('-webkit-filter', '$blur');") for values %{S.V};

    toginvis: |
      my @Vs = values %{S.V};
      if (ar.k) {
            @Vs = grep { defined } S.V->{ar.k}
      }
      
      $_->togcl('invis') for @Vs;
      

