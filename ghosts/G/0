
name: Ghost
hooks:
  _load_ways_post: |
    $S->w("load_ways_post");
    $G->Flab("$S->{name} +$S->{load_ways_count}+   ".
        join" , ", map { $_->{_wayfile} } @$w);
    
    w _fresh_init if $S->{load_ways_count} == 1;
    w _recoded_init if $S->{load_ways_count} != 1;
    $S->w("any_init");
    
  _recoded_init: |
    $S->w("recoded_init");
    my $g = $S;
    while ($g->{O} && ref $g->{O} eq "Ghost") {
        $g->w("child_recoded_init", {S => $S}) if $g eq $S;
        $g = $g->{O};
        $g->w("any_child_recoded_init", {S => $S});
    }
  _fresh_init: |
    $G->{S} = $S;
    say "init for $S->{name}";
    w V/init[$S];
    w include_init[$S];
    w GG_init[$S];
    $S->w("fresh_init");
  any_init: |
    G.U.mk_or_match = sub {
    
    };
    G.U.replace_o = sub {
        my ($S, $u) = @_;
        u.Li ? do {
            
        } :
         die;
    };
    G.U.match = sub {
        my $S = shift;
        
    };
    G.U.findA = sub {#c
        my $S = shift;
        my $ar = shift;
        
        my $u = { B => $ar };
        for my $LL (@{$S->W->{script}}) {
            die "wtf case" if ref $LL eq "ARRAY" && @$LL == 0; # wtf case
            my $t = LL.t;
            if (0S->B_same($u => $t)) {
                return $t;
            }
        }
    };
    G.U.andwhendo = sub { #c
        my $S = shift;
        for my $and (@{S.andwhen}) {
            my ($when, $doing) = %$and;
            $when eq "asap" || die || next;
            my ($func, $etc) = %$doing;
            $func eq "oway_D" ? do {
                my ($w) = grep { _.K eq $etc } @{S.o};
                $w || die "no such oway K=$etc";
                $G->doo(w.D, {}) if w.D;
            } : die "no func $func";
            U->deaccum($S, 'andwhen', $and);
        }
    };
    G.U.accum = sub {#c
        my ($S, $source, $ac, $t) = @_;
        my $a = $source->{$ac} ||= [];
        if ($ac eq "Lo" || $ac eq "Li") {
            $source->{$ac} = $t;
            return;
        }
        #die "Gunna...".wdump(2,[@_]);
        if (!grep { $_ eq $t } @$a) {
            push @$a, $t
        }
    };
    G.U.deaccum = sub {#c
        my ($S, $source, $ac, $t) = @_;
        my $a = $source->{$ac} ||= [];
        my $i = 0;
        for (@$a) {
            return splice(@$a, $i, 1) if $_ eq $t;
            $i++;
        }
    };
    G.U.sktcu = sub {#c skatch a way + B{
        my ($S, $way, $B) = @_; 
        die  "B contains B:".wdump($B) if B.B;
        my $w = 0S->scrape_way($way);
        die "w_B not hash" if w.B && ref w.B ne "HASH";
        w.B = { %{w.B||{}}, %$B };
        die "makedad".wdump($w) if w.Lu && w.O ne "ux";
        0S->wdif(_postsketch => $w);
        $w
    };
    G.U.wdif = sub {
        my ($S, $h, $w) = @_;
        if ($w->{$h}) {
            $S->w($h, {}, $w);
            delete $w->{$h};
        }
    };
    G.U.scrape_way = sub {
        my ($S, $way) = @_;
        my $nw = $S->nw();
        my $from = $S->findway('ways/'.$way);
        $from ||= do {
            my @chainway = grep { _.K eq $way } $S->chains;
            shift @chainway
        };
        $from || die "no findo way called $way";
        $nw->from($from);
        $nw;
    };
    G.U.TafuB = sub {#c # lightly travel this kinda u
        my $S = shift;
        
        my $uu = G.U.sktcu->($S, @_);
        
        my $u = G.U.fu->($S, $uu);
        return $u if $u;
        
        G.U.T->($S, {i => $uu});
        return $uu
    };
    G.U.TafuBl = sub {#c # lightly travel this kinda u
        my $S = shift;
        my $u = 0S->TafuB(@_);
        u.Li || die "no u Li";
        0S->accum($u, 'Lo', T.L);
        0S->accum($T, 'o', $u);
        $u
    };
    G.U.visTp_TafuBl = sub {#c
        my ($S, $Tp, $Tc) = @_;
        0S->spnT($Tp);
        my $u = 0S->TafuBl(@$Tc);
        $T= T._To;
        $u;
    };
    G.U.T= sub {#c
        my ($S, $p) = @_;
        my $t = $T;
        G.U.spnT->($S => $p);
        my $back = T._To;
        die if $back ne $t;
        
        G.U.haunt_swoop->($S);
        
        G.U.haunt_wooo->($S);
        
        $S->doo(T.i.extract_D, {}) if T.i.extract_D;
        
        my $L = T.L;
        $T= $back;
        return $L;
    };
    G.U.L_is = sub {
        my ($S, $L) = @_;
        0S->spnT({L=>$L});
    };
    G.U.spnT= sub {
        my ($S, $p) = @_;
        my $oldT=$T||=$G->nw();
        $T=$G->nw() if ref($T) ne "Way";
        $T=$T->spawn;
        T._To = $oldT;
        if (p.i || p.L) {
            delete $T->{$_} for qw'i L t o';
        }
        $T->from($p);
        T.i ||= T.L.i;
        T.L ||= T.i.Li;
        T.t ||= T.L.t unless exists T.t;
        T.o ||= T.L.o;
        T.o ||= [];
        # backwards compat
        $S->{$_} = $T->{$_} for qw'i L t o';
    };
    G.U.haunt = sub {
        my $S = shift;
        my $Travel = shift;
        my $L = G.U.T->($S, {
            depth => shift,
            t => shift,
            i => shift,
            o => [],
            _Travel => $Travel, # non
        });
        return @{L.i.returns};
    };
    G.U.haunt_swoop = sub {#c
        my $S = shift;
        my $i = T.i;
        $S->ob("haunt");
        $S->w("T_begin");
        
        G.U.arr->($S) unless T._noarr;
        
        $S->doo(i.flows_D, {}) if i.flows_D;
        
        G.U.continues->($S);
        
        _.Lo = T.L for @{T.L.o}; # too heavy for uy
        T.L.i.Li = T.L; # just right
    };
    G.U.continues = sub {
        my $S = shift;
        T.L = $S->W->continues($S); # %
        $S->ob("continues...", T.L);
    };
    G.U.haunt_wooo = sub {
        my $S = shift;
        my $R = [T.L];
        for my $c (@{T.o}) {
            if (exists c.travel_this) {
                T._Travel->T(c.travel_this, $S, $c, T.depth+1);
            }
            elsif (exists c.travel) {
                T._Travel->T(c.travel, $S, $c, T.depth+1);
                delete c.travel if !defined c.travel;
            }
            elsif (exists c.arr_returns) { # ded?
                $R = c.arr_returns;
            }
            elsif (exists c.travels) {
                G.U.T->($S, {i => $c});
            }
            elsif (exists c.B.s || exists c.O) {
                # sweet
            }
            else {
                Say "what kind of way out is
                S.name \n".wdump(2,$c);
            }
        }
        
        $R = T.i.returns if T.i.arr_hook;
        $S->w("T_end", {L=>T.L, r=>$R});
        T.i.returns = $R;
    };
    G.U.arr = sub {
        my $S = shift;
        my $i = T.i;
        if (i.arr_hook) {
            i.returns = [ $S->w(i.arr_hook, i.arr_ar) ];
        }
        else {
            $S->w("arr");
        }
        
    };
    
    G.U.fu = sub {#c
        my $S = shift;
        my $u = shift;
        for my $LL (@{$S->W->{script}}) {
            my $i = LL.i;
            if ($i eq $u || i.K eq u.K && 0S->B_same($u => $i)) {
                return $i;
            }
        }
        return undef;
    };
    G.U.B_same = sub {
        my ($S, $u, $i) = @_;
        my @ks = keys %{u.B};
        for my $k (@ks) {
            u.B->{$k} eq i.B->{$k} || return 0;
            next if $k eq "Codon";
        }
            $G->timer(2,sub {
            Say " u has no B, mind  you...".ki($u);
            }) unless keys %{u.B};
        return 1;
    };
    
    
    
  V: 
    spawn: |
      my $V;
      my $style = $S->styles($styles);
      if ($ar->{from}) {
          $V = $ar->{from}->spawn_floozy($S, $name, $style);
      }
      else {
          $V = View->new($H->intro, $S,  $name, $style);
      }
      $S->{V}->{$name} = $V;
      
    init: |
      for my $V ($S->findway('V')) {
          my $from = $S->{floozal} || $H->{sky};
          while (my ($name, $t) = each %$V) {
                my $styles = $t->{styles};
                w V/spawn[$S, $name, $styles, $from];
          }
      }
    blur: |
      my $blur = ++$S->{_blur} % 2 ? 'blur(8px) brightness(0.7)' : '';
      $H->JS($_, "css('-webkit-filter', '$blur');") for values %{S.V};

    toginvis: |
      my @Vs = values %{S.V};
      if ($ar->{k}) {
          @Vs = S.V->{$ar->{k}};
      }
      $_->togcl('invis') for @Vs;
      
  GG_init: |
    my $GG = $S->findway("GG");
    while (my ($way, $t) = each %$GG) {
        my $GG = $H->TT($S)->G($way);
    }
  include_init: |
    for my $include ($S->anyway('include')) {
        for my $in (split ' ', $include) {
            w do_include[$S, $in];
        }
    }
  do_include: |
    next if grep { $_->{_wayfile} =~ /$in/ } $S->ways;
    $S->{load_ways_count}--;
    $S->load_ways($in);
    
    
  sing: |
    $G->{singing} ||= {};
    return say "$name BLOCKED" if $G->{singing}->{$name} && $G->{singing}->{$name}++; # ignore sing until...
    $G->{singing}->{$name} = 1;
    my $t = $ar->{block_for} || $ar->{again_after} || 0.04;
    my $d = $ar->{begin_after} || 0.001;
    $G->timer($d, sub {
        $G->timer($t, sub {
            my $splatter = delete $G->{singing}->{$name};
            if ($splatter > 1 && $ar->{again_after}) {
                $S->Flab("Sig reps $splatter... "
                    .($ar->{again_after} ? "again!" : ".")
                    ."  $name");
                w sing(%$ar);
            }
        }, "sing-block        $name");
        $G->{singing}->{$name} = 1;
        $code->();
    }, "pre-sing     $name");
    
    

