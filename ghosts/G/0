
name: Ghost
include: T/0
hooks:
  _load_ways_post: |
    $S->w("load_ways_post");
    $G->Flab("$S->{name} +$S->{load_ways_count}+   ".
        join" , ", map { $_->{_wayfile} } @$w);
    
    w _fresh_init if $S->{load_ways_count} == 1;
    w _recoded_init if $S->{load_ways_count} != 1;
    $S->w("any_init");
    
  _recoded_init: |
    $S->w("recoded_init");
    my $g = $S;
    while ($g->{O} && ref $g->{O} eq "Ghost") {
        $g->w("child_recoded_init", {S => $S}) if $g eq $S;
        $g = $g->{O};
        $g->w("any_child_recoded_init", {S => $S});
    }
  _fresh_init: |
    $G->{S} = $S;
    say "init for $S->{name}";
    w V/init[$S];
    w GG_init[$S];
    $S->w("fresh_init");
  recoded_init: |
    H.G->w('re/exec');
  any_init: |
    G.U.sing = sub {#c
        my $S = shift;
        my $p;
        p.name = shift;
        p.code = shift;
        $p = {%$p, @_};
        p.again = 0.5 if !defined p.again;
        p.begin = 0.2 if !defined p.begin;
        w sing(%$p);
    };
    G.U.loquate = sub {#c
        my ($S, $source, $path, $def) = @_;
        my @moves = split '/', $path;
        my $s = $source;
        until (@moves == 1) {
            my $m = shift @moves;
            $s = $s->{$m};
        }
        my $m = shift @moves;
        my $thing = $s->{$m} ||= $def;
        !ref $thing && die "Oh no! $path led to non-ref $thing from $source";
        return $thing;
    };
    G.U.accum = sub {#c # TODO path loquation doesn't stretch far re policy, no prob for now.
        my ($S, $src, $ac, $t) = @_;
                
        if ($ac eq "Lo" || $ac eq "Li") {
            $src->{$ac} = $t;
            return;
        }
        
        my $a = 0S->loquate($src, $ac, []);
        
        return if $ac eq 'o' && src.i && src.i eq $t;

        if (!grep { $_ eq $t } @$a) {
            push @$a, $t
        }
    };
    G.U.deaccum = sub {#c
        my ($S, $source, $ac, $t) = @_;
        my $a = $source->{$ac} ||= [];
        my $i = 0;
        for (@$a) {
            return splice(@$a, $i, 1) if $_ eq $t;
            $i++;
        }
    };
    G.U.wdif = sub {#c
        my ($S, $h, $w) = @_;
        if ($w->{$h}) {
            $S->w($h, {}, $w);
            delete $w->{$h};
        }
    };
    G.U.sway = sub {#c # sucks way matching $p # only supports matching K for now
        my ($S, $p, $s) = @_;
        p.CsK ||= 'chains C';
        my ($from) = 0S->CsK($p);
        $from || die "no findo way called p.K (S.name)".wdump($p);
        
        my $w = $S->nw();
        $w->from($from);
        $w->from($s) if $s && %$s; # merges in B
        
        return $w
    };
    G.U.CsK = sub { my ($S, $p) = @_;   p.CsK || die "pass p.CsK to CsK";
        # p.CsK locates the Cs, is a qw of paths for anyway
        # another ghost lurks in the p.K grep
        my @Cs = map { flatline($_) } map { $S->anyway($_) }  split ' ', delete p.CsK;
        if (p.K) {
            @Cs = grep { _.K eq p.K } @Cs;
        }
        die "more p to CsK".sw($p) if !p.K || 1 < keys(%$p);
        return @Cs;
    };
    #cSTICKSSTICKSSTICKSSTICKSSTICKSSTICKSSTICKSSTICKSSTICKSSTICKS
    G.U.TafuBl = sub {my$S=shift;     0S->l( 0S->TafuB(@_) )             #c
    };
    G.U.TafuB = sub {my($S,$K,$B)=@_; 0S->Tafu(0S->Bu($K, $B))           #c
    };
    G.U.Tafu =sub{#c
        my($S,$uu)=@_;
        0S->fu($uu) || 0S->T({i => $uu});
    };
    G.U.Taful = sub {my($S,$uu)=@_;   0S->l( 0S->Tafu($uu) )             #c
    };
    G.U.Bu = sub {my($S,$K,$B)=@_;   0S->sway({K=>$K},{B=>$B});          #c
    };
    
    G.U.visTp_TafuBlA = sub { my ($S, $Tp, $Bup) = @_; #c
        my $old = 0S->visTp($Tp); # could be Fun, wire into end
        my $uu = 0S->Bu(@$Bup); 
        my $u = 0S->fu($uu) || 0S->T({i => $uu});
        0S->l($u);
        $T= $old;
        $u;
        
    };
    G.U.visTp_l_u = sub { my ($S, $Tp, $u) = @_; #c get in to a T place and make links
        my $old = 0S->visTp($Tp);
        0S->l($u);
        $T= $old;
        $u;
    };
    G.U.l = sub {#c draw arcs
        my ($S, $u) = @_;
        0S->accum($u, 'Lo', T.L);
        0S->accum($T, 'o', $u);
        $u;
    };
    G.U.visTp_TafuBl = sub {#c # get in Tp, 
        my ($S, $Tp, $Bp) = @_;
        my $old = 0S->visTp($Tp);
        my $u = 0S->TafuBl(@$Bp);
        $T= $old;
        $u;
    };
    G.U.T= sub {#c
        my ($S, $p) = @_;
        my $old = 0S->visTp($p);
        
        if ($S->deeby) {
            say "Deeby cos S.name \t\t S.db and $db > 0?" for 1..3
        }
        say "HAUNT HAUNT HAUNT ".pint(T.i) if $S->deeby;
        
        $G0->{travels_of}->{$S->{name}} ++;
        my $i = T.i;
        $S->ob("haunt");
        
        $S->w("arr");
        # ow
        $S->doo(i.flows_D, {}) if i.flows_D;
        
        # all this stuff is shaking # catch braids
        
        T.L = $S->W->continues($S); # %
        
        T.L.i eq T.i || die "tli not ni!?!?!";
        
        # [o  get Lo = L
        0S->accum($_, 'Lo', T.L) for @{T.L.o};
        0S->accum(T.L.i, 'Li', T.L); # just right
        
        
        
        
        for my $c (@{T.o}) {
            if (exists c.travel_this) {
                my $p = {
                    depth => T.depth+1, 
                    t => c.travel_this,
                    i => $c,
                };
                say " newT";
                0S->T($p);
            }
        }
        
        $S->doo(T.i.extract_D, {}) if T.i.extract_D;
        
        #Info "HAUNTED ".sw($T) if $S->{name} =~ /braid|ux|odon/;
        
        my $L = T.L;
        $T = $old;
        return L.i;
    };
    G.U.visTp= sub { #c
        my ($S, $p, $fun) = @_;
        
        my $old;
        if ($T && ref $T eq "Way") {
            $old = $T;
        }
        else {
            warn "T was ".wdump(2,$T);
            $T = $S->nw();
        }
        
        $T = $T->spawn;
        
        my $moved = p.i || p.L;
        if ($moved) {
            delete $T->{$_} for qw'i L t o';
        }
        
        $T->from($p);
        
        T.i ||= T.L.i;
        T.L ||= T.i.Li;
        T.t ||= T.L.t;
        T.o ||= T.L.o;
        T.o ||= [];
        
        if ($old) {
            T._T = $old;
            #push @{old.T_||=[]}, $T;
            if (old.i.T_remembers_last) {
                T._last->{old.i.K} = old.i;
            }
        }
        if (my $t = T._trail) {
            $t = T._trail = {%$t};
            t.is = [@{t.is||[]}, T.is];
            t.ih = {%{t.ih||{}}};
            if ($moved && t.ih->{T.i.id}) { # here before - some 3d? almost a real Trail?
                if (t._no_circles) {
                    die "not allowed circular travel, "
                        .sw({here_before => T.i,T=>$T});
                }
            }
            t.ih->{T.is.id} = $T;
        }
        $S->deeby && say "T is nowish ".ki($T);
        
        if (ref $fun eq "CODE") {
            return $fun->();
            $T = $old;
        }
        elsif ($fun eq "Fun") {
            push @{ $F[0]->{_after_do} }, sub { $T = $old }
        }
        return $old;
    };
    G.U.fu = sub {#c
        my $S = shift;
        my $u = shift;
        for my $LL (@{$S->W->{script}}) {
            my $i = LL.i;
            if ($i eq $u || (!exists u.K || i.K eq u.K) && 0S->B_same($u => $i)) {
                return $i;
            }
        }
        return undef;
    };
    G.U.B_same = sub {#c
        my ($S, $u, $i) = @_;
        
        return 1 if exists u.B._ && exists i.B._ && u.B._ eq i.B._;
        
        my @ks = keys %{u.B};
        for my $k (@ks) {
            u.B->{$k} eq i.B->{$k} || return 0;
            next if $k eq "Codon";
        }
            $G->timer(2,sub {
            Say " u has no B, mind  you...".ki($u);
            }) unless keys %{u.B};
        return 1;
    };
    
    
    
  V: 
    spawn: |
      my $V;
      my $style = $S->styles($styles);
      if (ar.from) {
          $V = ar.from->spawn_floozy($S, $name, $style);
      }
      else {
          $V = View->new($H->intro, $S,  $name, $style);
      }
      S.V->{$name} = $V;
      
    init: |
      for my $V ($S->findway('V')) {
          my $from = $S->{floozal} || $H->{sky};
          while (my ($name, $t) = each %$V) {
                my $styles = $t->{styles};
                w V/spawn[$S, $name, $styles, $from];
          }
      }
    blur: |
      my $blur = ++$S->{_blur} % 2 ? 'blur(8px) brightness(0.7)' : '';
      $H->JS($_, "css('-webkit-filter', '$blur');") for values %{S.V};

    toginvis: |
      my @Vs = values %{S.V};
      if (ar.k) {
            @Vs = grep { defined } S.V->{ar.k}
      }
      
      $_->togcl('invis') for @Vs;
      
  GG_init: |
    my $GG = $S->findway("GG");
    while (my ($way, $t) = each %$GG) {
        my $GG = $H->TT($S)->G($way);
    }
  sing: |
    G.singing ||= {};
    return $G->Flab("\t\t\t\t $name BLOCKED")
        if G.singing->{$name}
            && G.singing->{$name}++; # ignore sing until...
    G.singing->{$name} = 1;
    my $t = ar.block || ar.again || 0.04;
    my $d = ar.begin || 0.001;
    $G->timer($d, sub {
        $G->timer($t, sub {
            my $splatter = delete G.singing->{$name};
            if ($splatter > 1 && ar.again) {
                $G->Flab("Sig reps $splatter... again!  $name");
                w sing(%$ar);
            }
        }, "sing-block        $name");
        G.singing->{$name} = 1;
        $code->();
    }, "pre-sing     $name");
    
    

