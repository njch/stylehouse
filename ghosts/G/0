
name: Ghost
include: G/2
hooks:
  recoded_init: | # G/0 recode
    H.G->w('re/exec');
  _load_ways_post: | # G/0 manages some other G's way startup ripples
    $S->w("load_ways_post");
    $G->Flab("$S->{name} +$S->{load_ways_count}+   ".
        join" , ", map { $_->{_wayfile} } @$w);
    
    if ($S->{load_ways_count} == 1) {
        w _init/fresh;
    }
    else {
        w _init/recoded;
    }
      
    $S->w("any_init");
    
  _init:
    recoded: |
        w ub/wayrays[$S];
        w _init/recoded_Cways[$S] if $S->anyway('recoded_Cways');
        $S->w("recoded_init");
        w _init/recoded_care_parents[$S];
    recoded_Cways: |
      for my $i (map {_.i} G.U.scGre->($S)) {
          my $up = G.U.CsK->($S,{K=>i.K});
          $i->from($up);
      }
    recoded_care_parents: |
        my $g = $S;
        while ($g->{O} && ref $g->{O} eq "Ghost") {
            $g->w("child_recoded_init", {S => $S}) if $g eq $S;
            $g = $g->{O};
            $g->w("any_child_recoded_init", {S => $S});
        }
    fresh: |
      w ub/0[$S];
      $G->{S} = $S;
      say "init for $S->{name}";
      w V/init[$S];
      $S->w("fresh_init");
  ub:
    0: |
      w ub/keys[$S] if $S->findway("keys");
      w ub/GG[$S] if $S->anyway("GG");
      w ub/wayrays[$S];
    wayrays: |
      for my $s (qw'S C') { # C too?
          if (my $ws = $S->anyway($s)) {
              0->wayray($ws, $S);
          }
      }
    GG: |
      my $GGs = $S->anyway('GG');
      for my $GG (@$GGs) {
          my $way = GG.way || GG.K;
          my $g = S.GG->{GG.K} || $H->TT($S)->G($way);
          $g || die "no $way? GG $way from S.name = GG.K";
          g.K = GG.K;
          S.GG->{g.K} = $g;
          while (my ($s, $etc) = each %{GG.In||{}}) {
              while (my ($K, $win) = each %$etc) {
                  my $C = G.U.CsK->($g, {K=>$K, s=>$s});
                  $C->from($win);
              }
          }
      }
    keys: |
      if (my $keys = G:keys) {
        push @{keys.subs}, $S unless
            grep {$_ eq $S} @{keys.subs};
      }
      else {
          sayre "G L Waiting for G keys";
          $G->timer(0.5 => sub { w keyub[$S]; });
      }
  any_init: |
    G.U.ing = sub { #c
        my ($S, $time, $ing, $w) = @_;
        $time && $ing || die " time&ing";
        
        my $name = $ing;
        $name .= $w->pint if $w;
        my $ingw = $S->nw(
            K=>"ing",
            name => $name,
            ing => $ing,
            time => $time,
        );
        say "create ingw.G.name ingw.name $time";
        ingw.w = $w if $w;
        my $inga = S.ing->{$name} ||= {};
        _.dead = 1 for values %$inga;
        $inga->{ingw.id} = $ingw;
        0S->ingo($ingw);
    };
    
    G.U.ingo = sub { #c
        my ($S, $ingw) = @_;
        return say "ing ingw.name ingw.id deduped" if ingw.dead;
        return sayre "ing ingw.name ingw.id ui dead" if ingw.w && ingw.w.dead;
        
        $S->w(ingw.ing, {}, ingw.w);
        
        my $time = ingw.w.e if ingw.w && ingw.w.e;
        $time ||= ingw.time;
        fla "time ingw.G.name ingw.name $time";
        $S->timer($time, sub {
            0S->ingo($ingw);
        }, "ing ingw.name ingw.id");
    };
    
    G.U.scGre = sub {#c
        my ($S, $ip) = @_;
        # or something was somehow, tractioning v
        my @a = grep { G.U.ip->($S, $ip, _.i) } @{ S.W.script };
        @a
    };
    G.U.ip = sub {#c
        my ($S, $ip, $i) = @_;
        (!exists ip.K || i.K eq ip.K) &&
        (!exists ip.V || i.V eq ip.V)
    };
    G.U.rei = sub {#c
        my ($S, $ip) = @_;
        map {_.i} 0S->scGre($ip);
    };
    G.U.reeni = sub {#c
        my ($S, $ip, @is) = @_;
        my @sel;
        my @new = grep {defined} map {
            if (0S->ip($ip, _.i)) {;
                push @sel, $_;
                undef;
            }
            else {         $_           }
        } @{S.W.script};
        # etc
    };
    G.U.sing = sub {#c
        my $S = shift;
        my $p;
        p.name = shift;
        p.code = shift;
        $p = {%$p, @_};
        p.again = 0.5 if !defined p.again;
        p.begin = 0.2 if !defined p.begin;
        w sing(%$p);
    };
    G.U.loquate = sub {#c
        my ($S, $source, $path, $def) = @_;
        my @moves = split '/', $path;
        my $s = $source;
        until (@moves == 1) {
            my $m = shift @moves;
            $s = $s->{$m};
        }
        my $m = shift @moves;
        my $thing = $s->{$m} ||= $def;
        !ref $thing && die "Oh no! $path led to non-ref $thing from $source";
        return $thing;
    };
    G.U.accum = sub {#c # TODO path loquation doesn't stretch far re policy, no prob for now.
        my ($S, $src, $ac, $t) = @_;
                
        if ($ac eq "Lo" || $ac eq "Li") {
            $src->{$ac} = $t;
            return;
        }
        
        my $a = 0S->loquate($src, $ac, []);
        
        return if $ac eq 'o' && src.i && src.i eq $t;

        if (!grep { $_ eq $t } @$a) {
            push @$a, $t
        }
    };
    G.U.deaccum = sub {#c
        my ($S, $source, $ac, $t) = @_;
        my $a = $source->{$ac} ||= [];
        my $i = 0;
        for (@$a) {
            return splice(@$a, $i, 1) if $_ eq $t;
            $i++;
        }
    };
    G.U.wdif = sub {#c
        my ($S, $h, $w) = @_;
        if ($w->{$h}) {
            $S->w($h, {}, $w);
            delete $w->{$h};
        }
    };
    G.U.sway = sub {#c # sucks way matching $p # only supports matching K for now
        my ($S, $p, $s, $P) = @_;
        p.s ||= 'chains C';
        my ($from) = p.from || 0S->CsK($p);
        
        $from || defined P.e || die "no findo way called p.K (S.name)".wdump([$p,$s]);
        
        my $w = $S->nw();
        $w->from($from) if $from;
        $w->from($p) unless $from;
        $w->from($s) if $s && %$s; # merges in B :D
        
        return $w
    };
    G.U.Bu = sub {#c
        my($S,$K,$B)=@_;
        my $u = 0S->sway({K=>$K},{B=>$B});
        w $u Bu_D if u.Gw || u.Bu_D;#opopopopop
        $u;
    };
    G.U.CsK = sub { #c
        my ($S, $p, $GG) = @_;
        $GG ||= $S;
        p.s ||= 'C';
        # p.CsK locates the Cs, is a qw of paths for anyway
        my @Cs = map { flatline($_) } map { $GG->anyway($_) }  split ' ', delete p.s;
        # another ghost lurks
        if (p.K) {
            @Cs = grep { _.K eq p.K } @Cs;
        }
        return wantarray ? @Cs : shift @Cs;
    };
    G.U.Tind = sub {#c
        my ($S, $space) = @_;
        $space = "    " if !defined $space;
        my $mes = T.r.is if T.r;
        $mes ||= [];
        my $ind = "";
        $ind .= "    " for 0..@$mes; # +1
        return $ind;
    };
    G.U.Egypto = sub {#c
        my ($S, $Egyptian_Fraction) = @_;
        my $val = 0;
        for (split / ?\+ ?/, $Egyptian_Fraction) {
            /^(\d+)\/(\d+)$/ || die "Egypmal";
            $val += $1 / $2;
        }
        $val;
    };
    G.U.EgyB = sub {#c
        my ($S, $B) = @_;
        return { map { 0->Egypto($_) => $_ } keys %$B };
    };
    G.U.TafuBl = sub {#cSTICKSSTICKSSTICKSSTICKSSTICKSSTICKSSTICKSSTICKSSTICKSSTICKS
        my$S=shift;
        0S->l( 0S->TafuB(@_) );
    };
    G.U.TafuB = sub {
        my($S,$K,$B)=@_;
        my $ca = $S->W->{ca}->{K}->{$K}->{B_ki}->{ki($B)};
        if ($ca) {
            return $ca;
        }
        0S->Tafu(0S->Bu($K, $B))
    };
    G.U.Tafu =sub{
        my($S,$uu)=@_;
        0S->fu($uu) || 0S->T({i => $uu});
    };
    G.U.Taful = sub {
        my($S,$uu)=@_;
        0S->l( 0S->Tafu($uu) );
    };
    
    G.U.visTp_TafuBlA = sub { #c
        my ($S, $Tp, $Bup, $A) = @_;
        my $old = 0S->visTp($Tp); # could be Fun, wire into end
        my $uu = 0S->Bu(@$Bup); 
        my $u = 0S->fu($uu);
        
        A.old ||= [] if $A;
        A.new ||= [] if $A;
        if ($u) {
            push @{A.old}, $u if $A;
        }
        else {
            push @{A.new}, $u if $A;
            $u = 0S->T({i => $uu});
        }
        
        0S->l($u);
        $T= $old;
        $u;
        
    };
    G.U.visTp_l_u = sub { my ($S, $Tp, $u) = @_; #c get in to a T place and make links
        my $old = 0S->visTp($Tp);
        0S->l($u);
        $T= $old;
        $u;
    };
    G.U.l = sub {#c draw arcs
        my ($S, $u) = @_;
        0S->accum($u, 'Lo', T.L);
        0S->accum($T, 'o', $u);
        $u;
    };
    G.U.visTp_TafuBl = sub {#c # get in Tp, 
        my ($S, $Tp, $Bp) = @_;
        my $old = 0S->visTp($Tp);
        my $u = 0S->TafuBl(@$Bp);
        $T= $old;
        $u;
    };
    G.U.T= sub {#c
        my ($S, $p) = @_;
        
        # 1/9
        
        my $old = 0S->visTp($p); # 1
        0S->fu_cache(T.i);
        
        # 2/9
        
        say "HAUNT HAUNT HAUNT ".pint(T.i) if $S->deeby;
        $G0->{travels_of}->{$S->{name}} ++;
        $S->ob("haunt");
        
        # 3/9
        
        $S->w("T/flows");
        $S->w('flows_D', {}, T.i);
        
        # 4/9
        
        die "No i ".sw($G) unless T.i;
        T.L = $S->W->continues($S); # %
        
        $S->w('humms_D', {}, T.i);
        $S->w("T/humms");
        
        # 5/9
        
        T.L.i eq T.i || die "tli not ni!?!?!";
        0S->accum($_, 'Lo', T.L) for @{T.L.o};
        0S->accum(T.L.i, 'Li', T.L); # just right
        $S->w("T/links", {u=>T.i});
        $S->w('links_D', {}, T.i);
        
        # rounds_D? replayable when recoded?
        # assume 6/7 will continue the process...
        
        # 6/9
        
        $S->w("T/travels", {u=>T.i});
        $S->w('travels_D', {}, T.i);
        
        # 7/9
        
        $S->w('extract_D', {}, T.i);
        
        # 8/9
        
        #Info "HAUNTED ".sw($T) if $S->{name} =~ /braid|ux|odon/;
        
        # 9/9
        
        my $L = T.L;
        $T = $old;
        return L.i;
    };
    G.U.visTp= sub { #c
        my ($S, $p, $fun) = @_;
        
        my $old;
        if ($T && ref $T eq "Way") {
            $old = $T;
        }
        else {
            $T = $S->nw();
        }
        
        $T = $T->spawn;
        
        my $moved = p.i || p.L;
        if ($moved) {
            delete $T->{$_} for qw'i L t o';
        }
        
        $T->from($p);
        
        T.i ||= T.L.i;
        T.L ||= T.i.Li;
        T.t ||= T.L.t;
        T.o ||= T.L.o;
        T.o ||= [];
        
        if ($old) {
            T._T = $old;
            #push @{old.T_||=[]}, $T;
        }
        if (my $r = T.r) {
            if ($moved && r.ih->{T.i.id} && r.noo) {
                # recursion q factor # can rebraid things to go on forever etc.
                die "not allowed circular travel, "
                    .sw({here_before => $T});
            }
            $r = T.r = {%$r};
            r.ih = {%{r.ih||{}}};
            r.is = [@{r.is||[]}, T.i];
            r.ih->{T.i.id} = $T;
        }
        
        if (ref $fun eq "CODE") {
            return $fun->();
            $T = $old;
        }
        elsif ($fun eq "Fun") {
            push @{ $F[0]->{_after_do} }, sub { $T = $old }
        }
        return $old;
    };
    G.U.fu = sub {#c
        my $S = shift;
        my $u = shift;
        
        return $S->W->{ca}->{K}->{u.K}->{B_ki}->{ki(u.B)};
        
        for my $LL (@{$S->W->{script}}) {
            my $i = LL.i;
            my $yup = $i eq $u
                || (!exists u.K || i.K eq u.K)
                && 0S->B_same($u => $i);
            if ($yup) {
                return $i;
            }
        }
        return undef;
    };
    G.U.fu_cache = sub { #c
        my $S = shift;
        my $u = shift;
        $S->W->{ca}->{K}->{u.K}->{B_ki}->{ki(u.B)} = $u;
    };
    G.U.fs_glob = sub {#c
        my ($S, @globs) = @_;
        my @list;
        for my $glob (@globs) {
            push @list, grep { defined }
                grep { Hostinfo::fixutf8($_) || 1 }
                grep { -f $_ } glob $glob;
        }
        return @list;
    };
    G.U.fs_find = sub{#c
        my ($S, @dirs) = @_;
        my @list;
        File::Find::find(sub {
            my $na = $File::Find::name;
            Hostinfo::fixutf8($na);
            next unless -f $na;

            push @list, $na;
        }, @dirs);
        return @list;
    };
    G.U.jsq = sub {#c
        my $S = shift;
        my @a = @_;
        for (@a) {
            s/\\/\\\\/g;
            s/'/\\'/g;
            s/\n/\\n/g;
        }
        wantarray ? @a : shift @a;
    };
    G.U.B_same = sub {#c
        my ($S, $u, $i) = @_;
        
        return 1 if exists u.B._ && exists i.B._ && u.B._ eq i.B._;
        
        my @ks = keys %{u.B};
        for my $k (@ks) {
            u.B->{$k} eq i.B->{$k} || return 0;
            next if $k eq "Codon";
        }
        unless (keys %{u.B}) {
            Say " u has no B, mind  you...".ki($u);
        }
        return 1;
    };
    G.U.Ato = sub {#c
        my ($S, $w, $to) = @_;
        (    grep { _.K eq $to } @{w.Li.o}    )[0]
    };
    G.U.Stytog = sub {#c
        my ($S, $styles, $s) = @_;
        my @styles = split /\s+/, $styles;
        if (grep { $_ eq $s } @styles) {
            @styles = grep { $_ ne $s } @styles
        }
        else {
            push @styles, $s;
        }
        return join ' ', @styles;
    };
    G.U.wayray = sub {#c
        my ($S, $SS, $GG) = @_;
        $GG ||= $S;
        die sw(\@_) if ref ${GG} ne "Ghost";
        my $i = 0;
        for my $wS (@$SS) {
            $SS->[$i] = $GG->nw(%$wS) unless ref $wS eq "Way";
            $i++;
        }
    };
    G.U.RW = sub {#c
        my ($S, $GG) = @_;
        sayyl "RW RW RW RW RW GG.name\t\t GG.K";
        _.dead = $F[0] for G.U.rei->($GG, {});
        my $W = GG.W;
        my $deadscript = W.script;
        W.script = [];
        W.n = 0;
        delete W.ca;
        $deadscript;
    };
  V: 
    spawn: |
      my $V;
      my $style = $S->styles($styles);
      if (ar.from) {
          $V = ar.from->spawn_floozy($S, $name, $style);
      }
      else {
          $V = View->new($H->intro, $S,  $name, $style);
      }
      S.V->{$name} = $V;
      
    init: |
      for my $V ($S->findway('V')) {
          my $from = $S->{floozal} || $H->{sky};
          while (my ($name, $t) = each %$V) {
                my $styles = $t->{styles};
                w V/spawn[$S, $name, $styles, $from];
          }
      }
    blur: |
      my $blur = ++$S->{_blur} % 2 ? 'blur(8px) brightness(0.7)' : '';
      $H->JS($_, "css('-webkit-filter', '$blur');") for values %{S.V};

    toginvis: |
      my @Vs = values %{S.V};
      if (ar.k) {
            @Vs = grep { defined } S.V->{ar.k}
      }
      
      $_->togcl('invis') for @Vs;
      
  sing: |
    G.singing ||= {};
    return $G->Flab("\t\t\t\t $name BLOCKED")
        if G.singing->{$name}
            && G.singing->{$name}++; # ignore sing until...
    G.singing->{$name} = 1;
    my $t = ar.block || ar.again || 0.04;
    my $d = ar.begin || 0.001;
    $G->timer($d, sub {
        $G->timer($t, sub {
            my $splatter = delete G.singing->{$name};
            if ($splatter > 1 && ar.again) {
                $G->Flab("Sig reps $splatter... again!  $name");
                w sing(%$ar);
            }
        }, "sing-block        $name");
        G.singing->{$name} = 1;
        $code->();
    }, "pre-sing     $name");
    
    

