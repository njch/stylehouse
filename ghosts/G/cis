Ds:
  - K: tai #c
    D: |
      my ($f,$n) = 0->taR(@_);
      fspu($f, "$n\n");
      saybl '  tai fspu '.$f.'    '.slim(30, $n);
  - K: tac #c
    D: |
      my ($f,$n) = 0->taR(@_);
      fscc($f, "$n\n");
      saybl '  tac fscc '.$f.'    '.slim(30, $n);
  - K: tas #c
    D: |
      my ($fs,$n,$x) = 0->taR(@_);
      my $f = 0->msc($x);
      fscc($f, "$n\n");
      saybl '  tas fscc '.$f.'    '.slim(30, $n);
  - K: tri #c try read
    D: |
      my ($f) = 0->taR(@_);
      return if !-f $f;  
      read_file($f);
  - K: taR #c
    D: |
      # MZ $f,$n
      my ($f, $n) = @_;
      my $x = 0->spc($f);
      $n = ejson($n) if ref $n;
      (x.fi, $n, $x)
  - K: ily #c as su
    D: |
        say "Jep: ".join '  ', @_;
        my $l = pop;
        my $x = 0->spc(@_);
        x.l = $l;
        
        saybl "        ily: x.fi"; 

        for (@{x.lots}) {
            my $file = x.fi.'.'.$_;
            
            $G->tailf($x, $file);
        }

        $G->wtfy($x);
  - K: su #c ^ ily
    D: |
      0->ily(@_);
      return;
        my ($a) = @_;
        if (@_ > 1) {
            $a = {top => shift};
            a.cb = pop;
            a.div = shift || 7;
        }
        a.top && a.cb || die "wtf";
        my $D = a.cb;
        
        H.G->w(subsc => $a); 
  - K: pub #c
    D: |
       my ($S, $m, $ig) = @_;
       sayyl "H pub $S < ".G::slim(50,50,$m) if !$ig;
       $G->tas($S, $m);

      
  - K: spc #c
    D: |
      my $f = pop;
      my $o = pop || G.lifespot || 'life';
      my $fi = "$o/$f";
      my $x = G.taily.f->{$fi} ||= {};
        if (!x.fi) {
            x.fi = $fi;
            x.f = $f;
            x.o = $o;
            $fi =~ /^(.+)\/(.+?)$/;
            x.t = $2;
            x.d = $1;
            x.lots = ['sc','sc2'];
        }
      $x
  - K: msc #c catch movign zipper
    D: |
      my $x = ref $_[0] ? $_[0] : 0->spc(@_);
        my $link = x.fi.'.s';
        my $s = readlink $link if -e $link;
        if (!$s) {
            sayyl "auto sc x.fi";
            $G->wtfy($x); # makes a .s -> .sc
            return $G->msc($x);
        }
        # so appends can sense together before even .cing
        x.d.'/'.$s
  - K: wtfy #c ye
    D: |
      $G->taily->{wtfy}->(@_);
  - K: tailf #c ye
    D: |
      $G->taily->{tailf}->(@_);
  - K: taily #c fs xenostrogen
    D: |
      my $y = G.taily = {};
      #
      y.rw = sub { #c gone into msc
        my $x = y.spc->(@_);
        y.msc->($x);
      };
      y.msc = sub { #c gone
        my $x = shift;
        my $link = x.fi.'.s';
        my $s = readlink $link;
        say " LOokoing $link  : $s";
        if (!$s) {
            sayyl "auto sc x.fi";
            y.wtfy->($x); # makes a .s -> .sc
            return y.msc->($x);
        }
        # so appends can sense together before even .cing
        x.d.'/'.$s
      };
      y.rr = sub { #c points to a bud to have bits (.i etc) sprout off
        # make NZ to make can be created 
        my $x = y.spc->(@_);
        return x.fi;
      };
      y.spc = sub { #c gone 0->spc
        my $f = pop;
        my $o = pop || G.lifespot || 'life';
        my $fi = "$o/$f";
        my $x = G.taily.f->{$fi} ||= {};
        if (!x.fi) {
            x.fi = $fi;
            x.f = $f;
            x.o = $o;
            $fi =~ /^(.+)\/(.+?)$/;
            x.t = $2;
            x.d = $1;
            x.lots = ['sc','sc2'];
        }
        fscc("x.d/NZ", "") unless -e "x.d/NZ";
        $x
      };
      y.ily = sub { #c one l/ily per file
        my $l = pop;
        my $x = 0->spc(@_);
        x.l = $l;
        
        saybl "        ily: x.fi";

        for (@{x.lots}) {
            my $file = x.fi.'.'.$_;
            
            y.tailf->($x, $file);
        }

        y.wtfy->($x);
      };
      y.mk = sub { #c
        my $x = shift;
        say "mk path x.d";
        my $some = `ls -d x.d`;
        say "SOME: $some";
        say "-e x.d" if -e x.d;
        say "-d x.d" if -d x.d;
        return if -e x.d;
        sayre "MKDIR x.d";
        make_path(x.d);
        die "no go diggy x.d  pwd=".`pwd` if !-d x.d;
      };
      y.l_lines = sub { #c
        my $x = shift;
        my $b = shift;
        my $file = shift;
        y.burp->($x);
        for my $m (split "\n", $b) {
            next unless $m;
            x.l->($m);
        }
      };
      y.burp = sub { #c
        my $x = shift;
        my $time = hitime;
        x.hitime ||= $time;
        if ($time - x.hitime > 42) {
            y.wtfy->($x);
        }
      };
      y.wtfy = sub { #c
        my $x = shift;
        my $link = x.fi.'.s';

        my $s = readlink $link if -e $link;
        my $ex = $1 if $s && $s =~ /\.(.+?)$/;
        my ($next) = reverse reverse(@{x.lots}), reverse grep { !$ex || $_ eq $ex && do {$ex=0} } @{x.lots};
        # forth and around
        my $wt = x.t.'.'.$next;

        #y.mk->($x);
        
        sayyl "ln -fs $wt $link";
        
        my $fis = "x.d/$wt";
        if (!-e $fis) {
            fscc($fis, '');
        }
        
        symlink $wt, $link;
        #`ln -fs $wt $link`;

        if ($s) {
            my $sif = x.d.'/'.$s;
            # TODO acquire lock (first hol line in lock file wins, wait 0.1)
            0->sing("cleam$sif", sub {
                my $siz = -s $sif;
                0->timer(2.3, sub {
                    y.squash->($x, $sif, $siz);
                });
            }, begin => 0.4);
        }
      };
      y.squash = sub { #c
        my $x = shift;
        my $sif = shift;
        my $siz = shift;
        my $siz2 = -s $sif;
        if ($siz != $siz2) {
            warn "$sif got written to sinze changing link!?";
        }
        
        fspu($sif, '');
        
        sayre "Cleaned $sif";
      };
      y.tailf = sub { #c
        my $x = shift;
        my $file = shift;
        sayyl "Tailing $file";

        fscc($file, '');
        die "go figgy $file" unless -f $file;

        my $al = x.s->{$file} ||= {};
        open my $ha, '-|','tail',
            '-s','0.1','-F','-n0',
            $file
            or die $!;
        al.s && al.s->close;
        my $s = al.s = Mojo::IOLoop::Stream->new($ha);
        al.h = $ha;
        al.x = $x;
        al.file = $file;

        $s->on(read => sub {
            my ($s,$b) = @_;
            $H->fixutf8($b);
            y.l_lines->(al.x, $b, al.file);
        });
        $s->on(close => sub {
            my $s = shift;
            die "al.file closed!?";
        });
        $s->on(error => sub {
            my ($s, $err) = @_;
            die "al.file err: $err";
        });
        $s->timeout(0);
        $s->start;
        #$s->reactor->start unless $s->reactor->is_running;
      };
      $y #c
  - K: fspu #c write file
    style: func
    D: |
      my $file = shift;
      my $m = encode_utf8 shift;
      write_cone($file, $m);
      
  - K: fscc #c write >> file
    style: func
    D: |
      my $file = shift;
      my $m = encode_utf8 shift;
      write_cone($file, {append=>1}, $m);
      
  - K: write_cone #c write file (explode: create dir, retry)
    style: func
    D: |
      my @arm = @_;
      my $arm = \@arm;
      return H.G w write_cone[$arm];
      eval { write_file(@arm) };
      if ($@) {
          die $@ unless $@ =~ /sysopen: No such file or directory/;
          my $file = $arm[0];
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          sayre "Write $arm[0] fuckup: $@";
          $@ = "";
      }
      

  - K: djson #c & ejson
    style: func
    D: |
      my $m = shift;
      my $j;

      eval { $j = $H->json->decode(H::encode_utf8($m)) };
      die "JSON DECODE FUCKUP: $@\n\nfor $m\n\n\n\n" if $@;
      die "$m\n\nJSON decoded to ~undef~" unless defined $j;
      $j
  - K: ejson #
    style: func
    D: |
      my $m = shift;
      $H->json->encode($m);
  - K: parse_babble #c
    style: nonbabble
    D: |
            my $eval = shift;
            
            my $AR = qr/(?:\[(.+?)\]|(?:\((.+?)\)))/;
            my $G_name = qr/[\/\w]+/;
            my $Gnv = qr/\$?$G_name/;
            my $mwall = qr/(?:= |^\s*)/m;
            
            
            
            # word or scalar
            my $point = qr/[\w\$\/\->\{\}\*]*[\w\$\/\->\.\}\*]+/;
            
            my $alive = qr/\$[\w]*[\w\->\{\}]+/;
            # a.b.c
            my $dotha = qr/[A-Za-z_]\w{0,3}(?:\.[\w-]*\w+)+/;
            
            my $poing = qr/$alive|G:$point|$dotha/;
            
            # [...]
            my $sqar = qr/\[.+?\]|\(.+?\)/; 
            
            
            
            # Sw
            
            $eval =~ s/(Sw|ws) (?=\w+)/w \$S /sg;
            
            # timer
            
            $eval =~ s/(timer|recur) ($NUM) \{/$1 \$G, $2, sub{/sg;
            
            $eval =~ s/aft \{/accum \$G, \$F[0] => _after_do => sub {/sg;
            
            # io
            $eval =~ s/${mwall}Sur? (\S+) \{/su \$G, "$1", sub{my\$r=shift; /sg;
            $eval =~ s/${mwall}Pu?r (\S+) ([^;]+);$/\$H->pub("$1", $2);/sgm;
            
            
            my $Jsrc = qr/(J\d*(?:\.\w+)?) (\w+)/;
            # thingy, cv => thing
            my $Jlump = qr/(\S+) (\S+)\s+(\S.+)/;
            $eval =~ s/$mwall$Jsrc $Jlump$/$1.$2->("$3\\t$4" => $5);/smg;
            
            #Sur Hostinfo {
            #Pur S/$hol "hostinfo/ack r.m", 'ig'
            
            # waylay
            
            #$eval =~ s/waylay (?:($NUM) )?(\w.+?);/\$G->timer("$1",sub { w $2; },"waylay $2");/sg;
            
            # wholeness Rwish #c
            
            my $sur = qr/ if| unless| for| when|,\s*$|;\s*/;
            my $surn = qr/(?>! if)|(?>! unless)|(?>! for)/;
            my $suro = qr/(?:$sur|(?>!$sur))/;
            
            my $_m = qr/(?: (.+))?/;
            my $_u = qr/(?: ($poing))?/;
            my $ylay = qr/(yl(?: $NUM)?)?/;
            my $_g = qr/($poing )?/;
            
            while ($eval =~ /(?:^| )()(Rw$ylay() ((?:\*\/)?$point)$_m?)$sur?$/gsm) {
                my ($g, $old, $delay, $u, $p, $a, $un) = ($1, $2, $3, $4, $5, $6, $7);
                #say wdump[($1, $2, $3, $4, $5, $6, $7)];
                $g ||= $u.'->{G}' if $u;
                $g ||= '$G';
                $u ||= '$R';
                
                my $ne = ""; # hidden reverse
                $ne = $1 if $a =~ s/($sur)$//;
                
                my @n;
                my @m;
                my $wanr = $a =~ s/^\+ ?//;
                $wanr = 'stick' if $a =~ s/^- ?//;
                for (split /\,| |\, /, $a) {
                    # sweet little pool... $J:geo etc
                    if (/^\$((\w+:)?\S+)$/) {
                        my ($na, $fa) = ($1, $2);
                        if (!$fa) { # fake name, to ar
                            $fa = $na;
                        }
                        else {
                            $na =~ s/^\Q$fa\E//;
                            $fa =~ s/:$//;
                        }
                        $na = '$'.$na unless $na =~ /\S\.\S/;
                        #saygr "from: $a          na: $na";
                        push @n, "$fa => $na" ; # also avail a listy position
                    }
                    else {
                        push @m, $_;
                    }
                }
                unshift @n, '%$ar' if (!@n || $wanr) && $wanr ne "stick"; 
                
                # could use ^ here # edpeak?
                push @n, "m => [".join(',',map{'"'.$_.'"'}@m).']'
                    if @m;
                
                my @e;
                push @e, '"'.$p.'"';
                push @e, "{".join(", ",@n)."}";
                push @e, $u if $u;
                my $en = join ", ", @e;
                
                my $wa = $g.'->w('.$en.')'.$ne;
                
                if ($delay) {
                    $delay =~ /yl ($NUM)/;
                    $delay = $1 || "";
                    $wa = '$G->timer("'.$delay.'",sub { '.$wa.' })';
                }
                
                #saygr " $old \t=>\t$wa \t\t\tg$g \tu$u \tp$p \ta$a \tun$un";
                
                $eval =~ s/\Q$old\E/$wa/          || die "Ca't replace $1\n\n in\n\n$eval";
            }
            
            #c way
            while ($eval =~ 
            /\${0}($poing )?((?<![\$\w])w(aylay(?: $NUM)?)?(?: ($poing))? ($point)( ?$sqar| ?$point|))($sur)?/sg) {
                my ($g, $old, $delay, $u, $p, $a, $un) = ($1, $2, $3, $4, $5, $6, $7);
                $g = $g ? "" : '$G'; # not in $old, over there already

                my @n;
                my $ne = ""; # hidden reverse
                ($ne, $a) = ($a, "") if $a =~ /^$sur$/;
                # ^ caught a bit of conditional syntax after w expr


                push @n, '%$ar' if $a =~ s/^[\(\[]\+ ?// || !$a;
                
                push @n, $a     if $a =~ s/^\(|\)$//sg;
                
                push @n, 
                    map { my($l)=/\$(\w+)/;"$l => $_" } split /, */, $a

                                if $a =~ s/^\[|\]$//sg;
                

                my @e;
                push @e, '"'.$p.'"';
                push @e, "{".join(", ",@n)."}";
                push @e, $u if $u;
                my $en = join ", ", @e;
                
                my $wa = $g."->w(".$en.")".$ne;
                
                if ($delay) {
                    $delay =~ /aylay ($NUM)/;
                    $delay = $1 || "";
                    $wa = '$G->timer("'.$delay.'",sub { '.$wa.' })';
                }
                
                #saygr " $old \t=>\t$wa \t\t\tg$g \tu$u \tp$p \ta$a \tun$un";
                
                $eval =~ s/\Q$old\E/$wa/          || die "Ca't replace $1\n\n in\n\n$eval";
            } 
            
            # 8/9
            
            $eval =~ s/\${0}($poing)? K ($point)(?::($point))?(;| )/
            ($1 || '$G')
            .qq {->K("$2","$3")$4}/seg;
            
            $eval =~ s/(?<!G)0->(\w+)\(/\$G->$1(/sg; 

            $eval =~ s/(?:(?<=\W)|^)(?<!\\)([A-Za-z_]\w{0,3})((?:\.[\w-]*\w+)+)/"\$$1".join"",map {"->{$_}"} grep {length} split '\.', $2;/seg;


            $eval;
  - K: R #c needle extRange
    D: |
      G.A->spawn(R => @_);
  - K: K #c komprende
    D: |
        my $n = shift;
        my $K = shift;
        if (!length $K) {
            $K = $n;
            $n = "R/non/C"; 
        }
        my $A = G.A;
        if ($n =~ /^(\w+)\/(\w+)\/(\w+)$/) {
            $n = $3;
            my $o = $G->K($1,$2);
            $o || die "not finding $o $1 $2\n".wdump(2,$o)
            ."only: ".join(" ",sort keys %{G.A})."\n"
            .join"\n"," And: ",map{$_->pi} @{G.A.n_R};
            $A = o.A;
        }
        
        my $lot = $A->{"n_$n"};
        warn "G::K() no A n_$n: ".$A->pi."  ".join("  ", sort keys %$A) if !$lot;
        $lot ||= [];
        
        $lot = [map{_.i}@$lot];
        @$lot = grep { _.K eq $K } @$lot if $K ne '*';
        

        wantarray ? @$lot : shift @$lot;
  - K: InjC #c
    D: |
        my ($g, $In) = @_;
        while (my ($s, $etc) = each %$In) {
            while (my ($K, $win) = each %$etc) {
                my $C = $g->CsK({K=>$K, s=>$s});
                wish(C=>$C) || die "Wa".wdump[$K, $win, $C, $g];
                $C->from($win);
            }
        }
  - K: D_to_style #c
    D: |
      my ($D, $bb) = @_;
            my $i = 0.01;
            my @cs;
            my $up = sub {
                $bb->{"D.K\t$i"} = join "\n", @cs if @cs;
                @cs = ();
            };
            for my $l (split "\n", D.D) {
                if ($l =~ /^\s*# (\d\S*)/) {
                    my $ni = $1;
                    $up->();
                    $i = $ni;
                }
                push @cs, $l;
            }
            $up->();
  - K: stylekeysort #c
    D: |
      my $d = shift;
      my @r = sort keys %$d;
      
      if (grep { /^\[/ } @r) { 
          my $by = { map {
              my $p = $_;
              $p =~ s/^\[(\d+)/'['.sprintf('%08d', $1)/e;
              $p => $_
           } @r };
           @r = map { $by->{$_} } sort keys %$by;
      }
      @r
  - K: chuntr #c
    D: |
      split /(?=\{|\[|\^)/, shift;
  - K: vimcolor #c
    D: |
      my $string = shift;
      my $h = $H->dig($string);
      my $k = "vimcolor-$h";
      H.r.gest->($k, sub {
          use Text::VimColor;
          my $syntax = Text::VimColor->new(
              string => $string,
              filetype => 'perl',
          );
          return $syntax->html;
      });
  - K: CsK #c TODO C vortex reading # TODO
    D: |
        my ($p, $GG) = @_;
        $GG ||= $G;
        p.s ||= 'C';
        my @topK = delete p.s;
        my @Cs = map { flatline($_) } map { $GG->anyway($_) } @topK;
        @Cs = grep { 0->ip($p, $_) } @Cs if %$p;
        return wantarray ? @Cs : shift @Cs;
  - K: sway #c
    D: |
        # sucks way matching $p # only supports matching K for now
        my ($p, $s, $P) = @_;
        my ($from) = p.from || 0->CsK($p);
        
        $from || defined P.e || return undef;
        
        my $w = $G->nw();
        $w->from($from) if $from;
        $w->from($p) unless $from;
        $w->from($s) if $s && %$s; # merges in B :D
        
        return $w
  - K: B_same #c
    D: |
        my ($u, $i) = @_;
        
        return 1 if exists u.B._ && exists i.B._ && u.B._ eq i.B._;
        
        my @ks = keys %{u.B||{}};
        for my $k (@ks) {
            u.B->{$k} eq i.B->{$k} || return 0;
        }
        return 1;
  - K: loquate #c TODO A sess with vectory text
    D: |
        my ($source, $path, $def) = @_;
        my @moves = split '/', $path;
        my $s = $source;
        until (@moves == 1) {
            my $m = shift @moves;
            $s = $s->{$m};
        }
        my $m = shift @moves;
        my $thing = $s->{$m} ||= $def;
        !ref $thing && die "Oh no! $path led to non-ref $thing from $source";
        return $thing;
  - K: accum #c TODO C vortex i/o
    D: | 
        # TODO path loquation doesn't stretch far re policy, no prob for now.
        my ($src, $ac, $t) = @_;
                
        if ($ac eq "Lo" || $ac eq "Li") {
            $src->{$ac} = $t;
            return;
        }
        
        my $a = 0->loquate($src, $ac, []);
        
        return if $ac eq 'o' && src.i && src.i eq $t;

        if (!grep { $_ eq $t } @$a) {
            push @$a, $t
        }
  - K: deaccum #c
    D: |
        my ($source, $ac, $t) = @_; # takes ip ish $t maybe
        my $a = $source->{$ac} ||= [];
        my $i = 0;
        for (@$a) {
            return 1, splice(@$a, $i, 1) if $_ eq $t;
            $i++;
        }
        return 0;
  - K: slim #c
    style: func
    D: |
      my ($f,$t,$c) = @_;
      ($f,$t,$c) = (40,40,$f) if $f && !$t && !$c;
      ($f,$t,$c) = ($f,$f,$t) if $t && $f && !$c;
      $c = ($c=~/^(.{$t})/s)[0]."..." if length($c) > $f;
      $c
      
  - K: acum #c c array ups, goo
    style: func
    D: |
      my ($n, $y, $c) = @_;
      push @{$n->{$y}||=[]}, $c;
  - K: shtocss #c
    style: func
    D: |
      my $s = shift;
      return join "", map { "$_:$s->{$_};" } sort keys %$s if ref $s eq "HASH";
      return join ";", @$s if ref $s eq "ARRAY";
      return $s
      
  - K: ind #c
    style: func
    D: |
      "$_[0]".join "\n$_[0]", split "\n", $_[1]
  - K: dig #c make a unique art exubertique
      # same exube for same art) (string hash function
    style: func
    D: |
      Digest::SHA::sha1_hex(encode_utf8(shift))

