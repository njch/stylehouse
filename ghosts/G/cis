Ds:
  - K: parse_babble #c
    style: nonbabble
    D: |
      
            my $eval = shift;
            
            my $AR = qr/(?:\[(.+?)\]|(?:\((.+?)\)))/;
            my $G_name = qr/[\/\w]+/;
            my $Gnv = qr/\$?$G_name/;
            
            # 5/9
            
            $eval =~ s/(Sw|ws) (?=\w+)/w \$S /sg;
            
            $eval =~ s/(Say|Info|Err) (([^;](?! if ))+)/\$H->$1($2)/sg;
            $eval =~ s/T (?=->)/->T() /sg;
            
             
            # 6/9 - motionless subway
            
            $eval =~ s/timer $NUM? \{(.+?)\}/\$G->timer($1, sub { $3 })/sg;
            $eval =~ s/waylay $NUM?(\w.+?);/\$G->timer("$1",sub { w $2; },"waylay $2");/sg;
            
            my $point = qr/[\w\$\/\->\{\}]*[\w\$\/\->\.\}]+/;
            
            my $alive = qr/\$[\w]*[\w\->\{\}]+/;
            
            my $dotha = qr/[A-Za-z_]\w{0,3}(?:\.[\w-]*\w+)+/;
            my $poing = qr/$alive|G:$point|$dotha/;
            
            my $sqar = qr/\[.+?\]|\(.+?\)/; 
            
            my $sur = qr/ if| unless| for/;
            my $surn = qr/(?>! if)|(?>! unless)|(?>! for)/;
            my $suro = qr/(?:$sur|(?>!$sur))/;
            
            while ($eval =~
            /\${0}($poing )?((?<![\$\w])w(?: ($poing))? ($point)( ?$sqar| ?$point|))($sur)?/sg) {
                my ($g, $old, $u, $p, $a, $un) = ($1, $2, $3, $4, $5, $6);
                
                if (!$g) {
                    $g = '$G';
                }
                else {
                    $g = ""
                }

                my @n;
                my $ne = ""; # hidden reverse
                ($ne, $a) = ($a, "") if $a =~ /^$sur$/;
                # ^ caught a bit of conditional syntax after w expr


                push @n, '%$ar' if $a =~ s/^[\(\[]\+ ?// || !$a;
                
                push @n, $a     if $a =~ s/^\(|\)$//sg;
                
                push @n, 
                    map { my($l)=/\$(\w+)/;"$l => $_" } split /, */, $a

                                if $a =~ s/^\[|\]$//sg;
                

                my @e;
                push @e, qq["$p"];
                push @e, "{".join(", ",@n)."}";
                push @e, $u if $u;
                my $en = join ", ", @e;
                
                my $wa = $g."->w(".$en.")".$ne;
                
                
                #saygr " $old \t=>\t$wa \t\t\tg$g \tu$u \tp$p \ta$a \tun$un";
                
                $eval =~ s/\Q$old\E/$wa/          || die "Ca't replace $1\n\n in\n\n$eval";
            }
            
            # 8/9

            $eval =~ s/G!($Gnv)/G\.A->spawn(G => "$1")/sg;
            $eval =~ s/G-($Gnv)/\$G->Gf("$1")/sg;
            $eval =~ s/G:($Gnv)/HGf("$1")/sg;

            $eval =~ s/(?<!G)0->(\w+)\(/\$G->$1(/sg; 

            $eval =~ s/(?:(?<=\W)|^)([A-Za-z_]\w{0,3})((?:\.[\w-]*\w+)+)/"\$$1".join"",map {"->{$_}"} grep {length} split '\.', $2;/seg;


            $eval;
  - K: InjC #c
    D: |
        my ($g, $In) = @_;
        while (my ($s, $etc) = each %$In) {
            while (my ($K, $win) = each %$etc) {
                my $C = $g->CsK({K=>$K, s=>$s});
                wish(C=>$C) || die "Wa".wdump[$K, $win, $C, $g];
                $C->from($win);
            }
        }
  - K: D_to_style #c
    D: |
      my ($D, $bb) = @_;
            my $i = 0.001;
            my @cs;
            my $up = sub {
                $bb->{"D.K\t$i"} = join "\n", @cs if @cs;
                @cs = ();
            };
            for my $l (split "\n", D.D) {
                if ($l =~ /^\s*# (\d\S*)/) {
                    my $ni = $1;
                    $up->();
                    $i = $ni;
                }
                push @cs, $l;
            }
            $up->();
  - K: stylekeysort #c
    D: |
      my $d = shift;
      my @r = sort keys %$d;
      
      if (grep { /^\[/ } @r) { 
          my $by = { map {
              my $p = $_;
              $p =~ s/^\[(\d+)/'['.sprintf('%08d', $1)/e;
              $p => $_
           } @r };
           @r = map { $by->{$_} } sort keys %$by;
      }
      @r
  - K: chuntr #c
    D: |
      split /(?=\{|\[|\^)/, shift;
  - K: vimcolor #c
    D: |
      my $string = shift;
      my $h = $H->dig($string);
      my $k = "vimcolor-$h";
      H.r.gest->($k, sub {
          use Text::VimColor;
          my $syntax = Text::VimColor->new(
              string => $string,
              filetype => 'perl',
          );
          return $syntax->html;
      });
  - K: CsK #c TODO C vortex reading # TODO
    D: |
        my ($p, $GG) = @_;
        $GG ||= $G;
        p.s ||= 'Cs C';
        my @topK = split ' ', delete p.s;
        my @Cs = map { flatline($_) } map { $GG->anyway($_) } @topK;
        @Cs = grep { 0->ip($p, $_) } @Cs if %$p;
        return wantarray ? @Cs : shift @Cs;
  - K: sway #c
    D: |
        # sucks way matching $p # only supports matching K for now
        my ($p, $s, $P) = @_;
        my ($from) = p.from || 0->CsK($p);
        
        $from || defined P.e || die "no C: p.K (G.name)".wdump([$p,$s]);
        
        my $w = $G->nw();
        $w->from($from) if $from;
        $w->from($p) unless $from;
        $w->from($s) if $s && %$s; # merges in B :D
        
        return $w
  - K: B_same #c
    D: |
        my ($u, $i) = @_;
        
        return 1 if exists u.B._ && exists i.B._ && u.B._ eq i.B._;
        
        my @ks = keys %{u.B||{}};
        for my $k (@ks) {
            u.B->{$k} eq i.B->{$k} || return 0;
        }
        return 1;
  - K: loquate #c TODO A sess with vectory text
    D: |
        my ($source, $path, $def) = @_;
        my @moves = split '/', $path;
        my $s = $source;
        until (@moves == 1) {
            my $m = shift @moves;
            $s = $s->{$m};
        }
        my $m = shift @moves;
        my $thing = $s->{$m} ||= $def;
        !ref $thing && die "Oh no! $path led to non-ref $thing from $source";
        return $thing;
  - K: accum #c TODO C vortex i/o
    D: | 
        # TODO path loquation doesn't stretch far re policy, no prob for now.
        my ($src, $ac, $t) = @_;
                
        if ($ac eq "Lo" || $ac eq "Li") {
            $src->{$ac} = $t;
            return;
        }
        
        my $a = 0->loquate($src, $ac, []);
        
        return if $ac eq 'o' && src.i && src.i eq $t;

        if (!grep { $_ eq $t } @$a) {
            push @$a, $t
        }
  - K: deaccum #c
    D: |
        my ($source, $ac, $t) = @_; # takes ip ish $t maybe
        my $a = $source->{$ac} ||= [];
        my $i = 0;
        for (@$a) {
            return 1, splice(@$a, $i, 1) if $_ eq $t;
            $i++;
        }
        return 0;

