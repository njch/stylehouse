Ds:
  - K: fspu #c write file
    style: func
    D: |
      my $file = shift;
      my $m = encode_utf8 shift;
      write_cone($file, $m);
      
  - K: fscc #c write >> file
    style: func
    D: |
      my $file = shift;
      my $m = encode_utf8 shift;
      write_cone($file, {append=>1}, $m);
      
  - K: tai #c
    D: |
      my ($f,$n) = 0->taR(@_);
      fspu($f, "$n\n");
      #saybl '  tai fspu '.$f.'    '.slim(30, $n);
  - K: tac #c
    D: |
      my ($f,$n) = 0->taR(@_);
      fscc($f, "$n\n");
      #saybl '  tac fscc '.$f.'    '.slim(30, $n);
  - K: tas #c
    D: |
      my ($fs,$n,$x) = 0->taR(@_);
      my $f = 0->msc($x);
      fscc($f, "$n\n");
      #saybl '  tas fscc '.$f.'    '.slim(30, $n);
  - K: tri #c try read
    D: |
      my ($f) = 0->taR(@_);
      return if !-f $f;  
      read_file($f);
  - K: taR #c
    D: |
      # MZ $f,$n
      my ($f, $n) = @_;
      my $x = 0->spc($f);
      $n = zjson($n) if ref $n;
      (x.fi, $n, $x)
  - K: zjson #c .J ignore for aj
    style: func
    D: |
      my $n = shift;
      if (n.J) {
          $n = {%$n};
          delete n.J;
      }
      sjson($n)
      
  - K: ztm #c {y,id} for .s
    style: func
    D: |
      my $aj = shift;
      return {map{$_=>$aj->{$_}}'y','id'};
  - K: ily #c as su
    D: |
        say "Jep: ".join '  ', @_;
        my $l = pop;
        my $x = 0->spc(@_);
        x.l = $l;
        
        saybl "        ily: x.fi"; 

        for (@{x.lots}) {
            my $file = x.fi.'.'.$_;
            
            $G->tailf($x, $file);
        }

        $G->wtfy($x);
        $x
  - K: su #c ^ ily
    D: |
      0->ily(@_);
  - K: pub #c
    D: |
       my ($S, $m, $ig) = @_;
       sayyl "H pub $S < ".G::slim(50,50,$m) if !$ig;
       $G->tas($S, $m);

      
  - K: spc #c interpret a space of ? (def. life/)
    D: |
      my $f = pop;
      if ($f =~ /\x{0}/) {
          run(-in => sub{ print $f."\n"; },
              -out => '/tmp/fuuf',
              'xxd');
          sayre "NON ! ".`cat /tmp/fuuf`; 
      }
      my $o = pop || G.lifespot || 'life';
      my $fi = "$o/$f";
      my $x = G.taily.f->{$fi} ||= {};
        if (!x.fi) {
            x.fi = $fi;
            x.f = $f;
            x.o = $o;
            $fi =~ /^(.+)\/(.+?)$/;
            x.t = $2;
            x.d = $1;
            x.lots = ['sc','sc2'];
        }
        for (grep {$x->{$_} =~ /\x{0}/} keys %$x) {
            say "nully $_ => $x->{$_}";
            run(-in => sub{ print $x->{$_}."\n"; },
              -out => '/tmp/fuuf',
              'xxd');
            #say "MSC ZOOP:", ''.`cat /tmp/fuuf`;
        }
        if (0){
          }
      $x
  - K: msc #c catch movign zipper      M    S    C dont really need, write at .s if exists
    D: |
      my $x = ref $_[0] ? $_[0] : 0->spc(@_);
      my $link = x.fi.'.s';
      
      return $link if -l $link;
      
        my $s = `readlink $link` || do {
            $link =~ s/[^\w\/\-\.]//g; # TODO nully
            `readlink $link` || do {
                say "try again: $link";
                my $jsu = `ls -l $link`;
                sayre ' lsd: '.$jsu;
                saybl "JSU ". `pwd`;
                $jsu =~ /-> (.+)$/sgm;
                sayre " re - $1";
                $1;
            };
        };
        chomp $s;
        sayre "msc $link -> '$s'" unless $s =~ /^(J|Hostinfo|doc)\./;
        if (!$s) {
            say "auto sc (said $s) x.fi    from $link";
            $G->wtfy($x); # makes a .s -> .sc
            $H->snooze(2500);
            G.mscily++;
            die "TOO MUCH TRIP looking for $link" if G.mscily > 5;
            my $f = $G->msc($x);
            G.mscily--;
            return $f;
        }
        # so appends can sense together before even .cing
        x.d.'/'.$s
  - K: wtfy #c ye
    D: |
        my $x = shift;
        my $link = x.fi.'.s';

        my $s = readlink $link if -e $link;
        my $ex = $1 if $s && $s =~ /\.(.+?)$/;
        my ($next) = reverse reverse(@{x.lots}), reverse grep { !$ex || $_ eq $ex && do {$ex=0} } @{x.lots};
        # forth and around
        my $wt = x.t.'.'.$next;

        sayyl "ln -fs $wt $link";
        
        my $fis = "x.d/$wt";
        if (!-e $fis) {
            fscc($fis, '');
        }
        
        symlink $wt, $link;
        #`ln -fs $wt $link`;

        if ($s) {
            my $sif = x.d.'/'.$s;
            # TODO acquire lock (first hol line in lock file wins, wait 0.1)
            0->sing("cleam$sif", sub {
                my $siz = -s $sif;
                0->timer(2.3, sub {
                    $G->squash($x, $sif, $siz);
                });
            }, begin => 0.4);
        }
  - K: squash #c sas
    D: |
        my $x = shift;
        my $sif = shift;
        my $siz = shift;
        my $siz2 = -s $sif;
        if ($siz != $siz2) {
            #warn "$sif got written to sinze changing link!?";
        }
        
        fspu($sif, '');
        
        sayre "Cleaned $sif";
  - K: tailf #c ye
    D: |
        my $x = shift;
        my $file = shift;
        sayyl "Tailing $file";

        fscc($file, '');
        die "go figgy $file" unless -f $file;

        my $al = x.s->{$file} ||= {};
        open my $ha, '-|','tail',
            '-s','0.1','-F','-n0',
            $file
            or die $!;
        al.s && al.s->close;
        my $s = al.s = Mojo::IOLoop::Stream->new($ha);
        al.h = $ha;
        al.x = $x;
        al.file = $file;

        $s->on(read => sub {
            my ($s,$b) = @_;
            $H->fixutf8($b);
            $G->l_lines(al.x, $b, al.file);
        });
        $s->on(close => sub {
            my $s = shift;
            die "al.file closed!?";
        });
        $s->on(error => sub {
            my ($s, $err) = @_;
            die "al.file err: $err";
        });
        $s->timeout(0);
        $s->start;
        #$s->reactor->start unless $s->reactor->is_running;
  - K: burp #c ye
    D: |
        my $x = shift;
        my $file = shift;
        my $time = hitime;
        x.hitime ||= $time;
        if ($time - x.hitime > 42 && -s $file > 8000) {
            $G->wtfy($x);
        }
    
  - K: l_lines #c ye
    D: |
        my $x = shift;
        my $b = shift;
        my $file = shift;
        
        $G->burp($x, $file);
        
        if($b =~ /\x{0}/) {
            say "nully $b =>";
            run(-in => sub{ print "$b\n"; },
              -out => '/tmp/fuuf',
              'xxd');
            say "MSC ZOOP:", ''.slim(100,`cat /tmp/fuuf`);
        }
        for my $m (split "\n", $b) {
            next unless $m;
            
            x.l->($m);
        }
  - K: write_cone #c write file (explode: create dir, retry)
    style: func
    D: |
      my @arm = @_;
      my $arm = \@arm;
      return H.G w write_cone[$arm];
      eval { write_file(@arm) };
      if ($@) {
          die $@ unless $@ =~ /sysopen: No such file or directory/;
          my $file = $arm[0];
          sayre "Write $arm[0] fuckup: $@";
          $@ = "";
      }
      
  - K: djson #c
    style: func
    D: |
      my $m = shift;
      my $j;

      eval { $j = $H->json->decode(H::encode_utf8($m)) };
      die "JSON DECODE FUCKUP: $@\n\nfor $m\n\n\n\n" if $@;
      die "$m\n\nJSON decoded to ~undef~" unless defined $j;
      $j
  - K: ejson #c
    style: func
    D: |
      my $m = shift;
      $H->json->encode($m);
  - K: sjson #c
    style: func
    D: |
      my $m = shift;
      H.canon||= do {
         my $j = new JSON::XS;
         $j->canonical(1);
         $j
      };
      H.canon->encode($m);
  - K: jsq #c
    style: func
    D: |
      my ($s,@e) = @_;
      sprintf $s, map { ejson($_) } @e
  - K: E #c
    style: func
    D: |
      $H->send(@_);
  - K: parse_babble #c
    style: nonbabble
    D: |
            my $eval = shift;
            
            my $AR = qr/(?:\[(.+?)\]|(?:\((.+?)\)))/;
            my $G_name = qr/[\/\w]+/;
            my $Gnv = qr/\$?$G_name/;
            my $mwall = qr/(?:= |^\s*)/m;
            
            
            
            
            # word or scalar
            my $point = qr/[\w\$\/\->\{\}\*]*[\w\$\/\->\.\}\*]+/;
            
            my $alive = qr/\$[\w]*[\w\->\{\}]+/;
            # a.b.c
            my $dotha = qr/[A-Za-z_]\w{0,3}(?:\.[\w-]*\w+)+/;
            
            my $poing = qr/$alive|G:$point|$dotha/;
            
            # [...]
            my $sqar = qr/\[.+?\]|\(.+?\)/; 
            
            
            
            # Sw
            
            $eval =~ s/(Sw|ws) (?=\w+)/w \$S /sg;
            
            # timer
            
            $eval =~ s/(timer|recur) ($NUM) \{/$1 \$G, $2, sub{/sg;
            
            $eval =~ s/aft \{/accum \$G, \$F[0] => _after_do => sub {/sg;
            
            
            my $Jsrc = qr/(J\d*(?:\.\w+)?) (\w+)/;
            # thingy, cv => thing
            my $Jlump = qr/(\S+) (\S+)\s+(\S.+)/;
            $eval =~ s/$mwall$Jsrc $Jlump$/$1.$2->("$3\\t$4" => $5);/smg;
            
            $eval =~ s/($mwall)(\w?J)n\(/$1$2\.no->(\$$2, /smg;
            $eval =~ s/($mwall)(\w?M)n\(/${1}J\.no->(\$$2, /smg;
            
            
            #$eval =~ s/waylay (?:($NUM) )?(\w.+?);/\$G->timer("$1",sub { w $2; },"waylay $2");/sg;
            
            # wholeness Rwish #c
            
            my $sur = qr/ if| unless| for| when|,\s*$|;\s*/;
            my $surn = qr/(?>! if)|(?>! unless)|(?>! for)/;
            my $suro = qr/(?:$sur|(?>!$sur))/;
            
            my $_m = qr/(?: (.+))?/;
            my $_u = qr/(?: ($poing))?/;
            my $ylay = qr/(yl(?: $NUM)?)?/;
            my $_g = qr/($poing )?/;
            
            while ($eval =~ /(?:^| )()(Rw$ylay() ((?:\*\/)?$point)$_m?)$sur?$/gsm) {
                my ($g, $old, $delay, $u, $p, $a, $un) = ($1, $2, $3, $4, $5, $6, $7);
                #say wdump[($1, $2, $3, $4, $5, $6, $7)];
                $g ||= $u.'->{G}' if $u;
                $g ||= '$G';
                $u ||= '$R';
                
                my $ne = ""; # hidden reverse
                $ne = $1 if $a =~ s/($sur)$//;
                
                my @n;
                my @m;
                my $wanr = $a =~ s/^\+ ?//;
                $wanr = 'stick' if $a =~ s/^- ?//;
                for (split /\,| |\, /, $a) {
                    # sweet little pool... $J:geo etc
                    if (/^\$((\w+(:|=))?\S+)$/) {
                        my ($na, $fa, $wa) = ($1, $2, $3);
                        if (!$fa) { # fake name, to ar
                            $fa = $na;
                        }
                        else {
                            $na =~ s/^\Q$fa\E//;
                            $fa =~ s/(:|=)$//;
                            if ($wa eq '=') {
                                $na = '"'.$na.'"';
                            }
                        }
                        $na = '$'.$na unless
                            $wa eq '=' || $na =~ /^\S+\.\S/;
                        #saygr "from: $a          na: $na";
                        push @n, "$fa => $na" ; # also avail a listy position
                    }
                    else {
                        push @m, $_;
                    }
                }
                unshift @n, '%$ar' if (!@n || $wanr) && $wanr ne "stick"; 
                
                # could use ^ here # edpeak?
                push @n, "m => [".join(',',map{'"'.$_.'"'}@m).']'
                    if @m;
                
                my @e;
                push @e, '"'.$p.'"';
                push @e, "{".join(", ",@n)."}";
                push @e, $u if $u;
                my $en = join ", ", @e;
                
                my $wa = $g.'->w('.$en.')'.$ne;
                
                if ($delay) {
                    $delay =~ /yl ($NUM)/;
                    $delay = $1 || "";
                    $wa = '$G->timer("'.$delay.'",sub { '.$wa.' })';
                }
                
                #saygr " $old \t=>\t$wa \t\t\tg$g \tu$u \tp$p \ta$a \tun$un";
                
                $eval =~ s/\Q$old\E/$wa/          || die "Ca't replace $1\n\n in\n\n$eval";
            }
            
            #c way
            while ($eval =~ 
            /\${0}($poing )?((?<![\$\w])w(aylay(?: $NUM)?)?(?: ($poing))? ($point)( ?$sqar| ?$point|))($sur)?/sg) {
                my ($g, $old, $delay, $u, $p, $a, $un) = ($1, $2, $3, $4, $5, $6, $7);
                $g = $g ? "" : '$G'; # not in $old, over there already

                my @n;
                my $ne = ""; # hidden reverse
                ($ne, $a) = ($a, "") if $a =~ /^$sur$/;
                # ^ caught a bit of conditional syntax after w expr


                push @n, '%$ar' if $a =~ s/^[\(\[]\+ ?// || !$a;
                
                push @n, $a     if $a =~ s/^\(|\)$//sg;
                
                push @n, 
                    map { my($l)=/\$(\w+)/;"$l => $_" } split /, */, $a

                                if $a =~ s/^\[|\]$//sg;
                

                my @e;
                push @e, '"'.$p.'"';
                push @e, "{".join(", ",@n)."}";
                push @e, $u if $u;
                my $en = join ", ", @e;
                
                my $wa = $g."->w(".$en.")".$ne;
                
                if ($delay) {
                    $delay =~ /aylay ($NUM)/;
                    $delay = $1 || "";
                    $wa = '$G->timer("'.$delay.'",sub { '.$wa.' })';
                }
                
                #saygr " $old \t=>\t$wa \t\t\tg$g \tu$u \tp$p \ta$a \tun$un";
                
                $eval =~ s/\Q$old\E/$wa/          || die "Ca't replace $1\n\n in\n\n$eval";
            } 
            
            # 8/9
            
            $eval =~ s/\${0}($poing)? K ($point)(?::($point))?(;| )/
            ($1 || '$G')
            .qq {->K("$2","$3")$4}/seg;
            
            $eval =~ s/(?<!G)0->(\w+)\(/\$G->$1(/sg; 

            $eval =~ s/(?:(?<=\W)|^)(?<!\\)([A-Za-z_]\w{0,3})((?:\.[\w-]*\w+)+)/"\$$1".join"",map {"->{$_}"} grep {length} split '\.', $2;/seg;


            $eval;
  - K: R #c needle extRange
    D: |
      G.A->spawn(R => @_);
  - K: K #c komprende
    D: |
        my $n = shift;
        my $K = shift;
        if (!length $K) {
            $K = $n;
            $n = "R/non/C"; 
        }
        my $A = G.A;
        if ($n =~ /^(\w+)\/(\w+)\/(\w+)$/) {
            $n = $3;
            my $o = $G->K($1,$2);
            $o || die "not finding $o $1 $2\n".wdump(2,$o)
            ."only: ".join(" ",sort keys %{G.A})."\n"
            .join"\n"," And: ",map{$_->pi} @{G.A.n_R};
            $A = o.A;
        }
        
        my $lot = $A->{"n_$n"};
        #warn "G::K() no A n_$n: ".$A->pi."  ".join("  ", sort keys %$A) if !$lot;
        $lot ||= [];
        
        $lot = [map{_.i}@$lot];
        @$lot = grep { _.K eq $K } @$lot if $K ne '*';
        

        wantarray ? @$lot : shift @$lot;
  - K: InjC #c
    D: |
        my ($g, $In) = @_;
        while (my ($s, $etc) = each %$In) {
            while (my ($K, $win) = each %$etc) {
                my $C = $g->CsK({K=>$K, s=>$s});
                wish(C=>$C) || die "Wa".wdump[$K, $win, $C, $g];
                $C->from($win);
            }
        }
  - K: D_to_style #c
    D: |
      my ($D, $bb) = @_;
            my $i = 0.01;
            my @cs;
            my $up = sub {
                $bb->{"D.K\t$i"} = join "\n", @cs if @cs;
                @cs = ();
            };
            for my $l (split "\n", D.D) {
                if ($l =~ /^\s*# (\d\S*)/) {
                    my $ni = $1;
                    $up->();
                    $i = $ni;
                }
                push @cs, $l;
            }
            $up->();
  - K: stylekeysort #c
    D: |
      my $d = shift;
      my @r = sort keys %$d;
      
      if (grep { /^\[/ } @r) { 
          my $by = { map {
              my $p = $_;
              $p =~ s/^\[(\d+)/'['.sprintf('%08d', $1)/e;
              $p => $_
           } @r };
           @r = map { $by->{$_} } sort keys %$by;
      }
      @r
  - K: chuntr #c
    D: |
      split /(?=\{|\[|\^)/, shift;
  - K: CsK #c TODO C vortex reading # TODO
    D: |
        my ($p, $GG) = @_;
        $GG ||= $G;
        p.s ||= 'C';
        my @topK = delete p.s;
        my @Cs = map { flatline($_) } map { $GG->anyway($_) } @topK;
        @Cs = grep { 0->ip($p, $_) } @Cs if %$p;
        return wantarray ? @Cs : shift @Cs;
  - K: sway #c
    D: |
        # sucks way matching $p # only supports matching K for now
        my ($p, $s, $P) = @_;
        my ($from) = p.from || 0->CsK($p);
        
        $from || defined P.e || return undef;
        
        my $w = $G->nw();
        $w->from($from) if $from;
        $w->from($p) unless $from;
        $w->from($s) if $s && %$s; # merges in B :D
        
        return $w
  - K: B_same #c
    D: |
        my ($u, $i) = @_;
        
        return 1 if exists u.B._ && exists i.B._ && u.B._ eq i.B._;
        
        my @ks = keys %{u.B||{}};
        for my $k (@ks) {
            u.B->{$k} eq i.B->{$k} || return 0;
        }
        return 1;
  - K: loquate #c TODO A sess with vectory text
    D: |
        my ($source, $path, $def) = @_;
        my @moves = split '/', $path;
        my $s = $source;
        until (@moves == 1) {
            my $m = shift @moves;
            $s = $s->{$m};
        }
        my $m = shift @moves;
        my $thing = $s->{$m} ||= $def;
        !ref $thing && die "Oh no! $path led to non-ref $thing from $source";
        return $thing;
  - K: accum #c TODO C vortex i/o
    D: | 
        # TODO path loquation doesn't stretch far re policy, no prob for now.
        my ($src, $ac, $t) = @_;
                
        if ($ac eq "Lo" || $ac eq "Li") {
            $src->{$ac} = $t;
            return;
        }
        
        my $a = 0->loquate($src, $ac, []);
        
        return if $ac eq 'o' && src.i && src.i eq $t;

        if (!grep { $_ eq $t } @$a) {
            push @$a, $t
        }
  - K: deaccum #c
    D: |
        my ($source, $ac, $t) = @_; # takes ip ish $t maybe
        my $a = $source->{$ac} ||= [];
        my $i = 0;
        for (@$a) {
            return 1, splice(@$a, $i, 1) if $_ eq $t;
            $i++;
        }
        return 0;
  - K: slim #c
    style: func
    D: |
      my ($f,$t,$c) = @_;
      ($f,$t,$c) = (40,40,$f) if $f && !$t && !$c;
      ($f,$t,$c) = ($f,$f,$t) if $t && $f && !$c;
      $c = ($c=~/^(.{$t})/s)[0]."..".(length($c) - $f) if length($c) > $f;
      $c
      
  - K: slm #c
    style: func
    D: |
      my $s = slim(@_);
      $s =~ s/\.\.(\.|\d+)$//;
      $s
  - K: acum #c c array ups, goo
    style: func
    D: |
      my ($n, $y, $c) = @_;
      push @{$n->{$y}||=[]}, $c;
  - K: shtocss #c
    style: func
    D: |
      my $s = shift;
      return join "", map { "$_:$s->{$_};" } sort keys %$s if ref $s eq "HASH";
      return join ";", @$s if ref $s eq "ARRAY";
      return $s
      
  - K: ind #c
    style: func
    D: |
      "$_[0]".join "\n$_[0]", split "\n", $_[1]
  - K: dig #c string hash
    style: func
    D: |
      Digest::SHA::sha1_hex(encode_utf8(shift))
  - K: snooze #c                   \/\/\////\/\\\/\/\//\/\\\\\/\/////\/\///\\\
    style: func
    D: |
      return Time::HiRes::usleep((shift || 500) * 10);

