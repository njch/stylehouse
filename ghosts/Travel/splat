name: wormhole splatter
tractors:
  - K: Wormhole Splat
    arr_if: |
      $splatname =~ /^\w+$/ && ref $wormhole->{script} eq "ARRAY";
    B_: |
      $splatname
    first_time: |
      my $style = "padding: 1em;position:absolute;overflow:hidden;";
      if ($splatname eq "wing") {
          $style .= "right: 0px;border:5px solid green;width:10em;z-index:20;"
      }
      elsif ($splatname eq "splatselves") {
            $style = "max-width:60%; height: 14em; left:0px; bottom:0px;"
            ."position:absolute; overflow-x: scroll;"
            ."border: 2px solid white; z-index: 10; background: #B247F0;"
            ." color: #030; font-weight: bold; "
      }
      $S->{view} = $H->{sky}->spawn_floozy($G, $splatname, $style);
      
    nonfirst_times: |
      $S->{view}->fadehtml();
    print: |
      $S->{K} .": ". $S->{B}->{_}
hooks:
  load_ways_post: |
    $O->w("splat_wormholes");
  open_line: |
    my $CG = $O->Gf("crawl") || die "no O G crawl";
    
    my $NS = $CG->w('revisit', { line => $line, push_depth => 1 });
    $NS || die "NO!";
    my $wormhole = { script => $NS };
    my $A = Afind[$splatname];
    
    # new stuff, wedge into html like it has in the wormhole
    w script_out[$A, $wormhole, $append];
  splat_wormhole: |
    my ($splatname, $wormhole) = %$ar;
    
    $wormhole = { script => [@{$wormhole->{script}}] }
        if $wormhole eq $G->W;
        
    my $A = Arr[$splatname, $wormhole];
    timer 0.05 { w script_out[$A, $wormhole] };
    
  script_out: |
    my $lines = [];
    my $i = 0;
    for my $line (@{$wormhole->{script}}) {
        if($i++ > 40) {
            push @$lines, "more..."
        }
        push @$lines, w make_line(+ splatname => $A->{B}->{splatname},
            line => $line, R => [], B => {});
    }
    my $th = {
        nospace => 1,
        class => 'menu',
        tuxtstyle => 'width: 100%;',
    };
    $th->{append} = $ar->{append} if $ar->{append};
    
    my $t = $A->{view}->newtext($lines, $th);
    $H->JS("\$('.splat-w').hoverIntent(function(e) {"
    ."\$(this).animate({transform: 'scale(2,2)', 'z-index':50 })}, function(e) {"
    ."\$(this).animate({transform: 'scale(1,1)', 'z-index':'initial'}) });");
    return $t;
  
  go: |
      Info "\n go ".join "  ", %$ar;
      if (exists $ar->{line}) {
          w open_line;
      }
      else {
          $O->w('somewhere', $ar);
      }
      
      # ye
  
  make_line: |
    if (ref $line ne "HASH") {
        return "FUKN ".wdump($line);
    }
    my $ghost = $line->{ghost};

    w line/value; # R <-> B to be tractored

    return { _spawn => [ $R, {
        nospace => 1,
        B => $B,
        tuxtstyle => 'opacity:1; height:120%;position: relative; float: left; background: #0066CC; ',
        tuxts_to_htmls => sub {
            my $texty = shift;
            my $tx = $texty->{tuxts};
            
            w tuxtsB(B => $B, tx => $tx);
            w line/style;
        },
    }]}
  tuxtsB: |
      for (@$tx) {
          next unless $_->{bb};
          $B->{$_->{bb}}->{s} = $_;
      }
  line:
    value: |
      my @atom = qw[d i t o m]; # TODO combine d+i = a
      if ($splatname eq "wing") {
          @atom = qw[t m];
      }
      for my $bb (@atom) {
          my $b = $B->{$bb} = {line => $line, bb => $bb};
          my $v = $G->w("line/$bb/v", {%$ar, b=>$b});
          $v = "!bb=$bb $v" unless ref $v;
          push @$R, $v;
      }
      # ^ v here's the void; many R come to B, pretty much via Texty::mktuxts
    style: |
        while (my ($bb, $b) = each %$B) {
            $G->w("line/$bb/s",{%$ar,
            b => $b, s => $b->{s}, line => $b->{line}});
        }
    m:
      v: |
        my $t = $line->{t};
        my $menu = [];
        
        if (ref $t && "$t" =~ /HASH/ && $t->{GG} && ref $t->{GG} eq "Ghost") {
            push @$menu, $t->{GG} Tw splatmenues;
        }
        
        push @$menu, 't' => sub { w go( thing => $t ) };
        push @$menu, 'Ώ' => sub { w go( wormhole => $t ) }
            if ref $t eq "Wormhole";
        
        {
        contyt => { bb => $b->{bb} },
        _spawn => [ [], {
        nospace => 1,
        event => { menu => $menu },
        class => 'menu',
        tuxtstyle => "font-size:25pt;",
        }]
        }
    t:
      v: |
        my $t = $line->{t};
        if (ref $t) {#text-shadow: 2px 3px 40px #FFFFFF;color:#66CCFF;
            my $ref = ref $t;
            my $name = "$t";
            $name = $t->{name} if $name =~ /HASH/ && $t->{name};
            $name = "@ ".@$t."   " if $ref eq "ARRAY";
            $name = w $t print
                if $ref eq "Way";
            return "!style='color: transparent; font-size:25pt; font-weight: 900; text-shadow: 0 -5px 5px rgba(255,200,125,0.9);' $name";
        }
        ref $t ? "$t" : $t;
      s: |
        my $t = $line->{t};
        die $s->{value} if ref $s->{value};
        $s->{style}.="max-width: 20em; word-wrap:break-word; max-height: 5em; font-weight:900; min-width: 10em;font-size: 15pt; color:#".(
        ref $t ? (ref $t eq "ARRAY" ? "00FF00" 
                  : ref $t eq "HASH" ? "F42211" : "FF6666")
        : "000032"
        ).";";
        $s->{_event} = w line/event;
    event: |
        my $append = $s->{id};
        my $t = $line->{t};
        $splatname eq 'trev' ?
            sub { w go[$splatname, $line, $append] } :
            $splatname eq 'wing' ?
                sub { w go(thing => $t->{B}->{thing}) } :
                sub { w go(thing => $t) };
    d:
      v: |
        $line->{depth}
      s: |
        $s->{class}.=" splat-d";
        $s->{_event} = sub {
            my ($e, $s, $t) = @_;
            $H->JS("\$('.$t->{id}').slideUp();");
        };
        
    i:
      v: |
        $b->{c} = $line->{i};
        w desc/chain(+ c => $b->{c});
      s: |
        $s->{class} .= " splat-w ";
        $s->{style}.=" direction:rtl;width: "
        .(($line->{depth}+1) * 2 + 3)."em;"
            if $line->{depth} > 0;
        
        my $K = $b->{c}->{K};
        
        $s->{style}.="color: #".(
            $K eq 'dsc/%' ? "FF8533" :
            $K eq 'dsc/@' ? "85FF33" :
            'bbb' ).";" if $K;
            
        $s->{_event} = sub { w go(+ thing => $line->{i}) }
    o:
      v: |
        $b->{c} = $line->{o};
        w desc/chain(+ c => $b->{c});
      s: |
        $s->{class} .= " splat-w ";
        $s->{style} .= "font-size:7pt;" if length($s->{value}) > 8;
        $s->{_event} = sub { w go(+ thing => $line->{o}) }
  
  desc:
    chain: |
      return "?" unless $c;
      
      if (ref $c eq "ARRAY") {
          my @cl;
          
          for my $cc (@$c) {
              push @cl,
            scalar w desc/chain(+ c => $cc)
          }
          return "none" unless @cl;
          
          
          my @names = @cl;
          return scalar(@cl)." @names";
      }
      my $l = w $c print;
      unless (defined $l) {
          $l = 
          join ", ",
              map { "$_: $c->{$_}" }
              sort keys %$c;
      }
     
      if (0 && $c->{as_from}) {
          $l .= "<".w desc/chain(+ c => $c->{as_from});
      }
      return $l
    
  wdump: |
    use Data::Dumper;
    $Data::Dumper::Maxdepth = 2;
    return Dumper($in);

  colorf: |
    my $fing = $in;
    my ($l,$r,$b) = @_;
    my ($color) = ($in || "0") =~ /\(0x....(...)/;
    $color ||= $fing if $in && ref \$in eq "SCALAR" && $in =~ /^(\x{3}|\x{6})$/;
    $color ||= "663300";
    $l ||= 0;
    $r ||= 0;
    $b ||= 3;
    return "text-shadow: ${l}px ${r}px ${b}px #$color;";

  random_shadow: |
    my ($rgb) = join", ", map int rand 255, 1 .. 3;
    return "text-shadow: 0px 0px 4px rgb($rgb);";
  random_colour: |
    my ($rgb) = join", ", map int rand 255, 1 .. 3;
    return "rgb($rgb);";
  random_colour_background: |
    my ($rgb) = join", ", map int rand 255, 1 .. 3;
    return "rgb($rgb);";

