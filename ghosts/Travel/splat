name: wormhole splatter
tractors:
  - K: Wormhole Splat
    arr_if: |
      $splatname =~ /\w+/ && ref $wormhole->{script} eq "ARRAY";
    B_: |
      $splatname
    first_time: |
      my $style = "padding: 1em;position:absolute;overflow:hidden;";
      if ($splatname eq "wing") {
          $style .= "bottom:0px;right:0px;border:5px solid green;width:10em;z-index:20;"
      }
      $S->{view} = ($G->{floozal} || $H->{sky})->spawn_floozy($G, $splatname, $style);
      
    nonfirst_times: |
      $S->{view}->fadehtml();
    print: |
      $S->{K} .": ". $S->{B}->{_}
hooks:
  go: |
    Info "\n splat go:   ".join "  ", %$ar;
    exists $ar->{line}
      ? $G->w('open_line', $ar)
      : $O->w('somewhere', $ar);
    
  open_line: |
    my $CG = $O->Gf("crawl") || die "no O G crawl";
    
    my $NS = $CG->w('revisit', { line => $line, push_depth => 1 });
    $NS || die "NO!";
    
    
    my $wormhole = { script => $NS };
    
    my $A = Afind[$splatname];
    # new stuff, wedge into html like it has in the wormhole
    w script_out[$A, $wormhole, $append];
  lcodon: |
    my @files;
    my $t = $line->{t};
    if (ref $t eq "Ghost") {
        @files = @{ $t->{wayfiles} };
    }
    else { die "get codes from $t"; }
    
    for my $file (@files) {
        my $c = Codon->new($H->intro,
            { codo => $H->getapp("Codo"),
            filename => $file }
        );
        $c->{show} = $S->{view}->spawn_floozy($G, "codon-del-$line->{uuid}",  "width:89%; background:#80182; color:#afc; height:23em;", after => $A->{C}->{Line}->{S}->{id});
        $c->display();
    }
  
  Splat: |
    my ($splatname, $wormhole) = %$ar;
    $wormhole = w aWstract[$wormhole];
    my $A = Arr[$splatname, $wormhole];
    w script_out[$A, $wormhole];
  aWstract: |
    $wormhole ne $G->W
        ? $wormhole
        : { script => [@{$wormhole->{script}}] }
  script_out: |
    my $lines = [];
    my $i = 0;
    for my $line (@{$wormhole->{script}}) {
        if($i++ > 400) {
            push @$lines, "more...";
            last;
        }
        my ($splatname, $R, $B) = ($A->{B}->{splatname}, [], {});
        push @$lines, w make_line[$splatname, $R, $B, $line];
    }
    my $th = {
        nospace => 1,
        class => 'menu',
        tuxtstyle => 'width: 100%;',
    };
    $th->{append} = $ar->{append} if $ar->{append};
    
    my $t = $A->{view}->newtext($lines, $th);
    $H->JS("\$('.splat-w').hoverIntent(function(e) {"
    ."\$(this).animate({transform: 'scale(2,2)', 'z-index':50 })}, function(e) {"
    ."\$(this).animate({transform: 'scale(1,1)', 'z-index':'initial'}) });");
    return $t;
  
  make_line: |
    if (ref $line ne "HASH") {
        return "FUKN ".wdump($line);
    }
    my $ghost = $line->{ghost};

    w line/value; # R <-> B to be tractored

    return { _spawn => [ $R, {
        nospace => 1,
        B => $B,
        tuxtstyle => 'opacity:1; height:120%;position: relative; float: left; background: #0066CC; ',
        tuxts_to_htmls => sub {
            my $texty = shift;
            my $tx = $texty->{tuxts};
            
            w tuxtsB(B => $B, tx => $tx);
            w line/style;
        },
    }]}
  tuxtsB: |
      for (@$tx) {
          next unless $_->{bb};
          $B->{$_->{bb}}->{s} = $_;
      }
  line:
    value: |
      my @atom = qw[d i t o m]; # TODO combine d+i = a
      if ($splatname eq "wing") {
          @atom = qw[t m];
      }
      for my $bb (@atom) {
          my $b = $B->{$bb} = {line => $line, bb => $bb};
          my $v = $G->w("line/$bb/v", {%$ar, b=>$b});
          $v = "!bb=$bb $v" unless ref $v;
          push @$R, $v;
      }
      # ^ v here's the void; many R come to B, pretty much via Texty::mktuxts
    style: |
        while (my ($bb, $b) = each %$B) {
            $G->w("line/$bb/s",{%$ar,
            b => $b, s => $b->{s}, line => $b->{line}});
        }
    m:
      v: |
        my $t = $line->{t};
        my $menu = [];
        
        if (ref $t && "$t" =~ /HASH/ && $t->{G} && ref $t->{G} eq "Ghost") {
            push @$menu, $t->{G} Tw splatmenues;
        }
        
        push @$menu, 't' => sub { w go( thing => $t ) };
        push @$menu, 'Ώ' => sub { w go( wormhole => $t ) }
            if ref $t eq "Wormhole";
        push @$menu, '⊟' => sub { w lcodon[$line] }
            if "$t" =~ /Codon|Ghost/;
        
        {
        contyt => { bb => $b->{bb} },
        _spawn => [ [], {
        nospace => 1,
        event => { menu => $menu },
        class => 'menu',
        tuxtstyle => "font-size:25pt;",
        }]
        }
      s: |
        $s->{style} .= "font-size:35pt;";
#c thing
    t:
      v: |
        my $t = $line->{t};
        if ($t && ref $t eq "HASH") {
            # way in like: Hostinfo ->{ file_stream >@ this HASH
            #
            # means we want bring $t->{filename} to the surface and show here
            # organicness just around the corner.....
        }
        "$t";
      s: |
        my $t = $line->{t};
        die $s->{value} if ref $s->{value};
        my $inc = sub { $s->{html}=1;'<t style="color:'.shift.';">'.shift.'</t>' };
        if (ref $t) {#text-shadow: 2px 3px 40px #FFFFFF;color:#66CCFF;
            my $ref = ref $t;
            my $name = "$t";
            if ($name =~ /HASH/) {
                 $name = $t->{name} if $t->{name};
                 $s->{style}.="border:3px solid #$1;"
                 if $t->{id} && $t->{id} =~ m/^\w+-\w{5}(\w{3})/;
            }
            $name = "@ ".$inc->('black', 0+@$t)."   " if $ref eq "ARRAY";
            $name = "ϖ". w $t print
                if $ref eq "Way";
            if ($ref eq "Ghost") {
                my ($n,$w) = $name =~ /^(.+)\(([^\)]+)\)$/;
                $s->{style}.="border:2px solid #$1;"
                    if $n =~ m/^\w+-\w{5}(\w{3})/;
                $s->{html} = 2;
                $name = $inc->('black', $n).$w;
            }
            $s->{value} = $name;
            my $l = length($name);
            my $fs = 25;
            $fs = 17 if $l > 20;
            $fs = 10 if $l > 40;
            $s->{style} .= "font-size:${fs}pt; font-weight: 900; "
            ."text-shadow: ".(@{$line->{o}} ?
              "0 5px 5px #0F3694; "
            : "0 -5px 5px rgba(255,200,125,0.7);")
            .";";
        }
        else {
            if ($t =~ m/^\w+-\w{5}(\w{3})/) {
                $s->{style}.="border:3px solid #$1;";
            }
        }
        $s->{style}.="max-width: 20em; word-wrap:break-word; max-height: 5em; font-weight:900; min-width: 10em;font-size: 15pt; color:#".(
        ref $t ? (ref $t eq "ARRAY" ? "00FF00" 
                  : "$t" =~ "HASH" ? 
                  ( @{$line->{o}} ? "111" : "f82" )
                  : "FF6666")
        : "000032"
        ).";";
        $s->{style} .= "font-size:11pt;font-family:serif;" if !ref $t;
        $s->{_event} = w line/event;
    event: |
        my $append = $s->{id};
        
        my $t = $line->{t};
        $splatname eq 'trev' ?
            sub { w go[$splatname, $line, $append] } :
            $splatname eq 'wing' ?
                sub { w go(thing => $t->{B}->{thing}) } :
                sub { w go(thing => $t) };
    d:
      v: |
        $line->{depth}
      s: |
        $s->{style} .="color: #3D52A8; font-size:20pt; position: absolute; background:none; top:-0.25em;";
        $s->{_event} = sub {
            my ($e, $s, $t) = @_;
            $H->JS("\$('.$t->{id}').slideUp();");
        };
#c i o
    i:
      v: |
        $b->{c} = $line->{i};
        w desc/chain(+ c => $b->{c});
      s: |
        $s->{class} .= " splat-w ";
        $s->{style}.="background:rgba(130,108,33,0.5);direction:rtl;"
            ."width: "
        .(($line->{depth}+1) * 2 + 3)."em;"
            if $line->{depth} > 0;
        
        my $K = $b->{c}->{K};
        
        my $ilt = $line->{i}->{last_line}->{t};
        if ($ilt && ref $ilt
            && "$ilt" =~ "HASH"
            && $ilt->{id}
            && $ilt->{id} =~ /^\w+-\w{5}(\w{3})/) {
                $s->{style}.="border:3px solid #$1;";
        }
        
        $s->{style}.="color: #".(
            $K eq 'dsc/%' ? "FF8533" :
            $K eq 'dsc/@' ? "85FF33" :
            'bbb' ).";" if $K;
            
        $s->{_event} = sub { w go(thing => $line->{i}) }
    o:
      v: |
        $b->{c} = $line->{o};
        w desc/chain(+ c => $b->{c});
      s: |
        $s->{class} .= " splat-w ";
        $s->{style} .= "font-size:7pt;" if length($s->{value}) > 8;
        $s->{style} .= "max-width:15em; background:rgba(130,108,33,0.5);";
        $s->{style} .= "color: #f82;" unless $s->{value} eq "none";
        $s->{_event} = sub { w go(thing => $line->{o}) }
  
  desc:
    chain: |
      return "?" unless $c;
      
      if (ref $c eq "ARRAY") {
          my @cl;
          
          for my $cc (@$c) {
              push @cl,
            scalar w desc/chain(+ c => $cc)
          }
          return "[]" unless @cl;
          
          
          my @names = @cl;
          return scalar(@cl)." @names";
      }
      my $l = w $c print;
      unless (defined $l) {
          $l = 
          join ", ",
              map { "$_: $c->{$_}" }
              sort keys %$c;
      }
     
      if (0 && $c->{as_from}) {
          $l .= "<".w desc/chain(+ c => $c->{as_from});
      }
      return $l
    
  wdump: |
    use Data::Dumper;
    $Data::Dumper::Maxdepth = 2;
    return Dumper($in);

  colorf: |
    my $fing = $in;
    my ($l,$r,$b) = @_;
    my ($color) = ($in || "0") =~ /\(0x....(...)/;
    $color ||= $fing if $in && ref \$in eq "SCALAR" && $in =~ /^(\x{3}|\x{6})$/;
    $color ||= "663300";
    $l ||= 0;
    $r ||= 0;
    $b ||= 3;
    return "text-shadow: ${l}px ${r}px ${b}px #$color;";

  random_shadow: |
    my ($rgb) = join", ", map int rand 255, 1 .. 3;
    return "text-shadow: 0px 0px 4px rgb($rgb);";
  random_colour: |
    my ($rgb) = join", ", map int rand 255, 1 .. 3;
    return "rgb($rgb);";
  random_colour_background: |
    my ($rgb) = join", ", map int rand 255, 1 .. 3;
    return "rgb($rgb);";

