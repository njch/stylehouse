name: wormhole splatter
tractors:
  - K: Wormholes
    arr_if: |
      $splatname =~ /^\w+$/ && ref $wormhole eq "Wormhole"
    B_: |
      $splatname
    first_time: |
      my $style = "padding: 1em;position:absolute;overflow:hidden;";
      if ($splatname eq "wing") {
          $style .= "right: 0px;border:5px solid green;width:10em;z-index:20;"
      }
      elsif ($splatname eq "splatselves") {
            $style = "max-width:60%; height: 14em; left:0px; bottom:0px;"
            ."position:absolute; overflow-x: scroll;"
            ."border: 2px solid white; z-index: 10; background: #B247F0;"
            ." color: #030; font-weight: bold; "
      }
      $S->{view} = $H->{sky}->spawn_floozy($G, $splatname, $style);
      
    nonfirst_times: |
      $S->{view}->wipehtml();
    arr: blah
hooks:
  load_ways_post: |
    
  splat_wormhole: |
    my ($splatname, $wormhole) = %$ar;
    
    Say "splatting for: $O->{name}", $G->{name};
    
    my $A = A[$splatname, $wormhole];
    
    
    say "Wormhole Splattur: $splatname ".$wormhole->describe_size();
    
    my $lines = [];
    for my $line ($wormhole->star) {
        #say " : $line->{depth} - $line->{t}";
        push @$lines, w make_line(+ line => $line, R => [], B => {});
    }
    my $t = $A->{view}->newtext($lines, {
        nospace => 1,
        class => 'menu',
        tuxtstyle => 'width: 100%; background: #fff;',
    });
  make_line: |
    if (ref $line ne "HASH") {
        return "FUKN ".wdump($line);
    }
    my $ghost = $line->{ghost};

    w line/value;

    return { _spawn => [ $R, {
        nospace => 1,
        B => $B,
        tuxtstyle => 'opacity:1;position: relative; float: left; background: #0066CC; ',
        tuxts_to_htmls => sub {
            my $texty = shift;
            my $tx = $texty->{tuxts};
            
            w tuxtsB(B => $B, tx => $tx);
            w line/style;
        },
    }]}
  tuxtsB: |
      for (@$tx) {
          next unless $_->{bb};
          $B->{$_->{bb}}->{s} = $_;
      }
  gosomewhere: |
      say "\n  Heading to $thing\n\n";
      $O->w('somewhere', {thing => $thing});
      
      
      # ye
  
  line:
    value: |
      my @atom = qw[d i t o m]; # TODO combine d+i = a
      for my $bb (@atom) {
          my $b = $B->{$bb} = {line => $line, bb => $bb};
          my $v = $G->w("line/$bb/v", {%$ar, b=>$b});
          $v = "!bb=$bb $v" unless ref $v;
          push @$R, $v;
      }
      # ^ v here's the void; many R come to B, pretty much via Texty::mktuxts
    style: |
        while (my ($bb, $b) = each %$B) {
            $G->w("line/$bb/s",{%$ar,
            b => $b, s => $b->{s}, line => $b->{line}});
        }
    m:
      v: |
        my $t = $line->{t};
        my $menu = [];
        if (ref $t && ref $t =~ /HASH/) {
            if ($t->{GG}) {
                push @$menu,
                $t->{GG} Tw splatgoes;
            }
        }    
        push @$menu,
          Ώ => sub {
            w gosomewhere(+ thing => $line->{t})
          };
        
        if (ref $t && "$t" =~ /\wHASH/) {
            if ($t->{Ώ}) {
                push @$menu, each %{$t->{Ώ}};
            }
        }
        
        {
        contyt => { bb => $b->{bb} },
        _spawn => [ [], {
        nospace => 1,
        event => { menu => $menu },
        class => 'menu',
        }]
        }
      s: |
        $s->{style}.="border: none;"
    t:
      v: |
        my $t = $line->{t};
        ref $t ? "$t" : $t;
      s: |
        my $t = $line->{t};
        $s->{style}.="font-weight:900; color:#".(
        ref $t ? (ref $t eq "ARRAY" ? "00FF00" 
                  : ref $t eq "HASH" ? "F42211" : "FF6666")
        : "000032"
        ).";";
        $s->{_event} = sub { w gosomewhere(+ thing => $line->{t}) }
    d:
      v: |
        $line->{depth}
      s: |
        $s->{class}.=" splat-d";
        
    i:
      v: |
        $b->{c} = $line->{i};
        w desc/chain(+ c => $b->{c});
      s: |
        $s->{style}.= "direction:rtl;";
        $s->{style}.=" width: ".(($line->{depth}+1) * 2 + 3)."em;";
        if ($line->{depth} == 0) {
            $s->{style}.= "background-color:#445; width: 15em; word-wrap: break-word; ";
        }
        my $K = $b->{c}->{K};
        $K ||= ">:|";
        $s->{style}.="background-color:#".(
            $K eq 'dsc/%' ? "FF8533" :
            $K eq 'dsc/@' ? "85FF33" :
            'bbb' ).";";
        $s->{_event} = sub { w gosomewhere(+ thing => $line->{i}) }
    o:
      v: |
        $b->{c} = $line->{o};
        w desc/chain(+ c => $b->{c});
  
  desc:
    chain: |
      return "?" unless $c;
      
      if (ref $c eq "ARRAY") {
          my @cl;
          
          for my $cc (@$c) {
              push @cl,
            scalar w desc/chain(+ c => $_)
          }
          return join(", ", @cl) || ".";
      }
      my $l =
          $c->{print} ?
          $G->doo($c->{print},
             {c => $c})
        :
          join ", ",
              map { "$_: $c->{$_}" }
              sort keys %$c;
      
     
      if (0 && $c->{as_from}) {
          $l .= "<".w desc/chain(+ c => $c->{as_from});
      }
      return $l
    
  wdump: |
    use Data::Dumper;
    $Data::Dumper::Maxdepth = 2;
    return Dumper($in);

  colorf: |
    my $fing = $in;
    my ($l,$r,$b) = @_;
    my ($color) = ($in || "0") =~ /\(0x....(...)/;
    $color ||= $fing if $in && ref \$in eq "SCALAR" && $in =~ /^(\x{3}|\x{6})$/;
    $color ||= "663300";
    $l ||= 0;
    $r ||= 0;
    $b ||= 3;
    return "text-shadow: ${l}px ${r}px ${b}px #$color;";

  random_shadow: |
    my ($rgb) = join", ", map int rand 255, 1 .. 3;
    return "text-shadow: 0px 0px 4px rgb($rgb);";
  random_colour: |
    my ($rgb) = join", ", map int rand 255, 1 .. 3;
    return "rgb($rgb);";
  random_colour_background: |
    my ($rgb) = join", ", map int rand 255, 1 .. 3;
    return "rgb($rgb);";

