name: wormhole splatter
hooks:
  load_ways_post: |
    $H->getapp("Lyrico")->somewhere();
  
  
    #
  splat_wormhole: |
    
    my $style = "padding: 1em;position:absolute;overflow:hidden;";
    if ($splatname eq "wing") {
        $style .= "right: 0px;border:5px solid green;width:10em;z-index:20;"
    }
        
    my $v = $sky->spawn_floozy($G, $splatname, $style);
    
    say "Wormhole Splattur: $v->{divid}     ".$wormhole->describe_size();
    
    my $lines = [];
    for my $line (@{$wormhole->{script}}) {
        #say " : $line->{depth} - $line->{t}";
        push @$lines, w make_line(+ line => $line, R => [], B => {});
    }
    my $t = $v->newtext($lines, {
        nospace => 1,
        class => 'menu',
        tuxtstyle => 'width: 100%; background: #fff;',
    });
  make_line: |
    my $ghost = $line->{ghost};

    w line/value;

    return { _spawn => [ $R, {
        nospace => 1,
        B => $B,
        tuxtstyle => 'opacity:1;position: relative; float: left; background: #0066CC; ',
        tuxts_to_htmls => sub {
            my $texty = shift;
            my $tx = $texty->{tuxts};
            w tuxtsB(+ tx => $tx);
            w line/style;
        },
    }]}
  tuxtsB: |
      for (@$tx) {
          next unless $_->{bb};
          $B->{$_->{bb}}->{s} = $_;
      }
  
  line:
    value: |
      my @atom = qw[d i t o m]; # TODO combine d+i = a
      for my $bb (@atom) {
          my $b = $B->{$bb} = {line => $line, bb => $bb};
          my $v = $G->w("line/$bb/v", {%$ar, b=>$b});
          $v = "!bb=$bb $v" unless ref $v;
          push @$R, $v;
      }
      # ^ v here's the void; many R come to B
    style: |
        while (my ($bb, $b) = each %$B) {
            $G->w("line/$bb/s",{%$ar,
            b => $b, s => $b->{s}, line => $b->{line}});
        }
    m:
      v: |
        my $t = $line->{t};
        
        my $menu = [
          Ώ => sub {
            my $v =  $line->{t};
            say "\n  Heading to $v\n\n";
            $somewhereness->w('somewhere', {thing => $v});
          },
        ];
        if (ref $t && ref $t eq 'Hostinfo') {
            push @$menu, data => sub {
                $O->{L}->w('somewhere', {thing => $t->data() });
            }
        }
        if (ref $t && "$t" =~ /\w=HASH/) {
            if ($t->{Ώ}) {
                push @$menu, each %{$t->{Ώ}};
            }
        }
        
        {
        contyt => { bb => $b->{bb} },
        _spawn => [ [], {
        nospace => 1,
        event => { menu => $menu },
        class => 'menu',
        }]
        }
      s: |
        $s->{style}.="border: none;"
    t:
      v: |
        my $t = $line->{t};
        ref $t ? "$t" : $t;
      s: |
        my $t = $line->{t};
        $s->{style}.="font-weight:900; color:#".(
        ref $t ? (ref $t eq "ARRAY" ? "00FF00" 
                  : ref $t eq "HASH" ? "F42211" : "FF6666")
        : "000032"
        ).";";
    d:
      v: |
        $line->{depth}
      s: |
        $s->{style}.="color: blue; text-align:right;";
    i:
      v: |
        $b->{c} = $line->{i};
        w desc/chain(+ c => $b->{c});
      s: |
        $s->{style}.= "direction:rtl; min-width:"
        .(($line->{depth}+1) * 2 + 3)."em;";
        if ($line->{depth} == 0) {
            $s->{style}.= "background-color:#445;";
        }
        my $K = $b->{c}->{K};
        $K ||= ">:|";
        $s->{style}.="background-color:#".(
            $K eq 'dsc/%' ? "FF8533" :
            $K eq 'dsc/@' ? "85FF33" :
            '000' ).";";
    o:
      v: |
        $b->{c} = $line->{o};
        w desc/chain(+ c => $b->{c});
  
  desc:
    chain: |
      return "?" unless $c;
      
      if (ref $c eq "ARRAY") {
          my @cl;
          
          for my $cc (@$c) {
              push @cl,
            scalar w desc/chain(+ c => $_)
          }
          return join(", ", @cl) || ".";
      }
      my $l =
          $c->{print} ?
          $G->doo($c->{print},
             {c => $c})
        :
          join ", ",
              map { "$_: $c->{$_}" }
              sort keys %$c;
      
     
      if (0 && $c->{as_from}) {
          $l .= "<".w desc/chain(+ c => $c->{as_from});
      }
      return $l
    
  wdump: |
    use Data::Dumper;
    $Data::Dumper::Maxdepth = 2;
    return Dumper($in);

  colorf: |
    my $fing = $in;
    my ($l,$r,$b) = @_;
    my ($color) = ($in || "0") =~ /\(0x....(...)/;
    $color ||= $fing if $in && ref \$in eq "SCALAR" && $in =~ /^(\x{3}|\x{6})$/;
    $color ||= "663300";
    $l ||= 0;
    $r ||= 0;
    $b ||= 3;
    return "text-shadow: ${l}px ${r}px ${b}px #$color;";

  random_shadow: |
    my ($rgb) = join", ", map int rand 255, 1 .. 3;
    return "text-shadow: 0px 0px 4px rgb($rgb);";
  random_colour: |
    my ($rgb) = join", ", map int rand 255, 1 .. 3;
    return "rgb($rgb);";
  random_colour_background: |
    my ($rgb) = join", ", map int rand 255, 1 .. 3;
    return "rgb($rgb);";

