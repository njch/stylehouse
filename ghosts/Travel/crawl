name: ghost data structure crawl
chains:
 - K: 'dsc/%'
   arr_if: |
     ref $thing eq 'HASH'
     || $G->{depth} == 0
     && ref $thing
     && "$thing" =~ /=HASH/
     
   foreach_travel:
     each: sort keys %$thing
     next_thing: $thing->{$each}
   print: |
     $c->{each}
   
 - K: 'dsc/@'
   arr_if: ref $thing eq 'ARRAY'
   foreach_travel:
     each: @$thing
     next_thing: $each
   print: |
     $c->{i}
hooks:
  arr: |
    my @actcs;
    for my $c ($G->chains) {
        if (w $c arr_if) {
            push @actcs, $c->spawn;
        }
    }
    my @f;
    for my $c (@actcs) {
        push @f, w c_follow_as(+ c => $c);
    }
    @actcs = @f;
    say $_->{K} for @actcs;
    for my $c (@actcs) {
        w figureout(+ c => $c);
    }
    # all these motions we want to grab finer pictures of eventually
    
  figureout: |
    # these borders of my code our data... the language invention streams only just upstream from each other
    
    return if $G->{depth} > 5;
    
    if (my $fe = $c->{foreach_travel}) {
        my @list = $G->doo(
            $fe->{each}, $ar
        );
        my $i = 0;
        for my $each (@list) {
            # eddies of lingo
            my $next_thing = $G->doo(
                $fe->{next_thing}, {%$ar, each => $each}
            );
            my $oc = $c->spawn;
            $oc->{travel_this} = $next_thing;
            $oc->{i} = $i++;
            $oc->{each} = $each;
            
            push @{$G->{o}}, $oc;
        }
    }
    else {
        die "canot figure out".ddump($c);
    }
  c_follow_as: |
    my $as = $c->{as};
      return $c unless $as;
    
    my @really = $G->grep_chains("K" => $as);
    @really == 1 || die "cannot find ref=$c->{as}".ddump($c).ddump(@really);
    
    my $asc = shift @really;
    my $nc = $asc->spawn;
    $nc->{as_from} = $c;
    return $nc

