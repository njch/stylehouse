name: wormhole splatter
hooks:
  splat_wormhole: |
    my $Vs = $O->{Vs} ||= [];
    my $v = $sky->spawn_floozy($O->{wni}++, "position: absolute;");
    my $top = 10;
    for my $ov (@$Vs) {
        $H->JS("\$('#$ov->{divid}').animate({transform: 'scale(0.2,0.1)', bottom: '".$top."px', right: '10px'});")
            unless $ov->{_shrunken}++;
        #$H->JS("\$('#$ov->{divid}').animate({});");
        $top += 50;
    }
    push @$Vs, $v;
    my $wormhole = $G->W;
    say "Wormhole Splattur: $v->{divid}";
    say $wormhole->describe_size();
    
    my $lines = [];
    for my $line (@{$wormhole->{script}}) {
        push @$lines, w make_line(+ line => $line, R => [], B => {});
    }
    my $t = $v->newtext($lines, {
        nospace => 1,
        class => 'menu',
        tuxtstyle => 'width: 100%;',
    });
  load_ways_post: |
    say "Reloaded!";
  make_line: |
    my $ghost = $line->{ghost};

    w $ghost line/value;

    return { _spawn => [ $R, {
        nospace => 1,
        B => $B,
        tuxtstyle => 'position: relative; float: left; border: 1px solid #CCFF33; padding: 2px;',
        tuxts_to_htmls => sub {
            my $texty = shift;
            $ar->{tuxts} = $texty->{tuxts};
            w tuxtsB(+ tuxts => $texty->{tuxts});
            w $ghost line/style;
        },
    }]}
  tuxtsB:
      $B->{$_->{bb}}->{s} = $_ for @$tuxts;
  
  line:
    value: |
      for my $bb (qw[d i t o m]) {
          my $b = $B->{$bb} = {line => $line, bb => $bb};
          my $v = $G->w("line/$bb/v", {%$ar, b=>$b});
          $v = "!bb=$bb $v" unless ref $v;
          push @$R, $v;
      }
      # ^ v here's the void; many R come to B
    style: |
        while (my ($bb, $b) = each %$B) {
            $G->w("line/$bb/s",{%$ar,
            b => $b, s => $b->{s}, line => $b->{line}});
        }
    m:
      v: |
        my $t = $line->{t};
        
        my $menu = [
          Ώ => sub {
            my $v =  $line->{t};
            say "\n  Heading to $v\n\n";
            $O->somewhere($v);
          },
        ];
        
        {
        contyt => { bb => $b->{bb} },
        _spawn => [ [], {
        event => { menu => $menu },
        class => 'menu',
        }]
        }
      s: |
        $s->{style}.="border: none;"
    t:
      v: |
        my $t = $line->{t};
        ref $t ? "$t" : $t;
      s: |
        $s->{style}.="color: #FF6600;" unless ref $line->{t};
        $s->{style}.="color: blue; font-style: underlined;" if ref $line->{t};
    d:
      v: |
        $line->{depth}
      s: |
        $s->{style}.="color: blue;";
    i:
      v: |
        $b->{c} = $line->{i};
        w desc/chain(+ c => $b->{c});
      s: |
        $s->{style}.= "min-width:".($line->{depth} * 2 + 3)."em;";
        for ($b->{c}->{K}) {
            $s->{style}.="background-color:#FF8533;" if $_ eq 'dsc/%';
            $s->{style}.="background-color:#85FF33;" if $_ eq 'dsc/@';
        }
    o:
      v: |
        $b->{c} = $line->{o};
        w desc/chain(+ c => $b->{c});
  
  desc:
    chain: |
      return "?" unless $c;
      
      if (ref $c eq "ARRAY") {
          my @cl;
          
          for my $cc (@$c) {
              push @cl,
            scalar w desc/chain(+ c => $_)
          }
          return join(", ", @cl) || ".";
      }
      my $l =
          $c->{print} ?
          $G->doo($c->{print},
             {c => $c})
        :
          join ", ",
              map { "$_: $c->{$_}" }
              sort keys %$c;
      
     
      if (0 && $c->{as_from}) {
          $l .= "<".w desc/chain(+ c => $c->{as_from});
      }
      return $l
    
  wdump: |
    use Data::Dumper;
    $Data::Dumper::Maxdepth = 2;
    return Dumper($in);

  colorf: |
    my $fing = $in;
    my ($l,$r,$b) = @_;
    my ($color) = ($in || "0") =~ /\(0x....(...)/;
    $color ||= $fing if $in && ref \$in eq "SCALAR" && $in =~ /^(\x{3}|\x{6})$/;
    $color ||= "663300";
    $l ||= 0;
    $r ||= 0;
    $b ||= 3;
    return "text-shadow: ${l}px ${r}px ${b}px #$color;";

  random_shadow: |
    my ($rgb) = join", ", map int rand 255, 1 .. 3;
    return "text-shadow: 0px 0px 4px rgb($rgb);";
  random_colour: |
    my ($rgb) = join", ", map int rand 255, 1 .. 3;
    return "rgb($rgb);";
  random_colour_background: |
    my ($rgb) = join", ", map int rand 255, 1 .. 3;
    return "rgb($rgb);";

