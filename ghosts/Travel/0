name: wormhole splatter
hooks:
  splat_wormhole: |
    say "Wormhole Splattur: $view->{divid}";
    say $wormhole->describe_size();
    
    my $lines = [];
    for my $line (@{$wormhole->{script}}) {
        push @$lines, w make_line({%$ar,
            line => $line,
            R => [],
            B => {},
        });
    }
    $view->wipehtml();
    $view->newtext($lines, {
        spatialise => sub {
            { left => 40, space => 25, top => 50 }
        },
    });
  load_ways_post: |
    say "Reloaded!";
  make_line: |
    my $ghost = $line->{ghost};

    w $ghost line/value($ar);
    

    return { _spawn => [ $R, {
        nospace => 1,
        B => $B,
        tuxtstyle => 'position: relative; float: left; margin-left: 1em; border: 1px solid black; padding: 2px;',
        tuxts_to_htmls => sub {
            my $texty = shift;
            $ar->{tuxts} = $texty->{tuxts};
            w tuxtsB($ar);
            w $ghost line/style($ar);
        },
    }]}
  tuxtsB:
      $B->{$_->{bb}}->{s} = $_ for @$tuxts;
  
  line:
    value: |
      for my $bb (qw[d i o t]) {
          my $b = $B->{$bb} = {line => $line};
          my $v = $G->w("line/$bb/v", {%$ar, b=>$b});
          $v = "!bb=$bb $v";
          say " - $v";
          push @$R, $v;
      }
      # ^ v here's the void; many R come to B
    style: |
        while (my ($bb, $b) = each %$B) {
            $G->w("line/$bb/s",{%$ar,
              b => $b, s => $b->{s}});
        }
    t:
      v: |
        $line->{thing}
      s: |
        $s->{style}.="color: red;";
    d:
      v: |
        $line->{depth}
      s: |
        $s->{style}.="color: blue;";
        $s->{style}.="width: ".($line->{depth} * 4)."em;";
    i:
      v: |
        $b->{c} = $line->{wayin};
        w desc/chain({%$ar, 
              c => ($b->{c} = $line->{wayin})
          })
      s: |
        #hmm
    o:
      v: |
        my $wt = w desc/chain({%$ar, c => $b->{c}});
        w desc/chain({%$ar, 
              c => ($b->{c} = $line->{wayout})
          })
    
  wdump: |
    use Data::Dumper;
    $Data::Dumper::Maxdepth = 2;
    return Dumper($in);
  desc:
    chain: |
      return "?" unless $c;
      
      if (ref $c eq "ARRAY") {
          my @cl;
          say "Ways: ".@$c;
          for my $cc (@$c) {
              push @cl,
            scalar w desc/chain({%$ar, c => $_})
          }
          return join(", ", @cl) || ".";
      }
      my $l =
          $c->{print} ?
          $G->doo($c->{print},
             {c => $c})
        :
          join ", ",
              map { "$_: $c->{$_}" }
              sort keys %$c;
      
     
      if ($c->{as_from}) {
          $l .= "<".w desc/chain({%$ar, 
              c => $c->{as_from},
          });
      }
      return $l
    

  colorf: |
    my $fing = $in;
    my ($l,$r,$b) = @_;
    my ($color) = ($in || "0") =~ /\(0x....(...)/;
    $color ||= $fing if $in && ref \$in eq "SCALAR" && $in =~ /^(\x{3}|\x{6})$/;
    $color ||= "663300";
    $l ||= 0;
    $r ||= 0;
    $b ||= 3;
    return "text-shadow: ${l}px ${r}px ${b}px #$color;";

  random_shadow: |
    my ($rgb) = join", ", map int rand 255, 1 .. 3;
    return "text-shadow: 0px 0px 4px rgb($rgb);";
  random_colour: |
    my ($rgb) = join", ", map int rand 255, 1 .. 3;
    return "rgb($rgb);";
  random_colour_background: |
    my ($rgb) = join", ", map int rand 255, 1 .. 3;
    return "rgb($rgb);";

