name: ghost data structure crawl
chains:
 - look_at_thing: ref $thing eq 'HASH' 
   for: ' [ sort keys %$thing ] '
   travel: ' $thing->{$for} '
 - re f: ARRAY
   for: ' [ @$thing ] '
   travel: ' $for '
hooks:
  arr: |
      W arr_chains();
  arr_chains: |
    for my $c ($G->chains) {
        W arr_chain({c => $c});
    }
  arr_chain: |
    if ($c->{ref} && $c->{ref} eq ref $thing) {
        if ($c->{as}) {
            my @really = $G->grep_chains("ref" => $c->{as});
            die "cannot find ref=$c->{as}".ddump(@really)
                if @really != 1;
            my $new_c = shift @really;
            $c = { %$new_c, as_from => $c };
        }
        push @{$G->{wayout}}, $c;
    }
  umm: |
    for my $c (@{$G->{out}}) {
        if ($c->{note}) {
            push @{ $G->{etc}->{note}||=[] }, $G->doo($c->{note});
        }
    }
  and: |
    for my $c (@{$G->{wayout}}) {
        W and_chain({c => $c});
    }
    if (!@{$G->{away}}) {
        
    }
  and_chain: |
    if ($c->{for}) {
        my $i = 0;
        for my $for (@{ $G->doo($c->{for}) }) {
            if (my $t = $c->{travel}) {
                push @{$G->{away}}, {
                    travel => {
                        thing => $G->doo($t, {for => $for}),
                        way => { %$c, i => $i++, value => $for }
                    }
                };
            }
        }
    }

