name: ghost data structure crawl
chains:
 - K: 'dsc/%'
   arr_if: ref $thing eq 'HASH' 
   foreach_travel:
     each: sort keys %$thing
     next_thing: $thing->{$each}
   print: |
     $c->{each}
   
 - K: 'dsc/@'
   arr_if: ref $thing eq 'ARRAY'
   foreach_travel:
     each: @$thing
     next_thing: $each
   print: |
     $c->{i}
hooks:
  arr: |
    map { w figureout{c => $_} }
    map { w c_follow_as{c => $_} }
    map { $_->spawn }
    grep { w $_ arr_if } # all these motions we want to grab finer pictures of eventually
    $G->chains
    
  figureout: |
    # these borders of my code our data... the language invention streams only just upstream from each other
    
    return if $G->{depth} > 5;
    
    if (my $fe = $c->{foreach_travel}) {
        my @list = $G->doo(
            $fe->{each}
        );
        my $i = 0;
        for my $each (@list) {
            # eddies of lingo
            my $next_thing = $G->doo(
                $fe->{next_thing}, {each => $each}
            );
            my $oc = $c->spawn;
            $oc->{travel_this} = $next_thing;
            $oc->{i} = $i++;
            $oc->{each} = $each;
            
            push @{$G->{o}}, $oc;
        }
    }
    else {
        die "canot figure out".ddump($c);
    }

  c_follow_as: |
    my $as = $c->{as};
      return $c unless $as;
    
    my @really = $G->grep_chains("K" => $as);
    @really == 1 || die "cannot find ref=$c->{as}".ddump($c).ddump(@really);
    
    my $asc = shift @really;
    my $nc = $asc->spawn;
    $nc->{as_from} = $c;
    return $nc

