name: ghost data structure crawl
chains:
 - K: 'dsc/%'
   arr_if: ref $thing eq 'HASH' 
   for: ' [ sort keys %$thing ] '
   travel: ' $thing->{$for} '
   print: |
     $c->{value}
   
 - K: 'dsc/@'
   at_thing: ref $thing eq 'ARRAY'
   for: ' [ @$thing ] '
   travel: ' $for '
   print: |
     $c->{i}
hooks:
  arr: |
    for my $c ($G->chains) {
        if (w $c arr_if) {
    w arr_chains();
  arr_chains: |
    for my $c ($G->chains) {
        w arr_chain({c => $c});
    }
  arr_chain: |
    return if $G->{depth} > 5;
    if (
    if ($c->{at_thing} && $G->doo($c->{at_thing})) {
        $c = { %$c };
        if ($c->{as}) {
            my @really = $G->grep_chains("name" => $c->{as});
            die "cannot find ref=$c->{as}".ddump(@really)
                if @really != 1;
            my $new_c = shift @really;
            $c = { %$new_c, as_from => $c };
        }
        
        push @{$G->{wayout}}, $c;
    }
  umm: |
    for my $c (@{$G->{wayout}}) {
        if ($c->{note}) {
            push @{ $G->{etc}->{note}||=[] }, $G->doo($c->{note});
        }
    }
  and: |
    for my $c (@{$G->{wayout}}) {
        w and_chain({c => $c});
    }
    if (!@{$G->{away}}) {
        
    }
  and_chain: |
    if ($c->{for}) {
        my $i = 0;
        for my $for (@{ $G->doo($c->{for}) }) {
            if (my $t = $c->{travel}) {
                push @{$G->{away}}, {
                    travel => {
                        thing => $G->doo($t, {for => $for}),
                        way => { %$c, i => $i++, value => $for }
                    }
                };
            }
        }
    }

