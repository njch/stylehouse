name: language crux
GG:
 - K: lyr
   way: T/ux
   W_Z: {top: 20em, width: 5em, background: '#fca', z-index: 10, width: 5em}
   W_Ss: [X]
   M_Z: {font-size: 120%} # TODO <style scoped is not scoped... wtf
   
C:
  - K: path
    V: l
    print: |
      my ($what, $for) = %$B;
      die "too many" if %$B > 2;
      ($what ne "thing" ? "$what: " : "").slim(50,40,gpty($for));
    E:
      _D: |
        w somewhere(%$B);
    ux:
      spawn:
       - K: i
       - K: button
  - K: land
    V: l
    print: $name
    styles: land
    ux:
      spawn:
       - K: i
         Z: {font-size: 200%}
       - K: button
    E:
      _D: |
        B.code->() if B.code;
  - K: button
    flows_D: |
      sayre ui.B.name 
    S:
      content_D: |
        "B".ui.B.name
      ishtml: 1
    tag: yw
    styles: yw
      
S:
 - K: ooo
   Ss:
    - K: land
      css: 
        - padding:0.1em
        - max-width:15em
    - K: te
      css: 
        - border-bottom:1px solid black
        - float:left
        - position:relative
        - width:100%
        - background:rgba(150,100,50,0.7)
    - K: yi
      css: [font-size:100%]
    - K: yo
      css: [font-size:40%]
    - K: yt
      css: [color:#873, font-size:80%, padding:1em]
    - K: yw
      css: [font-size:130%]
        
hooks:
  event: |
    sayyl "Event relating to ".pint(L.i);
    0->visTp({L=>$L},'Fun');
    return sw($u) if e.C;
    w $u E/_D;
  fresh_init: |
    $Ly = $G;
    
    my ($mess) = G:mess->anyway('tractors');
    ($mess) = @$mess;
    mess.K eq "mess" || die "some mess";
    0->accum($mess, 'populi/trigs', sub {
        waylay messworm;
    });
    
    G!O/splat;
    G!T/crawl;
    G!L/ob;
    
    G.that = G:Ϡ;
  percolate: |
    0->RW($G);
    0->RW(G.GG.lyr);
    w set_Gdbs;
    w set_land;
    w uxing;
    w f/Lgs;
  uxing: |
    my $xing = ar.xing || $H->make_uuid;
    return say "uxing killed!" if G.uxing->{$xing} == 2;
    G.uxing->{$xing} = 1;
    if (keys %{G.uxing} > 1) {
        say "something else uxing uxing...";
        G.uxing = { map { $_ => 2 } keys %{G.uxing} };
        G.uxing->{$xing} = 1;
    }
    my $Ls = [0->scGre({V=>"l"})];
    return say "L not uxing", $G->timer(3, sub { w uxing[$xing]; }) unless @$Ls;
    say "L UXING!";
    w wux[$Ls];
    $G->timer(27, sub { w uxing[$xing]; });
  wux: |
    G.GG.lyr->w(ux => $ar);
  set_land: |
    my $land = {
       da => [do {
            my $w_f = $G->findway('d');
            map {
                my $k = $_;
                [ $k => sub { sw($G->w("d/$k")) } ]
            } sort keys %$w_f
       }],
       fa => [do {
            my $w_f = $G->findway('f');
            map {
                my $k = $_;
                [ $k => sub { $G->w("f/$k") } ]
            } sort keys %$w_f
       }],
    };
    # Aify {K=land}s so goings away, this now the difinitive list of them
    while (my ($sty, $stuff) = each %$land) {
        my $ty = 0->TafuB(land => {name => $sty});
        for my $d (@$stuff) {
            my ($name, $code) = @$d;
            say "$sty $name";
            my $st = 0->visTp_TafuBl({i=>$ty}, [land => {name => "$sty/$name"}]);
            st.B.code = $code;
        }
    }
  d: 
    "G*": $H->data->{Ghost}
    "wayf": $G->stackway
    "\@F": [@F]
    "Apps": $H->{G}->w('data/get_apps')
    'H': $H
    'L': $G
  keys:
    l: w percolate;
    m: |
        w tog_hmess;
    M: |
      G:splat ->_0('V/toginvis', {k=>'worm'});
    A+n: |
      G:splat ->_0('V/toginvis', {k=>'func'}); # ^ v
    a: |
      G:splat ->_0('V/toginvis', {k=>'somewhere'});
    'À': |
        w f/q;
    q: |
        my $thing = w look_for_ghost(name => 'Њ');
        w somewhere[$thing];
    g: |
        qx'cd ../styleshed && git gui'
  set_Gdbs: |
    $Ghost::db = 1;
    $G->susgdb();
    my @Gdbnah = map { w look_for_ghost(name => $_) }
    
        qw'splat H keys land path crawl sky colour mess ux ob G L';
    for my $g (map { @$_ } @Gdbnah) {
        $g->{db} = -1;
    }
    G._dont_mess_worm = 1;
  f:
    'ccc': | #ccc
      my $deg = -180 + int(rand(360));
      $ar->{V} ||= $H->{sky};
      $H->JS($ar->{V},"css('-webkit-filter', 'brightness(0.8) saturate(1.2) contrast(1.3) hue-rotate(${deg}deg)')");
    'ccm': |
      my $deg = -180 + int(rand(360));
      $H->JS("\$('#worm').css('-webkit-filter', 'brightness(0.5) saturate(0.6) contrast(1.3) hue-rotate(${deg}deg)')");
    'Lgs': |
      w somewhere(thing => "Hello");
    wux: |
      G:Ϡ ->w('wux');
    sW: w somewhere($wormhole => G:splat ->W);
    '⥁': |
      w splat_wormholes
  laterer:
    Gob: w somewhere(W => G:ob->W);
    'Ϡ?': |
      $H->Info("Ϡing... ",G:ob );
      my $th = G:Ϡ;
      th._ob = G:ob;
      0->RW(th._ob);
      eval {
          w somewhere(nothing => $Ly);
      };
      th._ob = undef;
      $H->error("EϠ EϠ EϠ EϠ", $@) if $@;
      $@ = ""         if $@;
      w f/Gob;
  somewhere: |
    return G:Ϡ ->w(Arr => $ar) if ar.nothing;
    return w wormholify if ar.wormhole;
    return w Splat(somewhere => ar.W) if ar.W;
    
    w splatsome;
  a:
    path: |
      my $i = 0->TafuB(path => $ar);
      w wux[$i];
      
  splatsome:
    waylay a/path;
    
    my $Cr = G:crawl;
    $Cr || die;
    my $unc = $Cr->crank(max_depth => $ar->{max_depth}) if defined $ar->{max_depth};
    whisper join"", ("       ẞ           ")x38;
    start_timer();
    
    0->RW($Cr);

    $G->{thething} = $thing;
    $Cr->T($thing, undef, $G->stackway);
    
    
    $unc->() if $unc;
    my $wormhole = $G->{some_W} = $Cr->W;
    my $crawltime = show_delta();

    w splat_wormholes;
  splatpath: |
    G:path ->w(Arr => $ar);
        my $p = {path => G:path->W};
        w Splat(%$p);
  Splat: |
    G:splat ->w(Splat => $ar);
  make_hmess: |
    $G->{_dont_mess_worm} = 0;
    my $wormhole = G:mess->W;
    w somewhere[$wormhole];
  tog_hmess: |
    $G->{_dont_mess_worm}
    ? w make_hmess
    : w hide_hmess;
  hide_hmess: |
        $G->{_dont_mess_worm} = 1;
        my $gs = G:splat;
        $gs ||die;
        gs.V.worm && gs.V.worm->fadehtml();
  messworm: |
    return if $G->{_dont_mess_worm};
    $G->susgdb;
    0->sing(messworm => sub {
        return if $G->{_dont_mess_worm};
        $G->susgdb;
        w make_hmess;
    });
  
    
    
  

  default_somewhere: |
      w look_for_ghost(name => 'Ϡ');
  swap_chains: |
    $_->{_disabled} = !$_->{_disabled} for G:crawl ->allchains;
    $G->timer(0.1, sub {
        w somewhere(thing => $G->{thething});
    });
  
  splat_wormholes: |
    return unless $G->{some_W};
    w Splat(somewhere => $G->{some_W});
  wormholify: |
    w Splat(worm => $wormhole);
  splat_splatW: |
    w Splat(splatW   => {script=>G:splat->W->CS}   );
    #timer 2.5 { w splat_splatW };
  any_child_recoded_init: |
    return if $S->{name} =~ /Ϡ.../;
    w set_land;
    if ($ar->{S}->{way} =~ /crawl/) {
        w getstarted;
    }
  look_for_ghost: |
    [ grep {
      (!$ar->{name} || $_->{name} =~ /$ar->{name}/)
    && 
      (!$ar->{not} || $_->{name} !~ /$ar->{not}/)
    } @{$H->data->{Ghost}} ]

