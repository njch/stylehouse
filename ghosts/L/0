name: Lyricoso writoro

hooks:
  fresh_init: |
    #
    H.G->w('init/future');
    
    G.that = G Ϡ;
    
    w getstarted;
  GG:
    O/splat: 1
    T/crawl: 1
    
    L/path: 1
    L/land: 1
    L/func: 1
    L/ob: 1
    
    #Ϡ: 1
  any_init: |
    waylay set_keys;
    waylay set_Gdbs;
    waylay set_land;
  key:
    m: |
        w tog_hmess;
    M: |
        my $gmw = HGf('H/mess')->W;
        w somewhere(wormhole => $gmw);
    N: |
      G Ϡ ->_0('V/blur');
    n: |
      Say "TOGIN";
      G Ϡ ->_0('V/toginvis');
    a: |
      G splat ->_0('V/toginvis', {k=>'somewhere'});
    'À': |
        w f/q;
    q: |
        my $thing = w look_for_ghost(name => 'Њ');
        w somewhere[$thing];
    g: |
        $H->getapp('Git')->spawn_proc('cd ../styleshed && git gui');
  set_Gdbs: |
    $Ghost::db = 1;
    $G->susgdb();
    
    my @Gdbnah = map {
        w look_for_ghost(name => $_)
        } qw{splat keys land path crawl sky colour mess ux ob uxt yle
        };
    for my $g (map { @$_ } @Gdbnah) {
        #$g->{db} = -1;
    }
  lands: |
    [ "G*",         sub { $H->data->{Ghost} } ],
    [ "wayf",         sub { $G->stackway } ],
    [ "\@F",           sub { [@F] } ],
    [ "Apps",        sub { $H->{G}->w('data/get_apps') } ],
    [ 'H',            sub {  $H } ],
    [ 'L',             sub { $G } ];
  f:
    'ccc': | #ccc
      my $deg = -180 + int(rand(360));
      $ar->{V} ||= $H->{sky};
      $H->JS($ar->{V},"css('-webkit-filter', 'brightness(0.8) saturate(1.2) contrast(1.3) hue-rotate(${deg}deg)')");
    'ccm': |
      my $deg = -180 + int(rand(360));
      $H->JS("\$('#worm').css('-webkit-filter', 'brightness(0.5) saturate(0.6) contrast(1.3) hue-rotate(${deg}deg)')");
      
    'comp': |
      if ($ar->{e}) {
          w f/ccc;
      }
      else {
          G H w grab/next_click; # recalls  Z with $V, etc.
      }
      
    'ЊϠʝ*': |
      my $thing = {
        'Њ' => w look_for_ghost(name => 'Њ'),
        'Ϡ' => w look_for_ghost(name => 'Ϡ'),
        'ʝ' => w look_for_ghost(name => 'ʝ', not => "Ϡ"),
        '*' => w look_for_ghost(not => 'Њ|Ϡ|ʝ'),
      };
      my $max_depth = 2;
      w somewhere[$thing, $max_depth];
    'L>Ϡ': | #c
      my $nothing = G Ϡ ->Gf('ux$');
      w somewhere[$nothing];
    'Lgs': |
      G Ϡ ->w('ux');
    wux: |
      G Ϡ ->w('wux');
    'Ϡdall': |
      G Ϡ ->w('dumpall');
    'Ϡuxt': |
      G Ϡ ->w('anduxt');
    'Ϡ?': |
      $H->Info("Ϡing... ",G ob );
      my $sty = $H->Gf('Ϡ')->Gf('style');
      $sty->{_ob} = G ob;
      $sty->{_ob}->RW();
      eval {
          w somewhere(nothing => $Ly);
      };
      $sty->{_ob} = undef;
      $H->error("EϠ EϠ EϠ EϠ", $@) if $@;
      $@ = ""         if $@;
      w f/Gob;
    Gob: | #c
      my $W = G(ob)->W;
      w somewhere[$W];
    G: |
      w somewhere(thing => $G);
    sW: |
      my $wormhole = G splat ->W;
      w somewhere[$wormhole];
    enclaw: |
      #e t c
    nogr: |
      H.ground->togcl('invis');
      
    '⥁': |
      w splat_wormholes
    futu: |
      $H->{_future} = !$H->{_future};
      $H->Say("\$H->{_future} = $H->{_future}");
    Gdb: |
        $Ghost::db = !$Ghost::db;
        $H->Say("\$Ghost::db = $Ghost::db \n");
        $G->timer(2, sub { w f/anddie; }, "and- die");
    anddie: |
      die "ETC";
    herenow: |
        G splat ->w('go', {thing => $G->stackway("Er", "TC")});
  getstarted: |
    $G->unrush('getstarted') || return;
    #w somewhere(thing => w default_somewhere);
    $G->w('f/Lgs') if G Ϡ;
  splat: |
    
  somewhere: |
    if ($ar->{nothing}) {
        Gf Ϡ ->w(Arr => $ar);
        return;
    }
    if ($ar->{wormhole}) {
        w wormholify;
        return;
    }
    if ($ar->{W}) {
        w Splat(somewhere => $ar->{W});
        return;
    }    
    
    $G->timer(0.1, sub {
        G path ->w(Arr => $ar);
        w Splat(path => G(path)->W);
    }, "splatup path");
    
    my $Cr = G crawl;
    $Cr || die;
    my $unc = $Cr->crank(max_depth => $ar->{max_depth}) if defined $ar->{max_depth};
    say join"", ("       ẞ           ")x38;
    start_timer();
    
    $Cr->RW;

    $G->{thething} = $thing;
    $Cr->T($thing, undef, $G->stackway);
    
    
    $unc->() if $unc;
    my $wormhole = $G->{some_W} = $Cr->W;
    my $crawltime = show_delta();

    w splat_wormholes;
  make_hmess: |
    $G->{_dont_mess_worm} = 0;
    my $wormhole = $H->{G}->Gf('mess')->W;
    w somewhere[$wormhole];
  tog_hmess: |
    $G->{_dont_mess_worm}
    ? w make_hmess
    : w hide_hmess;
  hide_hmess: |
        $G->{_dont_mess_worm} = 1;
        my $gs = G splat;
        $gs ||die;
        gs.V.worm && gs.V.worm->fadehtml();
  messworm: |
    return if $G->{_dont_mess_worm};
    $G->susgdb;
    $G->_0(sing => {
        name => "messworm",
        again_after => 0.5,
        begin_after => 0.2,
        code => sub {
          return if $G->{_dont_mess_worm};
          $G->susgdb;
          w make_hmess;
        },
    });
  
    
    
  
  set_land: |
    for my $t (qw'land func') {
        my $g = $G->Gf($t);
        $g->RW;
        
        my @data;
        @data = w lands if $t eq "land";
        @data = do {
            my $w_f = $G->findway('f');
            map {
                [ $_ => sub { $G->w("f/$_") } ]
            } sort keys %$w_f
        } if $t eq "func";
        for my $d (@data) {
            
            $g->w('Arr', {name => $d->[0], code => $d->[1]});
        }    
        G splat ->w('Splat', {$t => $g->W});
        
    }
  default_somewhere: |
      w look_for_ghost(name => 'Ϡ');
  swap_chains: |
    $_->{_disabled} = !$_->{_disabled} for G crawl ->allchains;
    $G->timer(0.1, sub {
        w somewhere(thing => $G->{thething});
    });
  
  splat_wormholes: |
    return unless $G->{some_W};
    w Splat(somewhere => $G->{some_W});
  wormholify: |
    w Splat(worm => $wormhole);
  splat_splatW: |
    w Splat(splatW   => {script=>G(splat)->W->CS}   );
    #timer 2.5 { w splat_splatW };
  any_child_recoded_init: |
    return if $S->{name} =~ /Ϡ.../;
    w set_land;
    if ($ar->{S}->{way} =~ /crawl/) {
        w getstarted;
    }
  look_for_ghost: |
    [ grep {
      (!$ar->{name} || $_->{name} =~ /$ar->{name}/)
    && 
      (!$ar->{not} || $_->{name} !~ /$ar->{not}/)
    } @{$H->data->{Ghost}} ]

