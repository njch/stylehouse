name: Lyricoso writoro
GG:
 - K: lyr
   way: T/ux
   W_Z: {top: 20em, width: 5em, background: '#fca', z-index: 10, width: 5em}
   W_Ss: [X]
   M_Z: {font-size: 120%}
   
C:
  - K: path
    V: l
  - K: land
    V: l
    print: $name
    Z:
      padding: 0.4em
      background: white
    ux:
      spawn:
       - K: i
       - K: button
    E:
      _D: |
        B.code->() if B.code;
  - K: button
    flows_D: |
      sayre ui.B.name 
    S:
      content_D: |
        "B".ui.B.name
      ishtml: 1
    tag: yw
    styles: yw
      
S:
 - K: ooo
   Ss:
    - K: te
      css: 
        - border-bottom:1px solid black
        - float:left
        - position:relative
        - width:100%
        - background:rgba(150,100,50,0.7)
        
    - K: yi
      css: [font-size:77%]
    - K: yo
      css: [font-size:40%]
    - K: yt
      css: [color:#873, font-size:80%, padding:1em]
    - K: yw
      css: [font-size:130%]
        
hooks:
  event: |
    sayyl "Event relating to ".pint(L.i);
    0->visTp({L=>$L},'Fun');
    sw ($ar);
    w $u E/_D;
  fresh_init: |
    $Ly = $G;
    H.G->w('init/future');
    
    my ($mess) = G:mess->anyway('tractors');
    ($mess) = @$mess;
    mess.K eq "mess" || die "some mess";
    0->accum($mess, 'populi/trigs', sub {
        waylay messworm;
    });
    
    G!O/splat;
    G!T/crawl;
    G!L/path;
    G!L/land;
    G!L/func;
    G!L/ob;
    
    G.that = G:Ϡ;
    
    w getstarted;
  percolate: |
    w set_Gdbs;
    w set_land;
    w uxing;
  uxing: |
    my $xing = ar.xing || $H->make_uuid;
    return say "uxing killed!" if G.uxing->{$xing} == 2;
    G.uxing->{$xing} = 1;
    if (keys %{G.uxing} > 1) {
        say "something else uxing uxing...";
        G.uxing = { map { $_ => 2 } keys %{G.uxing} };
        G.uxing->{$xing} = 1;
    }
    my @Im = 0->scGre({V=>"l"});
    return say "L not uxing", $G->timer(3, sub { w uxing[$xing]; }) unless @Im;
    say "L UXING!";
    G.GG.lyr->w(ux => {Ls => \@Im});
    $G->timer(27, sub { w uxing[$xing]; });
  set_land: |
    my $land = {
       la => [
              [ "G*",         sub { $H->data->{Ghost} } ],
              [ "wayf",         sub { $G->stackway } ],
              [ "\@F",           sub { [@F] } ],
              [ "Apps",        sub { $H->{G}->w('data/get_apps') } ],
              [ 'H',            sub {  $H } ],
              [ 'L',             sub { $G } ],
       ],
       fa => [do {
            my $w_f = $G->findway('f');
            map {
                my $k = $_;
                [ $k => sub { $G->w("f/$k") } ]
            } sort keys %$w_f
       }],
    };
    # Aify {K=land}s so goings away
    while (my ($sty, $stuff) = each %$land) {
        my $ty = 0->TafuB(land => {name => $sty});
        for my $d (@$stuff) {
            my ($name, $code) = @$d;
            say "$sty $name";
            my $st = 0->visTp_TafuBl({i=>$ty}, [land => {name => "$sty/$name"}]);
            st.B.code = $code;
        }
    }
  keys:
    l: w percolate;
    m: |
        w tog_hmess;
    M: |
      my $spla = G:splat;
      spla.V.worm->fadehtml();
    A+n: |
      Say "TOGIN!";
      G:splat ->_0('V/toginvis', {k=>'func'}); # ^ v
    a: |
      G:splat ->_0('V/toginvis', {k=>'somewhere'});
    'À': |
        w f/q;
    q: |
        my $thing = w look_for_ghost(name => 'Њ');
        w somewhere[$thing];
    g: |
        qx'cd ../styleshed && git gui'
  set_Gdbs: |
    $Ghost::db = 1;
    $G->susgdb();
    my @Gdbnah = map { w look_for_ghost(name => $_) }
    
        qw'splat H keys land path crawl sky colour mess ux ob G L';
    for my $g (map { @$_ } @Gdbnah) {
        $g->{db} = -1;
    }
    G._dont_mess_worm = 1;
  f:
    'ccc': | #ccc
      my $deg = -180 + int(rand(360));
      $ar->{V} ||= $H->{sky};
      $H->JS($ar->{V},"css('-webkit-filter', 'brightness(0.8) saturate(1.2) contrast(1.3) hue-rotate(${deg}deg)')");
    'ccm': |
      my $deg = -180 + int(rand(360));
      $H->JS("\$('#worm').css('-webkit-filter', 'brightness(0.5) saturate(0.6) contrast(1.3) hue-rotate(${deg}deg)')");
      
    'comp': |
          w f/ccc;
      
    'ЊϠʝ*': |
      my $thing = {
        'Њ' => w look_for_ghost(name => 'Њ'),
        'Ϡ' => w look_for_ghost(name => 'Ϡ'),
        'ʝ' => w look_for_ghost(name => 'ʝ', not => "Ϡ"),
        '*' => w look_for_ghost(not => 'Њ|Ϡ|ʝ'),
      };
      my $max_depth = 2;
      w somewhere[$thing, $max_depth];
    aaa: |
      my $s = "K↯p↯B";
      $H->send("alert('$s');");
    'L>Ϡ': | #c
      my $nothing = G:Ϡ ->Gf('ux$');
      w somewhere[$nothing];
    'Lgs': |
      w somewhere(thing => "Hello");
      G:Ϡ ->w('ux');
    wux: |
      G:Ϡ ->w('wux');
    'Ϡ?': |
      $H->Info("Ϡing... ",G:ob );
      my $th = G:Ϡ;
      th._ob = G:ob;
      0->RW(th._ob);
      eval {
          w somewhere(nothing => $Ly);
      };
      th._ob = undef;
      $H->error("EϠ EϠ EϠ EϠ", $@) if $@;
      $@ = ""         if $@;
      w f/Gob;
    Gob: | #c
      my $W = G:ob->W;
      w somewhere[$W];
    G: |
      w somewhere(thing => $G);
    sW: |
      my $wormhole = G:splat ->W;
      w somewhere[$wormhole];
    enclaw: |
      #e t c
    nogr: |
      H.ground->togcl('invis');
      
    '⥁': |
      w splat_wormholes
    futu: |
      $H->{_future} = !$H->{_future};
      $H->Say("\$H->{_future} = $H->{_future}");
    Gdb: |
        $Ghost::db = !$Ghost::db;
        $H->Say("\$Ghost::db = $Ghost::db \n");
        $G->timer(2, sub { w f/anddie; }, "and- die");
    anddie: |
      die "ETC";
    herenow: |
        G:splat ->w('go', {thing => $G->stackway("Er", "TC")});
  getstarted: |
    $G->unrush('getstarted') || return;
    #w somewhere(thing => w default_somewhere);
    $G->w('f/Lgs') if G:Ϡ;
  youtube: |
    my $video_id = shift || "PSNPpssruFY"; # Fats Waller - Aint Misbehavin
    my $iframe = '<iframe class="youtube-player" type="text/html" width="640" height="385" src="http://www.youtube.com/embed/'
        .$video_id.'" allowfullscreen frameborder="0"></iframe>';
    my $guru = "http://24.media.tumblr.com/tumblr_lzsfutEA3G1rop013o1_1280.jpg";
  somewhere: |
    return G:Ϡ ->w(Arr => $ar) if ar.nothing;
    return w wormholify if ar.wormhole;
    return w Splat(somewhere => ar.W) if ar.W;
    
    w splatsome;
  splatsome:
    waylay splatpath;
    
    my $Cr = G:crawl;
    $Cr || die;
    my $unc = $Cr->crank(max_depth => $ar->{max_depth}) if defined $ar->{max_depth};
    whisper join"", ("       ẞ           ")x38;
    start_timer();
    
    0->RW($Cr);

    $G->{thething} = $thing;
    $Cr->T($thing, undef, $G->stackway);
    
    
    $unc->() if $unc;
    my $wormhole = $G->{some_W} = $Cr->W;
    my $crawltime = show_delta();

    w splat_wormholes;
  splatpath: |
    G:path ->w(Arr => $ar);
        my $p = {path => G:path->W};
        w Splat(%$p);
  Splat: |
    G:splat ->w(Splat => $ar);
  make_hmess: |
    $G->{_dont_mess_worm} = 0;
    my $wormhole = G:mess->W;
    w somewhere[$wormhole];
  tog_hmess: |
    $G->{_dont_mess_worm}
    ? w make_hmess
    : w hide_hmess;
  hide_hmess: |
        $G->{_dont_mess_worm} = 1;
        my $gs = G:splat;
        $gs ||die;
        gs.V.worm && gs.V.worm->fadehtml();
  messworm: |
    return if $G->{_dont_mess_worm};
    $G->susgdb;
    0->sing(messworm => sub {
        return if $G->{_dont_mess_worm};
        $G->susgdb;
        w make_hmess;
    });
  
    
    
  

  default_somewhere: |
      w look_for_ghost(name => 'Ϡ');
  swap_chains: |
    $_->{_disabled} = !$_->{_disabled} for G:crawl ->allchains;
    $G->timer(0.1, sub {
        w somewhere(thing => $G->{thething});
    });
  
  splat_wormholes: |
    return unless $G->{some_W};
    w Splat(somewhere => $G->{some_W});
  wormholify: |
    w Splat(worm => $wormhole);
  splat_splatW: |
    w Splat(splatW   => {script=>G:splat->W->CS}   );
    #timer 2.5 { w splat_splatW };
  any_child_recoded_init: |
    return if $S->{name} =~ /Ϡ.../;
    w set_land;
    if ($ar->{S}->{way} =~ /crawl/) {
        w getstarted;
    }
  look_for_ghost: |
    [ grep {
      (!$ar->{name} || $_->{name} =~ /$ar->{name}/)
    && 
      (!$ar->{not} || $_->{name} !~ /$ar->{not}/)
    } @{$H->data->{Ghost}} ]

