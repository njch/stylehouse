name: language crux
GG:
 - K: lyr
   way: T/ux
   In:
     C:
       W:
         Z:
           bottom: 0%
           width: 5.5%
           max-height: 90%
           z-index: 10
         Ss: [X]
       M:
         Z:
           font-size: 140% # TODO <style...scoped> is not scoped, applies again and again, wtf
       ux:
         styles: le
   
C:
  - K: path
    V: l
    k: ""
    styles: land path
    print: |
      my ($what, $for) = %$B;
      die "too many" if %$B > 2;
      ($what ne "thing" ? "$what: " : "").slim(24,20,gpty($for));
    E:
      _D: w somewhere(%$B);
    ux:
      spawn:
       - K: button
         
  - K: land
    V: l
    print: $name
    flows_D: |
      S.S.styles .= ' '.($name =~ /^fa/ ? "redish" : "bluish");
    styles: land
    ux:
      spawn:
       - K: button
    E:
      _D: |
        B.code->() if B.code;
        
  - K: button
    S:
      content_D: |
        return slim(30,20,gpty(ui.B.thing)) if ui.B.thing;
        return (split '/', ui.B.name)[-1];
      ishtml: 1
    tag: butt
      
S:
 - K: ooo
   Ss:
    - K: redish
      css:
        - color:rgb(250,100,150)
    - K: bluish
      css:
        - color:rgb(50,50,204)
    - K: path
      css:
        - color:rgb(50,50,255)
        - overflow:display
        - white-space:nowrap
    - K: land
      css: 
        - padding:0.1em
    - K: fplat
      css:
        - -webkit-transform:scale(2,4)
        - -webkit-filter:blur(1px)
        - position:absolute
    - K: le
      css:
        - float:left
        - position:relative
        - width:100%
        - text-shadow:2px 2px 4px rgb(0,0,255)
        - background:rgba(150,100,50,0.2)
    - K: yi
      css: [font-size:400%]
    - K: yo
      css: [font-size:40%]
    - K: yt
      css: [color:#873, font-size:80%, padding:1em]
    - K: yw
      css: [font-size:130%]
        
hooks:
  event: |
    sayyl "Event relating to ".pint(L.i);
    0->visTp({L=>$L},'Fun');
    return sw($u) if e.C;
    w $u E/_D;
  fresh_init: |
    $Ly = $G;
    
    my $mess = G:mess;
    0->accum(G:mess, atrig => sub { waylay hm/messworm; });

    # as GG now
    G!O/splat;
    G!T/crawl;
    G!L/ob;
    
    G.that = G:Ϡ;
    
  channel: |
    ar.cb = sub {
        my $m = shift;
        $G->timer(0.1, sub { w sw(top=>$top, m=>$m); });
        return;
    };
    ar.div ||= 7;
    0->su($ar);
    
  sw: |
    use lib 'sal';
    use H;
    my $thing = eval "my \$VAR1; $m";
    die $@ if $@;
    
    if (G.iggggsw) { Say "igsw"; return; }
    
    w somewhere[$thing];
    
    Say "swthrow ".$G->F_delta;
  recoded_init: |
    waylay set_land;
    w wux;
  percolate: |
    0->RW(G.GG.lyr);
    w set_Gdbs;
    w set_land;
    $G->timer(0.1, sub { 0->ing(26, "uxing"); });
    w f/Lgs;
  wux: |
    0->sing(Lwux => sub {
        G.GG.lyr->w(ux => {Ls => [0->scGre({V=>"l"})]});
    });
  set_land: |
    my $land = {
       da => [do {
            my $w_f = $G->findway('d');
            map {
                my $k = $_;
                [ $k => sub { sw($G->w("d/$k")) } ]
            } sort keys %$w_f
       }],
       fa => [do {
            my $w_f = $G->findway('f');
            map {
                my $k = $_;
                [ $k => sub { $G->w("f/$k") } ]
            } sort keys %$w_f
       }],
    };
    # Aify {K=land}s so goings away, this now the difinitive list of them
    while (my ($sty, $stuff) = each %$land) {
        my $ty = 0->TafuB(land => {name => $sty});
        for my $d (@$stuff) {
            my ($name, $code) = @$d;
            my $st = 0->visTp_TafuBl({i=>$ty}, [land => {name => "$sty/$name"}]);
            st.B.code = $code;
        }
    }
  d: 
    "G*": $H->data->{Ghost}
    "Apps": $H->{G}->w('data/get_apps')
  keys:  
    l: w percolate;
    m: |
        w hm/tog;
    M: |
      G:splat ->_0('V/toginvis', {k=>'worm'});
    A+n: |
      G:splat ->_0('V/toginvis', {k=>'func'}); # ^ v
    a: |
      G:splat ->_0('V/toginvis', {k=>'somewhere'});
    'À': |
        w f/q;
    g: |
        qx'cd ../styleshed && git gui'
  set_Gdbs: | # vortex->logmessages intensity/thresholds # TODO R
    $Ghost::db = 1;
    $G->susgdb();
    my @Gdbnah = map { w look_for_ghost(name => $_) }
    
        qw'splat H keys land path crawl sky colour mess ux ob G L';
    for my $g (map { @$_ } @Gdbnah) {
        $g->{db} = -1;
    }
    G.donthmess = 1;
  f:  
    r: |
      G.iggggsw = !G.iggggsw;
      Say "iggggsw = G.iggggsw";
    c: | # TODO R
      my $deg = -180 + int(rand(360));
      $ar->{V} ||= $H->{sky};
      $H->JS($ar->{V},"css('-webkit-filter', 'brightness(0.8) saturate(1.2) contrast(1.3) hue-rotate(${deg}deg)')");
    Lgs: |
      w somewhere(thing => "Hello");
    ϠϪ: |
      G:Ϡ ->w('ux');
    Ϡϫ: |
      G:Ϡ ->w('wux');
    Lϫ: |
      w wux;
    W: |
      my $W = G:E/h ->W;
      w somewhere(wormhole => $W);
    '⥁': |
      G:splat w Arr(somewhere => G.asplat.W);
  laterer:
    Gob: w somewhere(W => G:ob->W);
    'Ϡ?': |
      $H->Info("Ϡing... ",G:ob );
      my $th = G:Ϡ;
      th._ob = G:ob;
      0->RW(th._ob);
      eval {
          w somewhere(nothing => $Ly);
      };
      th._ob = undef;
      $H->error("EϠ EϠ EϠ EϠ", $@) if $@;
      $@ = ""         if $@;
      w f/Gob;
  somewhere: |
    return G:Ϡ w Arr
        if ar.nothing;
    
    return G:splat w Arr(worm => ar.wormhole)
        if ar.wormhole;
    
    return G:splat w Arr(somewhere => ar.W)
        if ar.W;
    
    $H->send("\$('#somewhere > *').delay(400).fadeOut(400);", sub {
        w splatsome;
    });
  splatsome: |
    0->TafuB(path => $ar);
    start_timer();
    
    my $a = G.asplat = {
        t => $thing,
        i => ar.i || $G->Flab,
    };
    
       my $Cr = G:crawl || return $H->error("splat too early to see...");
    0->RW($Cr);
          $Cr->crank(maxd => ar.maxd) if exists ar.maxd;
    a.W = $Cr->W;
          $Cr->w(crawl => $a);
    
    $G->Flab(asplat => $a);
    
    G:splat w Arr(somewhere => a.W);
    
    sayg "splatsome ".show_delta();
  T:
    traction: |
      my $i = T.i;
      w wux[$i];
      return unless i.K eq "path";
      my @all = 0->rei({K=>'path'});
      pop @all for 1..4;
      0->del($_) for @all;
  hm:
    tog: |
      return w hm/make if G.donthmess;
      w hm/hide;
    make: |
      G.donthmess = 0;
      my $wormhole = G:mess->W;
      w somewhere[$wormhole];
    hide: |
      G.donthmess = 1;
      my $gs = G:splat;
      $gs ||die;
      gs.V.worm && gs.V.worm->fadehtml();
    messworm: |
      return if G.donthmess;
      $G->susgdb;
      0->sing(messworm => sub {
          return if G.donthmess;
          $G->susgdb;
          w hm/make;
      });

    
    
  
  look_for_ghost: |
    [ grep {
      (!$ar->{name} || $_->{name} =~ /$ar->{name}/)
    && 
      (!$ar->{not} || $_->{name} !~ /$ar->{not}/)
    } @{$H->data->{Ghost}} ]
recoded_Cways: 1

