name: Lyricoso writoro

hooks:
  fresh_init: |
    $H->{_future} = 1;
    G TT ->G("T/splat");
    G TT ->G("T/crawl");
    G TT ->G("Ϡ");
    
    G TT ->G("L/path");
    G TT ->G("L/land");
    G TT ->G("L/func");
    G TT ->G("L/ob");
    
    my $Gmess = $H->{G}->Gf('mess');
    $Gmess->{_post_throw} = sub {
        my $S = shift;
        #$H->keep_throwing($S->{B}->{what}, $S->{B}->{error});
        return if $G->{_dont_mess_worm};
        $G->{messworm} = $Gmess->W;
        w messworm;
    };
    
    $H->{G}->Gf('keys')->{trig}->{m} = sub {
        w tog_hmess;
    };
    $H->{G}->Gf('keys')->{trig}->{'À'} = sub {
        w q;
    };
    $H->{G}->Gf('keys')->{trig}->{q} = sub {
        my $thing = w look_for_ghost(name => 'Њ');
        w somewhere[$thing];
    };
    
    w getstarted;
  messworm: |
    return if $G->{_dont_mess_worm};
    $G->_0(sing => {
        name => "messworm",
        again_after => 0.7,
        code => sub {
          return if $G->{_dont_mess_worm};
          my $wormhole = $G->{messworm};
          say "Throgingo $wormhole;";
          w somewhere[$wormhole];
        },
    }, "mess>L");
  
    
    
  
  recoded_init: |
    w set_land;
    w getstarted;
  any_child_recoded_init: |
    w set_land;
    # splat_wormholes;
    Say $ar;
    if ($ar->{S}->{way} =~ /crawl/) {
        w getstarted;
    }
  
  look_for_ghost: |
    [ grep { $_->{name} =~ /$name/ } @{$H->data->{Ghost}} ]
  lands: |
    [ "G*",         sub { $H->data->{Ghost} } ],
    [ 'G*Ϡ', sub { w look_for_ghost(name => 'Ϡ') }    ],
    [ 'G*Њ', sub { w look_for_ghost(name => 'Њ') }    ],
    [ "wayf",         sub { $G->stackway } ],
    [ "\@F",           sub { [@F] } ],
    [ "Apps",        sub { $H->{G}->w('data/get_apps') } ],
    [ 'H',            sub {  $H } ],
    [ 'L',             sub { $G } ];
  q: |
    w somewhere(nothing => $L); 
  funcs: |
    [ chch => sub { w swap_chains; } ],
    [ "L>Ϡ", sub { w q;
    } ],
    [ "_fr",          sub {
        my $Gs = G splat;
        $Gs->{iggysplat}->{"worm"} = !$Gs->{iggysplat}->{"worm"};
        $G->Flab("IGGY worm $Gs->{iggysplat}->{worm}");
        return "and";
    }    ],
    [ "futflip" => sub {
        $H->{_future} = !$H->{_future};
        $H->Say("\$H->{_future} = $H->{_future}");
    }  ],
    [ 'Gdb',          sub {
        $Ghost::db = !$Ghost::db;
        $H->Say("\$Ghost::db = $Ghost::db");
    }    ],    
    [ 'herenow',          sub {
        G splat ->w('go', {thing => $G->stackway});
        say "going now_later";
    }    ];
  make_hmess: |
        $G->{_dont_mess_worm} = 0;
        my $wormhole = $H->{G}->Gf('mess')->W;
        w somewhere[$wormhole];
  tog_hmess: |
    $G->{_dont_mess_worm}
    ? w make_hmess
    : w hide_hmess;
  hide_hmess: |
        $G->{_dont_mess_worm} = 1;
        $G->Flab("Yup yup yup");
        G splat Tw clear(splatname => 'worm');
        return "and";
  
  set_land: |
    my $GG;
    my $f = sub {
        $G->Tw($GG, 'arr', {name => shift, code => shift});
    };
    
    G land ->RW;
    G func ->RW;
    
    $GG = G land; 
    $f->(@$_) for w lands;
    
    
    $GG = G func;
    $f->(@$_) for w funcs;
    
    G splat Tw Splat(land => G(land)->W);
    
    G splat Tw Splat(func => G(func)->W);
  default_somewhere: |
      w look_for_ghost(name => 'Ϡ');
  getstarted: |
    $G->unrush('getstarted') || return;
    w set_land;
    w somewhere(thing => w default_somewhere);
  swap_chains: |
    $_->{_disabled} = !$_->{_disabled} for G crawl ->allchains;
    $G->timer(0.1, sub {
        w somewhere(thing => $G->{thething});
    });
  
  somewhere: |
    if ($ar->{nothing}) {
        Gf Ϡ Tw arr(%$ar);
        return;
    }
    if ($ar->{wormhole}) {
        w wormholify;
        return;
    }
    
    G path Tw arr(%$ar);
    G splat Tw Splat(path => G(path)->W);
    
    my $Cr = G crawl;
    die unless $Cr;
    say "" for 1..5;
    say join"", ("       ẞ           ")x38;
    start_timer();
    
    $Cr->RW;

    $G->{thething} = $thing;
    $Cr->T($thing, undef, $G->stackway);
    
    my $wormhole = $G->{some_W} = $Cr->W;
    my $crawltime = show_delta();

    w splat_wormholes;
    
    Say "ẞ ".$wormhole->describe_size()." for ".($wormhole->{G}->{name}||"$thing")."\n$crawltime   ".show_delta();
  splat_wormholes: |
    return unless G(crawl);
    G splat Tw Splat(somewhere => $G->{some_W});
  wormholify: |
    G splat Tw Splat(worm => $wormhole);
  splat_splatW: |
    G splat Tw Splat(splatW   => {script=>G(splat)->W->CS}   );
    #timer 2.5 { w splat_splatW };
    
  splatmenues: |
    my $ob = G(ob)->W;
    ob => sub { 
    
    w somewhere(wormhole => $ob) };

