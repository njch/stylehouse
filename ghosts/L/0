name: Lyricoso writoro

hooks:
  fresh_init: |
    $H->{_future} = 1;
    G TT ->G("T/splat");
    G TT ->G("T/crawl");
    $G->{that} = G TT ->G("Ϡ");
    
    G TT ->G("L/path");
    G TT ->G("L/land");
    G TT ->G("L/func");
    G TT ->G("L/ob");
    
    my $Gmess = $H->{G}->Gf('mess');
    $Gmess->{_post_throw} = sub {
        my $S = shift;
        #$H->keep_throwing($S->{B}->{what}, $S->{B}->{error});
        return if $G->{_dont_mess_worm};
        #$G->sing(
          $G->_0(sing => { 
          name => "L messworm",
          again_after => 0.2,
          code => sub {
            w messworm;
          }
        })if 0;
        
            w messworm;
    };
    
    w getstarted;
  any_init: |
    $G->timer(0.01, sub {
        w set_keys;
        w set_Gdbs;
    }, "L setup"); 
    
    w set_land;
    w f/Gdb;
  set_keys: |
    my $kGs = $H->{G}->Gf('keys');
    my $tr = $kGs->{trig} ||= {};
    $tr->{m} = sub {
        w tog_hmess;
    };
    $tr->{'À'} = sub {
        w f/q;
    };
    $tr->{q} = sub {
        my $thing = w look_for_ghost(name => 'Њ');
        w somewhere[$thing];
    };
    $tr->{'g'} = sub {
        $H->getapp('Git')->spawn_proc('cd ../styleshed && git gui');
    };
  bunch_of: |
    Info "Yep";
    w set_Gdbs
  set_Gdbs: |
    $Ghost::db = 1;
    
    my @Gdbnah = map {
        w look_for_ghost(name => $_)
        } qw{T/splat.+W/tractor H/mess H/colour keys land path func};
    for my $g (map { @$_ } @Gdbnah) {
        say "Setting db-1 $g->{name}";
        $g->{db} = 0;
    }
  any_child_recoded_init: |
    w set_land;
    # splat_wormholes;
    Say "Child recoded", $ar;
    if ($ar->{S}->{way} =~ /crawl/) {
        w getstarted;
    }
  
  look_for_ghost: |
    [ grep { $_->{name} =~ /$name/ } @{$H->data->{Ghost}} ]
  lands: |
    [ "G*",         sub { $H->data->{Ghost} } ],
    [ "wayf",         sub { $G->stackway } ],
    [ "\@F",           sub { [@F] } ],
    [ "Apps",        sub { $H->{G}->w('data/get_apps') } ],
    [ 'H',            sub {  $H } ],
    [ 'L',             sub { $G } ];
  f:
    'Ϡ*': |
      my $thing = w look_for_ghost(name => 'Ϡ');
      w somewhere[$thing];
    'Њ*': |
      my $thing = w look_for_ghost(name => 'Њ');
      w somewhere[$thing];
    Ϡ: |
      w somewhere(nothing => $L);
    Ϡ?: |
      $H->Info("Ϡing... ",G ob );
      $G->{_ob} = $G->{that}->{_ob} = G ob;
      $G->{_ob}->RW();
      eval {
          w somewhere(nothing => $L);
      };
      $G->{_ob} = undef;
      $H->error("EϠ EϠ EϠ EϠ", $@) if $@;
      $@ = ""         if $@;
      w f/Gob;
    Gob: |
      my $W = G(ob)->W;
      w somewhere[$W];
    chch: |
      w swap_chains
    ⥁: |
      w splat_wormholes
    futu: |
      $H->{_future} = !$H->{_future};
      $H->Say("\$H->{_future} = $H->{_future}");
    Gdb: |
        $Ghost::db = !$Ghost::db;
        my $some = $G->printF();
        $H->Say("\$Ghost::db = $Ghost::db \n".$some);
        $G->timer(2, sub { w f/anddie; }, "and- die");
    anddie: |
      $DB::single = 1;
      say ETC";
    herenow: |
        G splat ->w('go', {thing => $G->stackway("Er", "TC")});
  somewhere: |
    if ($ar->{nothing}) {
        Gf Ϡ Tw arr(%$ar);
        return;
    }
    if ($ar->{wormhole}) {
        w wormholify;
        return;
    }
    if ($ar->{W}) {
        $G->{some_W} = $ar->{W};
        w splat_wormholes;
        return;
    }
    
    
    $G->timer(0.1, sub {
        G path Tw arr(%$ar);
        G splat Tw Splat(path => G(path)->W);
    }, "splatup path");
    
    my $Cr = G crawl;
    die "HMM" unless $Cr;
    say "" for 1..5;
    say join"", ("       ẞ           ")x38;
    start_timer();
    
    $Cr->RW;

    $G->{thething} = $thing;
    $Cr->T($thing, undef, $G->stackway);
    
    my $wormhole = $G->{some_W} = $Cr->W;
    my $crawltime = show_delta();

    w splat_wormholes;
    
    Say "ẞ ".$wormhole->describe_size()." for $thing"
    ."\n$crawltime   ".show_delta();
  make_hmess: |
        $G->{_dont_mess_worm} = 0;
        my $wormhole = $H->{G}->Gf('mess')->W;
        w somewhere[$wormhole];
  tog_hmess: |
    $G->{_dont_mess_worm}
    ? w make_hmess
    : w hide_hmess;
  hide_hmess: |
        $G->{_dont_mess_worm} = 1;
        G splat Tw clear(splatname => 'worm');
  messworm: |
    return if $G->{_dont_mess_worm};
    $G->_0(sing => {
        name => "messworm",
        again_after => 0.5,
        begin_after => 0.2,
        code => sub {
          return if $G->{_dont_mess_worm};
          w make_hmess;
        },
    }, "mess>L");
  
    
    
  
  set_land: |
    my $GG;
    my $f = sub {
        $G->Tw($GG, 'arr', {name => shift, code => shift});
    };
    
    G land ->RW;
    G func ->RW;
    
    $GG = G land;
    
    $f->(@$_) for w lands;
    
    $GG = G func;
    
    my $w_f = $G->findway('f');
    for my $wf (keys %$w_f) {
         $f->($wf => sub { $G->w("f/$wf") });
    }
    
    G splat Tw Splat(land => G(land)->W);
    
    G splat Tw Splat(func => G(func)->W);
  default_somewhere: |
      w look_for_ghost(name => 'Ϡ');
  getstarted: |
    $G->unrush('getstarted') || return;
    w set_land;
    w somewhere(thing => w default_somewhere);
  swap_chains: |
    $_->{_disabled} = !$_->{_disabled} for G crawl ->allchains;
    $G->timer(0.1, sub {
        w somewhere(thing => $G->{thething});
    });
  
  splat_wormholes: |
    return unless $G->{some_W};
    G splat Tw Splat(somewhere => $G->{some_W});
  wormholify: |
    #
    G splat Tw Splat(worm => $wormhole);
  splat_splatW: |
    G splat Tw Splat(splatW   => {script=>G(splat)->W->CS}   );
    #timer 2.5 { w splat_splatW };
    
  splatmenues: |
    my $ob = G(ob)->W;
    ob => sub { 
    
    w somewhere(wormhole => $ob) };

