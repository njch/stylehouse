name: Lyricoso writoro

hooks:
  fresh_init: |
    $H->{_future} = 1;
    G TT ->G("T/splat");
    G TT ->G("T/crawl", "T/ravel");
    $G->{that} = G TT ->G("Ϡ");
    
    G TT ->G("L/path");
    G TT ->G("L/land");
    G TT ->G("L/func");
    G TT ->G("L/ob");
    
    my $Gmess = $H->{G}->Gf('mess');
    my ($A) = $Gmess->tractors;
    die unless $A->{K} eq "mess";
    $A->accum('populi/_hooks', sub {
        return if $G->{_dont_mess_worm};
        waylay messworm;
    });
    
    w getstarted;
  any_init: |
    waylay set_keys;
    waylay set_Gdbs;
    waylay set_land;
  key:
    m: |
        w tog_hmess;
    N: |
      G Ϡ ->w('blur');
    n: |
      $_->togcl('invis') for G Ϡ ->w('views');
    a: |
        w f/nos;
    'À': |
        w f/q;
    q: |
        my $thing = w look_for_ghost(name => 'Њ');
        w somewhere[$thing];
    g: |
        $H->getapp('Git')->spawn_proc('cd ../styleshed && git gui');
  set_Gdbs: |
    $Ghost::db = 1;
    
    my @Gdbnah = map {
        w look_for_ghost(name => $_)
        } qw{T/splat keys land path func mess.+tractor L.....T\/crawl colour.+tractor ob
        yle uxt};
    for my $g (map { @$_ } @Gdbnah) {
        say "Setting db-1 $g->{name}";
        $g->{db} = -1;
    }
  lands: |
    [ "G*",         sub { $H->data->{Ghost} } ],
    [ "wayf",         sub { $G->stackway } ],
    [ "\@F",           sub { [@F] } ],
    [ "Apps",        sub { $H->{G}->w('data/get_apps') } ],
    [ 'H',            sub {  $H } ],
    [ 'L',             sub { $G } ];
  f:
    'ccc': | #ccc
      my $deg = -180 + int(rand(360));
      $ar->{V} ||= $H->{sky};
      $H->JS($ar->{V},"css('-webkit-filter', 'brightness(0.8) saturate(1.2) contrast(1.3) hue-rotate(${deg}deg)')");
    'ccm': |
      my $deg = -180 + int(rand(360));
      $H->JS("\$('#worm').css('-webkit-filter', 'brightness(0.5) saturate(0.6) contrast(1.3) hue-rotate(${deg}deg)')");
      
    'comp': |
      if ($ar->{e}) {
          w f/ccc;
      }
      else {
          G H w grab/next_click; # recalls  Z with $V, etc.
      }
      
    'ЊϠʝ*': |
      my $thing = {
        'Њ' => w look_for_ghost(name => 'Њ'),
        'Ϡ' => w look_for_ghost(name => 'Ϡ'),
        'ʝ' => w look_for_ghost(name => 'ʝ', not => "Ϡ"),
        '*' => w look_for_ghost(not => 'Њ|Ϡ|ʝ'),
      };
      my $max_depth = 2;
      w somewhere[$thing, $max_depth];
    'L>Ϡ': | #c
      my $nothing = ".";
      w somewhere[$nothing];
    'uxt': |
      G Ϡ ->w('anduxt');
    'Ϡ?': |
      $H->Info("Ϡing... ",G ob );
      my $sty = $H->Gf('Ϡ')->Gf('style');
      $sty->{_ob} = G ob;
      $sty->{_ob}->RW();
      eval {
          w somewhere(nothing => $Ly);
      };
      $sty->{_ob} = undef;
      $H->error("EϠ EϠ EϠ EϠ", $@) if $@;
      $@ = ""         if $@;
      w f/Gob;
    Gob: | #c
      my $W = G(ob)->W;
      w somewhere[$W];
    G: |
      w somewhere(thing => $G);
    enclaw: |
      #e t c
    chch: |
      w swap_chains
    nos: |
      $H->Gf("T/splat")->w("get", {splatname => "somewhere"})
      ->{view}->togcl('invis');
      
    '⥁': |
      w splat_wormholes
    futu: |
      $H->{_future} = !$H->{_future};
      $H->Say("\$H->{_future} = $H->{_future}");
    Gdb: |
        $Ghost::db = !$Ghost::db;
        my $some = $G->printF();
        $H->Say("\$Ghost::db = $Ghost::db \n".$some);
        $G->timer(2, sub { w f/anddie; }, "and- die");
    anddie: |
      say "ETC";
    herenow: |
        G splat ->w('go', {thing => $G->stackway("Er", "TC")});
  getstarted: |
    $G->unrush('getstarted') || return;
    #w somewhere(thing => w default_somewhere);
    #$G->w('f/L>Ϡ');
  somewhere: |
    if ($ar->{nothing}) {
        Gf Ϡ Tw arr(%$ar);
        return;
    }
    if ($ar->{wormhole}) {
        w wormholify;
        return;
    }
    if ($ar->{W}) {
        G splat Tw Splat(somewhere => $ar->{W});
        return;
    }
    
    $G->timer(0.1, sub {
        G path Tw arr(%$ar);
        G splat Tw Splat(path => G(path)->W);
    }, "splatup path");
    
    my $Cr = G crawl;
    $Cr || die;
    my $unc = $Cr->crank(max_depth => $ar->{max_depth}) if defined $ar->{max_depth};
    say join"", ("       ẞ           ")x38;
    start_timer();
    
    $Cr->RW;

    $G->{thething} = $thing;
    $Cr->T($thing, undef, $G->stackway);
    
    
    $unc->() if $unc;
    my $wormhole = $G->{some_W} = $Cr->W;
    my $crawltime = show_delta();

    w splat_wormholes;
  make_hmess: |
    $G->{_dont_mess_worm} = 0;
    my $wormhole = $H->{G}->Gf('mess')->W;
    w somewhere[$wormhole];
  tog_hmess: |
    $G->{_dont_mess_worm}
    ? w make_hmess
    : w hide_hmess;
  hide_hmess: |
        $G->{_dont_mess_worm} = 1;
        my $S = G splat Tw get(splatname => 'worm');
        $S->{view}->fadehtml();
  messworm: |
    return if $G->{_dont_mess_worm};
    $G->susgdb;
    $G->_0(sing => {
        name => "messworm",
        again_after => 0.5,
        begin_after => 0.2,
        code => sub {
          return if $G->{_dont_mess_worm};
          $G->susgdb;
          w make_hmess;
        },
    }, "mess>L");
  
    
    
  
  set_land: |
    my $GG;
    my $f = sub {
        $G->Tw($GG, 'arr', {name => shift, code => shift});
    };
    
    G land ->RW;
    G func ->RW;
    
    $GG = G land;
    
    $f->(@$_) for w lands;
    
    $GG = G func;
    
    my $w_f = $G->findway('f');
    for my $wf (sort keys %$w_f) {
         $f->($wf => sub { $G->w("f/$wf") });
    }
    
    G splat Tw Splat(land => G(land)->W);
    
    G splat Tw Splat(func => G(func)->W);
  default_somewhere: |
      w look_for_ghost(name => 'Ϡ');
  swap_chains: |
    $_->{_disabled} = !$_->{_disabled} for G crawl ->allchains;
    $G->timer(0.1, sub {
        w somewhere(thing => $G->{thething});
    });
  
  splat_wormholes: |
    return unless $G->{some_W};
    G splat Tw Splat(somewhere => $G->{some_W});
  wormholify: |
    G splat Tw Splat(worm => $wormhole);
  splat_splatW: |
    G splat Tw Splat(splatW   => {script=>G(splat)->W->CS}   );
    #timer 2.5 { w splat_splatW };
  any_child_recoded_init: |
    return if $S->{name} =~ /Ϡ.../;
    w set_land;
    if ($ar->{S}->{way} =~ /crawl/) {
        w getstarted;
    }
  look_for_ghost: |
    [ grep {
      (!$ar->{name} || $_->{name} =~ /$ar->{name}/)
    && 
      (!$ar->{not} || $_->{name} !~ /$ar->{not}/)
    } @{$H->data->{Ghost}} ]

