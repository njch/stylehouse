
C:
  - K: style #c redis
    conor: -1.5
    ishtml: 1
    S:
      attr:
        scoped: undef
        type: text/css
      content_D: |
        my ($WM) = map{_.i} @{S.A.u_y};
        my $GG = WM.W.G;
        my $sheet = w stylesheet[$GG, $K];
        die "GG.name has style $K ? " unless length($sheet);
        # may need to careful order new appendages too?
        $sheet ? "\n$sheet\n" : "";
S: # sssssssssssss
 - K: u #  u for wormhole liney primitives
   Ss:
    - K: te # yer standard thing
      css: 
        - border-bottom:1px solid black
        - padding-left:2em
        - float:left
        - position:relative
        - width:calc(100% - 2em)
        - background:rgba(150,100,50,0.1)
    
    - K: tu # without indentation, more normal
      css: 
        - border-bottom:1px solid black
        - float:left
        - position:relative
        - width:100%
        - background:rgba(150,100,50,0.1)

    - K: nopoi # outer
      css: [pointer-events:none]
    - K: poi
      css: [pointer-events:all]
    - K: OxO
      styles: ab
      css: [height:100%, width:100%]
    - K: ab
      css: [position:absolute]
    - K: rel
      css: 
        - position:relative
    - K: X
      css:
        - position:relative
        - width:100%
        - height:100%
    - K: NZ
      css: []
      classy: hidden until its brought into the web
    - K: z
      css: []
      classy: to bring into the web
hooks:
  stylespawn: |
    my $GG = W.G;
    my $SsKs = S.Ss ||= [];
    
    if ($SsKs eq "*") {
        my $eS = $GG->anyway('S');
        $SsKs = [ map { _.K } @$eS ];
    }
    for my $K (@$SsKs) {
        push @{S.spawn||=[]}, {
            K => 'style',
            B => {K=>$K},
        };
        w styleup[$GG, $K];
    }
  styleup: |
    my $SS = w styleway[$GG, $K];
    $SS || die sw(["style $K not found", $K, $SS, $GG]);
    H.G w wayray(wa => SS.Ss, S=>$G);
    
    #sayre "style up GG.name $K  got ".@{SS.Ss};;
    
    my @SSSs = @{SS.Ss};
    for my $S (@SSSs) { # mix the stylebits together
        if (S.spawns) {
            for my $w (w $S spawns) {
                w._spawns = delete w.spawns;
                push @{SS.Ss}, $w unless grep { _.K eq w.K } @{SS.Ss};
            }
        }
    }
    for my $S (@{SS.Ss}) { # mix the stylebits together
        G.h->{S.K} = $S;
    }
  styleway: |
    for my $tryG ($GG, $G) {
        my $SS = $tryG->CsK({s=>'S', K=>$K});
        return $SS if $SS;
    }
  stylesheet: |
    $K ||= "S";
    my $SS = w styleway[$GG, $K];
    $SS || die "NoiSSSS $K on ux or GG.name";
    my $Ss = SS.Ss;
    my ($c, @s);
    my $san = sub {
        my $props = shift;
        join ";", map {
            ref $_ eq "HASH" && die
                "oi c.K from GG.name's $K _S !"
                ." css line got YAML-munted into HASH !"
                ." remove the space after the colon?";
            $_
        } @$props
    };
    join "\n", grep {defined}
    map{
        $c = $_;
        if (c.css) {
            ".".c.K."{".$san->(c.css)."}"
        }
        elsif (c.keif) {
            my $keif = join "\n", map {
                _.K."{".$san->(_.css)."}"
            } @{c.keif};
            my $yep = "@"."-webkit-keyframes ".c.K."{\n"
                .ind('  ', $keif)
            ."\n}";
            $yep
        }
    } @{SS.Ss};
    
  stylezo: |
    # u at->attribute traslator
    # kind of an argument resolver
    # everything should be styleup'd to G.h
    # making this a G1 function we call from ux with M's W.G
    # some $style has space(s), leads through D to other style
    # speaking of style
    # which is what these capital letter concepts as individuals speak
    # which is our language held nicely
    my $GG = $G; # having said G1 etc we shove it all into G(ux) for now
    my $apply;
    my @deply;
    $apply = sub {
        my $style = shift;
        return if $style !~ /./;
        return map { $apply->($_) } split ' ', $style if $style =~ / /;
        
        my $S = GG.h->{$style};
        if (!$S) {
            return push @deply, $1 if $style =~ /^-(.+)$/;
            my $DS = GG.h->{$1."_n"} if $style =~ /^(\w+)(\d+)$/;
            if ($DS) {
                DS.D || die sw["D found style not have D", $DS];
                $G->w(D => {%$ar, n => $2}, $DS);
            }
            else {
                 warn "no ifndo $style";
            }
        }
        else {
            # lingosa
            if (S.styles) {
                $apply->(S.styles);
            }
            S.css ? do{ 
                at.attr.class .= " $style";
            }:
            S.D ? do{
                my $ysty = $G->w("D", $ar, $S); # ux or whatever models joints here
                $apply->($ysty) if $ysty;
            }:
            do {
                sayre "wtf '$style'" unless $style =~ /^(yi|te)$/;
            };
        }
    };
    $apply->($styles);
    for my $d (@deply) {
        at.attr.class =~ s/$d//;
    }
    at.attr.class =~ s/^\s+|\s+$|\s\s+//sg;
    
    if (u.K eq "W") { # class to style="" outside <style> scope 
        my $clastyle = delete at.attr.class;
        for my $style (split ' ', $clastyle) {
            my $S = GG.h->{$style};
            for my $css (@{S.css}) {
                my ($k, $v) = split ":", $css;
                at.Z->{$k} ||= $v;
            }
            if (!@{S.css} || S.classy) {
                at.attr.class .= " $style"; # secret meaning
            }
        }
    }
    
    

