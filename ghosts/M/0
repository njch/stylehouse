
C:            # W M ux ...
  - K: W #c us
    Gw: 1
    Ss: [u, x, X]
    S:
      styles: OxO nopoi ab z NZ
      tag: ww 
      id_D: |
        ( W.id =~ /-(\w+)$/ )[0]
  - K: M #c themmmmmmm from an R
    Gw: 1
    Ss: *
    S:
      styles: OxO poi
      tag: MMMM
        
  - K: style #c redis
    conor: -1.5
    ishtml: 1
    S:
      tag: style
      attr:
        scoped: undef
        type: text/css
      content_D: |
        S.sheet || "/* feels empty */";
     
  - K: ux #c
    Gw: 1
    S:
      tag: ux
    styles: te
    conor: 1 # TODO
       
Ray:
 - K: M
   findway: R_M
     
hooks:
  W:
    flows_D: |
      my $W = S.W;
      w stylespawn[$S, $W];
    flows_D: |
      G.R->phat(S.TV = {}); # G.R should be Jish for this M etc etc.
      G.R->phat(S.V = {});
    print: |
      "W=".S.W.G.name #Bthing, u is $S
  M:
    flows_D: |
      my $W = S.W;
      w stylespawn[$S, $W];
    print: |
      "MMMM=".S.W.G.name
  ux:
    print: |
       "S.K S.id  (".S.i->pi
  
  percolate_R: |
    w Puur unless K R:M;
  Puur: | # default percolation, creating R:M
    G.theM = $G->R('M', ar.K);
    w G.theM setup;
  mux: | # wandering way... bit vaggue, you'd lign up yer beams better than...
    my $K = ar.K || "M";
    my $M = K R:$K;
    my $MR = G.R; # default is the non of the whole G...
    # the W side is R:M.Wo (G.theM.Wo)
    my $a = {%$ar};
    my $u = delete a.u;
    saybl "Muxing ".$G->pi."   ".$M->pi."     via ".$MR->pi."      with ".$u->pi;
    a.v ||= 7; 
    w $M mux[$MR,$a,$u];
  remux: |
    my $M = G.theM;
    my $MR = G.R;
    my $a = {%$ar};
    my $u = delete a.u;
    w $M remux[$MR,$a,$u];
R_Ms:
  setup: |
    G.theM.Wo = G.theM.A->spawn(R => 'non'); # $G->R();
    G.theM.Wo.K = "WoM"; # TODO
    
    # ^ for holding the C:W, C:Ms, C:uxs
    
    my $uWa = {K => 'W', W => G.theM.Wo, R => G.theM};
    G.theM.W = w G.theM.Wo fuu(u => $uWa); # the unified into wormhole
    # ^ hardlink
    # all before perc_late makes things humm/mux
  mux: |
      my $M = w $R Mr[$MR]; # not G.theM, which is now $R
      my $TV = R.W.TV; # R.W is the C:W
      my $u = ar.u || [];
      
      my $us = [ref $u eq 'ARRAY' ? @$u : $u];
      
      $a = {k=>$a} if !ref $a;
      
      TV.bz->('W 4', R.W) if a.full;
      
      TV.bz->("M/M.id 6", $M);
      
      my $v = a.v if defined a.v;
      $v ||= 4;
      # 1-9 -> humm/links/etc
      
      for my $u (@$us) {
          next unless defined $u;
          die wdump($u) unless ref $u eq 'C';
          die if u.K eq 'ux';
          say "mux $v ".$u->pi;
          TV.bz->("i/u.id $v", $u); # v maybe subtle
          TV.bz->("i/u.id%M 4", $M); # two divides - then M can optimise 7
      }
      
      0->sing(uxd => sub { w $R uxd; }, again=>1, begin=>0.2);
  remux: | # upgrading the rubble before life arrives
    my $TV = R.W.TV;
    my ($goner) = grep { _.s eq $u } w $R JV[$TV];
    my $s = delete TV.bb->{goner.r};
    $s eq $goner || die;
    my $v = ar.v;
    $v ||= 9; # TODO naw
    TV.bz->(goner.T."\t".$v => goner.s);
  uxd: |
    my $TV = R.W.TV;
    G.R->phat(R.W.TV = {}); # flush
    w $R ux[$TV];
  Mr: |
      my $Ma = {K => 'M'};
      Ma.B.W = Ma.W = $MR;
      Ma.B.R = Ma.R = $R;
      my $M = w R.Wo fuu(u => $Ma); # the lines' W mirrored
      M.A->umk(R.W, 'M');
      M.A->umk($MR,'W'); # our long wave of the origin W (R/J)
      $M
  JV: |
    my @J;
    my $TV = ar.TV || ar.V;
    my $bb = TV.bb;
    for my $k (keys %$bb) {
        my $j = $bb->{$k};
        undef $j unless ref $j eq 'HASH' && j.t; # go round
        $j ||= $bb->{$k} = $R->shj($k, $bb);
        j.T ||= j.t;
        j.to ||= (j.t =~ /^(\w+)/)[0]; # ^
        
        
        next if defined j.style;
        
        push @J, $j;
    }
    @J
  pto: |
    my @m;
    for my $cv (sort keys %$p) {
        if ($cv <= $lcv) {
            my @ere = sort keys %{$p->{$cv}};
            @ere = reverse @ere if ar.rev;
            for my $el (@ere) {
                my ($to) = split '/', $el;
                my $s = $p->{$cv}->{$el};
                push @m, {
                    r=>{p=>$p,V=>$V,TV=>$TV,s=>$s,to=>$to}, # to do
                    aft=>{cv=>$cv,lcv=>(ar.rcv||$lcv),el=>$el,s=>$s}, # to move
                };
            }
        }
    }
    my $i=0;
    sub {
        my $r = ($m[$i]||{})->{r};
        if ($i>0) {
            my $aft = $m[$i-1]->{aft};
            if (aft.lcv < 9) {
                delete $p->{aft.cv}->{aft.el};
                $p->{aft.lcv}->{aft.el} = aft.s;
            }
        }
        return undef unless $r;
        $i++;
        return $r;
    };
  Usurf: | # TODO wants to climb up from extremity for speed, joining onto M pathways
    j.seenid->{i.id} = $i;
    my $jp = j.p ||= {};
    $j = {%$j};
    j.p = {};
    my $here = "i.id";
    $jp->{$here} = $here;
    my @down = w $R Udown;
    ar.d++;
    die if ar.d > 10;
    for my $d (@down) {
        my $jpp = w $R Usurf(j=>$j, i=>$d, d=>ar.d);
        for my $k (keys %$jpp) {
            $jp->{"$here/$k"} = $jpp->{$k};
        }
    }
    $jp;
    
    
    
    
    
  Udown: |
    # W->M->uxs, then uxs S amongst, y projects
    my $okn = { map {$_=>1} map {"n_$_"} qw'M ux S y' };
    my @ks = grep { $okn->{$_} } keys %{i.A};
    my @As = map { @{i.A->{$_}||[]} } @ks;
    my @down = map{_.i} @As;
    @down = grep {!ar.j.seenid->{_.id}} @down unless !ar.j || ar.allseeing;
    die if grep {_.dead} @down;
    uniq @down;
    
  event: |
    my $uy = $i if $i ne $ux;
    my $i = ux.i if $ux;
    $i = undef if !$ux;
    my $E = {
        e => $e,
        W => $W,
        i => $i,
        ux => $ux,
        uy => $uy, # something with ID beyond the ux, may be grasped...
        # TODO liesy after styley tagname anarchy
    };
    
    saybl " W ". $W->pi if $W;
    saybl " UX ". $ux->pi if $ux;
    saybl " Uy ". $uy->pi if $uy;
    return saygr "ungrasped line" unless $i;
    saybl " i ". $i->pi;
    
    # TODO make a pattern about y=to match against Eways...
    i.G w event(%$E);
R_Mz:
  - K: ux #c
    D: |
      # 1
      # very left of the dome, heading into micro peaks
      # we get more likely to fork
      #   as we go out along things that already exist
      #   they humm back to themselves at 8s
      #     where we can either switch to it as master
      #     or drop it if the thing wants a new 4 or so already

      # the W is what we propagate, where ux # slight singley for now
      # the M is Random input grouper - upstream patch panel to Cs
      # the i is a sack of Cs, somewhere under M, ux mirrors of source W Cs

      # so fitting into RNAs those things are

      # G.R is R, the wormhole C:M muxes
      # G.theM is this R:M
      # aka R in here
      # R.W is C, the wormhole we are unifying
      # R.Wo is R:non, the wormhole of this RNA

      sayyl "\n ixomg ".$G->pi."    ".R.W->pi."\n\n";
      my $W = R.W; # not really singular, crazy patchwork though
      my $V = R.W.V;
      my $les = '*';

      my @ONTV = w $R JV[$TV];
      my ($M) = map {_.s.W} grep {_.to eq 'M'} @ONTV;

      TV.bz->("W 6", $W) if !grep{_.to eq 'W'} @ONTV; # W always there

      my $p = {};
      # 2.3
      # 2.4
      my $tvp = { V=>$V, TV=>$TV, p=>$p };
      
      my $threes = w $R pto(%$tvp, lcv => 3);
      while (defined(my $r = $threes->())) {
          my $p = r.p; my $s = r.s; my $to = r.to;
          # 3
          # 3.9
      }

      w $R JV[$V]; # V ups for %u 3

      my $fours = w $R pto(%$tvp, lcv => 4, rev=>1);
      while (defined(my $r = $fours->())) {
          my $p = r.p; my $s = r.s; my $to = r.to;
          # 4
          # 4.9
      }


      my $fives = w $R pto(%$tvp, lcv => 7, rcv=>5);
      while (defined(my $r = $fives->())) {
          my $p = r.p; my $s = r.s; my $to = r.to;
          # 5
          # 5.9
      }

      my $j = $G->nw(K=>'j', s=>[], c=>[], W=>$W, M=>$M, R=>$R);

      my $sixes = w $R pto(%$tvp, lcv => 6);
      while (defined(my $r = $sixes->())) {
          my $p = r.p; my $s = r.s; my $to = r.to;
          # 6
          # 6.9
      }

      my $sevens = w $R pto(%$tvp, lcv => 6);
      while (defined(my $r = $sevens->())) {
          my $p = r.p; my $s = r.s; my $to = r.to;
          # 7
          # 7.9
      }

      H.G w aj[$j];

      sayre "ux -------- G.K done\t\t".F_delta."  load ".$H->la;

      w aj[$j];

      if (0) {
          my $abb = { map { $_ => TV.bb->{$_}->{s} } keys %{TV.bb} };
          w $R pv(i=>$p,n=>2);

          my @JJJ = w $R JV[$V];
          my $ab = { map { $_ => V.bb->{$_}->{s} } keys %{V.bb} };
          w $R pv(i=>$ab,n=>1);
      }
    
  - K: two #c
    babz:
      'ux 2.3': |
        @ONTV = w $R JV[$TV];
        for my $j (@ONTV) {
            my $to = j.to;
            my $s = j.s;
            my $cv = j.cv;

            $cv = 1 if $cv <= 3; # non hummed drops?
            if ($to eq 'i') {
                my $u = V.bb->{"i/s.id%u 3"};
                $u = u.s if ref $u eq 'HASH';
                if (s.dead) {
                    w R.Wo del[$u];
                    delete V.bb->{"i/s.id%u 3"};
                    sayre "SOMETHING DIED: ".$u->pi;
                }
                $cv = 1 if !$u || !u.at; # sat in
            }
            else {
                $cv = 1 if !s.at; # sat in
            }

            $p->{$cv}->{"$to/s.id"} = $s;
            sayre sprintf '%22s%s', j.r, " [ $cv";
        }
  - K: three #c
    babz:
      'ux 3': |
        if ($to eq 'i') {
            my $i = $s;
            ref $s eq 'C' || die $s;
            my $M = (TV.bb->{"i/i.id%M 4"}||die)->{s};
            my $ux = (V.bb->{"i/i.id%u 3"}||{})->{s};
            $p->{4}->{"M/M.id"} = $M;
            # also in M n_ux
            # also fuu might find the swaying identity (.K & .B) and return it
            say "for i i.id ".$i->pi;
            if ($ux) {
                say "Found u~! ux.i.id ".$ux->pi if $ux;
                die if ux.i ne $i;
            }
            else {
                # add C.Bs override for little B schemas not in .B.?
                my $uxa = {K => 'ux', i => $i};
                uxa.B.i = uxa.i;
                $ux = w R.Wo fuu(u => $uxa, q=>1);
            }
            ux.A->umk($M, 'ux');
            ux.A->umk(ux.i, 'U'); # into alien space
            V.bz->("i/i.id%u 3", $ux);
        }
  - K: four #c
    babz:
      'ux 4': |
            if ($to eq 'i') {
                saybl "Four i";
                # the 374 coil, ux set must be complete
                # ux nests under another ux like origin
                # and M must humm after (reversal after 3
                my $ux = (V.bb->{"i/s.id%u 3"} || die)->{s};
                my $M = (TV.bb->{"i/s.id%M 4"} || die "no i/s.id.'%M 4'")->{s};
                
                push @{M.tohu||=[]}, $ux;
                
                for my $iu (@{ux.i.A.u_S||[]}) { # or whatever
                    my $u = (V.bb->{"i/iu.id%u 3"} || next)->{s};
                    die if $iu ne u.i;
                    $p->{5}->{"i/iu.id"} = $iu; # must go through to get here
                    ux.A->umk($u, 'uS'); # relatable
                }
            }
            elsif ($to eq 'M') {
                my $M = $s;
                my $got = M.vom; # before
                my $needmore = 0;
                for my $ux (@{M.tohu||[]}) {
                    next if $got->{ux.id};
                    $needmore = 1;
                }
                if ($needmore) {
                    my $j = {};
                    my $jp = w $R Usurf(j=>$j, i=>$M);
                    my $vom = {reverse %$jp};
                    keys %$jp == keys %$vom
                    || die wdump[[sort keys %$jp], [sort values %$vom]];
                    M.vom = $vom;
                }
                M.tom = {}; # < ^ others 5s put moves forth to 6
            }
  - K: five #c
    babz:
      'ux 5': |
            if ($to eq 'i') {
                my $i = $s;
                my $ux = (V.bb->{"i/s.id%u 3"} || die)->{s};
                my $M = (TV.bb->{"i/s.id%M 4"} || die)->{s};
                my $vom = M.vom;
                my $tom = M.tom;
                
                my $mv = $vom->{ux.id} || die;
                $tom->{$mv} = $ux;
                #say "for ".$ux->pi." has top go through $mv";
            }
  - K: six #c
    babz:
      'ux 6': |
          my @mm;
              if ($to eq 'W') {
                  push @mm, $s;
              }
              if ($to eq 'M') {
                  my $M = $s;
                  push @mm, $M;

                  my $vom = M.vom;
                  my $to = M.tom;
                  my $pat = [];
                  for my $k (sort keys %$to) {
                      push @mm, $to->{$k};
                      push @$pat, {k=>$k, ux=>$to->{$k}};
                  }
                  M.pat = $pat;
              }
          for my $i (@mm) {
              sayyl "Six? ".$i->pi;
              #next if i.K eq 'ux' && !$p->{5}->{"i/i.i.id"};
              #sayyl "SPAWN ".$i->pi;
          }
  - K: seven #c
    babz:
      'ux 7': |
          my @mm;
              if ($to eq 'W') {
                  push @mm, $s;
              }

              if ($to eq 'M') {
                  my $M = $s;

                  my $pat = M.pat;

                  push @mm, map {_.ux} reverse @$pat;

                  push @mm, $M; # after desc lines come back
              }
              for my $i (@mm) {
                  sayyl "Seven! ".$i->pi;
                  w $R compile_figure[$i, $j];
                  w $R wayout_sendo[$i, $j];
              }
  - K: compile_figure #c
    D: |
        my $u = $i;
        my $ui = u.i if u.i;
        
        my $at = u.at = {};
        
        if (u.K eq "uW") {
            u.at = ui.at;
            sayre $ui->pi." wtf wtf ".$u->pi for 1..5;
            return;
        }
        
        # v the look-around-for-style-etc vortex v
        at.id = u.id; # probly... rest good to T
        at.tag = 0->uiuS($u => 'tag') || u.tag || u.K;
        at.ishtml = 0->uiuS($u => 'ishtml');
        at.class = 0->uiuS($u => 'class');
        
        my @styles;
        push @styles, u.styles, u.S.styles;
        push @styles, ui.styles, ui.S.styles if $ui;
        
        at.styles = join " ", grep {defined} @styles;
        
        
        at.tag ||= u.K;
        die "no tag" .sw($u) if !at.tag;
        
        at.conty = 0->uiuS($u => 'content');
        
        at.conty = "" if !defined at.conty;
        at.conty = encode_entities(at.conty) unless at.ishtml;
        
        
        my @down = w $R Udown(+ allseeing => 1);
        @down = sort { a.conor <=> b.conor } @down;
        at.ooze = \@down;
  - K: wayout_sendo #c
    D: |
        my $u = $i;
        my $ui = u.i if u.i && u.K eq 'ux';
        
        my $at = u.at;
        my $sendo = u.sendo = [];
        
        my ($s,$c) = ([],[]);
        my $do_S = sub { push @$s, shift };
        my $doj_S = sub {
            my ($id, $sp, @int) = @_;
            $do_S->("\$('#$id')".sprintf($sp, @int).";");
        };
        my $do_C = sub { push @$c, shift };
        # S is innards, C is complete (send all S before all C)
        # further thinking running on wholeness
        # order important
        my $_t = u._at;
        
        my $attr = at.attr = {
            id => at.id,
            class => at.class,
            %{ 0->uiuS($u => "attr") || {} },
        };
        
        my $conty = defined at.conty ? at.conty : "";
        my $oozs = [ grep { defined } map { _.html } @{ at.ooze } ];
        my $content = join "\n", @$oozs;
        
        at.Z = {}; # zip v
        
        at.Z = { %{at.Z}, %{u.Z} } if u.Z; # from u
        
        my $styles = at.styles;
        w stylezo[$u, $ui, $styles, $at]; # ye, wants to zip down Z too/
        # TODO widerly, the Z devolves into styles
        # and they're both about the same, Z translates and complicated styles
        # buzzing around here somewhere.
        
        my $Z = 0->uiuS($u => "Z"); # from ui S/Z(_D)
        at.Z = { %{at.Z}, %$Z } if $Z;
        
        $Z && attr.style && die "got uiu $Z\t\tattr.style already";
        
        at.css = at.Z;
        for my $k (keys %{at.css}) {
            my $v = at.css->{$k};
            if (ref $v eq 'HASH') {
                delete at.css->{flit} if $k eq 'flit';
                at.css->{'-webkit-filter'} = join " ",
                    map{ "$_($v->{$_})" } sort keys %$v;
            }
        }
        attr.title = "M H.style/H.name/H.id" if u.K eq "W";
        my $late = []; #c
        if (!$_t) {
            if ( $conty && $content ){
                warn "conty and ooze ".$u->pint;
                #sw(["contooz", $u, $conty, $content]);
                $conty = ",";
            }
            if (length($conty . $content) > 25000) {
                $content = "";
                $do_S->("\$('#at.id').append('$_');") for @$oozs;
            }
            for my $i ($u, $ui) {
                next unless 0;#$i && (i.S.sendo_init_D || i.Gw);
                #say "Snedoing ".$i->pi;
                my $Ce = w $i S/sendo_init_D[$u];
                $do_C->($Ce) if $Ce;
            }
            
            if ($u eq R.W) { # unified field of this W
                push @$late, sub {
                    $do_S->(
                        "\$('#ux > #at.id').remove();"
                    );
                    $do_S->(
                        "\$('#ux').append(".$H->ejson(u.html).");"
                    );
                };
                
                j._ && die "Already unified!?";
                j._ = $u; # TODO diffy for the J
            }
        }
        else {
            my $ino = sub { my ($u, $in) = @_; grep { $_ eq $u } @$in; };
            
            for my $newu (grep { !$ino->($_, u._at.ooze) } @{at.ooze}) {
            
                $doj_S->(at.id, '.append(%s)', $H->ejson(newu.html));
                
            }
            for my $gonu (grep { !$ino->($_, at.ooze) } @{u._at.ooze}) {
            
                $doj_S->(gonu.at.id, '.remove()');
                
            }
            if (at.conty ne _t.conty) {
            
                $doj_S->(at.id, '.html(%s)', $H->ejson(at.conty));
                
            }
            while (my ($k, $v) = each %{ at.attr }) {
                next if $v eq _t.attr->{$k};
                
                $doj_S->(at.id, '.attr(%s, %s)', $H->ejson($k), $H->ejson($v));
                
            }
            if (at.css) {
                my $anima;
                #saybl $u->pi."    ".wdump(at.css) if %{at.css};
                while (my($k,$v) = each %{at.css}) {
                    next if $v eq _t.css->{$k};
                    my $isa = '++';
                    # an uiuS for mergins Anim/* ?
                    
                    my $anim = 1 if ui.K eq 'Im';
                    #;#ui.K eq 'Do' && ($k eq 'left' || $k eq 'top');
                    if ($anim) {
                        $anima->{$k} = $v; # BB
                    }
                    else {
                        $doj_S->(at.id, '.css(%s, %s)', $H->ejson($k), $H->ejson($v));
                    }
                }
                if ($anima && %$anima) {
                    $anima = $H->ejson($anima);
                    $doj_S->(at.id, q".animate(%s, %s)", $anima, 1000);
                }
            }
        }
        attr.style .= shtocss(at.css) if at.css;
        my $tag = at.tag;
        my $mkat = sub {
            my $a = shift;
            my $v = $attr->{$a};
            return $a if $v eq "undef";
            return $a.'="'.$attr->{$a}.'"'
        };
        # style/class gets misccss/Wcss
        $attr = join " ", map { $mkat->($_) }
            grep { defined $attr->{$_} && $attr->{$_} ne "" } sort keys %$attr;
            
        u.html = "<$tag $attr>$conty$content</$tag>";
        $_->() for @$late; # what needs u.html
        
        u._at = $at;
        
        push @{j.s}, reverse @$s;
        push @{j.c}, reverse @$c;

