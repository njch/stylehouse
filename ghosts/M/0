
C:            # W M ux ...
  - K: W #c us
    flows_D: |
      my $W = S.W;
      w stylespawn[$S, $W];
    Ss: [u, x, X]
    print: |
      "W=".S.W.G.name #Bthing, u is $S
    S:
      styles: OxO nopoi ab z NZ
      tag: ww 
      id_D: |
        ( W.id =~ /-(\w+)$/ )[0]
    flows_D: |
      G.R->phat(S.TV = {}); # G.R should be Jish for this M etc etc.
      G.R->phat(S.V = {});
  - K: M #c themmmmmmm from an R
    flows_D: |
      my $W = S.W;
      w stylespawn[$S, $W];
    print: |
      "MMMM=".S.W.G.name
    Ss: *
    S:
      styles: OxO poi
      tag: MMMM
        
  - K: style #c redis
    conor: -1.5
    ishtml: 1
    S:
      attr:
        scoped: undef
        type: text/css
      content_D: |
        my ($WM) = map{_.i} @{S.A.u_y};
        my $GG = WM.W.G;
        my $sheet = w stylesheet[$GG, $K];
        die "GG.name has style $K ? " unless length($sheet);
        # may need to careful order new appendages too?
        $sheet ? "\n$sheet\n" : "";
     
  - K: ux #c
    O: ux
    spawn: []
    S:
      tag: ux
    styles: te
    conor: 1
    print: |
       "S.K S.id  (".S.i->pi
       

R:
 - K: M
   findway: R_M
     
hooks:
  percolate_R: |
    # Rushing: sets up the default R:M, could be many
    G.theM = $G->R('M');
    # ^ for holding this whole M business together
    G.theM.Wo = G.theM.A->spawn(R => 'non'); # $G->R();
    G.theM.Wo.K = "WoM"; # TODO
    
    # ^ for holding the C:W, C:Ms, C:uxs
    
    my $uWa = {K => 'W', W => G.theM.Wo, R => G.theM};
    G.theM.W = w G.theM.Wo fuu(u => $uWa); # the unified into wormhole
    # ^ hardlink
    # all before perc_late makes things humm/mux
  mux: |
    my $K = ar.K || "M";
    my $M = K R:$K;
    my $MR = G.R; # default is the non of the whole G
    # the W side is R:M.Wo (G.theM.Wo)
    my $a = {%$ar};
    my $u = delete a.u;
    saybl "Muxing UUUU ".$M->pi."     via ".$MR->pi."      with ".$u->pi;
    a.v ||= 7; 
    w $M mux[$MR,$a,$u];
  remux: |
    my $M = G.theM;
    my $MR = G.R;
    my $a = {%$ar};
    my $u = delete a.u;
    w $M remux[$MR,$a,$u];
R_Ms:
  mux: |
      my $M = w $R Mr[$MR]; # not G.theM, which is now $R
      my $TV = R.W.TV; # R.W is the C:W
      my $u = ar.u || [];
      
      my $us = [ref $u eq 'ARRAY' ? @$u : $u];
      
      $a = {k=>$a} if !ref $a;
      
      TV.bz->('W 4', R.W) if a.full;
      
      TV.bz->("M/M.id 6", $M);
      
      my $v = a.v if defined a.v;
      $v ||= 4;
      # 1-9 -> humm/links/etc
      
      for my $u (@$us) {
          next unless defined $u;
          die wdump($u) unless ref $u eq 'C';
          die if u.K eq 'ux';
          say "mux $v ".$u->pi;
          TV.bz->("i/u.id $v", $u); # v maybe subtle
          TV.bz->("i/u.id%M 4", $M); # two divides - then M can optimise 7
      }
      
      0->sing(uxd => sub { w $R uxd; }, again=>1, begin=>0.2);
  remux: | # upgrading the rubble before life arrives
    my $TV = R.W.TV;
    my ($goner) = grep { _.s eq $u } w $R JV[$TV];
    my $s = delete TV.bb->{goner.r};
    $s eq $goner || die;
    my $v = ar.v;
    $v ||= 9; # TODO naw
    TV.bz->(goner.T."\t".$v => goner.s);
  uxd: |
    my $TV = R.W.TV;
    G.R->phat(R.W.TV = {}); # flush
    w $R ux[$TV];
  Mr: |
      my $Ma = {K => 'M', W => $MR};
      my $M = w R.Wo fuu(u => $Ma, q=>1); # the lines' W mirrored
      M.A->umk(R.W, 'M');
      M.A->umk($MR,'W'); # our long wave of the origin W (R/J)
      $M
  JV: |
    my @J;
    my $TV = ar.TV || ar.V;
    my $bb = TV.bb;
    for my $k (keys %$bb) {
        my $j = $bb->{$k};
        undef $j unless ref $j eq 'HASH' && j.t; # go round
        $j ||= $bb->{$k} = $R->shj($k, $bb);
        j.T ||= j.t;
        (j.t,j.l) = ($1,$2) if j.t =~ /^(.+?)(%.+)$/;# pooling pull of lingo
        j.to ||= (j.t =~ /^(\w+)/)[0]; # ^
        
        if (ar.les) {
            if (ar.les eq '*') {
            }
            elsif (ar.les eq '%') {
                next if !defined j.l;
            }
            else {
                next if ar.les ne j.l;
            }
        }
        else {
            next if defined j.l;
        }
        
        push @J, $j;
    }
    @J
  orde: | # group by t or so ($k) and sort in by voltage
    my ($k, $v) = %$ar;
    my $by = {};
    $by->{"$_->{$k}"}->{_.r} = $_ for @$v;
    my @m = sort keys %$by;
    my $mi = 0;
    sub {
        my $t = $m[$mi++];
        return if !defined $t;
        $t = $by->{$t};
        
        # and bab clone sorting cv over T # already grouped by t or so
        # should come out same as style flows round that %ish place: /
        # note string compare, fractions most success, the structure of decimal is a lie
        my @mm = sort { a.r cmp b.r } values %$t;
        
        #saybl "sort hop: _.r" for @mm;
        
        return \@mm;
    };
  ordey: |
    my $to = delete ar.to;
    my $ew = w $R orde;
    my $or;
    $or = sub {
        my $mw = $ew->() || return;
        my $am = {m=>$mw,t=>[],l=>[]};
        for my $m (@$mw) {
            my $at = m.l ? am.l : am.t;
            push @$at, $m;
        }
        #sayyl "$to lives: _.r => ".(ref _.s eq 'C' ? _.s->pi : _.s) for @{am.t};
        #saygr "$to styles: _.r => ".(ref _.s eq 'C' ? _.s->pi : _.s) for @{am.l};
        if (!@{am.t}) {
            warn "^ no things, next";
            return $or->();
        }
    
        $am;
    }
  orderv: |
    my $TV = ar.TV || ar.V;
    my $les = '*';
    my @J = w $R JV[$TV, $les];
    my @WJ = grep{_.to eq $to} @J;
    my $ew = w $R ordey(t=>\@WJ, to=>$to);
    return { ew => $ew, wj => \@WJ };
  pv: |
    my $n = ar.n || 1;
    my $name = "RD$n";
    sayre "            Daving $name => ".gp($i) for 1..2;
    my $dg = H.G K G:C;
    $dg w Dave(K=>"C",Dname=>$name,i=>$i);
              
    
  three: |
    if ($to eq 'i') {
        my $i = $s;
        ref $s eq 'C' || die $s;
        my $M = (TV.bb->{"i/i.id%M 4"}||die)->{s};
        my $ux = (V.bb->{"i/i.id%u 3"}||{})->{s};
        $p->{4}->{"M/M.id"} = $M;
        # also in M n_ux
        # also fuu might find the swaying identity (.K & .B) and return it
        say "for i i.id ".$i->pi;
        if ($ux) {
            say "Found u~! ux.i.id ".$ux->pi if $ux;
            die if ux.i ne $i;
        }
        else {
            # add C.Bs override for little B schemas not in .B.?
            my $uxa = {K => 'ux', i => $i};
            uxa.B.i = uxa.i;
            $ux = w R.Wo fuu(u => $uxa, q=>1);
        }
        ux.A->umk($M, 'ux');
        ux.A->umk(ux.i, 'U'); # into alien space
        V.bz->("i/i.id%u 3", $ux);
    }
  four: |
            if ($to eq 'i') {
                saybl "Four i";
                # the 374 coil, ux set must be complete
                # ux nests under another ux like origin
                # and M must humm after (reversal after 3
                my $ux = (V.bb->{"i/s.id%u 3"} || die)->{s};
                my $M = (TV.bb->{"i/s.id%M 4"} || die "no i/s.id.'%M 4'")->{s};
                
                push @{M.tohu||=[]}, $ux;
                
                for my $iu (@{ux.i.A.u_S||[]}) { # or whatever
                    my $u = (V.bb->{"i/iu.id%u 3"} || next)->{s};
                    die if $iu ne u.i;
                    $p->{5}->{"i/iu.id"} = $iu; # must go through to get here
                    ux.A->umk($u, 'uS'); # relatable
                }
            }
            elsif ($to eq 'M') {
                my $M = $s;
                my $got = M.vom; # before
                my $needmore = 0;
                for my $ux (@{M.tohu||[]}) {
                    next if $got->{ux.id};
                    $needmore = 1;
                }
                if ($needmore) {
                    my $j = {};
                    my $jp = w $R Usurf(j=>$j, i=>$M);
                    my $vom = {reverse %$jp};
                    keys %$jp == keys %$vom
                    || die wdump[[sort keys %$jp], [sort values %$vom]];
                    M.vom = $vom;
                }
                M.tom = {}; # < ^ others 5s put moves forth to 6
            }
  five: |
  
            if ($to eq 'i') {
                my $i = $s;
                my $ux = (V.bb->{"i/s.id%u 3"} || die)->{s};
                my $M = (TV.bb->{"i/s.id%M 4"} || die)->{s};
                my $vom = M.vom;
                my $tom = M.tom;
                
                my $mv = $vom->{ux.id} || die;
                $tom->{$mv} = $ux;
                #say "for ".$ux->pi." has top go through $mv";
            }
  six: |
    my @mm;
            if ($to eq 'W') {
                push @mm, $s;
            }
            if ($to eq 'M') {
                my $M = $s;
                push @mm, $M;
                
                my $vom = M.vom;
                my $to = M.tom;
                my $pat = [];
                for my $k (sort keys %$to) {
                    push @mm, $to->{$k};
                    push @$pat, {k=>$k, ux=>$to->{$k}};
                }
                M.pat = $pat;
            }
    for my $i (@mm) {
        #next if i.K eq 'ux' && !$p->{5}->{"i/i.i.id"};
        #sayyl "SPAWN ".$i->pi;
    }
  seven: |
    my @mm;
            if ($to eq 'W') {
                push @mm, $s;
            }
            
            if ($to eq 'M') {
                my $M = $s;
                
                my $pat = M.pat;
                
                push @mm, map {_.ux} reverse @$pat;
                
                push @mm, $M; # after desc lines come back
            }
    for my $i (@mm) {
        sayyl "ARR ".$i->pi;
        w $R compile_figure[$i, $j];
        w $R wayout_sendo[$i, $j];
    }
  pto: |
    my @m;
    for my $cv (sort keys %$p) {
        if ($cv <= $lcv) {
            my @ere = sort keys %{$p->{$cv}};
            @ere = reverse @ere if ar.rev;
            for my $el (@ere) {
                my ($to) = split '/', $el;
                my $s = $p->{$cv}->{$el};
                push @m, {
                    r=>{p=>$p,V=>$V,TV=>$TV,s=>$s,to=>$to}, # to do
                    aft=>{cv=>$cv,lcv=>(ar.rcv||$lcv),el=>$el,s=>$s}, # to move
                };
            }
        }
    }
    my $i=0;
    sub {
        my $r = ($m[$i]||{})->{r};
        if ($i>0) {
            my $aft = $m[$i-1]->{aft};
            if (aft.lcv < 9) {
                delete $p->{aft.cv}->{aft.el};
                $p->{aft.lcv}->{aft.el} = aft.s;
            }
        }
        return undef unless $r;
        $i++;
        return $r;
    };
  ux: |
    # 1
    # very left of the dome, heading into micro peaks
    # we get more likely to fork
    #   as we go out along things that already exist
    #   they humm back to themselves at 8s
    #     where we can either switch to it as master
    #     or drop it if the thing wants a new 4 or so already
    
    # the W is what we propagate, where ux # slight singley for now
    # the M is Random input grouper - upstream patch panel to C
    # the i is a sack of i, somewhere under M
    
    # so fitting into RNAs those things are
    
    # G.R is R, the wormhole C:M muxes
    # G.theM is this R:M
    # aka R in here
    # R.W is C, the wormhole we are unifying
    # R.Wo is R:non, the wormhole of this RNA
    
    sayyl "\n ixomg ".$G->pi."    ".R.W->pi;
    my $W = R.W; # not really singular, crazy patchwork though
    my $V = R.W.V;
    my $les = '*';
    
    my @ONTV = w $R JV[$TV];
    my ($M) = map {_.s.W} grep {_.to eq 'M'} @ONTV;
        
    TV.bz->("W 6", $W) if !grep{_.to eq 'W'} @ONTV; # W always there
    
    my $p = {};
    # 2
    saybl "\n\n# 2";
    @ONTV = w $R JV[$TV];
    for my $j (@ONTV) {
        my $to = j.to;
        my $s = j.s;
        my $cv = j.cv;
        # 4 # response curves near
        
        $cv = 1 if $cv <= 3; # non hummed drops?
        if ($to eq 'i') {
            my $u = V.bb->{"i/s.id%u 3"};
            $u = u.s if ref $u eq 'HASH';
            if (s.dead) {
                w R.Wo del[$u];
                delete V.bb->{"i/s.id%u 3"};
                sayre "SOMETHING DIED: ".$u->pi;
            }
            $cv = 1 if !$u || !u.at; # sat in
        }
        else {
            $cv = 1 if !s.at; # sat in
        }
        
        $p->{$cv}->{"$to/s.id"} = $s;
        sayre "j.r\t->\t [ $cv";
    }
    
    my $tvp = { V=>$V, TV=>$TV, p=>$p };
    
    my $threes = w $R pto(%$tvp, lcv => 3);
    while (defined(my $r = $threes->())) {
        w $R three(%$r);
    }
    
    w $R JV[$V]; # V ups for %u 3
    
    my $fours = w $R pto(%$tvp, lcv => 4, rev=>1);
    while (defined(my $r = $fours->())) {
        w $R four(%$r);
    }
    

    my $fives = w $R pto(%$tvp, lcv => 7, rcv=>5);
    while (defined(my $r = $fives->())) {
        w $R five(%$r);
    }
    
    my $j = $G->nw(K=>'j', s=>[], c=>[], W=>$W, M=>$M, R=>$R);
    
    my $sixes = w $R pto(%$tvp, lcv => 6);
    while (defined(my $r = $sixes->())) {
        w $R six(%$r, j=>$j);
    }
                    
    my $sevens = w $R pto(%$tvp, lcv => 6);
    while (defined(my $r = $sevens->())) {
        w $R seven(%$r, j=>$j);
    }
    
    H.G w aj[$j];
    
    sayre "ux -------- G.K done\t\t".F_delta."  load ".$H->la;
    
    w aj[$j];
    
    if (0) {
        my $abb = { map { $_ => TV.bb->{$_}->{s} } keys %{TV.bb} };
        w $R pv(i=>$p,n=>2);

        my @JJJ = w $R JV[$V];
        my $ab = { map { $_ => V.bb->{$_}->{s} } keys %{V.bb} };
        w $R pv(i=>$ab,n=>1);
    }
    
  Usurf: | # TODO wants to climb up from extremity for speed, joining onto M pathways
    j.seenid->{i.id} = $i;
    my $jp = j.p ||= {};
    $j = {%$j};
    j.p = {};
    my $here = "i.id";
    $jp->{$here} = $here;
    my @down = w $R Udown;
    ar.d++;
    die if ar.d > 10;
    for my $d (@down) {
        my $jpp = w $R Usurf(j=>$j, i=>$d, d=>ar.d);
        for my $k (keys %$jpp) {
            $jp->{"$here/$k"} = $jpp->{$k};
        }
    }
    $jp;
    
    
    
    
    
  Udown: |
    # W->M->uxs, then uxs S amongst, y projects
    my $okn = { map {$_=>1} map {"n_$_"} qw'M ux S y' };
    my @ks = grep { $okn->{$_} } keys %{i.A};
    my @As = map { @{i.A->{$_}||[]} } @ks;
    my @down = map{_.i} @As;
    @down = grep {!ar.j.seenid->{_.id}} @down unless !ar.j || ar.allseeing;
    die if grep {_.dead} @down;
    uniq @down;
    
  compile_figure: |
        my $u = $i;
        my $ui = u.i if u.i;
        
        my $at = u.at = {};
        
        if (u.K eq "uW") {
            u.at = ui.at;
            sayre $ui->pi." wtf wtf ".$u->pi for 1..5;
            return;
        }
        
        # v the look-around-for-style-etc vortex v
        at.id = u.id; # probly... rest good to T
        at.tag = 0->uiuS($u => 'tag') || u.tag || u.K;
        at.ishtml = 0->uiuS($u => 'ishtml');
        at.class = 0->uiuS($u => 'class');
        
        my @styles;
        push @styles, u.styles, u.S.styles;
        push @styles, ui.styles, ui.S.styles if $ui;
        
        at.styles = join " ", grep {defined} @styles;
        
        
        at.tag ||= u.K;
        die "no tag" .sw($u) if !at.tag;
        
        at.conty = 0->uiuS($u => 'content');
        
        at.conty = "" if !defined at.conty;
        at.conty = encode_entities(at.conty) unless at.ishtml;
        
        
        my @down = w $R Udown(+ allseeing => 1);
        @down = sort { a.conor <=> b.conor } @down;
        at.ooze = \@down;
  wayout_sendo: |
        my $u = $i;
        my $ui = u.i if u.i && u.K eq 'ux';
        
        my $at = u.at;
        my $sendo = u.sendo = [];
        
        my ($s,$c) = ([],[]);
        my $do_S = sub { push @$s, shift };
        my $doj_S = sub {
            my ($id, $sp, @int) = @_;
            $do_S->("\$('#$id')".sprintf($sp, @int).";");
        };
        my $do_C = sub { push @$c, shift };
        # S is innards, C is complete (send all S before all C)
        # further thinking running on wholeness
        # order important
        my $_t = u._at;
        
        my $attr = at.attr = {
            id => at.id,
            class => at.class,
            %{ 0->uiuS($u => "attr") || {} },
        };
        
        my $conty = defined at.conty ? at.conty : "";
        my $oozs = [ grep { defined } map { _.html } @{ at.ooze } ];
        my $content = join "\n", @$oozs;
        
        at.Z = {}; # zip v
        
        at.Z = { %{at.Z}, %{u.Z} } if u.Z; # from u
        
        my $styles = at.styles;
        w stylezo[$u, $ui, $styles, $at]; # ye, wants to zip down Z too/
        # TODO widerly, the Z devolves into styles
        # and they're both about the same, Z translates and complicated styles
        # buzzing around here somewhere.
        
        my $Z = 0->uiuS($u => "Z"); # from ui S/Z(_D)
        at.Z = { %{at.Z}, %$Z } if $Z;
        
        $Z && attr.style && die "got uiu $Z\t\tattr.style already";
        
        at.css = at.Z;
        for my $k (keys %{at.css}) {
            my $v = at.css->{$k};
            if (ref $v eq 'HASH') {
                delete at.css->{flit} if $k eq 'flit';
                at.css->{'-webkit-filter'} = join " ",
                    map{ "$_($v->{$_})" } sort keys %$v;
            }
        }
        attr.title = "M H.style/H.name/H.id" if u.K eq "W";
        my $late = []; #c
        if (!$_t) {
            if ( $conty && $content ){
                warn "conty and ooze ".$u->pint;
                #sw(["contooz", $u, $conty, $content]);
                $conty = ",";
            }
            if (length($conty . $content) > 25000) {
                $content = "";
                $do_S->("\$('#at.id').append('$_');") for @$oozs;
            }
            for my $i ($u, $ui) {
                next unless 0;#$i && (i.S.sendo_init_D || i.Gw);
                #say "Snedoing ".$i->pi;
                my $Ce = w $i S/sendo_init_D[$u];
                $do_C->($Ce) if $Ce;
            }
            
            if ($u eq R.W) { # unified field of this W
                push @$late, sub {
                    $do_S->(
                        "\$('#ux > #at.id').remove();"
                    );
                    $do_S->(
                        "\$('#ux').append(".$H->ejson(u.html).");"
                    );
                };
                
                j._ && die "Already unified!?";
                j._ = $u; # TODO diffy for the J
            }
        }
        else {
            my $ino = sub { my ($u, $in) = @_; grep { $_ eq $u } @$in; };
            
            for my $newu (grep { !$ino->($_, u._at.ooze) } @{at.ooze}) {
            
                $doj_S->(at.id, '.append(%s)', $H->ejson(newu.html));
                
            }
            for my $gonu (grep { !$ino->($_, at.ooze) } @{u._at.ooze}) {
            
                $doj_S->(gonu.at.id, '.remove()');
                
            }
            if (at.conty ne _t.conty) {
            
                $doj_S->(at.id, '.html(%s)', $H->ejson(at.conty));
                
            }
            while (my ($k, $v) = each %{ at.attr }) {
                next if $v eq _t.attr->{$k};
                
                $doj_S->(at.id, '.attr(%s, %s)', $H->ejson($k), $H->ejson($v));
                
            }
            if (at.css) {
                my $anima;
                #saybl $u->pi."    ".wdump(at.css) if %{at.css};
                while (my($k,$v) = each %{at.css}) {
                    next if $v eq _t.css->{$k};
                    my $isa = '++';
                    # an uiuS for mergins Anim/* ?
                    
                    my $anim = 1 if ui.K eq 'Im';
                    #;#ui.K eq 'Do' && ($k eq 'left' || $k eq 'top');
                    if ($anim) {
                        $anima->{$k} = $v; # BB
                    }
                    else {
                        $doj_S->(at.id, '.css(%s, %s)', $H->ejson($k), $H->ejson($v));
                    }
                }
                if ($anima && %$anima) {
                    $anima = $H->ejson($anima);
                    $doj_S->(at.id, q".animate(%s, %s)", $anima, 1000);
                }
            }
        }
        attr.style .= shtocss(at.css) if at.css;
        my $tag = at.tag;
        my $mkat = sub {
            my $a = shift;
            my $v = $attr->{$a};
            return $a if $v eq "undef";
            return $a.'="'.$attr->{$a}.'"'
        };
        # style/class gets misccss/Wcss
        $attr = join " ", map { $mkat->($_) }
            grep { defined $attr->{$_} && $attr->{$_} ne "" } sort keys %$attr;
            
        u.html = "<$tag $attr>$conty$content</$tag>";
        $_->() for @$late; # what needs u.html
        
        u._at = $at;
        
        push @{j.s}, reverse @$s;
        push @{j.c}, reverse @$c;
  event: |
    my $uy = $i if $i ne $ux;
    my $i = ux.i if $ux;
    $i = undef if !$ux;
    my $E = {
        e => $e,
        W => $W,
        i => $i,
        ux => $ux,
        uy => $uy, # something with ID beyond the ux, may be grasped...
        # TODO liesy after styley tagname anarchy
    };
    
    saybl " W ". $W->pi if $W;
    saybl " UX ". $ux->pi if $ux;
    saybl " Uy ". $uy->pi if $uy;
    return saygr "ungrasped line" unless $i;
    saybl " i ". $i->pi;
    
    # TODO make a pattern about y=to match against Eways...
    i.G w event(%$E);

