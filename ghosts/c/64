
Goo: | # Gto is made, babbed, things for G's I which is G itself
    u allacgts
    
    n Gooso =>W
    n Goodat =>W
    n Gooway =>W
    n Goolog =>W
    Rw Ghuts;
Galso: | # Gooso goner
    G.h = sub {
        my $am = shift;
        my $D = $F[0];
        my $r = D.ar;
        my $A = r.A || die 'GhnoA';
        my $I = A.I || die 'GhnoI';
        I.d&Other,$am;
    };
    my %T = %{G.T||{}};
    G.T = \%T;
    {
        package Wormhole;
        use Tie::Hash;
        use YAML::Syck;
        our @ISA = qw(Tie::StdHash);
        sub FETCH {
            my ($s,$k) = @_;
            $s->{$k} ||= do{ 
            print "Loading w/$k ...\n" for 1..5;
            LoadFile("w/$k") };
        }
    }
    tie %T, 'Wormhole';
Gooso: |
    u allacgts
    
    # G.h&In # finds relevant A.I to AI.d&Other with, returning ($A,$I)
    n h =>''=><<''
        my $D = $F[0];
        my $r = D.ar;
        my $A = r.A || die 'GhnoA';
        my $I = A.I || die 'GhnoI';
        I.d&Other,$s;

    # see also Loading for ongoign G.T timeyness
    n T =>''=><<''
        my %T = %{G.T||{}};
        G.T = \%T;
        {
            package Wormhole;
            use Tie::Hash;
            use YAML::Syck;
            our @ISA = qw(Tie::StdHash);
            sub FETCH {
                my ($s,$k) = @_;
                $s->{$k} ||= do{ 
                    print "Loading w/$k ...\n" for 1..5;
                    LoadFile("w/$k");
                };
            }
        }
        tie %T, 'Wormhole';
Goodat: |
    u allacgts
        
    n mkD =>''=><<'',{acgt=>'pin,ar'}
        my $D;
        D.point = $pin;
        if (my $C = ar.__D) {
            delete ar.__D;
            D.bab = C.c.s || die "N s".ki $C;
            D.noise .= C.sc.dige if C.sc.dige;
            D.Verb = 1;
        }
        D.ar = $ar;
        D.name = join ' ', D.point, sort keys %{D.ar};
        D.sign = "Z";
        D.talk = join' ',grep{defined}map{$D->{$_}}qw'sign name noise';
        $D;

    n pwin =>''=><<'',{acgt=>'pin,way'}
        my $point = shift;
        return $way->{$point} if exists $way->{$point};
        my @path = split /\/|\./, $point;
        my $h = $way;
        for my $p (@path) {
            $h = $h->{$p};
            unless ($h) {
                undef $h;
                last;
            }
        }
        return $h if defined $h;
        . 
        return undef unless $point =~ /\*/;
        die "sat rs findy $point";
    
Gooway: |
    u allacgts
    
    n w =>''=><<'',{acgt=>'pin,ar'}
        my $D = G.mkD->($pin,$ar);
        .
        if (!defined D.bab) {
            D.bab = G.way->{$pin};
        }
        .
        if (!defined D.bab) {
            if ($pin =~ /\//) {
                #say "windshot: $pin" unless $pin =~ /^pi/;
                D.bab = fwind(G.way,$pin);
            }
        }
        .
        if (!defined D.bab && !ar.__D && ar.A) {
            my $c = ar.A;
            map{$c = $c->{$_} if $c} qw'J A II W 0.4';
            if ($c) {
                my $C = $c->{$pin};
                if ($C) {
                    c.sc.acgt && die "selected W4".ki$C;
                    ar.__D = $C;
                    $D = $mkD->($pin,$ar);
                }
            }
        }
        .
        if (!defined D.bab) {
            die "Not findin D.talk";
            return;
        }
        .
        G.log->(D.talk) if G.logs;
        .
        my $Z = G.Doming->($D);
        G.randomtask->() if G.randomtask;
        my $r; eval { $r = [ G.D->($Z) ] };
        sayyl "D.talk BANG: $@" if $@ && 5 > split 'âŠ˜',$@;
        G.Done->($Z);
        .
        if ($@) {
            D.nodie || die $@;
            $@ = "";
        }
        return wantarray ? @$r : $r->[0];
    
Goolog: |
    u allacgts
    
    n rese =>''=><<'','%code:G 1'
        `rm w/glog`;
        G.logs = 1;
    
    n log =>''=><<''
        write_file('w/glog', {append=>1}, "\n$s");
    
    
Babz: |
    # see <<'' and levitate
    u allacgts
    
    n bitsof_babble =>''=><<'','%bab:non,subpeel:1'
        my $p;
        p.alive = qr/\$[\w]*[\w\->\{\}]+/;
        p.dotha = qr/[A-Za-z_]\w{0,3}(?:\.[\w-]*\w+)+/;
        p.oing = qr/p.alive|p.dotha|[-\w]{8,}/;
        p.oint = qr/[\w\$\/\->\{\}\*]*[\w\$\/\->\.\}\*]+/;
        p.mwall = qr/(?:= |if |unless |^\s*)/m;
        p.sur = qr/ if| unless| for| when|,\s*$|;\s*/;
        $p
    
    n parse_babble =>''=><<'','%bab:non'
        my $p = G.bitsof_babble;
        # gone:
        my $Jsrc = qr/(J\d*(?:\.\w+)?) (\w+)/;
        my $Jlump = qr/(\S+) (\S+)\s+(\S.+)/;
        $s =~ s/p.mwall$Jsrc $Jlump$/$1.$2->("$3\\t$4" => $5);/smg;
        .
        # :
        my @s;
        my $indbe;
        for my $s (split "\n", $s) {
            if ($indbe) {
                if ($indbe eq 'nextind') {
                    $s =~ /^(\s+)/;
                    $indbe = qr/^$1/;
                }
                if ($s =~ $indbe) {
                    push @s, $s;
                    next;
                }
                else {
                    undef $indbe;
                }
            }
            if ($s =~ /<<['"](\w*)['"]/) {
                $indbe = $1 ?
                    qr/^(?!\Q$1\E)/ # for <<'EOD' til ^EOD, etc
                  : 'nextind';
            }
            $s =~ s/(p.mwall)(\w*A)(\w+)\(/$1$2\.$3->(\$J, /smg;
            $s =~ s/(p.mwall)(\w*G)(\w+)\(/${1}G\.$3->(\$A,\$C,\$G,\$T, /smg;
            $s =~ s/(p.mwall)(\w*J)(\w+)\(/$1$2\.$3->(\$$2, /smg;
            $s =~ s/(p.mwall)(\w*M)(\w+)\(/${1}J\.m->(\$$2, /smg;
            .
            $s =~ s/(p.mwall)(u|n) (.+?);?$/${1}J\.$2->($3=>'');/smg;
            #$s =~ s/(p.mwall)(m) (\w+)\(/${1}J\.$3->(\$M, /smg;
            .
            # lma quack $not->('tag');? from I.d&pui,$s
            $s =~ s/(p.oing|\w+)\&(p.oint)(,[^\s;]+)?(;)?/
                my $s = "$1->(\"$2\"$3)$4";
                $s = '$'.$s if $1 !~ m{\.};
                $s
            /smge;
            # $sc>$k -> $sc->{$k}
            $s =~ s/(p.oing)((?:\.>p.oing)+)/
                join '->', $1, map {'{"'.$_.'"}'}
                grep {$_} split m{\.>}, $2;
            /smge;
            .
            while ($s =~ /(?:^| )(Rw ((?:\*\/)?p.oint)(?: (.+))?)p.sur?$/gsm) {
                my ($old, $p, $a) = ($1, $2, $3);
                my $g;
                $g ||= '$G';
                .
                my $ne = ""; # hidden reverse
                $ne = $1 if $a =~ s/(p.sur)$//;
                .
                my @n;
                my @m;
                # want to mix {m m m %$ar m m} whereever + is
                my $wanr = $a =~ s/^\+ ?//;
                $wanr = 'stick' if $a =~ s/^- ?//;
                for (split /\,| |\, /, $a) {
                    # sweet little pool... $J:geo etc
                    if (/^\$((\w+(:|=))?\S+)$/) {
                        my ($na, $fa, $wa) = ($1, $2, $3);
                        if (!$fa) { # fake name, to ar
                            $fa = $na;
                        }
                        else {
                            $na =~ s/^\Q$fa\E//;
                            $fa =~ s/(:|=)$//;
                            if ($wa eq '=') {
                                $na = '"'.$na.'"';
                            }
                        }
                        $na = '$'.$na unless
                            $wa eq '=' || $na =~ /^\S+\.\S/;
                        #saygr "from: $a          na: $na";
                        push @n, "$fa => $na" ; # also avail a listy position
                    }
                    else {
                        push @m, $_;
                    }
                }
                unshift @n, '%$ar' if (!@n || $wanr) && $wanr ne "stick"; 
                # could use ^ here # edpeak?
                push @n, "m => [".join(',',map{'"'.$_.'"'}@m).']'
                    if @m;
                .
                my @e;
                push @e, '"'.$p.'"';
                push @e, "{".join(", ",@n)."}";
                my $en = join ", ", @e;
                .
                my $wa = $g.'->{w}->('.$en.')'.$ne;
                die "Delay" if $delay;
                $s =~ s/\Q$old\E/$wa/          || die "Ca't replace $1\n\n $s";
            }
            .
            # sc.k -> $sc->{k};
            $s =~ s/(?:(?<=\W)|^)(?<!\\)([A-Za-z_]\w{0,3})((?:\.[\w-]*\w+)+)/"\$$1".join"",map {"->{$_}"} grep {length} split '\.', $2;/seg;
            # 
            $s =~ s/aft \{/acum \$F[0] => _after_do => sub {/sg;
            #
            .
            push @s, $s;
        }
        $s = join "\n", @s;
        .
        $s;

