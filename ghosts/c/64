
Down: |
    y.at.isle = 'U';
    n Tides
    n Goodat
Ise: |
    n KnowTime
    n Shelf
    n Rob
Rob: |
    u allacgts
    n robeg =>'',<<''
        # look
        my $D = $s;
        my $eg = D.sc.eg;
        $eg =~ s/\//::/g;
        say "Robeg for D.t looking in $eg";
        return 0; # TODO
Dwight: | # grab old subs of G
    J.A.IIII = [@{G.IIII},'G/T/Draw'];
    J.VV.N = 1;
    n e=>''=>3
    sayyl "FOudn :".wdump 2, A.J.A.I.Mo;
    my $lot = "g/G/on g/G/way g/0/G g/G/cis";
    n shedful => '0.1-0.7', {pi=>'seas',s=>$lot}
    
G: | # GGG subs, must get wormholes to do this this shortly
    my $f = "w/J.name\.yml";
    my $N = -f $f ? LoadFile($f) : do {
        my $ay = 
        n Dwight
        my $N = Rw getJN $J:ay.nj $I:ay.I $pi=clife;
        # for cfile drop cache by mtime
        delete _.c.from for @$N;
        DumpFile($f,$N);
        $N
    };
    return sayyl "isleless J.name, assume stop" if !J.at.isle;
    for my $D (@$N) {
        my $s = D.sc.style;
        D.sc.head = 1         if D.t eq 'head';
        D.sc.bab = 'non'     if $s eq 'nonbabble';
        D.sc.subis = 1         if $s eq 'func' || $s eq '';
        D.sc.export = 1     if $s eq 'func';
        if (D.sc.head && !D.sc.export) {
            my $e = [];
            push @$e, $1 while D.c.s =~ /use \S+ (?:qw)?\W([\w\s]+)\W;/sgm;
            D.sc.export = join ' ', @$e;
            sayyl "Have ".wdump 4, $D;
        }
        D.c.s = "my \$G = shift;\n".D.c.s
                            if $s eq '';
        D.c.s = "sub D.t {\n".D.c.s."\n}"
                            if D.sc.subis;
        D.c.from = "G";
    }
    @$N = reverse I.d&sorp,'sc/head',@$N;
    #delete _.y.cv for @$N;
    sayyl "Came back : _.sc.head "._.t for @$N;
    
    if (1) {
        my $E = {};
        for (@$N) {
            my $kip = join ' ', sort keys %{_.sc};
            E.tisc->{$kip}++;
            E.styles->{_.sc.head} .= "_.t ";
            E.subi->{_.sc.subis} .= "_.t ";
        }
        say wdump [$E];
    }
    @$N = grep{_.t ne 'wag'} @$N; # anything with H... 
    u allcode
    Mn($N);
    
Ear: |
    n Down
    n Ise
    n G
    n Ngwe
Goth: | # agther limbs (Ear)
    u GBabz
    my ($A) = 
    n s=>'13'=>see
    my $I = A.I;
    y.at.isle = 'U';
    my $E = {};
    my ($X,$N) = Rw Xisle U Ear;
    for (@$N) {
        my $kip = join ' ', sort keys %{_.sc};
        E.tisc->{$kip}++;
        push @{E.from->{_.c.from}||=[]}, $_;
    }
    my @to;
    my $tld; # 'StyleHose'
    for my $k (sort keys %{E.from}) {
        my $t = {};
        my ($il,$i) = $k =~ /^(.+)\/(.+?)$/;
        my $N = E.from->{$k};
        @$N = I.d&sorp,'t',@$N;
        @$N = I.d&sorp,'y/cv',@$N;
        t.pack = join("::",grep{defined}$tld,split'/',$k);
        t.head = [];
        t.l = [];
        for my $D (@$N) {
            ref D.y || die "Dy nonref ".ki $D;
            say "Got D.c.from : D.y.cv    D.t";
            D.sc.eg = t.pack;
            $D = I.d&hup,$D;
            my $s = delete D.c.s;
            $s =~ s/A\.I\.d {0}\&An;\s*$//s if D.t eq 'An';
            $s = I.d&parse_babbl,$s unless D.sc.bab eq 'non';
            $_ && $_ ne 'non' && die "INter bab D.t bab=$_" for D.sc.bab;
            my $nov = wdump 5, $D;
            die "TOo long D D.t: $nov" if length($nov) > 500;
            my $wh = D.sc.head ? 'head' : 'l';
            t.II->{D.sc.code}->{D.y.cv}->{D.t} = $D
                unless D.sc.head || D.sc.subis || D.sc.code eq 'Pack';
            acum $t=>$wh=>$s;
            if (my $e = D.sc.export) {
                $e = $e ne '1' ? $e : D.t;
                acum $t=>export=>$e;
            }
        }
        if (t.II) {
            push @{t.l}, '$A->{II} = Load(<'.'<STEVE);', Dump(t.II), 'STEVE','';
        }
        if (my $e = t.export) {
            push @{t.head},
                "use Exporter 'import';",
                'our @EXPORT = qw('.join(' ',@$e).');',
                '';
        }
        unshift @{t.l},grep{defined}
            "package t.pack;",
            'use strict;',
            'use warnings;',
            (t.pack ne "G" ? "use G;" : ""),
            "our \$A = {};",
            @{t.head},
            '';
        push @to, $t;
    }
    my $lib = 'othlia';
    my @inc;
    for my $t (@to) {
        my @el = split '::', t.pack;
        my $fi = pop @el;
        my $dir = join '/', $lib, @el;
        `mkdir -p $dir` if !-d $dir;
        my $code = join "\n", @{t.l};
        my $f = "$dir/$fi\.pm";
        write_file($f, $code);
        push @inc, t.pack;
    }
    n othing=>''=><<'','%code'
        say "Not nothing here";
    
    
got: |
    u GBabz
    my ($A) = 
    n s=>'13'=>see
    my $I = A.I;
    my $inc = "othlia";
    my @find = grep {!/\/\./} map{chomp;$_}`find $inc`;
    my $as = {map{$_=>1} grep {-f $_} @find};
    my $se = {};
    for my $in (keys %$as) {
        (my $o = $in) =~ s/\/\w+(\.pm)$/$1/;
        $se->{$in} = 1 if $as->{$o};
    }
    my @in = map{delete $as->{$_};$_} keys %$se;
    my @inc = sort keys %$as;
    s/^$inc\/(.+)\.pm/$1/ || die "NOgot $_" for @inc;
    s/\//::/sgm for @inc;
    # ^ include topmosts
    
    my $l=[
        'use strict;',
        'use warnings;',
        'use FindBin qw($Bin);',
        'use lib "$Bin/othlia";',
        (map{"use $_;"}@inc),
        'our $A = {};',
        '$A->{I} = {};',
        '$A->{AAAA} = [',
        join(',',map {'$'.$_.'::A'} @inc).'];',
        I.d&parse_babbl,G.way.gothat ,
    ];
    
    write_file('got',join("\n",@$l));
    
    
    n othing=>''=><<'','%code'
        say "Not nothing here";
    
    
gothat: |
    for my $AA (@{A.AAAA}) {
        my @D = map{values%$_} map{values%$_} values %{AA.II};
        my $ne = {map{$_=>1}keys%{AA.I}};
        for my $D (@D) {
            delete $ne->{D.t} || sayre("II index for not in I: ".ki$D) && next;
            A.I->{D.t.'_dige'} = D.sc.dige;
            A.I->{D.t} = AA.I->{D.t};
            A.tople->{D.t} = 1;
        }
        saybl wdump 3, $AA;
    }
    sayyl "Have : ".join' ', sort keys %{A.tople};
    my $G;
    G.up = hitime();
    G.id = mkuid();
    G.I = A.I;
    my $C = {};
    my $T = {};
    
    for my $sn (qw'pwin tie h w') {
        $G->{$sn} = G.I->{$sn} || die "No $sn from G I";
    }
    $SIG{__WARN__} = sub {
        my $ing = shift;
        warn$ing unless $ing =~ /^Use of uninitialized/;
    };
    G&init;
    G&w,'expro';
     Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
Ngwe: |
    u allacgts
    
    n 'w'=>'',<<'',{acgt=>'pin,ar'}
        sayyl "Got www $pin   with ".ki $ar;
    
    # etc
    
Shelf: |
    u allacgts
    n h =>'',<<''
        my $y = A.I->{$s} || die "No way named $s on A.talk";
        $y->($A,$C,$G,$T,@Me);
    
    n A =>''=><<''
        ($A,my$up) = ({},$A);
        A.G = $G; # for wiring from A (G/T/Hypo)
        A.up = $up;
        A.mo = $A;
        ($C,my$S) = ({},$C);
        C.c.J = shift @$S;
        C.c.M = $S->[1] if 2 == grep{ref$_ eq 'ARRAY'}@{$S}[0,1];
        C.c.N = C.c.M ? $S->[0] : $S;
        A.N = [@{C.c.N}];
        A.M = [];
        A.J = C.c.J if C.c.J;
        A.J || die "NOJ";
        .
        A.fl = C.c.fl || {};
        A.am = $s || die "unsame?";
        A.talk = (A.J.le&&"(A.J.le.name)").A.J.name;
        {
        my $I = A.I = {};
        my $II = Rw collaspII $A;
        I.Ii = II.Ii;
        say "A.talk wants : II.Ii";
        # split from R, dispatches of patches as I.$k = CODE
        # base exuder of self if no Ii resol
        %$I = (%$I,%{G.I});
        I.Ii = II.Ii;
        # throw in from R exact Ii, bits of Ii to I before t gets it
        if (my $re = delete G.drop.recycling->{A.J.id}->{A.am}) {
            sayyl "Recyclo A.talk --- I.Ii  (".keys %$I;
            if (re.Ii eq I.Ii) {
                %$I = (%$I,%$re);
                A.cv = 0.1;
            }
            else {
                sayre "Recycloped, Diff I.Ii  <--  re.Ii";
            }
        }
        I.d&An;
        A.t&1;
        A.t&11111 || warn "NO 1";
        }
        ($A,$C,$T)
    
    n recycle =>''=>{s=><<''}
        return if I.recyttl++ > 38;
        G.drop.recycling->{A.J.id}->{A.am} = $I;
    
    n Act =>'',<<''
        A.s = shift @{A.N};
        if (ref A.s eq 'HASH' && A.s.J && A.s.mo && A.s.talk) {
            $A = A.s;
            A.mo eq $s || die "A.talk  mo A.mo.talk not s.talk";
            $C = A.C||die"travcno A.talk";
            $T = A.T ||= {};
        }
        else {
            $A = {%$s};
            A.mo.ont = $A; # keep
            $C = A.C = {};
            $T = A.T = {};
        }
        T.oM = [];
        G&An;
        A.t&2;
        ($A,$C,$T)
    
    n An =>101,<<''
        A.I || die "GimeI";
        A.note = {}; # pinging csc
        A.c = sub { G&c,@_; };
        A.e = sub { G&e,@_; };
        A.us = sub { G&us,@_; };
        A.t = sub { G&t,@_; };
        A.V = sub { A.J.VV && A.J.VV->{$_[0]} || A.J.V };
        $A
    
    #c ventlike      ඬ
    # make pool, synth space, want arches
    # fork & rejoin to exciting place
    # the valley, what it means to be here in here YIN
    # todo undef $s as repl, J ventlike
        #  $J, [in], [out]
    # @M = $s + @Me
    # Mn(.+) is n $J [$1] $M
    n n =>'',<<''
        $C = [$s,@Me];
        ($A,$C,$G,$T) = G&A,'In';
        G&loop;
    
    n m =>'',<<''
        $C = [$s,@Me];
        ($A,$C,$G,$T) = G&A,'Mo';
        G&loop;
    
    n Sev =>'',<<''
        $C = [Elvis=>''=>{J=>$s,Y=>'Pre',V=>'Duv'}];
        $C = [$s, $C];
        ($A,$C,$G,$T) = G&A,'Sev';
        A.I.scIfs || die "NO scIfs: A.J.name";
        G&loop;

    n loop =>'',<<''
        my $i;
        @{A.N}||die"nois".wdump[$C,$A];
        while (@{A.N}) { #
            $i++ > 5000 && die "Huge Indi";
            my ($A,$C,$T) = G&Act,$A;
            T.not&&next;
            A.t&6;
            T.not&&next;
            G&flywheels;
            T.not&&next;
            A.t&78;
            T.not&&next;
        }
        continue { I.d&z; }
        A.t&8;
        G&recycle;
        (A.nj) = values %{A.Js} if A.Js && keys %{A.Js} == 1;
        if (C.c.M) {
            @{C.c.M} = () if C.c.M eq C.c.N;
            my @un = uniq @{A.M};
            die "ManyofsameM: ".wdump 3, A.M if @{A.M} > @un;
            push @{C.c.M}, @{A.M};
            $A
        }
        elsif (C.c.J) {
            G&Mo,C.c.J,A.M,C.c.M||[];
        }
        else {
            die "noJMout";
        }
Tides: |
    u allacgts
    n tie =>0.09=><<'','%acgt:class'
        my %na;
        tie %na, $class, @Me;
        return \%na
    
    # see also Loading for ongoign G.T timeyness
    n T =>''=><<''
        my $e = I.d&tie,'Wormhole';
        %$e = (%$e,%{G.T}) if G.T;
        G.T = $e;
        G.T.base = 'w';
        G.T
    
    u allpack
    # for the hash of a filesystem
    # results must be kept up to date otherwise
    # (use only as G.T & Loading)
    n Wormhole =>''=><<''
        {
            package Wormhole;
            use Tie::Hash;
            use YAML::Syck;
            our @ISA = qw(Tie::StdHash);
            sub FETCH {
                my ($s,$k) = @_;
                $s->{$k} ||= $k eq 'dir' ? return : do {
                    my $d = s.dir;
                    my $il = join('/', grep{defined} $d, $k);
                    my $f = s.base.'/'.$il;
                    if (-d $f) {
                        my %Di;
                        tie %Di, 'Wormhole';
                        my $di = \%Di;
                        di.base = s.base;
                        di.dir = $il;
                        $di
                    }
                    elsif (-f $f) {
                        print "Loading $f ...\n";
                        LoadFile($f);
                    }
                    else {
                        die "Wormhole sens nothing: $f";
                    }
                };
            }
        }
    
    # for the T.at that also sees J.oy.at
    n Ghoz =>''=><<''
        {
            package Ghoz; #
            use Tie::Hash;
            our @ISA = qw(Tie::ExtraHash);
            sub TIEHASH {
                my $class = shift;
                my $sto = bless [{},@_], $class;
                $sto
            }
            sub FETCH {
                my ($s,$k) = @_;
                my ($st,@o) = @$s;
                return $st->{$k} if exists $st->{$k};
                option:
                for my $o (@o) {
                    if (my $in = o.inp) {
                        my $v = o.o;
                        for my $i (@$in,$k) {
                            exists $v->{$i} || next option;
                            $v = $v->{$i};
                        }
                        return $v;
                    }
                    else {
                        die "Hwoto climb a ".G::ki $o;
                    }
                }
            }
        }
        
Goodat: |
    u allacgts
    
    n pin =>''=><<'',{acgt=>'pin,way'}
        I.pwin || die "nopwin from pin";
        I.pwin->($pin,$way);
    
    n pon =>''=><<'',{acgt=>'pin,way,s'}
        I.pwin || die "nopwin from pin";
        I.pwin->($pin,$way,{et=>$s});
    
    n sorp =>''=><<'',{acgt=>'pin'}
        I.pwin || die "nopwin from pin";
        sort { I.pwin->($pin,$a) cmp I.pwin->($pin,$b) } @Me;
    
    n norp =>''=><<'',{acgt=>'pin'}
        I.pwin || die "nopwin from pin";
        sort { I.pwin->($pin,$a) <=> I.pwin->($pin,$b) } @Me;
    
    # non acgts
    # ref = T makes it look for jointed rest of path in tiedinto {}
    # then Tied hashes make connections, collapses the feely data mesh
    n pwin =>''=><<'',{args=>'pin,way,set'}
        if (exists $way->{$pin}) {
              my $o = $way->{$pin};
            $way->{$pin} = set.et if exists set.et;
            delete $way->{$pin} if set.de;
            return $o;
        }
        my @path = split /\/|\./, $pin;
        my $h = $way;
        my $last;
        for my $p (@path) {
            if (ref $h ne 'HASH' && ref $h ne 'G') {
                undef $last;
                undef $h;
                last;
            }
            $last = [$h,$p];
            $h = $h->{$p};
        }
        if ($last) {
            my ($he,$pi) = @$last;
            $he->{$pi} = set.et if exists set.et;
            delete $he->{$pi} if set.de;
        }
        return $h if defined $h;
        . 
        return undef unless $pin =~ /\*/;
        die "sat rs findy $pin";
    
Gooway: |
    u allacgts
    
    n w =>''=><<'',{acgt=>'pin,ar'}
        my $D = GmkD($pin,$ar);
        .
        if (!defined D.bab) {
            D.bab = G.way->{$pin};
        }
        .
        if (!defined D.bab) {
            if ($pin =~ /\//) {
                D.bab = Gpwin($pin,G.way);
            }
        }
        .
        if (!defined D.bab && !ar.__D && ar.A) {
            my $c = ar.A;
            map{$c = $c->{$_} if $c} qw'J A II W 0.4';
            if ($c) {
                my $C = $c->{$pin};
                if ($C) {
                    c.sc.acgt && die "selected W4".ki$C;
                    ar.__D = $C;
                    $D = GmkD($pin,$ar);
                }
            }
        }
        .
        return die "Not findin D.talk" if !defined D.bab;
        .
        Glog(D.talk) if G.logs;
        .
        my $Z = GDoming($D);
        G.randomtask->() if G.randomtask;
        my $r; eval { $r = [ GD($Z) ] };
        sayyl "D.talk BANG: $@" if $@ && 5 > split '⊘',$@;
        GDone($Z);
        .
        if ($@) {
            D.nodie || die $@;
            $@ = "";
        }
        return wantarray ? @$r : $r->[0];
    
    n comeback ''=><<''
        my $Dome = $s;
        my $a;
        a.name = 'r';
        a.from = $Dome;
        my $Doing = $G->Doming($a); 
        $G->D({D=>Dome.D, toplevel=>1, talk=>"351 dollars",name=>"comeback"});
        $G->Done($Doing);
        sayre $@ if $@; # TODO toplevely
        $@ = "";
    
    n mkD =>''=><<'',{acgt=>'pin,ar'}
        my $D;
        D.point = $pin;
        if (my $C = ar.__D) {
            delete ar.__D;
            D.bab = C.c.s || die "N s".ki $C;
            D.noise .= C.sc.dige if C.sc.dige;
            D.babnon = 1 if C.sc.bab eq 'non';
            D.Verb = 1;
        }
        D.ar = $ar;
        D.name = join ' ', D.point, sort keys %{D.ar};
        D.sign = "Z";
        D.talk = join' ',grep{defined}map{$D->{$_}}qw'sign name noise';
        $D;
Goolog: |
    u allacgts
    
    n rese =>''=><<'','%code:G 1'
        `rm w/glog`;
        G.logs = 1;
    
    n log =>''=><<''
        write_file('w/glog', {append=>1}, "\n$s");
    
    
GBabz: |
    # see <<'' and levitate
    u allacgts
    
    # bab:non,,'%subpeel'
    n bitsof_babble =>''=><<''
        my $p;
        p.alive = qr/\$[\w]*[\w\->\{\}]+/;
        p.dotha = qr/[A-Za-z_]\w{0,3}(?:\.[\w-]*\w+)+/;
        p.oing = qr/p.alive|p.dotha|[-\w]{8,}/;
        p.oint = qr/[\w\$\/\->\{\}\*]*[\w\$\/\->\.\}\*]+/;
        p.mwall = qr/(?:= |if |unless |^\s*)/;
        p.sur = qr/ if| unless| for| when|,?\s*$|;\s*/;
        $p
    
    #,'%bab:non'
    n parse_babbl =>''=><<''
        my $p = G.bitsof_babble ||= I.d&bitsof_babble;
        # gone:
        my $Jsrc = qr/(J\d*(?:\.\w+)?) (\w+)/;
        my $Jlump = qr/(\S+) (\S+)\s+(\S.+)/;
        $s =~ s/p.mwall$Jsrc $Jlump$/$1.$2->("$3\\t$4" => $5);/smg;
        .
        # :
        my @s;
        my $indbe;
        my $inend;
        for my $l (split "\n", $s) {
            my $s = $l;
            if ($indbe) {
                if ($indbe eq 'nextind') {
                    $s =~ /^(\s+)/;
                    $indbe = qr/^$1/;
                }
                if ($s =~ $indbe) {
                    $s =~ s/^(\s*)\.(\s*)$/$1$2/;
                    push @s, $s;
                    next;
                }
                else {
                    undef $indbe;
                    if ($s !~ /^\s*$/) {
                        if ($inend) {
                            pop @s  if $s[-1] eq '';
                            push @s, $inend;
                        }
                    }
                    else {
                        $s = $inend if $inend;
                    }
                    undef $inend;
                }
            }
            my $ze = qr/<<['"](\w*)['"]/;
            if ($s =~ /^(\s*)\S.*$ze/) {
                $indbe = $2 ?
                    qr/^(?!\Q$1\E)/ # for <<'EOD' til ^EOD, etc
                  : qr/^($1\s+|\s*$)/; # some space in or no nonspace = quote
                $s =~ s/$ze/'<<'.($1?"'$1'":'STEVE')/e;
                $inend = 'STEVE' if !$1;
            }
            .
            # babable # expect closing brackets and insert J
            # eg Atime(2) = A.time->($J, 2)
            $s =~ s/(p.mwall)(\w*A)(\w+)\(/$1$2\.$3->(\$J, /smg;
            $s =~ s/(p.mwall)(\w*G)(\w+)\(/${1}G\.$3->(\$A,\$C,\$G,\$T, /smg;
            $s =~ s/(p.mwall)(\w*J)(\w+)\(/$1$2\.$3->(\$$2, /smg;
            $s =~ s/(p.mwall)(\w*M)(\w+)\(/${1}J\.m->(\$$2, /smg;
            .
            # close side ourselves, likely to gobble suro if, etc.
            $s =~ s/(p.mwall)(u|n) (.+?);?$/${1}J\.$2->($3=>'');/smg;
            #$s =~ s/(p.mwall)(m) (\w+)\(/${1}J\.$3->(\$M, /smg;
            .
            $s =~ s/I\.d\&(p.oint)/G\&$1/sgm;
            # lma quack $not->('tag');? from I.d&pui,$s
            $s =~ s/(p.oing|\w+)\&(p.oint)(,[^\s;]+)?(;)?/
                my ($on,$p,$e,$t) = ($1,$2,$3,$4);
                my $in;
                ($on,$in) = ("G\.h",'$A,$C,$G,$T,')
                    if $on eq 'G';
                my $s = $on."->($in\"$p\"$e)$t";
                $s = '$'.$s if $on !~ m{\.};
                $s
            /smge;
            # $sc>$k -> $sc->{$k}
            $s =~ s/(p.oing)((?:\.>p.oing)+)/
                join '->', $1, map {'{"'.$_.'"}'}
                grep {$_} split m{\.>}, $2;
            /smge;
            .
            while ($s =~ /(Rw (p.oint)(?:(?!p.sur) (.+?))?)p.sur/gsm) {
                my ($old, $op, $oa) = ($1, $2, $3);
                my $g;
                $g ||= '$G';
                .
                my $ne = ""; # hidden reverse
                $ne = $1 if $oa =~ s/(p.sur)$//;
                .
                my @n;
                my @m;
                # want to mix {m m m %$ar m m} whereever + is
                my $wanr = $oa =~ s/^\+ ?//;
                $wanr = 'stick' if $oa =~ s/^- ?//;
                for (split /\,| |\, /, $oa) {
                    # sweet little pool... $J:geo etc
                    if (/^\$((\w+(:|=))?\S+)$/) {
                        my ($na, $fa, $wa) = ($1, $2, $3);
                        if (!$fa) { # fake name, to ar
                            $fa = $na;
                        }
                        else {
                            $na =~ s/^\Q$fa\E//;
                            $fa =~ s/(:|=)$//;
                            if ($wa eq '=') {
                                $na = '"'.$na.'"';
                            }
                        }
                        $na = '$'.$na unless
                            $wa eq '=' || $na =~ /^\S+\.\S/;
                        push @n, "$fa=>$na" ; # also avail a listy position
                    }
                    else {
                        push @m, $_;
                    }
                }
                unshift @n, '%$ar' if (!@n || $wanr) && $wanr ne "stick";
                push @n, "m=>[".join(',',map{'"'.$_.'"'}@m).']'
                    if @m;
                .
                my @e;
                push @e, '"'.$op.'"';
                push @e, "{".join(",",@n)."}";
                my $en = join ",", @e;
                .
                my $wa = $g.'->{w}->($A,$C,$G,$T,'.$en.')'.$ne;
                $s =~ s/\Q$old\E/$wa/          || die "Ca't replace $1\n\n $s";
            }
            .
            # sc.k -> $sc->{k};
            $s =~ s/(?:(?<=\W)|^)(?<!\\)([A-Za-z_]\w{0,3})((?:\.[\w-]*\w+)+)/"\$$1".join"",map {"->{$_}"} grep {length} split '\.', $2;/seg;
            # 
            $s =~ s/aft \{/acum \$F[0] => _after_do => sub {/sg;
            #
            .
            push @s, $s;
        }
        push @s, $inend if $indbe && $inend;
        $s = join "\n", @s;
        .
        $s;
Ghoots: |
    u allacgts
    
    n sigstackend =>''=><<'',
        local $@;
        eval { confess( '' ) };
        my @stack = split m/\n/, $@;
        #shift @stack for 1..1; # hide above this sub, G eval & '  at G...';
        my @stackend;
        push @stackend, shift @stack until $stack[0] =~ /ggggggg/ || !@stack && die "NO find gggg stack";
        s/\t//g for @stackend;
        # write on the train thats about to derail
        push @{$F[0]->{SigDieStack}||=[]}, \@stackend;
    
    n sigstackwa =>''=><<'',
        return 1 if $_[0] =~ /^Use of uninitialized value/;
        if ($_[0] =~ /Deep recursion on/) {
           return if G.deepr++ < 9;
           G.deepr = 0;
           sayre "snoozing $F[0]->{talk}";
           snooze();
           return;
        }
        my @loc = caller(1);
        $@ = join "\n", @_;
        my $DOOF = GDuck($F[0],1);
        $@ = "";
        sayre $DOOF;
        return 1;
    
    n Doming =>''=><<'',
        my $D = shift;
        die "More to DOming" if @_;
        $D = Gpyramid($D);
        unshift @F, $D;
        D.F = [@F];
        return $D;
    
    n pyramid =>''=><<'',
        my $am = $s;
        confess "Ba" if ref $am ne 'HASH';
        #
        my ($last) = @F;
        my $u = {%$am};
        if ($last) {
            push @{last.Lo||=[]}, $u;
            u.Li = $last;
        }
        else {
            push @{G.East||=[]}, $u;
        }
        u.G = $G;
        u.K = u.name || die "No Dome Name";
        u.hitime = hitime;
        u.order = H.pyramiding++;
        u.stack = stack(2,7);
        u.F = [@F];
        u.depth = 0+@F;
        u.Error = $@ if $@; #?
        $u
    
    n Done =>''=><<'',
        my $D = $s;
        sayre join"", ("BATS  ")x 23 if $F[0] ne $D;
        D.dolat = $@ if $@;
        $_->() for @{D._after_do||[]};
        shift @F;
        GDuck($D) if $@;
        $_->() for @{D._aft_etc_do||[]};
        $D
GDom: |
    u allacgts
    
    n ggggggg =>''=><<'',{code=>'Perl 3',args=>'c,sc'}
        eval{ $c->($sc) }
    
    # swim by the compile (Dm), do(g7 evals)/done($@ handle)/return
    n D =>''=><<''
        my $D = $s;
        my $ar = D.ar || {};
        .
        die "RECURSION ".@F if @F > $MAX_FCURSION;
        my $sub = D.D || do {
             D.Ds = GDm($D);
             D.Ds.sub;
        };
        D.sign = 'D';
        D.talk = "D.sign D.name";
        $D = GDoming($D);
        my @return;
        if (ref $sub eq "CODE" && !$@) {
            local $SIG{__DIE__} = G.sigstackend;
            local $SIG{__WARN__} = G.sigstackwa;
            
            wantarray ? 
                do { @return = ggggggg($sub, D.ar) }
                : do { $return[0] = ggggggg($sub, D.ar) };
        }
        .
        GDone($D); # Ducks
        D.r = [@return];
        .
        return wantarray ? @return : shift @return
    
    n Dm =>''=><<''
        my $am = $s;
        am.talk || confess wdump 2, $am;
        my $Ds = G.drop.Dscache->{am.talk};
        return $Ds if $Ds;
        .
        die "SOMEONENONE".wdump 1, $am if ref am.bab;
        .
        my $eval = am.bab;
        $eval = Gparse_babble($eval) unless am.babnon;
        .
        my $ar = am.ar || {};
         ar.R = $G;
        my $download = join("", map {
            'my$'.$_.'=$ar->{'.$_."}; "
            } keys %$ar)
            if %$ar;
        my $sub = "bollox";
        my $evs = 'sub { my $ar = shift; '
        ."$download\n"
        ."my \@doo_return = (sub { \n\n$eval\n })->();\n"
        .'return @doo_return };';
        .
        $sub = GDoe($evs, $ar);
        .
        $@ = "nicht kompilieren!\n\n$@" if $@;
        .
        $Ds = {evs=>$evs, sub=>$sub, talk=>am.talk};
        .
        if (!$@ && ref $sub eq "CODE") {
            G.drop.Dscache->{am.talk} = $Ds;
        }
        else {
            am.bungeval = $evs;
        }
        $Ds
    
    n Doe =>''=><<'',{acgt=>'D_eval_string,ar'}
         return eval $D_eval_string;
Gouck: |
    u allacgts
    
    n Duck =>''=><<''
        my $D = $s;
        my $evs = D.Ds.evs;
        my $ar = D.ar;
        my $DOOF; 
        my $first = 1 unless $@ =~ /DOOF/;
        $DOOF .= "DOOF D.talk\n" if D.sign eq 'D' || $nodie;
        $DOOF .= "  D.inter" if D.inter;
        if ($first) {
            my $x = $1 if $@ =~ /syntax error .+ line (\d+), near/
                || $@ =~ /line (\d+)/;
            my $file = $1 if $@ =~ /at (\S+) line/;
            undef $file if $file && $file =~ /\(eval \d+\)/;
            undef $file if $file && !-f $file;
            my $code = $file ? 
            read_file($file)
            : $evs;
            my $eval = GDuckling($x, $code, $D);
            if (exists $D->{SigDieStack}) {
                warn "3MALTY SIGGI" if @{$D->{SigDieStack}} > 3;
                $DOOF .= "\n";
                my $i = "  ";
                for my $s ( reverse flatline($D->{SigDieStack}) ) {
                    $DOOF .= "$i- $s\n";
                    $i .= "  ";
                }
            }        
            $DOOF .= "\n$eval\n";
        }
        .
        if ($first) {
            $DOOF .= ind("E    ", "\n$@\n\n")."\n\n";
        }
        else {
            my $in = D.sign eq 'D' ? "! " : "";
            $DOOF .= ind($in, "$@")."\n";
        }
        .
        if ($first) {
            $DOOF .= ind('ar.', join "\n",
                map{
                 my $e = $ar->{$_};
                 my $s = "$e";
                 $s .= "(name=$e->{name})"
                     if ref $e && ref $e ne 'ARRAY'
                    && $e->{name};
                "$_ = ". $s;
                }keys %$ar); 
        }
        .
        return $DOOF if $nodie;
        .
        D.Error = $DOOF;
        $@ = $DOOF;
        sayre $@;
        exit;
        if (@F == 1) {
            # send it away
            $DOOF = join"\n",map{s/^(\! )+//smg if !/DOOF/; $_}split"\n",$DOOF;
            sayre $DOOF;
            G.dooftip && G.dooftip->($@);
            $@ = "";
            $_->() for @{G._aft_err_do||[]};
        }
        else {
            die $@;
        }
    
    n Duckling =>''=><<'',{acgt=>'line,code,D'}
        my $diag = "";
        my @code = split "\n", $code;
        my $whole = @code < 18;
        if (!D.Verb && $code =~ /^sub \{ my \$ar = shift/
            && $code =~ /return \@doo_return \};/) {
            $line -= 2 if $line;
            shift @code for 1..2;
            pop @code for 1..2;
        }
        my $xx = 0;
        my $lci;
        for my $c (@code) {
            $xx++;
            $lci = $1 if $xx < $line && $c =~ /^\s*(#\s*\d.*)$/;
            if (!defined $line) {
                $diag .= ind("⊘  ", $c)."\n"
            }
            elsif ($xx == $line) {
                $diag .= ind("⊘  ", $c)."\n";
                
                my $bab = (split"\n",D.bab)[$line-2];
                if ($bab ne $c) {
                    $diag .= ind("⊖r ", $bab)."\n";
                }
            }
            elsif (!$whole && $xx > $line-5 && $xx < $line+5) {
                $diag .= ind("|  ", $c)."\n"
            }
            elsif ($whole) {
                $diag .= ind("|  ", $c)."\n"
            }
        }
        $diag = "$diag\n#~~~$lci" if $lci && $lci !~ /^# 0.01/;
        $diag
    
   
Goo: | # Gto is made, babbed, things for G's I which is G itself
    # this all goes... somewhere
    n Gooso
    n Goodat
    n Gooway
    n Goolog
    n GBabz
    n Ghoots
    n GDom
    n Gouck

