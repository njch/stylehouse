
collaspII: | # acquire perhaps even time 1, spiral spiraled IIII and I
    # you could make it keep A.II, which includes A.IIIII, many tiles
    my $II = A.J.A.II ||= {};
    Rw spII $A $II J/A/IIII J/A/III J/A/I;
    $II;
    
spII: | # thereis a II being passed overhead, entrance to spIII N C applier/updater
    my @N = @{ar.m};
    my @C;
    while (@N) {
        my $m = shift @N;
        my $r = G.pwin->($m, $A);
        if (ref $r eq 'ARRAY') {
            unshift @N, @$r;
        }
        elsif (ref $r eq 'HASH') {
            push @C, {t=>$m,c=>{s=>$r}};
        }
    }
    my $Ii = join " + ", map{"_.t:_.c.s"} @C;
    $Ii eq II.Ii && return;
    if (my $TI = G.TT->{$Ii}) {
        die "DifgTI " if TI.Ii ne $Ii;
        %$II = %$TI;
        $Ii eq II.Ii || die "Hiked GTT TI.Ii ne $Ii";
        return sayyl "Hiked GTT $Ii";
    }
    else {
        G.TT->{$Ii} = $II;
    }
    II.Ii = $Ii;
    # we dive into always, should form tidy tree with D chaos at tips
    # the screening space saver, the no way out-er
    my $N = [@C];
    my $s = {};
    (
    Rw spIII $A $II $N K/cv/t $s
    =~ /stabilised/
    || A.J.V > 1) &&
    saybl Rw TreeD $s $scby=gro;
    
    say "Spidered A.talk: ".F_delta;
spIII: |
    my $ooI = ar.ooI;
    $ooI ||= II.ooI ||= {};
    ooI.mo ||= $ooI;
    delete ooI.st if ooI.mo eq $ooI;
    my $m = [@{ar.m}];
    @$m = split '/', $m->[0] if @$m == 1;
    my $n = shift @$m;
    $n||die "Non? $n @$m ooI.ins";
    @$N||die"noNsp";
    
    my $Ii = join " + ", map{"_.t:_.c.s"} @$N;
    return "ooI.ins stabilised" if $Ii eq ooI.Ii;
    ooI.Ii = $Ii;
    
    my $E = {%$II};
    %$II = ();
    
    my $tw = {map{$_=>1} map{ keys %{_.c.s} } @$N};
    # can comission stillness
    # we all look like each other's Jesuses
    # must in N order move in changed hashes
    # but our awareness of
    my @say;
    for my $K (sort keys %$tw) {
        next if $K eq 'Ii' || $K eq 'ooI';
        if (@$m) {
            my $III = $II->{$K} = $E->{$K} ||= {};
            my $oI = ooI.K->{$K} ||= {mo=>ooI.mo};
            my $S = $s->{$K} ||= {};
            # ^ thse particles
            oI.ins = (ooI.ins&&"ooI.ins/")."$K";
            my $N = [
                map { {t=>_.t,c=>{s=>_.c.s->{$K}}} }
                grep {exists _.c.s->{$K}}
                @$N
            ];
            my $d = ar.d + 1;
            push @say,
            Rw spIII $A $II:III $ooI:oI $N $m $d $s:S;
        }
        else {
            my @C = grep {exists _.c.s->{$K}} @$N;
            # say "manyC for $K" if @C > 1;
            for (@C) {
                $s->{$K} =
                ooI.mo.st->{ooI.ins}->{_.t}->{$K} =
                    $II->{$K} = _.c.s->{$K};
            } 
            
        }
    }
    delete ooI.K->{$_} for grep {!$tw->{$_}} keys %{ooI.K};
    
    if ($ooI eq ooI.mo) {
        II.Ii = $Ii;
        II.ooI = $ooI;
    }
    join "\n",grep{defined}@say;
TreeD: |
    # $scby
    my $bydef = "^";
    my @say;
    for my $K (sort keys %$s) {
        my $vs = $s->{$K};
        for my $cv (sort keys %$vs) {
            my $tw = $vs->{$cv};
            my $g = {};
            while (my ($k,$D) = each %$tw) {
                my $gk = D.sc->{$scby} || $bydef;
                # ^
                # v
                $g->{$gk}->{$k} = $D;
            }
            for my $gk (sort keys %$g) {
                my $ts = $g->{$gk};
                push @say, sprintf ' %-9s %-6s %-18s %27s',
                    $K, $cv, $gk, join(",", sort keys %$ts);
            }
        }
    }
    join "\n", @say
dow: |
    my @e = grep{length > 1} keys %$ar;
    die "dowtoo @e" if @e > 1;
    my $f = shift @e;
    my $s = $ar->{$f};
    if (s.ooI) {
        $s = {%$s};
        delete s.ooI;
    }
    DumpFile("w/$f", $s);

