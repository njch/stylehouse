
oJ2: | # HOW c grabs on, how W transifies down...
     #sayyl "oJJJ oJJJ ".wdump $C;
     if (C.c.J eq A.J) {
         sayre "J above A.J.name";
         delete C.c.J;
     }
     if (exists C.c.J) {
         C.c.W = C.c.J;
         if (J.name ne 'qq') {
             A.ztime = 3;
         }
         # amount of time each thing spends being the top level
         # which was... n... mani
     }
     A.ztime = delete C.c.time if C.c.time;
     
     my $nn = A.note.not;
     
     C.c.s = 'S2im' if !defined C.c.s;
     nn&c,'s';
     C.c.W && # nets
     nn&c,'W';
     my $wasW;
     if (exists C.c.pi) {
         nn&c,'pi';
         Rw opi2 + $v:C.c.pi;
     }
     elsif (exists C.c.W) {
         $wasW = 1;
         nn&c,'W';
         Rw oW2 + $v:C.c.W;
     }
     else {
         #die "misrep ".wdump 2, $C;
     }
     if (C.c.W && !$wasW) {
         if (!ref C.c.W) {
             my $Wjr = Rw Ajr $J:G.oin $t:C.c.W $cv=0.3;
             my $WJ = Wjr&J;
             sayyl "HJvae A.J.name holding C.t with WJ.name" if J.V;
             C.c.W = $WJ;
         }
         else {
             die "knew W? ".ki C.c.W;
         }
     }
opi2: | # approach - c language is map to some u before 6ing
    my $v = C.c.pi;
    at.pi = $v || 'guess';
    C.c.J = 'pi'; # type of abdomin to use
    
    my $oJ = $J;
    $oJ = C.y.o.J if C.y.o && C.y.o.J;
    A.jr = Rw Ajr $J:oJ $C;
    
oW2: | # some get-J or weave wires protocol - hosts
    my $t = $v;
    $t = v.name if ref $t;
    at.J = ref $v ? $v : $t;
    at.W = $t;
    C.c.J ||= $v;
    
    die wdump ["onto W J.name:",$v] if ref $v && $v ne v.most.J;
    
    C.t = $t;
    # has already been 0.1 in Y
    C.y.cv ||= 0.3;
    
    A.jr = Rw Ajr $J:G.oin $t $cv=0.3;
    
    # and where the
    if (C.c.vv) {
        A.ztime = delete C.c.vv;
        A.jr&vv,9
        ->(); #delone
    }

