This: |
    u Traweil
    u allact
    and:
        off
    you:
        go
    n More
More: |
    u Traweil
    u allacgts
    del:
        soon
    you:
        moot
    #n \'W:Moos,isle:Ops'
Moos: |
    u Traweil
    u allacgts
    delo:
        3
Tp: | # execution, comes with depth unlimits
    u Traweil
    n \'W:This,isle:V'
pietrW: |
    # sense retriever, was a pi away
    
    my $isle = C.c.isle || J.mo.J.at.isle;
    $isle || die "No isledea !? J.name of J.mo.J.name has; ".ki J.mo.J.at;
    my $f = "w/$isle/$s";
    y.at.isle = $isle;
    say "trW; A.J.name - J.name";
    my $moj = J.mo.J;
    moj.at.isle || die "NO isle above? moj.name";
    my $Jd = "w/moj.at.isle/J/moj.name";
    `mkdir -p $Jd` if !-d $Jd;
    my $clue;
    if (J.at.isle ne moj.at.isle) {
        say "moj.name (moj.at.isle)   $s has src over in J.at.isle";
        $clue = "$Jd/${s}_src_$isle";
        say "Gunna leave clue at: $clue";
        `touch $clue`;
    }
    my $jf = "$Jd/$s";
    my $traveli;
    for ($jf) {
        next unless -s $_;
        $traveli = read_file($_);
        say "Travel from $_: $traveli";
    }
    if (!$traveli && -f $f) {
        say "Found $f !";
        n $f =>3,$s,{X=>LoadFile($f)}
        `touch $jf` && sayre "Xuper $f" if !-f $jf;
    }
    else {
        say "Making  $s !";
        die "Cannot diff src with travelineedy $s" if $clue;
        n $s=>W=>
        `cat /dev/null > $jf`;
    }
    saybl "Donel  $jf";
    
Traweil: | # uses localeo
    u allacgts
    # ye
    # wants to be a left-right by now, regarding the isles and meta (stop, src)
    shouldWe:
        my $tr = 1; # yes
        my $i = T.isle;
        c&isle && C.t || die "Cno isle/t ".ki $C;
        my $f = 'w/'.c&isle.'/'.C.t;
        my $pisle = i.stop ? c&isle : s.c.isle;
        my $j = 'w/'.$pisle.'/J/'.s.t;
        `mkdir -p $j` if !-d $j;
        $j .= '/'.C.t;
        G&fmakund,$j,$i;
        i.f = $f;
        i.j = $j;
        if (-f $j) {
            $tr = -s $j ? read_file($j) : 0;
            say "Joint $j weighs $tr";
        }
        if (!-f $f) {
            $tr = 1;
            say "Joint $j must make $f";
        }
        die "Cannot diff src $pisle/s.t -> c&isle/C.t" if $tr && i.src;
        $tr
    
    # flat reiter T log, $s = .../J/parent, @Me = {src:$isle}
    # C.t_src_$isle, on the parent join to the child
    fmakund:
        my @l = map { join '_', $s, @$_ }
            map { my $o = $_; map { [$_=>$o.>$_ ] } keys %$o } @Me;
        s/_1$// for @l;
        my $l = {map{$_=>1}@l};
        for (glob "$s*") {
            next if delete $l.>$_;
            sayre "RM $_";
            #unlink $_;
        }
        `touch $_` for @l; # meta bits
    
    u allvse
    
    #Top: 
        #n \'W:This,isle:V'
    #V:
        # what top wants to know about doing V
    n \'of:Mo'
    # This.c.isle adds More.c.isle:
    W 3215:
        my $ab = A.J.C;
        c&isle ||= ab.c.isle || die "Noisle top? ".wdump 2, $ab;
        
        T.isle.stop = 1 if !ab.c.isle && c&isle; # ab only involking
        
        T.isle.src = c&isle if ab.c.isle && c&isle ne ab.c.isle;
        
        my $tr = G&shouldWe,$ab;
        delete c&J if !$tr;
        # ^ or c&ov = 0.8, so it can fall in, general W only mean
        # ov=8 will resume, to give This'W correct link to More'W all the time
    
    
    # J stuff skipped, W level, real W users incur setup then
    
    #n \'of:Me'
    # here in the osc meta wander region,
    # having willed
    J.VV.N = 1;
    scW 74:
        if (my $J = C.sc.J) {
            my ($Y,$V) = map{ J.El.>$_ } Pre=>'Duv';
            my @lv = map { _.y.k || die "C from Yvs has no yk: ".ki $_;
                V.lv.>_.y.k } @{Y.vs};
            my @C = map{_.C} @lv;
            die wdump 3,[@C];
            C.c.z = [];
        }
        else {
            die "Re,member W   ".ki $C;
        }
        #exist for a point
        # connects Wscaping/versioning
        #for moving any o 7 out
        #and hitching at the 2 onto another
        ## retreieves header
        #how it is currently held (symp isle, makes aware as you like)
        # the isle/This'W is indexed whole/Wc as opposed to Wsc
        # for the thing applying at a distance, little updates way-cpu asap
        
        # so W underneath sprawls & tidies, convopool
        # isle hoisted off flattens all the time, possible meta:
        #   the bunch of Wags hoisted into one, clients can dive isle for update
        #   if nothing else gets built in the aggregation
    
    # the art shader as a post osc index builder
    # here making code more perl etc.
    
    isle 747:
        # continues encoding/indexing *
        # @N = encode grep{!.W} 
        # matched things
        # C.c.isle slightly defines how to encode Cings 
        #   it could ensure incoming are compatible with index
        #   
        sayyl "suckisle ".ki $C;
        # C is things 
        #my $N = [@{C.c.N}];
        # [t=>''=>{W=>t}] .. to feed &st with 
        
            # sc.coil = $stage, aNy sc.$stage = $function
        # this function pulls in many of itselfs from W ^
        # to be spires continuing,
        # ignores on sc.noXup, eg Xiles' content, 
        # 
        # st should know about making new D for us,
        #  ignored (sc.noXup) (Xiles' othering intrograb)
        
        
        if (my $stage = C.sc.coil) {
        }
        
        
        #we 8 everyWing already, know where to isle it
        # This'W should look normal
    
    
    # Every'W should just point to Other'W (+ version, maybe), requiring it 8 somewhere
    # humming clients must attach other trees (they would kMow how)
    # probably embedding in time, universals to bend it together

