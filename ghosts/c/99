This: |
    J.VV.N = 1;
    y.at.coil = "meashourp";
    u allact
    and: %meashourp:delopida
        G&peel,'off'
    you:
        G&peel,'go'
    n More
delopida: |
    D.sc.allthe = join ',', map{_.t} @$N;
More: |
    u allacgts
    del:
        C.sc.soon--;
    you:
        C.sc.you = 1 + $s;
    n \'W:Moos,isle:VV'
Moos: |
    J.VV.N = 1;
    u allacgts
    daloe:
        C.t + 4;
Tp: | # execution, comes with depth unlimits
    u Traweil
    n \'W:Moos,isle:VV'
    n \'W:This,isle:V'
    
Muoos: |
    n Moos
Pugwei: |
    u allacgts
    n UpPg
    
    Pugweidb:
        G&tyable,W=>'isle,ts';
        G&tyable,T=>'isle,l,ts';
    
    orb:
        use List::MoreUtils 'zip';
        my @arg = map{ref $_ ? @$_ : split ',',} shift @Me;
        $s = ref $s ?
            "$$s (".join(',',@arg).") values (".join(',',map{'?'}@arg).")"
            : 
            "$s where ".join(' and ',map{"$_=?"}@arg);
        if ($s =~ /^select/i) {
            my ($j,$ba) = G&qh,$s,@Me;
            $ba && die "Many $s ---- @Me";
            sayre "ARGME mis ".wdump 3, [$s,\@arg,\@Me, [zip @arg, @Me]]
                if @arg != @Me;
            $j ||= {do{ zip @arg, @Me }};
            $j.>$_ ||= {} for c=>'sc';
            ($j.>$_) = map { !ref $_ ? djson($_) : $_ } $j.>$_ for c=>'sc';
            j.sc ||= {};
            ref j.c && ref j.sc || die "JOS of $s  ".wdump 3, $j;
            $j
        }
        else {
            G&qp,$s,@Me;
        }
    
    sorb:
        my $q = "select * from $s";
        G&orb,$q,@Me;
    
    # header for a W in isle, 
    getW:
        G&sorb,W=>'isle,t',$s,@Me;
    
    # heads together Talking
    geT:
        G&sorb,T=>'isle,l,t',$s,@Me;
    
    # table, a j to put, index columns, other columns
    replace:
        my $j = pop @Me;
        my @ind = split',',shift @Me;
        my @del = map { $j.>$_ || die "NO $_ on ".ki$j } @ind;
        G&orb,$_,\@ind,@del for "delete from $s";
        
        my @ins = uniq @ind, qw't y c sc', @Me;
        @Me = map{ my $v = $j.>$_; /^s?c$/ ? sjson $v : $v } @ins;
        G&orb,\$_,\@ins,@Me for "insert into $s";
    
    putW:
        s.ts = do {
            my $t = G&qh,<<'';
                select now() as s
            say "Selected t.s as now for ".ki $s;
            t.s
        };
        G&replace,W=>'isle,t','ts',$s;
    
    # notes states from $s = T.isle, ball of data to join join
    puTsj:
        my $j = s.j||die"noj".ki$s;
        my $o = G&xonly,j.sc,$s,grep/../,keys%$s;
        #saybl "Diff: ".wdump 3,[s.j,{OLDSC=>$o}];
        G&replace,T=>'isle,l,t',s.j;
    
    xonly: %acgt:s c
        my $o = {%$s};
        %$s = ();
        for (@Me) {
            $s.>$_ = $c.>$_;
        }
        $o
    
    xery: %acgt:s c
        my $tt = {map{ref $_ ? %$_ : $_,$_ }@Me};
        while (my($f,$t) = each %$tt) {
            if (!exists $c.>$f ) {
                delete $s.>$t
            }
            else {
                $s.>$t = $c.>$f
            }
        }
    
    shouldWe:
        my $tr = 1;
        my $i = T.isle;
        $i && c&isle && C.t || die "Cno isle/t ".ki $C;
        
        i.f = G&getW,c&isle,C.t;
        unless (i.stop) {
            i.j = G&geT,s.c.isle,s.t,C.t;
            G&puTsj,$i;
        }
        if (0 && !i.j.y) {
            $tr = 1;
            say "pJoint noy: ".ki i.j;
        }
        elsif (keys %{i.j.c}) {
            $tr = 1;
            say "pJoint weighs: ".ki i.j;
        }
        else {
            $tr = 0;
            say "pJ easy ".ki i.j;
        }
        if (!i.f || !keys %{i.f.c}) {
            $tr = 1;
            say "pJoint ".ki(i.j)." must make ".ki i.f;
        }
        elsif (!-f 'w/'.i.f.c.yam) {
            $tr = 1;
            say "pJoint i.f.c.yam MISSING, make it";
        }
        $tr
    
    jound:
        say "Found! ".ki s.f;
        s.j.y = 0.1;
        G&puTsj,$s;
        
    
    fli:
        my $f = s.f.c.yam || die "Yanotcyam ".ki s.f;
        LoadFile('w/'.$f);
    
    fown:
        s.f.isle && s.f.t || die "fown: ".wdump 3, s.f;
        my $f = s.f.c.yam ||= s.f.isle.'/'.s.f.t;
        my $X = C.sc.X || die "get X ".ki$C;
        G&xery,s.f.sc,$X,{Ii=>'i'};
        # drops ooI, scrubs Ii: (saves file)
        Rw down $f $s:X;
        G&putW,s.f;
        
    joined:
        return if s.stop;
        saybl "Drains c: ".ki s.j.c;
        s.j.c = {};
        G&puTsj,$s;
    
DiskTravel: |
    u allacgts
    
    shouldWe:
        my $tr = 1; # yes
        my $i = T.isle;
        $i && c&isle && C.t || die "Cno isle/t ".ki $C;
        
        i.f = 'w/'.c&isle.'/'.C.t;
        unless (i.stop) {
            i.j = 'w/'.s.c.isle.'/J/'.s.t;
            `mkdir -p i.j` if !-d i.j;
            i.j .= '/'.C.t;
            G&fmakund,$i;
        }
        
        if (i.j && -f i.j) {
            $tr = -s i.j ? read_file(i.j) : 0;
            say "Joint i.j weighs $tr";
        }
        if (!-f i.f) {
            $tr = 1;
            say "Joint i.j must make i.f";
        }
        $tr
    
    # flat reiter T log, $s = .../J/parent, @Me = {src:$isle}
    # C.t_src_$isle, on the parent join to the child
    fmakund:
        my @l = map { join '_', s.j, $_, $s.>$_ } grep /../, keys %$s;
        s/_1$// for @l;
        push @l, s.j;
        my $l = {map{$_=>1}@l};
        for (glob "s.j*") {
            next if delete $l.>$_;
            warn "want to RM $_";
            #unlink $_;
        }
        #saybl "Info\n".ki $s;
        `touch $_` for @l;
    
    jound:
        say "Found! s.f";
        `touch s.j` if !-f s.j;
    fli:
        LoadFile(s.f);
    fown:
        my $f = s.f;
        $f =~ s/^w\/// || die "CAnot down out of w/: $f";
        # drops ooI, scrubs Ii: (saves file)
        my $X = C.sc.X || die "get X ".ki$C;
        Rw down $f $s:X;
    joined:
        return if s.stop;
        `cat /dev/null > s.j`;
        saybl ki $s;
    
Traweil: | # uses localeo
    u allacgts
    #n DiskTravel
    n Pugwei
    # ye
    # wants to be a left-right by now, regarding the isles and meta (stop, src)
    u allvse
    
    n \'of:Mo'
    # This.c.isle <-> More.c.isle:
    W 3215:
        G.glomp++ || G&Pugweidb;
        
        my $ab = A.J.C;
        c&isle ||= ab.c.isle || die "Noisle top? ".wdump 3,[$C, $ab];
        my $i = T.isle ||= {};
        ab.c.iZle.>C.t = $i;
        
        i.stop = 1 if !ab.c.isle && c&isle; # ab only involking
        
        i.src = c&isle if ab.c.isle && c&isle ne ab.c.isle;
        
        my $tr = G&shouldWe,$ab;
        #my $vs = G&pg_shouldWe,$ab;
        #$tr eq $vs || sayre "fs said $tr, pg didnt\n";
        #$tr ||= $vs;
        
        $tr || delete(c&J), delete(C&J);
        $tr && sayre "C.t travels";
        $tr && i.src && die "Cannot diff src s.c.isle/s.t -> c&isle/C.t";
    
    # ^ or c&ov = 0.8, so it can fall in, general W only mean
    # ov=8 will resume, to give This'W correct link to More'W all the time
    
    J 63: %code:J
        u Traweil
    
        
    #c to be spires continuing,
    # 
    # st should know about making new D for us,
    #we 8 everyWing already, know where to isle it
    # This'W should look normal
    
    # Every'W should just point to Other'W (+ version, maybe), requiring it 8 somewhere
    # humming clients must attach other trees (they would kMow how)
    # probably embedding in time, universals to bend it together
    
    # exist for a point
    # connects Wscaping/versioning
    #for moving any o 7 out
    #and hitching at the 2 onto another
    ## retreieves header
    #how it is currently held (symp isle, makes aware as you like)
    # the isle/This'W is indexed whole/Wc as opposed to Wsc
    # for the thing applying at a distance, little updates way-cpu asap

    # so W underneath sprawls & tidies, convopool
    # isle hoisted off flattens all the time, possible meta:
    #   the bunch of Wags hoisted into one, clients can dive isle for update
    #   if nothing else gets built in the aggregation
    
    # here in the osc meta wander region,
    # having willed, having it one way or another
    
    scW 74:
        if (my $J = C.sc.J) {
            # make N the recoverable inners if J,
            die wdump 3, $C if !ref $J;
            my ($Y,$V) = map{ J.El.>$_ } Pre=>'Duv';
            my @lv = map { V.rv.do.>$_ } sort keys %{V.rv.do};
            my ($root,@C) = map{_.C} V.rv, @lv;
            C.c.N = [map{
                my $D = G&hup,$_;
                # make normal
                delete D.c.>$_ for qw'J Y V';
                sayre "D.t came out of osc with X: ".ki D.sc.X if D.sc.X;
                $D
            }@C];
            say "C.t how has N";
        }
        else {
            # or just point, get W outer/root/rv/C, versioneddie
            # then that can acquire inners later or isle away
            #   (noticing if isle v < W v, maybe)
            say "Re,member W: C.t ".ki C.c;
        }
    
    # the art shader as a post osc index builder
    # here making code more perl etc.
    isle 747:
        my $sco = $isle =~ /^j/ ? {js=>'ym/jscoi'} : {code=>'ym/conoi'};
        my $i = T.isle;
        
        if (C.c.N) { # we are awake inside
        sayyl " C.t   ist ".ki C.c;
        saygr " C.t               ".ki C.sc;
        
        my $src = [];
        for my $D (@{C.c.N}) {
            D.y = D.y.cv;
            for (grep{ D.sc.>$_ }keys %$sco) {
                my $coder = $sco.>$_;
                my $v = {};
                Rw $coder $C:D $v;
                
                D.sc.X && die "D.t al; $_";
                D.sc.X = $v;
            }
            D.sc.X && D.sc.W && sayre "DscW already had X: ".ki $D;
            if (my $n = D.sc.W) {
                D.t eq $n || die "yuou";
                my $is = C.c.iZle.>$n || die "No $n on iZle: ".ki C.c;
                is.f && is.j || die "Noise ".ki $is;
                
                my $X = G&fli,$is;
                # land join
                G&jound,$is;
                
                # wants to be post-spiral-together for our C 
                # knowing which src - now here=C.t is missing
                my $N = Rw sumX $X;
                _.c.from = join'/',grep{defined} D.t, _.c.from
                    for @$N;
                
                D.sc.X = $X;
            }
            D.sc.noXup && sayre("No hoist D.t") && next;
            my $k = "D.t vers";
            push @$src, [$k,D.sc.X];
        }
        
        my $II = C.sc.X ||= {};
        Rw spII $A $II $src;
        }
        
        if (!C.c.N) {
            C.sc.X && die "!N ended up with X.".ki$C;
            C.sc.X = G&fli,$i;
        }
        my $X = C.sc.X;
        my $J = C.c.J;
        if (ref $J) {
            if (my $o = J.at.coil) {
                my $N = Rw sumX $X;
                for my $D (grep{ _.sc.>$o }@$N) {
                    my $way = D.sc.>$o;
                    saybl "C.t Coils D.t via $way";
                    Rw $way $D $N;
                }
            }
        }
        else {
        }
        
        G&fown,$i;
        
        G&joined,$i;
        

