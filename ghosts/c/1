r2j: |
    my $j;
    if (J.tt) {
        (j.cv,j.t,j.style) = $r =~ /^(.*?)\t(.*)\t(.*?)$/;
    }
    else {
        (j.t,j.style,j.cv) = $r =~ /^(.+?)(?:%(.+))?\s+(.+?)$/;
    }
    defined j.cv || die "(tt=J.tt) no $r    ".ki $j;
    j.s = ar.J.bb->{$r} if ar.J;
    $j;
paintaj: |
     aj.Wid || die "not Wid?";
     aj.hol = "H.style/H.name/H.id";
     aj.hitime = hitime;
     aj.name ||= aj.J.name;
S/ghostchanges: |
    unless ($m =~ /\/k\//) {
        Rw loD;
        sayyl "loded";
        Rw recoded_init;
    }
S/wayup: |
       -f $m || die;
       delete G.drop; 
       $G->wayup($m);
       Rw loD;
       Rw recoded_init;
waps: |
    sayyl 'ps';
    J.first++ || return;
    my $sleep = sub {
        my $til = hitime() + shift;
        G.pslagtil = $til if $til > G.pslagtil;
    };
    
    
    my @ps = `ps -p$$ fu`; # j right
    my ($u, $pid, $cpu, $mem) = (split /\s+/, $ps[1])[0,1,2,3];
    if ($mem > 20 || $cpu > 60) {
        saybl "& $mem";
        if ($mem > 38) {
            sayre "massive, restarting" for 1..8;sleep 1;
            Rw rez;
        }
        $sleep->(4);
    }
     
    my @temps = 
    map {/\+(\d+\.\d+)\S+? /;$1} 
    grep {/^temp1:/} 
    `sensors`;
    my ($ch,$gh) = @temps;
    sayre "$u $pid       mem:$mem   cpu:$cpu  $ch    $gh ";
    if ($ch > 70) {
        sayre "HOT";
        $sleep->(7);
    }
aftor: |
    my $J = J.most.J;
    my $N = Rw tyc $J;
    @$N = grep { _.sc.pi eq 'thumbnail' } @$N;
    
    my $u = {};
    for my $C (@$N) {
        my $p = C.t;
        my $n = C.c.s;
        Rw loadup $u $p $n;
    }
    sayyl "After J.name: clife: ".wdump 2, [$u,$N];
    Rw makoo $u;
    
makoo: |
       sayre "to make some code? ".wdump [sort keys %$u];
       return;
       my $t = Rw wuck - $u */flows/*;
       my $fr = 0;   
       my $amp = G.ampampamp ||= do{$fr=1;{}};
       for my $k (sort keys %$t) {
           my $v = $t->{$k};
           my ($path,$flows,$from) = split '/', $k;
           
           Rw make/op $amp $pin:k $path $from;
       }
       my $hk = {%{R.way.hooks}};
       for my $z ($hk, $amp) {
           for my $k (keys %$z) {
               next unless $k =~ /^g_(.+)$/;
               say "Has $k";
               $z->{$1} = delete $z->{$k};
           }
       }
       my $x;
       x.wormhole.yr = $hk;  
       x.wormhole.ya = $amp;
       while (my ($dir, $v) = each %$x) {
           while (my ($k, $d) = each %$v) {
               my $y = YAML::Syck::Dump($d);
               die wdump $y if length $y < 50; 
               $y =~ s/^---//;
               encode_utf8 $y;
               fspu("$dir/$k\.yml", $y);
           }    
       }
       
       # maka yml, seeing .s is a gas leak
       `cd wormhole; cat yr\.yml ya\.yml > yb\.yml`;
       #$fr = 1;
       $fr ?
       $G->pub('S/'.$_, "reexec")
       :
       $G->pub('S/'.$_, "wayup w/yb\.yml") for 'shed','coast';
       sayyl "We o ".F_delta();
       
       Rwyl 0.1 J5 scr;
ratio: |
    my $ratio = $o / ($t||1);
    0.01 * int(100*$ratio);
    

