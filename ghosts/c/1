MourmaZ: |
   u ashtray=>,'c ha' 
   my $niot = '
      in wayves it travels
      I hoist by z
      move the things out into args,name,id in I from already
      code leeching out - chov into index, and the brain indexes the bunch of codes run with their I...
      so I is vectored done stuff (u, che acquis)
      thatd be hard to not have at this point
      unmeni the zapping into an I is the finality...
      u bein done...
      the I gets wrenched out but it is all G via J stuff... apply 
      divide the stuff up into K/nk/gk limbs
      and apply the K = diffre/OSC/ACT/OMP
      compine blobs, can want to interdesign each other if travel points further than routable
      then break things off as case...
      just like things are pooled
      the over the room code forming way selector outputs more stuff, unified and interpreted as code to way 
      everything happens as an Elvis, even if not in El
      so In A can acquire its wires
      and splat from A couplings
   ';
   
already: |
    # note ar.*
    $J||die;
    
    ar.I = {};
    Rw I_Din;
    Rw C_C;
    Rw C_E;
    Rw I_D;
    Rw I_Ci;
    Rw I_Cr;
    ar.I
I_Din: |
    I.d = sub {
        my $s = shift;
        # grease thje stomac
        my $P = I.nF ||= {};
        my $y = $I->{$s} || die "no $s";
        $y->(P.A,P.C,P.G,P.T,@_);
    };
    I.n = sub {
        my ($A,$C,$G,$T,$AA,$CC,$GG,$TT) = @_;
        I.nF = {A=>$AA,C=>$CC,G=>$GG,T=>$TT};
    };
    I.z = sub {
        my ($A,$C,$G,$T) = @_;
        push @{A.M}, @{T.oM};
        1
    };
In: | # I I I
    my $N = ar.N||ar.C;
    my $I = J.I && J.I.free ? J.I : J.I = Rw already;
    my $A;
    A.N = [@$N];
    A.I = $I;
    A.fl = ar.fl || {};
    A.M = [];
    aft {
        I.free = 1;
        $@||return;
        my $m = "C: ".ki I.nF.C;
        $m .= "\ns: ".wdump 3, $N;
        $@ = "$m\n$@";
    };
    # 2821:      keys arrive as characters already:
    # prep A for A (I), J-sessioned etc stuff
    # is literal G spacer, index jointed bunch of code to check out from w
    # some comp could expectorate lots charstream rhythms ^
    # Z flow?
    # or we could do on a stick,
    # so its MZ junk dont linger in this stream
    # ie always flow outwards the sc filtery stuff.
    while (@{A.N}) { #
        my $s = shift @{A.N};
        my $C = {};
        my $T = {};
        my $A = {%$A};
        T.oM = [];
        I.d&n,$A,$C,$G,$T;
        I.d&An;
        
        I.d&Ci,$s;
        
        I.d&z && next if T.not;
        
        # elabourate C,
        for my $k (keys %{A.fl}) {
            my $v = A.fl->{$k};
            Rw ym/$k $J $A $C $n:C $v $G $T;
        }
        
        I.d&Cr,$s;
         
        die "not: ".wdump 4,[$N, $C]
           if !ref C.y || !C.y || !defined C.t;
         
        push @{T.oM}, $C;
        
        I.d&z;
    }
    
    my $M = ar.M;
    if ($M) {
        push @$M, @{A.M}
    }
    elsif ($J) {
        map {
           Rw mani + $J $C:_
        } @{A.M}
    } else {
        die "noJM";
    }
     
I_D: |
    I.Ci = sub { # 3 rip out of space
        my ($A,$C,$G,$T,$s) = @_;
        if (!ref $s) {
            I.d&string,$s;
        }
        elsif (ref $s eq 'ARRAY') {
            I.d&array,$s;
        }
        elsif (ref $s eq 'HASH') {
            I.d&hash,$s;
        }
        else { die "mmtype:$s" }
    };
    # of explode into nk,gk (neck jicker or no, tower/surface)
    # these are seen in unification to OSC points, indexed into I
    # the A whatever solicits the I into unifying chunks of itself
    # it can use the I directly for subs like these... 
    # I rafts may be, fall for a while in the background
    # the universal ambience
    # a uCon maxing sure I.x.everything is sequenced
    #I.x.C.1.hash = n hash=>1=>{code=>'C 12',of=>'Ccs',if=>'refs',s=><<''}
    # would flip out way or so as well as the index which is most of ^
    # these flip out way thing, yet compelled to compile with arg and t, where code is 2
    # so code=2 means arg/t,
    # code is 1 and 
    # the swelling hump of horizontally indexed things comes in
    # where N is feeding
    # and el interpret incombeing, pha coney continuate
    #  pha where last %+= new
    # and allow things to turn off vast swathes of other things
    # and pet urbane and beyond
    I.hash = sub {
        my ($A,$C,$G,$T,$s) = @_;
        # a Ci dome, In 3-4 looking at N[.+,{c}]
           s.MZ ? I.d&MZu,s.MZ
           : s.EZ ? I.d&MZu,s.EZ
           : s.WZ ? I.d&MZu,s.WZ
           : s.EC ? I.d&ECu,s.EC
           : die 'hash: '.wdump($s);
    };
    I.array = sub {
        my ($A,$C,$G,$T,$s) = @_;
            if (@$s == 1) {
                my ($s) = @$s;
                ref $s && die "1striong: ".wdump $s;
                I.d&4string,$s
            }
            else {
                I.d&4real,$s
            }
    };
    I.string = sub {
        my ($A,$C,$G,$T,$s) = @_;
        die "string: $s";
    };
    I.Cr = sub { # 6 work the corner
        my ($A,$C,$G,$T) = @_;
        die"reft" if ref C.t;
        I.d&Crey if !ref C.y;
        I.d&Crec if !ref C.c;
        I.d&Cresc if !ref C.sc;
    };
I_Ci: | # receive topu
    $I->{'4string'} = sub { # barse
        my ($A,$C,$G,$T,$s) = @_;
        # sticks out of usual c 5 hive of MZ/awarey things
        if ($s =~ /^\s*#?\s*MZ (.+)$/) {
           I.d&MZu, $1;
        }
        # the rest of this stuff lies here more, eating a string of lumps
        # if we were reading lines the N[$line] hop would neg
        # modem sounds etc.
        # dome props, repeatable tests
        elsif ($s =~ /^\s*(#.*)$/) {
           T.not = 1;
           T.com = $1;
        }
        elsif ($s eq '') {
           T.not = 1;
           T.space = 1; # could mean sticks
        }
        else {
           my $ci = $s;
           for my $nk (qw't y c sc') {
               if ($ci =~ s/^(\S+) *//) { # some t are types of space
                   my $v = $1;
                   $v = I.d&peel,$v if $nk ne 't' && $v =~ I.peels;
                   $C->{$nk} = $v;
               }
           }
        }
    };
    $I->{'4real'} = sub {
        my ($A,$C,$G,$T,$s) = @_;
        (C.t, C.y) = @$s;
        C.c  = $s->[2] if exists $s->[2];
        C.sc = $s->[3] if exists $s->[3];
        die'@>4'.wdump $s if @$s > 4;
    };
    
    I.peels = qr/^[\{\%]/;
    I.peel = sub { # simple as hash from string
        my ($A,$C,$G,$T,$s) = @_;
        $s =~ s/^%// || 
            $s =~ s/^{// && $s =~ s/}$//
            || die "unpealable $s";
        my $c;
        for (split ',', $s) {
            my ($k, $v) = split ':', $_, 2;
            $c->{$k} = $v;
        }
        $c||{}
    };
    I.MZu = sub { # fl apply, strangely, meta zip oi, applu guvtion
        my ($A,$C,$G,$T,$s) = @_;
        for (split /\s+/, $s) {
            /^(.+?)(?::(.+))?$/ || die;
            if (defined $2 && $2 eq '0') {
                delete A.fl->{$1};
            }
            else {
                A.fl->{$1} = $2 || 1;
            }
        }
        T.not = 1;
    };
    I.iZu = sub {
        my ($A,$C,$G,$T,$s) = @_;
        my $way = 'muck';
        $way = 'fund' if $s =~ s/^\///;
        my $Z = Rw $way - $p:s $dclone=1;
    };
    I.EZu = sub {
        my ($A,$C,$G,$T,$s) = @_;
        
        my $Z = I.d&iZu,$s;
        for my $k (sort keys %$Z) {
            my $N = $Z->{$k};
            $N = [ map { [$_] } split "\n",$N ] if !ref $N;
            Rw In $M:T.oM $N;
        }
        T.not = 1;
    };
    I.WZu = sub { # clomne N appends this N, width firstappend us
        my ($A,$C,$G,$T,$s) = @_;
         
        my $Z = I.d&iZu,$s;
        for my $k (sort keys %$Z) {
            my $s = $Z->{$k};
            die wdump $s if ref $s ne 'ARRAY';
            unshift @{A.N}, @$s;
        }
        T.not = 1;
    };
I_Cr: | # work the corner
    # kind of apply filters as they like to chew, ripping from string theirs, later congealing...
    # maybewa u and n of the ym is the way way
    # it doubles
    I.Crey = sub { # work the y corner
        my ($A,$C,$G,$T) = @_;
        if (C.y eq '') { # is or undef
            C.y = {};
        }
        elsif (C.y =~ /^($NUM)$/) {
            C.y = {cv=>$1};
        }
        elsif (C.y =~ /^($NUM)-($NUM)$/) {
            C.y = {from=>$1,to=>$2};
        }
        else {die "strung ny: C.y"};
    };
    I.Crec = sub { # work the c corner
        my ($A,$C,$G,$T) = @_;
        if (!ar.c_is && C.c =~ I.peels) {
            C.c = I.d&peel, C.c;
        }
        else {
            C.c = {s => C.c};
        }
    };
    I.Cresc = sub { # work the c corner
        my ($A,$C,$G,$T) = @_;
        if (C.sc eq '') {
            C.sc = {};
        }
        elsif (C.sc =~ I.peels) {
            C.sc = I.d&peel, C.sc;
        }
        else { die "nostr  C.sc    ".ki $C }
    };

