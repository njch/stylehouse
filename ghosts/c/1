MourmaZ: |
   u ashtray=>,'c ha' 
   my $niot = '
      in wayves it travels
      I hoist by z
      move the things out into args,name,id in I from already
      code leeching out - chov into index, and the brain indexes the bunch of codes run with their I...
      so I is vectored done stuff (u, che acquis)
      thatd be hard to not have at this point
      unmeni the zapping into an I is the finality...
      u bein done...
      the I gets wrenched out but it is all G via J stuff... apply 
      divide the stuff up into K/nk/gk limbs
      and apply the K = diffre/OSC/ACT/OMP
      compine blobs, can want to interdesign each other if travel points further than routable
      then break things off as case...
      just like things are pooled
      the over the room code forming way selector outputs more stuff, unified and interpreted as code to way 
      everything happens as an Elvis, even if not in El
      so In A can acquire its wires
      and splat from A couplings
   ';
   
already: |
    my $I = {};
    Rw I_Din $I;
    Rw I_D $I;
    Rw I_Ci $I;
    Rw I_Cr $I;
    $I;
I_Din: |
    I.d = sub {
        my $s = shift;
        # grease thje stomac
        my $P = I.nF ||= {};
        my $y = $I->{$s} || die "no $s";
        $y->(P.A,P.C,P.G,P.T,@_);
    };
    I.n = sub {
        my ($A,$C,$G,$T,$AA,$CC,$GG,$TT) = @_;
        I.nF = {A=>$AA,C=>$CC,G=>$GG,T=>$TT};
    };
    I.z = sub {
        my ($A,$C,$G,$T) = @_;
        push @{A.M}, @{T.oM};
        1
    };
In: | # I I I
    my $N = ar.N||ar.C;
    my $I = J.I ||= Rw already;
    my $A;
    A.N = $N;
    A.I = $I;
    A.fl = ar.fl || {};
    A.M = [];
    aft {
        $@||return;
        $@ = "C: ".ki(I.nF.C)."\n$@";
    };
    # 2821:      keys arrive as characters already:
    # prep A for A (I), J-sessioned etc stuff
    # is literal G spacer, index jointed bunch of code to check out from w
    # some comp could expectorate lots charstream rhythms ^
    # Z flow?
    # or we could do on a stick,
    # so its MZ junk dont linger in this stream
    # ie always flow outwards the sc filtery stuff.
    while (@{A.N}) { #
        my $s = shift @{A.N};
        my $C = {};
        my $T = {};
        T.oM = [];
        
        I.d&n,$A,$C,$G,$T;
        
        I.d&Ci,$s;
        
        I.d&z && next if T.not;
        
        # elabourate C,
        for my $k (keys %{A.fl}) {
            my $v = A.fl->{$k};
            Rw ym/$k $A $C $n:C $v $G $T;
        }
        
        I.d&Cr,$s;
         
        die "not: ".wdump 4,[$N, $C]
           if !ref C.y || !C.y || !defined C.t;
         
        push @{T.oM}, $C;
        
        I.d&z;
    }
    
    my $M = ar.M;
    if ($M) {
        push @$M, @{A.M}
    }
    elsif ($J) {
        map {
           Rw mani + $J $C:_
        } @{A.M}
    } else {
        die "noJM";
    }
     
I_D: |
    I.Ci = sub {
        my ($A,$C,$G,$T,$s) = @_;
        
        if (!ref $s) {
            die "string: $s";
        }
        elsif (ref $s eq 'ARRAY') {
            if (@$s == 1) {
                my ($s) = @$s;
                ref $s && die "1striong: ".wdump $s;
                I.d&4string,$s
            }
            else {
                I.d&4real,$s
            }
        }
        elsif (ref $s eq 'HASH') {
           s.MZ ? I.d&MZu,s.MZ
           : s.EZ ? I.d&MZu,s.EZ
           : s.WZ ? I.d&MZu,s.WZ
           : die 'hash: '.wdump($s);
        }
        else { die "mmtype:$s" }
    };
    I.Cr = sub { # work the corner
        my ($A,$C,$G,$T) = @_;
        die"reft" if ref C.t;
        I.d&Crey if !ref C.y;
        I.d&Crec if !ref C.c;
        I.d&Cresc if !ref C.sc;
    };
I_Ci: | # receive topu
    $I->{'4string'} = sub { # barse
        my ($A,$C,$G,$T,$s) = @_;
        if ($s =~ /^\s*#?\s*MZ (.+)$/) {
           I.d&MZu, $1;
        }
        elsif ($s =~ /^\s*(#.*)$/) {
           T.not = 1;
           T.com = $1;
        }
        elsif ($s eq '') {
           T.not = 1;
           T.space = 1; # could mean
        }
        else {
           my $ci = $s;
           for my $tk (qw't y c sc') {
               if ($ci =~ s/^(\S+) *//) { # some t are types of space
                   my $v = $1;
                   $v = I.d&peel,$v if $v =~ I.peels;
                   $C->{$tk} = $v;
               }
           }
        }
    };
    $I->{'4real'} = sub {
        my ($A,$C,$G,$T,$s) = @_;
        (C.t, C.y) = @$s;
        C.c  = $s->[2] if exists $s->[2];
        C.sc = $s->[3] if exists $s->[3];
        die'@>4'.wdump $s if @$s > 4;
    };
    
    I.peels = qr/^[\{\%]/;
    I.peel = sub { # simple as hash from string
        my ($A,$C,$G,$T,$s) = @_;
        $s =~ s/^%// || 
            $s =~ s/^{// && $s =~ s/}$//
            || die "unpealable $s";
        my $c;
        for (split ',', $s) {
            my ($k, $v) = split ':', $_, 2;
            $c->{$k} = $v;
        }
        $c||{}
    };
    I.MZu = sub { # fl apply, strangely, meta zip oi, applu guvtion
        my ($A,$C,$G,$T,$s) = @_;
        for (split /\s+/, $s) {
            /^(.+?)(?::(.+))?$/ || die;
            if (defined $2 && $2 eq '0') {
                delete A.fl->{$1};
            }
            else {
                A.fl->{$1} = $2 || 1;
            }
        }
        T.not = 1;
    };
    I.iZu = sub {
        my ($A,$C,$G,$T,$s) = @_;
        my $way = 'muck';
        $way = 'fund' if $s =~ s/^\///;
        my $Z = Rw $way - $p:s $dclone=1;
    };
    I.EZu = sub {
        my ($A,$C,$G,$T,$s) = @_;
        
        my $Z = I.d&iZu,$s;
        for my $k (sort keys %$Z) {
            my $N = $Z->{$k};
            $N = [ map { [$_] } split "\n",$N ] if !ref $N;
            Rw I $M:T.oM $N;
        }
        T.not = 1;
    };
    I.WZu = sub { # clomne N appends this N, width firstappend us
        my ($A,$C,$G,$T,$s) = @_;
         
        my $Z = I.d&iZu,$s;
        for my $k (sort keys %$Z) {
            my $s = $Z->{$k};
            die wdump $s if ref $s ne 'ARRAY';
            unshift @{A.N}, @$s;
        }
        T.not = 1;
    };
I_Cr: | # work the corner
    # kind of apply filters as they like to chew, ripping from string theirs, later congealing...
    # maybewa u and n of the ym is the way way
    # it doubles
    I.Crey = sub { # work the y corner
        my ($A,$C,$G,$T) = @_;
        if (C.y eq '') { # is or undef
            C.y = {};
        }
        elsif (C.y =~ /^($NUM)$/) {
            C.y = {cv=>$1};
        }
        elsif (C.y =~ /^($NUM)-($NUM)$/) {
            C.y = {from=>$1,to=>$2};
        }
        else {die "strung ny: C.y"};
    };
    I.Crec = sub { # work the c corner
        my ($A,$C,$G,$T) = @_;
        if (!ar.c_is && C.c =~ I.peels) {
            C.c = I.d&peel, C.c;
        }
        else {
            C.c = {s => C.c};
        }
    };
    I.Cresc = sub { # work the c corner
        my ($A,$C,$G,$T) = @_;
        if (C.sc eq '') {
            C.sc = {};
        }
        elsif (C.sc =~ I.peels) {
            C.sc = I.d&peel, C.sc;
        }
        else { die "nostr  C.sc    ".ki $C }
    };

