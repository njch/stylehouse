lod/C:
   fun: |
     Rw J5 wam;
     Rw J5 wa;
   wam/on: noe 0.1 eye/o {ou:eye,blur:5px}   
lod/u:
   os: Rw J5 wam;
   shv/curves: [EZ: floorish]
   wam/on: noe 0.1 g/c/1  {ou:eye,blur:5px}
floorish: |
    spun 0 -0.12
    zoom 0 1 
    y    0  0.84 
    x    0  0
    curve 0 -0.4 
brack: |
     Rw J5 shv;
fun: |
     Rw J5 wam;
wa:
   yJ: |
    'clw gui heag sope waz';
    
   M: |
    
    my $E = [map { ki $_ } map { 
      my $d = hitime() - _.now;
      _.now = Rw samv $d;
      $_
      } 
      map{djson $_}
    `cat life/H/*/*/*`
    ]; 
    # $E = wam.oJ.A;
    Mn('wamoJA','',{pi=>'', s=>$E});
    
samv: |
    G.samv ||= [
        ["w", 7*86400], ["d", 86400, " "], ["h", 3600, ":"],
        ["m", 60, ":" ], ["s", 1, 0],
        [ "ms", 0.001 ], [ "us", 1e-6 ], ["ns", 1e-9],
    ];  

    my $scalar = $d;
    my $neg = $scalar < 0;
    if ($neg) {
        $scalar = -$scalar;
    }
    my $d = (shift) || 4;
    if ($scalar == 0) {
        return "0s";
    }
    my $quanta = exp(log($scalar)-2.3025851*$d);
    my $rem = $scalar+0;
    my $rv = "";
    for my $i (0..@{G.samv}) {
           my $unit = G.samv->[$i];
        if ($rv or $unit->[1] <= $rem ) {
           my $x = int($rem/$unit->[1]);
           my $new_rem = ($x ? $rem - ($x*$unit->[1]) : $rem);
           my $last = (G.samv->[$i+1][1]<$quanta);
           if ($last and $new_rem >= $unit->[1]/2) {
               $x++;
           }
           if (!$last and $unit->[2]) {
               $rv .= $x.$unit->[0].$unit->[2];
           }
           elsif (defined $unit->[2] and !$unit->[2]) {
               # stop at seconds
               my $prec = ceil(-log($quanta)/log(10)-1.01);
               if ( $prec >= 1 ) {
                       $rv .= sprintf("%.${prec}f", $rem).$unit->[0];
               }
               else {
                       $rv .= sprintf("%d", $rem).$unit->[0];
               }
               last;
           }
           else {
               $rv .= $x.$unit->[0];
           }
           last if $last;
           $rem = $new_rem;
        }
    }
    ($neg?"-":"").$rv;
mugwu: |
    my %prefixes=(18=>"E",15=>"P",12=>"T",9=>"G",6=>"M",3=>"k",0=>"",
              -3=>"m",-6=>"u",-9=>"n",-12=>"p",-15=>"f",-18=>"a");

    my $scalar = $d;
    my $neg = $scalar < 0 ? "-" : "";
    if ($neg) {
        $scalar = -$scalar;
    }
    my $unit = (shift) || "";
    my $d = (shift) || 4;
    my $e = 0;
    #scale value
    while ( abs($scalar) > 1000 ) { $scalar /= 1000; $e += 3; }
    while ( $scalar and abs($scalar) < 1 ) {$scalar*=1000;$e-=3}

    # round the number to the right number of digits with sprintf
    if (exists $prefixes{$e}) {
        $d -= ceil(log($scalar)/log(10));
        $d = 0 if $d < 0;
        my $a = sprintf("%s%.${d}f", $neg, $scalar);
        return $a.$prefixes{$e}.$unit;
    } else {
        return sprintf("%s%${d}e", $neg, $scalar).$unit;
    }
waz:
    up: |
      my $coi = Rw pha $J $k=jo;
      my $wam = Rw J6 wam;
      my $M=[];
      
      Rw suck */M $J $M;
      
      Jn('zoo',{in=>0.2,o=>$M}); 

      Jn('hoos',0.9,'S@T');
      Rw vortex $J around $d=8;
      coi.exactl->();
      
sope/out: |
    #Rw oJ $J geo &up $noesc=1;
    #Rw chuv $J;
pi/keys: |
    my $M = [];
    Mn("key/$_" => {}, {pi=>'text',s=>$_}) for sort keys %$u;
    Jn('ls',{o=>$M},{});
pi/HASH: |
            my $si = keys %$u;
            Jn(si=>0.1, $si, '{co:fff,fs:6}');
            Jn(Bo => 0.11, {s=>'{'});
            
            if ($si > 32) {
                Jn(many=>0.2,'many}','{co:33e}');
            }
            
             return
             Jn('ends',0.2,'@','{hs:6984,ml:-0.3em}')
             if J.d.y.spc < 0.01;
            Jn(oB => 0.89, {s=>'}'});
            
            # 3
            my $r = {map{$_=>1} sort keys %$u};
            my @r = grep { delete $r->{$_} } 
            qw'K name r style';
            push @r, sort keys %$r;
            
            my $M=[];
            my $i = 0;
            for my $k (@r) {
                my $v = $u->{$k};
                
                my $y = {};
                y.thy = 5 if $k eq 'W';
                Mn('{'.$k => $y, {pi=>'kv',s=>[$k,$v]});
                
                 my $rl = int(21 * (J.d.y.spc / 0.3 * J.d.y.spc));
                if ($i >= $rl) {
                    J.bz->("more\t0.886" => "$i@!!!$rl",
                    
                        '%sf' => "blue");
                    last;
                }
            }
            Jn('ls',{o=>$M},{}); 
pi/ARRAY: |
            my $cv = J.cv ||= 0.3;
            
            Jn(t => 0.1, C.t);
            
            my $si = @$u;
            J.bz->('si 0.1' => $si, '%css' => "color:#fff;font-size:50%");
            J.bz->('Bo 0.11' => '[');
            J.bz->('oB 0.89' => ']');
            
            Jn(Bo => 0.11, {s=>'{'}); 
             return
             Jn('ends',0.2,'@','{hs:6984,ml:-0.3em}')
             if J.d.y.spc < 0.07;
            Jn(oB => 0.89, {s=>'}'});
            
            return if $cv < 0.2;
            
            my $M = [];
            my $i = 0;
            while (exists $u->[$i]) {
                my $uu = $u->[$i];
                
                
                Mn('['.$i => {}, {pi=>'kv',s=>['['.$i,$uu]});
                
                $i++ > 8 && last; 
                if ($i >= 5) {
                    J.bz->("more\t0.886" => "@",
                    
                        '%sf' => "blue");
                    last;
                }
            }
            Jn('ls',{o=>$M},{}); 
pi/kv: |
    return if 3<
    Rw pidepth;
    
    my ($k,$v) = @$u;
    Jn('la',0.2,$k,'{ab:1,ml:-4em}');
    my $M = [];
    Mn('v',0.3,{pi=>'',s=>$v});
    Jn('ls',{o=>$M},{}); 
pidepth: |
    my $o = $J;
    my $i = 0;
    while (o.Jiter) {
        $i++; $o = o.Jiter;
    }
    $i;
os: |
    Rw J5 wa;   
    
J6: |
   my $sc; 
   sc.ok = 6;
   Rw J5 + $sc; 
S/ghostchanges: |
    Rw J5 $file:m;
    Rw loD;
    sayyl "loded";
    Rw rego;
rego: |
    Rw os;   
J5: |
   my $r = {%$ar};
   r.J = delete($r->{m})->[0] if ar.m;
   delete r.R;
   my $d;
   d.c = $r;
   Rw oo $J:G.oin $d;
oo: |
   d.sc = delete d.c.sc if d.c.sc;
   d.t = !ref d.c.J ? d.c.J : d.c.J.name if d.c.J;
   d.t = d.c.file if d.c.file;
   d.cv = 0.4 if d.c.file;
   d.cv = 0.3 if d.c.J;
   sayyl ki 1, $d;
   
   my $jr = sub {
       my $s = shift;
       my $v = shift;
       $s = '%'.$s if $s;
       my $r = "d.t$s\td.cv";
       !defined $v ? J.bb->{$r} :
       do { J.bb->{$r} = $v;
         sub { delete J.bb->{$r} } 
       }
       ;
   };
   
   d.s = $jr->();
   if (d.c.J) {
       die if ref d.c.J;
       if (!d.s) {
           my $o = {name=>d.c.J};
           d.s = Rw JJ $o;
           sayyl "Made o.name";
       }
       die if !ref d.s;
   }
   if (d.c.file) {
       warn "d.c.file ist d.s";
       return if !d.s;
   }
   if (d.sc.ok) {
       my $ok = d.sc.ok;
       my $co = jr&ok-$ok;
       #$ok && hitime-
       return d.s;warn wdump d.sc;
   }
   my $ig = {map{$_,1}qw'file J ok'};
   my @jh = grep{!$ig->{$_}}keys %{d.c};
   #warn "Have: @jh" if @jh;
   my $hav = 1 if @jh;
   # some alt ^ make round v
   # 7
   die if !d.t;
   die if !d.cv;
   die if !ref d.s;
   
   J.bz->("d.t\td.cv",d.s);
   
   do {
       my $ar = {%{d.c}};
       ar.J=d.s;
       return d.s if !$hav && jr&ok-9;
       my $n = $hav ? sub{} : jr&ok-9,9;
       Rw around;
       $n->();
   };
   d.s
etc: |
   maky something

