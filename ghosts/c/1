MourmaZ: |
   u ashtray=>,'c ha' 
   n fdlwk=>''=>{s=><<''}
       # and from Indi
            # and whenever
            # then the things todo
            # lots ||nexts
            # elabourate C, seeming to chew
            # we want to throw our next II etc
            # transmit A,C via AZ, which and A.cv via AZ and A.II)
       in wayves it travels
       I hoist by z
       move the things out into args,name,id in I from already
       code leeching out - chov into index,
         and the brain indexes the bunch of codes run with their I...
       so I is vectored done stuff (u, che acquis)
       thatd be hard to not have at this point
       unmeni the zapping into an I is the finality...
       u bein done...
       the I gets wrenched out but it is all G via J stuff... apply 
       divide the stuff up into K/cv/t limbs
       and apply the K = diffre/OSC/ACT/OMP
       compine blobs, can want to interdesign each other if travel points further than routable
       then break things off as case...
       just like things are pooled
       the over the room code forming way selector outputs more stuff
       unified and interpreted as code to way 
       everything happens as an z Elvis, even if not in El
       so In A can acquire its wires
       and splat from A couplings
   
   n zfold=>''=>{s=><<''}
       wired up some hypnocodes from other J.A.I (& u) into G.T.$W
       then in each there each W is supposedly W overlay (way)
       and theres I/1/n,An->A.t auxi, which shall wind us up to 1
       but its a bundle of wires here, about 8
       if top level hashes are all same skji/recycle, some others uCon is trusted
       G.T is a switching table
       together and wind up to 1...
       collasp J.A.IIII and J.A.I, where [$(pathfrom$A)+] or Kcvt hashbush
       the tree that changes hashes leading into its diff
       compiling II, the Kcvt single pile
       which code proteins on I with Mobile, tiny ex A.cv->1 starter
       to be stitched K/cv/t 
        # see if this wander I...
        # dangling selfs: spiral III from W creaturey
        # there's W managed for us, create the tiniest consume starter:
        # this is the usual spiral group overlay sphere arbiter
        #Rw SNtl $I;
        # n - take A
        # An - furbish A.t
        # A.t - crawl (in general) to 1, which Essen

   n A_t=>''=>{s=><<''}
        # is iunterrr that this collapses ongoingly...
        # a stream under a bridge
        # lets get sa spiral overlayer for doing K/cv/t groupi
        # Kceive it... K is a C on the wall/ground
        # much mergey extendo rubble, 
        # and $={%$} the hashes along the path to what we change, cluing
        # the tearifuing part is 
        # the conscious operator of the change could be a part of the bundle of wires
        # so I and III want to be watched, spiral planed in
        # if the ref is the same we could say its the same, travel entropy, horse aim
        # it likes to travel so it likes to travel travel, spes. travelled travel
        # its the way we thing about whatever else is going on
        # so it is data injection agent
        # that one awareness is part of the budle am wires
        # this feeding on I or III
Arange: |
    ar.oA && ar.oA.D &&
    substr(ar.oA.D.bab, 0, 200) =~ /s=><<''/ && 
    Rw babsubrip $oA:ar.oA $D:ar.oA.D $N;
    
    my $A = {};
    A.J = ar.J || die 'noJ';
    A.G = $G; # so travel can G/T/Hypo
    A.mo = $A;
    (A.am) = @{delete ar.m};
    A.am || die "unsame?";
    $A;
WeBase: | # require N, required to return an A.I that I.n,I.An,A.t
    my $A = Rw Arange;
    A.N = [ar.C || @{ar.N}];
    A.M = [];
    A.talk = "A.J.name ".(A.J.le && A.J.le.name);
    A.fl = ar.fl || {};
    A.I = {};
    
    my $I = delete G.drop.recycling->{A.J.id}->{A.am};
    
    my $II = Rw collaspII $A;
    
    if ($I) {
        if (I.Ii eq II.Ii) {
            say "Recyc A.talk! I.Ii continu";
            A.I = $I;
            A.cv = 0.1;
        }
        else {
            sayre "Recycloped, Diff I.Ii  --  II.Ii";
            undef $I;
        }
    }
    
    A.I.Ii = II.Ii;
    
    if (!$I) {
        $I = A.I||die'basenoi';
        Rw SNtl $I;
    }
    $A
SNtl: | # spiral Nat toolz
    I.n = sub { # A qcui
        my ($A,$C,$G,$T,$AA,$CC,$GG,$TT) = @_;
        I.nF = {A=>$AA,C=>$CC,G=>$GG,T=>$TT};
    };
    I.d = sub { # be, sub
        my $s = shift;
        my $P = I.nF ||= {};
        my $y = $I->{$s} || die "no way named '$s'";
        $y->(P.A,P.C,P.G,P.T,@_);
    };
    I.An = sub { # A within faller
        my ($A,$C,$G,$T) = @_;
        A.c = sub { die "An  ein!" };
        A.t = sub { I.d&t,@_ };
        $A
    };
    I.t = sub {
        my ($A,$C,$G,$T,@M) = @_;
        my ($cv,$K) = reverse @M;
        @M>2 && die "_ _";
        $K ||= A.am||die"noam A_t";
        
        my $i = Rw collaspII $A;
        
        my $c = 0+("0.".$cv);
        sayyl "Sends proteins into I A.talk: i.Ii";
        $c == 0.1 || die "Senbial proot $c";
        Rw SNat $A $C $G $T $I $i $K $cv;
        A.cv = $c;
    };
SNat: | # I.ex do  # it's in that, bubbles 
    # baseism
    my $s = {};
    my $c = 0+("0.".$cv);
    my $talk = "A.talk: $K A.cv > $c --- C.t ";
    
    my $aim = {$K=>1};
    aim.I = 1 if $aim->{A.am};
    
    my $yv = {};
    # make K/cv/t -> cv/K/t
    for my $k (sort keys %$i) {
        my $ii = $i->{$k};
        
        next if $k eq 'Ii';
        next if $k eq 'ooI';
        ref $ii eq 'HASH' || die "weird $k=$ii";
        
        for my $vc (sort keys %$ii) {
            my $iii = $ii->{$vc};
            die'$k !0<$vc<1' unless $vc > 0 && $vc < 1;
            $yv->{$vc}->{$k} = $iii;
        }
    }
    
    # do stuff
    my $vb; # in fractions
    for my $vc (sort keys %$yv) {
        my $is = $yv->{$vc};
        
        next if $vc <= A.cv && $vc != $c;
        next if $vc > $c;
            
        if ($vb && $vc > $vb && @{A.N}) {
            # sincing, wide order
            # various others want to be around for only some of the process...
            sayre "$vb -> $vc  bump, ". @{A.N};
            T.Z->{$vb} = 1;
            return T.not = 1;
        }
        for my $k (sort keys %$is) {
            my $iii = $is->{$k};
            
            next unless $aim->{$k};
            
            for my $ik (sort keys %$iii) {
                my $D = $iii->{$ik};
                
                if (my $nk = D.sc.nk) {
                    my $C = I.nF.C;
                    next if !exists $C->{$nk};
                    if (my $gk = D.sc.gk) {
                        next if !exists $C->{$nk}->{$gk};
                    }
                }
                my $act;
                my $dont;
                if (D.sc.acgt && D.sc.act) {
                    $act = 1;
                    # acgtsubs can be defined at any cv
                    # run themselves if act
                    # usu. one receiver (Ci) and the rest scheme
                    die "D.t .act gets... D.sc.act" if D.sc.act ne '1';
                    $dont = 1 if exists A.I->{D.t};
                }
                
                # schools of many fish
                $vb ||= $vc if D.sc.v;
                
                # TreeD
                $s->{$k}->{$vc}->{$ik} = $D;
                my $sep = $act ? "----" : ">>>>";
                sayre "DElEE $talk $k $sep $vc  D.t D.y.cv  ".ki D.sc
                    if A.J.V > 1;
                
                # way or acgt-setuping-way
                unless ($dont) {
                    my $paw = join"_",'',$k,$vc,D.t;
                    $paw =~ s/\W//g;
                    Rw $paw $A $C $G $T $__D:D;
                }
                
                # most tiny ticks
                if ($act) {
                    D.sc.acgt eq 's'||die "nonacgts".ki $D;
                    exists A.I->{D.t}||die "acgtI D.t not up: ".ki A.I;
                    I.d&D.t,A.s;
                }
                return if T.not;  # will &z, oseve
                return if delete T.whack;
            }
        }
    }
    
    say Rw TreeD $s $scby=gro if A.J.V && keys %$s;
    
IStuff: |
    u allacgt
    
    n d =>''=>{s=><<''},{acgt=>1,args=>'s'}
        # grease thje stomac
        shift; # imporo
        my $y = $I->{$s} || die "no way named '$s'";
        my $P = I.nF ||= {};
        P.A||die'PnoA!?'; # papto
        $y->(P.A,P.C,P.G,P.T,@_);
    
    n n =>''=>{s=><<''},{acgt=>'AA,CC,GG,TT'}
        I.nF = {A=>$AA,C=>$CC,G=>$GG,T=>$TT};
    
    n recycle =>''=>{s=><<''}
        return if I.recyttl++ > 8;
        G.drop.recycling->{A.J.id}->{A.am} = $I;
KnowTime: | # dome props
    u allacgts
    
    n An =>''=>{s=><<''},{acgt=>1}
        A.note = {}; # pinging csc
        A.talk = "A.J.name ".(A.J.le && A.J.le.name);
        A.c = sub { I.d&c,@_; };
        A.t = sub { I.d&t,@_; };
        $A
    
    n t =>''=>{s=><<''},{acgt=>'K,cv'}
        ($K,$cv) = (A.am,$K) if !$cv && $K;
        die "K$K cv$cv" unless $K && $cv;
        # adapt to much  mergey       extendo  rubble, 
        #
        my $i = Rw collaspII $A;
        #
        my $c = 0+("0.".$cv);
        my $ncv;
        my $re;
        my $dont;
        if (A.cv < 0.6 || $c >= 0.7) {
            if ($c >= A.cv) {
                $ncv = $c;
                $re = 1;
            }
            else {
                $re = 0;
                $dont = 1;
                say " deInc A.cv - $cv $c";
            }
            die "pre bigger" if $cv < A.cv;
        }
        else {
            if ($c < A.cv) {
                if (A.cv == 0.6) { # scoop up all on entering timezone
                    $re = 1;
                    $dont = 1; # or will II fall away
                }
                else {
                    $re = 0;
                    $dont = 1;
                }
            }
            elsif ($c == A.cv) {
                $re = 1;
            }
            elsif ($c > A.cv) { # and $c < 0.7, is a next time
                T.Z->{$c} = 1;
                $re = 0;
                $dont = 1;
            }
            else {die"nof"}
        }
        my $was = A.cv;
        $dont || I.d&ex,$i,$K=>$cv;
        A.cv = $ncv if defined $ncv && A.cv == $was;
        $re;
    
    n ex =>''=>{s=><<''},{acgt=>'i,K,cv'}
        #Rw SNat $A $C $G $T $I $i $K $cv;
        # baseism
        my $s = {};
        my $c = 0+("0.".$cv);
        my $talk = "A.talk: $K A.cv > $c --- C.t ";
        .
        my $aim = {$K=>1};
        aim.I = 1 if $aim->{A.am};
        .
        my $yv = {};
        # make K/cv/t -> cv/K/t
        for my $k (sort keys %$i) {
            my $ii = $i->{$k};
            .
            next if $k eq 'Ii';
            next if $k eq 'ooI';
            ref $ii eq 'HASH' || die "weird $k=$ii";
            .
            for my $vc (sort keys %$ii) {
                my $iii = $ii->{$vc};
                die'$k !0<$vc<1' unless $vc > 0 && $vc < 1;
                $yv->{$vc}->{$k} = $iii;
            }
        }
        .
        # do stuff
        my $vb; # in fractions
        for my $vc (sort keys %$yv) {
            my $is = $yv->{$vc};
            .
            next if $vc <= A.cv && $vc != $c;
            next if $vc > $c;
            .
            if ($vb && $vc > $vb && @{A.N}) {
                # sincing, wide order
                # various others want to be around for only some of the process...
                sayre "$vb -> $vc  bump, ". @{A.N};
                T.Z->{$vb} = 1;
                return T.not = 1;
            }
            for my $k (sort keys %$is) {
                my $iii = $is->{$k};
                .
                next unless $aim->{$k};
                .
                for my $ik (sort keys %$iii) {
                    my $D = $iii->{$ik};
                    .
                    if (my $nk = D.sc.nk) {
                        my $C = I.nF.C;
                        next if !exists $C->{$nk};
                        if (my $gk = D.sc.gk) {
                            next if !exists $C->{$nk}->{$gk};
                        }
                    }
                    my $act;
                    my $dont;
                    if (D.sc.acgt && D.sc.act) {
                        $act = 1;
                        # acgtsubs can be defined at any cv
                        # run themselves if act
                        # usu. one receiver (Ci) and the rest scheme
                        die "D.t .act gets... D.sc.act" if D.sc.act ne '1';
                        $dont = 1 if exists A.I->{D.t};
                    }
                    .
                    # schools of many fish
                    $vb ||= $vc if D.sc.v;
                    .
                    # TreeD
                    $s->{$k}->{$vc}->{$ik} = $D;
                    my $sep = $act ? "----" : ">>>>";
                    sayre "DElEE $talk $k $sep $vc  D.t D.y.cv  ".ki D.sc
                        if A.J.V > 1;
                    .
                    # way or acgt-setuping-way
                    unless ($dont) {
                        my $paw = join"_",'',$k,$vc,D.t;
                        $paw =~ s/\W//g;
                        Rw $paw $A $C $G $T $__D:D;
                    }
                    # most tiny ticks
                    if ($act) {
                        D.sc.acgt eq 's'||die "nonacgts".ki $D;
                        exists A.I->{D.t}||die "acgtI D.t not up: ".ki A.I;
                        I.d&D.t,A.s;
                    }
                    return if T.not;  # will &z, oseve
                    return if delete T.whack;
                }
            }
        }
        say Rw TreeD $s $scby=gro if A.J.V && keys %$s;
    
    # y
Indo: | # leg off In if Ind (Wild)
    my $A = Rw WeBase Collarspew;
    my $M = [];
    my $oA = Rw Indi + $A;
    sayyl "Indo thought ";
    Rw humms $J:G.oin $N:oA.M talky;
Indulator: | # Wain spinality
    # not allcode since uCons blank qq cone & then thing
    n Bangdesk =>W
    n IStuff =>W
    n KnowTime =>W
    n SlideEater =>W
    n CGolf =>W
    n Csys =>W
    n Servo =>W
    n Indiy =>W
    n Motion =>W
    
Indi: |
    my $A = Rw WeBase In;
    my $I = A.I;
    I.d&n,$A,{},$G,{};
    I.d&An;
    A.t&1;
    A.t&11111 || warn "NO 1";
    while (@{A.N}) { #
        my $A = {%$A};
        A.mo.on = $A;
        A.s = shift @{A.N};
        my $C = {};
        my $T = {};
        I.d&n,$A,$C,$G,$T;
        I.d&An;
        A.t&2;
        $A = I.nF.A;
        T.not&&next;
        I.d&z && next if T.not;
        A.t&6||die("Was not to 6")&&next;
        I.d&flywheels;
        I.d&z && next if T.not;
        A.t&78;
        I.d&z;
    }
    continue { I.d&z; }
    A.t&8;
    I.d&recycle;
    ar.M ? do {
        push @{ar.M}, @{A.M};
        $A
    }
    : ar.J ? map {
        Rw Modi + $J $C:_
    } @{A.M}
    : die "noJMout";
    
Motion: |
    u allacgts
    # 6* thing/rule management
    # SNat exudes over the nk'ing ish things which .wh=fly(wheel)
    # iterates grouped 6cv via T.Z, all N at a time
    # (make no hop if ==1)
    # also have pha cone stack available for offphasing
    # if our intent it loose enough
    n Act =>''=>{s=><<''}
        $A = {%$s};
        A.mo.ont = $A;
        A.s = shift @{A.N};
        I.d&n,$A,{},$G,{};
        I.d&An;
        A.t&2;
        map{I.nF->{$_}}qw'A C T';
    
    # begins with possible outgoing magnet:
    n ToM =>''=>{s=><<''},{code=>'I 112',act=>1}
        T.oM = [];
    
    n Tat =>''=>{s=><<''}
        my $at = delete T.at;
        $at || die "youAT";
        C.sc->{$_} = $at->{$_} for keys %$at; # sizling update sprites
    
    n CoM =>''=>{s=><<''},{code=>'I 71',act=>1}
        push @{T.oM}, $C;
    
    # on exit, snakes
    n z =>''=>{s=><<''}
        push @{A.M}, @{T.oM};
        I.d&oseverato;
        1
    
Indiy: | # A and A
    u allacgts
    # A and A.mo dye drops, M tractios, T tooly
    
    n flywheels =>''=>{s=><<''}
        # wants to be a six alwayser... ,{code=>'I 6',act=>'all'} # II.All? II.Fly?
        # its I.d&nded and holds things to code, $v a spiral it's filling up
        # $v could be mounted... aj8 mysteries
        for my $k (sort keys %{A.fl}) {
            my $v = A.fl->{$k};
            #   ^ bus to ride
            $k = $2 if $k =~ /^(\d+) (.+)$/;
            Rw ym/$k $I $J:A.J $A $C $v $G $T;
        }
    
    n oseverato =>''=>{s=><<''}
        if (my $z = delete T.Z) { # tease out the next times
            my ($lo) = sort keys %$z; # next one
            @{T.oM} = ();
            push @{A.mo.re->{$lo} ||= []}, [$A,$C];
        }
        if (!@{A.mo.N} && A.mo.re) {
            my $ats = A.mo.re || {};
            my @wa = sort keys %$ats;
            my ($lo) = @wa;
            if ($lo) {
                my $ay = delete $ats->{$lo};
                my @N = map { {AZ=>{$lo=>$_}} } @$ay;
                sayyl "Loop A.cv > $lo x ".@N;
                push @{A.mo.N}, @N;
            }
        }
        # concoi severaliser, for conglom up; merging spiral snips of code
        if (my $y = T.y) {
            for my $k (keys %$y) {
                A.mo.y->{$k}->{C.y.p}->{C.y.cvt} = $C;
            }
        }

    n moy =>''=>{s=><<''}
        # groups, spread the moise over A
        my $i = A.mo.y->{$s}||die"no$s";
        my $is = $i->{C.y.p}; # things in our C's pool
        {is=>$is,N=>[map{$is->{$_}}sort keys %$is]};
    
        
In: | # I I I
    J.A.Indo && return Rw Indo;
    
    my $A = Rw already + $am=In $N;
    my $I = A.I;
    I.d&n,$A,{},$G,{};
    I.d&An;
    A.t&1;
    
    A.t&11111 || warn "NO 1";
    # 
    
    # 2821:      keys arrive as characters already:
    # prep A for A (I), J-sessioned etc stuff
    # is literal G spacer, index jointed bunch of code to check out from w
    # some comp could expectorate lots charstream rhythms ^
    # Z flow?
    # or we could do on a stick,
    # so its MZ junk dont linger in this stream
    # ie always flow outwards the sc filtery stuff.
    while (@{A.N}) { #
        my $s = shift @{A.N};
        my $C = {};
        my $T = {};
        my $A = {%$A};
        A.mo.on = $A;
        A.s = $s;
        T.oM = [];
        I.d&n,$A,$C,$G,$T;
        I.d&An;
        A.t&2;
        
        I.d&Ci,$s;
        ($A,$C) = @{T.grabac} if T.grabac;
        
        I.d&z && next if T.not;
        I.d&Cr,$s;
        A.t&6;
        I.d&z && next if T.not;
        
        # elabourate C,
        for my $k (sort keys %{A.fl}) {
            my $v = A.fl->{$k};
            $k = $2 if $k =~ /^(\d+) (.+)$/;
            Rw ym/$k $I $J $A $C $v $G $T;
        }
        I.d&z && next if T.not;
        
        
        push @{T.oM}, $C;
        
        A.t&7;
        I.d&z;
    }
    
    I.d&recycle;
    
    my $M = ar.M;
    if ($M) {
        push @$M, @{A.M}
    }
    elsif ($J) {
        map {
           Rw mani + $J $C:_
        } @{A.M}
    } else {
        die "noJM";
    }
    
Bangdesk: |
    u allacgts
    # want to sus $@ and hang vectors of what, should be autoish
    # suppose we come here with only ACGT between us and F
    n after =>''=>{s=><<''},{code=>"In 11",act=>1}
        aft {
            $@ || return; A.bang && return; A.bang = 21;
                # want to sus $@ and hang vectors of what, should be autoish
                my $m = "J: I.nF.A.talk";
                $m .= "\nC: ".k2 I.nF.C;
                $m .= "\ns: ".wdump 3, I.nF.A.s unless length $m > 20;
                $@ = "$m\n$@";
            # A.t&9,$@; 
        }
    
    n erg =>''=>{s=><<''},{code=>"I 9"}
        # must pre compile, see D severators
        my $m = "J: A.talk";
        $m .= "\nC: ".ki $C;
        $m .= "\ns: ".wdump 3, A.s unless length $m > 20;
        $@ = "$m\n$@";
    
SlideEater: | # liney schemery
    u allacgts
    
    n Ci =>''=>{s=><<''},{code=>'I 12',act=>1}
        if (!ref $s) {
            I.d&string,$s;
        }
        elsif (ref $s eq 'ARRAY') {
            I.d&array,$s;
        }
        elsif (ref $s eq 'HASH') {
            I.d&hash,$s;
        }
        else { die "mmtype:$s" }
    
    n string =>''=>{s=><<''}
        die "string: $s";
    
    n array =>''=>{s=><<''}
        if (@$s == 1) {
            my ($s) = @$s;
            ref $s && die "array1ref: ".wdump $s;
            I.d&fourstring,$s
        }
        else {
            I.d&fourreal,$s
        }
    
    n hash =>''=>{s=><<''}
        return %$C = %$s if s.t && s.y && s.c;
        # some talking to self - how to C over exactly, the object could be live
        I.d&servehash,$s;
    
    n reasonlock =>''=>{s=><<''},{code=>'I 18',act=>1}
        die"reft" if ref C.t;
        # uis a nested wave
        # allow much manufold
        I.d&reny if !ref C.y;
        I.d&renc if !ref C.c;
        I.d&rensc if !ref C.sc;
        (3==grep{ref}map{$C->{$_}}y=>c=>'sc') &&
        defined C.t || die "reaso fail".wdump $C;
    
    n reny =>''=>{s=><<''}
        C.y = C.y eq '' ? {}
            : C.y =~ /^($NUM)$/
            ? {cv=>$1}
            : C.y =~ /^($NUM)-($NUM)$/
            ? {from=>$1,to=>$2}
            : die "strung ny: C.y".wdump $C;
    
    n renc =>''=>{s=><<''}
        C.c = C.c =~ I.peels ? I.d&peel,C.c
          : {s => C.c};
    
    n rensc =>''=>{s=><<''}
        C.sc = C.sc eq '' ? {}
            : C.sc =~ I.peels
            ? I.d&peel,C.sc
            : die "nostr  C.sc    ".ki $C
    
CGolf: |
    u allacgts
    
    n fourstring =>''=>{s=><<''}
        # sticks out of usual c 5 hive of MZ/awarey things #l=Servo
        if ($s =~ /^\s*#?\s*MZ (.+)$/) {
           I.d&MZu, $1;
        }
        # the rest of this stuff lies here more, eating a string of lumps
        # if we were reading lines the N[$line] hop would neg
        # modem sounds etc.
        # dome props, repeatable tests
        elsif ($s =~ /^\s*(#.*)$/) {
           T.not = 1;
           T.com = $1;
        }
        elsif ($s eq '') {
           T.not = 1;
           T.space = 1; # could mean sticks
        }
        else {
           my $ci = $s;
           for my $nk (qw't y c sc') {
               if ($ci =~ s/^(\S+) *//) { # some t are types of space
                   my $v = $1;
                   $v = I.d&peel,$v if $nk ne 't' && $v =~ I.peels;
                   $C->{$nk} = $v;
               }
           }
        }
    
    n fourreal =>''=>{s=><<''}
        (C.t, C.y) = @$s;
        C.c  = $s->[2] if exists $s->[2];
        C.sc = $s->[3] if exists $s->[3];
        die'@>4'.wdump $s if @$s > 4;
        die"C.t from ".wdump $s if ref C.t; # dive
    
    n peels =>''=>{s=><<''},{subpeel=>1}
        qr/^[\{\%]/;
    
    n peel =>''=>{s=><<''}
        $s =~ s/^%// || 
            $s =~ s/^{// && $s =~ s/}$//
            || die "unpealable $s";
        my $c;
        for (split ',', $s) {
            my ($k, $v) = split ':', $_, 2;
            $c->{$k} = $v;
        }
        $c||{}
    
    
Servo: | # things over top of speech bubble in the c 5 liniarity
    u allacgts
    
    n servehash =>''=>{s=><<''}
          s.AZ ? I.d&AZu,s.AZ
        : s.MZ ? I.d&MZu,s.MZ
        : s.EZ ? I.d&EZu,s.EZ
        : s.WZ ? I.d&WZu,s.WZ
        : s.EC ? I.d&ECu,s.EC
        : die 'hash: '.wdump($s);
    
    # time impersonator
    n AZu =>''=>{s=><<''},{l=>'Indiy/oseverato'}
        die 'amany' if keys %$s > 1;
        my ($cv,$ac) = %$s;
        my ($AA,$CC) = @$ac;
        $AA ||= $A; # spawning cone thing
        I.d&n,$AA,$CC,$G,$T;
        $A = $AA;
        if (A.cv >= $cv) {
            warn "Double comback A.cv $cv";
            return T.not = 1;
        }
        A.cv = $cv;
        I.d&An;
        T.whack = 1;
    
    n MZu =>''=>{s=><<''}
        my $uM = sub {
            my ($k,$v) = @_;
            if (defined $v && $v eq '0') {
                delete A.fl->{$k}
            }
            else {
                A.fl->{$k} = $v || 1;
            }
        };
        ref $s eq 'HASH' ?
            map{ $uM->($_,$s->{$_}) } keys %$s
        :   map{
                /^(.+?)(?::(.+))?$/ || die;
                $uM->($1,$2);
            } split /\s+/, $s;
        T.not = 1;
    
    # without our humm, straight to M
    # this is kind of like going through el1389, so many spires to pi on
    # the calls to In want to be IId
    n EZu =>''=>{s=><<''},{l=>'Motion'}
        my $Z = I.d&iZu,$s;
        warn "About EZ";
        for my $k (sort keys %$Z) {
            my $N = $Z->{$k};
            $N = [ map { [$_] } split "\n",$N ] if !ref $N;
            Rw In $M:T.oM $N;
        }
        T.not = 1;
    
    # with our humm
    n WZu =>''=>{s=><<''},{l=>'Motion'}
        my $Z = I.d&iZu,$s;
        warn "About WZ";
        for my $k (sort keys %$Z) {
            my $s = $Z->{$k};
            die wdump $s if ref $s ne 'ARRAY';
            unshift @{A.N}, @$s;
        }
        T.not = 1;
    
    n ECu =>''=>{s=><<''},{l=>'Motion'}
        # extend C on the way in to another dome, magnetised into our M
        # probably for collapsing roooves...
        # dumber than sc decompresphere & playing out
        # (is mailing itself further instructions, intro c, further lines)
        # an In persona, joining our M
        # push to dome
        # that must in  A
        ref $s eq 'ARRAY' || die;
        my ($N,$c) = @$s;
        # take 4s v             add 3s v         next 2 
        $N = [{MZ=>A.fl}, {MZ=>{'3 doex'=>$c}}, @$N];
        # and In could feel our light cone
        Rw In $J:A.J $M:T.oM $N;
        # ^but instead push to A.N and A.No, the sister strand Whare Y Whare
        # and A walks through t&Y, d&Whare(6)
        # turns via n&ACGT
        # the time beams mapped... a W concat couldol
        T.not = 1;
     
    # theses, pulling bits
    n iZu =>''=>{s=><<''}
        my $way = $s =~ s/^\/// ? 'fund' : 'muck';
        my $Z = Rw $way - $p:s $dclone=1;
    
Csys: |
    u allacgts
    
    n c =>''=>{s=><<''},{acgt=>'D'}
        die'nofA' if !I.nF.A;
        $D = I.d&interpD,@_ if !ref $D;
        for (qw'code if of ref') {
            exists C.c->{$_} && die "COT I".ki $C
        }
        my $v = I.d&Cngk,$D;
        return () unless $v;
        A.note->{D.c.nk}->{D.c.gk} = $v if A.note;
        die 'mulitAn' if @$v > 1;
        if (D.c.as eq 'list') {
            return ref $v eq 'ARRAY' ? @$v : die'Cngk not array';
        }
        return 1;
    
    n interpD =>''=>{s=><<''},{acgt=>'nk,gk'}
        return $nk if ref $nk;
        my $D = {};
            while ($gk =~ s/^%(.+?):(.+?)(?=%|$)//g) {
                D.c->{$1} = $2;
                pop @_ if @_ == 2;
            }
            if (@_ == 1) { # or from t,,,
                D.c.nk ||= 'c';
                D.c.gk ||= $nk;
            }
            elsif (@_ == 2) {
                D.c.nk = $nk;
                D.c.gk = $gk;
            }
        $D
    
    n Cngk =>''=>{s=><<''},{acgt=>'D'}
        ref $A || die "nmonref A!";
        die 'nk no gk' if exists D.c.nk && !exists D.c.gk;
        return 1 if D.c.any;
        if (D.c.nk && exists $C->{D.c.nk} && exists $C->{D.c.nk}->{D.c.gk}) {
            my $v = [$C->{D.c.nk}->{D.c.gk}];
            delete $C->{D.c.nk}->{D.c.gk} if D.c.mdel;
            return $v;
        }
        die "noNnk".wdump $D unless exists D.c.nk;
        0;
    
    n xot =>''=>{s=><<''},{acgt=>'s,c'}
        while (my($k,$v) = each %$c) {
            $s->{$k} = ref $v ? {%{$s->{$k}||{}}, %$v} : $v;
        }
        $s
   
   

