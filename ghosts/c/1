MZ: |
   u ashtray=>,'c ha' 
   my $niot = '
      in wayves it travels
      I hoist by z
      move the things out into args,name,id in I from already
      code leeching out - chov into index, and the brain indexes the bunch of codes run with their I...
      so I is vectored done stuff (u, che acquis)
      thatd be hard to not have at this point
      unmeni the zapping into an I is the finality...
      u bein done...
      the I gets wrenched out but it is all G via J stuff... apply 
      divide the stuff up into K/nk/gk limbs
      and apply the K = diffre/OSC/ACT/OMP
      
   ';
   
already: |
    my $I = {};
    Rw I_Din $I;
    Rw I_D $I;
    Rw I_Ci $I;
    Rw I_Cr $I;
    $I;
I_Din: |
    I.d = sub {
        my ($s) = @_;
        # grease thje stomac
        my $P = I.nF ||= {};
        my $y = $I->{$s} || die "no $s";
        $y->(P.A,P.C,P.G,P.T,@_);
    };
    I.n = sub {
        my ($A,$C,$G,$T,$AA,$CC,$GG,$TT) = @_;
        I.nF = {A=>$AA,C=>$CC,G=>$GG,T=>$TT};
    };
    I.z = sub {
        my ($A,$C,$G,$T) = @_;
        push @{A.M}, @{T.oM};
        1
    };
In: | # I I I
    my $N = ar.N||ar.C;
    my $I = J.I ||= Rw already;
    my $A;
    A.N = $N;
    A.I = $I;
    A.fl = {};
    A.M = [];
    # prep A for A
    # some comp could expectorate lots charstream rhythms ^
    # Z flow?
    # or we could do on a stick,
    # so its MZ junk dont linger in this stream
    # ie always flow outwards the sc filtery stuff.
    while (@{A.N}) { #
        my $s = shift @{A.N};
        my $C = {};
        my $T = {};
        T.oM = [];
         
        I.d&n,$A,$C,$G,$T;
        
        I.d&Ci,$s;
        
        I.d&z && next if T.not;
        
        # elabourate C,
        for my $k (keys %{A.fl}) {
            my $v = A.fl->{$k};
            Rw ym/$k $A $C $n:C $v $G $T;
        }
        
        I.d&Cr,$s;
         
        die "not: ".wdump 4,[$N, $C]
           if !ref C.y || !C.y || !defined C.t;
         
        push @{T.oM}, $C;
        
        I.d&z;
    }
    
    my $M = ar.M;
    if ($M) {
        push @$M, @{A.M}
    }
    elsif ($J) {
        map {
           Rw mani + $J $C:_
        } @{A.M}
    } else {
        die;
    }
     
I_D: |
    I.Ci = sub {
        my ($A,$C,$G,$T,$s) = @_;
        
        if (!ref $s) {
            die "string: $s";
        }
        elsif (ref $s eq 'ARRAY') {
            if (@$s == 1) {
                my ($s) = @$s;
                ref $s && die;
                I.d&4string,$s
            }
            else {
                I.d&4real,$s
            }
        }
        elsif (ref $s eq 'HASH') {
           s.MZ ? I.d&MZu,s.MZ
           : s.EZ ? I.d&MZu,s.EZ
           : s.WZ ? I.d&MZu,s.WZ
           : die 'hash: '.wdump($s);
        }
        else { die "mmtype:$s" }
    };
    I.Cr = sub { # work the corner
        my ($A,$C,$G,$T) = @_;
        die"reft" if ref C.t;
        I.d&Crey if !ref C.y;
        I.d&Crec if !ref C.c;
        I.d&Cresc if !ref C.sc;
    };
I_Ci: | # receive topu
    $I->{'4string'} = sub { # barse
        my ($A,$C,$G,$T,$s) = @_;
        if ($s =~ /^\s*#?\s*MZ (.+)$/) {
           I.d&MZu, $1;
        }
        elsif ($s =~ /^\s*(#.*)$/) {
           T.not = 1;
           T.com = $1;
        }
        elsif ($s eq '') {
           T.not = 1;
           T.space = 1; # could mean
        }
        else {
           my $ci = $s;
           for my $tk (qw't y c sc') {
               if ($ci =~ s/^(\S+) *//) { # some t are types of space
                   my $v = $1;
                   $v = I.d&peel,$v if $v =~ I.peels;
                   $C->{$tk} = $v;
               }
           }
        }
    };
    $I->{'4real'} = sub {
        my ($A,$C,$G,$T,$s) = @_;
        (C.t, C.y) = @$s;
        C.c  = $s->[2] if exists $s->[2];
        C.sc = $s->[3] if exists $s->[3];
        die'@>4'.wdump $s if @$s > 4;
    };
    
    I.peels = qr/^[\{\%]/;
    I.peel = sub { # simple as hash from string
        my ($A,$C,$G,$T,$s) = @_;
        $s =~ s/^%// || 
            $s =~ s/^{// && $s =~ s/}$//
            || die "unpealable $s";
        my $c;
        for (split ',', $s) {
            my ($k, $v) = split ':', $_, 2;
            $c->{$k} = $v;
        }
        $c||{}
    };
    I.MZu = sub { # fl apply, strangely, meta zip oi, applu guvtion
        my ($A,$C,$G,$T,$s) = @_;
        for (split /\s+/, $s) {
            /^(.+?)(?::(.+))?$/ || die;
            if (defined $2 && $2 eq '0') {
                delete A.fl->{$1};
            }
            else {
                A.fl->{$1} = $2 || 1;
            }
        }
        T.not = 1;
    };
    I.iZu = sub {
        my ($A,$C,$G,$T,$s) = @_;
        my $way = 'muck';
        $way = 'fund' if $s =~ s/^\///;
        my $Z = Rw $way - $p:s $dclone=1;
    };
    I.EZu = sub {
        my ($A,$C,$G,$T,$s) = @_;
        
        my $Z = I.d&iZu,$s;
        for my $k (sort keys %$Z) {
            my $N = $Z->{$k};
            $N = [ map { [$_] } split "\n",$N ] if !ref $N;
            Rw I $M:T.oM $N;
        }
        T.not = 1;
    };
    I.WZu = sub { # clomne N appends this N, width firstappend us
        my ($A,$C,$G,$T,$s) = @_;
         
        my $Z = I.d&iZu,$s;
        for my $k (sort keys %$Z) {
            my $s = $Z->{$k};
            die wdump $s if ref $s ne 'ARRAY';
            unshift @{A.N}, @$s;
        }
        T.not = 1;
    };
I_Cr: | # work the corner
    # kind of apply filters as they like to chew, ripping from string theirs, later congealing...
    # maybewa u and n of the ym is the way way
    # it doubles
    I.Crey = sub { # work the y corner
        my ($A,$C,$G,$T) = @_;
        if (C.y eq '') { # is or undef
            C.y = {};
        }
        elsif (C.y =~ /^($NUM)$/) {
            C.y = {cv=>$1};
        }
        elsif (C.y =~ /^($NUM)-($NUM)$/) {
            C.y = {from=>$1,to=>$2};
        }
        else {die "strung ny: C.y"};
    };
    I.Crec = sub { # work the c corner
        my ($A,$C,$G,$T) = @_;
        if (!ar.c_is && C.c =~ I.peels) {
            C.c = I.d&peel, C.c;
        }
        else {
            C.c = {s => C.c};
        }
    };
    I.Cresc = sub { # work the c corner
        my ($A,$C,$G,$T) = @_;
        if (C.sc eq '') {
            C.sc = {};
        }
        elsif (C.sc =~ I.peels) {
            C.sc = I.d&peel, C.sc;
        }
        else { die "nostr  C.sc    ".ki $C }
    };

