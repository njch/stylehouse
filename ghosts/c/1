Intt: |
    my $A = Rw WeBase In;
    my $I = A.I;
    I.d&n,$A,{},$G,{};
    I.d&An;
    A.t&1;
    A.t&11111 || warn "NO 1";
    my $i;
    while (@{A.N}) { #
        $i++ > 1000 && die "Huge Indi";
        my ($A,$C,$T) = I.d&Act,$A;
        T.not&&next;
        A.t&6;
        T.not&&next;
        I.d&flywheels;
        T.not&&next;
        A.t&78;
        T.not&&next;
    }
    continue { I.d&z; }
    A.t&8;
    I.d&recycle;
    ar.M ? do {
        push @{ar.M}, uniq @{A.M};
        $A
    }
    : ar.J ? map {
        Rw Modi + $J $C:_
    } @{A.M}
    : die "noJMout";
    
MourmaZ: | # notes
   u ashtray=>,'c ha' 
   n fdlwk=>''=>{s=><<''}
       # and from Indi
            # and whenever
            # then the things todo
            # lots ||nexts
            # elabourate C, seeming to chew
            # we want to throw our next II etc
            # transmit A,C via AZ, which and A.cv via AZ and A.II)
       in wayves it travels
       I hoist by z
       move the things out into args,name,id in I from already
       code leeching out - chov into index,
         and the brain indexes the bunch of codes run with their I...
       so I is vectored done stuff (u, che acquis)
       thatd be hard to not have at this point
       unmeni the zapping into an I is the finality...
       u bein done...
       the I gets wrenched out but it is all G via J stuff... apply 
       divide the stuff up into K/cv/t limbs
       and apply the K = diffre/OSC/ACT/OMP
       compine blobs, can want to interdesign each other if travel points further than routable
       then break things off as case...
       just like things are pooled
       the over the room code forming way selector outputs more stuff
       unified and interpreted as code to way 
       everything happens as an z Elvis, even if not in El
       so In A can acquire its wires
       and splat from A couplings
   
   n zfold=>''=>{s=><<''}
       wired up some hypnocodes from other J.A.I (& u) into G.T.$W
       then in each there each W is supposedly W overlay (way)
       and theres I/1/n,An->A.t auxi, which shall wind us up to 1
       but its a bundle of wires here, about 8
       if top level hashes are all same skji/recycle, some others uCon is trusted
       G.T is a switching table
       together and wind up to 1...
       collasp J.A.IIII and J.A.I, where [$(pathfrom$A)+] or Kcvt hashbush
       the tree that changes hashes leading into its diff
       compiling II, the Kcvt single pile
       which code proteins on I with Mobile, tiny ex A.cv->1 starter
       to be stitched K/cv/t 
        # see if this wander I...
        # dangling selfs: spiral III from W creaturey
        # there's W managed for us, create the tiniest consume starter:
        # this is the usual spiral group overlay sphere arbiter
        #Rw SNtl $I;
        # n - take A
        # An - furbish A.t
        # A.t - crawl (in general) to 1, which Essen

   n A_t=>''=>{s=><<''}
        # is iunterrr that this collapses ongoingly...
        # a stream under a bridge
        # lets get sa spiral overlayer for doing K/cv/t groupi
        # Kceive it... K is a C on the wall/ground
        # much mergey extendo rubble, 
        # and $={%$} the hashes along the path to what we change, cluing
        # the tearifuing part is 
        # the conscious operator of the change could be a part of the bundle of wires
        # so I and III want to be watched, spiral planed in
        # if the ref is the same we could say its the same, travel entropy, horse aim
        # it likes to travel so it likes to travel travel, spes. travelled travel
        # its the way we thing about whatever else is going on
        # so it is data injection agent
        # that one awareness is part of the budle am wires
        # this feeding on I or III
Indulator: | # Wain spinality
    # not allcode since uCons blank qq cone & then thing
    n Bangdesk
    n IStuff
    n KnowTime
    n SlideEa
    n C
    n Servo
    n Motion
    
Arange: |
    ar.N && ar.oA && ar.oA.D &&
    substr(ar.oA.D.bab, 0, 200) =~ /<<('\w*'|"\w*")/ && 
    Rw babsubrip $oA:ar.oA $D:ar.oA.D $N:ar.N;
    
    my $A = {};
    A.oA = ar.oA if ar.oA;
    A.J = ar.J || die 'noJ';
    A.G = $G; # so travel can G/T/Hypo
    A.mo = $A;
    (A.am) = ar.t || ar.name || @{delete ar.m};
    A.am || die "unsame?";
    $A;
WeBase: | # require N, required to return an A.I that I.n,I.An,A.t
    my $A = Rw Arange;
    A.N = [ar.C ||
        @{ar.N ||
            [[ar.t?(ar.t,'',{J=>A.J}):die"artnot: send C or N"]]
        }];
    A.M = [];
    A.talk = "A.J.name ".(A.J.le && A.J.le.name);
    A.fl = ar.fl || {};
    A.I = {};
    
    my $I = delete G.drop.recycling->{A.J.id}->{A.am};
    
    my $II = Rw collaspII $A;
    
    if ($I) {
        if (I.Ii eq II.Ii) {
            say "Recyc A.talk! I.Ii continu" if A.J.V;
            #$I = {%$I,nF=>{}};
            A.I = $I;
            A.cv = 0.1;
        }
        else {
            sayre "Recycloped, Diff I.Ii  --  II.Ii" if A.J.V;
            undef $I;
        }
    }
    
    A.I.Ii = II.Ii;
    
    if (!$I) {
        $I = A.I||die'basenoi';
        Rw SNtl $I;
    }
    $A
SNtl: | # spiral Nat toolz
    I.n = sub { # A qcui
        my ($A,$C,$G,$T,$AA,$CC,$GG,$TT) = @_;
        I.nF = {A=>$AA,C=>$CC,G=>$GG,T=>$TT};
    };
    I.d = sub { # be, sub
        my $s = shift;
        my $P = I.nF ||= {};
        my $y = $I->{$s} || die "no way named '$s'";
        $y->(P.A,P.C,P.G,P.T,@_);
    };
    I.An = sub { # A within faller
        my ($A,$C,$G,$T) = @_;
        A.c = sub { die "An  ein!" };
        A.t = sub { I.d&t,@_ };
        $A
    };
    I.t = sub {
        my ($A,$C,$G,$T,@M) = @_;
        my ($cv,$K) = reverse @M;
        @M>2 && die "Massive M _ _";
        $K ||= A.am||die"noam A_t";
        
        my $i = Rw collaspII $A;
        
        my $c = 0+("0.".$cv);
        saygr "Proteins A.talk: i.Ii" if G.protV || A.J.V;
        $c == 0.1 || die "Senbial proot $c: A.J.name";
        Rw SNat $A $C $G $T $I $i $K $cv;
        A.cv = $c;
    };
SNat: | # I.ex do  # it's in that, bubbles 
    # baseism
    my $s = {};
    my $c = 0+("0.".$cv);
    my $talk = "A.talk: $K A.cv > $c --- C.t ";
    
    my $aim = {$K=>1};
    aim.I = 1 if $aim->{A.am};
    
    my $yv = {};
    # make K/cv/t -> cv/K/t
    for my $k (sort keys %$i) {
        my $ii = $i->{$k};
        
        next if $k eq 'Ii';
        next if $k eq 'ooI';
        ref $ii eq 'HASH' || die "weird $k=$ii";
        
        for my $vc (sort keys %$ii) {
            my $iii = $ii->{$vc};
            die'$k !0<$vc<1' unless $vc > 0 && $vc < 1;
            $yv->{$vc}->{$k} = $iii;
        }
    }
    
    # do stuff
    my $vb; # in fractions
    for my $vc (sort keys %$yv) {
        my $is = $yv->{$vc};
        
        next if $vc <= A.cv && $vc != $c;
        next if $vc > $c;
            
        if ($vb && $vc > $vb && @{A.N}) {
            # sincing, wide order
            # various others want to be around for only some of the process...
            sayre "$vb -> $vc  bump, ". @{A.N} if A.J.V > 1;
            T.Z->{$vb} = 1;
            return T.not = 1;
        }
        for my $k (sort keys %$is) {
            my $iii = $is->{$k};
            
            next unless $aim->{$k};
            
            for my $ik (sort keys %$iii) {
                my $D = $iii->{$ik};
                
                if (my $nk = D.sc.nk) {
                    my $C = I.nF.C;
                    next if !exists $C->{$nk};
                    if (my $gk = D.sc.gk) {
                        next if !exists $C->{$nk}->{$gk};
                    }
                }
                my $act;
                my $dont;
                if (D.sc.acgt && D.sc.act) {
                    $act = 1;
                    # acgtsubs can be defined at any cv
                    # run themselves if act
                    # usu. one receiver (Ci) and the rest scheme
                    die "D.t .act gets... D.sc.act" if D.sc.act ne '1';
                    $dont = 1 if exists A.I->{D.t};
                }
                
                # schools of many fish
                $vb ||= $vc if D.sc.v;
                
                # TreeD
                $s->{$k}->{$vc}->{$ik} = $D;
                my $sep = $act ? "----" : ">>>>";
                sayre "DElEE $talk $k $sep $vc  D.t D.y.cv  ".ki D.sc
                    if A.J.V > 2;
                
                # way or acgt-setuping-way
                unless ($dont) {
                    my $paw = join"_",'',$k,$vc,D.t;
                    $paw =~ s/\W//g;
                    Rw $paw $A $C $G $T $__D:D;
                }
                
                # most tiny ticks
                if ($act) {
                    D.sc.acgt eq 's'||die "nonacgts".ki $D;
                    exists A.I->{D.t}||die "acgtI D.t not up: ".ki A.I;
                    I.d&D.t,A.s;
                }
                return if T.not;  # will &z, oseve
                return if delete T.whack;
            }
        }
    }
    
    A.J.V > 1 && keys %$s && saygr
        Rw TreeD $s $scby=gro;
    
IStuff: |
    u allacgt
    
    n d =>''=>{s=><<''},{acgt=>1,args=>'s'}
        # grease thje stomac
        shift; # imporo
        my $y = $I->{$s} || die "no way named '$s'";
        my $P = I.nF ||= {};
        P.A||die'PnoA!?'; # papto
        $y->(P.A,P.C,P.G,P.T,@_);
    
    n n =>''=>{s=><<''},{acgt=>'AA,CC,GG,TT'}
        I.nF = {A=>$AA,C=>$CC,G=>$GG,T=>$TT};
    
    n recycle =>''=>{s=><<''}
        return if I.recyttl++ > 8;
        G.drop.recycling->{A.J.id}->{A.am} = $I;
KnowTime: | # dome props
    u allacgts
    
    n 't' =>''=>{s=><<''},{acgt=>'K,cv,av',nois=>'#c'}
        ($K,$cv) = (A.am,$K) if !$cv && $K;
        $av = 0+("0.".$av) if $av;
        die "K$K cv$cv" unless $K && $cv;
        my $c = 0+("0.".$cv);
        my $Av = $av || A.cv;
        .
        # adapt to much  mergey       extendo  rubble
        my $i = Rw collaspII $A;
        die'difAvcol' if $Av ne ($av || A.cv);
        #
        my $ncv;
        my $re;
        my $dont;
        if ($Av < 0.6 || $c >= 0.7) {
            if ($c >= $Av) {
                $ncv = $c;
                $re = 1;
            }
            else {
                $re = 0;
                $dont = 1;
                say " deInc $Av - $cv $c";
            }
            die "pre bigger" if $cv < $Av;
        }
        else {
            if ($c < $Av) {
                if ($Av == 0.6) { # scoop up all on entering timezone
                    $re = 1;
                    $dont = 1; # or will II fall away
                }
                else {
                    $re = 0;
                    $dont = 1;
                }
            }
            elsif ($c == $Av) {
                $re = 1;
            }
            elsif ($c > $Av) { # and $c < 0.7, is a next time
                T.Z->{$c} = 1;
                $re = 0;
                $dont = 1;
            }
            else {die"nof"}
        }
        undef $ncv if $av; # aux K
        my $was = A.cv;
        $dont || I.d&ex,$i,$K,$cv,$av;
        A.cv = $ncv if defined $ncv && A.cv == $was;
        $re;
    
    n ex =>''=>{s=><<''},{acgt=>'i,K,cv,av',nois=>'#c'}
        # was Rw SNat $A $C $G $T $I $i $K $cv;
        # baseism
        my $c = 0+("0.".$cv);
        my $Av = $av || A.cv;
        my $sp = $av ? " Flav $av (no A.cv)" : "";
        .
        my $talk = "A.talk: $K$sp $Av > $c --- C.t ";
        .
        my $aim = {$K=>1};
        if ($aim->{A.am}) {
            $aim->{$_} = 1 for @{A.Isl||[]};
            aim.I = 1;
        }
        .
        my $yv = {};
        # make K/cv/t -> cv/K/t
        for my $k (sort keys %$i) {
            my $ii = $i->{$k};
            .
            next if $k eq 'Ii';
            next if $k eq 'ooI';
            ref $ii eq 'HASH' || die "weird $k=$ii";
            .
            for my $vc (sort keys %$ii) {
                my $iii = $ii->{$vc};
                die'$k !0<$vc<1' unless $vc > 0 && $vc < 1;
                $yv->{$vc}->{$k} = $iii;
            }
        }
        .
        # do stuff
        my $vb; # in fractions
        my $wasSubtle;
        for my $vc (sort keys %$yv) {
            my $is = $yv->{$vc};
            my $s = {};
            my $x = {};
            my $xrd = [];
            .
            next if $vc <= $Av && $vc != $c;
            next if $vc > $c;
            .
            # our  osc (stay in K per Subtle ness);
            my @iz = grep {
                $aim->{$_} || (aim.I && (A.Iso->{$_} || I.also->{$_}))
            } sort keys %$is;
            next if !@iz;
            .
            # decide inter cv wideness loop
            if ($wasSubtle) {
                undef $wasSubtle;
            }
            elsif ($vb && $vc > $vb && (
                @{A.N} || @{A.mo.re->{$vb}||[]}
                )) {
                # sincing, wide order
                # various others want to be around for only some of the process...
                sayre "$vb -> $vc  bump, ". @{A.N} if A.J.V > 1;
                T.Z->{$vb} = 1;
                A.cv = $vb; # so we dont wind up to 6 on the way out of t
                return T.not = 1;
            }
            .
            # pin down poles
            I.cv = $vc;
            I.vb = $vb;
            # draw curvles as spirals done
            .
            for my $k (@iz) {
                my $iii = $is->{$k};
                I.k = $k;
                I.d&carebowl,$s,$iii,$x,$xrd;
            }
            # suble
            my $se = Rw TreeD $s $scby=gro 
                if A.J.V > 1 && keys %$s;
            $c == 0.1 ? saygr $se : say $se if $se;
            .
            my $o;
            (o.vc,o.vb) = ($vc,$vb);
            I.d&exood,$o,$x,$xrd;
            ($vc,$vb) = (o.vc,o.vb);
            if (o.Subtle && !o.nonSubtle) {
                $wasSubtle = 1;
            }
            .
            return if T.not;  # will &z, oseve
            return if delete T.whack;
        }
    
    n carebowl =>''=><<'',{l=>'#c',acgt=>'s,iii,x,xrd'}
        for my $ik (sort keys %$iii) {
            my $D = $iii->{$ik};
            if (my $nk = D.sc.nk) {
                my $C = I.nF.C;
                next if !exists $C->{$nk};
                if (my $gk = D.sc.gk) {
                    next if !exists $C->{$nk}->{$gk};
                }
            }
            my $act;
            my $dont;
            if (D.sc.acgt && D.sc.act) {
                $act = 1;
                # acgtsubs can be defined at any cv
                # run themselves if act
                # usu. one receiver (Ci) and the rest scheme
                die "D.t .act gets... D.sc.act" if D.sc.act ne '1';
                $dont = 1 if exists A.I->{D.t};
            }
            # way or acgt-setuping-way
            unless ($dont) {
                my $paw = join"_",'',I.k,I.cv,D.t;
                $paw =~ s/\W//g;
                Rw $paw $A $C $G $T $__D:D;
            }
            # most tiny ticks
            # this ind is all flywheel
            # it's a kind of unity that wants to be a block of code like this
            # and c
            my @is = A.s;
            @is = I.d&scIfs,D.sc.Ifs if D.sc.Ifs;
            @is || next;
            if ($act) {
                push @$xrd, [I.k,$ik];
                my $Ds = $x->{I.k}->{$ik} ||= {};
                Ds.D = $D;
                Ds.is = \@is;
                D.sc.its = @is;
            }
            # TreeD
            $s->{I.k}->{I.cv}->{$ik} = $D;
        }
    
    n exood =>''=><<'',{l=>'#c',acgt=>'o,x,xrd'}
        for my $kik (@$xrd) {
            my ($k,$ik) = @$kik;
            A.Subtle && A.Subtle->{$k} ? o.Subtle++ : o.nonSubtle++;
            my $Ds = $x->{$k}->{$ik};
            my $D = Ds.D;
            for my $s (@{Ds.is}) {
                D.sc.acgt eq 's'||die "nonacgts".wdump $D;
                exists A.I->{D.t}||die "acgtI D.t not up: ".wdump A.I;
                .
                I.d&D.t,$s;
                .
                I.acted and I.d&acted,$s;
                .
                if (my $ut = T.ut) {
                    if (ut.matchTd) {
                        my $d = s.d || die "confuse";
                        d.od.s.T.q->{d.e.k} ||= $d;
                        d.od.s.T.m->{d.e.k} ||= $d
                            unless delete(T.noTd);
                    }
                    else { die"utrowhat ".wdump 2, $ut }
                }
                .
                # outwave: schools of many fish (not upcv if !@is)
                o.vb ||= o.vc if D.sc.v;
                .
                last if T.not || T.whack;
            }
            delete T.ut;
            last if T.not || T.whack;
        }
    
    # y
Motion: |
    u allacgts
    # 6* thing/rule management
    # SNat exudes over the nk'ing ish things which .wh=fly(wheel)
    # iterates grouped 6cv via T.Z, all N at a time
    # (make no hop if ==1)
    # also have pha cone stack available for offphasing
    # if our intent it loose enough
    
    # G.h
    # encap A/spiral spinner for the G.h, from the  to ar A.I.d&Others
    # G.h&I finds relevant A.I to AI.d&Other with, returning ($A,$I)
    n Other =>''=>{s=><<''}
        my $ar = $F[0]->{ar};
        $A = Rw RB + $t:s;
        $I = A.I;
        # midnight at the oasis
        I.d&n,$A,{},$G,{};
        I.d&An;
        A.t&1;
        A.t&11111 || warn "NO 1";
        ($A,A.I)
    
    n An =>''=>{s=><<''},{acgt=>1}
        A.note = {}; # pinging csc
        A.talk = "A.J.name ".(A.J.le && A.J.le.name);
        A.c = sub { I.d&c,@_; };
        A.e = sub { I.d&e,@_; };
        A.us = sub { I.d&us,@_; };
        A.t = sub { I.d&t,@_; };
        A.V = sub {
            my $bl = shift;
            A.J.VV && A.J.VV->{$bl}
            || A.J.V
        };
        $A
    
    n Act =>''=>{s=><<''}
        $A = {%$s};
        A.mo.ont = $A;
        A.s = shift @{A.N};
        $T = {};
        T.oM = [];
        I.d&n,$A,{},$G,$T;
        I.d&An;
        A.t&2;
        map{I.nF->{$_}}qw'A C T';
    
    n Tat =>''=>{s=><<''}
        my $at = delete T.at;
        $at || die "youAT";
        C.sc->{$_} = $at->{$_} for keys %$at; # sizling update sprites
    
    # outgoing magnatrain (per Act)
    n CoM =>''=>{s=><<''},{code=>'I 71',act=>1}
        push @{T.oM}, $C unless T.Z;
    
    # on exit, snakes
    n z =>''=>{s=><<''}
        I.d&oseverato;
        push @{A.M}, @{T.oM};
        1

    # A and A.mo dye drops, M tractios, T tooly, see also flywheel
    n flywheels =>''=>{s=><<''}
        # wants to be a six alwayser... ,{code=>'I 6',act=>'all'} # II.All? II.Fly?
        # its I.d&nded and holds things to code, $v a spiral it's filling up
        # $v could be mounted... aj8 mysteries
        for my $k (sort keys %{A.fl}) {
            my $v = A.fl->{$k};
            #   ^ bus to ride
            $k = $2 if $k =~ /^(\d+) (.+)$/;
            Rw ym/$k $I $J:A.J $A $C $v $G $T;
        }
    
    n oseverato =>''=>{s=><<''}
        if (T.d) {
            A.T.d = T.d; # carte
        }
        if (my $z = delete T.Z) { # tease out the next times
            my ($lo) = sort keys %$z; # next one
            my $v = $z->{$lo};
            push @{A.mo.re->{$lo} ||= []},
                ref $v eq 'ARRAY' ? @$v :
                $v ne '1' ? [$A,$C,$v] :
                [$A,$C];
            @{T.oM} = ();
        }
        if (!@{A.mo.N} && A.mo.re) {
            my $ats = A.mo.re || {};
            my @wa = sort keys %$ats;
            my ($lo) = @wa;
            if ($lo) {
                my $ay = delete $ats->{$lo};
                my @N = map { {AZ=>{$lo=>$_}} } @$ay;
                push @{A.mo.N}, @N;
                saybl "Looping ".@N." to $lo" if A.J.V > 1;
            }
        }
        # concoi severaliser, for conglom up; merging spiral snips of code
        if (my $y = T.y) {
            for my $k (keys %$y) {
                A.mo.y->{$k}->{C.y.p}->{C.y.cvt} = $C;
            }
        }

    n moy =>''=>{s=><<''}
        # groups, spread the moise over A
        my $i = A.mo.y->{$s}||die"no$s";
        my $is = $i->{C.y.p}; # things in our C's pool
        {is=>$is,N=>[map{$is->{$_}}sort keys %$is]};
    
Bangdesk: |
    u allacgts
    # want to sus $@ and hang vectors of what, should be autoish
    # suppose we come here with only ACGT between us and F
    n after =>''=>{s=><<''},{code=>"I 11",act=>1}
        A.bangdesk = {};
        aft {
            $_->() for values %{A.bangdesk.aft};
            $@ || return;
            A.bang && return;
            A.bang = 21;
            $_->() for values %{A.bangdesk.bang};
            # want to sus $@ and hang vectors of what, should be autoish
            my $m = "J: I.nF.A.talk        A.mo.ont.cv";
            $m .= "\nC: ".k2 I.nF.C;
            $m .= "\ns: ".wdump 3, I.nF.A.s unless length $m > 20;
            $@ = "$m\n$@";
            # A.t&9,$@; # skippy
        }
    
    n erg =>''=>{s=><<''},{code=>"I 9"}
        # must pre compile, see D severators
        my $m = "J: A.talk";
        $m .= "\nC: ".ki $C;
        $m .= "\ns: ".wdump 3, A.s unless length $m > 20;
        $@ = "$m\n$@";
    
SlideEa: | # liney schemery
    u allacgts
    
    n Ci =>''=>{s=><<''},{code=>'I 12',act=>1}
        !ref $s ? I.d&string,$s
        :
        ref $s eq 'ARRAY' ? I.d&array,$s
        :
        ref $s eq 'HASH' ? I.d&hash,$s
        :
        die "mmtype:$s";
    
    n string =>''=>{s=><<''}
        die "string: $s";
    
    n array =>''=>{s=><<''}
        return I.d&fourreal,$s if @$s != 1 && !ref $s->[0] || $s->[0] =~ /^\w+$/;
        return I.d&fourstring,$s if @$s == 1 && !ref $s->[0];
        # should stick In in first and M it? 
        # kind of motion that wants to be unsure in the wild
        unshift @{A.N}, @$s;
        T.not = 1;
    
    n hash =>''=>{s=><<''}
        return %$C = %$s if exists s.t && s.y && s.c;
        # some talking to self - how to C over exactly
        # the object could be live
        I.d&servehash,$s;
    
    n reasonlock =>''=>{s=><<''},{code=>'I 18',act=>1,li=>'#c'}
        die"reft" if ref C.t;
        my $istf = sub {
            my $s = shift;
            exists s.t && !ref s.t && ref s.y && ref s.c && 9 > keys %$s;
        };
        # uis a nested wave - falling ]]]]]]]
        # allow much manufold
        # knot this not this:
        if (A.J.name eq 'qq' || A.J.most.J eq A.J) {
            C.c.W = C.t unless C.c || C.sc || C.y;
        }
        # this form: NextWorm=>$C=>$J (C/J swappy)
        if (ref C.y eq 'HASH' && (C.y.bb || $istf->(C.y))) {
            if (C.y.bb) {
                if (ref C.c eq 'HASH' && $istf->(C.c)) {
                    C.c = {e=>C.c};
                }
                C.c.s = C.y;
            }
            else {
                if (ref C.c eq 'HASH' && C.c.bb) {
                    C.c = {s=>C.c};
                }
                C.c.e = C.y;
            }
            C.y = '';
            C.c.W = C.t;
        }
        .
        I.d&renc if !ref C.c;
        I.d&reny if !ref C.y;
        I.d&rensc if !ref C.sc;
        defined C.t && !ref C.t
        && ref C.y && ref C.c && ref C.sc
            || die "reaso fail".wdump [A.s,$C];
        I.d&scyvle;
    
    # fold space til fit
    n scyvle =>''=>{s=><<''}
        for (qw'in out cv') {
            if (my $so = C.y->{$_}) {
                my $i;
                while (C.y->{$_} <= -1 || C.y->{$_} >= 1) {
                    C.y->{$_} /= 10;
                    die "Many i chewing on ".ki C.y if $i++ > 10;
                }
            }
        }
    
    n reny =>''=>{s=><<''}
        C.y = C.y eq '' ? (I.blanky ? I.d&blanky : {})
            : C.y =~ /^($NUM)$/ ? {cv=>$1}
            : C.y =~ /^($NUM)-($NUM)$/ ? {in=>$1,out=>$2}
            : C.y =~ /^($NUM)-($NUM)x($NUM)$/ ? {in=>$1,out=>$2,thi=>$3}
            : C.y =~ /^([WJ])$/ ? do {
                C.c->{$1} = C.t;
                {};
            }
            : I.rey ? I.d&rey
            : die "C y wtf: C.y";
    
    n renc =>''=>{s=><<''}
        C.c = C.c =~ I.peels ? I.d&peel,C.c
          : {s => C.c};
    
    n rensc =>''=>{s=><<''}
        C.sc = C.sc eq '' ? {}
            : C.sc =~ I.peels
            ? I.d&peel,C.sc
            : die "C sc nostr: C.sc   of I.peels  ".ki $C
    
C: |
    u allacgts
    # modem sounds etc.
    # dome props, repeatable tests
    n fourstring =>'',<<''
        I.d&MZu,$1 if $s =~ /^\s*#?\s*MZ (.+)$/;
        if ($s =~ /^\s*(#.*)$/) {
           T.not = 1;
           T.com = $1;
        }
        elsif ($s eq '') {
           T.not = T.space = 1;
        }
        else {
           my $ci = $s;
           for my $nk (qw't y c sc') {
               if ($ci =~ s/^(\S+) *//) { # some t are types of space
                   my $v = $1;
                   $v = I.d&peel,$v if $nk ne 't' && $v =~ I.peels;
                   # << consumes more lines into $nk, then ...
                   $v = '' if $v =~ /^(''|"")$/;
                   $C->{$nk} = $v;
               }
           }
        }
        saybl "4string: ".ki $C;
    
    n fourreal =>'',<<''
        (C.t, C.y) = @$s;
        C.c  = $s->[2] if exists $s->[2];
        C.sc = $s->[3] if exists $s->[3];
        die'@>4'.wdump $s if @$s > 4;
        die"C.t from ".wdump $s if ref C.t; # dives
    
    n peels =>'',<<'','%subpeel'
        qr/^[\{\%]/;
    
    n peel =>'',<<''
        $s =~ s/^%// || 
            $s =~ s/^{// && $s =~ s/}$//
            || die "unpealable $s";
        my $c;
        for (split ',', $s) {
            my ($k, $v) = split ':', $_, 2;
            $v = 1 if !defined $v;
            $c->{$k} = $v;
        }
        $c||{}
    
    # for getting click together:
    n c =>'',<<'','%acgt:D'
        I.d&inDin,$C,@M;
    
    n e =>'',<<'','%acgt:D'
        I.d&inDin,C.c.e,@M;
    
    n us =>'',<<'','%acgt:D'
        my $E = C.c.e || return ();
        push @M, 'NOGK' if @M == 1;
        I.d&inDin,E.c.us,@M;
    
    n inDin =>'',<<'',{acgt=>'s,D'}
        die'nofA' if !I.nF.A;
        #
        return () unless defined $s;
        return $s if $D eq 'C';
        #
        shift @M; # s
        $D = I.d&interpD,@M if !ref $D;
        #
        my $v = I.d&Cngk,$s,$D;
        #
        return () unless $v;
        # blankgk
        A.note->{D.c.nk}->{D.c.gk} = $v if A.note;
        #
        die 'mulitAn' if @$v > 1;
        if (D.c.as eq 'list') {
            ref $v eq 'ARRAY' || die 'Cngk not array';
            return @$v;
        }
        return 1;
    
    n interpD =>''=>{s=><<''},{acgt=>'nk,gk'}
        my $defnk = 'c';
        return $nk if ref $nk;
        my $D = {};
        D.c.as = 'list' if 1 || $nk =~ s/^_//;
        while ($gk =~ s/^%(.+?):(.+?)(?=%|$)//g) {
            D.c->{$1} = $2;
            pop @M if @M == 2;
        }
        if (@M == 1 && $nk eq 't') {
            D.c.nk = $nk;
        }
        elsif (@M == 1) { # or from t,,,
            D.c.nk ||= $defnk;
            D.c.gk ||= $nk;
        }
        elsif (@M == 2) {
            D.c.nk = $nk;
            D.c.gk = $gk;
        }
        delete D.c.gk if D.c.gk eq 'NOGK';
        $D
    
    n Cngk =>'',<<'',{acgt=>'s,D'}
        ref $A || die "nmonref A!";
        aft { $@ .= "\nLookat: ".ki($s)."\nWith: ".ki($D) if $@ };
        return 1 if D.c.any;
        die "nonNKnk".ki$D if !D.c.nk;
        return 0 if !exists $s->{D.c.nk};
        return [$s->{D.c.nk}] if !exists D.c.gk;
        return 0 if !exists $s->{D.c.nk}->{D.c.gk};
        return [$s->{D.c.nk}->{D.c.gk}];
    
    n xot =>'',<<'',{acgt=>'s,c'}
        while (my($k,$v) = each %$c) {
            $s->{$k} = ref $v ? {%{$s->{$k}||{}}, %$v} : $v;
        }
        $s
   
   
Servo: | # lightning over speech bubble in the c 5 liniarity (Motion doing)
    u allacgts
    
    n servehash =>''=>{s=><<''}
          s.AZ ? I.d&AZu,s.AZ
        : s.MZ ? I.d&MZu,s.MZ
        : s.EZ ? I.d&EZu,s.EZ
        : s.WZ ? I.d&WZu,s.WZ
        : s.EC ? I.d&ECu,s.EC
        : s.Elvis ? I.d&Elvisu,s.Elvis
        : die 'hash: '.wdump($s);
    
    # time impersonator
    n AZu =>''=>{s=><<''},{l=>'Motion/oseverato'}
        die 'amany' if keys %$s > 1;
        my ($cv,$ac) = %$s;
        my ($AA,$CC,$cov) = @$ac;
        my $aa = $AA?"AAcv=AA.cv":"NoAA";
        $AA ||= $A; # spawning cone thing
        I.d&n,$AA,$CC,$G,$T;
        $A = $AA;
        # see I.ex, changes A.cv = $vb to avoid A.t fulfilling exited time
        if (A.cv > $cv) {
            #sayre "Double comback A.cv > $cv: CC.t CC.y.cv ";
            #return T.not = 1;
        }
        A.cv = $cov || $cv;
        $T->{$_} = A.T->{$_} for keys %{A.T||{}};
        I.d&An;
        T.whack = 1;
    
    n MZu =>''=>{s=><<''}
        my $uM = sub {
            my ($k,$v) = @_;
            if (defined $v && $v eq '0') {
                delete A.fl->{$k}
            }
            else {
                A.fl->{$k} = $v || 1;
            }
        };
        ref $s eq 'HASH' ?
            map{ $uM->($_,$s->{$_}) } keys %$s
        :   map{
                /^(.+?)(?::(.+))?$/ || die;
                $uM->($1,$2);
            } split /\s+/, $s;
        T.not = 1;
    
    # without our humm, straight to M
    # this is kind of like going through el1389, so many spires to pi on
    # the calls to In want to be IId
    n EZu =>''=>{s=><<''},{l=>'Motion'}
        my $Z = I.d&iZu,$s;
        warn "About EZ";
        for my $k (sort keys %$Z) {
            my $N = $Z->{$k};
            $N = [ map { [$_] } split "\n",$N ] if !ref $N;
            Rw In $M:T.oM $N;
        }
        T.not = 1;
    
    # with our humm
    n WZu =>''=>{s=><<''},{l=>'Motion'}
        my $Z = I.d&iZu,$s;
        warn "About WZ";
        for my $k (sort keys %$Z) {
            my $s = $Z->{$k};
            die wdump $s if ref $s ne 'ARRAY';
            unshift @{A.N}, @$s;
        }
        T.not = 1;
    
    n ECu =>''=>{s=><<''},{l=>'Motion'}
        # extend C on the way in to another dome, magnetised into our M
        # probably for collapsing roooves...
        # dumber than sc decompresphere & playing out
        # (is mailing itself further instructions, intro c, further lines)
        # an In persona, joining our M
        # push to dome
        # that must in  A
        ref $s eq 'ARRAY' || die;
        my ($N,$c) = @$s;
        # take 4s v             add 3s v         next 2 
        $N = [{MZ=>A.fl}, {MZ=>{'3 doex'=>$c}}, @$N];
        # and In could feel our light cone
        Rw In $J:A.J $M:T.oM $N;
        # ^but instead push to A.N and A.No, the sister strand Whare Y Whare
        # and A walks through t&Y, d&Whare(6)
        # turns via n&ACGT
        # the time beams mapped... a W concat couldol
        T.not = 1;
     
    # theses, pulling bits
    n iZu =>''=>{s=><<''}
        my $way = $s =~ s/^\/// ? 'fund' : 'muck';
        my $Z = Rw $way - $p:s $dclone=1;
    

