r2j: | # interpreter of buzzed puit partiscules r -> j.[cv,t,style]
    my $j;
    my $sing;
    if (J.tt) {
        $sing = 'J_tt';
        (j.cv,j.t,j.style) = $r =~ /^(.*?)\t(.*)\t(.*?)$/;
    }
    else {
        (j.t,j.style,j.cv) = $r =~ /^(.+?)(?:%(.+))?\s+(.+?)$/;
    }
    defined j.cv || die "$sing no $r    ".ki $j;
    j.s = ar.J.bb->{$r} if ar.J;
    j.nos = 1 if ar.J && !exists ar.J.bb->{$r};
    $j;
Ajr: | # shed A.jr bb io, aimed for J and cv,t (of C?) aimed at J and cv,t    sends style => $v
      sub {
          my ($s,$v,$d) = @_;
          my $isv = @_ >= 2;
          my $isd = @_ >= 3;
          my $t = exists ar.t ? ar.t : ar.C.t;
          my $cv = exists ar.cv ? ar.cv : ar.C.y.cv;
          my $r;
          if (J.tt) {
              $r = $cv."\t".$t."\t".$s;
          }
          else {
              $s = '%'.$s if $s;
              $r = $t.$s."\t".$cv;
          }
          if ($isd) {
              sayre "delbbl $r  $d   J.name" for 1..5;
              Rw delbbl $J $l:t;
          }
          defined $v ? 
              saybl "J.name chuck $r     $v  <--  ".J.bb->{$r}
            : saygr "J.name read $r"
              if J.V;
          !$isv ?
            !exists J.bb->{$r} ? () : J.bb->{$r}
          : do {
              J.bz->($r, $v);
              sub { delete J.bb->{$r} } 
          };
      };
Nbz: | # receiver of buzzed out planes of N (C)   # peeler futuro, forte arbiter # suJ cloned  # other is A.jr
    J.tt = 1;
    J.bz = sub { # the cv=>t=>style r
       my $m = [@_];
       die "not 2 @$m" if @$m != 2;
       my $j={};
       while (@$m) {
           my ($r, $v) = (shift @$m, shift @$m);
           if ($r =~ /^%(\S+)/) {
               j.style = $1;
           }
           else {
               # to ivertake in here
               $j = Rw r2j $r $J;
           }
           defined j.cv || die "NOSEYV: j.cv".wdump[$j,[@_],[$r, $v]];
           
           j.r = join "\t", j.cv, j.t, j.style;
           j.s = $v;
           my @Js = $J;
           push @Js, values %{J.phy} if J.phy;
           for my $jj (@Js) {
               jj.bb->{j.r} = j.s;
               push @{jj.ord}, {%$j} if jj.ord;
               jj.tim->{j.r} = hitime() if jj.tim;
               jj.wtf->{j.r} = $F[0] if jj.wtf;
               jj.ap->($j) if jj.ap; # <<<
           }
      }
    };
    $J
S/ghostchanges: |
    unless ($m =~ /\/k\//) {
        Rw loD;
        sayyl "loded";
        Rw recoded_init;
    }
S/wayup: |
       -f $m || die;
       delete G.drop; 
       $G->wayup($m);
       Rw loD;
       Rw recoded_init;
ratio: |
    my $ratio = $o / ($t||1);
    0.01 * int(100*$ratio);
    

