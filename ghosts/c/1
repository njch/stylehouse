
MourmaZ: | # notes
   u ashtray=>,'c ha' 
   n fdlwk=>''=>{s=><<''}
       # and from Indi
            # and whenever
            # then the things todo
            # lots ||nexts
            # elabourate C, seeming to chew
            # we want to throw our next II etc
            # transmit A,C via AZ, which and A.cv via AZ and A.II)
       in wayves it travels
       I hoist by z
       move the things out into args,name,id in I from already
       code leeching out - chov into index,
         and the brain indexes the bunch of codes run with their I...
       so I is vectored done stuff (u, che acquis)
       thatd be hard to not have at this point
       unmeni the zapping into an I is the finality...
       u bein done...
       the I gets wrenched out but it is all G via J stuff... apply 
       divide the stuff up into K/cv/t limbs
       and apply the K = diffre/OSC/ACT/OMP
       compine blobs, can want to interdesign each other if travel points further than routable
       then break things off as case...
       just like things are pooled
       the over the room code forming way selector outputs more stuff
       unified and interpreted as code to way 
       everything happens as an z Elvis, even if not in El
       so In A can acquire its wires
       and splat from A couplings
   
   n zfold=>''=>{s=><<''}
       wired up some hypnocodes from other J.A.I (& u) into G.T.$W
       then in each there each W is supposedly W overlay (way)
       and theres I/1/n,An->A.t auxi, which shall wind us up to 1
       but its a bundle of wires here, about 8
       if top level hashes are all same skji/recycle, some others uCon is trusted
       G.T is a switching table
       together and wind up to 1...
       collasp J.A.IIII and J.A.I, where [$(pathfrom$A)+] or Kcvt hashbush
       the tree that changes hashes leading into its diff
       compiling II, the Kcvt single pile
       which code proteins on I with Mobile, tiny ex A.cv->1 starter
       to be stitched K/cv/t 
        # see if this wander I...
        # dangling selfs: spiral III from W creaturey
        # there's W managed for us, create the tiniest consume starter:
        # this is the usual spiral group overlay sphere arbiter
        #Rw SNtl $I;
        # n - take A
        # An - furbish A.t
        # A.t - crawl (in general) to 1, which Essen

   n A_t=>''=>{s=><<''}
        # is iunterrr that this collapses ongoingly...
        # a stream under a bridge
        # lets get sa spiral overlayer for doing K/cv/t groupi
        # Kceive it... K is a C on the wall/ground
        # much mergey extendo rubble, 
        # and $={%$} the hashes along the path to what we change, cluing
        # the tearifuing part is 
        # the conscious operator of the change could be a part of the bundle of wires
        # so I and III want to be watched, spiral planed in
        # if the ref is the same we could say its the same, travel entropy, horse aim
        # it likes to travel so it likes to travel travel, spes. travelled travel
        # its the way we thing about whatever else is going on
        # so it is data injection agent
        # that one awareness is part of the budle am wires
        # this feeding on I or III
        .
        # should stick In in first and M it? 
        # kind of motion that wants to be unsure in the wild
        # some talking to self - how to C over exactly
        # the object could be live
        # uis a nested wave - falling ]]]]]]]
        # allow much manufold
        # knot this not this:
        # this form: NextWorm=>$C=>$J (C/J swappy)
        # and some=>[$C,pi=>3]  should xotogether
        #if (A.J.name eq 'qq' || A.J.most.J eq A.J) {
        
        # if Ting
    
    tesc:
        # av,c = 0.av,c   zero pointilise
        # Av = av || A.cv
        # sync II
        # wind to cv until other needs
        # true/false time function that 1||0 if effecto
        # reentrant select tree idea, better something else
        
        # the ov=8 temporality is good
        # shoved off ov paths like y.U T crunch from tips to bases,
        # the shove danglindex so for it is just y specs
        # so Amo->{A.C} = An  finds y.U pointaboves
        # any ref y.? Amo knows should Tlapse things out
        # Tlapse wants to finish innermosts,
        # its force directed biograph
        # imports in/on above/after
        # Amo.T.o.$C.U.$U   means do C before U because U
        # Amo.T.e.$U.U.$C   means do U after C becuase U
        # which are entangled forwards-backwards
        # so the above can ov=8 Z itself when others y.U it
        # these coney spines of language subjectals
        # how to sharpen them (verate indexes)
        # and throw them (pluggin S in for lang acquisition from border, surf, pets roll)
        #  osc art inter
        #  like 9.c.u = musthave u things for 9
        #  .t is thing it is     .c.v may version     .sc.u = {K/cv/t}
        # 
        # the Teo is like Pile, may seniloop due to surfaceyness
        # Teo interrupts Cs in the throat of a thing
        
        # things dropping out the osc art wou
        # getting their reinput sentience in a sentence
        # sc.u = 'asthis' is an outgoing tow clue/versioning being on a thing
        # so then in osc u usedtobe ^ 
        # becomes .u={Kcvt}
        # the being on a thing, default for u would Kcvt
        # sc.u = {}
        # a pi is a versioning being
        # a climbing of a mountain, a maps for expeditions past & future
        # the joined by this space and the fabricated by semi pilins
        # getting pi to pile in just right, for requests
        # could see just t=>cv mood lighting compressions for data structure nativity
        #  exoods something the C must respond to (cachily), an R connecto
        # so things can load up each others c
        # would be pi balancing ventricles to implant,
        # tycsc matched mood lighting/etc
        # t most for bal & lum on things, they are frequency response curves
        # for sculpting space
        # the drop on it from here
        # to iunject T.b for subsequence...
        # should have a lifespan or lightcone relevativity
        # vase -pi model, the ring chaser levels bets on relevance
        # T.b.stuff, to be houisted out of n, etc
        # travel R making intel between C in this vector may wake up recipients
        # also theres a look into this mind ambiently available as pi
        # but basically can implant anything
        
        
        #c  a hive of ifs bush on as a pi proviTing for some C the littlest tunings
        
                # Teo m/mo traction,
                # also Travel how pi creates forms to rip up constantly,
                # break through to new pi or acum pi
                # is a base twisted from source
                # s/^(\w+)\$ /my \$$1 =\nn /;
                # first grab layer should be done by the next functions c.som=$it
                # the thing to do may emerge, need 4d cradling
                # how virtamins fly in T, coopt on A.mo,middlemost(J)
                # 
                # see if each thing is slightly what we want a proceed cv
                # for things to be in piles in two strands,

        
        # we'll make a spiral map of these too ^ taps how things are acting
        # most envirgorator
        # the probably S, person,(cv),t.. usual incrementor
        # spec chain breakup by nonref personin to next A
        
        # $s will be coned to C, which houses C ups at the ends of update ventures
        # $t in S too should emit unto C caught things
        # only way to build is to follow in parallel, curve
        # 
        # Carbon, that receive   R howtos, shared modes    S atya
        #  S things theyify, open wide
        #   R reads Cemes from s.4.$K, they would eg. for:S,fov:u, pings S aparts catchupy morethey
        #    - some subtle R may
        #  C closes in on dealio, transparent to thingleave
        # they is A.s ing iNner
        # want streamier situp for T.Z
        # v of C is made A.N, {A} where A.y not A, theyify
        # the C A.N=[$s] w`
        
    # s=A, protocol & data
    # to C an A,
    # As loop for an alien light cone update, using the S (second mode)
    # time to travel is up to u(S)
    # make a timey comportment of devotion

    # all this spushes out
    # lot of echoey comments like Some 9 = Oth 3, Some ...
    #  form travel loosities, travel is basically extra 3ing or so stuff
    #  pretends to be in vector, linkaged Cs hold nodes
    
    # Time & Grates
    # time is a grate focuser
    # A cease to be in unity and now has competing parts
    # sc from such field should fall away, could be m later
    # meaning of life density very meaningful
    # why is it just a thickl
    # signifies nothingness. texture.
    # many spiral jobs, elvis, mux, overs, repl
        # - bats types between cones, behalfitor R
        # together onto emerges from C>R>S
Eel: | # most wild (furthest from Wild, goes in circle)
    n Servo
    n SevWo
    n Yosc
    n Timing
    
    n SlideEa
    n C
    n Spaci
    n KnowTime
Again: |
    n Being
    n Arms
Arms: | # plant bubble
    #n Spiur
    # tree start ops
    n Bubble
    # proc usive
    
    n Anthro
    n Augen
    # tree sync ops
    
Being: | # cones with N, J # input coding, severab, sectory compressions
    u allacgts
    
    # stamp C there ( or read sc style 
    g:
        ($s,@Me) = ref $s eq 'SCALAR' ? ($$s,@Me) : (6,$s,@Me);
        # ^ \4 for sublatio, cs {set}/{suck}<-'J'
        G&zs,g=>$s,@Me
    
    # n=introversio, each oif these loaf out around a different basic angle
    zs:
        my ($n,$cs,$t,$cv) = (@Me);
        $t = C.t if !defined $t;
        $cv = C.y.cv if !defined $cv;
        # cs is stalk about how to move sc in/out
        # one string as one value if pos
        my $c = A.c.>$s ||= {};
        my $sc = A.sc.>$s ||= {};
        $cs = {$cs=>1} if !ref $cs && defined $cs;
        for ($t,$cv) {
            $sc = sc.K.>$_ ||= $n >= 5 ? return : {};
            $c = c.K.>$_ ||= {};
            # plucks t if 2
        }
        # c.L++ if change within
        if ($n == 6) {
            my $v = {map{ $_=>$sc.>$_ } keys $cs};
            my ($o) = keys %$cs if 1 == keys %$cs;
            return $v->{$o} if $o;
            return $v;
        }
        else {
            die "Handool $n";
            G&st,$A,$s=>{s=>$C,mk=>[$t,$cv]};
            
            # 1 start is
            # 2 start is or uniq t or above ~ things
            # ^ complete t/y/c/sc
            # 3 sync sc
            # 4 sync sc and name(8)s all z
            # 5 lum/bal
            # 6 retrieval from branches
            # 7 compression (into time) 
            #   - writes up unless up is over whole/Cmudge join minded
            # start over - bunch zs layers
            # carry ray around, seal bits
        }
        # immediate upspiral m-om unless blocked by later sc/vote
    
    # An grows N ordered C in as an An for a.mo
    # stmk marks 
    stmk:
        my $R = C.c.R;
        # when some splits from A.mo=A  (lowovsorts An)
        # or as al possibles also al lowcvs A.ovs 
        # R lives in mo.c.$t, c differ all A
        die wdump 3, $C;
        if (my $n = C.c.mk) {
            C.c.nos = 1;
            C.c.notw = 1;
            n.y eq $n || die "An so A";
            
            my $id = C.c.Ant ? n.t : "$n";
            
            my $ov = n.ov || 0;
            
            my $tw = C.sc.tw = R.sc.tw || {};
            my $new = !exists $tw->{$id};
            $tw->{$id} = $n;
            
            my $de = C.sc.N = R.sc.N || [];
            push $de, $n if $new;
            
            my $tt = C.sc.tt = R.sc.tt || {};
            my $old = $tt->{$id};
            $tt->{$id} = $ov;
            
            my $sl = C.sc.sl = R.sc.sl || [];
            my $tv = C.sc.tv = R.sc.tv || {};
            my $done;
            if (defined $old && $old ne $ov) {
                my $o = $tv->{$old};
                delete $o->{$id};
                if (!keys %$o) {
                    my $done;
                    for (0..6) {
                        $old eq $sl->[$_] || next;
                        splice @$sl, $_, 1;
                        $done = $_;
                        last;
                    }
                    if (!defined $done) {
                        @$sl = sort keys %$tv;
                        saybl "n.t n.cv n.ov @@ C.t sl rm Resorted to rm $old, s.t   @$sl";
                    }
                }
            }
            if (!defined $old || $old ne $ov) {
                my $o = $tv->{$ov} ||= {};
                my $vnew = !keys %$o;
                $o->{$id} = $n;
                if ($vnew) {
                    # must insert o
                    my $i = 0;
                    $i++ until !@$sl || !exists $sl->[$i] || $sl->[$i] >= $ov;
                    @$sl && $sl->[$i] == $ov && die "Thought $i would new $ov ".wdump 3, $sl;
                    splice @$sl, $i, 0, ($ov);
                    sayre "n.t n.cv n.ov @@ C.t sl $i" if $i != 0 && $i != 1;
                }
            }
            # sc.tw.$id = sc.tv.$ov.$id = $n
            # sc.sl[0] = lowest $ov, etc
        }
Dwig: | # open up wormhole asciis
    u allvse
    n \'of:De'
    J.VV.N = 1;
    s 3:
        C.c.sep = ' ';
        C.sc.fs = 30;
    g 7:
        sayyl "Afmoa";
        saybl wdump 3, $C;
        my $put = zs&g,7;
        say "lo: ".wdump 3, $put;
Esuy: |
    u urw
    
    m s=>-pre=>wdump 4, s.II.De;
    m s=>-pre=>wdump(4, s.M)=>'%hs:347,fs:7';
X: |
    u Being
    u Augen
    u Bubble
    u Dwig
    my $o = $A;
    my $A =
    nothing:
        else
    
    my $z = G&S,De=>[te=>{g=>'do',s=>"Seo"}];
    
    
    $G::KA->{"$A"} = $A = $z; 
    
    #my $s = {se=>3,foiu=>5,ro=>3};
    #Mn($_=>''=>\$s->{$_}) for sort keys %$s;
    
    # then M n sees whe yA and loops back creativity to
    #say "SA for M: ".wdump 3,[grep /\w/, 
    #sort keys %{z.al.A.I}];
    
    
    
    my @e = g&J;
    $A = $o;
    n Esuy=>W=>\$z
    n s=>[-pre=>3]=> "Wep ".wdump 4, ["woop"  ]
    
Life: |
    u allvse
    n \'of:M'
    
    ycv 12: %def
        C.y.cv = G&ecv,$cv||0.1;
    pi 321:
        undef $pi if $pi eq '1';
        C.sc.pi = $pi||'guess';
        C.c.J = 'pi';
        C.c.p = A.J;
    W 321:
        C.c.J = $W;
        C.c.p = A.J.y.s;
    J 322:
        my $J = G&g,'J';
        C.c.J = C.sc.J = $J if $J;
    
Anthro: | # open up wormhole asciis
    u allvse
    n \'of:u'
    
    cs 2:
        C.c.sep = ' ';
    sep 21:
        my @b = map{{c=>{s=>$_}}} split $sep, C.c.s;
        T.Z.2 = G&ri,[@b];
        T.Z.9 = 2; # changes to 6 root.cv = V.cvs + 0.1 once 0.6
        # A must hide slither per J, u shines through
    cs 22:
        C.c.u = C.c.s;
    u 23:
        C.c.W = C.c.u;
        A.Iso.M = 1;
    
    u 7:
        # name bring
Alit: |
    u allvse
    n \'of:umun'
    
    n cs =>2,<<'','%code:C'
        ref $s eq 'HASH' || die "notos";
    
    n slipout=>3,<<''
        my $Ii = join " + ", map{"_.t:_.c.s"} @C;
        $Ii eq II.Ii && return;
         
    
    n spII=>'',<<''
        if (my $TI = G.TT->{$Ii}) {
            %$II = %$TI;
            TI.Ii ne $Ii || die "Hiked GTT TI.Ii ne $Ii";
            return G.protV && sayyl "Hiked GTT $Ii";
        }
        else {
            G.TT->{$Ii} = $II;
        }
        II.Ii = $Ii;
        
        my $N = [@C];
        my $s = {};
        my $say = 
        Rw spIII $A $II $N K/cv/t $s
    
    n spIII =>3,<<''
        my $ooI = ar.ooI;
        $ooI ||= II.ooI ||= {};
        ooI.mo ||= $ooI;
        delete ooI.st if ooI.mo eq $ooI;
        my $m = [@{ar.m}];
        @$m = split '/', $m->[0] if @$m == 1;
        my $n = shift @$m;
        $n||die "Non? $n @$m ooI.ins";
        @$N||die"noNsp";

        my $Ii = join " + ", map{"_.t:_.c.s"} @$N;
        return "ooI.ins stabilised" if $Ii eq ooI.Ii;
        ooI.Ii = $Ii;

        my $E = {%$II};
        %$II = ();
    
    # for N
    n tw =>4,<<'','%v:N,ha:sh'
        C.c.tw = {map{$_=>1} map{ keys %{_.c.s} } @$N};
    
    # ^ wants of variantsl 
    # can comission stillness
    # we all look like each other's Jesuses
    # must in N order move in changed hashes
    # but our awareness of
    n tw =>5,<<''
        for my $K (sort keys %$tw) {
            next if $K eq 'Ii' || $K eq 'ooI';
            if (@$m) {
                my $III = $II->{$K} = $E->{$K} ||= {};
                my $oI = ooI.K->{$K} ||= {mo=>ooI.mo};
                my $S = $s->{$K} ||= {};
                # ^ thse particles
                oI.ins = (ooI.ins&&"ooI.ins/")."$K";
                my $N = [
                    map { {t=>_.t,c=>{s=>_.c.s->{$K}}} }
                    grep {exists _.c.s->{$K}}
                    @$N
                ];
                my $d = ar.d + 1;
                push @say,
                Rw spIII $A $II:III $ooI:oI $N $m $d $s:S;
            }z
            else {
                my @C = grep {exists _.c.s->{$K}} @$N;
                # say "manyC for $K" if @C > 1;
                for (@C) {
                    $s->{$K} =
                    ooI.mo.st->{ooI.ins}->{_.t}->{$K} =
                        $II->{$K} = _.c.s->{$K};
                } 

            }
        }
        delete ooI.K->{$_} for grep {!$tw->{$_}} keys %{ooI.K};

        if ($ooI eq ooI.mo) {
            II.Ii = $Ii;
            II.ooI = $ooI;
        }
        join "\n",grep{defined}@say;

        
        
        
        
        
    #
Aim: |
    
    u Again
    
    #u urw
    # v to: do$ {} # for An spacehash lex $do
    my ($A) =
    do:
        t
    for ('Again') {
        G.sus = $_;
        my $C = G.ui->{$_} ||= {t=>$_};
        C.sc.u = G.T.A->{$_};
    }
    my $o = G&At,In=>2,[Steve=>{s=>"washere"}];
    
    # n Bla=>\$o should v
    n Bla=>W=>{s=>$o}
    
Or: |
    G&wraf,'proc/start',"$$: perl got 4 Be";
    
Dlam: |
    sayyl "Sadmi Hereop $$";
    Rw iolam;
    sayyl "Sadmi Hereop $$";
    my $cb = sub { say "Dlam"; exit };
    Rw timer $d=2 $cb;
    u urw
    
    n Tarp
    dis 3: %fs:222,hs:3293
        SSssssssSSSSSSSSSSssssssSSSSSSSSsssss
iolam: |
    G.cv ||= 3;
    G.pid ||= $$;
    my $proc = 'proc';
    my $n = "$proc/G.cv";
    `mkdir $n` if !-d $n;
    my $pid = $$;
    my $safe = sub { die unless $_[0]=~/^proc/\d+\.\w+$/; shift };
    my $hand;
    if (!-t STDOUT) {
        for (qw'in out err') {
            my $k = $_;
            my @o = grep{-f"$_/G.pid\.$k"}$proc,$n;
            @o||next;
            @o<=1||die"onso@o";
            
            my $wh = /in/ ? \*STDIN : /out/ ? \*STDOUT
                : /err/ ? \*STDERR : die'whatch';
            my $i = /in/ ? '<' : '>';
            close($wh) || die "clope $_  @o: $!";
            
            # origin moves into cv also
            my $mv = G.pid == $$;
            G.pid = $$;
            my $now = $safe->("$n/G.pid\.$k");
            $mv ? map{`mv $_ $now`} grep $safe, @o
                : `touch $now`;
            
            open($wh,$i,$now) || die "bni $now: $!";
        }
    }
    die "Is G.t $net";
    
Bla: |
    u urw
    J.VV.N = 1;
    
    delete G.forked;
    # wait for in
    #J.fti = 2;
    #Rw Sl;
    
    # Mn s.t -SeeaboutA $s
    Mn(s.t=>-SeeaboutA=>\$s);
    
    
    #
BeiC: |
    u allt
    n \'of:A'
    # how to expand culture, bal lum to glory
    # have R code, can be
    # sc.t looking for Ct
    J.VV.N = 1;
    
    y 2: %tis
        say "eq a! : ";
    
    haseeC 2: %tis
        say "eq a! : ";
    
    haseey 2: %tis
        say "eq a! : ";
    
    n deem =>''=>'%s:dteas,flop','%d:3,ego,folo:so'


    #
pi/SeeaboutA: |
    u Again
    u BeiC
    #
    se: %fs:13,hs:2784
        See about a
    
    # off$ wd =>-pre=>{s=>wdump 1, $s}
    # off if depth > 3, etc somewhere
    J.A.d > 3 &&
    return
        n wd =>-pre=>wdump 1, $s
    
    # inspectro and
    $s = $A = 
    nse 12:
        withic
    
    Mn($_=>''=>\$s->{$_}) for sort keys %$s;
    
    my $z = G&S,A=>$M;
    # then M n sees whe yA and loops back creativity to
    say "SA for M: ".wdump 3,z.al.A.N;
    
    return;
    my $o = $s;
    my $z = o.1;
    
    # person join where persons can join
    #my $ai;
    #$ai->{$_} = 1 for map { keys %{_.c.aim} } values %{z.al};
    #delete ai.I;
    #say wdump4, [map {[ $_=>$kt->{$_} ]} grep {$ai->{$_}} sort keys %$kt];
    
    # ordered whathave M
    my $kt = z.R.II.sc.uz.II;
    say wdump 5, [ map{[_.t=>_.M]} map{z.al->{$_}} @{z.allk} ];
    
pi/iC: |
    n k=>1=>{s=>$_},'%hs:384,decor' for C.sc.k;
    n json =2=>\ki $C;
    
Swee: | # push commands
    u allvse
    n \'of:C'
    
    A 23:
        
    
    n via => 12=><<''
        C.sc.apart ||= [ map {
            [ map {
                my $c;
                /^([yc]|sc)(.+)$/;
                c.nk = $1 || $_;
                c.gk = $2 if $2;
                {c=>$c}
            } split ' ', $_ ]
        } C.c.ug ];
        C.sc.sck ||= C.t;
    
    n '','','%of:C'
    n via => 12=><<''
    
Bubble: | # upto st way
    u allacgts
    
    usage:
        # make C & feed atom
        # Ay 
    ri:
        my $z = G&At,In=>2,[@Me];
        G&$s,$z;
    C:
        my $z = G&At,$s,@Me;
        sayyl "Extract Cs from A: ". wdump 3, $s;
        @{z.M}
    At:
        $s = G&Aw,$s,@Me;
        G&o,$s;
        $s;
    # more plays on words than content
    # persons&things oscillation, last one to be mo
    # A tossed in with get a new mind wrapped around it
    wdef:
        my $per = {};
        my @z; # bits of mind
        my @p = (@Me);
        my @s;
        while (@p) {
            my $e = shift @p;
            $e || last;
            ref $e || push(@s, $e) && next;
            push @s, $s if !@s; # default person
            push @z, G&Aw,@s,$e;
            @s = ();
        }
        @z;
    Aw:
        my $z = ref $s ? $s : do { unshift @Me, $s; G&atom };
        my @to = qw't cv ov';
        while (@Me && !ref $Me[0]) {
            my $s = shift @Me;
            my $t = shift @to;
            $t || die "No t $s";
            $s = G&ecv,$s if $t eq 'cv';
            $z->{$t} = $s;
        }
        z.N = \@Me;
        $z
    ecv:
        $s /= 10 while $s >= 1 || $s <= -1;
        $s
    acv:
        ($s =~ /^.*?([1-9])/)[0]
    atom:
        my $z = {A=>$A};
        z.om = A.om || $A; # last most I together - Any can upgrade itself network
        # z.m is the bunch of persons person
        # z.mo is the way out of the loop, acquired on in
        # z.y self vis non C hash
        z.y = $z;
        $z;

    # attain wholifier
    # fairly trans parent A.II al readier
    # G&At,Vev=>3,[C] # shells out new Vev A->Cs until 3
    # the time difference, eg for 
    # 
    n o =>'',<<''
        s.1 ||= G&i,$s;
        ($s,$A,$C,$G,$T) = ($A,$s,s.C,s.G||$G,s.T||$T);
        #G&tex,$s;
        $A
    
    # find unities by name
    # forever spiral langality beyond the stick pouch mechanics
    n ui =>'',<<''
        my @d = grep {ref eq 'ARRAY'} @Me;
        my $ts = join ' +_ ', map {join ' + ', @$_} @d;
        if (my $D = G.ui->{$ts}) {
            return $D
        }
        G&C,$s,@Me;
    
    # rest to invigorate over the top
    # the u7 2d into produces the origins structure, index can be applied anywhere
    # u7 skinniest (made), talks about the origin its from, patches scs
    # wants to do width first qq stretches, this stuff finally t-ugged complete
    # host stat pops, 
    n i =>'',<<''
        # s=A
        # get spiral to one, rest is a qq J 9 s=desc, z=u7[] u=u8{}
        s.u = G.sus;
        @Me = G&ui,u=>8,[s.u];
        # person u creates sc.u, S has v=u spiral opener
        # which Zs things into R,
        #  but after they're there & 1 (or skippy insert at if >) do now if ov
        #  returns the Cs 
        
        # each R C may %for:N,vis:u, going to A.mo.N where sc.u
        # and it sets itself up for going onto s
        
        # pointers to stream S, many toplevel
        # weave itself a kind and connect up with this
        #  back and forth curse, slip in/out space play
        # attach rambling try this-er
        # and all con screen slinked listens
        
        # adapts apart maps
        my $mup = [u=>{
            ug => 'scof ycv t',
            via => 'spir', # selects N sc.$C.t, spirals ug into R 
            nines => 1,
        }];
        
        my $t = s.4.u ||= G&tC,$mup;
        my $o = G&S,$s,C=>[$s],R=>$t,[@Me];
        $o;
Augen: |
    u allacgts
    
    # make an al loop-t, many cones together  #
    # default S, which unpacks self data coils
    # which loops out time to others as they spiral things in to texiter
    # tex figure of each ones om, goes off and vamps them up if s.u or so
    # u being c and sc opposites, an into I recipe or contents
    # create a new A.mo (loop gatherer) with same A.om (I implier)
    S:
        unshift @Me, $s if !ref $s;
        # s is theg, z is the m, all is mo, then Ans <-> mos
        # may be no S if S,A=>$M
        my @z = reverse G&wdef,'S',@Me;
        my $z = $z[0];
        G&st,$z,al=>{tug=>\@z,mks=>'m'};
        # s.m,mo,n share R
        G&mode,$z;
        $z
    
    mode:
        @Me = G&thro,$s,@Me until G&away,$s,\@Me,@Me
    
    # lines up .c oscs;
    # make my $sc st ii: %sc ii s:i lk=usto
    away:
        my $Me = shift @Me;
        s.om || die wdump 3,["No om: ",$s];
        # steal an I
        s.om.II = s.om.J.A.II || die "NojAII ".ki s.om;
        # s.R.II spiral + cv index
        my $i = G&st,$s,II=>{s=>s.om,in=>'K,cv,t',to=>'cv,K,t'};
        my $ii = G&st,$s,ii=>{s=>$i,lk=>'usto'};
        my $sc = ii.c.R.sc;
        
        # ties itselves in knots to avoid foaming
        # interest in dispatching to A where m not us
        # that this C is kinda lying around clues and the seed itself
        # s.c.ii.c.R.sc is junk iterator
        
        s.c.m ||= 1 if s.m && s.m eq $s;
        s.c.mo ||= 1 if s.mo && s.mo eq $s;
        
        # figure for other al loop, cv wide
        # is a travel
        if (s.c.m) {
            _.I = $I for values %{s.al};
            
            my ($lo) = s.c.alov || do {
                reverse
                map { G&st,$s,alov=>{Ant=>$_} }
                map { s.al->{$_} }
                    @{s.allk};
            };
            my $low = lo.sc.sl->[0];
            my $o = lo.sc.tv->{$low} || die "no tv $low";
            my $wan;
            for (@{s.allk}) {
                $wan = $o->{$_} || next;
                last;
            }
            $wan || die "no $low";
            #sayre "sm  s.t going to wan.t  was  @{lo.sc.sl}[0..4]";
            
            if ($wan) {
                undef $wan if $wan eq $s;
            }
            if ($wan) {
                sayyl "s.t s.cv - s.ov ! want wan.t wan.cv - wan.ov";
                G&mode,$wan,$_ for "from s.t s.cv s.ov to wan.t $low";
                return 0;
            }
        }
        
        
        if (s.m && s.m ne $s) {
            my $lo = s.m.c.alov || die;
            my $low = lo.sc.sl->[0];
            my $tv = lo.sc.tv->{$low};
            if (s.ov > $low && $tv->{s.t} ne $s) {
                #say "mreturn s.t s.talk at s.cv s.ov  vs $low  "
                #    .join" ", sort keys %{$tv};
                return 1;
            }
            #say "s.t s.talk \t\t  s.ov > $low" if s.ov > $low;
            #return 1 if A.ov != 
        }
        
        # sc is ii order & state by lk holds it, adjusted to next > s.cv all the time
        # A.cv sync cv index lk
        # things in 8 want to attract corus - pond density into it, wait for levels, this space out
        # A things can project above 0.9 onto the through-microfilm bunch of stuff that's you
        # distributed computation
        # once in its a huge bundle of dont fall out (mind) 
        my $i = sc.it || 0;
        if (sc.lk->[$i] ne s.cv) {
            $i++ while exists sc.lk->[$i+1] && sc.lk->[$i+1] < s.cv;
            $i-- while $i > 0 && sc.lk->[$i] > s.cv;
        }
        if (sc.lk->[$i] <= s.cv) {
            $i++;
        }
        my ($ta) = s.cv =~ /^0?(.+)$/;
        if (!exists sc.lk->[$i]) {
            sayyl "Done $i  - s.t $ta s.ov";
            return 1;
        }
        sc.it = $i;
        
        s.c.osc = $sc; # unlk.$ov = $o
        s.c.ov = sc.lk->[$i];
        s.c.aim ||= {map{$_=>1}I=>s.t};
        
        # stackmess
        $G::KA->{"$s"} = $s;
        @$Me = ("To $ta s.c.ov");
        # somewhere (C) a by yU folength N inputty (Teo)
        0
    #c thro
    thro:
        return sayre "s.t s.talk  s.cv - s.ov  no re s.c.ov"
            if s.mo ne $s && s.ov > s.c.ov;
        if (!s.mo && s.N && s.cv >= 0.1) {
            s.c.mo = 2; # back to 1 for N repercolate
            # An/actomise travel relateds: person timedigits* 'N'
            # N is like yU or more a u or a way, isle of Pile
            # then refs to work from in that, N <> grabs source refs C.y.T, fly itself
            my @C = G&Ze,$s,1,N=>s.N;
            _.y.A.c.n = 1 for @C;
        }
        
        #saybl "Thro s.t s.cv-s.ov    - s.c.ov    s.talk  ";
        T.conty++ > 840 && sayre("CONTYREX") && exit;
        
        if (s.c.mo == 2) {
            # switch to children forever
            # give osc/ov
            # many persons throat mAny persons per cv
            # for moov
            for my $n (@{s.c.N.sc.N||die"No NscN"}) {
                next if n.ov > s.c.ov;
                # next if s.T.e->{_.C} ...
                # pass ring
                n.c->{$_} = s.c->{$_} for grep {exists s.c->{$_}} qw'aim osc ov o';
                G&thro,$n,"n.t~s.c.o";
            }
        }
        else {
            # Personalities (of/K/code) wind of synth noise stick for sort
            my $sc = s.c.osc||die"nonoscthro";
            my $ov = s.c.ov||die"noovthro";
            my $o = s.c.o = sc.unlk->{$ov}||die"notlk$ov";
            # comp how if
            my $if = 1;
            
            say "s.t s.cv s.ov ov $ov hide?" if $ov <= s.cv;
            undef $if if s.c.aim && !grep { s.c.aim->{$_} } keys %$o;
            if ($if) {
                # noise is the ornre
                # it contributes flips
                # that feeling in your fins
                my $C = s.C ||= {};
                my $T = s.T ||= {};
                s.c.x = {};

                G&how,$s,$o;

                G&exo,$s,s.c.x;

                T.not && die "cv 0.9 and z, oseve...";
            }
            s.cv = s.c.ov;
            my $i = sc.it + 1;
            s.ov = sc.lk->[$i] || s.cv;
            my $skip;
            while (s.c.aim) {
                s.ov = sc.lk->[$i] || last;
                last if grep { s.c.aim->{$_} } keys %{sc.unlk->{s.ov}};
                s.c.ovwi ||= s.ov; # check after
                $i++;
                $skip++;
            }
            #sayyl "Wound s.t $skip   s.c.ovwi -> s.ov \t\t s.talk" if s.c.ovwi;
            delete s.c.ovwi;
            s.ov = s.cv if s.cv > s.ov;
        }
        if (s.c.n) {
            G&st,s.mo,moov=>{Ant=>$s};
        }
        if (s.c.mo) {
            # s.ov = lowest ^
            my $low = s.c.moov.sc.sl->[0];
            $low || die "s.t mo no low $low";
            s.cv = s.ov;
            s.ov = $low;
            G&st,s.m,alov=>{Ant=>$s};
            #say "mo s.t   s.cv -> $low o";
        }
        
        # returns what to say to away
        ("YTe yep s.cv s.ov");
    
    #c how of things if, makes selections & compilings
    how:
        for my $o (@Me) {
            for my $k (keys %$o) {
                my $tD = $o->{$k};
                s.c.aim && !s.c.aim->{$k} && next;
                for my $t (keys %$tD) {
                    my $D = $tD->{$t};
                    # head match
                    if (D.sc.nk && !D.sc.def) {
                        !exists $C->{D.sc.nk} && next;
                        D.sc.gk && !exists $C->{D.sc.nk}->{D.sc.gk} && next;
                    }
                    my @is = s.s;
                    if (D.sc.Ifs) {
                        die "A impli";
                        @is = G&scIfs,D.sc.Ifs;
                    }
                    !@is && next;
                    # artists get drunk with power and fall of piers
                    # usu. one receiver (Ci) and the rest scheme
                    # may up Iso personalities as sublingoes to decompress inpatterns.
                    if (D.sc.acgt) {
                        # acgt lump normal as microfilm .001
                        # film replaces if you shave A.I
                        # which should Rustle up/m local code
                        # and float random code, manifolds of effects
                        # able to present ends to each other
                        my $dont = 1 if exists s.I->{D.t};

                        $dont = 0 if $dont && s.I->{D.t."_dige"} ne D.sc.dige;

                        # need I?
                        $dont = G&robeg,$D if !$dont && D.sc.eg;

                        unless ($dont) {
                            if (!ref D.y) {
                                sayre "D.t is .y = D.y   at s.c.ov";
                                D.y = {cv=>D.y};
                            }
                            s.I->{D.t} = Rw D.t $A $C $G $T $__D:D;
                            s.I->{D.t.'_dige'} = D.sc.dige;
                            sayyl "Compile D.t   for C.t  D.y.cv ";# if D.y.cv != 0.1;
                        }
                    }
                    s.I->{D.t."_D"} = $D;
                    # this ind is all flywheel
                    # it's a kind of unity that wants to be a block of code like this
                    # most tiny ticks
                    # and c
                    s.c.x->{$k}->{$t} = \@is if D.sc.act;
                }
            }
        }
    
    #c adapt to much  mergey # extendo  rubble # do stuff # in fractions
    exo:
        for my $x (@Me) {
            for my $k (keys %$x) { # cv's K/t
                my $tD = $x->{$k};
                s.c.aim && !s.c.aim->{$k} && next;
                for my $t (keys %$tD) {
                    my $Ds = $tD->{$t};
                    my $D = s.c.o->{$k}->{$t} || die "Nohead $k $t";
                    # head match
                    my $A = $s;
                    my $C = A.C;
                    my $T = A.T;
                    for my $s (@$Ds) {
                        D.sc.acgt eq 's'||die "nonacgts".wdump $D;
                        exists A.I->{D.t}||die "acgtI D.t not up".wdump 3, [ $A, $D ];
                        
                        T.D = $D;
                        G&D.t,$s;
                        sayyl " ---- s.t  D.y.cv~D.t" if D.y.cv > 0.1;

                        # T personality slickers, T.68 x ut , 
                        # all produces a slope for how much time you've got
                        if (my $ut = T.ut) {
                            if (ut.matchTd) {
                                my $d = s.d || die "confuse";
                                d.od.s.T.q->{d.e.k} ||= $d;
                                d.od.s.T.m->{d.e.k} ||= $d
                                    unless delete T.noTd;
                            }
                            else { die"utrowhat ".wdump 2, $ut }
                        }
                        # outwave: schools of many fish (cv=ov silentnot upcv if !@is)
                        if (T.Z) {
                            die "A.t 's D.y.cv~D.t used TZ for C.y.cv~C.t ".wdump 3, T.Z;
                        }
                        if (T.oM) {
                            #say "A.t 's D.y.cv~D.t used ToM for C.y.cv~C.t ".wdump 3, T.oM;
                            push @{A.mo.M||=[]}, @{T.oM};
                        }
                        last if T.not || T.whack;
                    }
                    delete T.ut;
                    return if delete T.whack || T.not; # close & fine slow mode
                }
            }
        }
    
    #c promise 1s for oneself to do
    # make impon this other surface, whose A.am is
    Ze:
        # al/cv,ov/isle N[]
        my $r = {};
        acum $r, !ref($_)||0, $_ for @Me;
        my ($cv,$e,$etc) = @{r.1};
        my @N = @{r.0};
        die "much spec" if $etc;
        die "$cv $e $etc   e nt abc" if $e !~ /^[a-z]$/i;
        
        # trade off round here for synapse of in, that tapeysplice other grasping
        my @C = G&tC,@N;
        
        s.mo ||= $s;
        s.mo ne $s && die "Ze is mo only s.t";
        
        my @M;
        for my $C (@C) {
            my $z = {%$s};
            if (C.y && C.y eq $C) {
                say "s.t eats ,c,A C.t";
                $C = G&tC,{A=>$C};
            }
            C.t = 'S1eve' if !exists C.t;
            exists C.y && ref C.y ne 'HASH' && die "NMotah".wdump 3, $C;
            C.y.A = $z;
            C.y.cv ||= 0.0001;
            z.mo = $s;
            z.y = $z;
            z.c = {};
            z.sc = {};
            z.s = $C;
            z.C = $C;
            z.talk .= s.c.chid++.": C.y.cv~C.t";
            z.T = {};
            G&st,z.mo,$e=>{An=>$z};
            G&st,z.mo,moov=>{Ant=>$z};
            push @M, $C;
        }
        # make An for all, same .I, .R
        # the $e puts in tv for channel
        @M;
    Z:
        # s.m.al.$person attach/create for N
        # seek ^ and spawn Anlike A.N->A.Cs
        # returning Cs with the .y.A = A
        # so you y.U = etc
        # the bunch of As will catch it up after current tex
        #   (from cv pocket)
        # unless the Z.1.7 = C, ov queues 7 then from 1
        #   (ov = thing after A.cv, time to come back)
        # so An ov on leaving tex
        # hits Amo ovs.$ov.$A = $A, rm old ov, shift/resort [] ovsl
        # ovsl->[0] low/change, thats where to swim
        # Ans ovsl to Amo,
        # Amo.ov = ovsl->[0],
        # Amo ovsl to Am
        # Am ovsl->[0] chases an Amo, possibly itself
        # the coathanger dangles
        #    Arm oldov & close orphans in [] iter
        # Am on top looks for Aal.*ovsl->[0]
        # lateral thinking Aw for local network 
        unshift @Me, $s;
        my (@S) = grep {!ref $_} @Me;
        unshift @S, A.t if $S[0] !~ /\D/;
        my ($K,$cv,$ov) = @S;
        $cv ||= 0.1;
        my $s = A.t eq $K ? $A : G&fint,$K;
        # find A.m.al
        # create on A.m
        my (@N) = grep {ref $_} @Me;
        #
       
    fint:
        my $m = A.m;
        m.al->{$s}
        #Rw dow $done:s.om.II;
        #DumpFile('dtwo',i.c.uz.II); # compare al compilings
 
    # simple .$k.$t = C from Cs
    # queue a push like a n does, substrate fromity from substrate
    # A would have no c, giving itself as idea
    # some over would batchify sources on supplied s
    #  that reaches for store around history baggage selved
    #  (actuaets history)
    #  so to create indices of same t, etc
    ow:
        my $k = shift @Me;
        my $c = s.c || {};
        my $sc = s.sc || $s;
        my $d = $sc->{$k}||={};
        #my $ot = $sc->{"hst_$k"};
        #($ot,my $to) = ({},$ot) if $ot;
        my $tw = {};
        for (@Me) {
            # could t=>s out and t-<s in, jamming many t
            my $K = _.t;
            if (my $al = $tw->{$K}) {
                die "Already loded a $K ".wdump [ @Me ];
            }
            $tw->{$K} = $_;
            my $o = $d->{$K};
            $d->{$K} = $_;
            #$ot->{$K} = $o if $ot && $o ne $_;
        }
        # %$ot && send c.w, qs edge of tex
        # C riplets 
    #c prongy return difference mash, index copy
    n supe =>'',<<'' 
        my $l = shift @Me;
        $l--;
        while (@Me) {
            my $m = shift @Me;
            my @k = keys %$m;
            for my $k (@k) {
                my $v = $m->{$k};
                if ($l) {
                    my $x = $s->{$k} ||= {};
                    G&supe,$x,$l,$v;
                }
                else {
                    $s->{$k} = $v;
                }
            }
        }
    
    
    n ylo =>'',<<''
        my @o = $C;
        while (1) {
            my $o = $o[0];
            unshift @o, o.y->{$s} || last;
        }
        @o
    
    n tC =>'',<<''
        @Me = ($s,@Me);
        @Me = ([@Me]) if !ref $Me[0];
        my @o;
        push @o,
        map{_.y.cv = _.y if _.y && !ref _.y;
            _.y ||= {};
            _.c ||= {};
            _.sc ||= {};
            $_ }
        grep{defined}
        map {
            if (ref $_ eq 'ARRAY') {
                if (!ref $_->[0]) {
                    my $C;
                    (C.t,C.y,C.c,C.sc,my @r) = @$_;
                    C.c = {s=>C.c} if defined C.c && !ref C.c;
                    C.c = delete C.y if ref C.y && !C.c;
                    $C
                }
                else {
                    G&tC,@$_;
                }
            }
            elsif (ref $_ eq 'HASH') {
                _.y || _.c || _.sc || @Me || return {c=>$_};
                $_
            }
            else {
                die "par".ki$_
            }
        } shift @Me while @Me;
        wantarray ? @o :
            @o != 1 ? die "tC not 1: ".wdump(4,\@o) :
                $o[0];
            
    
    #c pre zen ting
    n st =>'',<<''
        my ($C) = G&tC,@Me;
        C.c.re ||= 1;
        
        # C may already have R, hardwiring clue
        # or an R to diff this to, already in the environment or would-be
        # the other this v becomes to lk, An...
        C.c.An ||= C.c.Ant if C.c.Ant;
        C.c.cR ||= 1 if C.c.An || C.c.lk;
        my $R = C.c.R ||= do {
            if (C.c.cR) {
                # A.c is corner on the mn stretch
                s.c->{C.t} ||= {};
            }
            else {
                s.R->{C.t} ||= {};
            }
        };
        .
        # '' looks at $s, surfs II
        # syncopate times
        C.c.in = ['',split/[ ,]/,C.c.in] if C.c.in && !ref C.c.in;
        C.c.to =     [split/[ ,]/,C.c.to] if C.c.to && !ref C.c.to;
        my $de = C.c.in->[C.c.de];
        my $re = C.c.re <= C.c.de;
        C.c.is = $de;
        C.c.is = 'C' if C.c.in && !defined $de;
        C.sc ||= {};
        
        # the only mechani, passback if awake
        my $off = sub {
            for ('usto', 'uz') {
                C.c->{$_} = R.c->{$_} if $_[0] && exists R.c->{$_};
                C.y.U.sc->{$_}->{C.t} = C.c->{$_} if exists C.c->{$_};
            }
        };
        
        return $off->(1) #&& say "A C.t s ok $de   "
            if $re && $de &&
                C.c.s eq R.c.s;
        
        my $tw = C.sc.tw = {};
        if (defined $de) {
            $tw->{$_} = C.c.s->{$_} for !$de ? C.t : keys %{C.c.s};
            if (C.c.is eq 'K') {
                # clues to whittledness for less intact webs
                delete tw.ooI;
                delete tw.Ii;
            }
        }
        
        G&stlk,$s if C.c.lk;
        G&sttug,$s if C.c.tug;
        G&stAn,$s if C.c.An;
        G&stmk,$s if C.c.mk;
        
        return $off->(1) #&& say "A C.t tw ok $de"
            if $re && $de &&
                G&heq,R.sc.tw,$tw;
        
        $tw = {} if C.c.notw;
        
        # bits to revamp for group or
        # then whattoselect
        for my $k (sort keys %$tw) {
            my $c = G&hup,$C;
            delete c.sc.usto;
            delete c.c.usto;
            delete c.c.uz;
            delete c.sc.uz;
            c.t = $k;
            if (C.c.is) {
                c.sc->{C.c.is} = $k if C.c.is;
                # move raft from top.sc.i into C.c.us
                # c.c.us = c.c.us->{$k} ||= {};
            }
            c.c eq C.c && die "Soplf";
            c.c.R = R.sc.th->{$k} ||= {};
            c.c.de++;
            c.c.s = $tw->{$k};
            c.y.U = $C;
            G&st,$s,$c;
        }
        if (C.c.is eq 'C') {
            if (C.c.in) {
                # %{C.c.us} = %{C.c.s}; # embrace c/sc
                #C.y.U.c.us->{C.t} = C.c.s;
                C.c.uz = C.c.s; # pass entropy
            }
            if (my $to = C.c.to) {
                my @k = grep {defined} map { C.sc->{$_} } @$to;
                die "@k not for ".ki$to if @k != @$to;
                my $x = C.c.usto ||= {};
                while (@k) {
                    my $k = shift @k;
                    if (@k) {
                        $x = $x->{$k} ||= {};
                    }
                    else {
                        $x->{$k} = C.c.s;
                    }
                }
            }
        }
        if (my $z = C.sc.uz) {
            if (G&heq,R.sc.uz,$z ) {
                #sayre "Same euzk C.t $de";
                C.c.uz = R.c.uz;
            }
            else {
                my $to = C.c.uz = {};
                G&supe,$to,1,$z;
            }
        }
        if (my $u = C.sc.usto) {
            if (G&heq,R.sc.usto,$u ) {
                #sayre "Same euk C.t $de";
                C.c.usto = R.c.usto;
                C.c.ustolk = R.c.ustolk;
            }
            else {
                my $to = C.c.usto = {};
                G&supe,$to,3,$_ for values %$u;
                C.c.ustolk = [sort keys %$to];
            }
        }
        $off->();
        C.sc.th = R.sc.th;
        if (!C.c.de && !C.c.nos) {
            # top .c ends on s.R.II.c (.us = s.II)
            # and how us must change, be pumped upwards
            $s->{C.t} = C.c.uz->{C.t};
        }
        %$R = %$C;
        $C
    
    #c steamed R
    # eg ii, lk holds itervals, A.c.$R
    stlk:
        my $R = C.c.R;
        if (my $i = C.c.lk) {
            C.c.nos = 1;
            my $u = C.c.s;
            C.sc.s = $u;
            C.sc.lk = u.c->{$i.'lk'};
            C.sc.unlk = u.c->{$i};
            ref C.sc.lk eq 'ARRAY' || die "no lk array";
            ref C.sc.unlk eq 'HASH' || die "no unlk hash";
            %{C.sc} = (%{R.sc},%{C.sc}) if C.sc.lk eq R.sc.lk;
        }
    
    # one time _.t => _ and input ordered _.t *lk onto s.*
    sttug:
        my $R = C.c.R;
        if (my $u = C.c.tug) {
            C.c.nos = 1;
            C.c.notw = 1;
            my $tw = C.sc.tw;
            my $nd;
            for (@$u) {
                my $t = _.t;
                $nd->{$t}++ && die "two same lights";
                $tw->{$t} = $_;
                push @{C.sc.lk||=[]}, $t;
                if (my $m = C.c.mks) {
                    $_->{$m} = $s;
                }
            }
            $s->{C.t} = $tw; # al t=>A
            $s->{C.t.'lk'} = C.sc.lk;
        }
    
    # grow N ordered C as an An for a.mo
    # that is where we 
    # also inter whaT, changey shared tapes, reel arrays 
    stAn:
        my $R = C.c.R;
        # when some splits from A.mo=A  (lowovsorts An)
        # or as al possibles also al lowcvs A.ovs 
        # R lives in mo.c.$t, c differ all A
        if (my $n = C.c.An) {
            C.c.nos = 1;
            C.c.notw = 1;
            n.y eq $n || die "An so A";
            
            my $id = C.c.Ant ? n.t : "$n";
            
            my $ov = n.ov || 0;
            
            my $tw = C.sc.tw = R.sc.tw || {};
            my $new = !exists $tw->{$id};
            $tw->{$id} = $n;
            
            my $de = C.sc.N = R.sc.N || [];
            push $de, $n if $new;
            
            my $tt = C.sc.tt = R.sc.tt || {};
            my $old = $tt->{$id};
            $tt->{$id} = $ov;
            
            my $sl = C.sc.sl = R.sc.sl || [];
            my $tv = C.sc.tv = R.sc.tv || {};
            my $done;
            if (defined $old && $old ne $ov) {
                my $o = $tv->{$old};
                delete $o->{$id};
                if (!keys %$o) {
                    my $done;
                    for (0..6) {
                        $old eq $sl->[$_] || next;
                        splice @$sl, $_, 1;
                        $done = $_;
                        last;
                    }
                    if (!defined $done) {
                        @$sl = sort keys %$tv;
                        saybl "n.t n.cv n.ov @@ C.t sl rm Resorted to rm $old, s.t   @$sl";
                    }
                }
            }
            if (!defined $old || $old ne $ov) {
                my $o = $tv->{$ov} ||= {};
                my $vnew = !keys %$o;
                $o->{$id} = $n;
                if ($vnew) {
                    # must insert o
                    my $i = 0;
                    $i++ until !@$sl || !exists $sl->[$i] || $sl->[$i] >= $ov;
                    @$sl && $sl->[$i] == $ov && die "Thought $i would new $ov ".wdump 3, $sl;
                    splice @$sl, $i, 0, ($ov);
                    sayre "n.t n.cv n.ov @@ C.t sl $i" if $i != 0 && $i != 1;
                }
            }
            # sc.tw.$id = sc.tv.$ov.$id = $n
            # sc.sl[0] = lowest $ov, etc
        }
Indular: | # wain wain
    # not allcode since uCons blank qq cone & then thing
    n Bangdesk
    n SlideEa
    n C
    n Servo
    n Motion
    
Shelf: |
    u allacgts
    
    n d =>'',<<''
        die "USING I->d !".wdump 2, [$s,@Me];
    
    n AN =>'',<<''
        $C = {};
        C.c->{$_} = shift @Me for qw'J N M';
        ref C.c.N eq 'ARRAY' || die "Not array CcN";
        my $t = C.c.N->[0];
        C.c.N = [C.c.N] if defined $t && !ref $t; # C[] -> N[C[]]
        ref C.c.M || delete C.c.M;
        G&A,$s
    
    n A =>''=><<''
        ($A,my$up) = ({},$A);
        A.G = $G;
        A.up = $up;
        A.mo = $A;
        A.am = $s || die "unsame?";
        .
        A.C = $C;
        A.N = [@{C.c.N||[$C]}];
        A.M = [];
        A.J = C.c.J if C.c.J;
        A.J || die "NOJ";
        A.talk = (A.J.le&&"(A.J.le.name)").A.J.name."-".A.am;
        .
        $T = A.T = {};
        $G::KA->{"$A"} = $A;
        A.fl = C.c.fl || {};
        {
        my $I = A.I = {};
        %$I = (%$I,%{G.I});
        my $II = Rw collaspII $A;
        I.Ii = II.Ii;
        # split from R, dispatches of patches as I.$k = CODE
        # base exuder of self if no Ii resol
        I.Ii = II.Ii;
        # throw in from R exact Ii, bits of Ii to I before t gets it
        if (my $re = delete G.drop.recycling->{A.J.id}->{A.am}) {
            if (re.Ii eq I.Ii) {
                %$I = (%$I,%$re);
                A.cv = 0.1;
            }
            else {
                #sayre "Recycloped:  Diff I.Ii  <--  re.Ii";
            }
        }
        I.d&An;
        A.t&1;
        A.t&11111 || warn "NO 1";
        }
        ($A,$C,$G,$T)
    
    n recycle =>''=>{s=><<''}
        return if I.recyttl++ > 38;
        G.drop.recycling->{A.J.id}->{A.am} = $I;
    
    n Act =>'',<<''
        my $up = $s;
        $s = shift @{A.N};
        if (ref $s eq 'HASH' && s.J && s.mo && s.talk) {
            $A = $s;
            A.mo eq $up || die "A.talk re A mo A.mo.talk notfrom up.talk";
            $C = A.C||die"travcno A.talk";
            keys %$C == 4 || die "A.talk carries wei ".wdump 3, $A;
            $T = A.T ||= {};
            saybl "Resume has TNOT: A.talk to A.cv   with C.t" if delete T.not;
        }
        else {
            $A = {%$up};
            A.mo.ont = $A;
            A.s = $s;
            $C = A.C = {};
            $T = A.T = {};
        }
        T.oM = [];
        G&An;
        if (A.cv < 0.2) {
            A.t&2;
            return (undef,undef,undef,{isnot=>1}) if T.isnot;
            ($C,$T) = (A.C,A.T);
            G&An;
        }
        ($A,A.C,$G,A.T)
    
    n An =>'',<<''
        A.I || die "GimeI";
        A.note = {}; # pinging csc
        A.c = sub { G&c,@_; };
        A.e = sub { G&e,@_; };
        A.us = sub { G&us,@_; };
        A.t = sub { G&t,@_; };
        A.V = sub { A.J.VV && A.J.VV->{$_[0]} || A.J.V };
        $A
    
    
    
    #c veNtlike      
    # make pool, synth space, want arches
    # fork & rejoin to exciting place
    # the valley, what it means to be here in here YIN
    # todo undef $s as repl, J ventlike
        #  $J, [in], [out]
    # @M = $s + @Me
    # Mn(.+) is n $J [$1] $M
    
    n In =>'',<<''
        ($A,$C,$G,$T) = G&AN,'In',$s,@Me;
        G&loop;
    
    n Mo =>'',<<''
        ($A,$C,$G,$T) = G&AN,'Mo',$s,@Me;
        G&loop;
    
    n Sev =>'',<<''
        $Me[0] ||= [Elvis=>''=>{J=>$s,Y=>'Pre',V=>'Duv'}];
        $Me[1] ||= [];
        ($A,$C,$G,$T) = G&AN,'Sev',$s,@Me;
        A.I.scIfs || die "NO scIfs: A.J.name";
        G&loop;

    n loop =>'',<<''
        my $i;
        @{A.N}||die"nonois A.talk ".wdump(3, $C).wdump 2,$A;
        while (@{A.N}) { #
            $i++ > 5000 && die "Huge A.talk";
            my ($A,$C,$G,$T) = G&Act,$A;
            next if delete T.isnot; # zless
            for (1) {
                T.not&&next;
                A.t&6;
                T.not&&next;
                G&flywheels;
                T.not&&next;
                A.t&78;
                T.not&&next;
            }
            continue {
                G&z
            }
        }
        A.cv = 0.78;
        A.t&8;
        G&recycle;
        (A.nj) = values %{A.Js} if A.Js && keys %{A.Js} == 1;
        A.bangdesk.main->() if A.bangdesk.main;
        if (C.c.M) {
            @{C.c.M} = () if C.c.M eq C.c.N;
            my @un = uniq @{A.M};
            die "ManyofsameM: ".wdump 3, A.M if @{A.M} > @un;
            push @{C.c.M}, @{A.M};
            $A
        }
        elsif (C.c.J && A.am eq 'In') {
            G&Mo,C.c.J,A.M,C.c.M||[] if @{A.M};
        }
        else {
            die "noJMout A.am";
        }
KnowTime: | # dome props
    u allacgts
    
    n 't' =>''=><<'',{acgt=>'K,cv,av',nois=>'#c'}
        ($K,$cv) = (A.am,$K) if !$cv && $K;
        $av = 0+("0.".$av) if $av;
        die "K$K cv$cv" unless $K && $cv;
        my $c = 0+("0.".$cv);
        my $Av = $av || A.cv;
        my $i = Rw collaspII $A;
        die'difAvcol' if $Av ne ($av || A.cv);
        #
        my $ncv;
        my $re;
        my $dont;
        # is for reentrant pins like concoi
        # different phases of awareness
        if ($Av < 0.6 || $c >= 0.7) {
            if ($c >= $Av) {
                $ncv = $c;
                $re = 1;
            }
            else {
                $re = 0;
                $dont = 1;
                say " deInc $Av - $cv $c";
            }
            die "pre bigger" if $cv < $Av;
        }
        else {
            if ($c < $Av) {
                if ($Av == 0.6) { # scoop up all on entering timezone
                    $re = 1;
                    $dont = 1; # or will II fall away
                }
                else {
                    $re = 0;
                    $dont = 1;
                }
            }
            elsif ($c == $Av) {
                $re = 1;
            }
            elsif ($c > $Av) { # and $c < 0.7, is a next time
                T.Z->{$c} = 1;
                $re = 0;
                $dont = 1;
            }
            else {die"nof"}
        }
        undef $ncv if $av; # aux/Subtle K
        my $was = A.cv;
        $dont || I.d&ex,$i,$K,$cv,$av;
        A.cv = $ncv if defined $ncv && A.cv == $was;
        $re;
    
    # adapt to much  mergey       extendo  rubble
    # do stuff # in fractions
    n ex =>'',<<'',{l=>'#c',acgt=>'i,K,cv,av'}
        my $c = 0+("0.".$cv);
        my $Av = $av || A.cv;
        my $sp = $av ? " Flav $av (no A.cv)" : "";
        .
        my $talk = "A.talk: $K$sp $Av > $c --- C.t ";
        .
        my $aim = {$K=>1};
        if ($aim->{A.am}) {
            $aim->{$_} = 1 for @{A.Isl||[]};
            aim.I = 1;
        }
        .
        my $yv = {};
        for my $k (sort keys %$i) {
            my $ii = $i->{$k};
            .
            next if $k eq 'Ii';
            next if $k eq 'ooI';
            ref $ii eq 'HASH' || die "weird $k=$ii";
            .
            for my $vc (sort keys %$ii) {
                my $iii = $ii->{$vc};
                die'$k !0<$vc<1' unless $vc > 0 && $vc < 1;
                $yv->{$vc}->{$k} = $iii;
            }
        }
        .
        my $vb;
        my $wasSubtle;
        for my $vc (sort keys %$yv) {
            my $is = $yv->{$vc};
            my $s = {};
            my $x = {};
            my $xrd = [];
            .
            next if $vc <= $Av && $vc != $c;
            next if $vc > $c;
            .
            # our  osc (stay in K per Subtle ness);
            my @iz = grep {
                $aim->{$_} || (aim.I && A.Iso->{$_})
            } sort keys %$is;
            next if !@iz;
            .
            # decide inter cv wideness loop
            if ($wasSubtle) {
                undef $wasSubtle;
            }
            elsif ($vb && $vc > $vb &&
                (@{A.N} || @{A.mo.re->{$vb}||[]})) {
                # sincing, wide order
                # various others want to be around for only some of the process...
                sayre "$vb -> $vc  bump, ". @{A.N} if A.J.V > 1;
                T.Z->{$vb} = 1;
                A.cv = $vb; # so we dont wind up to 6 on the way out of t
                return T.not = 1;
            }
            I.cv = $vc;
            I.vb = $vb;
            for my $k (@iz) {
                my $iii = $is->{$k};
                I.k = $k;
                I.d&carebowl,$s,$iii,$x,$xrd;
            }
            # suble
            my $se = Rw TreeD $s $scby=gro 
                if A.J.V > 1 && keys %$s;
            $c == 0.1 ? saygr $se : say $se if $se;
            .
            my $o;
            o.talk = $talk;
            (o.vc,o.vb) = ($vc,$vb);
            I.d&exood,$o,$x,$xrd;
            ($vc,$vb) = (o.vc,o.vb);
            if (o.Subtle && !o.nonSubtle) {
                $wasSubtle = 1;
            }
            .
            return if T.not;  # will &z, oseve
            return if delete T.whack;
        }
    
    #
    n carebowl =>''=><<'',{l=>'#c',acgt=>'s,iii,x,xrd'}
        for my $ik (sort keys %$iii) {
            my $D = $iii->{$ik};
            if (D.sc.nk && !D.sc.def) {
                my $nk = D.sc.nk;
                die "AC-C confusio".wdump 4,[A.C,$C] if A.C ne $C;
                next if !exists $C->{$nk};
                if (my $gk = D.sc.gk) {
                    next if !exists $C->{$nk}->{$gk};
                }
            }
            my $dont;
            if (D.sc.acgt) {
                # acgtsubs can be defined at any cv
                # run themselves if act
                # usu. one receiver (Ci) and the rest scheme
                # may up Iso personalities as sublingoes to decompress inpatterns.
                $dont = 1 if exists A.I->{D.t};
                if ($dont) {
                    my $Ige = A.I->{D.t."_dige"};
                    if ($Ige ne D.sc.dige) {
                        $dont = 0;
                    }
                }
            }
            if (!$dont && D.sc.eg) {
                $dont = I.d&robeg,$D;
            }
            # the D.s should be perl expecting ACGT (which become robes to rob) z
            if (!$dont) {
                my $paw = join"_",'',I.k,I.cv,D.t;
                $paw =~ s/\W//g;
                A.I->{D.t} = Rw $paw $A $C $G $T $__D:D;
                A.I->{D.t."_dige"} = D.sc.dige;
            }
            # most tiny ticks
            # this ind is all flywheel
            # it's a kind of unity that wants to be a block of code like this
            # and c
            my @is = A.s;
            @is = I.d&scIfs,D.sc.Ifs if D.sc.Ifs;
            @is || next;
            if (D.sc.act) {
                die "D.t .act gets... D.sc.act" if D.sc.act ne '1';
                push @$xrd, [I.k,$ik];
                my $Ds = $x->{I.k}->{$ik} ||= {};
                Ds.D = $D;
                Ds.is = \@is;
                D.sc.its = @is;
            }
            # TreeD
            $s->{I.k}->{I.cv}->{$ik} = $D;
        }
    
    #
    n exood =>''=><<'',{l=>'#c',acgt=>'o,x,xrd'}
        for my $kik (@$xrd) {
            my ($k,$ik) = @$kik;
            A.Subtle && A.Subtle->{$k} ? o.Subtle++ : o.nonSubtle++;
            my $Ds = $x->{$k}->{$ik};
            my $D = Ds.D;
            for my $s (@{Ds.is}) {
                D.sc.acgt eq 's'||die "nonacgts".wdump $D;
                exists A.I->{D.t}||die "acgtI D.t not up: ".wdump $D;
                .
                T.D = $D;
                I.d&D.t,$s;
                .
                if (my $ut = T.ut) {
                    if (ut.matchTd) {
                        my $d = s.d || die "confuse";
                        d.od.s.T.q->{d.e.k} ||= $d;
                        d.od.s.T.m->{d.e.k} ||= $d
                            unless delete(T.noTd);
                    }
                    else { die"utrowhat ".wdump 2, $ut }
                }
                .
                # outwave: schools of many fish (not upcv if !@is)
                o.vb ||= o.vc if D.sc.v;
                .
                last if T.not || T.whack;
            }
            delete T.ut;
            last if T.not || T.whack;
        }
    
    # y
Motion: |
    u allacgts
    # 6* thing/rule management
    # SNat exudes over the nk'ing ish things which .wh=fly(wheel)
    # iterates grouped 6cv via T.Z, all N at a time
    # (make no hop if N==1 or A.Subtle.$K)
    # also have pha cone stack available for offphasing
    # if our intent it loose enough
    
    # encap A/spiral spinner for the G.h, from the  to ar A.I.d&Others
    # finds relevant A.I, returning ($A,$I)
    # ingoing niles, can take ACGT or just J, like you were holding the self
    #    T compine with ^ ? whatever
    #    tie T, T&M for temp A.c like grappler, ack from n that it did
    #    ie argument imposer, passes manual bits eg Magnets
    #    and some are required reading for the call to succeed
    # T is the only kind of dataspace that could store its q right there
    # see also the II's ooI branch rememberer, Yod, etc
    n NM =>''=><<'','%acgt:J'
        my $M = [];
        my $N = [@Me];
        Mn($N);
        return $M;
    
    # A and A.mo dye drops, M tractios, T tooly, see also flywheel
    # wants to be a six alwayser... ,{code=>'I 6',act=>'all'} # II.All? II.Fly?
    # its I.d&nded and holds things to code, $v a spiral it's filling up
    # $v could be mounted... aj8 mysteries
            #   ^ bus to ride
    n flywheels =>'',<<''
        for my $k (sort keys %{A.fl||return}) {
            my $v = A.fl->{$k};
            $k = $2 if $k =~ /^(\d+) (.+)$/;
            Rw ym/$k $I $J:A.J $A $C $v $G $T;
        }
    
    n sano =>''=><<''
        A.C = $C;
        A.T = $T;
        return$A
    
    # outgoing magnatrain (per Act)
    n CoM =>''=>{s=><<''},{code=>'I 71',act=>1}
        push @{T.oM}, $C unless T.Z;
    
    # on exit, snakes
    n z =>''=>{s=><<''}
        I.d&oseverato;
        push @{A.M}, @{T.oM};
        delete T.not;
        1

    n oseverato =>''=><<''
        A.T.d = T.d if T.d;
        if (my $z = delete T.Z) {
            I.d&Tz,$z;
        }
        !@{A.mo.N} && A.mo.re &&
            I.d&more,A.mo.re;
        if (my $y = delete T.y) {
            I.d&mar,T.y;
        }
    
    # carry A through time
    # T.Z always for lowest, tease out the next times off T.Z.$nexttime = $incv|$N
    # is N or incv, put things off til all else lo
    n Tz =>'',<<''
        my ($lo) = sort keys %$s;
        my $v = $s->{$lo};
        T.incv = $v if $v ne '1';
        $v = [ I.d&sano , undef ];
        push @{A.mo.re->{$lo}||=[]}, $v;
        @{T.oM} = ();
    
    # TODO sort by y.i ) s = c
    n more =>'',<<''
        my ($lo) = sort keys %$s;
        if ($lo) {
            my $ay = delete $s->{$lo};
            my @N = map { {AZ=>{$lo=>$_}} } @$ay;
            push @{A.mo.N}, @N;
            saybl "Looping ".@N." to $lo" if A.J.V > 1;
        }

    n moy =>''=>{s=><<''}
        # groups, spread the moise over A
        my $i = A.mo.y->{$s}||die"no$s";
        my $is = $i->{C.y.p}; # things in our C's pool
        {is=>$is,N=>[map{$is->{$_}}sort keys %$is]};
    
    n ar =>''=><<''
        my $ar;
        ar.A=$A;ar.G=$G;ar.C=$C;ar.T=$T;ar.I=$I;
        $ar;
    
Bangdesk: |
    u allacgts
    # want to sus $@ and hang vectors of what, should be autoish
    # suppose we come here with only ACGT between us and F
    n after =>''=>{s=><<''},{code=>"I 11",act=>1}
        A.bangdesk = {};
        A.bangdesk.main = sub {
            $_->() for values %{A.bangdesk.aft};
            $@ || return;
            A.bang && return;
            A.bang = 21;
            $_->() for values %{A.bangdesk.bang};
            # want to sus $@ and hang vectors of what, should be autoish
            my $m = "J: A.mo.ont.talk        A.mo.ont.cv";
            $m .= "\nC: ".k2 A.mo.ont.C;
            $m .= "\ns: ".wdump 3, A.mo.ont.s unless length $m > 20;
            sayre " * bangdesk: \n$m";
            return $m;
        };
    
    n erg =>''=>{s=><<''},{code=>"I 9"}
        # must pre compile, see D severators
        my $m = "J: A.talk";
        $m .= "\nC: ".ki $C;
        $m .= "\ns: ".wdump 3, A.s unless length $m > 20;
        $@ = "$m\n$@";
    
SlideEa: | # liney schemery
    u allacgts
    
    Ci 12: %act
        my $r = ref $s;
        !$r ? G&string,$s :
        'ARRAY'eq$r ? G&array,$s :
        'HASH'eq$r ? G&hash,$s :
        'SCALAR'eq$r ? do {
            C.t ||= '';
            C.y = $s;
        } :
        die "mmtype:$r for $s"
    
    string:
        die "string: $s ".wdump 5, [A.s,A.N];
    
    array:
        return I.d&fourreal,$s if @$s != 1 && !ref $s->[0] || $s->[0] =~ /^\w+$/;
        return I.d&fourstring,$s->[0] if @$s == 1 && !ref $s->[0];
        # should stick In in first and M it? 
        # kind of motion that wants to be unsure in the wild
        unshift @{A.N}, @$s;
        T.not = 1;
    
    hash:
        return %$C = %$s if exists s.t && s.y && s.c;
        I.d&servehash,$s;
    
    fourstring:
        I.d&MZu,$1 if $s =~ /^\s*#?\s*MZ (.+)$/;
        $s =~ s/^\s+//;
        if ($s =~ /^\s*(#.*)$/) {
           T.not = 1;
           T.com = $1;
        }
        elsif ($s eq '') {
           T.not = T.space = 1;
        }
        else {
           my $ci = $s;
           for my $nk (qw't y c sc') {
               if ($ci =~ s/^(\S+) *//) { # some t are types of space
                   my $v = $1;
                   $v = I.d&peel,$v if $nk ne 't' && $v =~ I.peels;
                   # << consumes more lines into $nk, then ...
                   $v = '' if $v =~ /^(''|"")$/;
                   $C->{$nk} = $v;
               }
           }
        }
        saybl "4string: $s            ".ki $C if A.V&C;
    
    fourreal:
        (C.t, C.y) = @$s;
        C.c  = $s->[2] if exists $s->[2];
        C.sc = $s->[3] if exists $s->[3];
        die'@>4'.wdump $s if @$s > 4;
        if (ref C.t eq 'SCALAR') {    
            die "scalaref Ct had Cc".wdump 4,$C if C.c;
            (C.t,C.y) = ('',$s);
        }
        die"C.t from ".wdump $s if ref C.t; # dives
    
    reasonlock 18: %act
        die"reft" if ref C.t;
        if (A.J && (A.J.name eq 'qq' || A.J.most.J eq A.J)) {
            C.c.W = C.t unless C.c || C.sc || C.y;
        }
        I.d&renc if ref C.c ne 'HASH';
        .
        my $yy = C.y;
        C.y = {} if ref C.y ne 'HASH';
        I.d&givy,$yy;
        .
        I.d&rensc if ref C.sc ne 'HASH';
        .
        I.d&isC,$C && ref C.sc
            || die "reaso fail".wdump [A.s,$C];
        I.d&scyvle;
    
    #curv=>pi=>see
    renc:
        (my $s,C.c) = (C.c,{});
        if (ref $s eq 'REF' || ref $s eq 'SCALAR') {
            C.c.s = $$s;
            return;
        }
        if (ref $s eq '' && $s =~ /I.peels/) {
            # peels for now
            G&xo,C.c,$_ for G&peel,$s;
        }
        else {
            A.btw.cwass = 1 if "" eq $s;
            A.btw.cwasnd = 1 if !defined $s;
            C.c.s = $s;
        }
    
    rensc:
        C.sc = '%'.${C.sc} if ref C.sc eq 'SCALAR';
        C.sc = C.sc eq '' ? {}
            : C.sc =~ I.peels
            ? G&peel,C.sc
            : die "C sc nostr: C.sc   of I.peels  ".ki $C
    
    givy:
        my $y = C.y;
        if (ref $s eq 'SCALAR') {
            my $z = $s;
            $s = $$s;
            $s = '%'.$s if $s !~ /^%/;
            $s =~ /I.peels/ || die "scalarnopeel $s";
            G&xo,C.c,$_ for G&peel,$s;
            
        }
        elsif (ref $s eq 'ARRAY') {
            for my $yy (@$s) {
                C.y = {};
                G&givy,$yy;
                ref $y || die "notash ".ki $y;
                G&xot,$y,C.y;
                C.y = $y;
            }
        }
        elsif (ref $s) {
            ref $s eq 'HASH' || die "no $s  ref=".ref $s;
            if (G&taJe,$s ) {
                my $yy = C.y;
                C.y = {} if ref C.y ne 'HASH';
                G&givy,$yy;
            }
            elsif ($y ne $s) {
                G&xot,$y,$s;
            }
        }
        elsif ($s eq '') {
            my $x = I.blanky ? G&blanky : {};
            G&xot,C.y,$x if keys %$x;
        }
        elsif ($s =~ /^($G::NUM)$/) {
            y.cv = $1;
        }
        elsif ($s =~ /^($G::NUM)-($G::NUM)$/) {
            y.in = $1;
            y.out = $2;
        }
        elsif ($s =~ /^($G::NUM)-($G::NUM)x($G::NUM)$/) {
            y.in = $1;
            y.out = $2;
            y.thi = $3;
        }
        elsif ($s =~ /^-(\w+)$/) {
            C.c.pi = $1;
            C.c.s = C.t if !exists C.c.s || A.btw.cwass;
        }
        elsif ($s =~ /^([a-zA-Z]+)(?::(.+))?$/) {
            C.c->{$1} = $2 || C.t;
        }
        else {
            die "C y wtf: $s";
        }
    
    isC:
        return 0 unless ref $s eq 'HASH';
        exists s.t && defined C.t && !ref s.t
        && ref s.y && ref s.c && 9 > keys %$s;
    
    isJ:
        ref $s eq 'HASH' && ref s.bb eq 'HASH';
    
    taJe:
        I.d&isC,$s || I.d&isJ,$s || return;
        if (s.bb) {
            if (I.d&isC,C.c ) {
                C.c = {e=>C.c};
            }
            C.c.s = $s;
        }
        else {
            if (I.d&isJ,C.c ) {
                C.c = {s=>C.c};
            }
            C.c.e = $s;
        }
        C.y = {};
        C.c.W = C.t;
        return 1
    
C: |                     #cCccCCCCccCCcccCCccccccCCCCCCCCCCCCccCCCCCCCCCCccccccCCCCCCCCCCCCCccccCCCCCCccccCCCCCccetcccCCCCccCCcccCCccccccCCCCCCCCCCCCccCCCCCCCCCCccccccCCCCCCCCCCCCCccccCCCCCCccccCCCCCccetcccCCCCccCCcccCCccccccCCCCCCCCCCCCccCCCCCCCCCCccccccCCCCCCCCCCCCCccccCCCCCCccccCCCCCccetcccCCCCccCCcccCCccccccCCCCCCCCCCCCccCCCCCCCCCCccccccCCCCCCCCCCCCCccccCCCCCCccccCCCCCccetcccCCCCccCCcccCCccccccCCCCCCCCCCCCccCCCCCCCCCCccccccCCCCCCCCCCCCCccccCCCCCCccccCCCCCccetcccCCCCccCCcccCCccccccCCCCCCCCCCCCccCCCCCCCCCCccccccCCCCCCCCCCCCCccccCCCCCCccccCCCCCccetcccCCCCccCCcccCCccccccCCCCCCCCCCCCccCCCCCCCCCCccccccCCCCCCCCCCCCCccccCCCCCCccccCCCCCccetcccCCCCccCCcccCCccccccCCCCCCCCCCCCccCCCCCCCCCCccccccCCCCCCCCCCCCCccccCCCCCCccccCCCCCccetcccCCCCccCCcccCCccccccCCCCCCCCCCCCccCCCCCCCCCCccccccCCCCCCCCCCCCCccccCCCCCCccccCCCCCccetcccCCCCccCCcccCCccccccCCCCCCCCCCCCccCCCCCCCCCCccccccCCCCCCCCCCCCCccccCCCCCCccccCCCCCccetcccCCCCccCCcccCCccccccCCCCCCCCCCCCccCCCCCCCCCCccccccCCCCCCCCCCCCCccccCCCCCCccccCCCCCccetcccCCCCccCCcccCCccccccCCCCCCCCCCCCccCCCCCCCCCCccccccCCCCCCCCCCCCCccccCCCCCCccccCCCCCccetcccCCCCccCCcccCCccccccCCCCCCCCCCCCccCCCCCCCCCCccccccCCCCCCCCCCCCCccccCCCCCCccccCCCCCccetcccCCCCccCCcccCCccccccCCCCCCCCCCCCccCCCCCCCCCCccccccCCCCCCCCCCCCCccccCCCCCCccccCCCCCccetcccCCCCccCCcccCCccccccCCCCCCCCCCCCccCCCCCCCCCCccccccCCCCCCCCCCCCCccccCCCCCCccccCCCCCccetcccCCCCccCCcccCCccccccCCCCCCCCCCCCccCCCCCCCCCCccccccCCCCCCCCCCCCCccccCCCCCCccccCCCCCccetcccCCCCccCCcccCCccccccCCCCCCCCCCCCccCCCCCCCCCCccccccCCCCCCCCCCCCCccccCCCCCCccccCCCCCccetcccCCCCccCCcccCCccccccCCCCCCCCCCCCccCCCCCCCCCCccccccCCCCCCCCCCCCCccccCCCCCCccccCCCCCccetcccCCCCccCCcccCCccccccCCCCCCCCCCCCccCCCCCCCCCCccccccCCCCCCCCCCCCCccccCCCCCCccccCCCCCccetcccCCCCccCCcccCCccccccCCCCCCCCCCCCccCCCCCCCCCCccccccCCCCCCCCCCCCCccccCCCCCCccccCCCCCccetcccCCCCccCCcccCCccccccCCCCCCCCCCCCccCCCCCCCCCCccccccCCCCCCCCCCCCCccccCCCCCCccccCCCCCccetcccCCCCccCCcccCCccccccCCCCCCCCCCCCccCCCCCCCCCCccccccCCCCCCCCCCCCCccccCCCCCCccccCCCCCccetcccCCCCccCCcccCCccccccCCCCCCCCCCCCccCCCCCCCCCCccccccCCCCCCCCCCCCCccccCCCCCCccccCCCCCccetcccCCCCccCCcccCCccccccCCCCCCCCCCCCccCCCCCCCCCCccccccCCCCCCCCCCCCCccccCCCCCCccccCCCCCccetcccCCCCccCCcccCCccccccCCCCCCCCCCCCccCCCCCCCCCCccccccCCCCCCCCCCCCCccccCCCCCCccccCCCCCccetcccCCCCccCCcccCCccccccCCCCCCCCCCCCccCCCCCCCCCCccccccCCCCCCCCCCCCCccccCCCCCCccccCCCCCccetcccCCCCccCCcccCCccccccCCCCCCCCCCCCccCCCCCCCCCCccccccCCCCCCCCCCCCCccccCCCCCCccccCCCCCccetc
    u allacgts
    n T
    # modem sounds etc.
    # dome props, repeatable tests
    # fold space til fit
    sca:
        $s /= 10 while $s > 1 || $s < -1;
        return $s
    
    scyvle:
        map { my$i;
            C.y->{$_} /= 10 while
            (C.y->{$_} <= -1 || C.y->{$_} >= 1)
            &&
            (++$i < 10 || die "Many i chewing on $_: ".ki C.y)
        }
        grep { C.y->{$_} }
        qw'in out cv'
    
    peels: %subpeel
        qr/^[\{\%]\w+/;
    
    peel:
        $s =~ s/^%//;
        my $c = {};
        for (split ',', $s) {
            my ($k, $v) = split ':', $_, 2;
            $v = 1 if !defined $v;
            $c->{$k} = $v;
        }
        $c
    
    # for getting click together:
    c: %acgt:D
        G&inDin,$C,@M;
    
    e: %acgt:D
        my $e = G&sces,C.c.e||return();
        G&inDin,$e,@M;
    
    us: %acgt:D
        my $e = G&sces,C.c.e||return();
        my $us = e.c.us||return();
        push @M, 'NOGK' if @M == 1;
        G&inDin,$us,@M;
    
    sces:
        my $i = 0;
        while (s.c.e) {
            $s = s.c.e;
            $i++ > 9 && die "HUGE $i recursing CceCceCceCce... by ".ki $s;
        }
        return $s;
    
    # index fancies
    inDin: %acgt:s D
        return () unless defined $s;
        return $s if $D eq 'C';
        #
        shift @M; # s
        $D = G&interpD,@M if !ref $D;
        #
        my $v = G&Cngk,$s,$D;
        saybl "Got cnkgk: ".wdump 3,[\@M,$D,$v,$s] if A.VV.D;
        die "Unhandles any: $v: ".ki $D if $v eq '1';
        #
        return () unless $v;
        # blankgk
        A.note->{D.c.nk}->{D.c.gk} = $v if A.note;
        #
        @$v == 1 || die "Many somehowed ".wdump 3,[ki($D),$v];
        ($v) = @$v;
        if (D.c.as eq 'list') {
            ref $v eq 'ARRAY' || die 'Cngk for list not array '.ki $D;
            return @$v;
        }
        return $v;
    
    interpD: %acgt:nk gk
        my $defnk = 'c';
        return $nk if ref $nk;
        my $D = {};
        D.c.as = 'list' if $nk =~ s/^_//;
        while ($gk =~ s/^%(.+?):(.+?)(?=%|$)//g) {
            D.c->{$1} = $2;
            pop @M if @M == 2;
        }
        if (@M == 1 && $nk eq 't') {
            D.c.nk = $nk;
        }
        elsif (@M == 1) { # or from t,,,
            D.c.nk ||= $defnk;
            D.c.gk ||= $nk;
        }
        elsif (@M == 2) {
            D.c.nk = $nk;
            D.c.gk = $gk;
        }
        delete D.c.gk if D.c.gk eq 'NOGK';
        $D
    
    Cngk: %acgt:s D
        ref $A || die "nmonref A!";
        A.bangdesk.bang->{Cngek} = sub {
            sayre "was Cngk; ".ki($s)."\nWith: ".ki($D)
        } if 0;
        return 1 if D.c.any;
        die "nonNKnk".ki$D if !D.c.nk;
        return 0 if !exists $s->{D.c.nk};
        return [$s->{D.c.nk}] if !exists D.c.gk;
        return 0 if !exists $s->{D.c.nk}->{D.c.gk};
        return [$s->{D.c.nk}->{D.c.gk}];
    
T: |
    u allacgts
    # intel s, c properties
    # \$whereclause
    ip: %acgt:s c
        my $z;
        $s = G&peel,$$s if ref $s eq 'SCALAR';
        my $pass = 1;
        for my $I (keys %$s) {
            my $y = $s->{$I};
            my $x = $c->{$I};
            if (ref $y eq 'REF') {
                $y = $$y;
                !defined $x || $pass-- if y.ndef;
                defined $x || $pass-- if y.def;
                y.not ne $x || $pass-- if exists y.not;
                y.in->{$x} || $pass-- if y.in;
                !y.nin->{$x} || $pass-- if y.nin;
                $x > y.gt || $pass-- if y.gt;
                $x < y.lt || $pass-- if y.lt;
            }
            elsif ($y ne $c->{$I}) {
                $pass--;
            }
        }
        $pass == 1
    
    xoy: %acgt:s c
        $c = G&xot,{},$c;
        G&xot,$c,$s;
        return $s;
    
    xot: %acgt:s c
        ref $c eq 'HASH' && ref $s eq 'HASH'
            || die "Hash up".wdump 3, [$s,$c];
        while (my($k,$v) = each %$c) {
            $s->{$k} = ref $v eq 'HASH' ?
                        {%{$s->{$k}||{}}, %$v}
            : $v;
        }
        return $s
    
    xo: %acgt:s c
        ref $c eq 'HASH' && ref $s eq 'HASH'
            || die "Hash up".wdump 3, [$s,$c];
        while (my($k,$v) = each %$c) {
            $s->{$k} = $v;
        }
        return $s
    
    hup:
        my $CC = {%$s};
        $CC->{$_} = {%{$CC->{$_}}} for
            grep {ref $CC->{$_} eq 'HASH'} keys %$CC;
        return $CC;
    
Servo: | # lightning over speech bubble in the c 5 liniarity (Motion doing)
    u allacgts
    
    n servehash =>'',<<''
          s.AZ ? I.d&AZu,s.AZ
        : s.MZ ? I.d&MZu,s.MZ
        : s.EZ ? I.d&EZu,s.EZ
        : s.WZ ? I.d&WZu,s.WZ
        : s.EC ? I.d&ECu,s.EC
        : s.Elvis ? I.d&Elvisu,s.Elvis
        : die 'hash: '.wdump($s);
    
    # time impersonator
    n AZu =>''=>{s=><<''},{l=>'Motion/oseverato'}
        die 'amany' if keys %$s > 1;
        my ($cv,$ac) = %$s;
        my ($AA,$CC) = ref $ac eq 'ARRAY' ? @$ac : ($ac,ac.C);
        $AA || $CC || die "AZ NO A or C: ".wdump 3, $s;
        $AA && $CC && die "AZ toomuch A or C: ".wdump 3, $s;
        my $cov;
        if ($AA) {
            $A = $AA;
            my $Te = A.T;
            $cov = delete Te.incv;
            A.cv = $cov || $cv;
            unshift @{A.mo.N}, $A;
            return T.whack = T.isnot = 1;
        }
        else {
            A.C = $CC;
        }
        A.cv = $cov || $cv;
        T.whack = 1;
    
    n MZu =>''=>{s=><<''}
        my $uM = sub {
            my ($k,$v) = @_;
            if (defined $v && $v eq '0') {
                delete A.fl->{$k}
            }
            else {
                A.fl->{$k} = $v || 1;
            }
        };
        ref $s eq 'HASH' ?
            map{ $uM->($_,$s->{$_}) } keys %$s
        :   map{
                /^(.+?)(?::(.+))?$/ || die;
                $uM->($1,$2);
            } split /\s+/, $s;
        T.not = 1;
    
    # without our humm, straight to M
    # this is kind of like going through el1389, so many spires to pi on
    # the calls to In want to be IId
    n EZu =>''=>{s=><<''},{l=>'Motion'}
        my $Z = I.d&iZu,$s;
        warn "About EZ";
        for my $k (sort keys %$Z) {
            my $N = $Z->{$k};
            $N = [ map { [$_] } split "\n",$N ] if !ref $N;
            Rw In $M:T.oM $N;
        }
        T.not = 1;
    
    # with our humm
    n WZu =>''=>{s=><<''},{l=>'Motion'}
        my $Z = I.d&iZu,$s;
        warn "About WZ";
        for my $k (sort keys %$Z) {
            my $s = $Z->{$k};
            die wdump $s if ref $s ne 'ARRAY';
            unshift @{A.N}, @$s;
        }
        T.not = 1;
    
    # extend C on the way in to another dome, magnetised into our M
    # probably for collapsing roooves...
    # dumber than sc decompresphere & playing out
    # (is mailing itself further instructions, intro c, further lines)
    # an In persona, joining our M
    # push to dome
    # that must in  A
    n ECu =>''=>{s=><<''},{l=>'Motion'}
        ref $s eq 'ARRAY' || die;
        my ($N,$c) = @$s;
        $N = [{MZ=>A.fl}, {MZ=>{'3 doex'=>$c}}, @$N];
        # and In could feel our light cone
        Rw In $J:A.J $M:T.oM $N;
        # ^but instead push to A.N and A.No, the sister strand Whare Y Whare
        # and A walks through t&Y, d&Whare(6)
        # turns via n&ACGT
        # the time beams mapped... a W concat couldol
        T.not = 1;
     
    # theses, pulling bits
    n iZu =>''=>{s=><<''}
        my $way = $s =~ s/^\/// ? 'fund' : 'muck';
        my $Z = Rw $way - $p:s $dclone=1;
    

