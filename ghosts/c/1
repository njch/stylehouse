r2j: | # interpreter of buzzed puit partiscules r -> j.[cv,t,style]
    my $j;
    my $sing;
    if (J.tt) {
        $sing = 'J_tt';
        (j.cv,j.t,j.style) = $r =~ /^(.*?)\t(.*)\t(.*?)$/;
    }
    else {
        (j.t,j.style,j.cv) = $r =~ /^(.+?)(?:%(.+))?\s+(.+?)$/;
    }
    defined j.cv || die "$sing no $r    ".ki $j;
    j.s = ar.J.bb->{$r} if ar.J;
    j.nos = 1 if ar.J && !exists ar.J.bb->{$r};
    $j;
Ajr: | # A.jr inputter aimed at J and a K/line: C or t/cv    sends style => $v
      sub {
          my $isv = @_ >= 2;
          my $isd = @_ >= 3;
          my $s = shift;
          my $v = shift;
          my $d = shift;
          $s = '%'.$s if $s;  
          my $t = exists ar.t ? ar.t : ar.C.t;
          my $cv = exists ar.cv ? ar.cv : ar.C.y.cv;
          my $r = $t.$s."\t".$cv;
          if ($isd) {
              sayre "delbbl $r  $d   J.name" for 1..5;
              Rw delbbl $J $l:t;
          }
          if (J.V) {
              if ( defined $v) {
                  saybl "J.name chuck $r     $v  <--  ".J.bb->{$r};
              }
              else {
                  saygr "J.name read $r";
              }
          }
          !$isv ?
            !exists J.bb->{$r} ? () : J.bb->{$r}
          : do {
              J.bz->($r, $v);
              sub { delete J.bb->{$r} } 
          };
      };
Nbz: | # receiver of buzzed out planes of N (C)   # peeler futuro, forte arbiter # suJ cloned  # other is A.jr
    J.tt = 1;
    J.bz = sub { # the cv=>t=>style r
       my $m = [@_];
       die "not 2 @$m" if @$m != 2;
       my $j={};
       while (@$m) {
           my ($r, $v) = (shift @$m, shift @$m);
           if ($r =~ /^%(\S+)/) {
               j.style = $1;
           }
           else {
               $j = Rw r2j $r $J;
           }
           defined j.cv || die "NOSEYV: j.cv".wdump[$j,[@_],[$r, $v]];
           
           j.r = join "\t", j.cv, j.t, j.style;
           j.s = $v;
           my @Js = $J;
           push @Js, values %{J.phy} if J.phy;
           for my $jj (@Js) {
               jj.bb->{j.r} = j.s;
               push @{jj.ord}, {%$j} if jj.ord;
               jj.tim->{j.r} = hitime() if jj.tim;
               jj.wtf->{j.r} = $F[0] if jj.wtf;
               jj.ap->($j) if jj.ap; # <<<
           }
      }
    };
    $J
S/ghostchanges: |
    unless ($m =~ /\/k\//) {
        Rw loD;
        sayyl "loded";
        Rw recoded_init;
    }
S/wayup: |
       -f $m || die;
       delete G.drop; 
       $G->wayup($m);
       Rw loD;
       Rw recoded_init;
waps: |
    sayyl 'ps';
    J.first++ || return;
    my $sleep = sub {
        my $til = hitime() + shift;
        G.pslagtil = $til if $til > G.pslagtil;
    };
    
    
    my @ps = `ps -p$$ fu`; # j right
    my ($u, $pid, $cpu, $mem) = (split /\s+/, $ps[1])[0,1,2,3];
    if ($mem > 20 || $cpu > 60) {
        saybl "& $mem";
        if ($mem > 38) {
            sayre "massive, restarting" for 1..8;sleep 1;
            Rw rez;
        }
        $sleep->(4);
    }
     
    my @temps = 
    map {/\+(\d+\.\d+)\S+? /;$1} 
    grep {/^temp1:/} 
    `sensors`;
    my ($ch,$gh) = @temps;
    sayre "$u $pid       mem:$mem   cpu:$cpu  $ch    $gh ";
    if ($ch > 70) {
        sayre "HOT";
        $sleep->(7);
    }
aftor: |
    my $J = J.most.J;
    my $N = Rw tyc $J;
    @$N = grep { _.sc.pi eq 'thumbnail' } @$N;
    
    my $u = {};
    for my $C (@$N) {
        my $p = C.t;
        my $n = C.c.s;
        Rw loadup $u $p $n;
    }
    sayyl "After J.name: clife: ".wdump 2, [$u,$N];
    Rw makoo $u;
    
makoo: |
       sayre "to make some code? ".wdump [sort keys %$u];
       return;
       my $t = Rw wuck - $u */flows/*;
       my $fr = 0;   
       my $amp = G.ampampamp ||= do{$fr=1;{}};
       for my $k (sort keys %$t) {
           my $v = $t->{$k};
           my ($path,$flows,$from) = split '/', $k;
           
           Rw make/op $amp $pin:k $path $from;
       }
       my $hk = {%{R.way.hooks}};
       for my $z ($hk, $amp) {
           for my $k (keys %$z) {
               next unless $k =~ /^g_(.+)$/;
               say "Has $k";
               $z->{$1} = delete $z->{$k};
           }
       }
       my $x;
       x.wormhole.yr = $hk;  
       x.wormhole.ya = $amp;
       while (my ($dir, $v) = each %$x) {
           while (my ($k, $d) = each %$v) {
               my $y = YAML::Syck::Dump($d);
               die wdump $y if length $y < 50; 
               $y =~ s/^---//;
               encode_utf8 $y;
               fspu("$dir/$k\.yml", $y);
           }    
       }
       
       # maka yml, seeing .s is a gas leak
       `cd wormhole; cat yr\.yml ya\.yml > yb\.yml`;
       #$fr = 1;
       $fr ?
       $G->pub('S/'.$_, "reexec")
       :
       $G->pub('S/'.$_, "wayup w/yb\.yml") for 'shed','coast';
       sayyl "We o ".F_delta();
       
       Rwyl 0.1 J5 scr;
ratio: |
    my $ratio = $o / ($t||1);
    0.01 * int(100*$ratio);
    

