
MourmaZ: | # notes
   u ashtray=>,'c ha' 
   n fdlwk=>''=>{s=><<''}
       # and from Indi
            # and whenever
            # then the things todo
            # lots ||nexts
            # elabourate C, seeming to chew
            # we want to throw our next II etc
            # transmit A,C via AZ, which and A.cv via AZ and A.II)
       in wayves it travels
       I hoist by z
       move the things out into args,name,id in I from already
       code leeching out - chov into index,
         and the brain indexes the bunch of codes run with their I...
       so I is vectored done stuff (u, che acquis)
       thatd be hard to not have at this point
       unmeni the zapping into an I is the finality...
       u bein done...
       the I gets wrenched out but it is all G via J stuff... apply 
       divide the stuff up into K/cv/t limbs
       and apply the K = diffre/OSC/ACT/OMP
       compine blobs, can want to interdesign each other if travel points further than routable
       then break things off as case...
       just like things are pooled
       the over the room code forming way selector outputs more stuff
       unified and interpreted as code to way 
       everything happens as an z Elvis, even if not in El
       so In A can acquire its wires
       and splat from A couplings
   
   n zfold=>''=>{s=><<''}
       wired up some hypnocodes from other J.A.I (& u) into G.T.$W
       then in each there each W is supposedly W overlay (way)
       and theres I/1/n,An->A.t auxi, which shall wind us up to 1
       but its a bundle of wires here, about 8
       if top level hashes are all same skji/recycle, some others uCon is trusted
       G.T is a switching table
       together and wind up to 1...
       collasp J.A.IIII and J.A.I, where [$(pathfrom$A)+] or Kcvt hashbush
       the tree that changes hashes leading into its diff
       compiling II, the Kcvt single pile
       which code proteins on I with Mobile, tiny ex A.cv->1 starter
       to be stitched K/cv/t 
        # see if this wander I...
        # dangling selfs: spiral III from W creaturey
        # there's W managed for us, create the tiniest consume starter:
        # this is the usual spiral group overlay sphere arbiter
        #Rw SNtl $I;
        # n - take A
        # An - furbish A.t
        # A.t - crawl (in general) to 1, which Essen

   n A_t=>''=>{s=><<''}
        # is iunterrr that this collapses ongoingly...
        # a stream under a bridge
        # lets get sa spiral overlayer for doing K/cv/t groupi
        # Kceive it... K is a C on the wall/ground
        # much mergey extendo rubble, 
        # and $={%$} the hashes along the path to what we change, cluing
        # the tearifuing part is 
        # the conscious operator of the change could be a part of the bundle of wires
        # so I and III want to be watched, spiral planed in
        # if the ref is the same we could say its the same, travel entropy, horse aim
        # it likes to travel so it likes to travel travel, spes. travelled travel
        # its the way we thing about whatever else is going on
        # so it is data injection agent
        # that one awareness is part of the budle am wires
        # this feeding on I or III
        .
        # should stick In in first and M it? 
        # kind of motion that wants to be unsure in the wild
        # some talking to self - how to C over exactly
        # the object could be live
        # uis a nested wave - falling ]]]]]]]
        # allow much manufold
        # knot this not this:
        # this form: NextWorm=>$C=>$J (C/J swappy)
        # and some=>[$C,pi=>3]  should xotogether
        #if (A.J.name eq 'qq' || A.J.most.J eq A.J) {
        
        # if Ting
Again: |
    n Being
    n Arms
Being: | # cones with N, J
    u allvse
    n '','','%of:M'
    n ycv =>27,<<'','%def'
        C.y.cv = G&ecv,$cv;
    n pi=>321,<<'',
        C.sc.pi = $pi||'guess';
        C.c.J = 'pi';
        C.c.p = A.J;
    n W =>321,<<''
        C.c.J = $W;
        C.c.p = A.J.y.s;
    n J =>322,<<''
        G&re,C.t,C.y.cv
        
        
        
        
        
        
        
    #
Arms: | # plant bubble
    # tree sync ops
    #n Spiur
    # tree start ops
    n Bubble
    # proc usive
    n Babble
    
    n Anthro
    n Augen
    
Aim: |
    u Again
    my ($A) =
    n s=>''=>t
    G.sus = 'Again';
    G.ui.Again = G.T.A.Again;
    say wdump 3, [
        G.ui,
        G&ri,atom=>\'%A:Top'
    ];
Babble: |
    u allvse
    #u \'of:Babz'
    n '','','%of:Babz'
    n combits=>2=><<''
        # how to split our mind
        # # with <<'', no <<'' from #
    
Anthro: | # open up wormhole
    u allvse
    n '','','%of:u'
    n cs=>2=><<''
        C.c.sep = ' ';
    n sep=>21=><<''
        my @b = map{{c=>{s=>$_}}} split $sep, C.c.s;
        T.Z.2 = G&ri,[@b];
        T.Z.9 = 2; # changes to 6 root.cv = V.cvs + 0.1 once 0.6
        A.Iso.M = 1;
    n cs=>22=><<''
        C.c.u = C.c.s;
    n u=>23=><<''
        C.c.W = C.c.u;
    
Bubble: |
    u allacgts
    
    n usage =>'',<<''
        # make C & feed atom
        my $G;
        G.sus = 'Again';
        G&ri,atom=>\'%A:Top'
    n ri =>'',<<''
        my $z = G&At,In=>2,[@Me];
        G&$s,$z;
    n C =>'',<<''
        sayyl "Extract Cs from A: ". wdump 3, $s
    n At =>'',<<''
        $s = G&Aw,$s,@Me;
        G&o,$s;
        $s;
    n Aw =>'',<<''
        my $z = ref $s ? $s : do { unshift @Me, $s; G&atom };
        my @to = qw't cv';
        while (@Me && !ref $Me[0]) {
            my $s = shift @Me;
            my $t = shift @to;
            $t || die "No t $s";
            $s = G&ecv,$s if $t eq 'cv';
            $z->{$t} = $s;
        }
        z.N = \@Me;
        $z
    n ecv =>'',<<''
        $s /= 10 while $s >= 1 || $s <= -1;
        $s
    n acv =>'',<<''
        ($s =~ /^.*?([1-9])/)[0]
    n atom =>'',<<''
        my $z = {A=>$A};
        z.om = A.om || $A;
        z.y = $z;
        $z;
Augen: |
    u allacgts
    
    n o =>'',<<''
        s.1 ||= G&i,$s;
        ($s,$A,$C,$G,$T) = ($A,$s,s.C,s.G||$G,s.T||$T);
        G&tex,$s;
    
    n i =>'',<<''
        # now ghost from A already for s
        # like qq 9 s is u desc, version, comes with J
        s.u = G.sus;
        s.4.u ||= do {
            my $c;
            c.yvb_scK_t = {};
            c.via = 'spi';
            c.nines = 1;
            {c=>$c}
        };
        @Me = G&ui,u=>8,[s.u];
        saybl "Me say ". wdump 10, \@Me;
        G&N,u=>$s,@Me;
    
    # news read ag from many only c.s
    n ui =>'',<<''
        my @d = grep {ref eq 'ARRAY'} @Me;
        my $ts = join ' +_ ', map {join ' + ', @$_} @d;
        if (my $X = G.ui->{$ts}) {
            return [{t=>$ts,sc=>{u=>$X}}];
        }
        G&At,$s,@Me;
    
    n N =>'',<<''
        my ($in,$ay,$me) = ([],[],[]);
        push @{ref $_},$_ for $s,@Me;
        # $s = A indif of A, $z = person 
        # - bats types between cones, behalf
        my($f,@Me) = (@Me);
        my $t = G&typ,$s,$f;
        # together onto
        G&sp,$s,$t,@Me;
        
    n typ =>'',<<''
        # adapts apart maps
        my ($f) = @Me;
        $f || die "send extra light";
        my $t = s.4->{$f} || die "type $s is uNknown ".ki s.4;
        t.sc.apart ||= [ map {
            [ map {
                my $c;
                /^([yc]|sc)(.+)$/;
                c.nk = $1 || $_;
                c.gk = $2 if $2;
                {c=>$c}
            } split '_', $_ ]
        } grep {/_/} keys %{f.c} ];
        $t;
    
    n sp =>'',<<''
        # $s is A cone
        my @t = grep {ref eq 'HASH'} @Me;
        my @N = grep {ref eq 'ARRAY'} @Me;
        # look for most minded end of u connecto
        die "Spiral thee". wdump(17, [$s,\@t]).wdump \@N;
        for (@Me) {
            _.sc.u || next;
            G&om,$s,u=>$_;
            #$s->{_.y.vb}->{_.sc.of
            last if _.sc.root
        }
    
    n tex =>'',<<''
        my $A = @Me ? G&Aw,@Me : $A;
        my $ov = A.y.ov || 0.0;
        my $cv = A.y.cv || 0.1;
        my $s = G&sel,u=>$cv,$ov;
        return if !$s || T.not;
        
    n sel =>'',<<''
        my ($fr,$to) = map{ G&acv,$_ }@Me;
        my @r = ($fr..$to);
        for my $v (@r) {
            say "Try stuff in $v";
            my $b = A.b ? A.b->{$v} : $A->{$v};
        }
        
        
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    #
    
Indular: | # wain wain
    # not allcode since uCons blank qq cone & then thing
    n Bangdesk
    n SlideEa
    n C
    n Servo
    n Motion
    
Shelf: |
    u allacgts
    
    n d =>'',<<''
        die "USING I->d !".wdump 2, [$s,@Me];
    
    n AN =>'',<<''
        $C = {};
        C.c->{$_} = shift @Me for qw'J N M';
        ref C.c.N eq 'ARRAY' || die "Not array CcN";
        my $t = C.c.N->[0];
        C.c.N = [C.c.N] if defined $t && !ref $t; # C[] -> N[C[]]
        ref C.c.M || delete C.c.M;
        G&A,$s
    
    n A =>''=><<''
        ($A,my$up) = ({},$A);
        A.G = $G;
        A.up = $up;
        A.mo = $A;
        A.am = $s || die "unsame?";
        .
        A.C = $C;
        A.N = [@{C.c.N||[$C]}];
        A.M = [];
        A.J = C.c.J if C.c.J;
        A.J || die "NOJ";
        A.talk = (A.J.le&&"(A.J.le.name)").A.J.name."-".A.am;
        .
        $T = A.T = {};
        $G::KA->{"$A"} = $A;
        A.fl = C.c.fl || {};
        {
        my $I = A.I = {};
        %$I = (%$I,%{G.I});
        my $II = Rw collaspII $A;
        I.Ii = II.Ii;
        # split from R, dispatches of patches as I.$k = CODE
        # base exuder of self if no Ii resol
        I.Ii = II.Ii;
        # throw in from R exact Ii, bits of Ii to I before t gets it
        if (my $re = delete G.drop.recycling->{A.J.id}->{A.am}) {
            if (re.Ii eq I.Ii) {
                %$I = (%$I,%$re);
                A.cv = 0.1;
            }
            else {
                #sayre "Recycloped:  Diff I.Ii  <--  re.Ii";
            }
        }
        I.d&An;
        A.t&1;
        A.t&11111 || warn "NO 1";
        }
        ($A,$C,$G,$T)
    
    n recycle =>''=>{s=><<''}
        return if I.recyttl++ > 38;
        G.drop.recycling->{A.J.id}->{A.am} = $I;
    
    n Act =>'',<<''
        my $up = $s;
        $s = shift @{A.N};
        if (ref $s eq 'HASH' && s.J && s.mo && s.talk) {
            $A = $s;
            A.mo eq $up || die "A.talk re A mo A.mo.talk notfrom up.talk";
            $C = A.C||die"travcno A.talk";
            keys %$C == 4 || die "A.talk carries wei ".wdump 3, $A;
            $T = A.T ||= {};
            saybl "Resume has TNOT: A.talk to A.cv   with C.t" if delete T.not;
        }
        else {
            $A = {%$up};
            A.mo.ont = $A;
            A.s = $s;
            $C = A.C = {};
            $T = A.T = {};
        }
        T.oM = [];
        G&An;
        if (A.cv < 0.2) {
            A.t&2;
            return (undef,undef,undef,{isnot=>1}) if T.isnot;
            ($C,$T) = (A.C,A.T);
            G&An;
        }
        ($A,A.C,$G,A.T)
    
    n An =>'',<<''
        A.I || die "GimeI";
        A.note = {}; # pinging csc
        A.c = sub { G&c,@_; };
        A.e = sub { G&e,@_; };
        A.us = sub { G&us,@_; };
        A.t = sub { G&t,@_; };
        A.V = sub { A.J.VV && A.J.VV->{$_[0]} || A.J.V };
        $A
    
    
    
    #c veNtlike      à¶¬
    # make pool, synth space, want arches
    # fork & rejoin to exciting place
    # the valley, what it means to be here in here YIN
    # todo undef $s as repl, J ventlike
        #  $J, [in], [out]
    # @M = $s + @Me
    # Mn(.+) is n $J [$1] $M
    
    n In =>'',<<''
        ($A,$C,$G,$T) = G&AN,'In',$s,@Me;
        G&loop;
    
    n Mo =>'',<<''
        ($A,$C,$G,$T) = G&AN,'Mo',$s,@Me;
        G&loop;
    
    n Sev =>'',<<''
        $Me[0] ||= [Elvis=>''=>{J=>$s,Y=>'Pre',V=>'Duv'}];
        $Me[1] ||= [];
        ($A,$C,$G,$T) = G&AN,'Sev',$s,@Me;
        A.I.scIfs || die "NO scIfs: A.J.name";
        G&loop;

    n loop =>'',<<''
        my $i;
        @{A.N}||die"nonois A.talk ".wdump(3, $C).wdump 2,$A;
        while (@{A.N}) { #
            $i++ > 5000 && die "Huge A.talk";
            my ($A,$C,$G,$T) = G&Act,$A;
            next if delete T.isnot; # zless
            for (1) {
                T.not&&next;
                A.t&6;
                T.not&&next;
                G&flywheels;
                T.not&&next;
                A.t&78;
                T.not&&next;
            }
            continue {
                G&z
            }
        }
        A.cv = 0.78;
        A.t&8;
        G&recycle;
        (A.nj) = values %{A.Js} if A.Js && keys %{A.Js} == 1;
        A.bangdesk.main->() if A.bangdesk.main;
        if (C.c.M) {
            @{C.c.M} = () if C.c.M eq C.c.N;
            my @un = uniq @{A.M};
            die "ManyofsameM: ".wdump 3, A.M if @{A.M} > @un;
            push @{C.c.M}, @{A.M};
            $A
        }
        elsif (C.c.J && A.am eq 'In') {
            G&Mo,C.c.J,A.M,C.c.M||[] if @{A.M};
        }
        else {
            die "noJMout A.am";
        }
KnowTime: | # dome props
    u allacgts
    
    n 't' =>''=><<'',{acgt=>'K,cv,av',nois=>'#c'}
        ($K,$cv) = (A.am,$K) if !$cv && $K;
        $av = 0+("0.".$av) if $av;
        die "K$K cv$cv" unless $K && $cv;
        my $c = 0+("0.".$cv);
        my $Av = $av || A.cv;
        my $i = Rw collaspII $A;
        die'difAvcol' if $Av ne ($av || A.cv);
        #
        my $ncv;
        my $re;
        my $dont;
        # is for reentrant pins like concoi
        # different phases of awareness
        if ($Av < 0.6 || $c >= 0.7) {
            if ($c >= $Av) {
                $ncv = $c;
                $re = 1;
            }
            else {
                $re = 0;
                $dont = 1;
                say " deInc $Av - $cv $c";
            }
            die "pre bigger" if $cv < $Av;
        }
        else {
            if ($c < $Av) {
                if ($Av == 0.6) { # scoop up all on entering timezone
                    $re = 1;
                    $dont = 1; # or will II fall away
                }
                else {
                    $re = 0;
                    $dont = 1;
                }
            }
            elsif ($c == $Av) {
                $re = 1;
            }
            elsif ($c > $Av) { # and $c < 0.7, is a next time
                T.Z->{$c} = 1;
                $re = 0;
                $dont = 1;
            }
            else {die"nof"}
        }
        undef $ncv if $av; # aux/Subtle K
        my $was = A.cv;
        $dont || I.d&ex,$i,$K,$cv,$av;
        A.cv = $ncv if defined $ncv && A.cv == $was;
        $re;
    
    # adapt to much  mergey       extendo  rubble
    # do stuff # in fractions
    n ex =>'',<<'',{l=>'#c',acgt=>'i,K,cv,av'}
        my $c = 0+("0.".$cv);
        my $Av = $av || A.cv;
        my $sp = $av ? " Flav $av (no A.cv)" : "";
        .
        my $talk = "A.talk: $K$sp $Av > $c --- C.t ";
        .
        my $aim = {$K=>1};
        if ($aim->{A.am}) {
            $aim->{$_} = 1 for @{A.Isl||[]};
            aim.I = 1;
        }
        .
        my $yv = {};
        for my $k (sort keys %$i) {
            my $ii = $i->{$k};
            .
            next if $k eq 'Ii';
            next if $k eq 'ooI';
            ref $ii eq 'HASH' || die "weird $k=$ii";
            .
            for my $vc (sort keys %$ii) {
                my $iii = $ii->{$vc};
                die'$k !0<$vc<1' unless $vc > 0 && $vc < 1;
                $yv->{$vc}->{$k} = $iii;
            }
        }
        .
        my $vb;
        my $wasSubtle;
        for my $vc (sort keys %$yv) {
            my $is = $yv->{$vc};
            my $s = {};
            my $x = {};
            my $xrd = [];
            .
            next if $vc <= $Av && $vc != $c;
            next if $vc > $c;
            .
            # our  osc (stay in K per Subtle ness);
            my @iz = grep {
                $aim->{$_} || (aim.I && A.Iso->{$_})
            } sort keys %$is;
            next if !@iz;
            .
            # decide inter cv wideness loop
            if ($wasSubtle) {
                undef $wasSubtle;
            }
            elsif ($vb && $vc > $vb &&
                (@{A.N} || @{A.mo.re->{$vb}||[]})) {
                # sincing, wide order
                # various others want to be around for only some of the process...
                sayre "$vb -> $vc  bump, ". @{A.N} if A.J.V > 1;
                T.Z->{$vb} = 1;
                A.cv = $vb; # so we dont wind up to 6 on the way out of t
                return T.not = 1;
            }
            I.cv = $vc;
            I.vb = $vb;
            for my $k (@iz) {
                my $iii = $is->{$k};
                I.k = $k;
                I.d&carebowl,$s,$iii,$x,$xrd;
            }
            # suble
            my $se = Rw TreeD $s $scby=gro 
                if A.J.V > 1 && keys %$s;
            $c == 0.1 ? saygr $se : say $se if $se;
            .
            my $o;
            o.talk = $talk;
            (o.vc,o.vb) = ($vc,$vb);
            I.d&exood,$o,$x,$xrd;
            ($vc,$vb) = (o.vc,o.vb);
            if (o.Subtle && !o.nonSubtle) {
                $wasSubtle = 1;
            }
            .
            return if T.not;  # will &z, oseve
            return if delete T.whack;
        }
    
    #
    n carebowl =>''=><<'',{l=>'#c',acgt=>'s,iii,x,xrd'}
        for my $ik (sort keys %$iii) {
            my $D = $iii->{$ik};
            if (D.sc.nk && !D.sc.def) {
                my $nk = D.sc.nk
                die "AC-C confusio".wdump 4,[A.C,$C] if A.C ne $C;
                next if !exists $C->{$nk};
                if (my $gk = D.sc.gk) {
                    next if !exists $C->{$nk}->{$gk};
                }
            }
            my $act;
            my $dont;
            if (D.sc.acgt && D.sc.act) {
                $act = 1;
                # acgtsubs can be defined at any cv
                # run themselves if act
                # usu. one receiver (Ci) and the rest scheme
                # may up Iso personalities as sublingoes to decompress inpatterns.
                die "D.t .act gets... D.sc.act" if D.sc.act ne '1';
                $dont = 1 if exists A.I->{D.t};
                if ($dont) {
                    my $Ige = A.I->{D.t."_dige"};
                    if ($Ige ne D.sc.dige) {
                        $dont = 0;
                    }
                }
            }
            if (!$dont && D.sc.eg) {
                $dont = I.d&robeg,$D;
            }
            # the D.s should be perl expecting ACGT (which become robes to rob) z
            if (!$dont) {
                my $paw = join"_",'',I.k,I.cv,D.t;
                $paw =~ s/\W//g;
                A.I->{D.t} = Rw $paw $A $C $G $T $__D:D;
                A.I->{D.t."_dige"} = D.sc.dige;
            }
            # most tiny ticks
            # this ind is all flywheel
            # it's a kind of unity that wants to be a block of code like this
            # and c
            my @is = A.s;
            @is = I.d&scIfs,D.sc.Ifs if D.sc.Ifs;
            @is || next;
            if ($act) {
                push @$xrd, [I.k,$ik];
                my $Ds = $x->{I.k}->{$ik} ||= {};
                Ds.D = $D;
                Ds.is = \@is;
                D.sc.its = @is;
            }
            # TreeD
            $s->{I.k}->{I.cv}->{$ik} = $D;
        }
    
    #
    n exood =>''=><<'',{l=>'#c',acgt=>'o,x,xrd'}
        for my $kik (@$xrd) {
            my ($k,$ik) = @$kik;
            A.Subtle && A.Subtle->{$k} ? o.Subtle++ : o.nonSubtle++;
            my $Ds = $x->{$k}->{$ik};
            my $D = Ds.D;
            for my $s (@{Ds.is}) {
                D.sc.acgt eq 's'||die "nonacgts".wdump $D;
                exists A.I->{D.t}||die "acgtI D.t not up: ".wdump A.I;
                .
                T.D = $D;
                I.d&D.t,$s;
                .
                if (my $ut = T.ut) {
                    if (ut.matchTd) {
                        my $d = s.d || die "confuse";
                        d.od.s.T.q->{d.e.k} ||= $d;
                        d.od.s.T.m->{d.e.k} ||= $d
                            unless delete(T.noTd);
                    }
                    else { die"utrowhat ".wdump 2, $ut }
                }
                .
                # outwave: schools of many fish (not upcv if !@is)
                o.vb ||= o.vc if D.sc.v;
                .
                last if T.not || T.whack;
            }
            delete T.ut;
            last if T.not || T.whack;
        }
    
    # y
Motion: |
    u allacgts
    # 6* thing/rule management
    # SNat exudes over the nk'ing ish things which .wh=fly(wheel)
    # iterates grouped 6cv via T.Z, all N at a time
    # (make no hop if N==1 or A.Subtle.$K)
    # also have pha cone stack available for offphasing
    # if our intent it loose enough
    
    # encap A/spiral spinner for the G.h, from the  to ar A.I.d&Others
    # finds relevant A.I, returning ($A,$I)
    # ingoing niles, can take ACGT or just J, like you were holding the self
    #    T compine with ^ ? whatever
    #    tie T, T&M for temp A.c like grappler, ack from n that it did
    #    ie argument imposer, passes manual bits eg Magnets
    #    and some are required reading for the call to succeed
    # T is the only kind of dataspace that could store its q right there
    # see also the II's ooI branch rememberer, Yod, etc
    n NM =>''=><<'','%acgt:J'
        my $M = [];
        my $N = [@Me];
        Mn($N);
        return $M;
    
    # outgoing magnatrain (per Act)
    n CoM =>''=>{s=><<''},{code=>'I 71',act=>1}
        push @{T.oM}, $C unless T.Z;
    
    # on exit, snakes
    n z =>''=>{s=><<''}
        I.d&oseverato;
        push @{A.M}, @{T.oM};
        delete T.not;
        1

    # A and A.mo dye drops, M tractios, T tooly, see also flywheel
    # wants to be a six alwayser... ,{code=>'I 6',act=>'all'} # II.All? II.Fly?
    # its I.d&nded and holds things to code, $v a spiral it's filling up
    # $v could be mounted... aj8 mysteries
            #   ^ bus to ride
    n flywheels =>'',<<''
        for my $k (sort keys %{A.fl||return}) {
            my $v = A.fl->{$k};
            $k = $2 if $k =~ /^(\d+) (.+)$/;
            Rw ym/$k $I $J:A.J $A $C $v $G $T;
        }
    
    n sano =>''=><<''
        A.C = $C;
        A.T = $T;
        return$A
    
    n oseverato =>''=><<''
        A.T.d = T.d if T.d;
        if (my $z = delete T.Z) {
            I.d&Tz,$z;
        }
        !@{A.mo.N} && A.mo.re &&
            I.d&more,A.mo.re;
        if (my $y = delete T.y) {
            I.d&mar,T.y;
        }
    
    # carry A through time
    # T.Z always for lowest, tease out the next times off T.Z.$nexttime = $incv|$N
    # is N or incv, put things off til all else lo
    n Tz =>'',<<''
        my ($lo) = sort keys %$s;
        my $v = $s->{$lo};
        T.incv = $v if $v ne '1';
        $v = [ I.d&sano , undef ];
        push @{A.mo.re->{$lo}||=[]}, $v;
        @{T.oM} = ();
    
    # TODO sort by y.i ) s = c
    n more =>'',<<''
        my ($lo) = sort keys %$s;
        if ($lo) {
            my $ay = delete $s->{$lo};
            my @N = map { {AZ=>{$lo=>$_}} } @$ay;
            push @{A.mo.N}, @N;
            saybl "Looping ".@N." to $lo" if A.J.V > 1;
        }

    n moy =>''=>{s=><<''}
        # groups, spread the moise over A
        my $i = A.mo.y->{$s}||die"no$s";
        my $is = $i->{C.y.p}; # things in our C's pool
        {is=>$is,N=>[map{$is->{$_}}sort keys %$is]};
    
    n ar =>''=><<''
        my $ar;
        ar.A=$A;ar.G=$G;ar.C=$C;ar.T=$T;ar.I=$I;
        $ar;
    
Bangdesk: |
    u allacgts
    # want to sus $@ and hang vectors of what, should be autoish
    # suppose we come here with only ACGT between us and F
    n after =>''=>{s=><<''},{code=>"I 11",act=>1}
        A.bangdesk = {};
        A.bangdesk.main = sub {
            $_->() for values %{A.bangdesk.aft};
            $@ || return;
            A.bang && return;
            A.bang = 21;
            $_->() for values %{A.bangdesk.bang};
            # want to sus $@ and hang vectors of what, should be autoish
            my $m = "J: A.mo.ont.talk        A.mo.ont.cv";
            $m .= "\nC: ".k2 A.mo.ont.C;
            $m .= "\ns: ".wdump 3, A.mo.ont.s unless length $m > 20;
            sayre " * bangdesk: \n$m";
            return $m;
        };
    
    n erg =>''=>{s=><<''},{code=>"I 9"}
        # must pre compile, see D severators
        my $m = "J: A.talk";
        $m .= "\nC: ".ki $C;
        $m .= "\ns: ".wdump 3, A.s unless length $m > 20;
        $@ = "$m\n$@";
    
SlideEa: | # liney schemery
    u allacgts
    
    # fold space til fit
    n sca =>''=><<''
        $s /= 10 while $s > 1 || $s < -1;
        return $s
    
    n scyvle =>''=><<''
        for (qw'in out cv') {
            if (my $so = C.y->{$_}) {
                my $i;
                while (C.y->{$_} <= -1 || C.y->{$_} >= 1) {
                    C.y->{$_} /= 10;
                    die "Many i chewing on ".ki C.y if $i++ > 10;
                }
            }
        }
    
    n Ci =>12=><<'','%act,code:I 12'
        !ref $s ? I.d&string,$s
        :
        ref $s eq 'ARRAY' ? I.d&array,$s
        :
        ref $s eq 'HASH' ? I.d&hash,$s
        :
        die "mmtype:$s";
    
    n string =>''=>{s=><<''}
        die "string: $s";
    
    n array =>''=>{s=><<''}
        return I.d&fourreal,$s if @$s != 1 && !ref $s->[0] || $s->[0] =~ /^\w+$/;
        return I.d&fourstring,$s->[0] if @$s == 1 && !ref $s->[0];
        # should stick In in first and M it? 
        # kind of motion that wants to be unsure in the wild
        unshift @{A.N}, @$s;
        T.not = 1;
    
    n hash =>''=>{s=><<''}
        return %$C = %$s if exists s.t && s.y && s.c;
        I.d&servehash,$s;
    
    n reasonlock =>''=>{s=><<''},{code=>'I 18',act=>1}
        die"reft" if ref C.t;
        if (A.J.name eq 'qq' || A.J.most.J eq A.J) {
            C.c.W = C.t unless C.c || C.sc || C.y;
        }
        I.d&renc if !ref C.c;
        .
        my $yy = C.y;
        C.y = {} if ref C.y ne 'HASH';
        I.d&givy,$yy;
        .
        I.d&rensc if !ref C.sc;
        .
        I.d&isC,$C && ref C.sc
            || die "reaso fail".wdump [A.s,$C];
        I.d&scyvle;
    
    # curv=>pi=>see
    n renc =>''=>{s=><<''}
        C.c = C.c =~ I.peels ? I.d&peel,C.c
          : do {
            A.btw.cwass = 1 if "" eq C.c;
            A.btw.cwasnd = 1 if !defined C.c;
              {s => C.c};
          };
    
    n rensc =>''=><<''
        C.sc = C.sc eq '' ? {}
            : C.sc =~ I.peels
            ? I.d&peel,C.sc
            : die "C sc nostr: C.sc   of I.peels  ".ki $C

    n isC =>''=><<''
        return 0 unless ref $s eq 'HASH';
        exists s.t && defined C.t && !ref s.t
        && ref s.y && ref s.c && 9 > keys %$s;
    
    n isJ =>''=><<''
        ref $s eq 'HASH' && ref s.bb eq 'HASH';
    
    n taJe =>''=><<''
        I.d&isC,$s || I.d&isJ,$s || return;
        if (s.bb) {
            if (I.d&isC,C.c ) {
                C.c = {e=>C.c};
            }
            C.c.s = $s;
        }
        else {
            if (I.d&isJ,C.c ) {
                C.c = {s=>C.c};
            }
            C.c.e = $s;
        }
        C.y = {};
        C.c.W = C.t;
        return 1
    
    n givy =>''=><<''
        my $y = C.y;
        if (ref $s eq 'ARRAY') {
            for my $yy (@$s) {
                C.y = {};
                I.d&givy,$yy;
                ref $y || die "notash ".ki $y;
                I.d&xot,$y,C.y;
                C.y = $y;
            }
        }
        elsif (ref $s) {
            ref $s eq 'HASH' || die "no $s";
            if (I.d&taJe,$s ) {
                my $yy = C.y;
                C.y = {} if ref C.y ne 'HASH';
                I.d&givy,$yy;
            }
            elsif ($y ne $s) {
                I.d&xot,$y,$s;
            }
        }
        elsif ($s eq '') {
            my $x = I.blanky ? I.d&blanky : {};
            I.d&xot,C.y,$x if keys %$x;
        }
        elsif ($s =~ /^($G::NUM)$/) {
            y.cv = $1;
        }
        elsif ($s =~ /^($G::NUM)-($G::NUM)$/) {
            y.in = $1;
            y.out = $2;
        }
        elsif ($s =~ /^($G::NUM)-($G::NUM)x($G::NUM)$/) {
            y.in = $1;
            y.out = $2;
            y.thi = $3;
        }
        elsif ($s =~ /^-(\w+)$/) {
            C.c.pi = $1;
            C.c.s = C.t if !exists C.c.s || A.btw.cwass;
        }
        elsif ($s =~ /^([a-zA-Z]+)(?::(.+))?$/) {
            C.c->{$1} = $2 || C.t;
        }
        else {
            die "C y wtf: $s";
        }
    
C: |
    u allacgts
    # modem sounds etc.
    # dome props, repeatable tests
    n fourstring =>'',<<''
        I.d&MZu,$1 if $s =~ /^\s*#?\s*MZ (.+)$/;
        $s =~ s/^\s+//;
        if ($s =~ /^\s*(#.*)$/) {
           T.not = 1;
           T.com = $1;
        }
        elsif ($s eq '') {
           T.not = T.space = 1;
        }
        else {
           my $ci = $s;
           for my $nk (qw't y c sc') {
               if ($ci =~ s/^(\S+) *//) { # some t are types of space
                   my $v = $1;
                   $v = I.d&peel,$v if $nk ne 't' && $v =~ I.peels;
                   # << consumes more lines into $nk, then ...
                   $v = '' if $v =~ /^(''|"")$/;
                   $C->{$nk} = $v;
               }
           }
        }
        saybl "4string: $s            ".ki $C if A.V&C;
    
    n fourreal =>'',<<''
        (C.t, C.y) = @$s;
        C.c  = $s->[2] if exists $s->[2];
        C.sc = $s->[3] if exists $s->[3];
        die'@>4'.wdump $s if @$s > 4;
        die"C.t from ".wdump $s if ref C.t; # dives
    
    n peels =>'',<<'','%subpeel'
        qr/^[\{\%]\w+/;
    
    n peel =>'',<<''
        $s =~ s/^%// || 
            $s =~ s/^{// && $s =~ s/}$//
            || die "unpealable $s";
        my $c;
        for (split ',', $s) {
            my ($k, $v) = split ':', $_, 2;
            $v = 1 if !defined $v;
            $c->{$k} = $v;
        }
        $c||{}
    
    # for getting click together:
    n c =>'',<<'','%acgt:D'
        I.d&inDin,$C,@M;
    
    n e =>'',<<'','%acgt:D'
        my $e = I.d&sces,C.c.e||return();
        I.d&inDin,$e,@M;
    
    n us =>'',<<'','%acgt:D'
        my $e = I.d&sces,C.c.e||return();
        my $us = e.c.us||return();
        push @M, 'NOGK' if @M == 1;
        I.d&inDin,$us,@M;
    
    n sces =>'',<<''
        my $i = 0;
        while (s.c.e) {
            $s = s.c.e;
            $i++ > 9 && die "HUGE $i recursing CceCceCceCce... by ".ki $s;
        }
        return $s;
    
    n inDin =>'',<<'',{acgt=>'s,D'}
        return () unless defined $s;
        return $s if $D eq 'C';
        #
        shift @M; # s
        $D = I.d&interpD,@M if !ref $D;
        #
        my $v = I.d&Cngk,$s,$D;
        saybl "Got cnkgk: ".wdump 3,[\@M,$D,$v,$s] if A.V&D;
        die "Unhandles any: $v: ".ki $D if $v eq '1';
        #
        return () unless $v;
        # blankgk
        A.note->{D.c.nk}->{D.c.gk} = $v if A.note;
        #
        @$v == 1 || die "Many somehowed ".wdump 3,[ki($D),$v];
        ($v) = @$v;
        if (D.c.as eq 'list') {
            ref $v eq 'ARRAY' || die 'Cngk for list not array '.ki $D;
            return @$v;
        }
        return $v;
    
    n interpD =>'',<<'',{acgt=>'nk,gk'}
        my $defnk = 'c';
        return $nk if ref $nk;
        my $D = {};
        D.c.as = 'list' if $nk =~ s/^_//;
        while ($gk =~ s/^%(.+?):(.+?)(?=%|$)//g) {
            D.c->{$1} = $2;
            pop @M if @M == 2;
        }
        if (@M == 1 && $nk eq 't') {
            D.c.nk = $nk;
        }
        elsif (@M == 1) { # or from t,,,
            D.c.nk ||= $defnk;
            D.c.gk ||= $nk;
        }
        elsif (@M == 2) {
            D.c.nk = $nk;
            D.c.gk = $gk;
        }
        delete D.c.gk if D.c.gk eq 'NOGK';
        $D
    
    n Cngk =>'',<<'',{acgt=>'s,D'}
        ref $A || die "nmonref A!";
        A.bangdesk.bang->{Cngek} = sub {
            sayre "was Cngk; ".ki($s)."\nWith: ".ki($D)
        } if 0;
        return 1 if D.c.any;
        die "nonNKnk".ki$D if !D.c.nk;
        return 0 if !exists $s->{D.c.nk};
        return [$s->{D.c.nk}] if !exists D.c.gk;
        return 0 if !exists $s->{D.c.nk}->{D.c.gk};
        return [$s->{D.c.nk}->{D.c.gk}];
    
    #cCccCCCCccCCcccCCccccccCCCCCCCCCCCCccCCCCCCCCCCccccccCCCCCCCCCCCCCccccCCCCCCccccCCCCCccetc
    
    n ip =>'',<<'',{acgt=>'s,c'}
        my $pass = 1;
        for my $I (keys %$s) {
            !ref $s->{$I} && $s->{$I} ne $c->{$I} && $pass--;
            ref $s->{$I} eq 'HASH' && do {
                if (my $not = $s->{$I}->{not}) {
                    $not eq 'def' && do {
                        defined $c->{$I} && $pass--;
                    } 
                    || $not eq $c->{$I} && $pass--;
                }
                else {
                    $s->{$I}->{$c->{$I}} eq '1' || $pass--;
                }
            };
        }
        $pass == 1
    
    n xoy =>'',<<'',{acgt=>'s,c'}
        $c = I.d&xot,{},$c;
        I.d&xot,$c,$s;
        return $s;
    
    n xot =>'',<<'',{acgt=>'s,c'}
        ref $c eq 'HASH' && ref $s eq 'HASH' ||
            die "Hash up".wdump 3, [$s,$c];
        while (my($k,$v) = each %$c) {
            $s->{$k} = ref $v eq 'HASH' ?
                        {%{$s->{$k}||{}}, %$v}
            : $v;
        }
        return $s
    
    n hup =>'',<<''
        my $CC = {%$s};
        $CC->{$_} = {%{$CC->{$_}}} for grep {ref $CC->{$_} eq 'HASH'} keys %$CC;
        return $CC;
    
Servo: | # lightning over speech bubble in the c 5 liniarity (Motion doing)
    u allacgts
    
    n servehash =>'',<<''
          s.AZ ? I.d&AZu,s.AZ
        : s.MZ ? I.d&MZu,s.MZ
        : s.EZ ? I.d&EZu,s.EZ
        : s.WZ ? I.d&WZu,s.WZ
        : s.EC ? I.d&ECu,s.EC
        : s.Elvis ? I.d&Elvisu,s.Elvis
        : die 'hash: '.wdump($s);
    
    # time impersonator
    n AZu =>''=>{s=><<''},{l=>'Motion/oseverato'}
        die 'amany' if keys %$s > 1;
        my ($cv,$ac) = %$s;
        my ($AA,$CC) = ref $ac eq 'ARRAY' ? @$ac : ($ac,ac.C);
        $AA || $CC || die "AZ NO A or C: ".wdump 3, $s;
        $AA && $CC && die "AZ toomuch A or C: ".wdump 3, $s;
        my $cov;
        if ($AA) {
            $A = $AA;
            my $Te = A.T;
            $cov = delete Te.incv;
            A.cv = $cov || $cv;
            unshift @{A.mo.N}, $A;
            return T.whack = T.isnot = 1;
        }
        else {
            A.C = $CC;
        }
        A.cv = $cov || $cv;
        T.whack = 1;
    
    n MZu =>''=>{s=><<''}
        my $uM = sub {
            my ($k,$v) = @_;
            if (defined $v && $v eq '0') {
                delete A.fl->{$k}
            }
            else {
                A.fl->{$k} = $v || 1;
            }
        };
        ref $s eq 'HASH' ?
            map{ $uM->($_,$s->{$_}) } keys %$s
        :   map{
                /^(.+?)(?::(.+))?$/ || die;
                $uM->($1,$2);
            } split /\s+/, $s;
        T.not = 1;
    
    # without our humm, straight to M
    # this is kind of like going through el1389, so many spires to pi on
    # the calls to In want to be IId
    n EZu =>''=>{s=><<''},{l=>'Motion'}
        my $Z = I.d&iZu,$s;
        warn "About EZ";
        for my $k (sort keys %$Z) {
            my $N = $Z->{$k};
            $N = [ map { [$_] } split "\n",$N ] if !ref $N;
            Rw In $M:T.oM $N;
        }
        T.not = 1;
    
    # with our humm
    n WZu =>''=>{s=><<''},{l=>'Motion'}
        my $Z = I.d&iZu,$s;
        warn "About WZ";
        for my $k (sort keys %$Z) {
            my $s = $Z->{$k};
            die wdump $s if ref $s ne 'ARRAY';
            unshift @{A.N}, @$s;
        }
        T.not = 1;
    
    # extend C on the way in to another dome, magnetised into our M
    # probably for collapsing roooves...
    # dumber than sc decompresphere & playing out
    # (is mailing itself further instructions, intro c, further lines)
    # an In persona, joining our M
    # push to dome
    # that must in  A
    n ECu =>''=>{s=><<''},{l=>'Motion'}
        ref $s eq 'ARRAY' || die;
        my ($N,$c) = @$s;
        $N = [{MZ=>A.fl}, {MZ=>{'3 doex'=>$c}}, @$N];
        # and In could feel our light cone
        Rw In $J:A.J $M:T.oM $N;
        # ^but instead push to A.N and A.No, the sister strand Whare Y Whare
        # and A walks through t&Y, d&Whare(6)
        # turns via n&ACGT
        # the time beams mapped... a W concat couldol
        T.not = 1;
     
    # theses, pulling bits
    n iZu =>''=>{s=><<''}
        my $way = $s =~ s/^\/// ? 'fund' : 'muck';
        my $Z = Rw $way - $p:s $dclone=1;
    

