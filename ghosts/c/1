lod/C:
   wam/on: noe 0.1 eye/o {ou:eye,blur:5px}
   fresh_init: |
     Rw J5 wa;
   recoded_init: |
     Rw fresh_init;
     sayyl "YEA";
     #$G->pub('S/hut/K', 'do make/up')
     #   if $m =~ /\/k\//;  
lod/u:
   shv/curves: [EZ: floorish]
   wam/on: noe 0.1 g/k/1  {ou:eye,blur:5pt}
   fresh_init: Rw J5 wam;
   recoded_init: |
      rand(5) > 3 &&
      Rw J5 wam;
floorish: |
    spun 0 -0.12
    zoom 0 1 
    y    0  0.84 
    x    0  0
    curve 0 -0.4 
S/ghostchanges: |
    unless ($m =~ /\/k\//) {
        Rw loD;
        sayyl "loded";
        Rw recoded_init;
    } 
    Rw J5 $file:m;
S/wayup: |
       -f $m || die;
       delete G.drop; 
       $G->wayup($m);
       Rw loD;
       Rw recoded_init;
aww:
   yJ: |
     my $A = J.A = J.most.A = {}; 
     A.time = sub{ 
         my ($J,$wa) = @_;
         warn "$J, $wa";
         J.A.ztime >= $wa ? 1 : do {
             A.fopi->{J.id} = $J;
             0;
         };
     };
     'clw gui heag sope waz Atime';
waz:
    up: |
      my $coi = Rw pha $J $k=jo;
      my $M=[];
      my $y = {o=>$M};
      my $A = J.A;
      A.ztime ||= 2;
      
      
      Rw suck */M $J $A $M $y;
      
      Jn('zoo',$y) if @$M;

      Jn('hoos',0.9,'S@T');
      Rw vortex $J around $d=6;
      coi.exactl->();
      
wa:
   yJ: |
     'aww'
   M: |
    if (J.runt++ > 8) {sayre "ex";sleep 1;
        #Rw rez;
    }
    A.ztime = 4;
    #die wdump G.way.Loadc;
    Rwyl 1 wa/ps;
    Rw wa/pl -;
   ps: |
    my @ps = `ps -p$$ fu`; # j right
    my ($u, $pid, $cpu, $mem) = (split /\s+/, $ps[1])[0,1,2,3];
    sayre "$u $pid       cpu:$cpu  mem:$mem";
    if ($mem > 20 || $cpu > 30) {
        saybl "& $mem";
        if ($mem > 22) {
            sayre "massive, restarting" for 1..8;sleep 1;
            Rw rez;
        }
        sleep 5;
        
    }
   pl: |
    #Rw J5 Wkcs; 
    Rw J6 - Hosp;
    Rw J6 - Eosse;
Eosse:
   yJ: |
     'aww'
   M: |
    Mn(shedful => '', {pi=>'eye',s=>'eye/fug/1/gt'});
    Rwyl 0.1 aftor;
    Atime(4) || return;
    
Wkcs:
   yJ: |
     'aww'
   M: |
    Mn(shedful => '', {pi=>'seas',s=>'w/k w/c'});
    Rwyl 0.1 aftor;
    Atime(4) || return; 
    
Hosp:
   yJ: |
     'aww'
   M: |
    my $d = Jn(qw'life 0.1 life/H/');
    Mn(hoisp => '',{pi=>'liv',s=>d.s}); 
    
We: |
    die "J.name seeks oJ.name:  ".die wdump [oJ.A, oJ.oJ.A];
aftor: |
    my $J = J.most.J;
    my $N = Rw tyc $J;
    @$N = grep { _.sc.pi eq 'clife' } @$N;
    
    my $u = {};
    for my $C (@$N) {
        my $p = C.t;
        my $n = C.c.s;
        Rw loadup $u $p $n;
    }
    
    Rw makoo $u;
    sayyl "YEP";
    
makoo: |
       warn "we could be ".wdump [sort keys %$u];
       return;
       my $t = Rw wuck - $u */flows/*;
       my $fr = 0;   
       my $amp = G.ampampamp ||= do{$fr=1;{}};
       for my $k (sort keys %$t) {
           my $v = $t->{$k};
           my ($path,$flows,$from) = split '/', $k;
           
           Rw make/op $amp $pin:k $path $from;
       }
       my $hk = {%{R.way.hooks}};
       for my $z ($hk, $amp) {
           for my $k (keys %$z) {
               next unless $k =~ /^g_(.+)$/;
               say "Has $k";
               $z->{$1} = delete $z->{$k};
           }
       }
       my $x;
       x.wormhole.yr = $hk;  
       x.wormhole.ya = $amp;
       while (my ($dir, $v) = each %$x) {
           while (my ($k, $d) = each %$v) {
               my $y = YAML::Syck::Dump($d);
               die wdump $y if length $y < 50; 
               $y =~ s/^---//;
               encode_utf8 $y;
               fspu("$dir/$k\.yml", $y);
           }    
       }
       
       # maka yml, seeing .s is a gas leak
       `cd wormhole; cat yr\.yml ya\.yml > yb\.yml`;
       #$fr = 1;
       $fr ?
       $G->pub('S/'.$_, "reexec")
       :
       $G->pub('S/'.$_, "wayup w/yb\.yml") for 'shed','coast';
       sayyl "We o ".F_delta();
       
       Rwyl 0.1 J5 scr;
pi/seas: |
     Jn(see => 0.1 => C.s,'%hs:7398'); 
     for my $t (split /\s+/, C.s) {
         Mn($t => '', {pi=>'loadc',s=>$t});
     }
pi/loadc: |
     my $l = C.s;
     Jn(l => 0.1 => $l);
     $l =~ s/\/*$/\//;
     my @f = map{chomp$_;$_}`find $l -type f`;
     @f || die "no $l";
     for my $file (@f) {
         Mn($file => '', {pi=>'cfile',s=>$file});
     }
pi/cfile: |
     my $file = C.s;
     Jn(file => 0.1 => $file, '%hs:042');
     saybl "Loading $file";
     my $s = read_file($file);
     my $h;
     my @ks;
     while ($s =~ m/^(\S+)(:.+?)(?=^\S|\Z)/smg) {
         push @ks, $1;
         $h->{$1} = $2;
     }
     my $m = Load($s);
     #die if m.R_Jz;
     if (m.R_Jz) {
         Jn(rj=>0.2=>'R_Jz');
         return;
     }
     my $in = {map{$_=>1}@ks};
     exists $in->{$_} || die "$_" for keys %$m;
     
     for my $p (@ks) {
         my $n = $m->{$p};
         my $dig = dig($h->{$p});
         Mn($p => '', {pi=>clife=>s=>$n},{dig=>$dig});
     }
pi/clife: |
     Jn(c=>0.1=>'c'=>'%hs:8474');
     Jn(c=>0.2=>"C.t"=>'%hs:849');
     Mn(c=>'',{pi=>''=>s=>slim(30,"C.s")});
sope/out: |
    #Rw oJ $J geo &up $noesc=1;
    #Rw chuv $J;
J6: |
   Rw J5 + $ok=6; 
J5: |
   my $r = {%$ar};
   r.J = delete($r->{m})->[0] if ar.m;
   delete r.R;
   my $d;
   d.c = $r;
   Rw oo $J:G.oin $d;
etc: |
   maky something

