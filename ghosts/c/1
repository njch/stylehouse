Intt: |
    my $A = Rw WeBase In;
    my $I = A.I;
    I.d&n,$A,{},$G,{};
    I.d&An;
    A.t&1;
    A.t&11111 || warn "NO 1";
    my $i;
    while (@{A.N}) { #
        $i++ > 1000 && die "Huge Indi";
        my ($A,$C,$T) = I.d&Act,$A;
        T.not&&next;
        A.t&6;
        T.not&&next;
        I.d&flywheels;
        T.not&&next;
        A.t&78;
        T.not&&next;
    }
    continue { I.d&z; }
    A.t&8;
    I.d&recycle;
    ar.M ? do {
        push @{ar.M}, uniq @{A.M};
        $A
    }
    : ar.J ? map {
        Rw Modi + $J $C:_
    } @{A.M}
    : die "noJMout";
    
MourmaZ: | # notes
   u ashtray=>,'c ha' 
   n fdlwk=>''=>{s=><<''}
       # and from Indi
            # and whenever
            # then the things todo
            # lots ||nexts
            # elabourate C, seeming to chew
            # we want to throw our next II etc
            # transmit A,C via AZ, which and A.cv via AZ and A.II)
       in wayves it travels
       I hoist by z
       move the things out into args,name,id in I from already
       code leeching out - chov into index,
         and the brain indexes the bunch of codes run with their I...
       so I is vectored done stuff (u, che acquis)
       thatd be hard to not have at this point
       unmeni the zapping into an I is the finality...
       u bein done...
       the I gets wrenched out but it is all G via J stuff... apply 
       divide the stuff up into K/cv/t limbs
       and apply the K = diffre/OSC/ACT/OMP
       compine blobs, can want to interdesign each other if travel points further than routable
       then break things off as case...
       just like things are pooled
       the over the room code forming way selector outputs more stuff
       unified and interpreted as code to way 
       everything happens as an z Elvis, even if not in El
       so In A can acquire its wires
       and splat from A couplings
   
   n zfold=>''=>{s=><<''}
       wired up some hypnocodes from other J.A.I (& u) into G.T.$W
       then in each there each W is supposedly W overlay (way)
       and theres I/1/n,An->A.t auxi, which shall wind us up to 1
       but its a bundle of wires here, about 8
       if top level hashes are all same skji/recycle, some others uCon is trusted
       G.T is a switching table
       together and wind up to 1...
       collasp J.A.IIII and J.A.I, where [$(pathfrom$A)+] or Kcvt hashbush
       the tree that changes hashes leading into its diff
       compiling II, the Kcvt single pile
       which code proteins on I with Mobile, tiny ex A.cv->1 starter
       to be stitched K/cv/t 
        # see if this wander I...
        # dangling selfs: spiral III from W creaturey
        # there's W managed for us, create the tiniest consume starter:
        # this is the usual spiral group overlay sphere arbiter
        #Rw SNtl $I;
        # n - take A
        # An - furbish A.t
        # A.t - crawl (in general) to 1, which Essen

   n A_t=>''=>{s=><<''}
        # is iunterrr that this collapses ongoingly...
        # a stream under a bridge
        # lets get sa spiral overlayer for doing K/cv/t groupi
        # Kceive it... K is a C on the wall/ground
        # much mergey extendo rubble, 
        # and $={%$} the hashes along the path to what we change, cluing
        # the tearifuing part is 
        # the conscious operator of the change could be a part of the bundle of wires
        # so I and III want to be watched, spiral planed in
        # if the ref is the same we could say its the same, travel entropy, horse aim
        # it likes to travel so it likes to travel travel, spes. travelled travel
        # its the way we thing about whatever else is going on
        # so it is data injection agent
        # that one awareness is part of the budle am wires
        # this feeding on I or III
        .
        # should stick In in first and M it? 
        # kind of motion that wants to be unsure in the wild
        # some talking to self - how to C over exactly
        # the object could be live
        # uis a nested wave - falling ]]]]]]]
        # allow much manufold
        # knot this not this:
        # this form: NextWorm=>$C=>$J (C/J swappy)
        # and some=>[$C,pi=>3]  should xotogether
        #if (A.J.name eq 'qq' || A.J.most.J eq A.J) {
        
        # if Ting
Indulator: | # Wain spinality
    # not allcode since uCons blank qq cone & then thing
    n Bangdesk
    n IStuff
    n KnowTime
    n SlideEa
    n C
    n Servo
    n Motion
    
Indular: | # wain wain
    # not allcode since uCons blank qq cone & then thing
    n Bangdesk
    n SlideEa
    n C
    n Servo
    n Motion
    
Arange: |
    ar.N && ar.oA && ar.oA.D &&
    substr(ar.oA.D.bab, 0, 200) =~ /<<('\w*'|"\w*")/ && 
    Rw babsubrip $oA:ar.oA $D:ar.oA.D $N:ar.N;
    
    my $A = {};
    A.oA = ar.oA if ar.oA;
    A.J = ar.J || die 'noJ';
    A.G = $G; # so travel can G/T/Hypo
    A.mo = $A;
    (A.am) = ar.t || ar.name || @{delete ar.m};
    A.am || die "unsame?";
    $A;
WeBase: | # require N, required to return an A.I that I.n,I.An,A.t
    my $A = Rw Arange;
    A.N = [ar.C ||
        @{ar.N ||
            [[ar.t?(ar.t,'',{J=>A.J}):die"artnot: send C or N"]]
        }];
    A.M = [];
    A.talk = "A.J.name ".(A.J.le && A.J.le.name);
    A.fl = ar.fl || {};
    A.I = {};
    
    my $I = delete G.drop.recycling->{A.J.id}->{A.am};
    
    my $II = Rw collaspII $A;
    
    if ($I) {
        if (I.Ii eq II.Ii) {
            A.I = $I;
            A.cv = 0.1;
        }
        else {
            sayre "Recycloped, Diff I.Ii  --  II.Ii" if A.J.V;
            undef $I;
        }
    }
    
    A.I.Ii = II.Ii;
    
    if (!$I) {
        $I = A.I||die'basenoi';
        Rw SNtl $I;
    }
    $A
RB: | # inits A of ar C/N, pins spiral down (ret A.I that I.n,I.An,A.t)
    # non babzub, assume pbab skipped <<''s in origin
    my $A = {};
    
    A.oA = ar.oA if ar.oA;
    A.J = ar.J || die 'noJ';
    A.G = $G; # so travel can G/T/Hypo
    A.mo = $A;
    (A.am) = ar.t || ar.name || @{delete ar.m};
    A.am || die "unsame?";
    
    A.N = [ar.C || @{ar.N}];
    A.M = [];
    A.talk = "A.J.name ".(A.J.le && A.J.le.name);
    A.fl = ar.fl || {};
    A.I = {};
    
    my $I = delete G.drop.recycling->{A.J.id}->{A.am};
    
    my $II = Rw collaspII $A;
    
    if ($I) {
        if (I.Ii eq II.Ii) {
            A.I = $I;
            A.cv = 0.1;
        }
        else {
            sayre "Recycloped, Diff I.Ii  --  II.Ii" if A.J.V;
            undef $I;
        }
    }
    
    A.I.Ii = II.Ii;
    
    if (!$I) {
        $I = A.I||die'basenoi';
        Rw SNtl $I;
    }
    $A
SNtl: | # spiral Nat toolz
    I.n = sub { # A qcui
        my ($A,$C,$G,$T,$AA,$CC,$GG,$TT) = @_;
        I.nF = {A=>$AA,C=>$CC,G=>$GG,T=>$TT};
    };
    I.d = sub { # be, sub
        my $s = shift;
        my $P = I.nF ||= {};
        my $y = $I->{$s} || die "no way named '$s'";
        $y->(P.A,P.C,P.G,P.T,@_);
    };
    I.An = sub { # A within faller
        my ($A,$C,$G,$T) = @_;
        A.c = sub { die "An  ein!" };
        A.t = sub { I.d&t,@_ };
        $A
    };
    I.t = sub {
        my ($A,$C,$G,$T,@M) = @_;
        my ($cv,$K) = reverse @M;
        @M>2 && die "Massive M _ _";
        $K ||= A.am||die"noam A_t";
        
        my $i = Rw collaspII $A;
        
        my $c = 0+("0.".$cv);
        # global proteining vote against A, like W sourcing to wantups
        #saygr "Proteins A.talk: i.Ii" if G.protV || A.J.V;
        $c == 0.1 || die "Senbial proot $c: A.J.name";
        Rw SNat $A $C $G $T $I $i $K $cv;
        A.cv = $c;
    };
SNat: | # I.ex do  # it's in that, bubbles 
    # baseism
    my $s = {};
    my $c = 0+("0.".$cv);
    my $talk = "A.talk: $K A.cv > $c --- C.t ";
    
    my $aim = {$K=>1};
    aim.I = 1 if $aim->{A.am};
    
    my $yv = {};
    # make K/cv/t -> cv/K/t
    for my $k (sort keys %$i) {
        my $ii = $i->{$k};
        
        next if $k eq 'Ii';
        next if $k eq 'ooI';
        ref $ii eq 'HASH' || die "weird $k=$ii";
        
        for my $vc (sort keys %$ii) {
            my $iii = $ii->{$vc};
            die'$k !0<$vc<1' unless $vc > 0 && $vc < 1;
            $yv->{$vc}->{$k} = $iii;
        }
    }
    
    # do stuff
    my $vb; # in fractions
    for my $vc (sort keys %$yv) {
        my $is = $yv->{$vc};
        
        next if $vc <= A.cv && $vc != $c;
        next if $vc > $c;
            
        if ($vb && $vc > $vb && @{A.N}) {
            # sincing, wide order
            # various others want to be around for only some of the process...
            sayre "$vb -> $vc  bump, ". @{A.N} if A.J.V > 1;
            T.Z->{$vb} = 1;
            return T.not = 1;
        }
        for my $k (sort keys %$is) {
            my $iii = $is->{$k};
            
            next unless $aim->{$k};
            
            for my $ik (sort keys %$iii) {
                my $D = $iii->{$ik};
                
                if (my $nk = D.sc.nk) {
                    my $C = I.nF.C;
                    next if !exists $C->{$nk};
                    if (my $gk = D.sc.gk) {
                        next if !exists $C->{$nk}->{$gk};
                    }
                }
                my $act;
                my $dont;
                if (D.sc.acgt && D.sc.act) {
                    $act = 1;
                    # acgtsubs can be defined at any cv
                    # run themselves if act
                    # usu. one receiver (Ci) and the rest scheme
                    die "D.t .act gets... D.sc.act" if D.sc.act ne '1';
                    $dont = 1 if exists A.I->{D.t};
                }
                
                # schools of many fish
                $vb ||= $vc if D.sc.v;
                
                # TreeD
                $s->{$k}->{$vc}->{$ik} = $D;
                my $sep = $act ? "----" : ">>>>";
                sayre "DElEE $talk $k $sep $vc  D.t D.y.cv  ".ki D.sc
                    if A.J.V > 2;
                
                # way or acgt-setuping-way
                unless ($dont) {
                    my $paw = join"_",'',$k,$vc,D.t;
                    $paw =~ s/\W//g;
                    Rw $paw $A $C $G $T $__D:D;
                }
                
                # most tiny ticks
                if ($act) {
                    D.sc.acgt eq 's'||die "nonacgts".ki $D;
                    exists A.I->{D.t}||die "acgtI D.t not up: ".ki A.I;
                    I.d&D.t,A.s;
                }
                return if T.not;  # will &z, oseve
                return if delete T.whack;
            }
        }
    }
    
    A.J.V > 1 && keys %$s && saygr
        Rw TreeD $s $scby=gro;
    
IStuff: |
    u allacgt
    
    n d =>''=>{s=><<''},{acgt=>1,args=>'s'}
        # grease thje stomac
        shift; # imporo
        my $y = $I->{$s} || die "no way named '$s'";
        my $P = I.nF ||= {};
        P.A||die'PnoA!?'; # papto
        $y->(P.A,P.C,P.G,P.T,@_);
    
    n n =>''=>{s=><<''},{acgt=>'AA,CC,GG,TT'}
        I.nF = {A=>$AA,C=>$CC,G=>$GG,T=>$TT};
    
    n recycle =>''=>{s=><<''}
        return if I.recyttl++ > 8;
        G.drop.recycling->{A.J.id}->{A.am} = $I;
    
    n Other =>''=>{s=><<''}
        my $ar = $F[0]->{ar};
        $A = Rw RB + $t:s;
        $I = A.I;
        # midnight at the oasis
        I.d&n,$A,{},$G,{};
        I.d&An;
        A.t&1;
        A.t&11111 || warn "NO 1";
        ($A,A.I)
    
    n An =>101=>{s=><<''},{acgt=>1}
        A.note = {}; # pinging csc
        A.talk = "A.J.name ".(A.J.le && A.J.le.name);
        A.c = sub { I.d&c,@_; };
        A.e = sub { I.d&e,@_; };
        A.us = sub { I.d&us,@_; };
        A.t = sub { I.d&t,@_; };
        A.V = sub {
            my $bl = shift;
            A.J.VV && A.J.VV->{$bl}
            || A.J.V
        };
        $A
    
    n Act =>''=>{s=><<''}
        $A = {%$s};
        A.mo.ont = $A;
        A.s = shift @{A.N};
        $T = {};
        T.oM = [];
        I.d&n,$A,{},$G,$T;
        I.d&An;
        A.t&2;
        map{I.nF->{$_}}qw'A C T';
    
KnowTime: | # dome props
    u allacgts
    
    n 't' =>''=><<'',{acgt=>'K,cv,av',nois=>'#c'}
        ($K,$cv) = (A.am,$K) if !$cv && $K;
        $av = 0+("0.".$av) if $av;
        die "K$K cv$cv" unless $K && $cv;
        my $c = 0+("0.".$cv);
        my $Av = $av || A.cv;
        # adapt to much  mergey       extendo  rubble
        my $i = Rw collaspII $A;
        die'difAvcol' if $Av ne ($av || A.cv);
        #
        my $ncv;
        my $re;
        my $dont;
        if ($Av < 0.6 || $c >= 0.7) {
            if ($c >= $Av) {
                $ncv = $c;
                $re = 1;
            }
            else {
                $re = 0;
                $dont = 1;
                say " deInc $Av - $cv $c";
            }
            die "pre bigger" if $cv < $Av;
        }
        else {
            if ($c < $Av) {
                if ($Av == 0.6) { # scoop up all on entering timezone
                    $re = 1;
                    $dont = 1; # or will II fall away
                }
                else {
                    $re = 0;
                    $dont = 1;
                }
            }
            elsif ($c == $Av) {
                $re = 1;
            }
            elsif ($c > $Av) { # and $c < 0.7, is a next time
                T.Z->{$c} = 1;
                $re = 0;
                $dont = 1;
            }
            else {die"nof"}
        }
        undef $ncv if $av; # aux/Subtle K
        my $was = A.cv;
        $dont || I.d&ex,$i,$K,$cv,$av;
        A.cv = $ncv if defined $ncv && A.cv == $was;
        $re;
    
    # do stuff # in fractions
    n ex =>'',<<'',{l=>'#c',acgt=>'i,K,cv,av'}
        my $c = 0+("0.".$cv);
        my $Av = $av || A.cv;
        my $sp = $av ? " Flav $av (no A.cv)" : "";
        .
        my $talk = "A.talk: $K$sp $Av > $c --- C.t ";
        .
        my $aim = {$K=>1};
        if ($aim->{A.am}) {
            $aim->{$_} = 1 for @{A.Isl||[]};
            aim.I = 1;
        }
        .
        my $yv = {};
        for my $k (sort keys %$i) {
            my $ii = $i->{$k};
            .
            next if $k eq 'Ii';
            next if $k eq 'ooI';
            ref $ii eq 'HASH' || die "weird $k=$ii";
            .
            for my $vc (sort keys %$ii) {
                my $iii = $ii->{$vc};
                die'$k !0<$vc<1' unless $vc > 0 && $vc < 1;
                $yv->{$vc}->{$k} = $iii;
            }
        }
        .
        my $vb;
        my $wasSubtle;
        for my $vc (sort keys %$yv) {
            my $is = $yv->{$vc};
            my $s = {};
            my $x = {};
            my $xrd = [];
            .
            next if $vc <= $Av && $vc != $c;
            next if $vc > $c;
            .
            # our  osc (stay in K per Subtle ness);
            my @iz = grep {
                $aim->{$_} || (aim.I && (A.Iso->{$_} || I.also->{$_}))
            } sort keys %$is;
            next if !@iz;
            .
            # decide inter cv wideness loop
            if ($wasSubtle) {
                undef $wasSubtle;
            }
            elsif ($vb && $vc > $vb && (
                @{A.N} || @{A.mo.re->{$vb}||[]}
                )) {
                # sincing, wide order
                # various others want to be around for only some of the process...
                sayre "$vb -> $vc  bump, ". @{A.N} if A.J.V > 1;
                T.Z->{$vb} = 1;
                A.cv = $vb; # so we dont wind up to 6 on the way out of t
                return T.not = 1;
            }
            I.cv = $vc;
            I.vb = $vb;
            for my $k (@iz) {
                my $iii = $is->{$k};
                I.k = $k;
                I.d&carebowl,$s,$iii,$x,$xrd;
            }
            # suble
            my $se = Rw TreeD $s $scby=gro 
                if A.J.V > 1 && keys %$s;
            $c == 0.1 ? saygr $se : say $se if $se;
            .
            my $o;
            (o.vc,o.vb) = ($vc,$vb);
            I.d&exood,$o,$x,$xrd;
            ($vc,$vb) = (o.vc,o.vb);
            if (o.Subtle && !o.nonSubtle) {
                $wasSubtle = 1;
            }
            .
            return if T.not;  # will &z, oseve
            return if delete T.whack;
        }
    
    #
    n carebowl =>''=><<'',{l=>'#c',acgt=>'s,iii,x,xrd'}
        for my $ik (sort keys %$iii) {
            my $D = $iii->{$ik};
            if (my $nk = D.sc.nk) {
                my $Ce = I.nF.C;
                die " SDIfC ".wdump 4,[$C, $Ce] if $C ne $Ce;
                next if !exists $C->{$nk};
                if (my $gk = D.sc.gk) {
                    next if !exists $C->{$nk}->{$gk};
                }
            }
            my $act;
            my $dont;
            if (D.sc.acgt && D.sc.act) {
                $act = 1;
                # acgtsubs can be defined at any cv
                # run themselves if act
                # usu. one receiver (Ci) and the rest scheme
                die "D.t .act gets... D.sc.act" if D.sc.act ne '1';
                $dont = 1 if exists A.I->{D.t};
            }
            if (!$dont && D.sc.eg) {
                $dont = I.d&robeg,$D;
            }
            # the D.s should be perl expecting ACGT (which become robes to rob)
            if (!$dont) {
                my $paw = join"_",'',I.k,I.cv,D.t;
                $paw =~ s/\W//g;
                A.I->{D.t} = Rw $paw $A $C $G $T $__D:D;
            }
            # most tiny ticks
            # this ind is all flywheel
            # it's a kind of unity that wants to be a block of code like this
            # and c
            my @is = A.s;
            @is = I.d&scIfs,D.sc.Ifs if D.sc.Ifs;
            @is || next;
            if ($act) {
                push @$xrd, [I.k,$ik];
                my $Ds = $x->{I.k}->{$ik} ||= {};
                Ds.D = $D;
                Ds.is = \@is;
                D.sc.its = @is;
            }
            # TreeD
            $s->{I.k}->{I.cv}->{$ik} = $D;
        }
    
    #
    n exood =>''=><<'',{l=>'#c',acgt=>'o,x,xrd'}
        for my $kik (@$xrd) {
            my ($k,$ik) = @$kik;
            A.Subtle && A.Subtle->{$k} ? o.Subtle++ : o.nonSubtle++;
            my $Ds = $x->{$k}->{$ik};
            my $D = Ds.D;
            for my $s (@{Ds.is}) {
                D.sc.acgt eq 's'||die "nonacgts".wdump $D;
                exists A.I->{D.t}||die "acgtI D.t not up: ".wdump A.I;
                .
                T.D = $D;
                I.d&D.t,$s;
                .
                if (my $ut = T.ut) {
                    if (ut.matchTd) {
                        my $d = s.d || die "confuse";
                        d.od.s.T.q->{d.e.k} ||= $d;
                        d.od.s.T.m->{d.e.k} ||= $d
                            unless delete(T.noTd);
                    }
                    else { die"utrowhat ".wdump 2, $ut }
                }
                .
                # outwave: schools of many fish (not upcv if !@is)
                o.vb ||= o.vc if D.sc.v;
                .
                last if T.not || T.whack;
            }
            delete T.ut;
            last if T.not || T.whack;
        }
    
    # y
Motion: |
    u allacgts
    # 6* thing/rule management
    # SNat exudes over the nk'ing ish things which .wh=fly(wheel)
    # iterates grouped 6cv via T.Z, all N at a time
    # (make no hop if N==1 or A.Subtle.$K)
    # also have pha cone stack available for offphasing
    # if our intent it loose enough
    
    # encap A/spiral spinner for the G.h, from the  to ar A.I.d&Others
    # finds relevant A.I, returning ($A,$I)
    # ingoing niles, can take ACGT or just J, like you were holding the self
    #n u =>''=><<'','%acgt:J'
    #n n =>''=><<'','%acgt:J'
    #n M =>''=><<'','%acgt:J'
    #    T compine with ^ ? whatever
    #    tie T, T&M for temp A.c like grappler, ack from n that it did
    #    ie argument imposer, passes manual bits eg Magnets
    #    and some are required reading for the call to succeed
    # T is the only kind of dataspace that could store its q right there
    # see also the II's ooI branch rememberer, Yod, etc
    n NM =>''=><<'','%acgt:J'
        my $M = [];
        my $N = [@Me];
        Mn($N);
        return $M;
    
    # outgoing magnatrain (per Act)
    n CoM =>''=>{s=><<''},{code=>'I 71',act=>1}
        push @{T.oM}, $C unless T.Z;
    
    # on exit, snakes
    n z =>''=>{s=><<''}
        I.d&oseverato;
        push @{A.M}, @{T.oM};
        1

    # A and A.mo dye drops, M tractios, T tooly, see also flywheel
    # wants to be a six alwayser... ,{code=>'I 6',act=>'all'} # II.All? II.Fly?
    # its I.d&nded and holds things to code, $v a spiral it's filling up
    # $v could be mounted... aj8 mysteries
            #   ^ bus to ride
    n flywheels =>'',<<''
        for my $k (sort keys %{A.fl||return}) {
            my $v = A.fl->{$k};
            $k = $2 if $k =~ /^(\d+) (.+)$/;
            Rw ym/$k $I $J:A.J $A $C $v $G $T;
        }
    
    n sano =>''=><<''
        A.C = $C;
        A.T = $T;
        return$A
    
    n oseverato =>''=><<''
        A.T.d = T.d if T.d;
        if (my $z = delete T.Z) {
            I.d&Tz,$z;
        }
        !@{A.mo.N} && A.mo.re &&
            I.d&more,A.mo.re;
        if (my $y = delete T.y) {
            I.d&mar,T.y;
        }
    
    # carry A through time
    # tease out the next times off T.Z.$nexttime = $incv|$N
    # is N or incv, put things off til all else lo
    n Tz =>'',<<''
        my ($lo) = sort keys %$s;
        my $v = $s->{$lo};
        T.incv = $v if $v ne '1';
        $v = [I.d&sano ] if ref $v ne $A;
        push @{A.mo.re->{$lo}||=[]}, @$v;
        @{T.oM} = ();
    
    # TODO sort by y.i ) s = c
    n more =>'',<<''
        my ($lo) = sort keys %$s;
        if ($lo) {
            my $ay = delete $s->{$lo};
            my @N = map { {AZ=>{$lo=>$_}} } @$ay;
            push @{A.mo.N}, @N;
            saybl "Looping ".@N." to $lo" if A.J.V > 1;
        }

    n moy =>''=>{s=><<''}
        # groups, spread the moise over A
        my $i = A.mo.y->{$s}||die"no$s";
        my $is = $i->{C.y.p}; # things in our C's pool
        {is=>$is,N=>[map{$is->{$_}}sort keys %$is]};
    
    n ar =>''=><<''
        my $ar;
        ar.A=$A;ar.G=$G;ar.C=$C;ar.T=$T;ar.I=$I;
        $ar;
    
Bangdesk: |
    u allacgts
    # want to sus $@ and hang vectors of what, should be autoish
    # suppose we come here with only ACGT between us and F
    n after =>''=>{s=><<''},{code=>"I 11",act=>1}
        A.bangdesk = {};
        A.bangdesk.main = sub {
            $_->() for values %{A.bangdesk.aft};
            $@ || return;
            A.bang && return;
            A.bang = 21;
            $_->() for values %{A.bangdesk.bang};
            # want to sus $@ and hang vectors of what, should be autoish
            my $m = "J: A.mo.ont.talk        A.mo.ont.cv";
            $m .= "\nC: ".k2 A.mo.ont.C;
            $m .= "\ns: ".wdump 3, A.mo.ont.s unless length $m > 20;
            sayre " * bangdesk: \n$m";
            return $m;
        };
        aft { A.bangdesk.main->() }
    
    n erg =>''=>{s=><<''},{code=>"I 9"}
        # must pre compile, see D severators
        my $m = "J: A.talk";
        $m .= "\nC: ".ki $C;
        $m .= "\ns: ".wdump 3, A.s unless length $m > 20;
        $@ = "$m\n$@";
    
SlideEa: | # liney schemery
    u allacgts
    
    # fold space til fit
    n sca =>''=><<''
        $s /= 10 while $s > 1 || $s < -1;
        return $s
    
    n scyvle =>''=><<''
        for (qw'in out cv') {
            if (my $so = C.y->{$_}) {
                my $i;
                while (C.y->{$_} <= -1 || C.y->{$_} >= 1) {
                    C.y->{$_} /= 10;
                    die "Many i chewing on ".ki C.y if $i++ > 10;
                }
            }
        }
    
    n Ci =>12=><<'','%act'
        !ref $s ? I.d&string,$s
        :
        ref $s eq 'ARRAY' ? I.d&array,$s
        :
        ref $s eq 'HASH' ? I.d&hash,$s
        :
        die "mmtype:$s";
    
    n string =>''=>{s=><<''}
        die "string: $s";
    
    n array =>''=>{s=><<''}
        return I.d&fourreal,$s if @$s != 1 && !ref $s->[0] || $s->[0] =~ /^\w+$/;
        return I.d&fourstring,$s->[0] if @$s == 1 && !ref $s->[0];
        # should stick In in first and M it? 
        # kind of motion that wants to be unsure in the wild
        unshift @{A.N}, @$s;
        T.not = 1;
    
    n hash =>''=>{s=><<''}
        return %$C = %$s if exists s.t && s.y && s.c;
        I.d&servehash,$s;
    
    n reasonlock =>''=>{s=><<''},{code=>'I 18',act=>1}
        die"reft" if ref C.t;
        if (A.J.name eq 'qq' || A.J.most.J eq A.J) {
            C.c.W = C.t unless C.c || C.sc || C.y;
        }
        I.d&renc if !ref C.c;
        .
        my $yy = C.y;
        C.y = {} if ref C.y ne 'HASH';
        I.d&givy,$yy;
        .
        I.d&rensc if !ref C.sc;
        .
        I.d&isC,$C && ref C.sc
            || die "reaso fail".wdump [A.s,$C];
        I.d&scyvle;
    
    # curv=>pi=>see
    n renc =>''=>{s=><<''}
        C.c = C.c =~ I.peels ? I.d&peel,C.c
          : do {
            A.btw.cwass = 1 if "" eq C.c;
            A.btw.cwasnd = 1 if !defined C.c;
              {s => C.c};
          };
    
    n rensc =>''=><<''
        C.sc = C.sc eq '' ? {}
            : C.sc =~ I.peels
            ? I.d&peel,C.sc
            : die "C sc nostr: C.sc   of I.peels  ".ki $C

    n isC =>''=><<''
        return 0 unless ref $s eq 'HASH';
        exists s.t && defined C.t && !ref s.t
        && ref s.y && ref s.c && 9 > keys %$s;
    
    n isJ =>''=><<''
        ref $s eq 'HASH' && ref s.bb eq 'HASH';
    
    n taJe =>''=><<''
        I.d&isC,$s || I.d&isJ,$s || return;
        if (s.bb) {
            if (I.d&isC,C.c ) {
                C.c = {e=>C.c};
            }
            C.c.s = $s;
        }
        else {
            if (I.d&isJ,C.c ) {
                C.c = {s=>C.c};
            }
            C.c.e = $s;
        }
        C.y = {};
        C.c.W = C.t;
        return 1
    
    n givy =>''=><<''
        my $y = C.y;
        if (ref $s eq 'ARRAY') {
            for my $yy (@$s) {
                C.y = {};
                I.d&givy,$yy;
                ref $y || die "notash ".ki $y;
                I.d&xot,$y,C.y;
                C.y = $y;
            }
        }
        elsif (ref $s) {
            ref $s eq 'HASH' || die "no $s";
            if (I.d&taJe,$s ) {
                my $yy = C.y;
                C.y = {} if ref C.y ne 'HASH';
                I.d&givy,$yy;
            }
            elsif ($y ne $s) {
                I.d&xot,$y,$s;
            }
        }
        elsif ($s eq '') {
            my $x = I.blanky ? I.d&blanky : {};
            I.d&xot,C.y,$x if keys %$x;
        }
        elsif ($s =~ /^($G::NUM)$/) {
            y.cv = $1;
        }
        elsif ($s =~ /^($G::NUM)-($G::NUM)$/) {
            y.in = $1;
            y.out = $2;
        }
        elsif ($s =~ /^($G::NUM)-($G::NUM)x($G::NUM)$/) {
            y.in = $1;
            y.out = $2;
            y.thi = $3;
        }
        elsif ($s =~ /^-(\w+)$/) {
            C.c.pi = $1;
            C.c.s = C.t if !exists C.c.s || A.btw.cwass;
        }
        elsif ($s =~ /^([a-zA-Z]+)(?::(.+))?$/) {
            C.c->{$1} = $2 || C.t;
        }
        else {
            die "C y wtf: $s";
        }
    
C: |
    u allacgts
    # modem sounds etc.
    # dome props, repeatable tests
    n fourstring =>'',<<''
        I.d&MZu,$1 if $s =~ /^\s*#?\s*MZ (.+)$/;
        $s =~ s/^\s+//;
        if ($s =~ /^\s*(#.*)$/) {
           T.not = 1;
           T.com = $1;
        }
        elsif ($s eq '') {
           T.not = T.space = 1;
        }
        else {
           my $ci = $s;
           for my $nk (qw't y c sc') {
               if ($ci =~ s/^(\S+) *//) { # some t are types of space
                   my $v = $1;
                   $v = I.d&peel,$v if $nk ne 't' && $v =~ I.peels;
                   # << consumes more lines into $nk, then ...
                   $v = '' if $v =~ /^(''|"")$/;
                   $C->{$nk} = $v;
               }
           }
        }
        saybl "4string: $s            ".ki $C if A.V&C;
    
    n fourreal =>'',<<''
        (C.t, C.y) = @$s;
        C.c  = $s->[2] if exists $s->[2];
        C.sc = $s->[3] if exists $s->[3];
        die'@>4'.wdump $s if @$s > 4;
        die"C.t from ".wdump $s if ref C.t; # dives
    
    n peels =>'',<<'','%subpeel'
        qr/^[\{\%]\w+/;
    
    n peel =>'',<<''
        $s =~ s/^%// || 
            $s =~ s/^{// && $s =~ s/}$//
            || die "unpealable $s";
        my $c;
        for (split ',', $s) {
            my ($k, $v) = split ':', $_, 2;
            $v = 1 if !defined $v;
            $c->{$k} = $v;
        }
        $c||{}
    
    # for getting click together:
    n c =>'',<<'','%acgt:D'
        I.d&inDin,$C,@M;
    
    n e =>'',<<'','%acgt:D'
        my $e = I.d&sces,C.c.e||return();
        I.d&inDin,$e,@M;
    
    n us =>'',<<'','%acgt:D'
        my $e = I.d&sces,C.c.e||return();
        my $us = e.c.us||return();
        push @M, 'NOGK' if @M == 1;
        I.d&inDin,$us,@M;
    
    n sces =>'',<<''
        my $i = 0;
        while (s.c.e) {
            $s = s.c.e;
            $i++ > 9 && die "HUGE $i recursing CceCceCceCce... by ".ki $s;
        }
        return $s;
    
    n inDin =>'',<<'',{acgt=>'s,D'}
        return () unless defined $s;
        return $s if $D eq 'C';
        #
        shift @M; # s
        $D = I.d&interpD,@M if !ref $D;
        #
        my $v = I.d&Cngk,$s,$D;
        saybl "Got cnkgk: ".wdump 3,[\@M,$D,$v,$s] if A.V&D;
        die "Unhandles any: $v: ".ki $D if $v eq '1';
        #
        return () unless $v;
        # blankgk
        A.note->{D.c.nk}->{D.c.gk} = $v if A.note;
        #
        @$v == 1 || die "Many somehowed ".wdump 3,[ki($D),$v];
        ($v) = @$v;
        if (D.c.as eq 'list') {
            ref $v eq 'ARRAY' || die 'Cngk for list not array '.ki $D;
            return @$v;
        }
        return $v;
    
    n interpD =>'',<<'',{acgt=>'nk,gk'}
        my $defnk = 'c';
        return $nk if ref $nk;
        my $D = {};
        D.c.as = 'list' if $nk =~ s/^_//;
        while ($gk =~ s/^%(.+?):(.+?)(?=%|$)//g) {
            D.c->{$1} = $2;
            pop @M if @M == 2;
        }
        if (@M == 1 && $nk eq 't') {
            D.c.nk = $nk;
        }
        elsif (@M == 1) { # or from t,,,
            D.c.nk ||= $defnk;
            D.c.gk ||= $nk;
        }
        elsif (@M == 2) {
            D.c.nk = $nk;
            D.c.gk = $gk;
        }
        delete D.c.gk if D.c.gk eq 'NOGK';
        $D
    
    n Cngk =>'',<<'',{acgt=>'s,D'}
        ref $A || die "nmonref A!";
        A.bangdesk.bang->{Cngek} = sub {
            sayre "was Cngk; ".ki($s)."\nWith: ".ki($D)
        } if 0;
        return 1 if D.c.any;
        die "nonNKnk".ki$D if !D.c.nk;
        return 0 if !exists $s->{D.c.nk};
        return [$s->{D.c.nk}] if !exists D.c.gk;
        return 0 if !exists $s->{D.c.nk}->{D.c.gk};
        return [$s->{D.c.nk}->{D.c.gk}];
    
    #cCccCCCCccCCcccCCccccccCCCCCCCCCCCCccCCCCCCCCCCccccccCCCCCCCCCCCCCccccCCCCCCccccCCCCCccetc
    
    n ip =>'',<<'',{acgt=>'s,c'}
        my $pass = 1;
        for my $I (keys %$s) {
            !ref $s->{$I} && $s->{$I} ne $c->{$I} && $pass--;
            ref $s->{$I} eq 'HASH' && do {
                if (my $not = $s->{$I}->{not}) {
                    $not eq 'def' && do {
                        defined $c->{$I} && $pass--;
                    } 
                    || $not eq $c->{$I} && $pass--;
                }
                else {
                    $s->{$I}->{$c->{$I}} eq '1' || $pass--;
                }
            };
        }
        $pass == 1
    
    n xoy =>'',<<'',{acgt=>'s,c'}
        $c = I.d&xot,{},$c;
        I.d&xot,$c,$s;
        return $s;
    
    n xot =>'',<<'',{acgt=>'s,c'}
        ref $c eq 'HASH' && ref $s eq 'HASH' ||
            die "Hash up".wdump 3, [$s,$c];
        while (my($k,$v) = each %$c) {
            $s->{$k} = ref $v eq 'HASH' ?
                        {%{$s->{$k}||{}}, %$v}
            : ref $v ? 
                die "Hash a ref v: ".wdump 2, $s
            : $v;
        }
        return $s
    
    n hup =>'',<<''
        my $CC = {%$s};
        $CC->{$_} = {%{$CC->{$_}}} for grep {ref $CC->{$_} eq 'HASH'} keys %$CC;
        return $CC;
    
   
Servo: | # lightning over speech bubble in the c 5 liniarity (Motion doing)
    u allacgts
    
    n servehash =>''=>{s=><<''}
          s.AZ ? I.d&AZu,s.AZ
        : s.MZ ? I.d&MZu,s.MZ
        : s.EZ ? I.d&EZu,s.EZ
        : s.WZ ? I.d&WZu,s.WZ
        : s.EC ? I.d&ECu,s.EC
        : s.Elvis ? I.d&Elvisu,s.Elvis
        : die 'hash: '.wdump($s);
    
    # time impersonator
    n AZu =>''=>{s=><<''},{l=>'Motion/oseverato'}
        die 'amany' if keys %$s > 1;
        my ($cv,$ac) = %$s;
        my ($AA,$CC) = ($ac,ac.C);
        $T = ac.T||{};
        my $cov = delete T.incv;
        my $aa = $AA?"AAcv=AA.cv":"NoAA";
        $AA ||= $A; # spawning cone thing
        I.d&n,$AA,$CC,$G,$T;
        $A = $AA;
        # see I.ex, changes A.cv = $vb to avoid A.t fulfilling exited time
        if (A.cv > $cv) {
            #sayre "Double comback A.cv > $cv: CC.t CC.y.cv ";
            #return T.not = 1;
        }
        A.cv = $cov || $cv;
        I.d&An;
        T.whack = 1;
    
    n MZu =>''=>{s=><<''}
        my $uM = sub {
            my ($k,$v) = @_;
            if (defined $v && $v eq '0') {
                delete A.fl->{$k}
            }
            else {
                A.fl->{$k} = $v || 1;
            }
        };
        ref $s eq 'HASH' ?
            map{ $uM->($_,$s->{$_}) } keys %$s
        :   map{
                /^(.+?)(?::(.+))?$/ || die;
                $uM->($1,$2);
            } split /\s+/, $s;
        T.not = 1;
    
    # without our humm, straight to M
    # this is kind of like going through el1389, so many spires to pi on
    # the calls to In want to be IId
    n EZu =>''=>{s=><<''},{l=>'Motion'}
        my $Z = I.d&iZu,$s;
        warn "About EZ";
        for my $k (sort keys %$Z) {
            my $N = $Z->{$k};
            $N = [ map { [$_] } split "\n",$N ] if !ref $N;
            Rw In $M:T.oM $N;
        }
        T.not = 1;
    
    # with our humm
    n WZu =>''=>{s=><<''},{l=>'Motion'}
        my $Z = I.d&iZu,$s;
        warn "About WZ";
        for my $k (sort keys %$Z) {
            my $s = $Z->{$k};
            die wdump $s if ref $s ne 'ARRAY';
            unshift @{A.N}, @$s;
        }
        T.not = 1;
    
    # extend C on the way in to another dome, magnetised into our M
    # probably for collapsing roooves...
    # dumber than sc decompresphere & playing out
    # (is mailing itself further instructions, intro c, further lines)
    # an In persona, joining our M
    # push to dome
    # that must in  A
    n ECu =>''=>{s=><<''},{l=>'Motion'}
        ref $s eq 'ARRAY' || die;
        my ($N,$c) = @$s;
        $N = [{MZ=>A.fl}, {MZ=>{'3 doex'=>$c}}, @$N];
        # and In could feel our light cone
        Rw In $J:A.J $M:T.oM $N;
        # ^but instead push to A.N and A.No, the sister strand Whare Y Whare
        # and A walks through t&Y, d&Whare(6)
        # turns via n&ACGT
        # the time beams mapped... a W concat couldol
        T.not = 1;
     
    # theses, pulling bits
    n iZu =>''=>{s=><<''}
        my $way = $s =~ s/^\/// ? 'fund' : 'muck';
        my $Z = Rw $way - $p:s $dclone=1;
    

