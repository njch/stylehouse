MourmaZ: |
   u ashtray=>,'c ha' 
   n fdlwk=>''=>{s=><<''}
       in wayves it travels
       I hoist by z
       move the things out into args,name,id in I from already
       code leeching out - chov into index,
         and the brain indexes the bunch of codes run with their I...
       so I is vectored done stuff (u, che acquis)
       thatd be hard to not have at this point
       unmeni the zapping into an I is the finality...
       u bein done...
       the I gets wrenched out but it is all G via J stuff... apply 
       divide the stuff up into K/cv/t limbs
       and apply the K = diffre/OSC/ACT/OMP
       compine blobs, can want to interdesign each other if travel points further than routable
       then break things off as case...
       just like things are pooled
       the over the room code forming way selector outputs more stuff
       unified and interpreted as code to way 
       everything happens as an z Elvis, even if not in El
       so In A can acquire its wires
       and splat from A couplings
   
   n zfold=>''=>{s=><<''}
       wired up some hypnocodes from other J.A.I (& u) into G.T.$W
       then in each there each W is supposedly W overlay (way)
       and theres I/1/n,An->A.t auxi, which shall wind us up to 1
       but its a bundle of wires here, about 8
       if top level hashes are all same skji/recycle, some others uCon is trusted
       G.T is a switching table
       together and wind up to 1...
       collasp J.A.IIII and J.A.I, where [$(pathfrom$A)+] or Kcvt hashbush
       the tree that changes hashes leading into its diff
       compiling II, the Kcvt single pile
       which code proteins on I with Mobile, tiny ex A.cv->1 starter
       to be stitched K/cv/t 
        # see if this wander I...
        # dangling selfs: spiral III from W creaturey
        # there's W managed for us, create the tiniest consume starter:
        # this is the usual spiral group overlay sphere arbiter
        #Rw SNtl $I;
        # n - take A
        # An - furbish A.t
        # A.t - crawl (in general) to 1, which Essen

   n A_t=>''=>{s=><<''}
        # is iunterrr that this collapses ongoingly...
        # a stream under a bridge
        # lets get sa spiral overlayer for doing K/cv/t groupi
        # Kceive it... K is a C on the wall/ground
        # much mergey extendo rubble, 
        # and $={%$} the hashes along the path to what we change, cluing
        # the tearifuing part is 
        # the conscious operator of the change could be a part of the bundle of wires
        # so I and III want to be watched, spiral planed in
        # if the ref is the same we could say its the same, travel entropy, horse aim
        # it likes to travel so it likes to travel travel, spes. travelled travel
        # its the way we thing about whatever else is going on
        # so it is data injection agent
        # that one awareness is part of the budle am wires
        # this feeding on I or III
Arange: |
    ar.oA && ar.oA.D &&
    substr(ar.oA.D.bab, 0, 200) =~ /s=><<''/ && 
    Rw babsubrip $oA:ar.oA $D:ar.oA.D $N;
    
    my $A = {};
    A.J = ar.J || die 'noJ';
    A.G = $G; # so travel can G/T/Hypo
    A.mo = $A;
    (A.am) = @{delete ar.m};
    A.am || die "unsame?";
    $A;
WeBase: | # require N, required to return an A.I that I.n,I.An,A.t
    my $A = Rw Arange;
    A.N = [ar.C || @{ar.N}];
    A.M = [];
    A.fl = ar.fl || {};
    A.I = {};
    
    my $I = delete G.drop.recycling->{A.J.id}->{A.am};
    
    my $II = Rw collaspII $A;
    
    if ($I) {
        if (I.Ii eq II.Ii) {
            say "Recyc A.talk! I.Ii continu";
            A.I = $I;
            A.cv = 0.1;
        }
        else {
            sayre "Recycloped, Diff I.Ii  --  II.Ii";
            undef $I;
        }
    }
    
    A.I.Ii = II.Ii;
    
    if (!$I) {
        $I = A.I||die'basenoi';
        Rw SNtl $I;
    }
    $A
SNtl: | # spiral Nat toolz
    I.n = sub { # A qcui
        my ($A,$C,$G,$T,$AA,$CC,$GG,$TT) = @_;
        I.nF = {A=>$AA,C=>$CC,G=>$GG,T=>$TT};
    };
    I.d = sub { # be, sub
        my $s = shift;
        my $P = I.nF ||= {};
        my $y = $I->{$s} || die "no way named '$s'";
        $y->(P.A,P.C,P.G,P.T,@_);
    };
    I.An = sub { # A within faller
        my ($A,$C,$G,$T) = @_;
        A.c = sub { die "An  ein!" };
        A.t = sub { I.d&t,@_ };
        $A
    };
    I.t = sub {
        my ($A,$C,$G,$T,@M) = @_;
        my ($cv,$K) = reverse @M;
        @M>2 && die "_ _";
        $K ||= A.am||die"noam A_t";
        
        my $i = Rw collaspII $A;
        
        my $c = 0+("0.".$cv);
        sayyl "Sends proteins into I A.talk: i.Ii";
        $c == 0.1 || die "Senbial proot $c";
        Rw SNat $A $C $G $T $I $i $K $cv;
        A.cv = $c;
    };
IStuff: |
    u allacgt
    
    n d =>''=>{s=><<''},{acgt=>1,args=>'s'}
        # grease thje stomac
        shift; # imporo
        my $y = $I->{$s} || die "no way named '$s'";
        my $P = I.nF ||= {};
        P.A||die'PnoA!?'; # papto
        $y->(P.A,P.C,P.G,P.T,@_);
    
    n n =>''=>{s=><<''},{acgt=>'AA,CC,GG,TT'}
        I.nF = {A=>$AA,C=>$CC,G=>$GG,T=>$TT};
    
    n recycle =>''=>{s=><<''}
        return if I.recyttl++ > 8;
        G.drop.recycling->{A.J.id}->{A.am} = $I;
KnowTime: | # dome props
    u allacgts
    
    n An =>''=>{s=><<''},{acgt=>1}
        A.note = {}; # pinging csc
        A.talk = "A.J.name ".(A.J.le && A.J.le.name);
        A.c = sub { I.d&c,@_; };
        A.t = sub { I.d&t,@_; };
        $A
    
    n t =>''=>{s=><<''},{acgt=>'K,cv'}
        ($K,$cv) = (A.am,$K) if !$cv && $K;
        die "K$K cv$cv" unless $K && $cv;
        # much  mergey       extendo  rubble, 
        my $i = Rw collaspII $A;
        my $c = 0+("0.".$cv);
        my $ncv;
        my $re;
        my $dont;
        sayre "A.talk  $K,$cv  is interesting" if $K ne 'In';
            if (A.cv < 0.6 || $c >= 0.7) {
                if ($c >= A.cv) {
                    $ncv = $c;
                    $re = 1;
                }
                else {
                    $re = 0;
                    $dont = 1;
                    say " deInc A.cv - $cv $c";
                }
                die "pre bigger" if $cv < A.cv;
            }
            else {
                if ($c < A.cv) {
                    if (A.cv == 0.6) { # scoop up all on entering timezone
                        $re = 1;
                        $dont = 1; # or will IIII fall away
                    }
                    else {
                        $re = 0;
                        $dont = 1;
                    }
                }
                elsif ($c == A.cv) {
                    $re = 1;
                }
                elsif ($c > A.cv) { # and $c < 0.7
                    T.Z->{$c} = 1;
                    $re = 0;
                    $dont = 1;
                }
                else {die"nof"}
            }
            I.d&severato if $cv == 7;
            undef $ncv if T.sever; # hmm
            unless ($dont) {
                # break off at 1,2
                I.d&ex,$i,$K=>$cv
            }
            A.cv = $ncv if defined $ncv;
            $re;
    
    n ex =>''=>{s=><<''},{acgt=>'i,K,cv'}
        Rw SNat $A $C $G $T $I $i $K $cv;
    
    # y
SNat: | # I.ex do  # it's in that, bubbles 
    # baseism
    my $s = {};
    my $c = 0+("0.".$cv);
    my $talk = "A.talk: $K A.cv > $c --- C.t ";
    my $aim = {$K=>1};
    aim.I = 1 if $aim->{A.am};
    for my $k (sort keys %$i) {
        my $ii = $i->{$k};
        
        ref $ii ? die "wei $k=$ii" : next
            if ref $ii ne 'HASH';
        $aim->{$k} || next;
        
        for my $vc (sort keys %$ii) {
            my $iii = $ii->{$vc};
            die unless $vc < 1;
            next if $vc <= A.cv;
            next if $vc > $c;
            for my $ik (sort keys %$iii) {
                my $D = $iii->{$ik};
                die if D.sc.gk;
                my $act;
                my $dont;
                if ($k ne 'I' && D.sc.acgt) {
                    $act = 1;
                    $dont = 1 if exists A.I->{D.t};
                }
                $s->{$k}->{$vc}->{$ik} = $D;
                my $sep = $act ? "----" : ">>>>";
                sayre "DElEE $talk $k $sep $vc  D.t D.y.cv  ". ki D.sc
                    if A.J.V > 1;
                unless ($dont) {
                    my $paw = join"_",'',$k,$vc,D.t;
                    $paw =~ s/\W//g;
                    Rw $paw $A $C $G $T $__D:D;
                }
                # non-I acgt means some expressed tick of the creature
                # as osc accesses
                # should exude spines, have 0.9s in oo awaiting
                # where nodes want to unify to is another osc trick
                # cna get the fingers picking through fillaments
                if ($act) {
                    D.sc.acgt eq 's'||die "nonacgts".ki $D;
                    exists A.I->{D.t}||die "acgtI D.t not up: ".ki A.I;
                    I.d&D.t,A.s;
                }
            }
        }
    }
    say
        Rw TreeD $s $scby=gro
            if A.J.V && keys %$s;
    
Ind: | # main spine
    # not allcode since uCons blank qq cone & then thing
    n ''=>''=>{W=>'Bangdesk'}
    n ''=>''=>{W=>'IStuff'}
    n ''=>''=>{W=>'KnowTime'}
    n ''=>''=>{W=>'SlideEater'}
    n ''=>''=>{W=>'CGolf'}
    n ''=>''=>{W=>'Csys'}
    n ''=>''=>{W=>'Servo'}
    n ''=>''=>{W=>'Indiy'}
    
    n ''=>''=>{W=>'Indulator'}
    n ''=>''=>{W=>'Modulator'}
    
    # 
Indo: | # leg off In if Ind (Wild)
    my $A = Rw WeBase Collarspew;
    my $M = [];
    Rw Indi + $A $M;
    sayyl "Indo thought ". wdump $M;
Indulator: |
    # 
    #n Indi=>''=>{s=><<''},{code=>'W 4'}
Indi: |
        my $A = Rw WeBase In;
        my $I = A.I;
        I.d&n,$A,{},$G,{};
        I.d&An;
        A.t&1;
        A.t&11111 || warn "NO 1";
        while (@{A.N}) { #
            my $A = {%$A};
            A.mo.on = $A;
            A.s = shift @{A.N};
            my $T = {oM=>[]};
            I.d&n,$A,{},$G,$T;
            I.d&An;
            A.t&2;
            $A = I.nF.A;
            # and whenever
            I.d&z && next if T.not;
            # then the things todo
            # lots ||nexts
            A.t&6||next; 
            # elabourate C, seeming to chew
            # we want to throw our next II etc
            # transmit A,C via AZ, which and A.cv via AZ and A.II)
            my $C = I.nF.C;
            for my $k (sort keys %{A.fl}) {
                my $v = A.fl->{$k};
                $k = $2 if $k =~ /^(\d+) (.+)$/;
                Rw ym/$k $I $J $A $C $n:C $v $G $T;
            }
            I.d&z && next if T.not;
            $C = I.nF.C;
            sayyl "Indi 7!". wdump $C;
            push @{T.oM}, $C; # this a 67 thing?
            A.t&7;
            I.d&z;
        }
        A.t&8;
        I.d&recycle;
        my $M = ar.M;
        if ($M) {
            push @$M, @{A.M}
        }
        elsif ($J) {
            map {
               Rw Modi + $J $C:_
            } @{A.M}
        } else {
            die "noJM";
        }
    
    
Modulator: |
    #
    #n Modi=>''=>{s=><<''},{code=>'W 4'}
Modi: |
        # make pool, synth space, want arches
        # fork & rejoin to exciting place
        # the valley, what it means to be here in here YIN
        my $A = Rw WeBase Mo;
        my $I = A.I;
        I.d&n,$A,$C,$G,{};
        I.d&An;
        A.t&1;
        A.t&11111 || warn "NO 1";
        @{A.N}||die"nois".wdump[$C,$A];
        while (@{A.N}) { #                                             ඬ
            my $A = {%$A};
            A.mo.on = $A;
            A.s = shift @{A.N};
            my $T = {oM=>[]};
            my $C = {};
            I.d&n,$A,$C,$G,$T;
            I.d&An;
            A.t&2;
            $A = I.nF.A;
            my $CC = I.nF.C;
            die wei=>wdump[$C,$CC] if $CC ne $C;
            # and whenever
            die "Must be C: ". wdump [A.s,$C] unless C.t eq 'something';
            die "through".wdump[A.s,$C];
               C.r = join "\t", C.t, (C.y.cv+0);
               C.sc = {%{C.sc||{}}}; # ?
               #
               # 7.9
               C.r = join "\t", C.t, (C.y.cv+0);
               my $oJ = $J;
               my $J = C.y.o && C.y.o.J || $oJ;
               if (J.V) {
               say "A.talk COMPLETE J.name     ->>>   C.t C.y.cv  ".k2(C.c)
               ."                     ".k2(C.sc);
               }
               Rw jamsc $J $oJ $C $s:C.c.s $sc:C.sc;
         }
         # 9
         return $A
    
    
Indiy: | # A and A.mo dye drops, M tractios
    u allacgts
    
    n z =>''=>{s=><<''}
        push @{A.M}, @{T.oM};
        1
    
    n moy =>''=>{s=><<''}
        # groups, spread the moise over A
        my $i = A.mo.y->{$s}||die"no$s";
        my $is = $i->{C.y.p}; # things in our C's pool
        {is=>$is,N=>[map{$is->{$_}}sort keys %$is]};
    
    n severato =>''=>{s=><<''}
        if (my $z = T.Z) {
            my ($lo) = sort keys %$z; # next one
            @{T.oM} = ();
            push @{A.mo.re->{$lo} ||= []}, [$A,$C];
            T.sever = 1;
        }
        if (!@{A.mo.N}) {
            my $ats = A.mo.re || {};
            my @wa = sort keys %$ats;
            my ($lo) = @wa;
            if ($lo) {
                my $ay = delete $ats->{$lo};
                my @N = map { {AZ=>{$lo=>$_}} } @$ay;
                sayyl "Loop A.cv > $lo x ".@N;
                push @{A.mo.N}, @N;
            }
        }
    
Servo: | # things over top of speech bubble in the c 5 liniarity
    u allacgts
    
    n servehash =>''=>{s=><<''}
          s.AZ ? I.d&AZu,s.AZ
        : s.MZ ? I.d&MZu,s.MZ
        : s.EZ ? I.d&EZu,s.EZ
        : s.WZ ? I.d&WZu,s.WZ
        : s.EC ? I.d&ECu,s.EC
        : die 'hash: '.wdump($s);
    
    n AZu =>''=>{s=><<''},{li=>'Indiy'}
        die 'amany' if keys %$s > 1;
        my ($cv,$ac) = %$s;
        my ($AA,$CC) = @$ac;
        I.d&n,$AA,$CC,$G,$T;
        T.grabac = [$AA,$CC]; #lexac
        if (AA.cv >= $cv) {
            warn "Double comback AA.cv $cv";
            return T.not = 1;
        }
        AA.cv = $cv;
        I.d&An;
    
    n MZu =>''=>{s=><<''}
        my $uM = sub {
            my ($k,$v) = @_;
            if (defined $v && $v eq '0') {
                delete A.fl->{$k}
            }
            else {
                A.fl->{$k} = $v || 1;
            }
        };
        ref $s eq 'HASH' ?
            map{ $uM->($_,$s->{$_}) } keys %$s
        :   map{
                /^(.+?)(?::(.+))?$/ || die;
                $uM->($1,$2);
            } split /\s+/, $s;
        T.not = 1;
    
    # without our humm, straight to M
    # this is kind of like going through el1389, so many spires to pi on
    # the calls to In want to be IId
    n EZu =>''=>{s=><<''},{l=>'Indiy'}
        my $Z = I.d&iZu,$s;
        warn "About EZ";
        for my $k (sort keys %$Z) {
            my $N = $Z->{$k};
            $N = [ map { [$_] } split "\n",$N ] if !ref $N;
            Rw In $M:T.oM $N;
        }
        T.not = 1;
    
    # with our humm
    n WZu =>''=>{s=><<''},{l=>'Indiy'}
        my $Z = I.d&iZu,$s;
        warn "About WZ";
        for my $k (sort keys %$Z) {
            my $s = $Z->{$k};
            die wdump $s if ref $s ne 'ARRAY';
            unshift @{A.N}, @$s;
        }
        T.not = 1;
    
    n ECu =>''=>{s=><<''},{li=>'Indiy'}
        # extend C on the way in to another dome, magnetised into our M
        # probably for collapsing roooves...
        # dumber than sc decompresphere & playing out
        # (is mailing itself further instructions, intro c, further lines)
        # an In persona, joining our M
        # push to dome
        # that must in  A
        ref $s eq 'ARRAY' || die;
        my ($N,$c) = @$s;
        # take 4s v             add 3s v         next 2 
        $N = [{MZ=>A.fl}, {MZ=>{'3 doex'=>$c}}, @$N];
        # and In could feel our light cone
        Rw In $J:A.J $M:T.oM $N;
        # ^but instead push to A.N and A.No, the sister strand Whare Y Whare
        # and A walks through t&Y, d&Whare(6)
        # turns via n&ACGT
        # the time beams mapped... a W concat couldol
        T.not = 1;
     
    # theses, pulling bits
    n iZu =>''=>{s=><<''}
        my $way = $s =~ s/^\/// ? 'fund' : 'muck';
        my $Z = Rw $way - $p:s $dclone=1;
    
In: | # I I I
    J.A.Indo && return Rw Indo;
    
    my $A = Rw already + $am=In $N;
    my $I = A.I;
    I.d&n,$A,{},$G,{};
    I.d&An;
    A.t&1;
    
    A.t&11111 || warn "NO 1";
    # 
    
    # 2821:      keys arrive as characters already:
    # prep A for A (I), J-sessioned etc stuff
    # is literal G spacer, index jointed bunch of code to check out from w
    # some comp could expectorate lots charstream rhythms ^
    # Z flow?
    # or we could do on a stick,
    # so its MZ junk dont linger in this stream
    # ie always flow outwards the sc filtery stuff.
    while (@{A.N}) { #
        my $s = shift @{A.N};
        my $C = {};
        my $T = {};
        my $A = {%$A};
        A.mo.on = $A;
        A.s = $s;
        T.oM = [];
        I.d&n,$A,$C,$G,$T;
        I.d&An;
        A.t&2;
        
        I.d&Ci,$s;
        ($A,$C) = @{T.grabac} if T.grabac;
        
        I.d&z && next if T.not;
        I.d&Cr,$s;
        A.t&6;
        
        # elabourate C,
        for my $k (sort keys %{A.fl}) {
            my $v = A.fl->{$k};
            $k = $2 if $k =~ /^(\d+) (.+)$/;
            Rw ym/$k $I $J $A $C $n:C $v $G $T;
        }
        I.d&z && next if T.not;
        
        
        push @{T.oM}, $C;
        
        A.t&7;
        I.d&z;
    }
    
    I.d&recycle;
    
    my $M = ar.M;
    if ($M) {
        push @$M, @{A.M}
    }
    elsif ($J) {
        map {
           Rw mani + $J $C:_
        } @{A.M}
    } else {
        die "noJM";
    }
    
    
Bangdesk: |
    u allacgts
    # want to sus $@ and hang vectors of what, should be autoish
    # suppose we come here with only ACGT between us and F
    n after =>''=>{s=><<''},{code=>"In 11"}
        aft {
            $@ || return; A.bang && return; A.bang = 21;
                # want to sus $@ and hang vectors of what, should be autoish
                my $m = "J: I.nF.A.talk";
                $m .= "\nC: ".k2 I.nF.C;
                $m .= "\ns: ".wdump 3, I.nF.A.s unless length $m > 20;
                $@ = "$m\n$@";
            # A.t&9,$@; 
        }
    
    n erg =>''=>{s=><<''},{code=>"I 9"}
        # must pre compile, see D severators
        my $m = "J: A.talk";
        $m .= "\nC: ".ki $C;
        $m .= "\ns: ".wdump 3, A.s unless length $m > 20;
        $@ = "$m\n$@";
SlideEater: | # liney schemery
    u allacgts
    
    n Ci =>''=>{s=><<''},{code=>'I 12'}
        if (!ref $s) {
            I.d&string,$s;
        }
        elsif (ref $s eq 'ARRAY') {
            I.d&array,$s;
        }
        elsif (ref $s eq 'HASH') {
            I.d&hash,$s;
        }
        else { die "mmtype:$s" }
    
    n string =>''=>{s=><<''}
        die "string: $s";
    
    n array =>''=>{s=><<''}
        if (@$s == 1) {
            my ($s) = @$s;
            ref $s && die "array1ref: ".wdump $s;
            I.d&fourstring,$s
        }
        else {
            I.d&fourreal,$s
        }
    
    n hash =>''=>{s=><<''}
        return %$C = %$s if s.t && s.y && s.c;
        # some talking to self - how to C over exactly, the object could be live
        I.d&servehash,$s;
    
    n reasonlock =>''=>{s=><<''},{code=>'I 18'}
        die"reft" if ref C.t;
        # uis a nested wave
        # allow much manufold
        I.d&reny if !ref C.y;
        I.d&renc if !ref C.c;
        I.d&rensc if !ref C.sc;
        (3==grep{ref}map{$C->{$_}}y=>c=>'sc') &&
        defined C.t || die "reaso fail".wdump $C;
        say "C.t C.y.cv    looks reasonable...  ". join"  ",sort keys %{C.sc};
    
    n reny =>''=>{s=><<''}
        C.y = C.y eq '' ? {}
            : C.y =~ /^($NUM)$/
            ? {cv=>$1}
            : C.y =~ /^($NUM)-($NUM)$/
            ? {from=>$1,to=>$2}
            : die "strung ny: C.y".wdump $C;
    
    n renc =>''=>{s=><<''}
        C.c = C.c =~ I.peels ? I.d&peel,C.c
          : {s => C.c};
    
    n rensc =>''=>{s=><<''}
        C.sc = C.sc eq '' ? {}
            : C.sc =~ I.peels
            ? I.d&peel,C.sc
            : die "nostr  C.sc    ".ki $C
    
    #e
Csys: |
    u allacgts
    
    n interpD =>''=>{s=><<''},{acgt=>'nk,gk'}
        return $nk if ref $nk;
        my $D = {};
            while ($gk =~ s/^%(.+?):(.+?)(?=%|$)//g) {
                D.c->{$1} = $2;
                pop @_ if @_ == 2;
            }
            if (@_ == 1) { # or from t,,,
                D.c.nk ||= 'c';
                D.c.gk ||= $nk;
            }
            elsif (@_ == 2) {
                D.c.nk = $nk;
                D.c.gk = $gk;
            }
        $D
    
    n c =>''=>{s=><<''},{acgt=>'D'}
        die'nofA' if !I.nF.A;
            $D = I.d&interpD,@_ if !ref $D;
            exists C.c->{$_} && die "COT I".ki $C
                for qw'code if of ref';
            my $v = I.d&Cngk,$D;
            return () unless $v;
            A.note->{D.c.nk}->{D.c.gk} = $v if A.note;
            die 'mulitAn' if @$v > 1;
            if (D.c.as eq 'list') {
                return ref $v eq 'ARRAY' ? @$v : die'Cngk not array';
            }
            return 1;
    
    n accept =>''=>{s=><<''},{acgt=>'D'}
        return T.next = 1 unless I.d&Cngk,$D;
    
    n Cngk =>''=>{s=><<''},{acgt=>'D'}
        ref $A || die "nmonref A!";
        die 'nk no gk' if exists D.c.nk && !exists D.c.gk;
        return 1 if D.c.any;
        if (D.c.nk && exists $C->{D.c.nk} && exists $C->{D.c.nk}->{D.c.gk}) {
            my $v = [$C->{D.c.nk}->{D.c.gk}];
            delete $C->{D.c.nk}->{D.c.gk} if D.c.mdel;
            return $v;
        }
        die "noNnk".wdump $D unless exists D.c.nk;
        0;
    
    n extend =>''=>{s=><<''},{acgt=>'s,c'}
        while (my($k,$v) = each %$c) {
            $s->{$k} = ref $v ? {%{$s->{$k}||{}}, %$v} : $v;
        }
CGolf: |
    u allacgts
    
    n fourstring =>''=>{s=><<''}
        # sticks out of usual c 5 hive of MZ/awarey things #li=Servo
        if ($s =~ /^\s*#?\s*MZ (.+)$/) {
           I.d&MZu, $1;
        }
        # the rest of this stuff lies here more, eating a string of lumps
        # if we were reading lines the N[$line] hop would neg
        # modem sounds etc.
        # dome props, repeatable tests
        elsif ($s =~ /^\s*(#.*)$/) {
           T.not = 1;
           T.com = $1;
        }
        elsif ($s eq '') {
           T.not = 1;
           T.space = 1; # could mean sticks
        }
        else {
           my $ci = $s;
           for my $nk (qw't y c sc') {
               if ($ci =~ s/^(\S+) *//) { # some t are types of space
                   my $v = $1;
                   $v = I.d&peel,$v if $nk ne 't' && $v =~ I.peels;
                   $C->{$nk} = $v;
               }
           }
        }
    
    n fourreal =>''=>{s=><<''}
        (C.t, C.y) = @$s;
        C.c  = $s->[2] if exists $s->[2];
        C.sc = $s->[3] if exists $s->[3];
        die'@>4'.wdump $s if @$s > 4;
        die"C.t from ".wdump $s if ref C.t; # dive
    
    n peels =>''=>{s=><<''},{subpeel=>1}
        qr/^[\{\%]/;
    
    n peel =>''=>{s=><<''}
        $s =~ s/^%// || 
            $s =~ s/^{// && $s =~ s/}$//
            || die "unpealable $s";
        my $c;
        for (split ',', $s) {
            my ($k, $v) = split ':', $_, 2;
            $c->{$k} = $v;
        }
        $c||{}
    
    

