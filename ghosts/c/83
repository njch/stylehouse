GW: | # assume G W, router, uxvis nestle into GW/W... via om & CsE utbing
    y.at.jslines = 1;
    J.ev.th = 'middle';
    y.at.Mid = "G-J.mo.s.C.c.s";
    y.at.Wid = J.mo.s.id;
    G.GW = $J;
    my $f = "life/W/y.at.Wid\.e";
    J.taile = $f;
    `cat /dev/null > $f` if !-f $f;
    # =>{ac=>{create=>1}} # ac/asc/etc involvers slide into the experiment from E
    n $f =>-sol
    
    n rmold =>2=> "\n\$('ww[title=\"".y.at.Mid."\"]').remove();",'%js'
    
    n skfdo =>3=> "\$('#ux').append('<ww id=\"".y.at.Wid."\" style=\"position:absolute;height:100%;width:100%;background-color:hsla(118.8, 50%, 30%, 0.1);pointer-events:none;\" title=\"".y.at.Mid."\"></ww>');",'%js'
    
    # demand etc
    
    #n $C
    
closeline: | # event end (following few wires together)
    # go from holding to referencing each other, adapt 
    # End C can reach further beside itself
    # the strand should collapse hierarchy upwards
    # see Sev for limited channels
    my $E = Rw CsE $C;
    # ids are brain tickets
    if (A.V&Ecl || 1) {
        sayyl " - _.t   _.y.cv  _.c.s :: _.c.e" for @{E.c.z};
    }
    if (!E.c.us) {
        return Rw Elis + $E;
    }
    # trail piled up to eventual/original Ece=Cevent(cs={jsonform})
    # because from O we get cJ 9er, scJ 6er
    # so cJ groups and scJ is for s (pi instruct)
    # any anything along the bead chain (J), would be correspondant
    # make
    Rw zyeuter + $E;
    # wants ope Mn
    die "refCcstavbib".wdump 4,[$E] if ref E.c.s;
    T.pos = 0;
threJ: | # Sav Sav
    u allvse
    # heaven's above me on a street called love
    n '','','%of:oJ'
    n J =>344,<<''
        my $ins = sub { my $J = shift; $J ne J.mo.J ? "J.mo.J.name ' J.name" : J.name };
        if (C.c.e) {
            my $new = !J.A.first ? "(first!)":"";
            say $ins->(A.J)."   is elvising to  ".$ins->($J)." $new\n    "
                ." C.t  ".ki(C.c)."     ".ki(C.sc);
            C.c.elv = delete C.c.e if $new;
            # do over after osc (or time2 could in middle)
            # donow, may wat
            A.Iso.th = 1;
        }
        else {
            A.J eq $J && die sayre "THreJ does Celt A.J.name   ".(C.c.e && ki C.c.e);
            #saybl $ins->(A.J)." can create -----> ".$ins->($J);
            if (J.ev.amb) {
                my $ar = I.d&ar;
                Rw J.ev.amb + $J;
            }
        }
    
    n '','','%of:J'
    # fit e into 2
    n J =>632114142,<<''
        return if exists C.sc.pi;
        A.time = sub {
            my ($JJ,$q) = @_;
            $J eq $JJ || die "wtfJure  J.name   vs JJ.name";
            my $r = 1;
            if ($q == 2) {
                A.Subtle.time = 1;
                A.t&time,3,19;
                $r = 0 if T.pos == 0; # def 1, 0 if no change
                return $r;
            }
            .
            warn "T.alk other $q";
            if ($q == 8) {
                # until J.most coord attention evaporates
                # as in pulling on a list
            }
            $r
        }
    
    # coming to a known thing, engage wave lasso
    #   vector may want to wake up itself,
    #   e could time2 in, pre-osc 7 or post-osc 76
    #   also the e could know if its an incoming list,
    # bringing into the handler ...
    n '','','%of:th'
    n e =>36,<<'','%rg:J'
        $J || warn "e no J";
        # no J being tricks for handulation, event energy, unless T.oke
        delete A.Iso.oJ;
        my $ar = I.d&ar;
        Rw hevt + $J e36;
        if (T.oke) {
            die "thoughts of a thous J.name" if A.J eq $J;
            delete A.Iso.th;
            A.Iso.oJ = 1;
            A.ztime = 6;
            return say "Tanking into J.name";
        }
        T.pos = 1 unless defined T.pos;
        T.pos &&
            Rw waito $J $C;
    
    # cancels proto this (threes)
    n J =>4,<<''
        return;
    
    # communication log, join proton, usually no trace of other in the self
    n e =>769,<<'','%rg:J'
        T.oke = 1; # unpin
    
    # T.oke means the vector wants to immediately handle e itself
    # or must m/osc some truth for the question, eg creating geo
    # the answer is laid along the tracks
    n '','','%of:time'
    n elv =>2,<<'','%rg:J'
        C.c.e = delete C.c.elv;
        my $ar = I.d&ar;
        Rw hevt + $J elv2;
        #T.oke && warn "NOTOKE time2 J.name";
        T.pos = 1 unless defined T.pos;
        # time true, complete vector, unless we cat a list
    
    
    n '','','%of:oJ'
    n elv =>76,<<'','%rg:J'
        C.c.e = delete C.c.elv;
        Rw hevt + $J elv76;
        if (T.oke) {
            die "76 thoughtself J.name" if A.J eq $J;
            say "Tanking 76 into J.name";
            Rw waited $J;
            return;
        }
        T.pos = 1 unless defined T.pos;
        T.pos &&
            Rw waito $J $C;
    
waito: | # refresh vector in a post e swarm catchup way, without e, departs call stack
    say "Comebacking J.name with C.t...";# if A.V&V;
    my $d = ar.d || 0.03;
    my $p = ar.p || 'waited';
    my $K = "ar.p ar.d J.name"; # request comp
    my $queued = J.waito->{$K};
    saygr " waito $K     the C.t  ".($queued ? "again":"");
    return if $queued;
    J.waito->{$K} = 1;
    Rw wayt + $K $d $p;
    
waited: | # refresh soon has returned so it cIsOn, a hicup of order clasps e noise
    ar.K && say("Back to ar.K") &&
        delete J.waito->{ar.K};
    # how much exactly... arg scuttle lots, mind moires, eddying structures
    #my $c = {%{C.c}};
    #delete c.e;
    my $c;
    c.W = ar.J ? ref ar.J ? ar.J.name : ar.J : ar.W || die "say what W to waited";
    %$c = (%$c, %{ar.c}) if ar.c;
    my $J = G.oin;
    n c.W =>''=>{%$c,time=>6}
hevt: | # nonself sends you (the mount) (C.c.e) (to middle, from e ev)
    my $pin = J.ev.th || 'hopend';
    sayyl "In!to J.name  $pin      ".join', ', @{ar.m};
    say "threeevent A.J.name ----> J.name !-> $pin" if A.V&E;
    # eg openevent means J opens to Trabitation for events
    Rw $pin + $J;
hopend: | # event end,
    my $E = Rw CsE $C;
    C.c.e = $E;
    T.oke = 1; # does pin

Elis: |
    E.c.trJ eq $J && return
        Rw clack Doublysendo;
    E.c.trJ = $J;
    J.ev.av && sayre("On to J.name: J.ev.av") && # on arrival
        Rw J.ev.av;
    
    J.ev.o && A.J ne $J && return
        saygr("othero: J.ev.o: A.J.name to J.name  C.sc.J.name  E.sc.J.name") &&
        Rw J.ev.o;
    
    J.ev.li && return
        saygr("JevLi: J.ev.li: A.J.name to J.name  ---  C.sc.J.name  E.sc.J.name") &&
        Rw J.ev.li;
    
    my $f = J.ev.f;
    $f = {split':',$f,2} if !ref $f;
    for my $pi (keys %$f) {
        E.sc.pi eq $pi || next;
        my $d = $f->{$pi};
        my $pin = ref $d ? die "ref f d in $pi" : $d;
        sayyl "Elis: $pi to $pin";
        return
        Rw $pin;
    }
    
    E.sc.was && return saybl "E.t was: $_ ".E.c.s;
    
    # double take aft writedown
    J.ev.tr && return
        Rw J.ev.th;
    
    Rw clack + Elisi;
    
CsE: | # collasp C.c.e& tube, decode line, gives E
    my $C = $C;
    my $z = [];
    while ($C) {
        push @$z, $C;
        $C = C.c.e;
    }
    my ($m,$E) = [];
    ($C,@$m,$E) = @$z;
    $E = pop @$m if !$E;
    die "No E".wdump $z if !$E;
    
    # interesting maps, exfolat:
    E.c.z = $z;
    E.c.m = $m;
    
    # & any
    if (!E.c.us && E.c.s =~ /^\{/) {
        E.c.us = eval{djson E.c.s};
        die "KGAO: $@\n\n cs: E.c.s" if $@;
    }
    return $E
    
middle: |
    my $E = Rw CsE $C;
    say "midd: C.t has E.t ".(E.c.us && "(us)");
    # us, ids are brain tickets, tractorbeam does Elis first time
    if (J.ev.tr && E.c.trJ ne $J
        || !E.c.us
        || E.c.us.ids->[E.c.us.idi - 1] eq J.id) {
        Rw Elis + $E;
    }
    else {
        Rw zyeuter + $E;
    }
    
zyeuter: | # via closeline on handling Trabit, resolve into Giddiness pile G.Wh, may network
    # c z is Croute of energy from event listener
    # c us is decoded event hash from s, is trust
    my $u = E.c.us;
    # send on with $C, next closeline shall re idi, maybe redime asapish
    # te .e modalism focuses on how to recursion
    # the line/pipe compresses as it substrates certainly
    # wants can do as J 8, fishing/finishing zom
    # could fork & do asap but rezoom results sluggishly
    # for an oozey process that writes small high quality about etc.
    ref u.ids eq 'ARRAY' || die "Quackvent: ".wdump $u;
    my $res = sub {
        my $id = shift;
        # idyl || G.Wh
        G.Wh->{$id} || G.W->{$id};
    };
    my $oth;
    # v should maybe just C pipeline ($z)
    u.idi ||= 0;
    my $i = 0;
    for my $id (@{u.ids}) {
        my $oJ = $res->($id);
        my $ta;
        if ($i == 0) {
            $oJ || die "alien space going $id";
            $ta = "Got this G";
        }
        elsif ($oJ) {
            $ta = "Would in";
        }
        if ($oJ && u.idi == $i) {
            u.idi = $i+1;
            $oth = $oJ;
            $ta .= " ~Routo $i";
        }
        my $name = $oJ ? oJ.name : "UNKNOWN";
        sayyl " ^ $id: $name    $ta" if A.V&V;
        last if $oth;
        $i++;
    }
    $oth || die "no others ".ki $u;
    sayyl "Routing J.name: C.t   ---> oth.name";
    my $oJ = $J;
    if (my $J = $oth) {
        # e stackin, very end has anoth stackin that we travel & do
        u.idi = $i+1;
        n J.C.t,$C,$oJ
    }
    T.pos = 0;
    
Followe: | # eg th=openevent
    # (everything threes)
    u linesfollow
    u Ipifalls
    # ^ qq {cpi:lines u:followlines}
    J.VV.N = 1;
    y.ope = 1;
    y.at.oWl = 1;
    # y.at.es = 'closeline' # & a provider of closeline = Trabit
    J.ev.th = 'middle';
    J.ev.tr = 1;
    J.ev.f.line = 'openevent';
    
    sayyl "Checkin following...";
    !ref $s && $s &&
    n Follow =>''=>{pi=>cfile=>s=>$s,create=>1}
    
    n $C
openevent: | # $e, join Followe to Trabit as an event
    saybl "OPENEVENT J.name: for C.t called C.c.e.t";
    n Trabit=>$C
Trabit: |
    u pi3d
    u Ipifalls
    y.ope = 1;
    J.ev.th = 'middle';
    J.ev.tr = 1;
    J.ev.av = 'avel';
    n $C
avel: | # dry mounds of any velocities
    say "Travel J.name avel ".ki E.c.s;
    J.VV.N = 1;
    my $n = ++J.ieuye;
    n travel=>($n * 0.1)=>{pi=>line=>s=>E.c.s}
    # comeback &, watching whatever Norgs pha cones into time
    #n done=>($n * 0.1)=>{s=>"Delivered to ..."}

