    
Jam: | # idless, uppins, some time
    u allovse
    n \'of:O'
    
    n sel =>381=><<''
        delete at.c.id;

    u allvse
    
    uppins 621218189: %code:J,v:J,rg:pin
        my $to = $J;
        $to = to.mo.J;
        to.pins.>$pin ||= 1;
        if ($J eq $to) {
            G.oin.inJ.>J.name = $J;
        }
        if ($J eq G.oin) {
            Rw wayty $J $p=Pins;
        }
    
    J 434: %code:oJ
        $J = C.c.J = C.sc.J;
        J.name || die "WNO ".wdump 4, $C;
        A.ztime = 6 if J.name eq 'qq';
        # TODO: soft acuminy over \d esp. until .bb or something
        A.mo.Js->{J.name} = $J;
        # A falls
        # A.mo exits
        # J.A persists
        J.A.first ||= hitime();
        if (C.sc.W && G.oin ne $J) {
            my $lev = G.oin.A.tid;
            if (J.A.tidi && (J.A.tidi + 3) > $lev) {
                A.ztime ||= 6;
            }
            else {
                J.A.tidi = $lev;
            }
        }
        sayre "same A.J.name inside J.name" if A.J eq $J;
        if (exists C.sc.pi) {
            sayre "JiternotAJ J.Jiter.name ne A.J.name" if J.Jiter ne A.J;
            die 'pimostJ'if J.most.J eq $J;
        }
        else {
            die 'esel'.wdump [J.C, J.most.J.C] if J.most.J ne $J;
        }
        A.ztime ||= 6;
        A.time && sayre "Had atime";
        A.time = sub { # A.t& cover, serve single digit ad hocs, like 2
            my ($JJ,$q) = @_; die"JTIMEJ" if $JJ ne $J;
            A.ztime >= $q
        };
        if (C.sc.pi) {
            J.A.d = J.Jiter.A.d + 1;
            J.ind = join '  ', ('') x J.A.d;
            J.name = "J.A.d. C.c.pi*C.t";
            J.d = $C;
            A.ztime = 6 if A.ztime < 6;
        }
        J.C = $C;
        A.talk .= " J: J.name";
Gum: |
    ar.m || J.done++ && return;
    
    my @h = ar.m ? map{s/-/ /sg;$_}@{ar.m} : die "hi".(
       Ws=>
       Goat=>Goh=>
       # 'Gub',
       'Dub',
       "Doof"
    );
    
    G&wraf,'proc/start',$_ for grep{say "L:oad: $_"} 
        map{"$$: perl got $_ 4 b"} @h;
    

    
Gun: |
    Rw forked v;
    Rw forked jes:styclick;
    Rw forked jes:stylext;
Gub: |
    u urw
    y.at.anch = 'Noteal';
    soyt 21:
        five five
    Rw PSF;
    
Dub: |
    u urw
    u unicrow
    u UpPg
    u cu=>-curv=><<''
        zoom 0 1.2
        y    0  0
        x    0  0.02
        curve 0 -0.2
        curve 0.4 0.3
        spin 0.3 2
    
    n Doy
    # 
     #
    # #
    Rw Code;
    
    
    m exit=>[-dot=>0.02],{},'%hs:594'
    m $_=>[-doJ=>0.04],{},'%hs:896' for qw'JJ PSF';
    
    Mn($_) for @{J.ro.sc.M||[]};
    
    
    #n sto=>'1-6x33',{loug=>3300,hsb=>376}
    
    
    J.VV.N = 1;
    #my $j = G&A,'S';
    #n Rec=>$C
    
Doy: |
    u urw
    u unicrow
    u curv=>-curv=><<''
        zoom 0 1.2
        y    0  0
        x    0  0.02
        curve 0 -0.2
        zoom 0.01 1.6
        curve 0.2 -0.1
        zoom 0.3 0.8
        spin 0.3 2
        zoom 0.38 1.4
        curve 0.4 1.3
        zoom 35 2
    
    J.VV.N = 1;
    my $at = 8000 + int rand(4203);
    n good=>[-dot=>0.02]=>$at
    n bad =>[-dot=>0.04]=>$at
    
    
    y.in = 1;
    y.out = 8;
    for (1..22) {
        m $_,'',{loug=>$at,hsb=>376}
    }
    
good: |
    my $do = e&hC ->[1];
    Rw AddToMy $l=good $s:do.c.s;
    
bad: |
    my $do = e&hC ->[1];
    Rw AddToMy $l=bad $s:do.c.s;
    
AddToMy: |
    my $l = "w/T/C.t/$l";
    G&wraf,$l,$s
    
Dool: |
    u urw
    
    my @la = shuffle `cat w/T/Doy/good`;
    chomp for @la;
    
    m lang=>-langi=>$_ for @la[0..1];
pi/langi: |
    u Phi
    u unicrow
    y.at.width = '50%';
    y.at.height = '50%';
    
    y.clos = 1;
    y.in = 0.1;
    y.out = 0.9;
    n bit=>'1-9x30'=>{loug=>$s+4},'%phi,cola:654'
    
    n '.'=>'2-5x10'=>'@','%phi,fs:30,cola:3'
    
    
    
    
    
Sho: |
    u urw
    m ze=>-tinput
    m sat=>-slid
    m J.vid || medlos=>-vid
    J.VV.N = 1;
Tjs: |
    u alljs
    crn:
        a.om(A.mo,['','',{},{sat:A.on.value}],a,{});
        ~cornerbit sat: A.mo.W.t, A.on.value
        
    och:
        console.log('adjust AW',this);
    
    u alljse
    on 4:
        var h = G&peel,s;
        var el = $(A.on);
        console.log('recover:', el);
        $.each(h, function(k,v){
            k === 'c' and k = 'change';
            el.on(k,function(e){
                G&$v,e
            });
        });
pi/slid: |
    y.at.qs = 1;
    n t=>1=>C.t,'%fs:11'
    my $cra = "3";
    #my $vid = "<input type=range min=1 value=$cra max=9 step=0.25 onchange=a\.crn(this)>";
    #n s=>2=>$vid,'%ht,tra:3 40'
    J.VV.N = 1;
    
    n st=>22=>$cra,{tag=>'input',atr=>'type:range,min:1,max:9,step:0.25',on=>'c:crn'};
    
pi/vid: |
    my $di = 'public/art/';
    (my $see = C.t) =~ s/\W/?/g;
    my @o = glob "$di*$see*";
    saybl "From $see: ".wdump 3,\@o;
    map{
        my ($t) = /^$di(.+)\.\w+$/;
        s/^public\///;
        m $t=>-video=>$_
    } @o
pi/video: |
    y.at.qs = 1;
    n t=>1=>C.t,'%ab,fs:40'
    my $vid = '<video width="900" autoplay controls><source src="'.$s.'""></video>';
    n s=>2=>$vid,'%ht,ml:-50%,zi:-34,tra:3 40'
pi/tinput: |
    C&fs = 17;
    n t=>1=>C.t,'%sha:4 9 5 698'
    n s=>2=>':'
    
    my $sc = G&peel,'%cod:perl,dig:steve,dos:Tinput,ab';
    sc.width = 2;
    n z =>1 =>'',$sc
    
    #y.at.cssdel = 'transform';
Tinput: |
    A.us&code || return;
    my $sl = e&hC ->[-2];
    J.vid = us&code;
    #T.oke = 1;
Not: |
    u urw
    u Phi
    u curv=>-curv=><<''
        zoom 0 1
        curve 4 -0.1
    
    n m=>1=>'moere'
    
    y.in = 2;
    y.out = 8;
    my $which = 3 > rand 5 ? 'not' : 'g/N/Z';
    my $not = J.note||=[ shuffle split /\n\s*\n/, ''.`cat $which` ];
    my @in;
    push @in,
        grep{!/\/\w+\/|https?:/}
        shift @$not
        until sum(map{length}@in) > 80;
    @in = map{split/\s+/} @in;
    
    m s=>''=>$_=>{fs=>40, cola=>1} for @in;
    
NotPhi: |
    my $phi = sub {
        my $s = shift;
        $s = {n=>1,cv=>$s} if !ref $s;
        my $n = s.n || 9;
        s.w ||= 100;
        s.h ||= 100;
        my $cx = s.x || (s.w / 2);
        my $cy = s.y || (s.h / 2);
        my $lg_diam = s.w * 0.85;
        my $lg_rad = $lg_diam / 2;
        my $outer_rad = s.w * 0.45;
        my $angle_incr = s.ai || 9 / $n;
          my $xy = [];
          for my $i (1..$n) {
              my $ratio = $i/$n;
              $ratio = s.cv if s.cv;
              my $spiral_rad = ($ratio *1.43) * $outer_rad;
              my $angi = $angle_incr + 1.15;
              my $angle = 0.3 + $i *$angi;
              my $x = $cx + cos($angle) * $spiral_rad;
              my $y = $cy + sin($angle) * $spiral_rad;
              push @$xy, {
                  rad => sprintf('%.4f', atan2($x - $cx, $y - $cy)),
                # angle => sprintf('%.3f', $angle),
                  x => sprintf('%.4f', $x/100),
                  y => sprintf('%.4f', $y/100),
              };
          }
          wantarray ? @$xy : $xy->[0]
    };
    
    my $x;
    x.n = @in;
    my @phi = $phi->($x);
    
    m s=>''=>$_=>{geo=>G&here2geo,shift@phi ,fs=>40, cola=>1} for @in;
Phi: |
    u allsvse
    #n Spirals
    n \'of:Mo'
    
    cola 5:
        my $start = $cola || 1;
        $start *= 10;
        
        my @ay = ($1, split'',$1) if C.y.pcv =~ /\.(\d+)/;
        C.sc.hs = join' ', map {
            my $o = shift @ay;
            $o += 2;
            $o *= $start;
            $o /= 100 until $o < 100;
            int $o;
        } 1..3;
        C.sc.sha = '3 4 8 248';
    
unicrow: |
    u allc
    n \'of:Mo'
    J.VV.N = 1;
    
    loug 44:
        my ($tin) = C.y.pcv =~ /(\d\d)$/;
        c&s = encode_entities unico $loug + $tin;
        C&ht = 1;
    
    hsb 45:
        my ($t,$in) = C.y.pcv =~ /(\d)(\d)$/;
        my @hs = split '', $hsb;
        $hs[0] += $in * 3;
        $hs[1] += $t * 3;
        for my $y (0,1) {
            $hs[$y] -= 9 while $hs[$y] > 9;
            $hs[$y] += 9 while $hs[$y] < 1;
        }
        C&fs = 8 * $in + 3;
        #C&ml = 1 * $in;
        C&zi = $in;
        C&hs = join '', @hs;
PSF: |
    u urw
    my $j;
    for (`ps faux | grep perl`) {
        next if /grep perl/;
        my ($user,$pid,$cpu,$mem) = split /\s+/;
        my $p = $1 if /\|(.+)$/;
        $j .= "$pid \t $cpu  $mem \t !  $p\n";
    }
    n date=>0.032=>`date`,'%fs:66,blr:9,opa:7,hs:394'
    n ps=>-pre=>$j
Rec: | # batchy you, web
    #u urw
    u Sugd
    u AmPg
    J.ev.o = 'SpaceFlos';
    J.ev.opl = 'fiew';
    
    Atime(2);
    
    n s=>''=>t
    
    for ( e&C ) {
        sayyl "Rec receives : ".ki $_;
    }
pi/fiew: | # Rec Receiving
    sayyl "Pi J.name receives  some .... ".wdump 3, $s;
urw: | # the pointyclick, curved probablW, %dos do w
    n ReoCur
    u allvse
    n seolu =>32,<<'','%code:U,v:J'
        J.oy.at.ux = 1;
        J.oy.at.oWl = 1;
        J.ev.th ||= 'middle';
        J.ev.li ||= 'climbos';
        
Code: |
    y.at.cssdel = 'transform';
    ###
    G.edit ||= 'Dub';
    J.lA=
    n edit=>0.02=>'@'=>'%dos:flse,op:J/se/cod,to:!,fs:40'
    n edit=>0.02=>'~'=>'%dos:flse,op:J/se/cod,to:!,fs:40'
    
    if (J.se.cod) {
        n 'G/edit'=>[-cde=>'1-2']
        n G.edit=>[-cde=>'2-6']
    }
    
CodeMirror: |
    # do in iframe
    n Headstuff=>2=><<''
        <script src="../lib/codemirror.js"></script>
        <script src="../mode/xml/xml.js"></script>
        <script src="../addon/dialog/dialog.js"></script>
        <script src="../addon/search/searchcursor.js"></script>
        <script src="../addon/search/search.js"></script>
        <style type="text/css">
              .CodeMirror {border-top: 1px solid black; border-bottom: 1px solid black;}
              dt {font-family: monospace; color: #666;}
            </style>
        </head>
flse: | # click data fusilagery
    my $r = E.c.hC->[-1];
    if (r.sc.to) {
        r.sc.op || die "nop";
        my $o = I.d&pin,r.sc.op,$A;
        if (r.sc.to eq '!') {
            sayyl "! op to r.sc.op, was: ".
                I.d&pon,r.sc.op,$A,!$o;
        }
        else {
            I.d&pon,r.sc.op,$A,$o+C.sc.to;
        }
    }
    else {
        sayre "How to hold ".wdump 2, $r;
    }
    #sayre "Have flse click: ".wdump 2, $r;
pi/cde: |
    my $he = $s = /\// ? $s : "G/way/$s";
    my $se = G&pin,$he,$A;
    
    my $sc = G&peel,'%cod:perl,dig:steve,dos:upcde,width:24,ab';
    sc.height = C.y.spc * 10;
    n C.t =>1 =>$se,$sc
    
    C.sc.cssdel = 'transform';
upcde: |
    sayre "Upacode J.name: C.t - E.t" for 1..4;
    
    my $t = e&hC ->[-2];
    
    #Rw talkzyh;
    sayyl ":Elvis: ".ki e&us ;
    for (A.us&code) {
        if ("" eq $_) {
            # schedl, sewop #
            saybl "Blank thing";
        }
        else {
            
            my $E = e&us;
            E.t = t.t;
            E.c.s = $_;
            
            Rw Gohup $J $E;
            # goh wind, 
            my $pin = t.c.s;
            say "Upping $pin ---";
            I.d&pon,$pin,$A,$_;
        }
    }
    

