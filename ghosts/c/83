    
Jam: | # idless, uppins, some time
    u allovse
    n \'of:O'
    
    n sel =>381=><<''
        delete at.c.id;

    u allvse
    
    uppins 621218189: %code:J,v:J,rg:pin
        my $to = $J;
        $to = to.mo.J;
        to.pins.>$pin ||= 1;
        if ($J eq $to) {
            G.oin.inJ.>J.name = $J;
        }
        if ($J eq G.oin) {
            Rw wayty $J $p=Pins;
        }
    
Gum: |
    ar.m || J.done++ && return;
    
    my @h = ar.m ? map{s/-/ /sg;$_}@{ar.m} : die "hi".(
       Ws=>
       Goat=>Goh=>
       # 'Gub',
       'Dub',
       "Doof"
    );
    
    G&wraf,'proc/start',$_ for grep{say "L:oad: $_"} 
        map{"$$: perl got $_ 4 b"} @h;
    

    

Gub: |
    u urw
    y.at.anch = 'Noteal';
    soyt 21:
        five five
    Rw PSF;
    
Dub: | #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    u urw
    #u unicrow
    u UpPg
    u curv=>-curv=><<''
        zoom 0 0.6
        y    0  0
        x    0  0.02
        spun 0.3 -0.2
        curve 0.3 -0.26
    
    #
     #
    # #
    Rw Code;
    
    
    
    $A=
    m exit=>[-dot=>0.02],{},'%hs:594'
    m $_=>[-doJ=>0.04],{},'%hs:896' for qw'JJ PSF';
    
    m Sources=>-bath
    
    y.in = 24;
    y.out = 5;
    
    Mn($_) for @{J.ro.sc.M||[]};
    
    #n sto=>'1-6x33',{loug=>3300,hsb=>376}
    
    
    J.VV.N = 1;
    #my $j = G&A,'S';
    #n Rec=>$C
    
pi/bath: |
    y.clos = 1;
    y.at.mw = 25;
    y.at.mt = -3;
    Rw Sources;
Sources: |
    map{delete $J.>$_ }qw'olp ghut' if J.olp++ > 10;
    
    J.ghut ||= [ G&qh,<<'' ];
        select file, t, ts from gho order by file, t
    
    J.seg ||= 16;
    J.gset ||= [shuffle grep{_.t =~ /^[A-Z]/}@{J.ghut}];
    J.yset ||= [@{J.gset}[1..J.seg]];
    J.seg++;
    my $l = @{J.yset};
    J.yset->[int rand($l)] = J.gset->[J.seg];
    
    m _.t=>-yamco for @{J.yset}
    
pi/yamco: |
    C&ma = 0.3;
    C&hs = int(rand 9).int(3+rand 6).int(3+rand 6);
    C&fs = int(6 + rand 14);
    C&dos = 'yamin';
    C&sha = '2 2 5 849'
    #n t=>1=>C.t=>'%deco'
yamin: |
    my $l = e&hC ->[-1];
    saybl "edit to: ".ki$l;
    G.edit = l.t;
    J.mo.J.se.cod = 1;
Hi: | # youse
    u urw
    n zoo=>12=>'m'=>{on=>'c:hidom',perch=>'#ux',hides=>'#msgs'}
    n Hi
Rel: |
    u urw
    if (0) {
    my @sc= qw'Movy Viow Vind';
    my @take;
    for my $sc (@sc) {
        my $d = "life/W/";
        my $f = $sc.'.sc';
        my @l = read_file($d.$f);
        push @take, map{$d.$_}$f,@l;
    }
    chomp for @take;
    n ze=>-pre=>wdump 3, \@take
    `mkdir n/W`;
    `cp $_ n/W` for grep{!/EarlyCoast/}@take;
    }
    my $in = "public/lowcal\.html";
    my $s = read_file($in);
    
    $s =~ s/(div id=')(msgs')/${1}no$2/s;
    
    $s =~ s/ (\S+window\).on\()/0 && $1/sg;
    
    
    $s = join"\n",grep{!(
        /(href|src)=.(codemirror|light)/ || /a\.con\(w\);/
    )}split "\n",$s;
    
    $s =~ /a\.codeso.+\['(.+)'\];/;
    $1 || die "Canotfind codeso!";
    my @codes = split "', '", $1;
    
    
    `cp life/$_ n/W` for @codes;
    
    write_file("n/index\.html", $s);
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #
Tel: |
    n Hoo
    n Yoo
Hoo: | # sliders and content actuator wormhole
    u srw
    C.sc.qs = 1;
    y.in = 0.05;
    y.out = 0.18;
    delete C.c.s;
    
    n zoo=>1=>'h'=>{on=>'c:hid',perch=>'#ux',fsc=>'o'}
    
    # use random <= 5 to start, make 3 in-sc-issions at a time
    # start off,  #
    m Movy=>-sliT=>{sc=>'%lows:9,vid',s=>0}
    m Viow=>-sliT=>{sc=>'%lows:9,qfa:2'}
    
    m Vind=>-sliT=>{sc=>'%play'}
    
    
Yoo: |
    u srw
    C.sc.qs = 1;
    y.at.anch = 'LeCurve';
    
    n zoo=>45=>'h'=>{on=>'c:hid',hides=>'textarea[cv="0.44"]',fsc=>'o',ml=>'40%',mt=>'40%'}
    
    n s=>44=>'h'=>'%tag:textarea,hs:3984,ml:-9,mt:26%,bgh:3841,fs:24,width:30,height:15,cssdel:transform,bo:0px,sha:3 4 8 691'
    
    J.VV.N = 1;
    
pi/sliT: |
    my $sc;
    sc.fsc = 'Tac';
    G&xot,$sc,$_ for map{G&peel,$_ } grep{defined} c&sc;
    saybl "Xoteted C.t:  ".ki $sc;
    Rw pi/slid + $sc;
    
pi/slid: |
    y.at.qs = 1;
    y.clos = 1;
    n t=>1=>substr(C.t,0,1),'%fs:11'
    $s = 1 if $s eq C.t;
    m C.t=>22=>$s,{pc=>lid=>lid=>1,on=>'ch:crn',%{ar.sc||{}}};
    
And: | # andimation
    u alljs
    
    nw: %args:dp
        var now = Date.now();
        now /= 1000;
        return now;
    
    # func or zet with .fut (next now) .e (func) ##$
    nim:
        $K = typeof s == 'function' && 'N' || 'sN';
        a.WW ||= {};
        a.WW[K] ||= {};
        a.WW[K][C.t] = s;
        if (K == 'sN' && 0) {
            s.ee ||= &e{
                $til = s.fut - a.nw();
                if (til <= 0) {
                    s.e({});
                    til = s.fut - a.nw();
                }
                til <= 0 and ~sucesiv: s.t
                til <= 0 and til = 1;
                a.yl(til,s.ee);
            }
            s.ee();
        }
        ~nimbly: C.t
    
    # W.next && W.next > Date() and return ! #
    frame: %args:e
        a.WW ||= {};
        a.WW.N ||= {};
        a.WW.sN ||= {};
        a.yl(5, &{ a.huf(e) });
    
    rnd: %args:s
        return Math.round( s * 100) / 100
    
    huf: %args:e
        $.each(a.WW.N, &t,M{
            $.each(M, &k,s{
                s(e);
            });
        });
        if (e.count % 10 == 0) {
            $nw = a.nw();
            $gap = nw - (a.tenlast || nw);
            $.each(a.WW.sN, &t,s{
                if (nw < s.fut) {
                    $of = a.rnd(s.fut - nw);
                    //~wai: t, of
                    return
                }
                e.now = nw;
                s.e(e);
            });
            $del = nw - a.tenlast;
            //~tenframes: a.rnd(gap), a.rnd(del)
            a.tenlast = nw;
        }
    
    
    #c only one vid/playlist via iframe, make it end
    # the bigger js for it does everything
    vid:
        ~gotviddy: s, C.t, C
        $l = G&pull,s.t;
        $c = {el:2};
        $sc = {geo:'a1 0.1361 0.3466 -0.3734'};
        if (l.match('^\/')) {
            c.ht = 1;
            c.s = '<video width="600px" autoplay controls><source src="'+l+'"></video>';
        }
        else {
            l = l + "&autoplay=1";
            sc.z = [['i',4,{el:2},{ifr:l}]];
        
        }
        a.om(A.om,[C.t+'eo',4,c,sc],a,{});
    
    # s = TacC.c.r = lidC, have tuned, progress time #
    play:
        $tap = a.zet('tap',s.t);
        tap.e ||= &e{ G&play,s }; G&nim,tap;
        
        $n = G&sand,tap;
        !n and return
        //~play: s.t, n.t, n.sc.int, A
        a.om(A.om,n,a,{});
        
        
    # s = tap wanting time to piece stream of lines into C.sc.z tree
    sand:
        s.tlas ||= a.nw();
        s.next ||= G&land,s;
        n = s.next;
        !n and ~die~nonext: s
        $i = n.sc.int;
        i == undefined and i = 1.3;
        a.timesmoving ||= 1;
        i = i / a.timesmoving;
        s.fut = s.tlas + i * 1;
        $gap = a.rnd(s.fut - s.tlas);
        $til = a.rnd(s.fut - a.nw());
        $ii = '+'+n.sc.ini;
        ~gaptiltz: gap, til, n.t, ii
        til > 0 and return
        
        s.last = s.next;
        s.tlas = a.nw();
        delete s.next;
        $z = [];
        $last;
        while (!s.next && !last) {
            $l = G&land,s;
            !l and last = 1;
            else
            l.c.ind == s.last.c.ind and s.next = l;
            else {
                z.push(l);
            }
        }
        $iz = {};
        z.unshift(s.last);
        while (z.length) {
            $l = z.shift();
            $d = l.c.ind;
            delete l.c.ind;
            if (d) {
                iz[d-1].sc.z ||= [];
                iz[d-1].sc.z.push(l);
            }
            iz[d] = l;
        }
        $l = s.last
        return s.last;
    
    land:
        $l = G&pull,s.t;
        l = l.split("\t");
        $ind = l.shift();
        l = G&inC,l;
        l.c.ind = ind.length;
        return l;
        
Tjs: | # webis
    u alljse
    perch 4:
        $(A.on).appendTo('#ux');
    
    lid 3: %nk:c
        s == '1' and s = '';
        var l = s.split(' ');
        var step = l[0];
        step ||= '0.25';
        var max = l[1];
        max ||= '9';
        var min = l[2];
        min ||= '0';
        s&lows and c&s = (elvis+'').match('[1-'+s&lows+']\\\d') * 0.1;
        s&atr = ['type:range', 'value:'+c&s,
            'min:'+min, 'max:'+max, 'step:'+step].join(',');
        c&tag = 'input';
        delete c&s;
    
    # tune in traction, 0 should rm, all loopi should t up somehow #
    Tac 3:
        if (s <= 0) {
            C.t.match('^V') and return paper.project.clear();
            return $(A.om.on).find('>[cv!="0.9"]').remove();
        }
        
        !s&zoo && !G&get,C.t+'.sc' and T.not = 1; return
        !s&zoo and ~nozoo: C.t
        ~szooing: C.t, s
        c&lo ||= G&qvea,s;
        
        !c&lo || !c&lo.length and ~die~notlong: C.t
        c&lodi ||= 0;
        while (c&lodi < c&lo.length) {
            $v = c&lo[c&lodi];
            if (!v || !v.length) {
                ~die~novlo: v, C
            }
            c&lodi++;
            if (!G&get,v) {
                ~inbac: v
                T.not = 1;
                return
            }
        }
        $cur = a.zet('cur',C.t);
        cur.l = c&lo;
        C.t == 'Vind' && !G&mindu,['Viow'] and return;
        $r = G&ge,'r';
        delete cur.ol;
        r.sc.play and G&play,r;
        r.sc.vid and G&vid,r;
        ~way: C.t, cur.l.length
    
    ifr:
        c&tag = 'iframe';
        s&atr = 'width:500,height:380'
            +',frameBorder:0,allowfullscreen:1,autoplay:1';
        c&src = s;
    
    on 4:
        var h = G&peel,s;
        var el = $(A.on);
        $.each(h, &k,v{
            k == 'c' and k = 'click';
            k == 'ch' and k = 'change';
            el.on(k, &e{
                G&$v,e
            });
            C&fsc and a.yl(420, G&$v );
        });
    
    u alljs
    mindu:
        $waits = [];
        $.each(s, &i,t{ a.zet('cur',t).l || waits.push(t) });
        !waits.length and return 1
        ~needu: C.t, waits.join(',')
        a.yl(231, &{ a.om(A,C,a,{}) });
        T.not = 1;
        return 0;
    
    ge:
        $r = C.c[s];
        $l = [r];
        while (r && r.c && r.c[s]) {
            r = r.c[s];
            l.push(r);
        }
        C.c[s+'eel'] = l;
        return r
    
    qvea:
        $f = s&zoo;
        $p = s * 0.1 * f.length;
        $t = [];
        $q = 1;
        $lim = 1;
        $r = G&ge,'r';
        if (r && r.sc) {
            r.sc.qfa and lim = r.sc.qfa;
            r.sc.qfa and q = r.sc.qfa; lim--;
        }
        lim *= 1;
        q *= 1;
        $e = &i,v{
            $abouts = p < i + q;
            return abouts && (t.length < lim);
        };
        
        a.read(f,t,e);
        return t;
    
    hid:
        $(s&hides || A.mo.on).toggle();
        !s&hides and $(A.om.on).find('[cv="0.4"]').toggle();
    
    crn:
        $sc = {};
        var t = '';
        var fsc = C.t;
        s&fsc and t = C.t; fsc = s&fsc
        sc[fsc] = A.on.value;
        a.om(A.mo,[t,'',{r:C},sc],a,{});
    
    #c read,zet,get,
    read: %args:f t e
        t ||= [];
        $o = [];
        $.each(f, &i,v{
            !v.length and return
            o.push(v);
        });
        $.each(o, &i,v{
            e && !e(i,v) and return
            t.push(v);
        });
        !t.length and t.push(o[o.length - 1]);
        return t
    
    # circle back into A z #1
    # cache sources #
    zet: %args:K t
        a.WW ||= {};
        a.WW[K] ||= {};
        a.WW[K][t] ||= {};
        $s = a.WW[K][t];
        s.t ||= t;
        return s;
    
    get:
        $Was = a.zet('Wa',s);
        $izoo = s.match('\\\.sc$');
        if (Was.last + 90 < a.nw()) {
            ~cached: s
            izoo and s&zoo = Was.l;
            return Was
        }
        $cb = &e{
            Was.l = [];
            a.read(e.split("\n"), Was.l);
            Was.t = s;
            Was.last = a.nw();
            izoo and s&zoo = Was.l;
            a.om(A,C,a,{});
        };
        ~get: s
        $.ajax('/W/'+s).done(cb);
        return 0;
    
    #c pull oinlinre solution, sol wandering
    pull:
        $sol = a.zet('sol',s);
        sol.i ||= 0;
        sol.ii ||= 0;
        sol.i++;
        if (s == 'Viow' && sol.fs && sol.fs.length > 9
            && (sol.i % 3) < 2) {
            sol.ii > sol.fs.length and sol.ii = 0;
            return sol.fs[sol.ii++]
        }
        $cur = a.zet('cur',s);
        !cur and ~NO CUR: s
        !cur.l || !cur.l.length and ~NO CURl: s
        if (!cur.ol) {
            cur.ol = [];
            $.each(cur.l, &i,v{
                $Wa = a.WW.Wa[v];
                !Wa.l and ~die~toprelo: v
                cur.ol.push(Wa)
            });
        }
        cur.i ||= 0;
        $ol = cur.ol[cur.i];
        cur.i++;
        cur.i >= cur.ol.length and cur.i = 0
        
        ol.i ||= 0;
        $f = '';
        $uh = 0;
        while (!f.length && uh < 5) {    
            uh++;
            !ol.l and ~borknine: ol.t, ol.i
            f = ol.l[ol.i];
            //~seek: ol.t, cur.i, ol.i
            ol.i++;
            ol.i >= ol.l.length and ol.i = 0;
        }
        ~many pul: cur.t, ol.t, C.t, ol.i, f
        sol.fs ||= [];
        sol.fs.push(f);
        a.lim(sol.fs,49)
        return f
    
Sho: | #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    u urw
    J.zesat = 1 if !defined J.zesat;
    n edit=>0.01=>'~'=>'%dos:flse,op:J/zesat,to:!,fs:30'
    return unless J.zesat;
    m ze=>-tinput
    m sat=>-slid
    J.vid &&
        m J.vid =>-vid
    J.VV.N = 1;
pi/vid: |
    my $di = 'public/art/';
    (my $see = C.t) =~ s/\W/?/g;
    my @o = glob "$di*$see*";
    saybl "From $see: ".wdump 3,\@o;
    map{
        my ($t) = /^$di(.+)\.\w+$/;
        s/^public\///;
        m $t=>-video=>$_
    } @o
pi/video: |
    y.at.qs = 1;
    n t=>1=>C.t,'%ab,fs:40'
    my $vid = '<video width="900" autoplay controls><source src="'.$s.'""></video>';
    n s=>2=>$vid,'%ht,ml:-50%,zi:-34,tra:3 40'
pi/tinput: |
    C&fs = 17;
    n t=>1=>C.t,'%sha:4 9 5 698'
    
    my $sc = G&peel,'%cod:perl,dig:steve,dos:Tinput,ab';
    sc.width = 2;
    n z =>1 =>'',$sc
    
    #y.at.cssdel = 'transform';
Tinput: |
    # thing!
    A.us&code || return;
    my $sl = e&hC ->[-2];
    sayyl wdump 1, $ar;
    saybl q{Yep: us&code  };
    J.vid = us&code;
    #T.oke = 1;
PSF: |
    u urw
    my $j;
    for (`ps faux | grep perl`) {
        next if /grep perl/;
        my ($user,$pid,$cpu,$mem) = split /\s+/;
        my $p = $1 if /\|(.+)$/;
        $j .= "$pid \t $cpu  $mem \t !  $p\n";
    }
    $j =~ s/     !          //g;
    n date=>0.032=>`date`,'%fs:66,blr:9,opa:7,hs:394'
    n ps=>-pre=>$j
Rec: | # batchy you, web
    #u urw
    u Sugd
    u AmPg
    J.ev.o = 'SpaceFlos';
    J.ev.opl = 'fiew';
    
    Atime(2);
    
    n s=>''=>t
    
    for ( e&C ) {
        sayyl "Rec receives : ".ki $_;
    }
pi/fiew: | # Rec Receiving
    sayyl "Pi J.name receives  some .... ".wdump 3, $s;
Code: |
    y.at.cssdel = 'transform';
    ###
    G.edit ||= 'Dub';
    say "Edito: G.edit";
    J.lA=
    n edit=>0.02=>'~'=>'%dos:flse,op:J/se/cod,to:!,fs:40'
    
    if (J.se.cod) {
        n the=>12=>G.edit
        n 'G/edit'=>[-cde=>'1-2']
        n G.edit=>[-cde=>'2-6'],{},'%ml:-3'
    }
    
CodeMirror: |
    # do in iframe
    n Headstuff=>2=><<''
        <script src="../lib/codemirror.js"></script>
        <script src="../mode/xml/xml.js"></script>
        <script src="../addon/dialog/dialog.js"></script>
        <script src="../addon/search/searchcursor.js"></script>
        <script src="../addon/search/search.js"></script>
        <style type="text/css">
              .CodeMirror {border-top: 1px solid black; border-bottom: 1px solid black;}
              dt {font-family: monospace; color: #666;}
            </style>
        </head>
flse: | # click data fusilagery
    my $r = E.c.hC->[-1];
    if (r.sc.to) {
        r.sc.op || die "nop";
        my $o = I.d&pin,r.sc.op,$A;
        if (r.sc.to eq '!') {
            sayyl "! op to r.sc.op, was: ".
                I.d&pon,r.sc.op,$A,!$o;
        }
        else {
            I.d&pon,r.sc.op,$A,$o+C.sc.to;
        }
    }
    else {
        sayre "How to hold ".wdump 2, $r;
    }
    #sayre "Have flse click: ".wdump 2, $r;
pi/cde: |
    my $he = $s = /\// ? $s : "G/way/$s";
    my $se = G&pin,$he,$A;
    
    my $sc = G&peel,'%cod:perl,dig:steve,dos:upcde,width:24,ab';
    sc.height = C.y.spc * 10;
    n C.t =>1 =>$se,$sc
    
    C.sc.cssdel = 'transform';
upcde: |
    sayre "Upacode J.name: C.t - E.t" for 1..4;
    
    my $t = e&hC ->[-2];
    
    #Rw talkzyh;
    sayyl ":Elvis: ".ki e&us ;
    for (A.us&code) {
        if ("" eq $_) {
            # schedl, sewop #
            saybl "Blank thing";
        }
        else {
            
            my $E = e&us;
            E.t = t.t;
            E.c.s = $_;
            
            Rw Gohup $J $E;
            # goh wind, 
            my $pin = t.c.s;
            say "Upping $pin ---";
            I.d&pon,$pin,$A,$_;
        }
    }
    

