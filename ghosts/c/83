    
Jam: | # idless, uppins, some time
    u allovse
    n \'of:O'
    
    n sel =>381=><<''
        delete at.c.id;

    u allvse
    
    uppins 621218189: %code:J,v:J,rg:pin
        my $to = $J;
        $to = to.mo.J;
        to.pins.>$pin ||= 1;
        if ($J eq $to) {
            G.oin.inJ.>J.name = $J;
        }
        if ($J eq G.oin) {
            Rw wayty $J $p=Pins;
        }
    
Gum: |
    ar.m || J.done++ && return;
    
    my @h = ar.m ? map{s/-/ /sg;$_}@{ar.m} : die "hi".(
       Ws=>
       Goat=>Goh=>
       # 'Gub',
       'Dub',
       "Doof"
    );
    
    G&wraf,'proc/start',$_ for grep{say "L:oad: $_"} 
        map{"$$: perl got $_ 4 b"} @h;
    

    
Gun: |
    Rw forked v;
    Rw forked jes:styclick;
    Rw forked jes:stylext;
Gub: |
    u urw
    y.at.anch = 'Noteal';
    soyt 21:
        five five
    Rw PSF;
    
Dub: | #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    u urw
    #u unicrow
    u UpPg
    u curv=>-curv=><<''
        zoom 0 0.6
        y    0  0
        x    0  0.02
        spun 0.3 -0.2
        curve 0.3 -0.26
    
    #
     #
    # #
    Rw Code;
    
    
    
    $A=
    m exit=>[-dot=>0.02],{},'%hs:594'
    m $_=>[-doJ=>0.04],{},'%hs:896' for qw'JJ PSF';
    
    m Sources=>-bath
    
    y.in = 24;
    y.out = 5;
    
    Mn($_) for @{J.ro.sc.M||[]};
    
    #n sto=>'1-6x33',{loug=>3300,hsb=>376}
    
    
    J.VV.N = 1;
    #my $j = G&A,'S';
    #n Rec=>$C
    
pi/bath: |
    y.clos = 1;
    y.at.mw = 25;
    y.at.mt = -3;
    Rw Sources;
Sources: |
    map{delete $J.>$_ }qw'olp ghut' if J.olp++ > 10;
    
    J.ghut ||= [ G&qh,<<'' ];
        select file, t, ts from gho order by file, t
    
    J.seg ||= 16;
    J.gset ||= [shuffle grep{_.t =~ /^[A-Z]/}@{J.ghut}];
    J.yset ||= [@{J.gset}[1..J.seg]];
    J.seg++;
    my $l = @{J.yset};
    J.yset->[int rand($l)] = J.gset->[J.seg];
    
    m _.t=>-yamco for @{J.yset}
    
pi/yamco: |
    C&ma = 0.3;
    C&hs = int(rand 9).int(3+rand 6).int(3+rand 6);
    C&fs = int(6 + rand 14);
    C&dos = 'yamin';
    C&sha = '2 2 5 849'
    #n t=>1=>C.t=>'%deco'
yamin: |
    my $l = e&hC ->[-1];
    saybl "edit to: ".ki$l;
    G.edit = l.t;
    J.mo.J.se.cod = 1;
Hoo: | # sliders and content actuator wormhole
    u urw
    y.out = 2;
    m Vind=>-sliT=>{sc=>'%play'}=>
    # use random <= 5 to start, make 3 in-sc-issions at a time
    m Viow=>-sliT=>{sc=>'%stoneto:5,qfa:3'}
    # start off, 
    m Movy=>-sliT=>{sc=>'%vid',s=>0}
    J.VV.N = 1;
pi/sliT: |
    my $sc;
    sc.fsc = 'Tac';
    G&xot,$sc,$_ for map{G&peel,$_ } grep{defined} c&sc;
    saybl "Xoteted C.t:  ".ki $sc;
    Rw pi/slid + $sc;
    
pi/slid: |
    y.at.qs = 1;
    y.clos = 1;
    n t=>1=>C.t,'%fs:11'
    $s = 1 if $s eq C.t;
    m C.t=>22=>$s,{pc=>lid=>lid=>1,on=>'c:crn',%{ar.sc||{}}};
    
And: | # andimation
    u alljs
    
    nw: %args:dp
        var now = Date.now();
        now /= 1000;
        return now;
    
    nim:
        A.W.N ||= [];
        A.W.N.push(s);
        ~nimbly: A.W.t
    
    # W.next && W.next > Date() and return !
    frame: %args:e
        var now = Date.now();
        $.each(ww, &t,W{
            !W.N and return
            $.each(W.N, &k,on{
                on(e);
            });
        });
    
    # s = TacC.c.r = lidC, have tuned, progress time
    play:
        A.W.N[s.t] = &e{ G&play,s };
        $tap = a.zet('tap',s.t);
        $n = G&sand,tap;
        !n and return;
        ~play: n
        a.om(A.mo,n,a,{});
        
    # s = tap wanting time to piece stream of lines
    sand:
        s.snow = a.nw();
        s.slas ||= s.snow;
        $deal = s.snow - s.slas;
        s.next ||= G&land,s;
        !s.next and ~die~nonext: s
        // p
        s.next.sc.int > $deal and return
        s.last = s.next;
        s.tlas = a.nw();
        delete s.next;
        $z = [];
        while (!s.next) {
            $l = G&land,s;
            !l && last;
            l.c.ind == s.last.c.ind and s.next = l; last;
            z.push(l);
        }
        $iz = {};
        z.unshift(s.last);
        while (z.length) {
            $l = z.shift();
            $d = l.c.ind;
            iz[d-1].sc.z ||= [];
            iz[d-1].sc.z.push(l);
            iz[d] = l;
        }
        ~sanded: s.next
        return s.next;
    
    land:
        $l = G&pull,s.t;
        l = l.split("\t");
        $ind = l.shift();
        l = G&inC,l;
        l.c.ind = ind.length;
        return l;
        
Tjs: | # webis
    u alljs
    # circle back into A z #1
    get:
        a.WW ||= {};
        a.WW.Wa ||= {};
        a.WW.Wa[s] ||= {};
        $Was = a.WW.Wa[s];
        if (Was.last + 90 < a.nw()) {
            ~cached: s
            C&zoo = Was.l;
            return 1;
        }
        $cb = &e{
            $l = e.split("\n");
            Was.l = l;
            Was.last = a.nw();
            if (s.match('\\\.sc$')) {
                C&zoo = l;
                a.om(A,C,a,{});
            }
        };
        ~get: s
        $.ajax('/W/'+s).done(cb);
    
    zet: %args:K t
        a.WW ||= {};
        a.WW[K] ||= {};
        a.WW[K][t] ||= {};
        $s = a.WW[K][t];
        s.t ||= t;
        return s;
    
    # cur short list of image/etc list Wa[s], sol list line wanderings
    pull:
        $sol = a.zet('sol',s);
        sol.i ||= 0;
        sol.ii ||= 0;
        sol.i++;
        if (s == 'Viow' && sol.fs && sol.fs.length > 9
            && (sol.i % 3) < 2) {
            sol.ii > sol.fs.length and sol.ii = 0;
            return sol.fs[sol.ii++]
        }
        $cur = a.zet('cur',s);
        !cur and ~NO CUR: s
        !cur.l || !cur.l.length and ~NO CURl: s
        if (!cur.ol) {
            cur.ol = [];
            $.each(cur.l, &i,v{ cur.ol.push(a.WW.Wa[v]) });
        }
        cur.i ||= 0;
        $ol = cur.ol[cur.i];
        cur.i++;
        cur.i >= cur.ol.length and cur.i = 0
        
        ol.i ||= 0;
        $f = '';
        $uh = 0;
        while (!f.length && uh < 5) {    
            uh++;
            $f = ol.l[ol.i];
            ol.i++;
            ol.i >= ol.l.length and ol.i = 0;
        }
        ~many pul: uh, C.t, ol, ol.i
        sol.fs ||= [];
        sol.fs.push(f);
        return f
    
    u alljse
    # tune in traction
    Tac 3:
        !C&zoo && !G&get,C.t+'.sc' and return T.not = 1;
        c&zooi = (s / 9) * C&zoo.length;
        $qfa = 1;
        $len = 1;
        c&r && c&r.sc.qfa and len = c&r.sc.qfa;
        c&r && c&r.sc.qfa and qfa = c&r.sc.qfa; len--;
        $lo = [];
        $.each(C&zoo, &i,v{
            !v.length and return
            $abouts = i + qfa > c&zooi;
            abouts && (lo.length < len) and lo.push(v)
        });
        $.each(lo, &i,v{
            !v.length and return
            G&get,v;
        });
        a.WW ||= {};
        a.WW.cur ||= {};
        $cur = a.WW.cur[C.t] = {};
        cur.l = lo;
        c&r && c&r.sc.play and G&play,c&r;
        c&r && c&r.sc.play and G&vid,c&r;
        ~way: C.t, cur.l.length
    
    
    lid 3: %nk:c
        s == '1' and s = '';
        var l = s.split(' ');
        var step = l[0];
        step ||= '0.25';
        var max = l[1];
        max ||= '9';
        var min = l[2];
        min ||= '0';
        C&stoneto and c&s = (elvis+'').match('[1-'+C&stoneto+']\\\d') * 0.1;
        C&atr = ['type:range', 'value:'+c&s,
            'min:'+min, 'max:'+max, 'step:'+step].join(',');
        c&tag = 'input';
        delete c&s;
    
    u alljs
    crn:
        $sc = {};
        var t = '';
        var fsc = C.t;
        C&fsc and t = C.t; fsc = C&fsc
        sc[fsc] = A.on.value;
        a.om(A.mo,[t,'',{r:C},sc],a,{});
    
Sho: | #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    u urw
    J.zesat = 1 if !defined J.zesat;
    n edit=>0.01=>'~'=>'%dos:flse,op:J/zesat,to:!,fs:30'
    return unless J.zesat;
    m ze=>-tinput
    m sat=>-slid
    J.vid &&
        m J.vid =>-vid
    J.VV.N = 1;
pi/vid: |
    my $di = 'public/art/';
    (my $see = C.t) =~ s/\W/?/g;
    my @o = glob "$di*$see*";
    saybl "From $see: ".wdump 3,\@o;
    map{
        my ($t) = /^$di(.+)\.\w+$/;
        s/^public\///;
        m $t=>-video=>$_
    } @o
pi/video: |
    y.at.qs = 1;
    n t=>1=>C.t,'%ab,fs:40'
    my $vid = '<video width="900" autoplay controls><source src="'.$s.'""></video>';
    n s=>2=>$vid,'%ht,ml:-50%,zi:-34,tra:3 40'
pi/tinput: |
    C&fs = 17;
    n t=>1=>C.t,'%sha:4 9 5 698'
    
    my $sc = G&peel,'%cod:perl,dig:steve,dos:Tinput,ab';
    sc.width = 2;
    n z =>1 =>'',$sc
    
    #y.at.cssdel = 'transform';
Tinput: |
    # thing!
    A.us&code || return;
    my $sl = e&hC ->[-2];
    sayyl wdump 1, $ar;
    saybl q{Yep: us&code  };
    J.vid = us&code;
    #T.oke = 1;
PSF: |
    u urw
    my $j;
    for (`ps faux | grep perl`) {
        next if /grep perl/;
        my ($user,$pid,$cpu,$mem) = split /\s+/;
        my $p = $1 if /\|(.+)$/;
        $j .= "$pid \t $cpu  $mem \t !  $p\n";
    }
    $j =~ s/     !          //g;
    n date=>0.032=>`date`,'%fs:66,blr:9,opa:7,hs:394'
    n ps=>-pre=>$j
Rec: | # batchy you, web
    #u urw
    u Sugd
    u AmPg
    J.ev.o = 'SpaceFlos';
    J.ev.opl = 'fiew';
    
    Atime(2);
    
    n s=>''=>t
    
    for ( e&C ) {
        sayyl "Rec receives : ".ki $_;
    }
pi/fiew: | # Rec Receiving
    sayyl "Pi J.name receives  some .... ".wdump 3, $s;
Code: |
    y.at.cssdel = 'transform';
    ###
    G.edit ||= 'Dub';
    say "Edito: G.edit";
    J.lA=
    n edit=>0.02=>'~'=>'%dos:flse,op:J/se/cod,to:!,fs:40'
    
    if (J.se.cod) {
        n the=>12=>G.edit
        n 'G/edit'=>[-cde=>'1-2']
        n G.edit=>[-cde=>'2-6'],{},'%ml:-3'
    }
    
CodeMirror: |
    # do in iframe
    n Headstuff=>2=><<''
        <script src="../lib/codemirror.js"></script>
        <script src="../mode/xml/xml.js"></script>
        <script src="../addon/dialog/dialog.js"></script>
        <script src="../addon/search/searchcursor.js"></script>
        <script src="../addon/search/search.js"></script>
        <style type="text/css">
              .CodeMirror {border-top: 1px solid black; border-bottom: 1px solid black;}
              dt {font-family: monospace; color: #666;}
            </style>
        </head>
flse: | # click data fusilagery
    my $r = E.c.hC->[-1];
    if (r.sc.to) {
        r.sc.op || die "nop";
        my $o = I.d&pin,r.sc.op,$A;
        if (r.sc.to eq '!') {
            sayyl "! op to r.sc.op, was: ".
                I.d&pon,r.sc.op,$A,!$o;
        }
        else {
            I.d&pon,r.sc.op,$A,$o+C.sc.to;
        }
    }
    else {
        sayre "How to hold ".wdump 2, $r;
    }
    #sayre "Have flse click: ".wdump 2, $r;
pi/cde: |
    my $he = $s = /\// ? $s : "G/way/$s";
    my $se = G&pin,$he,$A;
    
    my $sc = G&peel,'%cod:perl,dig:steve,dos:upcde,width:24,ab';
    sc.height = C.y.spc * 10;
    n C.t =>1 =>$se,$sc
    
    C.sc.cssdel = 'transform';
upcde: |
    sayre "Upacode J.name: C.t - E.t" for 1..4;
    
    my $t = e&hC ->[-2];
    
    #Rw talkzyh;
    sayyl ":Elvis: ".ki e&us ;
    for (A.us&code) {
        if ("" eq $_) {
            # schedl, sewop #
            saybl "Blank thing";
        }
        else {
            
            my $E = e&us;
            E.t = t.t;
            E.c.s = $_;
            
            Rw Gohup $J $E;
            # goh wind, 
            my $pin = t.c.s;
            say "Upping $pin ---";
            I.d&pon,$pin,$A,$_;
        }
    }
    

