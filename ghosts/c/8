  
floatation: |
    # Wencaps the Wubstance behind the Jaulted door
    # good for clouding away entropy from the foundation
    # so so, wants to separate heaps
    
    # kicks rays off the end of sev (or so)
    # all the stuff is is s by now if its making lines
    # or its a bunch of whatever, to json onto new line
    
    # also to sever things where sc.W c.W + id (if they are reachable via Wspace)
    # pi can also sever into channels of art noise + realmy stuff
    # float the bets
    # edge thje het
    
        #   R writef life/W/em.is.W\.c em.lines $append:em.i
        # G is a tied hash, resolves to doing like I through G.d
        # R makes I from further Wish inquiry, G does similar
        # R implies floatation
        # repeast                       G.fsk.oth (does little I.oth where C is t=k s=v)

        # kind of wants lvish pointerism - you would get it from ^ids or so
        # osc idly (was around before) would keep j etc, 
        # handy for travelish reentrances by third parties
        # Jmosts must subscribe to the Goin osc...
        # which give them a G-finding W above their own W
        # which they dont know about, it's routed to...
    

        # J.mo.s is G.oin

    #u openphase
    #u threestep
    # root of the chuck out lines only sort
    # when 8s groW time on G.oin
    # C.c.In && A.t&62 &&

    # to connect Gw so A.t&63 to hold things again, merge many Rw personas into one live as repeated subs with blanky u,etc,y.at outthrustocombing, since everything goes within to sed out - sometimes holding what it was originally for loop
    # the whole control panel of J.? of ^\w .* funcs is up, line feed, code is cracking open a valley

    # Followe:
    # ^ u threes
    # ^ qq {cpi:lines u:followlines}
    # which is normal perl code^and replies to the u qq seeming
    # want to consume every void context stuff as mind
    # u/n symbol family, j for nonJmo:
    # ^ j qq {cpi:lines u:followlines}
    # or perhouse (some Jness)
    # ^ j:interso qq {cpi:lines u:followlines}
    # when vector compose program
    
    # is kinda 
    # little j eventuates index of doings to follow index
Sl: |
    #n JSlines =>W=>{s=>$J}
    #u alljs
    y.at.jslines = 1;
    y.at.oWl = 1;
    n reJSlines
    J.V = 1;
    
    n bawls =>3=><<'','%js'
        var v = $('#msgs');
        a.m("SOmething clea r "+v);
    
    n Details
    
    my $n = J.fsjoi++;
    $n && 1;
    $n || Rw loopby $b=0.6 $d=2 $p=Top;
EYZ: |
    u ReoCur
    u curv =>pi=><<''
        zoom 0  0.6
        y    0  0
        x    0  0
        curve 0 0.04
    
    Mn(shedful => '', {pi=>'eye',s=>'eye/Tarf'});
    n TeCurve =>$J
TeCurve: | # plop W space resolve
    y.at.unit = 1; # e W come by, upper state could kink into curv
    # it pis into I... suu
    u ReoCur
    u curv =>pi=><<''
        zoom 0 1.4
        y    0  0
        x    0  0.02
        curve 0 -0.2
        curve 0.4 0.4
        spin 0.3 2

    for (A.e&C) {
        # y.unit 
        sayyl "GOT SPACE ELVIS: _.t   _.y.cv "
            .wdump 2, ["",''];
    }
    J.V = 1;
    # weird mediation between placed J.C and J.root to plop W 
Claw: |
    y.at.shape = 1; # advise e to draw in
    u curv =>pi=><<''
        zoom 0  0.7
        y    0  0
        x    0  0
        curve 0 0.1
    
pi/curv: | # source/be ex
    u GeoSlur
    J.V = 1;
    for (A.e&C) {
        sayyl "Placing in J.name ::: ".ki $_ for 1..5;    
        return y.ope = 1;
    }
    J.VV.C = 1;
    n $_ for split "\n", $s;
    # ^ fill gaps > 0.1 at 0.1s, or maybe all 0.1s
    # so produce
findupi: |
    my $Ye;
    for ('El/qq/El/Duv') {
        $Ye = I.d&pin,$_,$J;
        last if $Ye;
    }
    my @curv = grep { _.sc.pi eq 'curv'} values %{Ye.tv};
    @curv = map{J.El.qq.bb->{$_}} grep{/curv\tJ$/} keys%{J.El.qq.bb} if !@curv;
    die "many ".wdump \@curv if @curv > 1;
    shift @curv
    
ReoCur: | # inner bracken resolve (for randoms)
    # wants to reach qq... do ^qq/(.+) root reacumin
    # u pi is I art
    # sinky massive spiral space, name system of
    # this is the thin osc superfactor
    # could climb in by V.cvi and atom or blend geos
    #n 'allovse'=>2,<<'','%code:In 4189'
    u allvse
    n '','','%of:Sev'
    n J =>3212=><<'',{rg=>'J,Y,ylv,yvl'}
        return if C.c.root;
        my $csrc = Y.csrcmostly ||= do {
            my $cs = Rw findupi $I $J curv;
            my $from = "Jse" if $cs;
            $cs ||= do {
                $from = "Clawdef";
                my $def =
                n Claw
                Rw findupi $I $J:def.nj curv;
            };
            sayyl "Finding J.name  $from:  cs.t";
            say "J.name  Got curve: ".ki $cs;
            $cs || sayre "No curve J.name"
        };
        saybl "J.name Gainst: C.t  C.y.cv ";
        # might wanna crawl
Teal: | # de al
    n 'curvsligu'=>2,<<'','%code:In 4189'
        return unless C.t eq 'curves';
        
GeoSlur: |
    # may +atomb? without compare you are dead
    u allacgts
    n atom =>''=><<'',{acgt=>'last,here'}
         # spacin
         here.dist = here.cv - last.cv;
         # twistin spin inherit
         here.spin += last.spin;
         # scale local-local change
         here.rad += here.spin * here.dist * 10;
         # builds rad on rad
         here.rad += last.rad;
         # distort space + more ways, orbital
         # chuck skeletons for mods
         # adapt M meta for what kinda places things want
         # into constellations of high level things
         # atomised hairs
         here.zoom ||= last.zoom;
         here.dist *= here.zoom if here.zoom;
         # and move
         here.x = last.x + (here.rad ? cos(here.rad) : 0) * here.dist;
         here.y = last.y + (here.rad ? sin(here.rad) : 1) * here.dist;
    
    n ron =>''=><<''
        0.0001 * int(10000*$s)
    
    u allvse
    n '','','%of:Sev'
    
    n root =>24111=><<''
        # root holds this 0, next any is a thing...
        # squary downy
        my $l = C.y.last = {};
        l.x = C.sc.x||0;
        l.y = C.sc.y||0;
        l.cv = 0.001;
        l.rad = C.sc.rad||$RADIAN;
        l.spin = C.sc.spin||0;
    
    n J =>3213=><<'',{rg=>'J,Y,V,yat',l=>'#c get here'}
        my $i = Y.kvi->{C.y.k};
        # mapping intents into chain reactions
        # sleeps if prev here same, shifting arms
        # make bouncey land time, things joiN post-Sly if engaged
        if (C.c.root) {
            # roots here is remote, elvis space vectors
            # ab:100 + top/left/rad
            # and when host space ins see/want e into geo they can:
            #  - blend between figured there geos
            #  - insert & osc the stranger:
            my $Wsp = C.sc.Wsp||'TeCurve';
            #n $Wsp=>$C,$J
            #C.y.here || C.sc.geo || die "$Wsp didnt set geospacei ! ".ki $C;
        }
        else {
            my $last;
            if ($i == 0) {
                $last = Y.root.y.last || die "no root ylast";
            }
            else {
                # alv is lv but early, but it doesn't want to be (?)
                # so its place to find last C.y.here for others
                # at is your outgoing awakeness
                # wakeup should haps when src change....
                # the process of this is off
                # & to spirals, potentially...
                # deep[end te data somewhere
                my $lC = Y.vs->[$i-1] || die "nof leftoi $i";
                my $lk = lC.y.cv."\t".lC.t;
                my $llv = V.alv->{$lk};
                $llv || die "No lv left of C.y.k:  $lk ".wdump[V.alv];
                $lC = llv.C || die "nollv $lk";
                $last = llv.C.y.here || die "bnoi yhere".ki $lC;
            }
            # eat last, make here here
            $last = {%$last};
            my $here = C.y.here = {};
            # moves
            here.cv = C.y.cv;
            my $r = {};
            if (!keys %{C.sc}) {
                #sayre "- asume @ C.y.cv  C.t = C.c.s   istrunctio";
                $r->{C.t} = C.c.s;
            }
            here.x  = last.x = r.x if exists r.x;
            here.y = last.y = r.y if exists r.y;
            here.rad = 4*$RADIAN * r.spun if exists r.spun;
            here.zoom = r.zoom if defined r.zoom;
            .
            I.d&atom,$last,$here;
            here.spin = r.curve if exists r.curve; # on the level
            #
            here.x = I.d&ron,here.x;
            here.y = I.d&ron,here.y;
            here.rad = I.d&ron,here.rad;
            # here may inc down compression styles geo is expanded
            if (J.C.c.e eq C.c.s) {
                sayyl "ElvisSpace: A.J.name C.y.k  is holding: ".ki C.c.s;
                C.c.s.y.here = $here;
            }
        }
    
    n J =>3214=><<'',{rg=>'J,Y,V,yat',l=>'#c wait here'}
        my $here = C.y.here;
        $here || return sayre "NO HERE C.y.k";
        return sayyl "C.y.k  has e geo: C.sc.geo" if C.sc.geo;
        .
        my $geo = {};
        geo.rad = here.rad;
        # unwind (into...)
        my $o = $RADIAN*4;
        my $swish = $o;
        $swish *= -1 if geo.rad < 0;
        my $i = 0;
        geo.rad -= $swish until
            do {$i++>5&&die"$i muchwind".ki$here;0}
            ||
            $o*-1 < geo.rad && geo.rad < $o*4;
        # pan to hemisphere...
        # from O- is it in the left hemisphere etc
        my $rad = geo.rad;
        my $radleg = -$RADIAN;
        $radleg *= -1 unless $rad < -$RADIAN && $rad > $RADIAN;
        $rad -= $radleg;
        geo.radial = I.d&ron,$rad;
        geo.x = here.x;
        geo.y = here.y;
        geo.ab = '100' if 1; # w=h=100,ab=1
        # transform about
        geo.tro = '0 0.5'; # midleft
        geo.tro = '0 0' if 0; # topleft
        #
        my $fo = sub { (shift() * 100).'%' };
        geo.tro = join' ',map{$fo->($_)}split' ',geo.tro;
        # shove com toeget
        # OR SOMETHING
        # loses its compressibility as csz
        my @am = qw'a? ab  x x  y y  r radial  s scale';
        my @l;
        while (@am) {
            my $k = shift @am;
            my $v = shift @am;
            my $sens = $k =~ s/\?$//;
            push @l, ($sens && $k).$geo->{$v} if exists $geo->{$v};
        }
        my $l = join ' ', @l;
        C.sc.geo = $l;
        if (J.C.c.e eq C.c.s) {
            sayyl "ElvisSpace: A.J.name C.y.k  is holding: ".ki C.c.s;
            C.c.s.sc.geo = $l;
        }
    
    
Details: |
    u ReoCur 
    for (A.us&C) {
        sayyl "Goots: ".wdump $_;
    }
    for (A.us&time) {
        J.icker += $_;
    }
    J.V = 1;
    y.at.ux = 1;
    my $n = J.sdjfsiji ||= int rand 9;
    n b320 => '3-9x7',join'',($n) x 3
    n latelo => '12', '12-'.J.icker
    n TeCurve =>$C=>$J
Wight: |
    n Funstuff
    n JScomp
    n JSea
    # could ahh...
    
    n JSlines =>$J
    
    my $n = J.fsjoi++;
    $n || Rw loopby $b=0.2 $d=17 $p=Top;
Sight: |
    n stylehut
    # could ahh...
    n JSlines =>W=>{s=>$J}
    
reJSlines: | # could spiral intuit re$W to just this - A coney islands
    y.at.ressur = 'JSlines';
JSlines: |
    y.at.jslines = 1;
    y.ope = 1;
    n $C
Followe: |
    # (everything threes)
    u linesfollow
    u Ipifalls
    
    y.ope = 1;
    y.at.oWl = 1;
    # y.at.es = 'closeline' # & a provider of closeline = Trabit
    J.ev.th ||= 'openevent';
    
    sayyl "Checkin following...";
    !ref $s && $s &&
    n Follow =>''=>{pi=>cfile=>s=>$s,create=>1}
    
    n $C
Trabit: |
    u pi3d
    u Ipifalls
    y.ope = 1;
    J.ev.th = 'closeline';
    n $C
linesfollow: |
    u allvse
    n '','','%of:J'
    n J =>62221,<<''
        C.c.pi eq 'lines' &&
        u followlines
    
followlines: |
    u allovse
    n '','','%of:Sev'
    
    n LinesFollow =>4431=><<'',{Td=>'V/*/new',Tdarge=>'iv,ov'}
        T.noTd = 1;
        return unless C.sc.pi eq 'line';
        my $oJ = $J;
        $J = J.mo.J;
        $C = I.d&hup,$C;
        C.c.was = !Y.root.y.ta;
        # should be refering to the one and the one of the event
        saybl "Got pi line!             C.c.s";
        saybl "";
        n J.C.t,$C,$oJ
        # may like to grab the element before it
        # like a curve continuing
    
putmoves: |
    u allovse
    n '','','%of:Sev'

    n Y =>31=><<'',{rg=>'J,V,yk'}
        # patch new to old where same t,s, add Vhooks
        C.y.lv = {k=>$k,C=>$C};
        C.y.at = {};
        C.y.ta = V.ta->{$k};
        C.y.vl = V.lv->{$k};
        if (C.c.root) { # / continues from 3 when everything's 6
            Y.root = $C;
            T.Z->{0.6} = 0.3;
            T.not = 1;
        }
SevWo: |
    n Meta
    n Wuts
    
    u allacgts
    
    n writef =>''=><<'',{acgt=>'f,s,append'}
        (my $d = $f) =~ s/\/[^\/]+?$//;
        unless (-d $d) {
            `mkdir -p $d`;
        }
        .
        $s = [$s] if !ref $s;
        my $li = ref $s eq 'ARRAY' ? join("",map{/\n$/?$_:"$_\n"}@$s)
            : die "Wsome other $f type: $s";
        $li = encode_utf8 $li;
        .
        my $wa = {};
        wa.append = 1 if $append;
        write_file($f,$wa,$li);

    u allovse
    n '','','%of:O'
    n J =>35=><<''
        delete at.sc.J if C.c.S;
        # conceal the multiJexits
    
    u allvse
    n '','','%of:Sev'
    # might wanna carebowl em 2-4 to engage scd/em at all
    n root =>582=><<'',{rg=>'ylv,yvl'}
        return unless A.J.most.J eq A.J || A.J.C.c.Wo;
        my $r = Rw scd $rl:vl $rv:lv;
        return unless @{r.z};
        aft { $@ || return; sayre "$@  !~!! ".wdump 9, $r; };
        C.c.em && die'wtf';
        .
        my $em = C.c.em = {};
        em.lines = r.z;
        em.i = @{r.oldz};
        .
        A.Subtle.em = 1;
        A.t&em,6,2;
    
Meta: |
    u allvse
    n '','','%of:em'
    n em =>21=><<''
        em.lines || die "Not lines";
        em.hitime = hitime();
        em.is.W = C.sc.Wid || A.J.id;
        em.is.M = C.sc.Mid || A.J.name;
        em.id = em.is.W.'.'.(0+em.i);
    
    u allsvse
    # split into line forms
    n jslines =>3=><<'',{cg=>'J,em'}
        my $N = [@{em.lines||die"Nop"}];
        @$N = Rw humms $J $N wongui _;
        @$N = Rw humms $J $N notnotjs _;
        my $S = Rw humms $J $N spots;
        em.lines = [map{
            " a\.e(".sjson($_).");"
        }@{S.z}];
        C.c.os = 1 if !grep {/\S/} @{S.z};
        C.sc.Wc = 1;
    
    n ux =>3=><<'',{cg=>'em'}
        my $J = G.oin;
        my $M = ['','',{W=>J.id},{z=>em.lines}];
        em.lines = [" a\.om({},".sjson($M).",a,{});"];
        C.sc.Wc = 1;
        n GW
        # ^ router, W with an .e v
    
    # event feedback (even tee rollistic trickles) donafto, drops
    n eve =>3=><<'',{cg=>'J,em'}
        `touch life/W/em.is.W\.e`;
        J.mo.s.al.opt.fole = [Followe=>W=>"life/W/em.is.W\.e"];
        # routes ids[] into All(Oth)
    
    n ressur =>3=><<'',{cg=>'J,em'}
        saybl "Ressurrecting $ressur ...";
        die "zomp $ressur" if $ressur =~ /\W/;
        die "bno JSlines" unless -e "life/W/$ressur";
        `cd life; ln -s ../W/$ressur J/em.id\.c`;
        my $catch = sjson {y=>J=>id=>em.id};
        I.d&writef,"life/J\.s",$catch,1;
        T.whack = 1; # out of em
    
    
    
Wuts: |
    u allsvse
    n '','','%of:em'
    n Wc =>446=><<'',{cg=>'J,em'}
        saybl "Downing em.is.M: em.is.W: ".wdump 5,em.lines;
        I.d&writef,"life/W/em.is.W\.c",em.lines,em.i;
        .
        # is coming soon: (only space or)
        C.c.as = !C.c.os;
        C.c.As = C.c.as;
        C.sc.meta = 1;
        C.sc.speak = 1 if C.c.as;
        C.sc.takeover = 1 if C.c.As;
        saybl "WHITESPACE S em.is.M" if C.c.os;
    
    # inter intros
    n meta =>47=><<'','%cg:em'
        G.Wh->{em.is.W} && return;
        G.Wh->{em.is.W} = A.J;
        my $me = I.d&hup,$em;
        delete me.lines;
        $me = sjson $me;
        I.d&writef,"life/W/em.is.W\.i",$me;
    
    n speak =>48=><<'','%cg:em'
        return if G.Jlone;
        .
        I.d&writef,"life/J/em.id\.c",em.lines;
        .
        my $catch = sjson {y=>J=>id=>em.id};
        I.d&writef,"life/J\.s",$catch,1;
    
    n takeover =>49=><<'','%cg:em'
        -l $_ && `unlink $_` for "life/W/em.is.M";
        `cd life/W; ln -s em.is.W\.c em.is.M`;
    
    
Travel: # make somewhere bridge
   yJ: |
     'clw waz gui'
   sh: |
     Rw J5 shv $aj;
   Em: |
     Rw Emvil;
Emvil: |
     my $tw = Rw huck $J $aj */sh;
     $tw || die "nomount J.name";
      
     my $c = aj.c;
     die 'scs' if @{aj.sc};
     die 's' if aj.s;
     my $M = ['','',{W=>G.Wid},{z=>aj.c}];
     
     #sayyl wdump 15, $M if aj.J.name eq 'Vuel';
     aft {
         $@ || return;
         sayre "$@  !~!! ".wdump 35, $M;
     };
     aj.c = [" a\.om({},".sjson($M).",a,{});"];
     aj.sent = 1;
     
     Rw paintaj $aj;
     
     # route aj.W from ...
     G.Wh->{aj.Wid} ||= do {
         my $ij = {}; map {
         $ij->{$_} = $aj->{$_} if !/^[sc]+/; } keys %$aj;
         ij.id = delete ij.Wid;
         ij.y = 'W';
         
         sayyl "Life! of ij.y ij.id";
         0->tai("ij.y/ij.id\.i", $ij);
         0->tac("V/H.style/H.name/H.id\.s", ztm($ij));
         aj.J;
     };

     Rw J5 wu $aj;
     
     aj.y ||= 'J';
     aj.yy = 'W';
     Rw aji $aj;
     Rw blabaj $aj;
somewhere: | # be somewhere
     my @path = ar.j.sc.J || ar.j.J;
     while (1) {
        my $l = $path[0];
        unshift @path, l.Jiter || last;
     }
     #saybl wdump 2, ["Gootblock:",@path];
     
     say "avoid: ".gp shift @path until !@path || $path[0] eq $J;
     shift @path;
     my $path = join '/', map{_.C.t} @path;
     
     my $A = J.A;
     my $v = G.pwin->("in/$path", $A);
     my $amo = 1.5;
     $amo = 0.8 if e.S;
     (v._.y.thy ||= 1) *= $amo;
     say "A in assign". wdump 14, [gp($J), $path, $v];
     return;
     
     #die wdump 2, [@lspath]; 
     #my $path = join '/', reverse @lspath;
     my $M = [];
     
     Mn('fro',{},"$path",'{ou:file}');
     
     Rw J5 wut $M;
siueon: |
    iroughoan anonate
paintaj: |
     aj.Wid || die "not Wid?";
     aj.hol = "H.style/H.name/H.id";
     aj.hitime = hitime;
     aj.name ||= aj.J.name;
thing2: |
   fow
hip_po: |
    tree-ish campus
    str i sin tko
things: |
    with suct ion
Mainiy: |
    things in 
Steve: |
   was h ere

