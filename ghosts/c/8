  
Wight: |
    u SevWo
    J.V = 1;
    n JSea
    n s=>''=>t
    # could ahh...
    n JSlines =>W=>{s=>$J}
    
JSlines: |
    u threes
    u SevWo
    y.ope = 1;
    #u openphase
    #u threestep
    # root of the chuck out lines only sort
    # when 8s groW time on G.oin
    # C.c.In && A.t&62 &&
    n $C
    
    
pi/pane: |
    #u perCcsomethingtracepha
    n $_ for map{values %$_}values %$s
threes: |
    u allvse
    J.V = 1;
    n '','','%of:oJ'
    n J =>344,<<''
        !ref $J && die "NotrefJ: $J  ".ki $C;
        if ($J eq A.J) { # deal with self later
            my $s = C.c.s;
            ref $s && s.bb || die "s not J";
            A.J ne $s || die "dupe s.name ion A.J.name";
            sayyl "On A.J.name   with s.name";
            C.c.IsOn || return do {
                Rw wayt $J $C $d=0.01 $p=jive;
                T.not = 1;
            };
            # no J being tricks for handulation
            A.Iso.th = 1;
            delete A.Iso.oJ;
        }
        else {
            say "Noine  for A.J.name  's      J.name";
        }
    
    n '','','%of:th'
    n J =>4,<<''
        # I.d&take,$s
        my $oJ = C.c.s;
        sayyl "44444444n A.J.name   with s.name";
        ref $oJ && oJ.bb || die "NoJ";
        my $so = J.oJ->{oJ.name} ||= {};
        # mong beans
        # is {M:name,W:id} coupling, so pi is {file:g/c/1} etc
        my $Y = oJ.El.Duv;
        my $rv = Y.rv;
        if (@{rv.sc}) {
            sayre "J.name SLIPPING SC" for 1..5;
            sleep 4;
        }
        if (rv.i eq so.rv.i) {
            say "J.name receiving same oJ.name";
            return;
        }
        so.rv = $rv;
        my $N = [@{rv.c}];
        # get that banjo
        @$N = Rw humms $J $N wongui _;
        @$N = Rw humms $J $N notnotjs _;
        my $S = Rw humms $J $N jscoi;
        my $sc = [@$N];
        #sayyl "J.name from oJ.name:\n". 
        #Rw ZNews $sc $nov=1;
        # feed also cones?
        n $_ =>''=>{pi=>pane=>s=>$S->{$_}} for sort keys %$S;
        # panes
        J.V = 1;
jive: |
    my $J = G.oin;
    J.V = 1;
    n ar.J.name =>''=>{IsOn=>1,%{C.c},time=>6}
ww: | # open this ghost
    u SevWo
    u uxWout
    
    n ww =>0.9,{},"%id:J.id,tt:H.ol,poi:0,ab:100,bgh:33.5.3.1"
    #G.Wid = J.id;
    #unshift @{aj.c}, jsq " \$('#ux').append(%s);", $s;
uxWout: |
    u allacgts
    #n ztojsM =>''=><<''
        # yellow
        #die "HWELO";
    
    
Wool: |
    u allacgts
    
    n JrW =>''=><<'',{acgt=>'J,r,lines'}
        my $em;
        em.lines = $lines;
        em.hitime = hitime();
        em.is.W = J.id;
        em.is.M = J.name;
        em.id = J.id.'.'.r.in;
        .
        G.Wh->{em.is.W} ||= do {
            sayyl "Life! of W em.is.W";
            my $me = I.d&hup,$em;
            delete me.lines;
            $me = sjson $me;
            sayyl "Would write $me";
            I.d&writef,"life/W/em.is.W\.i",$me;
            -l $_ && `unlink $_` for "life/W/em.is.M";
            `cd life/W; ln -s em.is.W\.c em.is.M`;
            # kind of wants lvish pointerism
            # osc idly (was around before) would keep j etc, 
            # handy for travelish reentrances by third parties
            # Jmosts must subscribe to the Goin osc...
            # which give them a G-finding W above their own W
            # which they dont know about, it's routed to...
            $J
        };
        .
        my $append = @{r.oldz};
        I.d&writef,"life/W/em.is.W\.c",em.lines,$append;
        .
        I.d&writef,"life/J/em.id\.c",em.lines;
        .
        my $catch = sjson {y=>J=>id=>em.id};
        I.d&writef,"life/J\.s",$catch,1;
        
    
    n writef =>''=><<'',{acgt=>'f,s,append'}
        saybl "SZOY: $f    ".slim(300,$s).($append && " APPEND");
        (my $d = $f) =~ s/\/[^\/]+?$//;
        unless (-d $d) {
            say "Making -d $d ...";
            `mkdir -p $d`;
        }
        .
        $s = [$s] if !ref $s;
        my $li = ref $s eq 'ARRAY' ? join("",map{/\n$/?$_:"$_\n"}@$s)
            : die "Wsome other $f type: $s";
        $li = encode_utf8 $li;
        .
        my $wa = {};
        wa.append = 1 if $append;
        .
        write_file($f,$wa,$li);
SevJs: |
    n Wool
    u allovse
    n '','','%of:Sev'
    
    n rootout =>582=><<'','%v:root'
        return unless A.J.most.J eq A.J || A.J.C.c.Wo;
SevWo: |
    n Wool
    u allovse
    n '','','%of:Sev'
    # Wencaps the Wubstance behind the Jaulted door
    # good for clouding away entropy from the foundation
    # so so, wants to separate heaps
    # kicks rays off the end of sev (or so)
    # all the stuff is is s by now if its making lines
    # or its a bunch of whatever, to json onto new line
    
    # also to sever things where sc.W c.W + id (if they are reachable via Wspace)
    # pi can also sever into channels of art noise + realmy stuff
    # 
    
    n rootout =>582=><<'','%v:root'
        return unless A.J.most.J eq A.J || A.J.C.c.Wo;
        .
        my $r = Rw scd $rl:vl $rv:lv;
        .
        return unless @{r.z};
        aft { $@ || return; sayre "$@  !~!! ".wdump 9, $r; };
        my $jsdo;
        if (I.ztojsM) {
            $jsdo = I.d&ztojsM,r.z;
        }
        else {
            my $M = ['','',{W=>G.oin.id},{z=>r.z}];
            $jsdo = [" a\.om({},".sjson($M).",a,{});"];
        }
        I.d&JrW,$J,$r,$jsdo
    
Travel: # make somewhere bridge
   yJ: |
     'clw waz gui'
   sh: |
     Rw J5 shv $aj;
   Em: |
     Rw Emvil;
Emvil: |
     my $tw = Rw huck $J $aj */sh;
     $tw || die "nomount J.name";
      
     my $c = aj.c;
     die 'scs' if @{aj.sc};
     die 's' if aj.s;
     my $M = ['','',{W=>G.Wid},{z=>aj.c}];
     
     #sayyl wdump 15, $M if aj.J.name eq 'Vuel';
     aft {
         $@ || return;
         sayre "$@  !~!! ".wdump 35, $M;
     };
     aj.c = [" a\.om({},".sjson($M).",a,{});"];
     aj.sent = 1;
     
     Rw paintaj $aj;
     
     # route aj.W from ...
     G.Wh->{aj.Wid} ||= do {
         my $ij = {}; map {
         $ij->{$_} = $aj->{$_} if !/^[sc]+/; } keys %$aj;
         ij.id = delete ij.Wid;
         ij.y = 'W';
         
         sayyl "Life! of ij.y ij.id";
         0->tai("ij.y/ij.id\.i", $ij);
         0->tac("V/H.style/H.name/H.id\.s", ztm($ij));
         aj.J;
     };

     Rw J5 wu $aj;
     
     aj.y ||= 'J';
     aj.yy = 'W';
     Rw aji $aj;
     Rw blabaj $aj;
somewhere: | # be somewhere
     my @path = ar.j.sc.J || ar.j.J;
     while (1) {
        my $l = $path[0];
        unshift @path, l.Jiter || last;
     }
     #saybl wdump 2, ["Gootblock:",@path];
     
     say "avoid: ".gp shift @path until !@path || $path[0] eq $J;
     shift @path;
     my $path = join '/', map{_.C.t} @path;
     
     my $A = J.A;
     my $v = G.pwin->("in/$path", $A);
     my $amo = 1.5;
     $amo = 0.8 if e.S;
     (v._.y.thy ||= 1) *= $amo;
     say "A in assign". wdump 14, [gp($J), $path, $v];
     return;
     
     #die wdump 2, [@lspath]; 
     #my $path = join '/', reverse @lspath;
     my $M = [];
     
     Mn('fro',{},"$path",'{ou:file}');
     
     Rw J5 wut $M;
siueon: |
    iroughoan anonate
paintaj: |
     aj.Wid || die "not Wid?";
     aj.hol = "H.style/H.name/H.id";
     aj.hitime = hitime;
     aj.name ||= aj.J.name;
thing2: |
   fow
hip_po: |
    tree-ish campus
    str i sin tko
things: |
    with suct ion
Mainiy: |
    things in 
Steve: |
   was h ere

