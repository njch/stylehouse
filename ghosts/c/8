  
floatation: | # Æ¾
    # Wencaps the Wubstance behind the Jaulted door
    # good for clouding away entropy from the foundation
    # so so, wants to separate heaps
    # like a pha, C that is collapsing from otherspouts
    
    # kicks rays off the end of sev (or so), making lines for an In to unfold
    # or its a bunch of whatever, to json onto new line
    
    # also to sever things where sc.W c.W + id (if they are reachable via Wspace)
    # pi can also sever into channels of art noise + realmy stuff
    # float the bets
    # edge the heat
    
        # G is a tied hash, resolves to doing like I through G.h
        # R makes I from further Wish inquiry, G does similar
        # R implies floatation
        # repeast                       G.fsk.oth (does little I.oth where C is t=k s=v)

        # kind of wants lvish pointerism - you would get it from ^ids or so
        # osc idly (was around before) would keep j etc, 
        # handy for travelish reentrances by third parties
        # Jmosts must subscribe to the Goin osc...
        # which give them a G-finding W above their own W
        # which they dont know about, it's routed to...
    

        # J.mo.s is G.oin

    #u openphase
    #u threestep
    # root of the chuck out lines only sort
    # when 8s groW time on G.oin
    # C.c.In && A.t&62 &&

    # to connect Gw so A.t&63 to hold things again, merge many Rw personas into one live as repeated subs with blanky u,etc,y.at outthrustocombing, since everything goes within to sed out - sometimes holding what it was originally for loop
    # the whole control panel of J.? of ^\w .* funcs is up, line feed, code is cracking open a valley

    # Followe:
    # ^ u threes
    # ^ qq {cpi:lines u:followlines}
    # which is normal perl code^and replies to the u qq seeming
    # want to consume every void context stuff as mind
    # u/n symbol family, j for nonJmo:
    # ^ j qq {cpi:lines u:followlines}
    # or perhouse (some Jness)
    # ^ j:interso qq {cpi:lines u:followlines}
    # when vector compose program
    
    # is kinda 
    # little j eventuates index of doings to follow index
SevWo: |
    n Meta
    n Wuts
    
    u allacgts
    
    dlin: %acgt:dir to it
        my $l = "$dir/$it";
        my $is = -l $l;
        return if $is && readlink($l) eq $to;
        `unlink $l` if $is;
        `cd $dir; ln -s $to $it`;
    
    wraf: %acgt:f s noappend
        $s =~ s/\n?$/\n/s;
        G&writef,$f,$s,!$noappend
    
    writef: %acgt:f s append
        (my $d = $f) =~ s/\/[^\/]+?$//;
        unless (-d $d) {
            `mkdir -p $d`;
        }
        .
        $s = [$s] if !ref $s;
        my $li = ref $s eq 'ARRAY' ? join("",map{/\n$/?$_:"$_\n"}@$s)
            : die "Wsome other $f type: $s";
        .
        my $wa = {};
        wa.append = 1 if $append;
        write_file($f,$wa,$li);
    
    u allovse
    n \'of:O'
    # conceal the multiJexits
    J 35:
        delete at.sc.J if C.c.S;
    
    u allvse
    n \'%of:Sev'
    # might wanna carebowl em 2-4 to engage scd/em at all
    n root =>582=><<'',{rg=>'ylv,yvl'}
        return unless A.J.most.J eq A.J || A.J.C.c.Wo;
        my $r = G&scd,$lv,$vl;
        return unless @{r.z};
        A.bangdesk.bang.sevwoe = sub {
            sayre " was in em section: ".wdump 5, $r;
        };
        C.c.em && die'wtf';
        .
        my $em = C.c.em = {};
        em.lines = r.z;
        em.i = @{r.oldz};
        .
        A.Subtle.em = 1;
        A.t&em,6,2;
    
Meta: |
    u allvse
    n '','','%of:em'
    n em =>21=><<''
        em.lines || die "Not lines";
        em.hitime = hitime();
        em.is.W = C.sc.Wid || A.J.id;
        em.is.M = C.sc.Mid || A.J.name;
        em.id = em.is.W.'.'.(0+em.i);
    
    u allsvse
    
    n jslines =>3=><<'',{cg=>'J,em'}
        Rw EmJSlines $A $J $em $C $T;
    
    n ux =>3=><<'',{cg=>'em'}
        my $J = G.oin;
        my $M = ['','',{W=>J.id},{z=>em.lines}];
        em.lines = [sjson($M)];
        C.sc.Wc = 1;
        n GW
    
    n ressur =>3=><<'',{cg=>'J,em'}
        saybl "Ressurrecting $ressur ...";
        die "zomp $ressur" if $ressur =~ /\W/;
        my $resu = "life/W/$ressur";
        die "bno JSlines" unless -e $resu;
        if (G.Jsem) {
            my $q = " var v = \$.ajax('/W/$ressur');"
                ." var m = v\.responseText".'.split("\n");'
                ." \$.each(m,function(k,v){ a\.m(v); });";
            #my $s = read_file($resu);
            say "Sending $resu via Jsem";
            return G.Jsem->($q);
        }
        `cd life; ln -s ../W/$ressur J/em.id\.c`;
        my $catch = sjson {y=>J=>id=>em.id};
        I.d&writef,"life/J\.s",$catch,1;
        T.whack = 1; # out of em
    
Wuts: |
    u allsvse
    n '','','%of:em'
    # (ais coming soon: (only space or)
    n Wc =>446=><<'',{cg=>'J,em'}
        saybl join"\n","Downing em.is.M: em.is.W: ",
            map{!ref $_ ? $_ : wdump 5,$_} @{em.lines}
            if A.V&W;
        I.d&writef,"life/W/em.is.W\.c",em.lines,em.i;
        .
        C.c.as = !C.c.os;
        C.c.As = C.c.as;
        C.sc.meta = 1;
        C.sc.speak = 1 if C.c.as;
        C.sc.takeover = 1 if C.c.As;
        saybl "WHITESPACE S em.is.M" if C.c.os;
    
    # inter intros
    n meta =>47=><<'','%cg:em'
        G.Wh->{em.is.W} && return;
        G.Wh->{em.is.W} = A.J;
        my $me = I.d&hup,$em;
        delete me.lines;
        I.d&writef,"life/W/em.is.W\.i",sjson($me);
    
    n speak =>48=><<'','%cg:em'
        return if G.Jlone;
        .
        if (G.Jsem) {
            G.Jsem->($em);
        }
        I.d&writef,"life/J/em.id\.c",em.lines;
        .
        I.d&writef,"life/J\.s",sjson({y=>'J',id=>em.id}),1;
    
    n takeover =>49=><<'','%cg:em'
        G&dlin,'life/W',"em.is.W\.c","em.is.M";
    
Dig: |
    my $ge = LoadFile('g/c/8');
    my $s = G.way.AfghanRug;
    my $l = $1 if $s =~ /encode_entities\((.+)\)/;
    write_file('w/thei',$l);
    $l = read_file('w/thei');
    y.at.ux = 1;
    u ReoCur;
    J.VV.N = 1;
    #$l = wdump 3, [opssibl=>$l];
    $l = encode_entities(decode_utf8($l));
    Mn(afghani=>''=>$l,'%ht,tag:pre,fs:150');
Wat: |
    u UpPg
    my ($A) =
    n s=>''=>t
    my $db = G&db;
    for (1..8) {
        $db->notify('Js', "Jibajaba");
        sleep 1;
    }
    
Ws_up: |
    use Mojolicious::Lite;
    push @{app->static->paths}, '/home/s/styleshed/public';
    app->secrets([readlink '/home/s/stylehouse/msecret']);
    
    my $s = "http://s:10094";

    websocket '/s' => sub {
        my $mojo = shift;
        sayyl "Connect!";
        die "No GWebsock yet" unless G.Websock;
        G.Websock->($mojo);
    };
    
    G.clockon = sub {
        saybl "Starting  G.t     listens: $s";
        app->start('daemon', '--listen' => "$s");
    };
Ws: |
    #
    n Web;
    #n Tarp;
    #
Web: |
    u UpPg
    my ($A) =
    n s=>''=>t
    
    G.Websock = J.Websock ||= sub {
        my $mojo = shift;
        say "Web is socked!";
        my $s = $mojo;
        my $tx = $s->tx;
        J.tx = $tx;
        my $addr = $tx->remote_address;
        Mojo::IOLoop->stream($tx->connection)->timeout(300000);
        $s->on(message => sub {
            my ($M, $m) = @_;
            sayyl "Message from $addr ".$m;
        });
        $s->on(finish => sub {
            my ($M, $code, $reason) = @_;
            sayre "Gone: $addr $code $reason";
        });
        $tx->send(' clon();keon();');
        return;
        my $M = [];
        Mn(elvi=>-websock=>{s=>$mojo});
        n WebSocks => @$M
        sayyl "Socksdone";
    };
    
    G.Websen = J.Websen ||= sub {
        my $m = shift;
        say "Web is sended! $m";
        J.tx->send($m);
    };
    
    my $ya = G.onfork.Web = sub {
        sayyl "Listening forte ! ! !";
        my $db = G&db;
        $db->on(notification => sub {
            my ($db, $name, $pid, $payload) = @_;
            say "$name: $payload";
            J.Websen->($payload);
        });
        $db->listen('Js');
    };
    $ya->();
    saybl "Web done";
    
    
    
Doing: |
    u UpPg
    
    my ($A) =
    n s=>''=>t
    
    my $db = G&db;
    $db->notify(Js=>"SOGEOGMEO");
    
WebSocks: |
    J.VV.N = 1;
    y.ope = 1;
    for (A.e&C) {
        if (_.c.pi eq 'websock') {
            saybl "Have client: ".wdump 3, $_;
            n $_
        }
        else {
            say "J.name something e;ses: ".wdump 3, C.c.e;
            n $_
        }
    }
pi/websock: |
    #y.ope = 1;
    J.tx ||= do {
        my $tx = $s->tx;
        Mojo::IOLoop->stream($tx->connection)->timeout(300000);
        $s->on(message => sub {
            my ($M, $m) = @_;
            sayyl "Message from A.tt.addr: ".slim 90, $m;
        });
        $s->on(finish => sub {
            my ($M, $code, $reason) = @_;
            sayre "Gone: A.tt.addr $code $reason";
        });
        n esta =>1=>hitime()
        n addr =>2=>$tx->remote_address;
    };
pi/tfile: |
    n 1,1,Tailing =>'%hs:4856'
    n 2,2,$s
    -f $s || die "NOpe -f $s";
    my $al = J.al ||= {};
    
    ref C.c.cb eq 'CODE' || die "No callback to J.name";
    
    al.s ||= do {
        open my $ha, '-|','tail', '-q',
            '-s','0.1','-F','-n0',
            $s
            or die $!;
        #al.s && al.s->close;
        my $S = al.s = Mojo::IOLoop::Stream->new($ha);
        $S->on(read => sub { C.c.cb->($_[1]); });
        $S->on(close => sub { die "$s closed!?"; });
        $S->on(error => sub {
            my ($s, $err) = @_;
            die "$s err: $err";
        });
        $S->timeout(0);
        $S->start;
        #$s->reactor->start unless $s->reactor->is_running;
        $S
    };
Sl: |
    J.fti ||= 0;
    if (J.fti >= 0) {
        Rw waitme;
    }
    sayyl "Ftime up J.fti";
    Rw forked;
    
Be: |
    my @and = G.cv < 3 ? 'K/eel' : 'K/Eel';
    G.IIII = [map{'G/T/'.$_}qw'H/Boat H/Rest Chang',@and];
    G.c.pre &&
    n G.c.pre
    Rw Sl;
waitme: |
    use POSIX ':sys_wait_h';
    if (G.forked) {
        sayre "waitme already forked" for 1..3;
        return;
        exit;
    }
        
    if (my $pid = fork()) {
        sayyl "FOrked! ,,,," for 1..3;
        waitpid($pid,0);
        saybl "Restart? <";
        my $IN = \*STDIN;
        while (my $k = <$IN>) {
            chomp $k;
            J.me = $k;
            say "__ $k";
            Rw goche $n=$1
            while $k =~ s/(\d+)//g;
            Rw goche $n:_
                for qw'81 64 8 84 1';
            Rw waitme;
            return;
        }
    }
    else {
        G.forked = 1;
    }
    
goche: |
    my $m = "g/c/".($n||8);
    Rw ghosch $m
ghosch: |
    sayyl "Ghosch: $m";
    return sayre "iggy $m" if $m !~ /^g(hosts?)?\/c\//;
    my $u = LoadFile $m;
    map {
        (my $k = $_) =~ s/\W/-/g;
        G.way->{$k} = $u->{$_};
    } keys %$u;
    delete G.drop;
forked: |
    # etc
    my $also;
    if (J.me =~ s/(\S+) (\w+)/$1/) {
        $also = $2;
    }
    if (J.me eq 'm') {
        J.me = read_file("w/wasme");
        say "Repeating: J.me";
    }
    write_file("w/wasme", J.me) if J.me;
    J.wasme = J.me;
    if ($also) {
        say "Also: $also";
        J.me .= " $also";
    }
    if (J.me =~ /^(\w+):(\S+)(\s|$)/) {
        my $o;
        my ($is,$ul) = ($1,$2);
        my $t = $1 if $ul =~ /^(\w+)/ || die "niul $ul";
        if (!-f "w/$is/$t") {
            my @op = glob "w/$is/$t*";
            sayre "Many options: ".ki @op if @op > 1;
            my $o = shift @op;
            $ul = $1 if $o =~ /^.+\/(.+?)$/;
        }
        sayyl "So: $is, $ul   fr  $o";
        J.me = " ALL $is:$ul";
    }
    if (J.me =~ s/^ (\w+)(?: (.+))?// && G.way->{$1}) {
        n $1=>W=>{t=>$2}
    }
    J.me = $also if $also;
    J.fti -= 3 if J.me =~ s/o//g;
    J.fti -= 2 if J.me =~ s/i//g;
    delete G.forked if J.me =~ s/p//;
    Rw loopby $b=3 $d=5 $p=Top
        if J.fti < 0;
    J.fti++;
    
    J.me =~ /n/ &&
        `cat /dev/null > G.GW.taile`;
    J.me =~ /a/ &&
        n All=>W=>{time=>6}
    J.me =~ /A/ &&
        n Aim
    J.me =~ /u/ &&
        n uncan
    J.me =~ /N/ &&
        n Notes
    J.me =~ /s/ &&
        n Sefi
    J.me =~ /S/ &&
        n Sefission
    J.me =~ /w/ &&
        n Pile
    J.me =~ /g/ &&
        n Dug
    J.me =~ /c/ &&
        n Chang
    J.me =~ /d/ &&
        n Details
    J.me =~ /j/ &&
        n ALL=>W=>{t=>'Swomp',isle=>'jes'}
    J.me =~ /t/ &&
        n Tarp
    J.me =~ /v/ &&
        n reJSlines
    
    J.me = '';
    #n Details
    #n EYZ
    #n Usee
    # Rw followS
Wh: |
    y.at.oWl = 1;
    n Tarp
    #n AfghanRug
    n Soom
    J.fsjoi++ ||
        Rw loopby $b=5 $d=26 $p=Top;
Soom: |
    u ReoCur
    y.at.ux = 1;
    n sleoo => ''=>"FASKODFKO"
    Mn(fivbe=>''=>"letilo") for 1..9;
Notes: |
    u ReoCur
    y.at.anch = 'Noteal';
    y.at.ux = 1;
    J.VV.N = 1;
    J.ev.th ||= 'middle';
    J.ev.li ||= 'climbos';
    Mn($_=>-te=>$_,'%dos:plucJ') for qw'
        Mandrins
        Damine
        Leteleto
        Loenade
    ';
plucJ: |
    my @Js = I.d&inDin,$E,'_hJ';
    my ($tW,$tl) = @Js[0,-1];
    tW.mo.J eq $tW || die "not most 1: ".ki $tW;
    tl.C.sc.pi || die "not pi 3: ".ki $tl;
    my $us = A.us&C || die "Not us?";
    my $M = us.pick ||= [];
    Mn(founde=>-edr=>(join';',tl.C.c.s),{mean=>'Somehows'});
    n Othie =>$E
    T.pos = 0;
Othie: |
    u ReoCur
    y.at.anch = 'Noteal';
    y.at.ux = 1;
    J.ev.th ||= 'middle';
    J.ev.o ||= 'indoc';
    J.ev.li ||= 'climbos';
    J.ev.tr = 1; # thing dont fly off to inners, has id, from event line
    J.UG ||= [];
    y.in = 2;
    y.out = 5;
    J.VV.N = 1;
    Atime(2);
    
    n downsave=>[-doi=>0.04]
    n noie => 1=>"OOOOOOO"
    n noie => 7=>"OOOOOOO"
    my $pi = {};
    push @{$pi->{"_.sc.oW _.sc.mean _.sc.to"}||=[]}, $_ for @{J.UG};
    for my $k (sort keys %$pi) {
        Mn($k=>-ean=>{s=>$pi->{$k}});
    }
    sayyl "Other things we arte: _.t    x ".@{_.c.s} for @$M;
 
ThisPr: |
    #u ReoCur
    y.at.ux = 1;
    J.VV.N = 1;
    y.at.oWl = 1;
    n Chang
    
    Mn(Y=>-raay=>'Chang');
    y.out = 6;
    y.in = 1;
    n d =>'1.2-3x2.4'=>','=>'%fs:44,ml:-1'
    
pi/raay: |
    my $oJ = J.mo.J.bb->{"0.3\t$s\tJ"} || return
        n 404 => 1 =>"snothere: $s"
    my $Y = oJ.El.Pre;
    my $se = Y.tv if C.t eq 'tv';
    $se = $Y if C.t eq 'Y';
    $se = se.tv;
    $pi ||= C.t;
    $se || return
        n 500 => 2 =>"no access: C.t"
    Mn(C.t=>pi=>{s=>$se});
pi/Y: |
    n Y =>1=>C.t
    Mn(hach=>pi=>{s=>$s});
pi/w: | # the soft Rw or u art grab
    my $es = G.way.Elis;
    y.in=1;
    Mn(pre=>pi=>{s=>$es});
    
pi/hach: |
    my $se = {%$s};
    while (my ($k,$v) = each %$se)  {
        $se->{$k} = ref $v ? ref($v)." ".ki $v : $v;
    }
    my $es = wdump 1, $se;
    Mn(pre=>pi=>{s=>$es});
    #
pi/pre: |
    y.at.qs = 1;
    n pre =>1=>{s=>$s}=>'%tag:pre'
pi/tv: |
    Mn($_=>''=>{pi=>C=>s=>$s->{$_}})
        for sort keys %$s;
    
pi/C: |
    ref $s eq 'HASH' || return
        n nothash=>''=>{s=>wdump 2, $s}
    n t =>1=> s.t
    n ycv =>2=> s.y.cv
    n c =>3=> ki s.c
    n sc =>4=> ki s.sc
pi/di: |
    y.ert = 9;
    for (`ls --full-time --inode`) {
        chomp;
    }
DetailMark: |
    my $mark = [',',qw' ? ; :'];
    A.us&C && A.us&S ? J.fkeo++ : J.fkeo--;
    
    J.fkeo += 1 until J.fkeo >= 0;
    J.fkeo -= @$mark while J.fkeo > @$mark;
    
    J.sdjfsiji ||= 4;
    my $n = J.sdjfsiji++;
    my $sp = J.sfjkiig .= '   ';
    my $sc = J.fekooo ||= {};
    sc.fs ||= 3;
    sc.fs += 2;
    sc.ml += 1;
    #Mn(d =>''=>$mark->[J.fkeo]=>'%fs:44,hs:'.int(rand(9)).'36') for 1..6;
    
Somehows: |
    sayyl "SOMEHOWS! ".wdump 3, C.c.e.c.e.c.e;
    my ($jj,$ti,$no) = A.e&_hJ;
    $no && die "GOt extra thing: ".ki $no;
    say wdump 3, ti.El.Duv.rv;
    saybl wdump 3, ti.C;
    Rw talkzyh;
pi/dos: |
    n sym => 1=>C.t,{hs=>844=>dos=>'dosier'}
pi/nothing: |
    C.sc.qs = 1;
hijack: | # yJ, the event for-er
    saybl "HERE\n\n\n";
    my $ep = E.c.hC->[-1];
    ep.sc.pi eq 'yam' || die "Dodge E: ".
        Rw talkzyh;
    E.c.yJ = Rw yJTrunk $C:ep;
    my ($hoc,$ad);
    for my $o (reverse @{E.c.yJ}) {
        sayyl "Here: - ".ki $o;
        if (o.name =~ /^2/) {
            my $rv = o.El.Duv.rv;
            my $s = "Outside: ".ki(rv.C)."\nInside: ".ki(o.C);
            push @{E.c.us.pick||=[]}, [founde=>-ckup=>$s];
            n Dug =>$E
        }
    }
    
pi/doi: |
    C.sc.dos = $s;
    n s=>1=>'D','%fs:12'
    n o=>2=>$s,'%hs:268'
    if (!J.El.Duv && exists G.way->{"${s}_up"}) {
        say "Why not wake up... $s";
        Rw ${s}_up;
    }
    
pi/ckup: |
    n lin=>1=>"ckup: C.t"
    Mn($_->[0]=>-te=>$_->[1],'%width:42%,wb,ws')
        for map{ /^(.+?): (.+)$/ ? [$1, $2] : ["?",$_] } split "\n", $s;
pi/te: |
    C.sc.qs = 1;
    y.at.ws = '1';
    y.at.bgh = '8733';
    y.at.ma = '1em';
    n it =>1=>C.t=>'%hs:748,fw:3'
    
    my $fs = I.d&ron,(0+split("\n",$s))*(1 / 8);
    
    Mn(C.t=>''=>$s,'%wb,ws,dis,lh:1,fs:'.$fs);
    y.spc < 0.2
        ? sayyl "Wasbig: C.t: y.spc  J.C.y.spc  for ".slim 30,$s
        : sayyl "Notbig: C.t  a y.spc    J.C.y.spc";
    
    Rw Rums $J $C $M $y $spc:J.C.y.spc $I;
Rums: | # as an In osc, string ring ring
    # attach _.yy.NOISE.ytalk for tiny ysland mentalities
    @$M = map {
        my $ls = int($spc * 90);
        my $lino = J.mo.yam.sc.vert || scalar(split"\n",_.c.s);
        saybl "Have $spc * 90 = $ls      ----- $lino";
        if ($lino && $lino > $ls) {
            _.c.s =~ s/^(([^\n]*\n){$ls}).*$/$1 .../s;
            saybl "Made snip";
        }
        if ($spc < 0.2) {
            $_
        }
        elsif (_.c.s =~ /^(.+?): (.+)$/) {
            $_
        }
        elsif (_.c.s =~ /^(.+)( sc=\{ )(.+)$/s) {
            I.d&xoy,{c=>{s=>$1}},$_ ,
            [and=>''=>"AND: $2"=>'%hs:483'], 
            I.d&xoy,{c=>{s=>$3},sc=>{hs=>'287'}},$_
        }
        else {
            $_
        }
    } @$M;
    saybl "Took ".F_delta()." to spread J.name 's ".@$M;
    
flse: | # fusilagery - wants about 2 seconds
    my $r = E.c.hC->[-1];
    if (r.sc.to) {
        r.sc.op || die "nop";
        my $o = I.d&pin,r.sc.op,$A;
        if (r.sc.to eq '!') {
            sayyl "! op to r.sc.op, was: ".
                I.d&pon,r.sc.op,$A,!$o;
        }
        else {
            I.d&pon,r.sc.op,$A,$o+C.sc.to;
        }
    }
    else {
        sayre "How to hold ".wdump 2, $r;
    }
    sayre "Have flse click: ".wdump 2, $r;
pi/cde: |
    my $se = I.d&pin,$s,$A;
    #$se = wdump 3, $se;
    n row =>1 =>{idly=>1,s=>$se},'%cod:perl,dig:steve,dos:upcde'
    n row =>1=>{}=>{css=>"width:10em",ab=>1}
    C.sc.cssdel = 'transform';
    
    
upcde: |
    sayre "Upacode : C.t - E.t" for 1..4;
    
    sayre wdump 2, $C;
    Rw talkzyh;
    return;
    for (A.us&code) {
        sayyl "Writeing $_ from C.c.e.c.us";
        #I.d&pon,$s,$A,$_;
    }
putmoves: | # TODO y-move instead of remove
    u allovse
    n '','','%of:Sev'

    n Y =>31=><<'',{rg=>'J,V,yk'}
        # patch new to old where same t,s, add Vhooks
        C.y.lv = {k=>$k,C=>$C};
        C.y.at = {};
        C.y.ta = V.ta->{$k};
        C.y.vl = V.lv->{$k};
        if (C.c.root) { # / continues from 3 when everything's 6
            Y.root = $C;
            T.Z->{0.6} = 0.3;
            T.not = 1;
        }
somewhere: | # be somewhere by default
     my @path = ar.j.sc.J || ar.j.J;
     while (1) {
        my $l = $path[0];
        unshift @path, l.Jiter || last;
     }
     #saybl wdump 2, ["Gootblock:",@path];
     
     say "avoid: ".gp shift @path until !@path || $path[0] eq $J;
     shift @path;
     my $path = join '/', map{_.C.t} @path;
     
     my $A = J.A;
     my $v = G.pwin->("in/$path", $A);
     my $amo = 1.5;
     $amo = 0.8 if e.S;
     (v._.y.thy ||= 1) *= $amo;
     say "A in assign". wdump 14, [gp($J), $path, $v];
     return;
     
     #die wdump 2, [@lspath]; 
     #my $path = join '/', reverse @lspath;
     my $M = [];
     
     Mn('fro',{},"$path",'{ou:file}');
     
     Rw J5 wut $M;
Steve: |
   was h ere

