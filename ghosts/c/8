  
floatation: |
    # Wencaps the Wubstance behind the Jaulted door
    # good for clouding away entropy from the foundation
    # so so, wants to separate heaps
    
    # kicks rays off the end of sev (or so)
    # all the stuff is is s by now if its making lines
    # or its a bunch of whatever, to json onto new line
    
    # also to sever things where sc.W c.W + id (if they are reachable via Wspace)
    # pi can also sever into channels of art noise + realmy stuff
    # float the bets
    # edge thje het
    
        #   R writef life/W/em.is.W\.c em.lines $append:em.i
        # G is a tied hash, resolves to doing like I through G.d
        # R makes I from further Wish inquiry, G does similar
        # R implies floatation
        # repeast                       G.fsk.oth (does little I.oth where C is t=k s=v)

        # kind of wants lvish pointerism - you would get it from ^ids or so
        # osc idly (was around before) would keep j etc, 
        # handy for travelish reentrances by third parties
        # Jmosts must subscribe to the Goin osc...
        # which give them a G-finding W above their own W
        # which they dont know about, it's routed to...
    

        # J.mo.s is G.oin

    #u openphase
    #u threestep
    # root of the chuck out lines only sort
    # when 8s groW time on G.oin
    # C.c.In && A.t&62 &&

    # to connect Gw so A.t&63 to hold things again, merge many Rw personas into one live as repeated subs with blanky u,etc,y.at outthrustocombing, since everything goes within to sed out - sometimes holding what it was originally for loop
    # the whole control panel of J.? of ^\w .* funcs is up, line feed, code is cracking open a valley

    # Followe:
    # ^ u threes
    # ^ qq {cpi:lines u:followlines}
    # which is normal perl code^and replies to the u qq seeming
    # want to consume every void context stuff as mind
    # u/n symbol family, j for nonJmo:
    # ^ j qq {cpi:lines u:followlines}
    # or perhouse (some Jness)
    # ^ j:interso qq {cpi:lines u:followlines}
    # when vector compose program
    
    # is kinda 
    # little j eventuates index of doings to follow index
SevWo: |
    n Meta
    n Wuts
    
    u allacgts
    
    n writef =>''=><<'',{acgt=>'f,s,append'}
        (my $d = $f) =~ s/\/[^\/]+?$//;
        unless (-d $d) {
            `mkdir -p $d`;
        }
        .
        $s = [$s] if !ref $s;
        my $li = ref $s eq 'ARRAY' ? join("",map{/\n$/?$_:"$_\n"}@$s)
            : die "Wsome other $f type: $s";
        $li = encode_utf8 $li;
        .
        my $wa = {};
        wa.append = 1 if $append;
        write_file($f,$wa,$li);

    u allovse
    n '','','%of:O'
    n J =>35=><<''
        delete at.sc.J if C.c.S;
        # conceal the multiJexits
    
    u allvse
    n '','','%of:Sev'
    # might wanna carebowl em 2-4 to engage scd/em at all
    n root =>582=><<'',{rg=>'ylv,yvl'}
        return unless A.J.most.J eq A.J || A.J.C.c.Wo;
        my $r = Rw scd $rl:vl $rv:lv;
        return unless @{r.z};
        aft { $@ || return; sayre "$@  !~!! ".wdump 9, $r; };
        C.c.em && die'wtf';
        .
        my $em = C.c.em = {};
        em.lines = r.z;
        em.i = @{r.oldz};
        .
        A.Subtle.em = 1;
        A.t&em,6,2;
    
Meta: |
    u allvse
    n '','','%of:em'
    n em =>21=><<''
        em.lines || die "Not lines";
        em.hitime = hitime();
        em.is.W = C.sc.Wid || A.J.id;
        em.is.M = C.sc.Mid || A.J.name;
        em.id = em.is.W.'.'.(0+em.i);
    
    # c ^
    # sc v
    u allsvse
    n jslines =>3=><<'',{cg=>'J,em'}
        Rw EmJSlines $A $J $em $C $T;
    
    n ux =>3=><<'',{cg=>'em'}
        my $J = G.oin;
        my $M = ['','',{W=>J.id},{z=>em.lines}];
        em.lines = [sjson($M)];
        C.sc.Wc = 1;
        n GW
        # ^ router, W with an .e v
    
    n ressur =>3=><<'',{cg=>'J,em'}
        saybl "Ressurrecting $ressur ...";
        die "zomp $ressur" if $ressur =~ /\W/;
        die "bno JSlines" unless -e "life/W/$ressur";
        `cd life; ln -s ../W/$ressur J/em.id\.c`;
        my $catch = sjson {y=>J=>id=>em.id};
        I.d&writef,"life/J\.s",$catch,1;
        T.whack = 1; # out of em
    
Wuts: |
    u allsvse
    n '','','%of:em'
    n Wc =>446=><<'',{cg=>'J,em'}
        saybl join"\n","Downing em.is.M: em.is.W: ",
            map{!ref $_ ? $_ : wdump 5,$_} @{em.lines};
        I.d&writef,"life/W/em.is.W\.c",em.lines,em.i;
        .
        # is coming soon: (only space or)
        C.c.as = !C.c.os;
        C.c.As = C.c.as;
        C.sc.meta = 1;
        C.sc.speak = 1 if C.c.as;
        C.sc.takeover = 1 if C.c.As;
        saybl "WHITESPACE S em.is.M" if C.c.os;
    
    # inter intros
    n meta =>47=><<'','%cg:em'
        G.Wh->{em.is.W} && return;
        G.Wh->{em.is.W} = A.J;
        my $me = I.d&hup,$em;
        delete me.lines;
        $me = sjson $me;
        I.d&writef,"life/W/em.is.W\.i",$me;
    
    n speak =>48=><<'','%cg:em'
        return if G.Jlone;
        .
        I.d&writef,"life/J/em.id\.c",em.lines;
        .
        my $catch = sjson {y=>J=>id=>em.id};
        I.d&writef,"life/J\.s",$catch,1;
    
    n takeover =>49=><<'','%cg:em'
        -l $_ && `unlink $_` for "life/W/em.is.M";
        `cd life/W; ln -s em.is.W\.c em.is.M`;
    
Sl: |
    y.at.oWl = 1;
    J.ev.th ||= 'middle';
    J.ev.li ||= 'climbo';
    J.ev.bo ||= 'bodos';
    J.VV.N = 1;
    
    #n reJSlines
    # makes everything but js=1
    
    #n "life/S\.s"=>-sol=>''=>'%dos:loadwav'
    
    #y.at.jslines = 1;
    #n skdo=>2=>"a\.sitandspin();",'%js'
    
    #rand 1 < 0.17 &&
    0 &&
    n bla =>3=>G.way.paps,'%js'
    
    0 &&
    n blag =>4=>{s=><<''},'%js'
        //paper.project.clear();
    
    # here
    
    #n jshang
    #n ThisPr
    n Details
    if (0){
    n Precoall
    Rw waitme;
    n Chang
    #n EYZ
    #n Usee
    # Rw followS
    return;
    }
    my $n = J.fsjoi++;
    $n && 1;
    $n || Rw loopby $b=5 $d=26 $p=Top;
paps: |
        with (paper) {
            var find = $('img');
            var src = $(find).attr('src');
            var r = new Raster(src);
            r.position = view.center;
            r.scaling = 3;
            r.rotation = 30;
            r.blendMode = 'color-burn';
            console.log('img: ', r);
            if (!a.fo)
                a.fo = {};
            a.fo[src] = r;
        }
pi/pape: |
    my ($no,$i,$se) = ($1,$2,$3) if `uptime` =~ /([\d\.]+), ([\d\.]+), ([\d\.]+)/;
    my $fo = $no - $i;
    
    map{delete J.El->{$_}}'Pre','Duv';
    say wdump [$no,$i,$se,$fo];
    my $sc = {
        pa=>ra=>es=>"\$('img').attr('src')",
        poxop=>-70 * (rand(3) -2),
        poyop=>-70 * (rand(3) -2),
        sca=>3.421 * rand(3) ^ 2,
        opa=>0.61,
        b=>(shuffle 'normal', 'multiply', 'screen', 'overlay', 'soft-light', 'hard-light', 'color-dodge', 'color-burn', 'darken', 'lighten', 'difference', 'exclusion', 'hue', 'saturation', 'luminosity', 'color', 'add', 'subtract', 'average', 'pin-light', 'negation', 'source-over', 'source-in', 'source-out', 'source-atop', 'destination-over', 'destination-in', 'destination-out', 'destination-atop', 'lighter', 'darker', 'copy', 'xor')[0],
        r=>int(900 * $fo),
    };
    $sc->{$_} = I.d&ron,$sc->{$_} for grep{$sc->{$_}} qw'poxop poyop sca opa r';
    n payp =>3=>{},$sc
    
jspa: |
    u alljse
    
    n pa =>3=><<''
        with (paper) {
            !s === 'ra' and a.c('nom ra: '+s);
            s = C.sc;
            s ||= {};
            s.jfi ||= 'img';
            var find = $(s.jfi);
            !find.length and a.c('no find '+s.jfi);
            var src = $(find).last().attr('src');
            var r = new Raster(src);
            s.poes and r.position = eval(s.poes);
            else { 
                r.position = view.center;
            }
            s.poxop and r.position.x += s.poxop;
            s.poyop and r.position.y += s.poyop;
            s.sca and r.scaling = s.sca;
            s.b and r.blendMode = s.b;
            s.r and r.rotation = s.r;
            s.opa and r.opacity = s.opa;
            console.log('img: ', r);
            A.W ||= {};
            A.W.ras ||= {};
            A.W.ras[src] = r;
        }
    
ThisPr: |
    #u ReoCur
    y.at.ux = 1;
    J.VV.N = 1;
    y.at.oWl = 1;
    n Chang
    
    Mn(Y=>-raay=>'Chang');
    y.out = 6;
    y.in = 1;
    n d =>'1.2-3x2.4'=>','=>'%fs:44,ml:-1'
    
pi/raay: |
    my $oJ = J.mo.J.bb->{"0.3\t$s\tJ"} || return
        n 404 => 1 =>"snothere: $s"
    my $Y = oJ.El.Pre;
    my $se = Y.tv if C.t eq 'tv';
    $se = $Y if C.t eq 'Y';
    $se = se.tv;
    $pi ||= C.t;
    $se || return
        n 500 => 2 =>"no access: C.t"
    Mn(C.t=>pi=>{s=>$se});
pi/Y: |
    n Y =>1=>C.t
    Mn(hach=>pi=>{s=>$s});
pi/w: | # the soft Rw or u art grab
    my $es = G.way.Elis;
    y.in=1;
    Mn(pre=>pi=>{s=>$es});
    
pi/hach: |
    my $se = {%$s};
    while (my ($k,$v) = each %$se)  {
        $se->{$k} = ref $v ? ref($v)." ".ki $v : $v;
    }
    my $es = wdump 1, $se;
    Mn(pre=>pi=>{s=>$es});
    #
pi/pre: |
    n pre =>1=>{s=>$s}=>'%tag:pre'
pi/tv: |
    Mn($_=>''=>{pi=>C=>s=>$s->{$_}})
        for sort keys %$s;
    
pi/C: |
    ref $s eq 'HASH' || return
        n nothash=>''=>{s=>wdump 2, $s}
    n t =>1=> s.t
    n ycv =>2=> s.y.cv
    n c =>3=> ki s.c
    n sc =>4=> ki s.sc
pi/di: |
    y.ert = 9;
    for (`ls --full-time --inode`) {
        chomp;
    }
Sinter: |
    J.VV.N = 1;
    n stylext
ghosch: |
    sayyl "Ghosch: $m";
    return sayre "iggy $m" if $m !~ /^g(hosts?)?\/c\//;
    my $u = LoadFile $m;
    
    G.way->{$_} = $u->{$_} for keys %$u;
    delete G.drop;
loadwav: |
    sayyl " F  IND SOME FOR E.c.s";
    
    E.c.serJ && map {
        Rw clack + $m:_
    } "Already serJ = E.c.serJ.name";
    E.c.serJ = $J;
    
    for (E.c.s) {
        /^ghostchanges (.+)$/ ?
            Rw ghosch + $m:1
        :
        /^hello/ ?
            return saybl " hello! E.t: $_"
        :
        sayre "Unclassified talk: $_"
    }
    # be!  plus
    
    sayyl '' for 1..4;
Usee: |
    u ReoCur
    y.at.ux = 1;
    J.VV.N = 1;
    
    my $i = int rand 19;
    sayre("CHANGING THIS\n\n\n\n") && `echo $i >> ded/$i` if int(rand 19) > 14;
    my @l = `find ded`;
    #my @l = `find life/W -type l`;
    #my @r = `find life/W -mtime 0.6`;
    #my @el = `find life/W`;
    chomp for @l;
    while (@l > 7) {
        `rm $_` for shift @l;
    }
    y.in=1;
    y.out=5;
    Mn(some=>''=>{pi=>textl=>s=>$_})
        for split"\n",wdump 2, \@l;
pi/textl: |
    my $l = sum map{ord $_} split '', $s;
    $l /= 10 until $l < 10;
    my $h = int $l;
    n text=>1=>$s,{hs=>"${h}86"}
EYZ: |
    u ReoCur
    y.at.ux = 1;
    J.VV.N = 1;
    u curv =>pi=><<''
        zoom 0  0.13
        y    0  0
        x    0  0
        curve 0 -0.03
    
    # eyes !
    y.limn = 0.2245;
    y.lum = 5;
    y.in = 0.04;
    y.out = 0.3;
    #Mn(shedful => '', {pi=>'eye',s=>'eye/Tarf/Photo serieses'});
    Mn(shedful => '', {pi=>'fi',s=>'eye/el'});
Details: |
    J.A.III = ['G/T/Chang'];
    u ReoCur
    y.at.ux = 1;
    
    J.ev.th ||= 'middle';
    J.ev.li ||= 'climbo';
    J.ev.bo ||= 'bodos';
    
    my $mark = [',',qw' ? ; :'];
    A.us&C && A.us&S ? J.fkeo++ : J.fkeo--;
    
    J.fkeo += 1 until J.fkeo >= 0;
    J.fkeo -= @$mark while J.fkeo > @$mark;
    
    J.sdjfsiji ||= 4;
    my $n = J.sdjfsiji++;
    my $sp = J.sfjkiig .= '   ';
    my $sc = J.fekooo ||= {};
    sc.fs ||= 3;
    sc.fs += 2;
    sc.ml += 1;
    
    
    #n b320 => '3-5x'.$n, join($sp,(J.fkeo) x 3),$sc;
    
    n fsdk => 0.04 => "Steve, ya need: <b>BVOLD</b>",'%ht:1'
    n lod=>0.06 =>'fds'=>'%id:lodo,dos:goche,wi:3'
    #
    G.edit ||= 'G/way/Chang';
    n edit=>0.08=>'@'=>'%id:edat,dos:flse,op:J/se/cod,to:!'
    J.se.cod &&
    n 'G/edit'=>[-cde=>'1-2']
    J.se.cod &&
    n G.edit=>[-cde=>'2-6']
    y.at.cssdel = 'transform';
    
    #Rw Tarp;
    
    y.in = 1;
    y.out = 3;
    y.ert = 9; 
    J.VV.N = 1;
    Mn(d =>''=>$mark->[J.fkeo]=>'%fs:44') for 1..6;
    
    
    return;
    Mn(shedful => '', {pi=>'eye',s=>'eye/fug/1/lt'});
    
Portito: |
    n quiet=>2=><<'','%ht'
        <video width="420" height="0" autoplay controls>
            <source src="groof/lesbaxter_quietvillage.mp3">
        </video>
    
Tarp: |
    J.tea ||= [grep{chomp}shuffle`ls -1 eye/Tarf/*/*`];
    J.fast++;
    if (J.fast > 2) {
        J.slow++;
        J.fast = 0;
        J.slow = 0 if J.slow >= @{J.tea};
    }
    n J.tea->[J.slow]=>[-fi=>3]=>{}=>'%dos:flse,op:J/slow,to:1'
    n mild=>-pape
flse: | # fusilagery - wants about 2 seconds
    my $r = E.c.hC->[-1];
    if (r.sc.to) {
        r.sc.op || die "nop";
        my $o = I.d&pin,r.sc.op,$A;
        if (r.sc.to eq '!') {
            sayyl "! op to r.sc.op, was: ".
                I.d&pon,r.sc.op,$A,!$o;
        }
        else {
            I.d&pon,r.sc.op,$A,$o+C.sc.to;
        }
    }
    else {
        sayre "How to hold ".wdump 2, $r;
    }
    sayre "Have flse click: ".wdump 2, $r;
goche: |
    my $m = "g/c/".($n||8);
    Rw ghosch $m
pi/cde: |
    my $se = I.d&pin,$s,$A;
    #$se = wdump 3, $se;
    n row =>1 =>{idly=>1,s=>$se},'%cod:perl,dig:steve,dos:upcde'
    n row =>1=>{}=>{css=>"width:10em",ab=>1}
    C.sc.cssdel = 'transform';
    
    
upcde: |
    sayre "Upacode : C.t - E.t" for 1..4;
    
    sayre wdump 2, $C;
    Rw talkzyh;
    return;
    for (A.us&code) {
        sayyl "Writeing $_ from C.c.e.c.us";
        #I.d&pon,$s,$A,$_;
    }
putmoves: |
    u allovse
    n '','','%of:Sev'

    n Y =>31=><<'',{rg=>'J,V,yk'}
        # patch new to old where same t,s, add Vhooks
        C.y.lv = {k=>$k,C=>$C};
        C.y.at = {};
        C.y.ta = V.ta->{$k};
        C.y.vl = V.lv->{$k};
        if (C.c.root) { # / continues from 3 when everything's 6
            Y.root = $C;
            T.Z->{0.6} = 0.3;
            T.not = 1;
        }
somewhere: | # be somewhere
     my @path = ar.j.sc.J || ar.j.J;
     while (1) {
        my $l = $path[0];
        unshift @path, l.Jiter || last;
     }
     #saybl wdump 2, ["Gootblock:",@path];
     
     say "avoid: ".gp shift @path until !@path || $path[0] eq $J;
     shift @path;
     my $path = join '/', map{_.C.t} @path;
     
     my $A = J.A;
     my $v = G.pwin->("in/$path", $A);
     my $amo = 1.5;
     $amo = 0.8 if e.S;
     (v._.y.thy ||= 1) *= $amo;
     say "A in assign". wdump 14, [gp($J), $path, $v];
     return;
     
     #die wdump 2, [@lspath]; 
     #my $path = join '/', reverse @lspath;
     my $M = [];
     
     Mn('fro',{},"$path",'{ou:file}');
     
     Rw J5 wut $M;
Steve: |
   was h ere

