  
floatation: | # Æ¾
    # Wencaps the Wubstance behind the Jaulted door
    
    
    
    # good for clouding away entropy from the foundation
    # so so, wants to separate heaps
    # like a pha, C that is collapsing from otherspouts
    
    # kicks rays off the end of sev (or so), making lines for an In to unfold
    # or its a bunch of whatever, to json onto new line
    
    # also to sever things where sc.W c.W + id (if they are reachable via Wspace)
    # pi can also sever into channels of art noise + realmy stuff
    # float the bets
    # edge the heat
    
        # G is a tied hash, resolves to doing like I through G.h
        # R makes I from further Wish inquiry, G does similar
        # R implies floatation
        # repeast                       G.fsk.oth (does little I.oth where C is t=k s=v)

        # kind of wants lvish pointerism - you would get it from ^ids or so
        # osc idly (was around before) would keep j etc, 
        # handy for travelish reentrances by third parties
        # Jmosts must subscribe to the Goin osc...
        # which give them a G-finding W above their own W
        # which they dont know about, it's routed to...
    

        # J.mo.s is G.oin

    #u openphase
    #u threestep
    # root of the chuck out lines only sort
    # when 8s groW time on G.oin
    # C.c.In && A.t&62 &&

    # to connect Gw so A.t&63 to hold things again, merge many Rw personas into one live as repeated subs with blanky u,etc,y.at outthrustocombing, since everything goes within to sed out - sometimes holding what it was originally for loop
    # the whole control panel of J.? of ^\w .* funcs is up, line feed, code is cracking open a valley

    # Followe:
    # ^ u threes
    # ^ qq {cpi:lines u:followlines}
    # which is normal perl code^and replies to the u qq seeming
    # want to consume every void context stuff as mind
    # u/n symbol family, j for nonJmo:
    # ^ j qq {cpi:lines u:followlines}
    # or perhouse (some Jness)
    # ^ j:interso qq {cpi:lines u:followlines}
    # when vector compose program
    
    # is kinda 
    # little j eventuates index of doings to follow index
Sen: | # next net, fork catchee on stdin listened puur
    #u urw
    u UpPg;
    #u SpaceWatch
    y.in = 0.02;
    y.out = 0.5;
    y.at.sca = 0.3;
    $A = 
    s:
        t
    
    if (!-t STDIN) {
        `cd proc/; ln -s $$\.out G.t-G.cv`;
    }
    G.Jsem = sub {
        my $em = shift;
        my $db = G&db;
        $em = {lines=>[$em]} if !ref $em;
        map{$db->notify('Js',$_)} map{decode_utf8($_)} @{em.lines};
    };
    
    Rw End
urw: | # the pointyclick, curved probablW, %dos do w
    n ReoCur
    u allvse
    n seolu =>32,<<'','%code:U,v:J'
        J.oy.at.ux = 1;
        J.oy.at.oWl = 1;
        J.ev.th ||= 'middle';
        J.ev.li ||= 'climbos';
        
usr: |
    u allovse
    n urw
    Jnamehides 7: %code:Art,v:root
        delete at.c.s
GW: | # star listening !
    # networky other G.W/GW the J, see also Oth who is G.s/oin the J, self time pourer
    G.c.b &&
        u UpPg
    u Bubble
    J.VV.N = 1;
    
    #y.at.jslines = 1;
    J.ev.th = 'middle';
    y.at.ux = 2;
    y.at.sq = G.c.i ? 'Iam' : 'oWo';
    # and oin.C.c.s is also G.t, it does it
    y.at.Mid = G.t || die "NoGt? ".ki$G;
    y.at.Wid = G.oin.id;
    delete c&s;
    # ^ V
    J.lA=$A=
    n GW=>9=>{},'%ab:100,poi:0,tag:ww'
    
    my $ear = G.W;
    G.GW = G.W = $J;
    G&xot,$J,$ear if $ear;
    delete c&s;
    
    if (!G.c.b) {
        my $f = "life/W/y.at.Wid\.e";
        J.taile = $f;
        `cat /dev/null > $f` if !-f $f;
        G&dlin,'life/W',"J.at.Wid\.e","J.at.Mid\.e";
        # =>{ac=>{create=>1}} # ac/asc/etc involvers slide into the experiment from E
        n $f =>-sol
        return;
    }
    
    my $ya = G.onfork.GW = sub {
        my $db = G&db;
        my $not = G.W.noti ||= {};
        $db->on(notification => sub {
            my ($db, $name, $pid, $s) = @_;
            $s = encode_utf8($s);
            Rw GW_Answer $name $s;
        });
        for (J.at.Wid, keys %{G.W.noti}) {
            $db->listen($_);
            sayyl "Listen: $_";
        }
        G.W.lizdb = $db;
    };
    $ya->() unless J.islisten++;
    
GW_Answer: |
            my $J = G.oin;
            say "listened: $name: $s";
            if ($s =~ /^\['/) {
                Rw Too $name $s;
            }
            if ($s =~ /^CCC (\d+)$/) {
                my $h = G&qh,<<'',$1;
                    select f,t,s,mid from mez where mid = ?
                length(h.s) || die "mized mez: $1";
                Rw timer $d=2 $cb:_ for sub { G&qp,<<'',h.mid };
                    delete from mez where mid = ?
                $s = h.s;
                warn "aNm not $name h.t for mezmid=h.mid" if h.t ne $name;
            }
            if (my $J = G.W.noti.>$name ) {
                my $c;
                c.e = G&tC,[PgNotify=>{s=>$s}];
                ref $J eq 'CODE' ? $J->($name,$s) :
                    Rw waited $J $c
            }
            elsif ($s =~ /^(\w+);(.+)$/) {
                my $m = [split',',$2];
                Rw $1 $J:G.oin $m;
            }
            elsif ($s =~ /^me (.+)$/) {
                $J = G.U;
                J.me = $1;
                Rw forked $J;
            }
            else {
                my $c;
                c.e = G&tC,[PgNotify=>{s=>$s}];
                Rw waited $J:G.W $c;
            }
Iam: |
     @$N == 1 || die "strangely: ".wdump 3, $N;
     $N = $N->[0];
     my ($t,$y,$c,$sc) = @$N;
     delete c.s;
     delete c.tag if c.tag eq 'ww';
     delete sc.ab if sc.ab eq '100';
     delete sc.poi if sc.poi eq 'none';
     c.el = 6;
     c.Mid || die "No mid: ".ki{o=>$c};
     [delete(c.Mid),$y,$c,$sc];
oWo: |
    @$N == 1 || die "strangely: ".wdump 3, $N;
    $N->[0];
SevWo: |
    u allacgts
    n Meta
    n Wuts
    
    slnk:
        my $i = readlink $s;
        return $i if !@Me;
        my $e = $Me[0];
        return if $i eq $e;
        `unlink $s` if -l $s;
        `ln -s $e $s`;
        
    
    dlin: %acgt:dir to it
        return readlink $dir if !defined $to;
        my $l = "$dir/$it";
        my $is = -l $l;
        return if $is && readlink($l) eq $to;
        `unlink $l` if $is;
        `cd $dir; ln -s $to $it`;
    
    wraf: %acgt:f s noappend
        $s =~ s/\n?$/\n/s if !ref $s;
        G&writef,$f,$s,!$noappend
    
    writef: %acgt:f s append
        (my $d = $f) =~ s/\/[^\/]+?$//;
        unless (-d $d) {
            `mkdir -p $d`;
        }
        .
        $s = [$s] if !ref $s;
        my $li = ref $s eq 'ARRAY' ? join("",map{/\n$/?$_:"$_\n"}@$s)
            : die "Wsome other $f type: $s";
        .
        my $wa = {};
        wa.append = 1 if $append;
        write_file($f,$wa,$li);
        return length $li;
    
    ajam:
        " \$.ajax('$s').done(function(v) {"
            ." var m = v".'.split("\n");'
            ." \$.each(m,function(k,v){ a\.m(v); }); });";
    
    u allovse
    n \'of:O'
    # conceal the multiJexits
    J 35:
        delete at.sc.J if C.c.S;
    
    u allvse
    n \'%of:Sev'
    # might wanna carebowl em 2-4 to engage scd/em at all
    n root =>582=><<'',{rg=>'ylv,yvl'}
        return unless A.J.most.J eq A.J || A.J.C.c.Wo;
        my $r = G&scd,$lv,$vl;
        return unless @{r.z};
        A.bangdesk.bang.sevwoe = sub {
            sayre " was in em section: ".wdump 5, $r;
        };
        C.c.em && die'wtf';
        .
        my $em = C.c.em = {};
        em.lines = r.z;
        em.i = @{r.oldz};
        .
        A.Subtle.em = 1;
        A.t&em,6,2;
    
Meta: |
    u allvse
    n '','','%of:em'
    n em =>21=><<''
        em.lines || die "Not lines";
        em.hitime = hitime();
        em.is.W = C.sc.Wid || A.J.id;
        em.is.M = C.sc.Mid || A.J.name;
        em.id = em.is.W.'.'.(0+em.i);
    
    u allsvse
    
    n jslines =>3=><<'',{cg=>'J,em'}
        Rw EmJSlines $A $J $em $C $T;
    
    sq 24: %cg:em
        em.lines = Rw $sq $N:em.lines $em $J:A.J;
    
    ux 3: %cg:em
        if (ref em.lines) {
            my $M = em.lines;
            if ($ux < 2) {
                $M = ['','',{W=>G.t},{z=>$M}]
            }
            em.lines = [sjson($M)];
        }
        C.sc.Wc = 1;
        return sayyl "Was router for G.W.name" if C.c.J eq G.W;
        my $J = G.oin;
        n GW
        #
    
    n ressur =>3=><<'',{cg=>'J,em'}
        saybl "Ressurrecting $ressur ...";
        die "zomp $ressur" if $ressur =~ /\W/;
        my $resu = "life/W/$ressur";
        die "bno JSlines" unless -e $resu;
        if (G.Jsem) {
            my $q = G&ajam,$resu;
            say "Sending $resu via Jsem";
            return G.Jsem->($q);
        }
        `cd life; ln -s ../W/$ressur J/em.id\.c`;
        my $catch = sjson {y=>J=>id=>em.id};
        I.d&writef,"life/J\.s",$catch,1;
        T.whack = 1; # out of em
    
Wuts: |
    u allsvse
    n '','','%of:em'
    # (ais coming soon: (only space or)
    n Wc =>446=><<'',{cg=>'J,em'}
        saybl join"\n","Downing em.is.M: em.is.W: ",
            map{!ref $_ ? $_ : wdump 5,$_} @{em.lines}
            if A.V&W;
        I.d&writef,"life/W/em.is.W\.c",em.lines,em.i;
        .
        C.c.as = !C.c.os;
        C.c.As = C.c.as;
        C.sc.meta = 1;
        C.sc.speak = 1 if C.c.as;
        C.sc.takeover = 1 if C.c.As;
        saybl "WHITESPACE S em.is.M" if C.c.os;
    
    # inter intros
    n meta =>47=><<'','%cg:em'
        G.M->{em.is.M} = A.J;
        G.Wh->{em.is.W} && return;
        G.Wh->{em.is.W} = A.J;
        my $me = I.d&hup,$em;
        delete me.lines;
        I.d&writef,"life/W/em.is.W\.i",sjson($me);
    
    n speak =>48=><<'','%cg:em'
        return if G.Jlone;
        .
        my $jf = "life/J/em.id\.c";
        my $l = I.d&writef,$jf,em.lines;
        if (G.Jsem) {
            if ($l > 4000) {
                sayre "Big em.is.M: $l";
                my $q = G&ajam,$jf;
                sayyl "Sending in $q";
                G.Jsem->($q);
            }
            else {
                G.Jsem->($em);
            }
        }
        .
        I.d&writef,"life/J\.s",sjson({y=>'J',id=>em.id}),1;
    
    n takeover =>49=><<'','%cg:em'
        G&dlin,'life/W',"em.is.W\.c","em.is.M";
    
Too: |
    for (G&tC,djson$s ) {
        if (_.c.mez) {
            my $h = G&qh,<<'',$1;
                select f,t,s,mid from mez where mid = ?
            length(h.s) || die "mized mez: $1";
            Rw timer $d=2 $cb:_ for sub { G&qp,<<'',h.mid };
                delete from mez where mid = ?
            $s = h.s;
            warn "aNm not $name h.t for mezmid=h.mid" if h.t ne $name;
        }
        else {
            say "What $name: ".ki$_
        }
    }
    
Siendo: | # send instruct (to forked) between G
    u UpPg
    Atime(2);
    $A =
    n n=>''=>n
    
    my $db = G&db;
    my $to;
    if (my $to = e&toG ) {
        my $name = "life/W/$to";
        -e $name || die "$name is not exids";
        my $W = readlink $name;
        $W =~ s/\.c$//;
        my $s = 'me '.e&s;
        G&zen,$W=>$s;
        sayre "Hars: $to -> $W    puts: $s";
    }
    
waitme: | # 
    use POSIX ':sys_wait_h';
    for (@{ar.m||[]}) {
        G.fasting = 1 if /fr/;
        G.reing = 1 if /re/;
    }
    G.reing = 1 if ar.m && ar.m->[0] eq 're';
    if (G.forked && !G.reing) {
        sayre "waitme already forked" for 1..3;
        return;
        exit;
    }
    
    my $parent = $$;
    if (my $pid = fork()) {
        sayyl "
            oooo
               oo
               o o
              o   o
             o";
        my $and;
        my $kill = $SIG{INT} = sub {
            sayre "Killing $pid...";
            kill 'KILL', $pid;
            delete $SIG{INT}
        };
        $SIG{HUP} = sub {
            $and = 1;
        };
        
        waitpid($pid,0);
        
        if ($and) {
            saybl "child wants restart!";
            return
            Rw waitme
        }
        return 1 if G.fasting;
        my $gen = G.reing ? "Remiddle" : "Restart";
        saybl $gen.(G.fasting ? "d" : "? <");
        unless (delete G.fasting) {
        my $IN = \*STDIN;
        while (my $k = <$IN>) {
            chomp $k;
            !G.reing && !$k && return 2;
            J.me = $k;
            say "__ $k";
            Rw goche $n=$1
            while $k =~ s/(\d+)//g;
            Rw goche $n:_
                for qw'81 64 8 84 1';
            Rw waitme;
            return 2;
        }
        }
    }
    else {
        G.forked = $parent;
    }
    delete G.reing;
    return !G.forked;
forked: | # me enters stufff
    J.me = ar.m->[0] if ar.m;
    # etc
    if (J.me eq 'm') {
        J.me = read_file("w/wasme");
        say "Repeating: J.me";
    }
    write_file("w/wasme", J.me) if J.me;
    J.wasme = J.me;
    if (J.me =~ /^(\w+): (.+)$/) {
        my $c = {t=>mesay=>y=>{}=>c=>{s=>$2,toG=>$1}};
        n Siendo=>$c
        J.me = '';
        return;
    }
    if (J.me =~ /^(\w+);(.*)$/) {
        my $m = [split',',$2];
        Rw $1 $J:G.oin $m;
        return;
    }
    if (J.me =~ /^(\w+):(\S+)(\s|$)/) {
        my $o;
        my ($is,$ul) = ($1,$2);
        my $t = $1 if $ul =~ /^(\w+)/ || die "niul $ul";
        if (0 && !-f "w/$is/$t") {
            my @op = glob "w/$is/$t*";
            sayre "Many options: ".ki @op if @op > 1;
            my $o = shift @op;
            $ul = $1 if $o =~ /^.+\/(.+?)$/;
        }
        sayyl "So: $is, $ul   fr  $o";
        J.me = " ALL $is:$ul";
    }
    if (J.me =~ s/^ (\w+)(?: (.+))?// && G.way->{$1}) {
        n $1=>W=>{t=>$2}
    }
    
    J.fti -= 3 if J.me =~ s/o//g;
    J.fti -= 2 if J.me =~ s/i//g;
    
    delete G.forked if J.me =~ s/p//;
    
    Rw loopby $b=3 $d=5 $p=Top
        if J.fti < 0;
    J.fti++;
    
    J.me =~ /n/ &&
        `cat /dev/null > G.GW.taile`;
    J.me =~ /a/ &&
        n All=>W=>{time=>6}
    J.me =~ /A/ &&
        n Aim
    J.me =~ /u/ &&
        n uncan
    J.me =~ /N/ &&
        n Notes
    J.me =~ /s/ &&
        n Sefi
    J.me =~ /S/ &&
        n Sefission
    J.me =~ /w/ &&
        n Pile
    J.me =~ /g/ &&
        n Dug
    J.me =~ /c/ &&
        n Chang
    J.me =~ /d/ &&
        n Details
    J.me =~ /j/ &&
        n ALL=>W=>{t=>'Swomp',isle=>'jes'}
    J.me =~ /t/ &&
        n Tarp
    J.me =~ /v/ &&
        n reJSlines
    
    J.me = '';
exit: |
    for (@{ar.m||[]}) {
        $_ eq 'refork' &&
            Rw restar $keep=1;
        if ($_ eq 'refork') {
        }
    }
    exit;
restar: |
    G.forked eq $$ && die "You are forked: $$";
    kill HUP=>G.forked;
    exit unless ar.keep;
Sl: |
    G.U = $J;
    J.fti ||= 0;
    if (J.fti >= 0) {
        Rw waitme;
    }
    sayyl "Ftime up J.fti";
    Rw forked;
    
Wh: |
    y.at.oWl = 1;
    n Tarp
    #n AfghanRug
    n Soom
    J.fsjoi++ ||
        Rw loopby $b=5 $d=26 $p=Top;
Be: |
    # nothing!
Br: |
    Rw Be;
Bu: |
    Rw Be;
Bo: |
    Rw Be;
Le: |
    #
    Rw Be l;
    n Ger;
Web_up: |
    use Mojolicious::Lite;
    use MIME::Base64;
    push @{app->static->paths}, '/home/s/styleshed/public';
    app->secrets(["nothing"]);
    
    G.c.listen = readlink('listen') if -f 'listen';
    my $s = G.c.listen || "http://s:10094";
    
    

    get '/' => sub {
        my $c = shift;
        $c->reply->static("index\.html");
    };
    
    Rw Tism;
    
    websocket '/s' => sub {
        my $mojo = shift;
        sayyl "Connect!";
        die "No GWebsock yet" unless G.Websock;
        G.Websock->($mojo);
    };
    
    
    
    G.clockon = sub {
        saybl "Starting  G.t     listens: $s";
        app->start('daemon', '--listen' => "$s");
    };
    
Web: |
    u UpPg
    $A=
    s:
        t
    
    G.Websock = J.Websock ||= sub {
        my $mojo = shift;
        say "Web is socked!";
        my $s = $mojo;
        my $tx = $s->tx;
        J.tx = $tx;
        my $addr = $tx->remote_address;
        Mojo::IOLoop->stream($tx->connection)->timeout(300000);
        $tx->max_websocket_size(512000);
        $s->on(message => sub {
            my ($M, $m) = @_;
            $m = encode_utf8($m);
            sayyl "Message from $addr ".$m;
            my $dec = eval { djson $m };
            $@ && die "Message doesnt decode: $@\n\n$m";
            
            if (my $W = dec.event.W) {
                my $db = G&db;
                $db->notify($W,decode_utf8($m));
                say "Sent ".length($m)." to $W";
            }
            else {
            
            }
        });
        $s->on(finish => sub {
            my ($M, $code, $reason) = @_;
            sayre "Gone: $addr $code $reason";
        });
        $tx->send(' clon();keon();');
        return;
        my $M = [];
        Mn(elvi=>-websock=>{s=>$mojo});
        n WebSocks => @$M
        sayyl "Socksdone";
    };
    
    G.Websen = J.Websen ||= sub {
        my $m = shift;
        J.tx->send(decode_utf8($m));
    };
    
    my $ya = G.onfork.Web = sub {
        my $db = G&db;
        $db->on(notification => sub {
            my ($db, $s, $pid, $m) = @_;
            $m = encode_utf8($m);
            say "$s: $m";
            J.Websen->($m);
        });
        $db->listen(G.c.in || 'Js');
    };
    $ya->();
    saybl "Web done";
    
    
    
Wob_up: |
    use Mojolicious::Lite;
    use MIME::Base64;
    push @{app->static->paths}, '/home/s/styleshed/public';
    app->secrets([readlink '/home/s/stylehouse/msecret']);
    
    my $s = "http://c:10096";

    get '/hello' => sub {
        my $c = shift;
        $c->render(text => 'Hello World!');
      };

    Rw Tism;
    
    G.clockon = sub {
        saybl "Starting  G.t     listens: $s";
        app->start('daemon', '--listen' => "$s");
    };
Tism: |
    0 && <<'';
        require Image::Magick;
        my $cand_photo = Image::Magick->new;
        #my $decoded = decode_base64($args{image_string});
        $cand_photo->read(blob=>$decoded);

        #save original
        $cand_photo->Write($f.".igk\.jpg");

        #resize
        $cand_photo->Set( Gravity => 'Center' );
        $cand_photo->Resize( geometry => '120x120' );
        $cand_photo->Extent( geometry => '120x120' );
        #save thumbnail
        $cand_photo->Write($f.".gth\.jpg");

    
    put '/tism' => sub {
        my $m = shift;
        my $c = $m->req->body;
        $c =~ s/^data:image\/jpeg;base64,//;
        my $decoded= MIME::Base64::decode_base64($c);
        my $run = substr($G->{id},0,4);
        my $dir = "znap";
        my $rundir = "znap/$run";
        `mkdir $rundir` unless -d $rundir;
        my $f = sprintf "$rundir/%06d\.jpg", $G->{tismi}++;
        say "Go to $f for ".length $c;
        $f = "/home/s/shed/$f";
        write_file($f,{binmode=>':raw'},$decoded);
        $m->render(text => 'yup');
    };
Wob: |
    G.c.in = "Ws";
    #Rw Web;
goche: |
    my $m = "g/c/".($n||8);
    Rw ghosch $m
ghosch: |
    return sayre "ghosch iggy $m" if $m !~ /^g(hosts?)?\/c\//;
    my $u = LoadFile $m;
    map {
        (my $k = $_) =~ s/\W/-/g;
        G.way->{$k} = $u->{$_};
    } keys %$u;
    delete G.drop;

