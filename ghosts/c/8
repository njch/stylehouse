  
floatation: |
    # Wencaps the Wubstance behind the Jaulted door
    # good for clouding away entropy from the foundation
    # so so, wants to separate heaps
    
    # kicks rays off the end of sev (or so)
    # all the stuff is is s by now if its making lines
    # or its a bunch of whatever, to json onto new line
    
    # also to sever things where sc.W c.W + id (if they are reachable via Wspace)
    # pi can also sever into channels of art noise + realmy stuff
    # float the bets
    # edge thje het
    
        #   R writef life/W/em.is.W\.c em.lines $append:em.i
        # G is a tied hash, resolves to doing like I through G.d
        # R makes I from further Wish inquiry, G does similar
        # R implies floatation
        # repeast                       G.fsk.oth (does little I.oth where C is t=k s=v)

        # kind of wants lvish pointerism - you would get it from ^ids or so
        # osc idly (was around before) would keep j etc, 
        # handy for travelish reentrances by third parties
        # Jmosts must subscribe to the Goin osc...
        # which give them a G-finding W above their own W
        # which they dont know about, it's routed to...
    

        # J.mo.s is G.oin

    #u openphase
    #u threestep
    # root of the chuck out lines only sort
    # when 8s groW time on G.oin
    # C.c.In && A.t&62 &&

    # to connect Gw so A.t&63 to hold things again, merge many Rw personas into one live as repeated subs with blanky u,etc,y.at outthrustocombing, since everything goes within to sed out - sometimes holding what it was originally for loop
    # the whole control panel of J.? of ^\w .* funcs is up, line feed, code is cracking open a valley

    # Followe:
    # ^ u threes
    # ^ qq {cpi:lines u:followlines}
    # which is normal perl code^and replies to the u qq seeming
    # want to consume every void context stuff as mind
    # u/n symbol family, j for nonJmo:
    # ^ j qq {cpi:lines u:followlines}
    # or perhouse (some Jness)
    # ^ j:interso qq {cpi:lines u:followlines}
    # when vector compose program
    
    # is kinda 
    # little j eventuates index of doings to follow index
SevWo: |
    n Meta
    n Wuts
    
    u allacgts
    
    n writef =>''=><<'',{acgt=>'f,s,append'}
        (my $d = $f) =~ s/\/[^\/]+?$//;
        unless (-d $d) {
            `mkdir -p $d`;
        }
        .
        $s = [$s] if !ref $s;
        my $li = ref $s eq 'ARRAY' ? join("",map{/\n$/?$_:"$_\n"}@$s)
            : die "Wsome other $f type: $s";
        $li = encode_utf8 $li;
        .
        my $wa = {};
        wa.append = 1 if $append;
        write_file($f,$wa,$li);

    u allovse
    n '','','%of:O'
    n J =>35=><<''
        delete at.sc.J if C.c.S;
        # conceal the multiJexits
    
    u allvse
    n '','','%of:Sev'
    # might wanna carebowl em 2-4 to engage scd/em at all
    n root =>582=><<'',{rg=>'ylv,yvl'}
        return unless A.J.most.J eq A.J || A.J.C.c.Wo;
        my $r = Rw scd $rl:vl $rv:lv;
        return unless @{r.z};
        aft { $@ || return; sayre "$@  !~!! ".wdump 9, $r; };
        C.c.em && die'wtf';
        .
        my $em = C.c.em = {};
        em.lines = r.z;
        em.i = @{r.oldz};
        .
        A.Subtle.em = 1;
        A.t&em,6,2;
    
Meta: |
    u allvse
    n '','','%of:em'
    n em =>21=><<''
        em.lines || die "Not lines";
        em.hitime = hitime();
        em.is.W = C.sc.Wid || A.J.id;
        em.is.M = C.sc.Mid || A.J.name;
        em.id = em.is.W.'.'.(0+em.i);
    
    # c ^
    # sc v
    u allsvse
    n jslines =>3=><<'',{cg=>'J,em'}
        Rw EmJSlines $A $J $em $C $T;
    
    n ux =>3=><<'',{cg=>'em'}
        my $J = G.oin;
        my $M = ['','',{W=>J.id},{z=>em.lines}];
        em.lines = [sjson($M)];
        C.sc.Wc = 1;
        n GW
        # ^ router, W with an .e v
    
    n ressur =>3=><<'',{cg=>'J,em'}
        saybl "Ressurrecting $ressur ...";
        die "zomp $ressur" if $ressur =~ /\W/;
        die "bno JSlines" unless -e "life/W/$ressur";
        `cd life; ln -s ../W/$ressur J/em.id\.c`;
        my $catch = sjson {y=>J=>id=>em.id};
        I.d&writef,"life/J\.s",$catch,1;
        T.whack = 1; # out of em
    
Wuts: |
    u allsvse
    n '','','%of:em'
    n Wc =>446=><<'',{cg=>'J,em'}
        saybl join"\n","Downing em.is.M: em.is.W: ",
            map{!ref $_ ? $_ : wdump 5,$_} @{em.lines}
            if A.V&W;
        I.d&writef,"life/W/em.is.W\.c",em.lines,em.i;
        .
        # is coming soon: (only space or)
        C.c.as = !C.c.os;
        C.c.As = C.c.as;
        C.sc.meta = 1;
        C.sc.speak = 1 if C.c.as;
        C.sc.takeover = 1 if C.c.As;
        saybl "WHITESPACE S em.is.M" if C.c.os;
    
    # inter intros
    n meta =>47=><<'','%cg:em'
        G.Wh->{em.is.W} && return;
        G.Wh->{em.is.W} = A.J;
        my $me = I.d&hup,$em;
        delete me.lines;
        $me = sjson $me;
        I.d&writef,"life/W/em.is.W\.i",$me;
    
    n speak =>48=><<'','%cg:em'
        return if G.Jlone;
        .
        I.d&writef,"life/J/em.id\.c",em.lines;
        .
        my $catch = sjson {y=>J=>id=>em.id};
        I.d&writef,"life/J\.s",$catch,1;
    
    n takeover =>49=><<'','%cg:em'
        -l $_ && `unlink $_` for "life/W/em.is.M";
        `cd life/W; ln -s em.is.W\.c em.is.M`;
    
Sl: |
    y.at.oWl = 1;
    J.ev.th ||= 'middle';
    J.ev.li ||= 'climbo';
    J.ev.bo ||= 'bodos';
    
    n reJSlines
    # makes everything but js=1
    
    #n "life/S\.s"=>-sol=>''=>'%dos:loadwav'
    
    #y.at.jslines = 1;
    #n skdo=>2=>"a\.sitandspin();",'%js'
    
    #rand 1 < 0.17 &&
    0 &&
    n bla =>3=>G.way.paps,'%js'
    
    0 &&
    n blag =>4=>{s=><<''},'%js'
        //paper.project.clear();
    
    #n jshang
    #n ThisPr
    #n ReoCur
    #n Precoall
    
    #J.dfko++ ||
    #    n Notes
    
    my $time = J.fsjoi ||= 0;
    if ($time >= 0) {
        Rw waitme;
        $time -= 3 if J.me =~ s/o//g;
        $time -= 2 if J.me =~ s/i//g;
    }
    sayyl "Ftime up $time";
    $time++;
    if ($time < 1) {
        Rw loopby $b=3 $d=5 $p=Top;
    }
    J.fsjoi = $time;
    Rw forked;
    
forked: |
    J.me =~ s/p// &&
        delete G.forked;
    J.me =~ /a/ &&
        n All=>W=>{time=>6}
    J.me =~ /u/ &&
        n uncan
    J.me =~ /n/ &&
        n Notes
    J.me =~ /s/ &&
        n Sefi
    J.me =~ /w/ &&
        n Wjes
    J.me =~ /g/ &&
        n jogthe
    J.me =~ /c/ &&
        n Chang
    J.me =~ /d/ &&
        n Details
    J.me =~ /j/ &&
        n jshang
    J.me =~ /t/ &&
        n Tarp
    
    #n Details
    #n EYZ
    #n Usee
    # Rw followS
Noteal: | # heeling notation, a TeCurve, space share
    y.at.unit = 1; # e W come by, upper state could kink into curv
    y.ope = 1;
    y.at.anch = 'Noteal';
    J.ev.th = "SpaceElvs"; # no where yet...
    J.UG ||= [];
    J.VV.N = 1;
    
    # hinges open spacecones
    u ReoCur
    
    # it pis into I... suu
    u curv =>pi=><<''
        zoom 0 0.9
        y    0  0
        x    0  0.02
        curve 0 -0.2
        curve 0.4 0.4
        spin 0.3 2

    # kind of space that is balanced, recurring, cleaning
    # weird mediation between placed J.C and J.root to plop W
    n s=>''=>t
    y.in = 2;
    
    Mn(J.UG) if @{J.UG};
SpaceElvs: |
    my $M = J.UG||die"stuppug";
    for (A.e&C) {
        # y.unit 
        my $id = _.sc.id;
        if (grep{_.sc.id eq $id}@$M) {
            saygr "Already spaced: $id";
        }
        else {
            sayyl "GOT S P A C E ELVIS: C.t: _.t   _.y.cv";
            sayyl "Unto: ".wdump 3,[$M,$_];
            Mn(_.t=>''=>"Thi _.t",{id=>$id,swy=>'de',nspc=>0.3});
        }
        T.oke = 1; # must reply for id
    }
indoc: | # for notes, income
    J.UG = [] if !defined J.UG || A.us&S;
    if (A.us&pick) {
        # ^ array of pick, can be empty meaning bring display,
        # align proteins tracks, sheer interest
        push @{J.UG}, $_ for A.us&_pick;
        sayyl "Intdoctrined J.name from A.J.name: ".wdump 3,[A.us&_pick ];
    }
    else {
        warn "e complicated but not pick ".ki C.c.e if A.us&C || A.e&yJ;
        my $e = C.c.e;
        say "CLumping from A.J.name to J.name: e.t  ===  e.c.s";
        e.sc.oW = A.J.name;
        push @{J.UG}, $e;
    };
Notes: |
    y.at.anch = 'Noteal';
    u ReoCur
    u threJ
    y.at.ux = 1;
    J.VV.N = 1;
    J.ev.th ||= 'middle';
    J.ev.li ||= 'climbo';
    J.ev.bo ||= 'bodos';
    Mn($_=>-text=>$_,'%dos:plucJ') for qw'
        Mandrins
        Damine
        Leteleto
        Loenade
    ';
    return;
    
    delete J.dfkog if J.dfkog > 3;
    return if J.dfkog++;
    
    my ($e) = do {
        my $M = [];
        Mn(thing=>''=>"WIthu");
        @$M
    };
    saybl "J.name posts to Othie: ".ki $e;
    n Othie=>$e
plucJ: |
    # not =>$E properly, C is first C,c.e $E is from before $E
    my @Js = I.d&inDin,$E,'_hJ';
    my ($tW,$tl) = @Js[0,-1];
    tW.mo.J eq $tW || die "not most 1: ".ki $tW;
    
    tl.C.sc.pi =~ /^(text)$/ || die "not bl/gee 3: ".ki $tl;
    
    my $M = E.c.us.pick ||= [];
    Mn(founde=>-edr=>(join';',tl.C.c.s),{mean=>Somehows});
    n Othie =>$E
Othie: |
    u ReoCur
    u threJ
    y.at.anch = 'Noteal';
    y.at.ux = 1;
    J.ev.th ||= 'middle';
    J.ev.li ||= 'indoc';
    J.UG ||= [];
    y.in = 2;
    y.out = 5;
    J.VV.N = 1;
    J.VV.V = 1;
    n noie => 1=>"OOOOOOO"
    n noie => 7=>"OOOOOOO"
    my $pi = {};
    push @{$pi->{"_.sc.oW _.sc.mean _.sc.to"}||=[]}, $_ for @{J.UG};
    for my $k (sort keys %$pi) {
        Mn($k=>-ean=>{s=>$pi->{$k}});
    }
    sayyl "Other things we arte: _.t    x ".@{_.c.s} for @$M;
    my $from = A.e&trJ;
    say "From: from.name from a C.c.e.t ".wdump 3, [
        A.us&_pick ,
        [From=>map{ki $_} A.e&_hJ
        ],
    ];
 
uncan: |
    y.at.jslines = 1;
    n blag =>4=>{s=><<''},'%js'
        paper.project.clear();
    
Wh: |
    y.at.oWl = 1;
    n Details
    
    my $n = J.fsjoi++;
    $n && 1;
    $n || Rw loopby $b=5 $d=26 $p=Top;
    
    
ThisPr: |
    #u ReoCur
    y.at.ux = 1;
    J.VV.N = 1;
    y.at.oWl = 1;
    n Chang
    
    Mn(Y=>-raay=>'Chang');
    y.out = 6;
    y.in = 1;
    n d =>'1.2-3x2.4'=>','=>'%fs:44,ml:-1'
    
pi/raay: |
    my $oJ = J.mo.J.bb->{"0.3\t$s\tJ"} || return
        n 404 => 1 =>"snothere: $s"
    my $Y = oJ.El.Pre;
    my $se = Y.tv if C.t eq 'tv';
    $se = $Y if C.t eq 'Y';
    $se = se.tv;
    $pi ||= C.t;
    $se || return
        n 500 => 2 =>"no access: C.t"
    Mn(C.t=>pi=>{s=>$se});
pi/Y: |
    n Y =>1=>C.t
    Mn(hach=>pi=>{s=>$s});
pi/w: | # the soft Rw or u art grab
    my $es = G.way.Elis;
    y.in=1;
    Mn(pre=>pi=>{s=>$es});
    
pi/hach: |
    my $se = {%$s};
    while (my ($k,$v) = each %$se)  {
        $se->{$k} = ref $v ? ref($v)." ".ki $v : $v;
    }
    my $es = wdump 1, $se;
    Mn(pre=>pi=>{s=>$es});
    #
pi/pre: |
    n pre =>1=>{s=>$s}=>'%tag:pre'
pi/tv: |
    Mn($_=>''=>{pi=>C=>s=>$s->{$_}})
        for sort keys %$s;
    
pi/C: |
    ref $s eq 'HASH' || return
        n nothash=>''=>{s=>wdump 2, $s}
    n t =>1=> s.t
    n ycv =>2=> s.y.cv
    n c =>3=> ki s.c
    n sc =>4=> ki s.sc
pi/di: |
    y.ert = 9;
    for (`ls --full-time --inode`) {
        chomp;
    }
ghosch: |
    sayyl "Ghosch: $m";
    return sayre "iggy $m" if $m !~ /^g(hosts?)?\/c\//;
    my $u = LoadFile $m;
    
    G.way->{$_} = $u->{$_} for keys %$u;
    delete G.drop;
loadwav: |
    sayyl " F  IND SOME FOR E.c.s";
    
    E.c.serJ && map {
        Rw clack + $m:_
    } "Already serJ = E.c.serJ.name";
    E.c.serJ = $J;
    
    for (E.c.s) {
        /^ghostchanges (.+)$/ ?
            Rw ghosch + $m:1
        :
        /^hello/ ?
            return saybl " hello! E.t: $_"
        :
        sayre "Unclassified talk: $_"
    }
    # be!  plus
    
    sayyl '' for 1..4;
Usee: |
    u ReoCur
    y.at.ux = 1;
    J.VV.N = 1;
    
    my $i = int rand 19;
    sayre("CHANGING THIS\n\n\n\n") && `echo $i >> ded/$i` if int(rand 19) > 14;
    my @l = `find ded`;
    #my @l = `find life/W -type l`;
    #my @r = `find life/W -mtime +0.6 -type f`;
    #my @el = `find life/W`;
    chomp for @l;
    while (@l > 7) {
        `rm $_` for shift @l;
    }
    y.in=1;
    y.out=5;
    Mn(some=>''=>{pi=>textl=>s=>$_})
        for split"\n",wdump 2, \@l;
pi/textl: |
    my $l = sum map{ord $_} split '', $s;
    $l /= 10 until $l < 10;
    my $h = int $l;
    n text=>1=>$s,{hs=>"${h}86"}
EYZ: |
    u ReoCur
    y.at.ux = 1;
    J.VV.N = 1;
    u curv =>pi=><<''
        zoom 0  0.13
        y    0  0
        x    0  0
        curve 0 -0.03
    
    # eyes !
    y.limn = 0.2245;
    y.lum = 5;
    y.in = 0.04;
    y.out = 0.3;
    #Mn(shedful => '', {pi=>'eye',s=>'eye/Tarf/Photo serieses'});
    Mn(shedful => '', {pi=>'fi',s=>'eye/el'});
Details: |
    u ReoCur
    y.at.ux = 1;
    y.at.oWl = 1;
    J.VV.N = 1;
    
    #n AfghanRug
    n $_,$_,$_,'%hs:389,fs:24,ml:-2em' for 1, 3, 5, 7, 9;
    
    J.ev.th ||= 'middle';
    J.ev.li ||= 'climbo';
    J.ev.bo ||= 'bodos';
    
    n undivthis=>[-dos=>0.06]
    
    #n lod=>0.06 =>'fds'=>'%id:lodo,dos:goche,wi:3'
    
    G.edit ||= 'G/way/Details';
    n edit=>0.02=>'@'=>'%id:edat,dos:flse,op:J/se/cod,to:!'
    J.se.cod &&
    n 'G/edit'=>[-cde=>'1-2']
    J.se.cod &&
    n G.edit=>[-cde=>'2-6']
    y.at.cssdel = 'transform';
    
    #n Tarp
    J.act = 0; # pi always
    #return
    #n Sefi
    J.dooed++ || 
    n Wjes
    # one to com the piles
    return;
    y.in = 0.08;
    y.lum = 1;
    y.out = 3;
    Mn($_=>-shed=>) for 'ghosts/c/45';
    J.pix = {pi=>te=>pito=>'nothing'};
    
    
    #Mn($_=>-codey=>) for @{J.CO||=[]};
    #Mn(shedful => '', {pi=>'eye',s=>'eye/fug/1/lt'});
    
    n $_,$_,$_,'%hs:389,fs:20' for 1, 3, 5, 7, 9;
    
    return;
DetailMark: |
    my $mark = [',',qw' ? ; :'];
    A.us&C && A.us&S ? J.fkeo++ : J.fkeo--;
    
    J.fkeo += 1 until J.fkeo >= 0;
    J.fkeo -= @$mark while J.fkeo > @$mark;
    
    J.sdjfsiji ||= 4;
    my $n = J.sdjfsiji++;
    my $sp = J.sfjkiig .= '   ';
    my $sc = J.fekooo ||= {};
    sc.fs ||= 3;
    sc.fs += 2;
    sc.ml += 1;
    #Mn(d =>''=>$mark->[J.fkeo]=>'%fs:44,hs:'.int(rand(9)).'36') for 1..6;
    
Sefi: |
    u ReoCur
    y.at.ux = 1;
    y.at.oWl = 1;
    y.at.ws = 1;
    y.at.hs = '393';
    y.in = 0.03;
    y.out = 4;
    J.VV.N = 1;
    
    my $p = 'g/c/*';
    Mn(p=>''=>$p,'%decor,hs:388,fs:15');
    
    # $f mtimes into w/wf/$fish (s/\//-/g), for its -glo:
    #  - way $k digs into w/digway/$kish
    #    - new file written & diffed and move in/over w/way/$kish
    
    my $glomet = sub {
        my $f = shift;
        my $mt = (stat $f)[9];
        my $fi = $f;
        $fi =~ s/\//-/g;
        my $wf = "w/wf/$fi";
        my $mft = (stat $wf)[9] if -f $wf;
        $mt > $mft
    };
    
    my @li = glob $p;
    for my $f (@li) {
        $glomet->($f) || next;
        # part of glo ^
        Mn($f=>-glo=>{}=>'%dis');
    }
    Mn(found=>''=>"found ".@li);
    n o=>42=>"@",'%fs:40,blr:4';
    # and so
pi/glo: | # see file glowing, flood gates of
    y.at.hs = '638';
    n f => 1 => C.t
    n changed=>2=>changed=>'%hs:857'
    
    my $d = LoadFile($s);
    `mkdir w/way` if !-d 'w/way';
    `mkdir w/digway` if !-d 'w/digway';
        
        while(my($k,$v) = each %$d) {
            $k =~ s/\//-/g;
            my $waf = "w/way/$k";
            my $wig = "w/digway/$k";
            my $dig = slm 10, dig($v);
            my $lin = readlink($wig) if -l $wig;
            if ($lin eq $dig) {
                sayyl "$wig same ($dig)";
                next;
            }
            else {
                sayyl "Lin: $lin eq $dig" if $lin;
                sayre "No lin $wig " if !$lin;
            }
            write_file($waf."nt",$v);
            if (!-f $waf || `diff $waf ${waf}nt`) {
                Mn(gfot=>''=>"\n - $k");
                `mv ${waf}nt $waf`;
            }
            else {
                `rm ${waf}nt`;
            }
            -l $wig && `unlink $wig`;
            `ln -s $dig $wig`;
        }
        
    # mtimes in wf must be after any of the inner branches ^
    my $fi = $s;
    $fi =~ s/\//-/g;
    my $wf = "w/wf/$fi";
    `mkdir w/wf` if !-d 'w/wf';
    write_file($wf,'');
    
pileJup: |
    # not =>$E properly, C is first C,c.e $E is from before $E
    my @Js = I.d&inDin,$E,'_hJ';
    @Js == 3 || return sayre("WEird look".wdump 4, [ @Js  ]) &&
        Rw talkzyh;
    my ($tW,$tJ,$tl) = @Js;
    tW.mo.J eq $tW || die "not most 1: ".ki $tW;
    tJ.C.sc.pi eq 'Join' || die "not Join 2: ".ki($tJ).saybl(wdump 2, tJ.C);
    tl.C.sc.pi =~ /^(bl|gee)$/ || die "not bl/gee 3: ".ki $tl;
    # tJ/tl mo.jes es littljoin
    saybl wdump 3, [map {ki $_}$tW,$tJ,$tl];
    my $jes = tJ.mo.jes;
    my $to = jes.tower;
    my @up = tl.C.t;
    while (1) {
        my $l = $up[0];
        die "if $l" if $l =~ / or /;
        my $o = $to->{$l} || die "No tower: $l ".wdump 2, jes.trowl;
        my $u = o.u || last;
        unshift @up, join(" or ", sort keys %$u);
    }
    say "Find path to tl.C.t    from: ".wdump 3, \@up;
    my $M = E.c.us.pick ||= [];
    Mn(founde=>-edr=>(join';',@up),{mean=>Jiter=>onto=>tJ.C.c.s});
    n Dug =>$E
Wjes: |
    u ReoCur
    u threJ
    u curv =>pi=><<''
        zoom 0  0.7
        y    0  0
        x    0  0
        curve 0 0.03
    
    J.VV.V = 1;
    J.ev.th ||= 'middle';
    J.ev.li ||= 'climbo';
    J.ev.bo ||= 'bodos';
    
    y.at.ux = 1;
    y.at.oWl = 1;
    y.at.ws = 1;
    y.at.hs = '893';
    y.in = 0.03;
    y.out = 6;
    J.VV.N = 1;
    y.ert = 20;
    
    Mn("w/jes"=>-Join);
threJ: | # Sav Sav
    u allvse
    # heaven's above me on a street called love
    n '','','%of:oJ'
    n J =>344,<<''
        my $ins = sub { my $J = shift; $J ne J.mo.J ? "J.mo.J.name ' J.name" : J.name };
        if (C.c.e) {
            my $new = !J.A.first;
            say $ins->(A.J)."   is elvising to  ".$ins->($J)." ($new)\n    ".ki C.c.e;
            C.c.elv = delete C.c.e if $new;
            # do over after osc (or time2 could in middle)
            # donow, may wat
            A.Iso.th = 1;
        }
        else {
            A.J eq $J && die sayre "THreJ does Celt A.J.name   ".(C.c.e && ki C.c.e);
            saybl $ins->(A.J)." can create -----> ".$ins->($J);
        }
    
    n morenothingJ =>344,<<''
        if (J.ev.amb) {
            my $ar = I.d&ar;
            Rw J.ev.amb + $J;
        }
    
    n '','','%of:th'
    # coming to a known thing, engage wave lasso
    #   vector may want to wake up itself,
    #   e could time2 in, pre-osc 7 or post-osc 76
    #   also the e could know if its an incoming list, bringing into the handler ...
    n e =>36,<<'','%rg:J'
        $J || warn "e no J";
        sayyl "E36: J.name   ontop   A.J.name   e.t";
        # no J being tricks for handulation, event energy, unless T.oke
        delete A.Iso.oJ;
        my $ar = I.d&ar;
        Rw hevt + $J;
        if (T.oke) {
            die "thoughts of a thous J.name" if A.J eq $J;
            delete A.Iso.th;
            A.Iso.oJ = 1;
            A.ztime = 6;
            return say "Tanking into J.name";
        }  
    
    # cancels proto this (threes)
    n J =>4,<<''
        return;
    
    # communication log, join proton, usually no trace of other in the self
    n e =>769,<<'','%rg:J'
        T.oke = 1; # unpin
    
    # T.oke means the vector wants to immediately handle e itself
    # or must m/osc some truth for the question, eg creating geo
    # the answer is laid along the tracks
    n '','','%of:time2'
    n elv =>5,<<'','%rg:J'
        say "Time2 do elvi! \n".ki C.c.elv;
        C.c.e = delete C.c.elv;
        my $ar = I.d&ar;
        Rw hevt + $J;
        T.oke && warn "NOTOKE time2 J.name";
        # time true, complete vector, unless we cat a list
    
    
    n '','','%of:oJ'
    n elv =>76,<<'','%rg:J'
        say "A.J.name   elv 76 (UN2d) J.name \n    ".ki C.c.elv;
        C.c.e = delete C.c.elv;
        my $ar = I.d&ar;
        J.VV.E = J.VV.V = 1;
        Rw hevt + $J;
        sayyl "Out of J.name !";
        if (T.oke) {
            die "76 thoughtself J.name" if A.J eq $J;
            say "Tanking 76 into J.name";
            Rw waited $J;
            return;
        }
        T.pos = 1 unless defined T.pos;
        T.pos &&
            Rw waito $J $C;
        sayyl "After 76 !: ".ki $T;
    
waito: | # refresh vector in a post e swarm catchup way, without e, departs call stack
    say "Comebacking J.name with C.t...";# if A.V&V;
    my $d = ar.d || 0.03;
    my $p = ar.p || 'waited';
    my $K = "ar.p ar.d J.name"; # request comp
    return sayre "trusting will $K" if J.waito->{$K};
    J.waito->{$K} = 1;
    Rw wayt + $K $d $p;
    say "Going to $K";
    
waited: | # refresh soon has returned so it cIsOn, a hicup of order clasps e noise
    ar.K && say("Back to ar.K") &&
        delete J.waito->{ar.K};
    # how much exactly... arg scuttle lots, mind moires, eddying structures
    #my $c = {%{C.c}};
    #delete c.e;
    my $c = {W=>J.name};
    my $J = G.oin;
    n c.W =>''=>{%$c,time=>6}
hevt: | # nonself sends you (the mount) (C.c.e)
    my $pin = J.ev.th || 'hopend';
    sayyl "In!to J.name  $pin";
    say "threeevent A.J.name ----> J.name !-> $pin" if A.V&E;
    # eg openevent means J opens to Trabitation for events
    Rw $pin + $J;
pi/Join: |
    C.sc.dos = 'pileJup';
    my $dir = $s;
    -d $dir || die "No $dir";
    my $p = "$dir/*";
    Mn(p=>''=>$p,'%decor,hs:388');
    J.mo.jes = $J;
    
    my $geese = sub {
        my $f = shift;
        my $way = $1 if $f =~ /.+\/(.+?)$/;
        $way || die "noqway $f";
        my $mt = (stat $f)[9];
        my $fi = $f;
        $fi =~ s/\//-/g;
        my $wf = "w/way/$way";
        my $mft = (stat $wf)[9] if -f $wf;
        $mt > $mft
    };
    
    my $li = {map{$_=>1}glob($p)};
    my @n;
    my $jf = "$dir/J";
    if (delete $li->{$jf}) {
        Rw trowil $J $s:jf;
        Mn($jf=>-gejo=>{}=>'%dis');
        
    }
    else {
        sayre "No $jf in ".wdump 2, $li;
    }
    my $wt = J.mo.jes.trowl || die "no trowl";
    
    my $tal;$tal = sub {
        my ($d,$wt) = @_;
        map {
            my $v = $wt->{$_};
            my @M;
            push @M, [$_=>''=>{s=>$_,ind=>$d}];
            push @M, $tal->($d+1, $v) if keys %$v;
            @M
        } sort keys %$wt;
    };
    my $N = [$tal->(0,$wt)];
    my $eM = [];
    Rw In $J $N $M:eM;
    
    for (@$eM) {
        my $f = "$dir/_.t";
        if (delete $li->{$f}) {
            _.sc.ml = _.c.ind * 3;
            if ($geese->($f)) {
                _.c.s = $f;
                _.c.pi = 'gee';
            }
            else {
                _.c.pi = 'bl';
            }
            _.c.idly = 1;
            _.sc.hs = '255';
        }
        else {
            _.sc.hs = '339';
        }
        _.sc.dis = 1;
    }
    
    keys %$li &&
        Mn(unc=>''=>"Uncounted: $_")
            for sort keys %$li;
    
    saybl _.c.s for @$M;
    
    Mn($eM);
    
    n o=>62=>"@",'%fs:40,blr:4';
    # and so
pi/bl: |
    n way=>1=>C.t
trowil: |
    my @li = glob "$s/*/*";
    my $tw = {};
    for my $f (@li) {
        my ($gate,$up,$way) = $f =~ /^(.+)\/J\/(.+?)\/(.+?)$/;
        $up && $way || die "nope $f";
        $tw->{$up}->{n}->{$way} = 1;
        $tw->{$way}->{u}->{$up} = 1;
    }
    my $wt = {};
    $wt->{$_} = {} for grep{!$tw->{$_}->{u}} keys %$tw;
    my @ne = $wt;
    while (@ne) {
        my @m = @ne;
        @ne = ();
        for $wt (@m) {
            for my $k (keys %$wt) {
                my $t = $tw->{$k};
                if (t.n) {
                    my $n = $wt->{$k};
                    $n->{$_} = {} for keys %{t.n};
                    push @ne, $n;
                }
                else {
                    #
                }
            }
        }
    }
    J.mo.jes.tower = $tw;
    J.mo.jes.trowl = $wt;
pi/gejo: |
    y.at.hs = '388';
    y.at.mt = '5';
    y.at.fs = '9';
    y.at.lh = '0.9em';
    y.at.geo = 'a100 0 0.1 1.2';
    n gate=>2=>"\n.\n.\n.\n.\n.\n.\nGasm: $s\n\n";
    $s =~ /\/J$/ || die "nogate: $s";
    my $wt = J.mo.jes.trowl;
    my $tal;$tal = sub {
        my ($d,$wt) = @_;
        join"\n",map{
            ind(join("",("  ") x $d), $_)
        }map {
            "$_".(!keys %{$wt->{$_}} ? "" : do {
                ":\n".$tal->($d+1, $wt->{$_});
            });
        }sort keys %$wt;
    };
    my $s = $tal->(0,$wt);
    Mn(eo=>''=>"\n$s");
    
pi/gee: |
    my ($gate,$way) = $s =~ /^(.+)\/(.+?)$/;
    $way eq C.t || die "C.t - $way mix";
    n way =>1=>C.t,'%hs:389'
    
    my $mt = (stat $s)[9];
    
    $way || die "noqway $s";
    my $wf = "w/way/$way";
    -f $wf || return
        n no=>2=>"NO $wf",'%hs:898'
    my $mft = (stat $wf)[9];
    my $mis = $mft - $mt;
    
    if ($mt > $mft) {
        n from=>2=>'way','%ml'
        n mis=>31=>"$mis",'%hs:333'
        my $tw = J.mo.jes.tower;
        my $u = $tw->{$way} || die "no topwer $way";
        
    }
    




pi/dos: |
    n sym => 1=>C.t,{hs=>844=>dos=>'dosier'}
pi/shed: |
    y.lum = 0.6;
    n what=>1=>"C.t shed: $s",'%hs:258'
    my ($j)=map{_.nj}
    Mn($s=>-yaml=>);
    
pi/yaml: |
    C.c.mtime = 1;
    y.at.serv = 'packyaml';
    y.at.osci = 1;
    Rw pi/file;
     -f $s || return
     n 404 =>2=>"404: $s",'%hs:388';
    #C.sc.nspc = 0.02;
    y.limn = 7;
    #y.lumfa = 2;
    
    Atime(2)||return saybl "\nIs J.name ico\n"; 
    
    my @l = read_file($s);
    sayyl "Reading for $s" for 1..4;
    push @l, {};
    my ($t,$s,$e,$i);
    for my $l (@l) {
        if (ref $l || $l =~ /^(\S.*): \|(.*)\n/) {
            my @new = ($1,'',$2);
            if (defined $t) {
                my $ind = $1 if $s =~ /^(\s+)\S/ || die "Noin stya: $l";
                $s =~ s/^$ind//sgm;
                my $sc;
                sc.vert = $i;
                sc.ontop = $e if length $e;
                sc.dig = slm(6, dig($s));
                Mn($t=>'pi:yam'=>{s=>$s},$sc);
            }
            ($t,$s,$e) = @new;
            $i = 0;
        }
        else {
            $l !~ /\S/ && next || die "no t aft $l" if !$t;
            $s .= $l;
            $i++;
        }
    }
pi/yam: |
    J.A.III = ['G/T/Chang'];
    C.sc.dos = 'hijack';
    
    J.mo.yam = $C;
    
    n it =>1=>C.t=>'%hs:748,fw:3'
    C.sc.hs = int(rand 9).'74';
    saybl " - -yamin C.t";
    n dig=>1=>C.sc.dig,'%hs:388'
    C.sc.ontop &&
    n also=>2=>C.sc.ontop,'%hs:864'
    #Mn(C.t=>-te=>$s);
pi/nothing: |
    C.sc.qs = 1;
Dug: |
    u ReoCur
    u threJ
    y.at.ux = 1;
    J.ev.th ||= 'middle';
    J.ev.li ||= 'indoc';
    J.UG ||= [];
    y.in = 0.1;
    y.out = 0.5;
    J.VV.N = 1;
    J.VV.V = 1;
    
    my $pi = {};
    push @{$pi->{"_.sc.mean _.sc.to"}||=[]}, $_ for @{J.UG};
    for my $k (sort keys %$pi) {
        Mn($k=>-ean=>{s=>$pi->{$k}});
    }
    sayyl wdump 3, $M;
    my $from = A.e&trJ;
    say "From: from.name from a C.c.e.t ".wdump 3, [
        A.us&_pick ,
        [From=>map{ki $_} A.e&_hJ
        ],
    ];
    n $C
 
pi/edr: |
    n for=>1=>$s
    n instr=>2=>" To C.sc.mean C.sc.onto"
pi/ean: |
    J.V = 1;
    y.close = 1;
    n ean=>1=>"Meaning: C.t"
    Mn($s);
hijack: | # yJ, the event for-er
    saybl "HERE\n\n\n";
    my $ep = E.c.hC->[-1];
    ep.sc.pi eq 'yam' || die "Dodge E: ".
        Rw talkzyh;
    E.c.yJ = Rw yJTrunk $C:ep;
    my ($hoc,$ad);
    for my $o (reverse @{E.c.yJ}) {
        sayyl "Here: - ".ki $o;
        if (o.name =~ /^2/) {
            my $rv = o.El.Duv.rv;
            my $s = "Outside: ".ki(rv.C)."\nInside: ".ki(o.C);
            push @{E.c.us.pick||=[]}, [founde=>-ckup=>$s];
            n Dug =>$E
        }
    }
    
pi/ckup: |
    n lin=>1=>"ckup: C.t"
    Mn($_->[0]=>-te=>$_->[1],'%width:42%,wb,ws')
        for map{ /^(.+?): (.+)$/ ? [$1, $2] : ["?",$_] } split "\n", $s;
pi/te: |
    C.sc.qs = 1;
    y.at.ws = '1';
    y.at.bgh = '8733';
    y.at.ma = '1em';
    n it =>1=>C.t=>'%hs:748,fw:3'
    
    my $fs = I.d&ron,(0+split("\n",$s))*(1 / 8);
    
    Mn(C.t=>''=>$s,'%wb,ws,dis,lh:1,fs:'.$fs);
    y.spc < 0.2
        ? sayyl "Wasbig: C.t: y.spc  J.C.y.spc  for ".slim 30,$s
        : sayyl "Notbig: C.t  a y.spc    J.C.y.spc";
    
    Rw Rums $J $C $M $y $spc:J.C.y.spc $I;
Rums: | # as an In osc, string ring ring
    # attach _.yy.NOISE.ytalk for tiny ysland mentalities
    @$M = map {
        my $ls = int($spc * 90);
        my $lino = J.mo.yam.sc.vert || scalar(split"\n",_.c.s);
        saybl "Have $spc * 90 = $ls      ----- $lino";
        if ($lino && $lino > $ls) {
            _.c.s =~ s/^(([^\n]*\n){$ls}).*$/$1 .../s;
            saybl "Made snip";
        }
        if ($spc < 0.2) {
            $_
        }
        elsif (_.c.s =~ /^(.+?): (.+)$/) {
            $_
        }
        elsif (_.c.s =~ /^(.+)( sc=\{ )(.+)$/s) {
            I.d&xoy,{c=>{s=>$1}},$_ ,
            [and=>''=>"AND: $2"=>'%hs:483'], 
            I.d&xoy,{c=>{s=>$3},sc=>{hs=>'287'}},$_
        }
        else {
            $_
        }
    } @$M;
    saybl "Took ".F_delta()." to spread J.name 's ".@$M;
    
AfghanRug: |
    J.A.III = ['G/T/Chang'];
    u ReoCur
    y.at.ux = 1;
    n $_,$_,$_,'%hs:389,fs:20' for 1, 3, 5, 7, 9;
    my $c;
    c.s = encode_entities("  ஓ୶");
    c.cow = 'r4b3 a3a';
    c.mixco = '0.5 582';
    
    y.in = 1;
    y.out = 9;
    Mn(d =>''=>$c=>'%ht,fs:164,hs:'.int(rand(9)).'96,sha:3 3 3 034') for 1..6;
    0 &&
    n afghanrug =>'1-9x3',$c,@{Load(fixutf8(<<''))};
          - blr: 4
            fs: 152.9
            fw: 4
            ht: 1
            sat: 1
            bri: 0.3
            con: 3
            sha: 3 3 3 034
            hs: 493
            zig: 5
    
    
    n affg =>'12-88x8'=>$c=>'%fs:73,blr:3,hs:374,ht:1,ml:4';
    # c
QuietVillage: |
    n quiet=>2=><<'','%ht'
        <video width="420" height="0" autoplay controls>
            <source src="groof/lesbaxter_quietvillage.mp3">
        </video>
    
Tarp: |
    u ReoCur
    y.at.ux = 1;
    y.at.oWl = 1;
    J.VV.N = 1;
    #
    J.tea ||= [grep{chomp}shuffle`ls -1 eye/Tarf/*/*`];
    my $pg = 'w/Tarpig';
    J.slow = readlink($pg) || 0;
    J.slow += 0.5;
    `unlink $pg` if -l $pg;
    `ln -s J.slow $pg`;
    J.slow = 0 if int(J.slow) >= @{J.tea};
    #
    y.ope = 1;
    my $f = J.tea->[int J.slow];
    n "the J.slow J.fast"=>-pape=>{s=>'mild'=>thumb=>$f};
    
    Mn(f=>''=>$f=>'%dos:flse,op:J/slow,to:1');
flse: | # fusilagery - wants about 2 seconds
    my $r = E.c.hC->[-1];
    if (r.sc.to) {
        r.sc.op || die "nop";
        my $o = I.d&pin,r.sc.op,$A;
        if (r.sc.to eq '!') {
            sayyl "! op to r.sc.op, was: ".
                I.d&pon,r.sc.op,$A,!$o;
        }
        else {
            I.d&pon,r.sc.op,$A,$o+C.sc.to;
        }
    }
    else {
        sayre "How to hold ".wdump 2, $r;
    }
    sayre "Have flse click: ".wdump 2, $r;
goche: |
    my $m = "g/c/".($n||8);
    Rw ghosch $m
pi/cde: |
    my $se = I.d&pin,$s,$A;
    #$se = wdump 3, $se;
    n row =>1 =>{idly=>1,s=>$se},'%cod:perl,dig:steve,dos:upcde'
    n row =>1=>{}=>{css=>"width:10em",ab=>1}
    C.sc.cssdel = 'transform';
    
    
upcde: |
    sayre "Upacode : C.t - E.t" for 1..4;
    
    sayre wdump 2, $C;
    Rw talkzyh;
    return;
    for (A.us&code) {
        sayyl "Writeing $_ from C.c.e.c.us";
        #I.d&pon,$s,$A,$_;
    }
putmoves: | # TODO y-move instead of remove
    u allovse
    n '','','%of:Sev'

    n Y =>31=><<'',{rg=>'J,V,yk'}
        # patch new to old where same t,s, add Vhooks
        C.y.lv = {k=>$k,C=>$C};
        C.y.at = {};
        C.y.ta = V.ta->{$k};
        C.y.vl = V.lv->{$k};
        if (C.c.root) { # / continues from 3 when everything's 6
            Y.root = $C;
            T.Z->{0.6} = 0.3;
            T.not = 1;
        }
somewhere: | # be somewhere by default
     my @path = ar.j.sc.J || ar.j.J;
     while (1) {
        my $l = $path[0];
        unshift @path, l.Jiter || last;
     }
     #saybl wdump 2, ["Gootblock:",@path];
     
     say "avoid: ".gp shift @path until !@path || $path[0] eq $J;
     shift @path;
     my $path = join '/', map{_.C.t} @path;
     
     my $A = J.A;
     my $v = G.pwin->("in/$path", $A);
     my $amo = 1.5;
     $amo = 0.8 if e.S;
     (v._.y.thy ||= 1) *= $amo;
     say "A in assign". wdump 14, [gp($J), $path, $v];
     return;
     
     #die wdump 2, [@lspath]; 
     #my $path = join '/', reverse @lspath;
     my $M = [];
     
     Mn('fro',{},"$path",'{ou:file}');
     
     Rw J5 wut $M;
Steve: |
   was h ere

