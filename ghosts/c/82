
thank: | # J, as self consuming other, s=other, !e
    # I.d&take,$s
    # does its own phasing
    say "thank J.name ! ";
    my $oJ = C.c.s;
    ref $oJ && oJ.bb || die "NoJ:".ki $oJ;
    my $so = J.oJ->{oJ.name} ||= {};
    # mong beans
    # is {M:name,W:id} coupling, so pi is {file:g/c/1} etc
    my $Y = oJ.El.Duv;
    my $rv = Y.rv;
    if (@{rv.sc}) {
        sayre "J.name SLI!P!P!ING SC !!! !!! !!!" for 1..5;
        sleep 4;
    }
    if (rv.i eq so.rv.i) {
        say "J.name receiving same oJ.name";
        return;
    }
    so.rv = $rv;
    my $N = [@{rv.c}];
    # get that banjo
    @$N = Rw humms $J $N wongui _;
    @$N = Rw humms $J $N notnotjs _;
    my $S = Rw humms $J $N jscoi;
    my $sc = [@$N];
    #sayyl "J.name from oJ.name:\n". 
    #Rw ZNews $sc $nov=1;
    # feed also cones?
    n $_ =>''=>{pi=>pane=>s=>$S->{$_}} for sort keys %$S;
    # panes
Foli: | # non driven trevil
    u allvse
    n '','','%of:J'
    n J =>6211211,<<''
        my $x = A.J.pix || J.mo.J.pix || return;
        Rw Foldout $x $J $C;
Foldout: |
        my @m = ref $x eq 'ARRAY' ? @$x : $x;
        for my $x (@m) {
            if (x.pi ? C.c.pi eq x.pi : 
                x.any ? 1 :
                0) {
                saybl "matched: J.name ::: ".ki $x;
                
                x.u &&
                u x.u
                
                C.c.pi = C.sc.pi = x.pito if x.pito;
            }
            # up!
        }
ambth: | # e,biertoho, does the 0.3 things (should do 6 and compress into 3"
    while (my ($k,$v) = each %{J.El.Pre.v->{'0.3'}}) {
        next unless v.sc.pi;
        say "J.name ambients v.sc.J.name";
        n v.t=>v.y.cv=>{pi=>v.sc.pi,s=>v.c.s}
    }
pi/sol: | # file anywhere, together
    # everything this s can get a copy of the ,,,
    y.at.oWl = 1;
    $s || die "Sol: ".wdump 2, $C;
    n Film=>$C=>{}=>'%qz'
    
Film: |
    J.ev.th ||= 'middle';
    J.ev.f.line = 'yJLong';
    # reverse trip ^
    # make otherwise so solflos, syncs panops to Follower
    # to sleep
    #J.ev.f.sol = 'SpaceFlos';
    #J.ev.opl = 'panop';
    y.ope = 1;
    map {
        saybl "_.t _.sc.J.id Tango _.c.s           _.sc.pi";
        n _.c.s=>6=>{pi=>panop=>s=>$_,},'%qs'
    } A.e&C
pi/pane: |
    #u perCcsomethingtracepha
    n $_ for map{values %$_}values %$s
    
pi/panop: |
    Rw pi/anoply;
    n Follower=>6,{W=>Follower=>e=>$C},'%qs,qz'
pi/anoply: |
    y.ope =  1;
    y.at.oWl = 1;
    $s || die "no anoply in";
    my ($t,$l) = Rw idToE;
    $t || die "anoply noi $t: ".wdump [$C,$s];
    n $t =>{}=>{}=>{opel=>sjson($l)}
    
pi/annopl: |
    y.ope = 1;
    my ($t,$l) = Rw idToE;
    n $t =>{}=>{}=>{opel=>sjson($l)}
    
Follower: | # follws E.t as file, sends lines to E.t, has panopoly of Film like things to unify changesity into therermore panoply actioney changesity
    # (everything threes)
    y.ope = 1;
    y.cvil = 1;
    y.at.oWl = 1;
    J.VV.N = 0;
    J.pix = {pi=>'lines',u=>'followlines'};
    A.jr&all,1;
    #J.VV.N = 1;
    J.ev.th ||= 'middle';
    J.ev.f.panop = 'SpaceFlos';
    J.ev.f.line = 'yJLong';
    J.ev.so = 'cfile';
    J.ev.amb = 'ambth';
    #
    n $C

linesfollow: |
    u allvse
    n '','','%of:J'
    n J =>62221,<<''
        C.c.pi eq 'lines' &&
        u followlines
    
followlines: |
    u allovse
    n '','','%of:Sev'
    
    n LinesFollow =>4431=><<'',{Td=>'V/*/new',Tdarge=>'iv,ov'}
        T.noTd = 1;
        return unless C.sc.pi eq 'line';
        return sayre "J.name Foundaou wasthere: C.c.s" if !V.rv;
        my $oJ = $J;
        $J = J.mo.J;
        .
        $C = I.d&hup,$C;
        .
        C.c.was = !Y.root.y.ta;
        # should be refering to the one and the one of the event
        saybl "J.name    Got pi line!             C.c.s   C.c.was";
        n J.C.t,$C,$oJ
        # may like to grab the element before it
        # like a curve continuing
    

