
siueon: |
    iroughoan anonate
paintaj: |
     aj.Wid || die "not Wid?";
     aj.hol = "H.style/H.name/H.id";
     aj.hitime = hitime;
     aj.name ||= aj.J.name;
thing2: |
   fow
hip_po: |
    tree-ish campus
    str i sin tko
things: |
    with suct ion
Mainiy: |
    things in 
Travel: # make somewhere bridge
   yJ: |
     'clw waz gui'
   sh: |
     Rw J5 shv $aj;
   Em: |
     Rw Emvil;
Emvil: |
     my $tw = Rw huck $J $aj */sh;
     $tw || die "nomount J.name";
      
     my $c = aj.c;
     die 'scs' if @{aj.sc};
     die 's' if aj.s;
     my $M = ['','',{W=>G.Wid},{z=>aj.c}];
     
     #sayyl wdump 15, $M if aj.J.name eq 'Vuel';
     aft {
         $@ || return;
         sayre "$@  !~!! ".wdump 35, $M;
     };
     aj.c = [" a\.om({},".sjson($M).",a,{});"];
     aj.sent = 1;
     
     Rw paintaj $aj;
     
     # route aj.W from ...
     G.Wh->{aj.Wid} ||= do {
         my $ij = {}; map {
         $ij->{$_} = $aj->{$_} if !/^[sc]+/; } keys %$aj;
         ij.id = delete ij.Wid;
         ij.y = 'W';
         
         sayyl "Life! of ij.y ij.id";
         0->tai("ij.y/ij.id\.i", $ij);
         0->tac("V/H.style/H.name/H.id\.s", ztm($ij));
         aj.J;
     };

     Rw J5 wu $aj;
     
     aj.y ||= 'J';
     aj.yy = 'W';
     Rw aji $aj;
     Rw blabaj $aj;
S/ghostchanges: |
    unless ($m =~ /\/k\//) {
        Rw loD;
        sayyl "loded";
        Rw recoded_init;
    }
S/wayup: |
    -f $m || die;
    delete G.drop; 
    $G->wayup($m);
    Rw loD;
    Rw recoded_init;
 

around: | # GONER
     inter({Jname=>ar.J.name}) if ref ar.J;
     die if !ar.J;
     if (!ar.A) {
         saybl "around -- J5 ".(ar.J ? ar.J.name : ki $ar);
         return Rw J5
     }
     die J.name unless ref G.way->{J.name} eq 'HASH';
     
     my $tw = Rw huck + */around;
     
     if (!$tw) {
        Rw up +;
        Rw out +;
     }
     
     saygr "around ! ! J.name ".F_delta()
         unless J.yt.quiet;
     
     # try return stuff? pretty aroundo
     @{(values %$tw)[0]} if $tw
makoo: | # BLAG
       sayre "to make some code? ".wdump [sort keys %$u];
       return;
       my $t = Rw wuck - $u */flows/*;
       my $fr = 0;   
       my $amp = G.ampampamp ||= do{$fr=1;{}};
       for my $k (sort keys %$t) {
           my $v = $t->{$k};
           my ($path,$flows,$from) = split '/', $k;
           
           Rw make/op $amp $pin:k $path $from;
       }
       my $hk = {%{R.way.hooks}};
       for my $z ($hk, $amp) {
           for my $k (keys %$z) {
               next unless $k =~ /^g_(.+)$/;
               say "Has $k";
               $z->{$1} = delete $z->{$k};
           }
       }
       my $x;
       x.wormhole.yr = $hk;  
       x.wormhole.ya = $amp;
       while (my ($dir, $v) = each %$x) {
           while (my ($k, $d) = each %$v) {
               my $y = YAML::Syck::Dump($d);
               die wdump $y if length $y < 50; 
               $y =~ s/^---//;
               encode_utf8 $y;
               fspu("$dir/$k\.yml", $y);
           }    
       }
       
       # maka yml, seeing .s is a gas leak
       `cd wormhole; cat yr\.yml ya\.yml > yb\.yml`;
       #$fr = 1;
       $fr ?
       $G->pub('S/'.$_, "reexec")
       :
       $G->pub('S/'.$_, "wayup w/yb\.yml") for 'shed','coast';
       sayyl "We o ".F_delta();
       
       Rwyl 0.1 J5 scr;
gui: # turn into some
     yJ: |
       'gui quigeo rondo' 
     out: |
       Rw oJ7;
rondo:
     yJ: |
       J.cv = 20;
       J.most.mody = 'mani';
       J.most.eo = 'chuv';
aww:
   yJ: |
     'clw gui heag sope waz Atime zipl Travel';
     
     
shd:
   sh: |
     Rw J5 shw $style=shv $aj;
   
floorish: |
    spun 0 -0.12
    zoom 0 1
    y    0  0.84 
    x    0  0
    curve 0 -0.4

shrad/curves: | 
       spun 0 0
       spin 0 0.2
       zoom 0 1.2 
       y    0  0.5
       x    0  0.6
       curve 0 1 
       # curve 0.4 0.4
       #spin 0.3 2
shv/curves: [EZ: cur/sjiv]
shw/curves: [EZ: cur/land]
  
cur/sjiv: |
       zoom 0 1.4
       y    0  0
       x    0  0.02
       curve 0 -0.2
       curve 0.4 0.4
       spin 0.3 2
cur/topd: |
       spun 0 0
       zoom 0 1.6
       y    0  0
       x    0  0.02
       curve 0 -0.3
cur/land: |
       spun 0 0.2
       zoom 0 1.6
       y    0.001  0.2
       x    0.001  0.9
       curve 0 -0.3 


newwave: | # THE TAKER
    saygr "EXactly";
    G.oin = Rw JJ join;
    Rw up $J:G.oin;
    
    Rw cl/tidy;
    #Rw zoybracken;
    Rwyl 0.01 fresh_init;
    1
lod/C:
   wam/on: noe 0.1 eye/o {ou:eye,blur:5px}
   fresh_init: |
     #die wdump [ G.way.ano];
     Rw J5 wa;
   recoded_init: |
     Rw fresh_init;
     #$G->pub('S/hut/K', 'do make/up')
     #   if $m =~ /\/k\//;  
lod/u:
   shv/curves: [EZ: floorish]
   wam/on: noe 0.1 g/k/1  {ou:eye,blur:5pt}
   fresh_init: Rw J5 wam;
   recoded_init: |
      rand(5) > 3 &&
      Rw J5 wam;
join:
     yJ: |
       G.oin = $J;
       'join clw rondo'
     around: |
       sayre "J.name    around:!". ki $ar;
     up: |
       # G.oin root ww:.
       Rw J5 Ha;
       Rw J5 wu;
       # iterations:
       Rw J5 toc;
     X: |
       # message goes up to wu via A
       my $oJ = J.oJ.A || die 'noway';
       Rw A/X $J:oJ $X:J;
       # to inX for the A delbbl
       Rw J5 $J $X:J;
       Rw J5 $J=J.name
       if e.S;
     inX: |
       die "dont join/inX";
toc:
     yJ: |
       'toc'
     around: |
       Rw vortex toc/up $J $d=3;
     up: | #
       # hops, rhythm aesthetics
       # things pur ambiently & incur pipes of sprawlingness into music
       # to space it out right...
       # for the mass of the atom of thought
       # wants emit with precision, figure processing/Em route into time
       # is a subscribe that catches up as %vv is join bz'd
       
       my $oJ = G.oin;
       
       #my $ip = {style=>'vv'};
       my $ip = {};
       my $timey = Rw tc $J:oJ $ip;
       my $tw = {};
       acum $tw, _.sc.vv, $_ for grep { _.sc.vv } @$timey;
       my $one = 0;
       for my $k (sort keys %$tw) {
           my $v = $tw->{$k};
           for my $C (@$v) {
               last if $one;
               $one = 1;
               sayyl "spawning C.t   C.y.cv   ".ki C.sc;
               my $sc = {map{$_=>C.sc->{$_}}grep{!/\W/}keys%{C.sc}};
               timer 0.001 {
                   oJn('','',$sc);
               };
           }
       }
Ha: # how not, T is
   yJ: |
     'Ha'
   around: |
     my $now = hitime();
     return if J.last > $now - 0.4 || G.pslagtil > $now;
     $now - J.last < 9 && Rw vortex around $J $d=5;    
     J.last = $now;
     G.ino ||= $J;
     
     my $N = Rw tc $J;
     my $lcv;
     my $i;
     for my $d (@$N) {
         my $n = d.c.s;
         
         my $com;
         my $dont;
         if (d.sc.watime) {
             my $del = d.sc.watime - hitime;
             $com = "w\@in ".sprintf('%.3f',$del);
             if ($del > 0.02) {
                 if (d.sc.watime != d.sc.watimed) {
                     # & shift out Ha 6
                     #sayyl "WAYLAY $del to n.t";
                     my $ip = {l=>d.t,cv=>d.y.cv};
                     timer $del {
                        Rw around $J;
                     };
                     J.bz->("d.t%watimed\t".d.y.cv => d.sc.watime);
                 }
                 $dont = 1;
             }
             
         }
         #my $mers = "WAITS  ".slim(10,d.t)."  n.t\t d.y.cv  $com  ".ki (1,n.c)." \t\t";#.d.sc.pict;
         #$dont ? saybl $mers : sayyl $mers;
         next if $dont;
         
         Rw hoset + $d;
         #sayyl "RE& n.t  at d.y.cv  d.sc.pict";
         
         timer 0.001 {
             Rw oo $J:G.oin $d:n;
         };
         
         $i++;
         last if $lcv && $lcv > d.y.cv;
         $lcv = d.y.cv;
     }
     
ok5: |
    my $J = C.sc.J||die;
       A.ztime = 1;
       A.note.not&csrm,'ok';
       
       my $co = A.jr&ok-$v;
       my $til = $co - hitime;
       # cv wave column to plant next self in
       A.waov = $v;
       # assume that v shapes delay until DNS of tension
       my $del = $v;
       if ($co && $til < 0) {
           sayre "running late: ". $til if $til < -0.1;
           A.ztime = $v if $v > A.ztime; # on there
           undef $co;
       }
       elsif (!$co) {
           $del = 0.1;
           sayyl "C.t begins";
       }
       $del *= 3.7;
       $del *= 1.2 if rand 5 > 3;
       $co ||= $del + hitime;
       
       A.watime = $co;
       die "yep";
       
       say "!! $til for A.ztime   ".ki C.c;
       A.jr&ok-$v,$co;
hoset: |
    my @r = map { d.t.($_?'%'.$_:'')."\t".d.y.cv } '', keys %{d.sc};
    delete J.bb->{$_} for @r;
    
hosin: |
    n.sc = ar.sc if ar.sc; n.c.s = n.s if exists n.s; n.y.cv = n.cv if n.cv;
    my @glu = map { '%'.$_ => n.sc->{$_} } sort keys %{n.sc};
    J.bz->(n.t."\t".n.y.cv => n.c.s, @glu);
comb: |
    # so that J.2 etcs declare needs and resume when ready
    my $iJ = G.ino || return do{warn "no loop";1}; # continues the Atime
    
    
    A.selif = Rw cscomp $C $ig:A.note;
    my $dig = dig A.selif;
    
    die "wamngle $wa" if $wa != int($wa) || $wa < 1 || $wa > 9;
    die 'noiJ' if !$iJ;
    
    my $n;
    n.sc.pict = A.selif;
    n.sc.watime = A.watime if A.watime;
    $wa = A.waov if A.waov;
    n.cv = $wa / 10;
    n.s = {%$C};
    n.t = $dig;
    
    sayyl "COMB J.name  C.t  A.ztime } to $wa \t ".ki 1,C.c;
    
    Rw hosin $J:iJ $n;
    0;
cscomp: |
    my $non = {%$C};
    my $de;$de = sub {
        my $v = shift;
        ref $v eq 'ARRAY' ?  [map{ $de->($_) } @$v]
        : !ref $v ? $v
        : v.id || die "no v".wdump(2,$v);
    };
    for my $k (qw'c sc') {
        my $v = $non->{$k} || next;
        $non->{$k} = $v = {%$v};
        for my $sk (keys %$v) {
            my $sv = $v->{$sk};
            $v->{$sk} = $de->($sv);
        }
    }
    non.cv = ''.non.cv;
    non.s = $de->(non.s);
    return sjson $non



Gto: | # is made, babbed
    my $G = $G;
    G.name = 'thouG';
    my $mkD = sub {
        my ($pin,$ar)=@_;
        my $D;
        D.point = $pin;
        
        if (my $C = ar.__D) {
            delete ar.__D;
            D.bab = C.c.s || die "N s".ki $C;
            D.noise .= C.sc.dige if C.sc.dige;
            if (my $ba = C.sc.bab) {
                sayyl "D.t has ".ki C.sc;
                D.babnon = $ba eq 'non' ? 1 : die "WHat is bab=$ba ?";
            }
            D.Verb = 1;
        }
        D.ar = $ar;
        D.name = join ' ', D.point, sort keys %{D.ar};
        D.sign = "Z";
        D.talk = join' ',grep{defined}map{$D->{$_}}qw'sign name noise';
        $D;
    };
    G.log = sub {
        fscc('w/glog',"\n".shift);
    };
    G.pwin = sub {
        my $point = shift;
        my $way = shift;
            return $way->{$point} if exists $way->{$point};
            my @path = split /\/|\./, $point;
            my $h = $way;
            for my $p (@path) {
                $h = $h->{$p};
                unless ($h) {
                    undef $h;
                    last;
                }
            }
            return $h if defined $h;
            
            return undef unless $point =~ /\*/;
            die "sat rs findy $point";
    };
    Rw Galso;
    Rw Ghuts;
    G.w = sub {
        my ($pin,$ar)=@_;
        my $D = $mkD->($pin,$ar);
        
        
        if (!defined D.bab) {
            D.bab = G.way->{$pin};
        }
        if (!defined D.bab) {
            if ($pin =~ /\//) {
                #say "windshot: $pin" unless $pin =~ /^pi/;
                D.bab = fwind(G.way,$pin);
            }
        }
        
        if (!defined D.bab && !ar.__D && ar.A) {
            my $c = ar.A;
            map{$c = $c->{$_} if $c} qw'J A II W 0.4';
            if ($c) {
                my $C = $c->{$pin};
                if ($C) {
                    c.sc.acgt && die "selected W4".ki$C;
                    ar.__D = $C;
                    $D = $mkD->($pin,$ar);
                }
            }
        }
        
        if (!defined D.bab) {
            die "Not findin D.talk";
            return;
        }
        G.log->(D.talk) if G.logs;
        
        my $Z = G.Doming->($D);
        G.randomtask->() if G.randomtask;
        my $r; eval { $r = [ G.D->($Z) ] };
        sayyl "D.talk BANG: $@" if $@ && !G.bangplu++;
        G.Done->($Z);
      
        if ($@) {
            die $@;
            $@ = "";
        }
        return wantarray ? @$r : $r->[0];
    };
    $G
Galso: | # Gooso goner # 
    G.d = sub {
        my $in = shift @_;
        my $y = G.d->{$in} || die "No way $in go GGG";
        $y->(@_); # to ACGT when 64
    };
    G.A = sub {
        my $am = shift;
        my $D = $F[0];
        my $r = D.ar;
        my $A = r.A || die 'GhnoA';
        my $I = A.I || die 'GhnoI';
        I.d&Other,$am;
    };
    # lifted from 64 Gooso
        my %T = %{G.T||{}};
        {
            package Wormhole;
            use Tie::Hash;
            use YAML::Syck;
            our @ISA = qw(Tie::StdHash);
            sub FETCH {
                my ($s,$k) = @_;
                return $s->{$k} if $k eq 'dir';
                $s->{$k} ||= do {
                    my $d = s.dir;
                    my $il = join('/', grep{defined} $d, $k);
                    my $f = "w/$il";
                    if (-d $f) {
                        my %Di;
                        tie %Di, 'Wormhole';
                        my $di = \%Di;
                        di.dir = $il;
                        $di
                    }
                    elsif (-f $f) {
                        print "Loading $f ...\n";
                        LoadFile($f);
                    }
                    else {
                        die "Wormhole sens nothing: $f";
                    }
                };
            }
        }
        tie %T, 'Wormhole';
        G.T = \%T;
    
    
        {
            package Ghoz; #
            use Tie::Hash;
            our @ISA = qw(Tie::ExtraHash);
            sub TIEHASH {
                my $class = shift;
                my $sto = bless [{},@_], $class;
                $sto
            }
            sub FETCH {
                my ($s,$k) = @_;
                my ($st,@o) = @$s;
                return $st->{$k} if exists $st->{$k};
                option:
                for my $o (@o) {
                    if (my $in = o.inp) {
                        my $v = o.o;
                        for my $i (@$in,$k) {
                            exists $v->{$i} || next option;
                            $v = $v->{$i};
                        }
                        return $v;
                    }
                    else {
                        die "Hwoto climb a ".G::ki $o;
                    }
                }
            }
        }
    G.tie = sub {
        my ($class,@Me) = @_;
        my %na;
        tie %na, $class, @Me;
        return \%na
    };
    
    G.comeback = sub {
        my $Dome = shift;
        
        my $a;
        a.name = 'r';
        a.from = $Dome;
        my $Doing = $G->Doming($a); 
        
        $G->D({D=>Dome.D, toplevel=>1, talk=>"351 dollars",name=>"comeback"});
        
        $G->Done($Doing);
        
        sayre $@ if $@; # TODO toplevely
        $@ = "";
    }
        
Ghuts: |
    G.sigstackend = sub {
        local $@;
        eval { confess( '' ) };
        my @stack = split m/\n/, $@;
        shift @stack for 1..2; # hide above this sub, G eval & '  at G...';
        @stack = @stack[0..20] if @stack > 24;
        my @stackend;
        push @stackend, shift @stack until $stack[0] =~ /g::ggggggg/ || !@stack;
        s/\t//g for @stackend;

        # write on the train thats about to derail
        my $wall = $F[0]->{SigDieStack}||=[];

        push @$wall, \@stackend;
    };
    G.sigstackwa = sub {
        return 1 if $_[0] =~ /^Use of uninitialized value/;
        if ($_[0] =~ /Deep recursion on/) {
           return if G.deepr++ < 9;
           G.deepr = 0;
           sayre "snoozing $F[0]->{talk}";
           snooze();
           return;
        }
        my @loc = caller(1);
        $@ = join "\n", @_;
        my $DOOF = G.Duck->($F[0],1);
        $@ = "";
        sayre $DOOF;
        exit;
        return 1;
    };
    G.Doming = sub {
        my $D = shift;
        die "More to DOming" if @_;
        $D = G.pyramid->($D);
        unshift @F, $D;
        D.F = [@F];
        return $D;
    };
    G.pyramid = sub {
        my $am = shift;
        confess "Ba" if ref $am ne 'HASH';

        my ($last) = @F;
        my $u = {%$am};
        if ($last) {
            push @{last.Lo||=[]}, $u;
            u.Li = $last;
        }
        else {
            push @{G.East||=[]}, $u;
        }
        u.G = $G;
        u.K = u.name || die "No Dome Name";
        u.hitime = hitime;
        u.order = H.pyramiding++;
        u.stack = stack(2,7);
        u.F = [@F];
        u.depth = 0+@F;
        u.Error = $@ if $@; #?

        $u
    };
    G.Done = sub {
        my $D = shift;
        sayre join"", ("BATS  ")x 23 if $F[0] ne $D;
        D.dolat = $@ if $@;
        $_->() for @{D._after_do||[]};
        shift @F;
        G.Duck->($D) if $@;
        $_->() for @{D._aft_etc_do||[]};
        $D
    };
    G.D = sub { #c
        my $D = shift;
        my $ar = D.ar || {};

        die "RECURSION ".@F if @F > $MAX_FCURSION;
        my $sub = D.D || do {
             D.Ds = G.Dm->($D);
             D.Ds.sub;
        };
        D.sign = 'D';
        D.talk = "D.sign D.name";
        $D = G.Doming->($D);
        my @return;
        if (ref $sub eq "CODE" && !$@) {
            local $SIG{__DIE__} = G.sigstackend;
            local $SIG{__WARN__} = G.sigstackwa;
            
            #sub ggggggg {eval{shift->(@_)}}
            wantarray ? 
            #do { @return = $sub->(D.ar)} # stack crawl wants to see ggggggg
            #: do { $return[0] = $sub->(D.ar)};
                do { @return = ggggggg($sub, D.ar) }
                : do { $return[0] = ggggggg($sub, D.ar) };
        }

        G.Done->($D); # Ducks
        D.r = [@return];

        return wantarray ? @return : shift @return
    };
    G.Dm = sub {
        my $am = shift;
        
        am.talk || confess wdump 2, $am;
        my $Ds = G.drop.Dscache->{am.talk};
        return $Ds if $Ds;
        
        die "SOMEONENONE".wdump 1, $am if ref am.bab;
        
        
        my $eval = am.bab;
        $eval = $G->parse_babble($eval) unless am.babnon;
        
        my $ar = am.ar || {};
         ar.R = $G;
        my $download = join("", map {
            'my$'.$_.'=$ar->{'.$_."}; "
            } keys %$ar)
            if %$ar;
        my $upload = join("", map {
            '$ar->{'.$_.'}=$'.$_."; "
            } keys %$ar)
            if %$ar;
            
        my $sub = "bollox";
        my $evs = 'sub { my $ar = shift; '.
        "$download\n".

        "my \@doo_return = (sub { \n\n$eval\n })->();\n"

        #."$upload"
        .'return @doo_return };';

        
        $sub = G.Doe->($evs, $ar);
            
        $@ = "nicht kompilieren!\n\n$@" if $@;
        
        $Ds = {evs=>$evs, sub=>$sub, talk=>am.talk};

        if (!$@ && ref $sub eq "CODE") {
            G.drop.Dscache->{am.talk} = $Ds;
        }
        else {
            am.bungeval = $evs;
        }
        $Ds
    };
    G.Doe = sub {
         my $D_eval_string = shift;
         my $ar = shift;
         return eval $D_eval_string;
    };
      
    G.Duck = sub { #c
        my $D = shift;
        my $nodie = shift;
        my $evs = D.Ds.evs;
        my $ar = D.ar;

        my $DOOF; 
        my $first = 1 unless $@ =~ /DOOF/;
                
        $DOOF .= "DOOF D.talk\n" if D.sign eq 'D' || $nodie;
        $DOOF .= "  D.inter" if D.inter;
        
        if ($first) {
            my $x = $1 if $@ =~ /syntax error .+ line (\d+), near/
                || $@ =~ /line (\d+)/;

            my $file = $1 if $@ =~ /at (\S+) line/;

            undef $file if $file && $file =~ /\(eval \d+\)/;
            undef $file if $file && !-f $file;

            my $code = $file ? 
            read_file($file)
            : $evs;
            
            my $eval = G.Duckling->($x, $code, $D);
            
            if (exists $D->{SigDieStack}) {
                warn "3MALTY SIGGI" if @{$D->{SigDieStack}} > 3;
                $DOOF .= "\n";
                my $i = "  ";
                for my $s ( reverse flatline($D->{SigDieStack}) ) {
                    $DOOF .= "$i- $s\n";
                    $i .= "  ";
                }
            }        
            $DOOF .= "\n$eval\n";
        }
        
        if ($first) {
            $DOOF .= ind("E    ", "\n$@\n\n")."\n\n";
        }
        else {
            my $in = D.sign eq 'D' ? "! " : "";
            $DOOF .= ind($in, "$@")."\n";
        }
        
        if ($first) {
            $DOOF .= ind('ar.', join "\n",
                map{
                 my $e = $ar->{$_};
                 my $s = "$e";
                 $s .= "(name=$e->{name})"
                     if ref $e && ref $e ne 'ARRAY'
                    && $e->{name};
                "$_ = ". $s;
                }keys %$ar); 
        }
        
        sayre "NO DIE? D.talk" if $nodie;
        return $DOOF if $nodie;
        
        D.Error = $DOOF;
        $@ = $DOOF;
        if (G.gbang++ > 110) {
            sayre "long explosion...\n$@";
            exit;
        }
        if (@F < 1) {
            # send it away
            $DOOF = join"\n",map{s/^(\! )+//smg if !/DOOF/; $_}split"\n",$DOOF;
            sayre $DOOF;
            exit;
            G.dooftip && G.dooftip->($@);
            $@ = "";
            $_->() for @{G._aft_err_do||[]};
        }
        else {
            die $@;
        }
    };
    G.Duckling = sub {
        my ($line, $code, $D) = @_;
        
        my $diag = "";
        my @code = split "\n", $code;
        my $whole = @code < 18;
        
        
        if (!D.Verb && $code =~ /^sub \{ my \$ar = shift/
            && $code =~ /return \@doo_return \};/) {
            $line -= 2 if $line;
            shift @code for 1..2;
            pop @code for 1..2;
        }
        
        
        my $xx = 0;
        my $lci;
        for my $c (@code) {
            $xx++;
            $lci = $1 if $xx < $line && $c =~ /^\s*(#\s*\d.*)$/;
            if (!defined $line) {
                $diag .= ind("⊘  ", $c)."\n"
            }
            elsif ($xx == $line) {
                $diag .= ind("⊘  ", $c)."\n";
                
                my $bab = (split"\n",D.bab)[$line-2];
                if ($bab ne $c) {
                    $diag .= ind("⊖r ", $bab)."\n";
                }
            }
            elsif (!$whole && $xx > $line-5 && $xx < $line+5) {
                $diag .= ind("|  ", $c)."\n"
            }
            elsif ($whole) {
                $diag .= ind("|  ", $c)."\n"
            }
        }
        
        $diag = "$diag\n#~~~$lci" if $lci && $lci !~ /^# 0.01/;
        $diag
    };
   

