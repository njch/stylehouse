Ipifalls: |
    n stopiclife=>''=><<'',{code=>"Mo 444",v=>'cpi'}
        return unless C.c.J;
        C.sc.J.A.III.Ipifalls = ['J/most/J/A/I'];
IIpifalls: |
    n stopicqlife=>''=><<'',{code=>"Mo 444",v=>'cpi'}
        return unless C.c.J;
        C.c.J.A.III.IIpifalls = ['J/most/J/A/II'];
pi3d: |
    n inlevels =>''=><<'',{code=>"Mo 3212",v=>'cpi'}
        C.c.pi && delete C.y.o.J;
        
stopi_clife: |
    n stopi_clife=>''=><<'',{code=>"Mo 32131",v=>'cpi'}
        delete C.c.J if C.sc.pi eq 'clife';
clifeGkeeps: |
    # wants to be in a humming list of the things, before thi gets figured tho
    n clifeGkeeps=>''=><<'',{code=>"Mo 212",act=>1}
        my $CC = A.J.C;
        return unless $CC && CC.c.pi eq 'cfile' && C.t eq 'z';
        my $keep = {
            'g/0/G' => qr/^(say.*|k.|hitime|unico|hex.*|.dump|mku.*|head|flatline)$/,
            'g/G/cis' => qr/^(ind|dig|snooze|acum|sli?m|.json)$/,  
            'g/G/on' => qr/^(wag|wayup|fwind)$/,
            'g/G/way' => qr/^(stack|F_delta|inter)$/,
        };
        my $r = $keep->{CC.t} || die "noyt to CC.t";
        my @not;
        my @keep = @{C.y.o.M} = grep { _.t =~ $r ? 1 :
            do{ push @not, $_; 0 }
        } @{C.y.o.M};
        saybl "CC.t keeps ".join", ",sort map{_.t} @keep;
        saygr "CC.t drops ".join", ",sort map{_.t} @not;
        return;
timery: | # capturing
    # n ^-re should mean n C.t."-re"
    n timery_re => 2 => {s=><<''},{code=>'J 42'}
        if (J.most.J eq $J) {
            # J.most.A could coord 8ish stuff. allele towerish...
            J.A.timery = {};
        }
    
    n timery_do => 7 => {s=><<''},{code=>'J 69'}
        if (my $ti = J.most.J.A.timery) {
            ti.t->{J.name} = $sol;
            $ti->{$sol}++;
            if (J.name eq 'Wkcs') {
                say "Wkcs: ". k2 {w=>{W=>$ti}};
            }
        }

