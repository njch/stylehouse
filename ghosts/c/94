
Life: | # piWJ
    u allvse
    n \'of:M'
    
    ycv 12: %def
        C.y.cv = G&ecv,$cv||0.1;
    pi 321:
        undef $pi if $pi eq '1';
        C.sc.pi = $pi||'guess';
        C.c.J = 'pi';
        C.c.p = A.J;
    W 321:
        C.c.J = $W;
        C.c.p = A.J.y.s;
    J 322:
        my $J = G&g,'J';
        C.c.J = C.sc.J = $J if $J;
    
Anthro: | # u selfing, [] acumed until thrust away
    u allvse
    n \'of:u'
    
    cs 2:
        C.c.sep = ' ';
    sep 21:
        my @b = map{{c=>{s=>$_}}} split $sep, C.c.s;
        T.Z.2 = G&ri,[@b];
        T.Z.9 = 2; # changes to 6 root.cv = V.cvs + 0.1 once 0.6
        # A must hide slither per J, u shines through
    cs 22:
        C.c.u = C.c.s;
    u 23:
        C.c.W = C.c.u;
        A.Iso.M = 1;
    
    u 7:
        # name bring
        
Geeeee: |
    u Being
    
    $A = 
    nfo:
        o
    
    $s = J.sync ||= G&S,m=>[Main=>{}];
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    # how makes, pass down to Life
Jam: |
    u allvse
    
    # time out
    J 434: %code:oJ
        $J = C.c.J = C.sc.J;
        J.name || die "WNO ".wdump 4, $C;
        # TODO: soft acuminy over \d esp. until .bb or something
        A.mo.Js->{J.name} = $J;
        # A falls
        # A.mo exits
        # J.A persists
        J.A.first ||= hitime();
        if (C.sc.W && G.oin ne $J) {
            my $lev = G.oin.A.tid;
            if (J.A.tidi && (J.A.tidi + 3) > $lev) {
                A.ztime ||= 6;
            }
            else {
                J.A.tidi = $lev;
            }
        }
        sayre "same A.J.name inside J.name" if A.J eq $J;
        if (exists C.sc.pi) {
            sayre "JiternotAJ J.Jiter.name ne A.J.name" if J.Jiter ne A.J;
            die 'pimostJ'if J.most.J eq $J;
        }
        else {
            die 'esel'.wdump [J.C, J.most.J.C] if J.most.J ne $J;
        }
        A.ztime ||= 6;
        A.time && sayre "Had atime";
        A.time = sub { # A.t& cover, serve single digit ad hocs, like 2
            my ($JJ,$q) = @_; die"JTIMEJ" if $JJ ne $J;
            A.ztime >= $q
        };
        if (C.sc.pi) {
            J.A.d = J.Jiter.A.d + 1;
            J.ind = join '  ', ('') x J.A.d;
            J.name = "J.A.d. C.c.pi*C.t";
            J.d = $C;
            A.ztime = 6 if A.ztime < 6;
        }
        J.C = $C;
        A.talk .= " J: J.name";
Ger: |
    
    Rw wayt $d=5 $p=Top;
    G.oin.A.tid += 1;
    G.t = 'Ger';
    
    n Dub
    
The: |
    n G.t
    
Or: |
    G&wraf,'proc/start',$_ 
    
    
        for "$$: perl got 4 Be pre:Sen s:Dlam";
Dlam: |
    sayyl "Sadmi Hereop $$";
    Rw iolam;
    sayyl "Sadmi Hereop $$";
    my $cb = sub { say "Dlam"; kill 'KILL', $$ };
    Rw timer $d=2 $cb;
    u urw
    
    n Tarp
    dis 3: %fs:222,hs:3293
        SSssssssSSSSSSSSSSssssssSSSSSSSSsssss
iolam: |
    G.cv ||= 3;
    G.pid ||= $$;
    my $proc = 'proc';
    my $n = "$proc/G.cv";
    `mkdir $n` if !-d $n;
    my $pid = $$;
    my $safe = sub {
        my $s = shift;
        $s =~ /^proc\/(\d+\/)?\d+\.\w+$/ || die "unsafe: $s";
        $s
    };
    my $hand;
    if (!-t STDOUT) {
        for (qw'in out err') {
            my $k = $_;
            my @o = grep{-f $_}map{"$_/G.pid\.$k"}$proc,$n;
            @o||next;
            @o<=1||die"onso@o";
            
            my $wh = /in/ ? \*STDIN : /out/ ? \*STDOUT
                : /err/ ? \*STDERR : die'whatch';
            my $i = /in/ ? '<' : '>';
            close($wh) || die "clope $_  @o: $!";
            
            # origin moves into cv also
            my $mv = G.pid == $$;
            G.pid = $$;
            my $now = $safe->("$n/G.pid\.$k");
            $mv ? map{`mv $_ $now`} grep $safe, @o
                : `touch $now`;
            
            open($wh,$i,$now) || die "bni $now: $!";
        }
    }
    say "Is G.t $pid";
    

