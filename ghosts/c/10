TestRun: |
    u allact
    
    # runs twice.. .what the hell,
    # could In it like test but u wants to be enough
    n runs =>4,<<'','%v:cJ,code:U 4'
        my $ts = J.tests ||= {};
        ts.i++;
        ok(ts.i, "Running tests ts.i of J.name");
    
    n test =>2,<<'','%v:ctest,code:Mo 2'
        my $J = A.J;
        my $ts = J.tests||die'suhpetsts';
        my $f = C.c.tfile = join '/', 't', J.name, C.t, $test;
        my $its = $ts->{$f} ||= {};
        its.i++;
        .
        its.is->{its.i} && die'alelee';
        my $st = C.c.st = its.is->{its.i} = {};
        st.exp = LoadFile(C.c.tfile) if -f C.c.tfile;
        C.c->{"test$test"} = 1;
        .
        my $min = " (ts.i)" if ts.i > 1;
        ok(its.i, "$f begins its.i$min");
    
TestTool: |
    u allacgts
    # pushed to
    n taccept =>'',<<''
        my $f = C.c.tfile;
        (my $d = $f) =~ s/\/[^\/]+$//;
        `mkdir -p $d` unless -d $d;
        my $got = C.c.st.got;
        say "Accepting for $f: ".wdump 2,$got;
        die "Ref leaky " if 
            length(wdump 4,$got) < length(wdump 5,$got);
        DumpFile($f, $got);

    n eeply =>'',<<'',{acgt=>'s,K'}
        C.c.st.got->{$K} = $s;
        my $e = C.c.st.exp->{$K};
        is_deeply($s, $e, $K);
        
    n testNews =>'',<<''
        # provide $vl for follower
        my $rv = $s;
        my $rl = {}; # pass, lives with $ids
        my $r = Rw scd $rl $rv;
        my $o = Rw ZNews sold $sc:r.oldz if r.oldz;
        my $n = Rw ZNews news $sc:r.z;
        my $stuff = $n;
        my $ids = {};
        my $here = 3;
        my $idi = 1;
        my $idstu = sub {
            my $id = shift;
            my $il = $ids->{$id} ||= $idi++;
            "il$here$il";
        };
        $stuff =~ s/(id=)(\S+)/$1.$idstu->($2)/eg;
        $stuff =~ s/(mtime=)(\d{5})(\d+)/$1.$2.join'', (('?') x length $3)/eg;
        [split "\n", encode_utf8 $stuff];
    

AutoCzech: | # check re-working
    # wants to n Tests first
    # u uns when un repeats
    u allvse
    n '','','%of:Mo'
    
    n test1 =>77,<<''
        ok(ref C.c.J, "J is alive");
        is(C.c.J, C.sc.J, "in two places");
        my $rv = C.c.J.El.Duv.rv;
        ok(ref $rv, "rv is alive");
        my $stuff = I.d&testNews,$rv;
        I.d&eeply,$stuff,$_
            for "Wheels of chaos";
        # if fails launch something to apply got -> exp or so
        I.d&taccept if C.c.tac;

    




Dwive: |
    #J.A.IIII = G.IIII = ['G/T/Remy','G/T/Eel'];
    u AutoCzech
    u TestTool
    u TestRun
    use Test::More 'no_plan';
    #n Head =>W
    n s=>''=>t
    if (!J.fsjoi) {
        #n DwightSmall =>W=>'%test:1'

        #n CarSmall =>W=>'%test:1'

        n EwokSmall =>W=>'%test:1'
    }
    else {
        n EwokSmall =>W=>'%test:2'
    }
    
    #n Gapitan =>W
    # EatDwightfully 
    # this can A.t&38 itself a ...
    # bab &38 -> if (A.t&38) {
    # A.e&sackil # A.c for C.c.e for sackil, travel got it there
    J.fsjoi++ ||
    Rw loopfourby $d=5 $p=Top;
DwightSmall: |
    J.A.IIII = [@{G.IIII},'G/T/Draw'];
    
    n s=>''=>t
    #J.V = 1;
    #J.inV = 1;
    
    #Mn($_=>''=>{pi=>ewoks=>s=>$_})
    #    for "Deliu", "Deo";
    #
    
    my $lot = "g/G/on g/G/way";# g/0/G g/G/cis";
    n shedful => '0.1-0.7', {pi=>'seas',s=>$lot}
    
CarSmall: |
    n CarSmall =>0.9=>{}=>'%Steve:was'
    my $r = J.foib++;
    $r > 0 &&
    n foib =>''=>"foib$r",'%fs:'.(30 * (($r+1) / 3))
    
    
    n sto => 2 => {pi=>'ARRAY',s=>[THing=>With=>"The $r"]}
    
    #!$r &&
    #Rw wayt $d=4 $p=Top;
    n sjei => 3 => 'Steilrofoam'
    n jury => '2-7x8' => '$(000'
    
EwokSmall: |
    n some => '',{pi=>ekwo=>s=>'sil'}
    J.runjloop++;
        
pi/ekwo: |
    Mn($_=>''=>{pi=>ewoks=>s=>$_})
        for "Deliu", "Deo";
pi/ewoks: |
    n seww => 1,{s=>'sile: '}
    J.most.J.runjloop ||
    n sewt => 2,{s=>$s}
    Mn($_=>''=>{pi=>eee=>s=>$_})
        for "Deleeeeiu", "Deeeeeo";
