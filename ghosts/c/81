
Tr: |
    u urw
    n exit=>[-dot=>0.03]
    # #
    J.VV.N = 1;
    is: %fs:25
        mostilie
    y.in = 2;
    m oooStevoooiooo=>-dlu
    m some=>-dlu
    m sonete=>-dlu
    m soy=>-dlu
    sayyl wdump 4, J.pins;
pi/dlu: |
    y.ert = 8;
    # !!! 
    y.clos = 1;
    n n=>1=>';Heft' 
    m o=>''=>C.t=>'%hs:775,ml:3'
    m t=>''=>',' for 1..(J.doofs++ + 3);
    
pi/breath: |
    Mn(@$_) for
    [Telling=>'','My troubles'],
    [To=>'','Strangers'];
trows: |
    u allact
    n UpPg
    
    n Arow =>32,<<'','%code:U,v:scJ'
        if (0) {
            G&qp,<<'';
                drop table cheese;
            G&qp,<<'';
                drop table goat;
            G&tyable,goat=><<'';
                s,ts:timestamptz,jid:serial:primary:key,jup:int
            G&tyable,cheese=><<'';
                s,ts:timestamptz,jid:int:references:goat:on:delete:cascade
        }
        my $o = {t=>C.t};
        o.jup = C.c.W ? \'is null' : do {
            my $up = J.Jiter.trow || die "No trow upin ".ki J.Jiter;
            up.jid
        };
        J.trow = G&pet,goat=>$o;
        
        J.wz = {map{_.t=> G&decj,$_ } G&qh,<<'',J.trow.jid };
            select * from cheese where jid = ?
        
        J.pich.trows = {any=>1,u=>'trows'};
    
    # grab current (just past) things we said
    n rows =>5,<<'','%code:Sev,v:yat'
        my $V = C.c.V;
        my $J = C.c.J;
        if (C.y.cv == 0.9) {
            return if delete J.lies;
            my @bu = map { V.ta->{$_} || die "No $_ on V f ".ki$C }
                C.y.k, sort keys %{at.V};
            
            G&qp,<<'',J.trow.jid;
                delete from cheese where jid = ?
            
            for (@bu) {
                if (_.sc.wassame) {
                    $_ = J.wz.>_.t || die "No _.t to same";
                }
                my ($t,$s,$c,$sc) = (_.t,_.c.s,sjson(_.c),sjson(_.sc));
                G&qp,<<'',J.trow.jid,$t,$s,$c,$sc;
                    insert into cheese (jid,t,s,c,sc) values (?,?,?,?,?)
            }
        }
    
    
    
    
    
    
    
    #
Travel: |
    my ($from,$to) = ('s','v');
    
    my $date = `ssh $from date`;
    my $dath = `ssh $to date`;
    chomp $date;
    chomp $dath;
    
    say "From $from: $date";
    saybl "Over $to:  $dath";
    `ssh $to "sudo date --set '$date'"`;
    sayyl "Done $to now: ".`ssh $to date`;
    
    return;
    # sudo -u postgres vacuumdb s
    
    # some day:
    n \ask=>\"sudo date --set '$date'";
    saybl wdump 3, u.M;
    
    # scan ISLE
    # do chobs
    
AmPg: | # U at.row=1, J.ro=$read, UG=ro.sc.M=UG or ro.M=oy.o.M
    n UpPg
    
    u allact
    n Arow =>32,<<'','%code:U,v:scJ'
        J.oy.at.row = 1;
        #G&tyable;
        if (my $r = J.ro = G&Jr ) {
            r.c = djson r.c;
            r.sc = djson r.sc;
            J.UG = r.sc.M if J.UG;
            $r
        }
    
    u allsvse
    n row =>4,<<'','%code:Art'
        return warn "Nonroot row: ".ki$C if !C.c.root;
        .
        my $M = J.UG || J.Oy.o.M;
        die "J.name TOO DEEP o M ". wdump 7, $M if G&oleak,$M,4;
        .
        #sayyl "J.name has ".wdump 3, $M;
        #sayyl "Got row on C.t: ".ki $at;
        my $r = J.ro ||= {};
        r.c ||= {};
        G&xot,r.sc||={},at.sc;
        delete r.sc.row;
        delete r.sc.z;
        r.sc.M = $M;
        my ($c,$sc) = map{sjson($_)} r.c, r.sc;
        .
        J.ro &&
            G&qp,<<'',C.t;
                delete from names where t = ?
        .
        #say " For C.t  : $sc";
        G&qp,<<'',C.t,0.3,$c,$sc
            insert into names (t,y,c,sc) values (?,?,?,?)
    
    #
UpPg: |
    u allacgts
    # not here ! ! ! !
    batik:
        $s = decode_utf8($s); # o
        `$s`
    hesl: %acgt:s c
        map{qq[$s.>$_ \n ne \n $c.>$_]}
            grep { $s.>$_ ne $c.>$_ } keys %$c;
    
    db:
        use Mojo::Pg;
        my $sJ = A.J && A.J.mo.s || die "no AJmos: A.talk";
        my $pg = sJ.A.pg ||= Mojo::Pg->new('postgresql://s@/s');
        my $mJ = A.J.mo.J || die "nomoJ";
        delete mJ.A.db if mJ.A.db.process ne $$;
        mJ.A.db ||= do {
            my $db = $pg->db;
            db.process = $$;
            $db
        };
        
    
    qp:
        G&db ->query($s,
        map{!ref && defined $_ ? decode_utf8($_) : $_ }
        @Me);
    
    tyable:
        $s ||= 'names';
        my @col = map{split','} @Me;
        push @col, 't','y real','c json','sc json';
        my $colum = join', ',map{s/:/ /g;/ /?$_:"$_ text"} @col;
        my $q = "create table if not exists $s ($colum)";
        say "Create: $q from".wdump 2, [$s,@Me] ;
        G&qp,$q
    
    qh:
        my @o;
        G&qp,$s,@Me ->hashes->map(sub{push @o,$_});
        for my $o (@o) {
            for my $k (keys %$o) {
                my $v = $o.>$k;
                $o.>$k = encode_utf8($v) if defined $v && !ref $v;
            }    
        }
        sayre "".(@o-1)." rows dropped from: @Me\n$s" if !wantarray && @o > 1;
        wantarray ? @o : $o[0]
    
    Jr:
        G&qh,<<'',$s
            select * from names where t = ?
    
    # select and then insert somewhat, osc updates it
    # with o {k=>v}, scalar ref v is sql hack
    decj:
        $s = G&hup,$s;
        $s.>$_ = djson $s.>$_ for 'c', 'sc';
        $s;
    encj:
        $s = G&hup,$s;
        $s.>$_ = sjson $s.>$_ for 'c', 'sc';
        $s;
    
    pet: %acgt:s o
        my @ks = sort keys %$o;
        my @sel;
        my $sel = "select * from $s where ".join" and ",map{
            my $z = $o.>$_;
            ref $z eq 'SCALAR' ? "$_ $$z" : do {
                push @sel, $z;
                "$_ = ?"
            };
        }@ks;
        my $n = G&qh,$sel,@sel;
        $n ||= do {
            my @ac = grep { ref $o.>$_ ne 'SCALAR' } @ks;
            my @in = map { $o.>$_ } @ac;
            my $in = "insert into $s (".join(',',@ac)
                .") values (".join(",",('?') x @ac)
                .") returning *";
            G&qh,$in,@in;
        };
        $n
    
    liz: %acgt:s J
        $s ||= C.c.W;
        $J ||= C.c.W;
        G.W.noti.>$s = $J;
        G.W.lizdb->listen($s) if G.W.lizdb;
    
    zen:
        my $m = @Me > 1 || ref $Me[0] ? sjson(\@Me) : $Me[0];
        G&db ->notify($s,$m);

        
Usee: |
    u urw
    u curv=>pi=><<''
        curve 0 0.11
    
    my @l = `find life/W -type l`;
    my $keep = {map{chomp; readlink($_) =~ /^(.+)\..+?$/; $1=>$_}@l};
    my @r = `find life/W -mtime +0.6 -type f`;
    for (@r) {
        my $k = $1 if /^life\/W\/(.+)\..+?$/;
        $keep->{$k} ?
            sayre "$k \t\tis $keep->{$k}"
          : `rm $_`;
    }
    sayyl sort keys %$keep;
    #my @el = `find life/W`;
    y.in=1;
    y.out=5;
    Mn(some=>''=>{pi=>textl=>s=>$_})
        for split"\n",wdump 2, \@l;
EYZ: |
    u urw
    u curv =>pi=><<''
        zoom 0  0.13
        y    0  0
        x    0  0
        curve 0 -0.03
    
    # eyes !
    y.limn = 0.2245;
    y.lum = 5;
    y.in = 0.04;
    y.out = 0.3;
    #Mn(shedful => '', {pi=>'eye',s=>'eye/Tarf/Photo serieses'});
    Mn(shedful => '', {pi=>'fi',s=>'eye/el'});
Details: |
    u urw
    u curv=>pi=><<''
        curve 3 -0.2
        curve 5 0.5
        zoom 2 0.6
    
    #Rw AfghanRug;
    n $_,$_,$_,'%hs:389,fs:24,ml:-2em' for 1, 3, 5, 7, 9;
    
    J.ev.th ||= 'middle';
    J.ev.li ||= 'climbos';
    
    n undivthis=>[-dos=>0.06]
    
    #n lod=>0.06 =>'fds'=>'%id:lodo,dos:goche,wi:3'
    
    Rw Code;
    
    #n Tarp
    J.act = 0; # pi always
    y.in = 0.08;
    #y.lum = 1;
    y.out = 88;
    Mn($_=>-shed=>) for 'ghosts/c/48';
    
    
    #Mn($_=>-codey=>) for @{J.CO||=[]};
    #Mn(shedful => '', {pi=>'eye',s=>'eye/fug/1/lt'});
    
    n "1$_",$_,$_,'%hs:389,fs:20' for 1, 3, 5, 7, 9;
    
    return;
AfghanRug: |
    u urw
    #u ReoCur
    #y.at.ux = 1;
    #n $_,$_,$_,'%hs:389,fs:20' for 1, 3, 5, 7, 9;
    my $c;
    c.s = enth("  ஓ୶");
    c.cow = 'r4b3 a3a';
    c.mixco = '0.5 582';
    
    n nob =>''=>{nobody=>'ux'},'%sat:7'
    
    y.in = 1;
    y.out = 9;
    Mn(d =>''=>$c=>'%ht,fs:164,hs:'.int(rand(9)).'96,sha:3 3 3 034') for 1..6;
    0 &&
    n afghanrug =>'1-9x3',$c,@{Load(fixutf8(<<''))};
          - blr: 4
            fs: 152.9
            fw: 4
            ht: 1
            sat: 1
            bri: 0.3
            con: 3
            sha: 3 3 3 034
            hs: 493
            zig: 5
    
    Rw QuietVillage;
    J.VV.N = 1;
    n affg =>'12-88x8'=>$c=>'%fs:73,blr:3,hs:374,ht:1,ml:4';
    # c
QuietVillage: |
    n quiet=>2=><<'','%ht'
        <video width="900" autoplay controls>
            <source src="art/ritimco.mp4">
        </video>
    
Tarp: |
    u urw
    #y.at.dis = 0;
    #
    for (J.slow ? 1 : (1,2,3)) {
    
    J.tea ||= [shuffle grep /^[\/\-\.\w]+jpg$/i, glob 'eye/*/*'];
    
    my $pg = 'w/Tarpig';
    J.slow = readlink($pg) || 0;
    J.slow += 0.3;
    J.slow = 0 if J.slow >= @{J.tea};
    G&dlin,w=>J.slow,'Tarpig';
    
    #
    my $f = J.tea->[1-$_ + int J.slow];
    J.fast += 1 if rand 5 > 1;
    
    n "the J.slow J.fast"=>-pape=>{s=>'mild'=>thumb=>$f};
    
    Mn(f=>''=>$f=>'%dos:flse,op:J/slow,to:1');
    
    }

