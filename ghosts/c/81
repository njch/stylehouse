
Tr: |
    u urw
    n exit=>[-dot=>0.03]
    is: %fs:20
        mostilie
    y.in = 2;
    m some=>-dlu
    m sonete=>-dlu
    m soy=>-dlu
    sayyl wdump 4, J.pins;
pi/dlu: |
    y.ert = 8;
    # !!!
    y.clos = 1;
    n n=>1=>';Heft' 
    m t=>''=>',' for 1..(J.doofs++ + 3);
    
Gonews: |
    # look at hosts->host_pins table, invents from Gohup
    
    
Pins: |
    my $pins = {};
    ###
    my $self = J.name;
    $pins->{$_}->{$self} = 1 for keys %{J.pins};
    while (my ($k,$v) = each %{J.inJ}) {
        $v eq v.mo.J || die "v.name not mo";
        v.pins || die "$k has no pins...";
        $pins->{$k}->{$k} = 1;
        $pins->{$_}->{$k} = 1 for keys %{v.pins};
    }
    my $la = J.pinla ||= {};
    my $new = [grep { !$la.>$_ } keys %$pins];
    if (@$new) {
        G.GW || return sayre "Avoid pin listening sync, no GW";
        say "pin listenings: + @$new";
        $A = G.GW.lA || die "GW no .lA :".wdump 2, G.W;
        Rw AddPins $A $J $new;
        $la.>$_ = 1 for @$new;
    }
    J.supins = $pins;
AddPins: |
    # given GW's A for UpPg, and J Oth whose id GW is listening to
    my $o;
    o.W = G.GW.at.Wid || die "No wid G_W";
    o.t = G.GW.at.Mid || die "no mid G_W";
    my $h = G&pet,$o;
    sayre "Got: ".wdump 3, $h;
    #my $c = G&tC,[AddPins=>{s=>\@new}];
    #    n GW=>$c
Goh: |
    u UpPg
    # qua     ! ! !!! ! ! !!!
    J.lA=$A=
    n GW
    J.ev.th = 'middle';
    J.ev.t.PgNotify.s = 'M';
    J.ev.f.Gup = 'Gohup';
    delete J.ev.li;
    J.lsit ||= G&liz;
    Rw waito + $d=22;
Gohup: |
    $A = J.lA||die "Need an init J.name A"; #! ! ! !!!
    my $c;
    c.t = E.t;
    c.s = E.c.s;
    $c.>$_ = E.sc.>$_ for qw'ts file dig';
    my($o) = my @m = G&qh,<<'',c.t;
        select * from gho where t = ?
    die "Many c.t: ".wdump 4,\@m if @m > 1;
    # ts was noticed time
    # tos is mtime of the paddock
    my ($ts) = map{_.ts} G&qh,<<'';
        select now() as ts
    my @s = (c.file,c.t,c.s,c.dig,$ts);
    if ($o) {
        G&qp,<<'',@s,$ts,c.t
            update gho set file=?, t=?, s=?, dig=?, ts=? where t = ?
    }
    else {
        G&qp,<<'',@s,$ts
            insert into gho (file,t,s,dig,ts) values (?,?,?,?,?)
    }
    c.ts = $ts;
    Rw Gonews $c;
    
Tray: |
    # ! !  ! ! !!
Goat: |
    n GW
    n Gosh
    J.times++ > 45 &&
        Rw exit refork;
    Rw waito + $d=4;
Gosh: |
    u trows
    J.VV.N = 1;
    y.in=y.out=0.3;
    
    my @c = map {"Ghost/c/$_"} 'ඬ', qw'11 61 43 81';
    my @z = `ls --full-time --inode @c`;
    $A=
    n sha=>1=>slm(20,dig(join"\n",@z))
    my ($sha) = @{A.M};
    if (sha.c.s eq J.wz.sha.c.s) {
        J.lies = 1;
        return saybl"Skiping same C.t: ".ki$sha;
    }
    
    for (@z) {
        s/^\s+|\s+$//sg;
        my ($ino,$mo,$qua,$use,$grp,$size,$date,$time,$tz,$file)
            = split /\s+/, $_, 11;
        $time =~ s/\.?0+$//g;
        my $o = {ts=>"$date $time $tz",ino=>$ino,size=>$size};
        my $oC = J.wz.>$file;
        $oC || say "No find $file in: ".wdump 1, J.wz;
        
        my @dif = G&hesl,oC.sc,$o;
        if (!@dif) {
            m $file=>''=>'','%wassame'
        }
        else {
            sayre "$file wasdif: ",@dif;
            m $file=>-Gosh=>$o
        }
    }
pi/Gosh: |
    y.at.>$_ = c&$_ || die "no $_ givec" for qw'ts ino size';
    y.in=y.out=0.3;
    
    #Atime(2)||return say "Same J.name";
    $A=
    n sha=>1=>(`sha1sum $s` =~ /^(\S+)/)[0]
    my ($sha) = @{A.M};
    return saybl"Skiping same C.t: ".ki$sha
        if sha.c.s eq J.wz.sha.c.s;
    
    my $file = $s;
    my $am = LoadFile($file);
    my @l = sort keys %$am;
    for (@l) {
        # should be on sev somewhere, impose new ts by s/dig change, maintain this W
        my $s = $am.>$_;
        my $wa = J.wz.>$_;
        my $dig = slm(9,dig($s));
        if ($dig ne wa.sc.dig) {
            my $c;
            c.t = $_;
            c.c.s = $s;
            c.sc.pi = 'Gup';
            (c.sc.ts) = map{_.ts} G&qh,<<'';
                select now() as ts
            c.sc.tos = J.at.ts;
            c.sc.dig = $dig;
            c.sc.file = $file;
            sayyl "Was a change: $file -> c.t";
            G&zen,Goh=>$c;
        }
        n $_=>3=>$s,{dig=>$dig}
    }
    # sev fold 3 - 
pi/breath: |
    Mn(@$_) for
    [Telling=>'','My troubles'],
    [To=>'','Strangers'];
trows: |
    u allact
    n UpPg
    
    n Arow =>32,<<'','%code:U,v:scJ'
        if (0) {
            G&qp,<<'';
                drop table cheese;
            G&qp,<<'';
                drop table goat;
            G&tyable,goat=><<'';
                s,ts:timestamptz,jid:serial:primary:key,jup:int
            G&tyable,cheese=><<'';
                s,ts:timestamptz,jid:int:references:goat:on:delete:cascade
        }
        my $o = {t=>C.t};
        o.jup = C.c.W ? \'is null' : do {
            my $up = J.Jiter.trow || die "No trow upin ".ki J.Jiter;
            up.jid
        };
        J.trow = G&pet,goat=>$o;
        
        J.wz = {map{_.t=> G&decj,$_ } G&qh,<<'',J.trow.jid };
            select * from cheese where jid = ?
        
        J.pich.trows = {any=>1,u=>'trows'};
    
    n rows =>5,<<'','%code:Sev,v:yat'
        my $V = C.c.V;
        my $J = C.c.J;
        if (C.y.cv == 0.9) {
            return if delete J.lies;
            # grab current (just past) things we said
            my @bu = map { V.ta->{$_} || die "No $_ on V f ".ki$C }
                C.y.k, sort keys %{at.V};
            
            G&qp,<<'',J.trow.jid;
                delete from cheese where jid = ?
            
            for (@bu) {
                if (_.sc.wassame) {
                    $_ = J.wz.>_.t || die "No _.t to same";
                }
                my ($t,$s,$c,$sc) = (_.t,_.c.s,sjson(_.c),sjson(_.sc));
                G&qp,<<'',J.trow.jid,$t,$s,$c,$sc;
                    insert into cheese (jid,t,s,c,sc) values (?,?,?,?,?)
            }
        }
    
    
    
    
    
    
    
    #
Travel: |
    Rw svsync;
    # scan ISLE
    # do chobs
    
Ghost: |
    u CimPg
    #u urw
    y.in=y.out=0.3;
    
    my @c = map {"Ghost/c/$_"} qw'81 85 ඬ 99';
    my @z = `ls --full-time --inode @c`;
    n sha=>1=>slm(20,dig(join"\n",@z))
    
    #Atime(2)||return do{J.V = 0; sayre "Ghostreturn"};
    
    for (@z) {
        s/^\s+|\s+$//sg;
        my ($ino,$mo,$qua,$use,$grp,$size,$date,$time,$tz,$file)
            = split /\s+/, $_, 11;
        m $file=>-Ghost=>{ts=>"$date $time $tz",ino=>$ino,size=>$size}
        J.ajkdi++ > 1 && last;
    }
pi/Ghost: |
    y.at.>$_ = c&$_ || die "no $_ givec" for qw'ts ino size';
    y.in=y.out=0.3;
    # ^ any unId or for index c, what was given
    # could do an early g&3, which swims changes along by named hops (the M^ Ans)
    # hop missing means not, how to merge at different spillover points
    n sha=>1=>(`sha1sum $s` =~ /^(\S+)/)[0]
    Atime(2)||return say "Same J.name";
    my $Y = LoadFile($s);
    my @l = sort keys %$Y;
    for (@l) {
        # should be on sev somewhere, impose new ts by s change, maintain this W
        my $s = $Y.>$_;
        my $c = {perch=>{ts=>'s'}};
        my $sc = {t=>$_,s=>$s,ts=>J.at.ts};
        G&upgok,$c,$sc;
        m $_=>''=>$s
    }
    # sev fold 3 - 
CimPg: | # C.c diff imposes C.c from Jiter
    n UpPg
    
    
    u allact
    n Arow =>32,<<'','%code:U,v:scJ'
        #J.oy.at.rows = 1;
        #G&qp,<<'';
        #     drop table if exists G;
        #G&tyable,G=>'s,ts:timestamptz';
        
    
    # to grab t:s as the {}
    u allsvse
    n rows =>4,<<'','%code:Art'
        return warn "Nonroot row: ".ki$C if !C.c.root;
        my $Y = C.c.Y;
        my $te = {map{_.t=>$_}values %{Y.tv}};
        my $ts = {map{_.t=>_.c.s}values %$te};
        my $k = te.k.c.s;
    
    # apply the {}, unless the Me says things to ignore
    u allacgts
    upgok:
        my ($c,$sc) = ($s,@Me);
        sc.t || die "Index mis: ".ki $sc;
        my $j = G&qh,<<'',sc.t;
            select * from G where t = ?
        
        my $e = $j;
        my $i = {};
        $i.>$_ = $sc.>$_ for keys %$sc;
        if (my $p = c.perch) {
            while (my ($k,$v) = each %$p) {
                # same ts is no s change, etc.
                $i.>$k = $j.>$k if $j.>$v eq $i.>$v;
                say "Wasnoch $k" if sc.t =~ /This/ && $j.>$v eq $i.>$v;
            }
        }
        return if G&heq,$j,$i;
        
        $e ? 
        G&qp,<<'',i.s,i.ts,i.t
            update g set s = ?, ts = ? where t = ?
        :
        G&qp,<<'',i.t,i.s,i.ts;
            insert into G (t,s,ts) values (?,?,?)
AmPg: | # U at.row=1, J.ro=$read, UG=ro.sc.M=UG or ro.M=oy.o.M
    n UpPg
    
    u allact
    n Arow =>32,<<'','%code:U,v:scJ'
        J.oy.at.row = 1;
        #G&tyable;
        if (my $r = J.ro = G&Jr ) {
            r.c = djson r.c;
            r.sc = djson r.sc;
            J.UG = r.sc.M if J.UG;
            $r
        }
    
    u allsvse
    n row =>4,<<'','%code:Art'
        return warn "Nonroot row: ".ki$C if !C.c.root;
        .
        my $M = J.UG || J.Oy.o.M;
        die "J.name TOO DEEP o M ". wdump 7, $M if G&oleak,$M,4;
        .
        #sayyl "J.name has ".wdump 3, $M;
        #sayyl "Got row on C.t: ".ki $at;
        my $r = J.ro ||= {};
        r.c ||= {};
        G&xot,r.sc||={},at.sc;
        delete r.sc.row;
        delete r.sc.z;
        r.sc.M = $M;
        my ($c,$sc) = map{sjson($_)} r.c, r.sc;
        .
        J.ro &&
            G&qp,<<'',C.t;
                delete from names where t = ?
        .
        #say " For C.t  : $sc";
        G&qp,<<'',C.t,0.3,$c,$sc
            insert into names (t,y,c,sc) values (?,?,?,?)
    
    #
UpPg: |
    u allacgts
    # not here ! ! ! !
    hesl: %acgt:s c
        map{qq[$s.>$_ \n ne \n $c.>$_]}
            grep { $s.>$_ ne $c.>$_ } keys %$c;
    
    db:
        use Mojo::Pg;
        my $sJ = A.J && A.J.mo.s || die "no AJmos: A.talk";
        my $pg = sJ.A.pg ||= Mojo::Pg->new('postgresql://s@/s');
        my $mJ = A.J.mo.J || die "nomoJ";
        delete mJ.A.db if mJ.A.db.process ne $$;
        mJ.A.db ||= do {
            my $db = $pg->db;
            db.process = $$;
            $db
        };
        
    
    qp:
        G&db ->query($s,@Me);
    
    tyable:
        $s ||= 'names';
        my @col = map{split','} @Me;
        push @col, 't','y real','c json','sc json';
        my $colum = join', ',map{s/:/ /g;/ /?$_:"$_ text"} @col;
        my $q = "create table if not exists $s ($colum)";
        say "Create: $q from".wdump 2, [$s,@Me] ;
        G&qp,$q
    
    qh:
        my @o;
        G&qp,$s,@Me ->hashes->map(sub{push @o,$_});
        wantarray ? @o : $o[0]
    
    Jr:
        G&qh,<<'',$s
            select * from names where t = ?
    
    # select and then insert somewhat, osc updates it
    # with o {k=>v}, scalar ref v is sql hack
    decj:
        $s = G&hup,$s;
        $s.>$_ = djson $s.>$_ for 'c', 'sc';
        $s;
    encj:
        $s = G&hup,$s;
        $s.>$_ = sjson $s.>$_ for 'c', 'sc';
        $s;
    
    pet: %acgt:s o
        my @ks = sort keys %$o;
        my @sel;
        my $sel = "select * from $s where ".join" and ",map{
            my $z = $o.>$_;
            ref $z eq 'SCALAR' ? "$_ $$z" : do {
                push @sel, $z;
                "$_ = ?"
            };
        }@ks;
        my $n = G&qh,$sel,@sel;
        $n ||= do {
            my @ac = grep { ref $o.>$_ ne 'SCALAR' } @ks;
            my @in = map { $o.>$_ } @ac;
            my $in = "insert into $s (".join(',',@ac)
                .") values (".join(",",('?') x @ac)
                .") returning *";
            G&qh,$in,@in;
        };
        $n
    
    liz: %acgt:s J
        $s ||= C.c.W;
        $J ||= C.c.W;
        G.W.noti.>$s = $J;
        G.W.lizdb->listen($s) if G.W.lizdb;
    
    zen:
        G&db ->notify($s,sjson([@Me]));

        
Usee: |
    u urw
    u curv=>pi=><<''
        curve 0 0.11
    
    my @l = `find life/W -type l`;
    my $keep = {map{chomp; readlink($_) =~ /^(.+)\..+?$/; $1=>$_}@l};
    my @r = `find life/W -mtime +0.6 -type f`;
    for (@r) {
        my $k = $1 if /^life\/W\/(.+)\..+?$/;
        $keep->{$k} ?
            sayre "$k \t\tis $keep->{$k}"
          : `rm $_`;
    }
    sayyl sort keys %$keep;
    #my @el = `find life/W`;
    y.in=1;
    y.out=5;
    Mn(some=>''=>{pi=>textl=>s=>$_})
        for split"\n",wdump 2, \@l;
EYZ: |
    u urw
    u curv =>pi=><<''
        zoom 0  0.13
        y    0  0
        x    0  0
        curve 0 -0.03
    
    # eyes !
    y.limn = 0.2245;
    y.lum = 5;
    y.in = 0.04;
    y.out = 0.3;
    #Mn(shedful => '', {pi=>'eye',s=>'eye/Tarf/Photo serieses'});
    Mn(shedful => '', {pi=>'fi',s=>'eye/el'});
Details: |
    u urw
    u curv=>pi=><<''
        curve 3 -0.2
        curve 5 0.5
        zoom 2 0.6
    
    #Rw AfghanRug;
    n $_,$_,$_,'%hs:389,fs:24,ml:-2em' for 1, 3, 5, 7, 9;
    
    J.ev.th ||= 'middle';
    J.ev.li ||= 'climbos';
    
    n undivthis=>[-dos=>0.06]
    
    #n lod=>0.06 =>'fds'=>'%id:lodo,dos:goche,wi:3'
    
    Rw Code;
    
    #n Tarp
    J.act = 0; # pi always
    y.in = 0.08;
    #y.lum = 1;
    y.out = 88;
    Mn($_=>-shed=>) for 'ghosts/c/48';
    
    
    #Mn($_=>-codey=>) for @{J.CO||=[]};
    #Mn(shedful => '', {pi=>'eye',s=>'eye/fug/1/lt'});
    
    n "1$_",$_,$_,'%hs:389,fs:20' for 1, 3, 5, 7, 9;
    
    return;
AfghanRug: |
    u urw
    #u ReoCur
    #y.at.ux = 1;
    #n $_,$_,$_,'%hs:389,fs:20' for 1, 3, 5, 7, 9;
    my $c;
    c.s = enth("  ஓ୶");
    c.cow = 'r4b3 a3a';
    c.mixco = '0.5 582';
    
    n nob =>''=>{nobody=>'ux'},'%sat:7'
    
    y.in = 1;
    y.out = 9;
    Mn(d =>''=>$c=>'%ht,fs:164,hs:'.int(rand(9)).'96,sha:3 3 3 034') for 1..6;
    0 &&
    n afghanrug =>'1-9x3',$c,@{Load(fixutf8(<<''))};
          - blr: 4
            fs: 152.9
            fw: 4
            ht: 1
            sat: 1
            bri: 0.3
            con: 3
            sha: 3 3 3 034
            hs: 493
            zig: 5
    
    Rw QuietVillage;
    J.VV.N = 1;
    n affg =>'12-88x8'=>$c=>'%fs:73,blr:3,hs:374,ht:1,ml:4';
    # c
QuietVillage: |
    n quiet=>2=><<'','%ht'
        <video width="900" autoplay controls>
            <source src="art/ritimco.mp4">
        </video>
    
Tarp: |
    u urw
    #y.at.dis = 0;
    #
    for (J.slow ? 1 : (1,2,3)) {
    
    J.tea ||= [shuffle grep /^[\/\-\.\w]+jpg$/i, glob 'eye/*/*'];
    
    my $pg = 'w/Tarpig';
    J.slow = readlink($pg) || 0;
    J.slow += 0.3;
    J.slow = 0 if J.slow >= @{J.tea};
    G&dlin,w=>J.slow,'Tarpig';
    
    #
    my $f = J.tea->[1-$_ + int J.slow];
    J.fast += 1 if rand 5 > 1;
    
    n "the J.slow J.fast"=>-pape=>{s=>'mild'=>thumb=>$f};
    
    Mn(f=>''=>$f=>'%dos:flse,op:J/slow,to:1');
    
    }

