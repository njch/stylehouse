
Tr: |
    u urw
    n exit=>[-dot=>0.03]
    
    is: %fs:20
        mostily
    y.in = 2;
    
    
    J.VV.N = 1;
    m some=>-dlu
    m sonete=>-dlu
    m soy=>-dlu
Goat: |
    #u urw
    u trows
    J.VV.N = 1;
    
    whitehorse 6:
        Blaga!
    
    n breath=>pi
    
Gosh: |
    u trows
    J.VV.N = 1;
    #u urw
    y.in=y.out=0.3;
    
    my @c = map {"Ghost/c/$_"} 'ඬ', qw'11 61 43';
    my @z = `ls --full-time --inode @c`;
    my ($sha) = map{@{_.M}}
    n sha=>1=>slm(20,dig(join"\n",@z))
    #return
    saybl"-----------\nSkiping same C.t: ".ki$sha
        if sha.c.s eq J.wz.sha.c.s;
    
    #Atime(2)||return do{J.V = 0; sayre "Ghostreturn"};
    saybl wdump 3, J.wz;
    for (@z) {
        s/^\s+|\s+$//sg;
        my ($ino,$mo,$qua,$use,$grp,$size,$date,$time,$tz,$file)
            = split /\s+/, $_, 11;
        my $o = {ts=>"$date $time $tz",ino=>$ino,size=>$size};
        saybl "Wasl $file: ".wdump 3, J.wz.>$file ;
        m $file=>-Gosh=>$o
    }
pi/Gosh: |
    y.at.>$_ = c&$_ || die "no $_ givec" for qw'ts ino size';
    y.in=y.out=0.3;
    # ^ any unId or for index c, what was given
    # could do an early g&3, which swims changes along by named hops (the M^ Ans)
    # hop missing means not, how to merge at different spillover points
    my ($sha) = map{@{_.M}}
    n sha=>1=>(`sha1sum $s` =~ /^(\S+)/)[0]
    return saybl"-----------\nSkiping same C.t: ".ki$sha
        if sha.c.s eq J.wz.sha.c.s;
    
    #Atime(2)||return say "Same J.name";
    
    my $Y = LoadFile($s);
    my @l = sort keys %$Y;
    for (@l) {
        # should be on sev somewhere, impose new ts by s change, maintain this W
        my $s = $Y.>$_;
        my $c = {perch=>{ts=>'s'}};
        my $sc = {t=>$_,s=>$s,ts=>J.at.ts};
        #G&upgok,$c,$sc;
        m $_=>''=>$s,{dig=>slm(9,dig($s))}
    }
    # sev fold 3 - 
pi/breath: |
    Mn(@$_) for
    [Telling=>'','My troubles'],
    [To=>'','Strangers'];
trows: |
    u allact
    n UpPg
    
    n Arow =>32,<<'','%code:U,v:scJ'
        if (0) {
            G&qp,<<'';
                drop table cheese;
            G&qp,<<'';
                drop table goat;
            G&tyable,goat=><<'';
                s,ts:timestamptz,jid:serial:primary:key,jup:int
            G&tyable,cheese=><<'';
                s,ts:timestamptz,jid:int:references:goat:on:delete:cascade
        }
        sayre "C.t  ----- C.c.W or C.c.pi";
        my $o = {t=>C.t};
        o.jup = C.c.W ? \'is null' : do {
            my $up = J.Jiter.trow || die "No trow upin ".ki J.Jiter;
            up.jid
        };
        #J.trow = G&pet,goat=>{t=>C.c.W
        my $m;
        if (C.c.W) {
            J.trow = G&qh,<<'',C.c.W;
                select * from goat where t = ? and jup is null
            
            J.trow ||= do{$m=1} && G&qh,<<'',C.c.W;
                insert into goat (t) values (?) returning *
            
        }
        else {
            my $up = J.Jiter.trow || die "No trow upin ".ki J.Jiter;
            
            J.trow = G&qh,<<'',C.t,up.jid;
                select * from goat where t = ? and jup = ?
            
            J.trow ||= do{$m=1} && G&qh,<<'',C.t,up.jid;
                insert into goat (t,jup) values (?,?) returning *
            
        }
        sayre(($m&&"MADE  ")." the C.t: ".sjson(J.trow));
        J.wz = {map{_.t=>$_} G&qh,<<'',J.trow.jid };
            select * from cheese where jid = ?
        for (values %{J.wz}) {
            _.c = djson(_.c);
            _.sc = djson(_.sc);
        }
        J.pich.trows = {any=>1,u=>'trows'};
    
    n rows =>5,<<'','%code:Sev,v:yat'
        my $V = C.c.V;
        my $J = C.c.J;
        if (C.y.cv == 0.9) {
            # grab current (just past) things we said
            my @bu = map { V.ta->{$_} || die "No $_ on V f ".ki$C }
                C.y.k, sort keys %{at.V};
            
            G&qp,<<'',J.trow.jid;
                delete from cheese where jid = ?
            
            for (@bu) {
                my ($t,$s,$c,$sc) = (_.t,_.c.s,sjson(_.c),sjson(_.sc));
                G&qp,<<'',J.trow.jid,$t,$s,$c,$sc;
                    insert into cheese (jid,t,s,c,sc) values (?,?,?,?,?)
            }
            #sayre "the: ".wdump 3, J.wz;
            #G&qh,<<'',J.trow.jid;
        #        select * from cheese where jid = ?
            
        }
    
    
    
    
    
    
    
    #
pi/dlu: |
    y.ert = 8;
    y.clos = 1;
    n n=>1=>';Heft'
    m t=>''=>',' for 1..(J.doofs++ + 3);
    
Travel: |
    Rw svsync;
    # scan ISLE
    # do chobs
    
Ghost: |
    u CimPg
    #u urw
    y.in=y.out=0.3;
    
    my @c = map {"Ghost/c/$_"} qw'81 85 ඬ 99';
    my @z = `ls --full-time --inode @c`;
    n sha=>1=>slm(20,dig(join"\n",@z))
    
    #Atime(2)||return do{J.V = 0; sayre "Ghostreturn"};
    
    for (@z) {
        s/^\s+|\s+$//sg;
        my ($ino,$mo,$qua,$use,$grp,$size,$date,$time,$tz,$file)
            = split /\s+/, $_, 11;
        m $file=>-Ghost=>{ts=>"$date $time $tz",ino=>$ino,size=>$size}
        J.ajkdi++ > 1 && last;
    }
pi/Ghost: |
    y.at.>$_ = c&$_ || die "no $_ givec" for qw'ts ino size';
    y.in=y.out=0.3;
    # ^ any unId or for index c, what was given
    # could do an early g&3, which swims changes along by named hops (the M^ Ans)
    # hop missing means not, how to merge at different spillover points
    n sha=>1=>(`sha1sum $s` =~ /^(\S+)/)[0]
    Atime(2)||return say "Same J.name";
    my $Y = LoadFile($s);
    my @l = sort keys %$Y;
    for (@l) {
        # should be on sev somewhere, impose new ts by s change, maintain this W
        my $s = $Y.>$_;
        my $c = {perch=>{ts=>'s'}};
        my $sc = {t=>$_,s=>$s,ts=>J.at.ts};
        G&upgok,$c,$sc;
        m $_=>''=>$s
    }
    # sev fold 3 - 
CimPg: | # C.c diff imposes C.c from Jiter
    n UpPg
    
    
    u allact
    n Arow =>32,<<'','%code:U,v:scJ'
        #J.oy.at.rows = 1;
        #G&qp,<<'';
        #     drop table if exists G;
        #G&tyable,G=>'s,ts:timestamptz';
        
    
    # to grab t:s as the {}
    u allsvse
    n rows =>4,<<'','%code:Art'
        return warn "Nonroot row: ".ki$C if !C.c.root;
        my $Y = C.c.Y;
        my $te = {map{_.t=>$_}values %{Y.tv}};
        my $ts = {map{_.t=>_.c.s}values %$te};
        my $k = te.k.c.s;
    
    # apply the {}, unless the Me says things to ignore
    u allacgts
    upgok:
        my ($c,$sc) = ($s,@Me);
        sc.t || die "Index mis: ".ki $sc;
        my $j = G&qh,<<'',sc.t;
            select * from G where t = ?
        
        my $e = $j;
        my $i = {};
        $i.>$_ = $sc.>$_ for keys %$sc;
        if (my $p = c.perch) {
            while (my ($k,$v) = each %$p) {
                # same ts is no s change, etc.
                $i.>$k = $j.>$k if $j.>$v eq $i.>$v;
                say "Wasnoch $k" if sc.t =~ /This/ && $j.>$v eq $i.>$v;
            }
        }
        return if G&heq,$j,$i;
        
        $e ? 
        G&qp,<<'',i.s,i.ts,i.t
            update g set s = ?, ts = ? where t = ?
        :
        G&qp,<<'',i.t,i.s,i.ts;
            insert into G (t,s,ts) values (?,?,?)
AmPg: | # U at.row=1, J.ro=$read, UG=ro.sc.M=UG or ro.M=oy.o.M
    n UpPg
    
    u allact
    n Arow =>32,<<'','%code:U,v:scJ'
        J.oy.at.row = 1;
        #G&tyable;
        if (my $r = J.ro = G&Jr ) {
            r.c = djson r.c;
            r.sc = djson r.sc;
            J.UG = r.sc.M if J.UG;
            $r
        }
    
    u allsvse
    n row =>4,<<'','%code:Art'
        return warn "Nonroot row: ".ki$C if !C.c.root;
        .
        my $M = J.UG || J.Oy.o.M;
        die "J.name TOO DEEP o M ". wdump 7, $M if G&oleak,$M,4;
        .
        #sayyl "J.name has ".wdump 3, $M;
        #sayyl "Got row on C.t: ".ki $at;
        my $r = J.ro ||= {};
        r.c ||= {};
        G&xot,r.sc||={},at.sc;
        delete r.sc.row;
        delete r.sc.z;
        r.sc.M = $M;
        my ($c,$sc) = map{sjson($_)} r.c, r.sc;
        .
        J.ro &&
            G&qp,<<'',C.t;
                delete from names where t = ?
        .
        #say " For C.t  : $sc";
        G&qp,<<'',C.t,0.3,$c,$sc
            insert into names (t,y,c,sc) values (?,?,?,?)
    
    #
UpPg: |
    u allacgts
    n db =>'',<<''
        use Mojo::Pg;
        my $sJ = A.J && A.J.mo.s || die "no AJmos: A.talk";
        my $pg = sJ.A.pg ||= Mojo::Pg->new('postgresql://s@/s');
        my $mJ = A.J.mo.J || die "nomoJ";
        delete mJ.A.db if mJ.A.db.process ne $$;
        mJ.A.db ||= do {
            my $db = $pg->db;
            db.process = $$;
            $db
        };
    
    n qp =>'',<<''
        G&db ->query($s,@Me);
    
    n tyable =>'',<<''
        $s ||= 'names';
        my @col = map{split','} @Me;
        push @col, 't','y real','c json','sc json';
        my $colum = join', ',map{s/:/ /g;/ /?$_:"$_ text"} @col;
        my $q = "create table if not exists $s ($colum)";
        say "Create: $q from".wdump 2, [$s,@Me] ;
        G&qp,$q
    
    n qh =>'',<<''
        my @o;
        G&qp,$s,@Me ->hashes->map(sub{push @o,$_});
        wantarray ? @o : $o[0]
    
    n Jr =>'',<<''
        G&qh,<<'',$s
            select * from names where t = ?
    
Usee: |
    u urw
    u curv=>pi=><<''
        curve 0 0.11
    
    my @l = `find life/W -type l`;
    my $keep = {map{chomp; readlink($_) =~ /^(.+)\..+?$/; $1=>$_}@l};
    my @r = `find life/W -mtime +0.6 -type f`;
    for (@r) {
        my $k = $1 if /^life\/W\/(.+)\..+?$/;
        $keep->{$k} ?
            sayre "$k \t\tis $keep->{$k}"
          : `rm $_`;
    }
    sayyl sort keys %$keep;
    #my @el = `find life/W`;
    y.in=1;
    y.out=5;
    Mn(some=>''=>{pi=>textl=>s=>$_})
        for split"\n",wdump 2, \@l;
EYZ: |
    u urw
    u curv =>pi=><<''
        zoom 0  0.13
        y    0  0
        x    0  0
        curve 0 -0.03
    
    # eyes !
    y.limn = 0.2245;
    y.lum = 5;
    y.in = 0.04;
    y.out = 0.3;
    #Mn(shedful => '', {pi=>'eye',s=>'eye/Tarf/Photo serieses'});
    Mn(shedful => '', {pi=>'fi',s=>'eye/el'});
Details: |
    u urw
    u curv=>pi=><<''
        curve 3 -0.2
        zoom 2 0.6
    
    #Rw AfghanRug;
    n $_,$_,$_,'%hs:389,fs:24,ml:-2em' for 1, 3, 5, 7, 9;
    
    J.ev.th ||= 'middle';
    J.ev.li ||= 'climbos';
    
    n undivthis=>[-dos=>0.06]
    
    #n lod=>0.06 =>'fds'=>'%id:lodo,dos:goche,wi:3'
    
    Rw Code;
    
    #n Tarp
    J.act = 0; # pi always
    y.in = 0.08;
    #y.lum = 1;
    y.out = 88;
    Mn($_=>-shed=>) for 'ghosts/c/48';
    
    
    #Mn($_=>-codey=>) for @{J.CO||=[]};
    #Mn(shedful => '', {pi=>'eye',s=>'eye/fug/1/lt'});
    
    n "1$_",$_,$_,'%hs:389,fs:20' for 1, 3, 5, 7, 9;
    
    return;
AfghanRug: |
    u urw
    #u ReoCur
    #y.at.ux = 1;
    #n $_,$_,$_,'%hs:389,fs:20' for 1, 3, 5, 7, 9;
    my $c;
    c.s = enth("  ஓ୶");
    c.cow = 'r4b3 a3a';
    c.mixco = '0.5 582';
    
    n nob =>''=>{nobody=>'ux'},'%sat:7'
    
    y.in = 1;
    y.out = 9;
    Mn(d =>''=>$c=>'%ht,fs:164,hs:'.int(rand(9)).'96,sha:3 3 3 034') for 1..6;
    0 &&
    n afghanrug =>'1-9x3',$c,@{Load(fixutf8(<<''))};
          - blr: 4
            fs: 152.9
            fw: 4
            ht: 1
            sat: 1
            bri: 0.3
            con: 3
            sha: 3 3 3 034
            hs: 493
            zig: 5
    
    Rw QuietVillage;
    J.VV.N = 1;
    n affg =>'12-88x8'=>$c=>'%fs:73,blr:3,hs:374,ht:1,ml:4';
    # c
QuietVillage: |
    n quiet=>2=><<'','%ht'
        <video width="900" autoplay controls>
            <source src="art/ritimco.mp4">
        </video>
    
Tarp: |
    u urw
    #y.at.dis = 0;
    #
    for (J.slow ? 1 : (1,2,3)) {
    
    J.tea ||= [shuffle grep /^[\/\-\.\w]+jpg$/i, glob 'eye/*/*'];
    
    my $pg = 'w/Tarpig';
    J.slow = readlink($pg) || 0;
    J.slow += 0.3;
    J.slow = 0 if J.slow >= @{J.tea};
    G&dlin,w=>J.slow,'Tarpig';
    
    #
    my $f = J.tea->[1-$_ + int J.slow];
    J.fast += 1 if rand 5 > 1;
    
    n "the J.slow J.fast"=>-pape=>{s=>'mild'=>thumb=>$f};
    
    Mn(f=>''=>$f=>'%dos:flse,op:J/slow,to:1');
    
    }

