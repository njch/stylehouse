
Seem: |
    J.ttl ||= 10;
    --J.ttl || return;
    Rw loopby $b=3 $d=5 $p=Top;
    n Dub
Beep: |
    use Term::ReadLine;
    my $term = Term::ReadLine->new('Simple Perl calc');
    my $prompt = "Enter your arithmetic expression: ";
    while ( defined (my $s = $term->readline($prompt)) ) {
        my $res = eval G&parse_babbl,$s;
        sayre $@ if $@;
        say $res unless $@;
        $@ = "" if $@;
        $term->addhistory($_) if /\S/;
    }
    sayre "Over";
Ble: |
    u urw
    n G=>1=>"G.t G.cv ".ki(G.c)."       ".ki(G.sc),'%ws'
    
    n temp=>[-sensors=>12]
    n Is=>[-pre=>2]=>wdump 3, [J.A.Ii, J.A.III, J.A.IIII]
    
    sayyl "Y\n\n\n\n\n";
    
    n So
    
    
    # fork to , runtimes
    J.times||=10;
    J.times-- > 2 &&
    do {for (qw'4.12 4.15 4.2') {
        say "Loopang $_ fior J.times";
        Rw wayt $d=$_ $p=Top times J.times ing$_;
    }};
God: |
    u Doop
    
    
    n Ghost
    
Doop: |
    u allvse
    n \'%of:J'
    
    # use less -
    J 63342:
        sayre "Here is J! ".ki $C;
Travel: |
    my @hosts = qw'v s';
    my $here = $1 if `hostname` =~ /^(\S+)/;
    $here || die "no hre: ".`hostname`;
    my ($there) = grep {$_ ne $here} @hosts;
    my $date = `ssh $there date`;
    chomp $date;
    say "Their: $date";
    saybl "Over:  ".`date`;
    `sudo date --set '$date'`;
    
    # T type explains how things joined, what the target is
    # G pulls live T for you, G origins vs G wanderers
    #   u for example is w/u/J,etc
    #   w is w/way/$
    # W is a T membrane for the spheres
    # 
    # theres a travel to connect the way you run back to the origins
    # by spiralling W backchannel, like isle
    # the T Cs 
    # G              W
    # 
    
    
    
    
    
    
    
    
    
    
    
    
    # T leans to 
Ghost: |
    u CimPg
    #u urw
    y.in=y.out=0.3;
    my @c = map {"Ghost/c/$_"} qw'81 85 ඬ 99';
    my @z = `ls --full-time --inode @c`;
    n sha=>1=>slm(20,dig(join"\n",@z))
    #Atime(2)||return do{J.V = 0; sayre "Ghostreturn"};
    for (@z) {
        s/^\s+|\s+$//sg;
        my ($ino,$mo,$qua,$use,$grp,$size,$date,$time,$tz,$file)
            = split /\s+/, $_, 11;
        m $file=>-Ghost=>{ts=>"$date $time $tz",ino=>$ino,size=>$size}
        J.ajkdi++ > 1 && last;
    }
pi/Ghost: |
    y.at.>$_ = c&$_ || die "no $_ givec" for qw'ts ino size';
    y.in=y.out=0.3;
    # ^ any unId or for index c, what was given
    # could do an early g&3, which swims changes along by named hops (the M^ Ans)
    # hop missing means not, how to merge at different spillover points
    n sha=>1=>(`sha1sum $s` =~ /^(\S+)/)[0]
    Atime(2)||return say "Same J.name";
    my $Y = LoadFile($s);
    my @l = sort keys %$Y;
    for (@l) {
        # should be on sev somewhere, impose new ts by s change, maintain this W
        my $s = $Y.>$_;
        my $c = {perch=>{ts=>'s'}};
        my $sc = {t=>$_,s=>$s,ts=>J.at.ts};
        G&upgok,$c,$sc;
        m $_=>''=>$s
    }
    # sev fold 3 - 
CimPg: | # C.c diff imposes C.c from Jiter
    n UpPg
    
    
    u allact
    n Arow =>32,<<'','%code:U,v:scJ'
        #J.oy.at.rows = 1;
        #G&qp,<<'';
        #     drop table if exists G;
        #G&tyable,G=>'s,ts:timestamptz';
        
    
    # to grab t:s as the {}
    u allsvse
    n rows =>4,<<'','%code:Art'
        return warn "Nonroot row: ".ki$C if !C.c.root;
        my $Y = C.c.Y;
        my $te = {map{_.t=>$_}values %{Y.tv}};
        my $ts = {map{_.t=>_.c.s}values %$te};
        my $k = te.k.c.s;
    
    # apply the {}, unless the Me says things to ignore
    u allacgts
    upgok:
        my ($c,$sc) = ($s,@Me);
        sc.t || die "Index mis: ".ki $sc;
        my $j = G&qh,<<'',sc.t;
            select * from G where t = ?
        
        my $e = $j;
        my $i = {};
        $i.>$_ = $sc.>$_ for keys %$sc;
        if (my $p = c.perch) {
            while (my ($k,$v) = each %$p) {
                # same ts is no s change, etc.
                $i.>$k = $j.>$k if $j.>$v eq $i.>$v;
                say "Wasnoch $k" if sc.t =~ /This/ && $j.>$v eq $i.>$v;
            }
        }
        return if G&heq,$j,$i;
        
        $e ? 
        G&qp,<<'',i.s,i.ts,i.t
            update g set s = ?, ts = ? where t = ?
        :
        G&qp,<<'',i.t,i.s,i.ts;
            insert into G (t,s,ts) values (?,?,?)
    
    #
Torp: |
    u urw
    y.ert = 7;
    m uyp=>-uptime
    m uyeo=>'',$$
    m fi=>'','D','%hs:384,fs:55' for 1..(J.tioes++ + 3);
    
    
        
    #n if=>4=>{
    J.VV.N = 1;
pi/uptime: |
    my ($l) = reverse split ': ', `uptime`;
    n uptime=>2=>$l
pi/sensors: |
    y.at.ws = 1;
    J.diel += 0.4;
    n diel =>1=>"D ".int(J.diel)
    Atime(2) || return;
    my $com = "sensors";
    $com = "ssh v '$com'" if `hostname` !~ /v/;
    my @l = `$com`;
    my @k = qw'pi co no';
    @l = grep{$_} map{/^(Core 0|temp1):\s+(\S+)/ && $2} @l;
    s/^.*?(\d+).*$/$1/ for @l;
    $_ = shift(@k).": $_   " for @l;
    m yolt=>'',$_ for @l;
    
drid: |
    # major is tid > 3 + lastid, Oth can partition arms into the tide
Swell: |
    u urw
    
    J.fire ||= 88;
    sayyl "zeplot         \n\n\n";
    J.fire += 14;
    n Fun=>'1-8x1','Fun','%hs:684,blr:14,fs:'.(J.fire * (1+rand(2)));
Sen: |
    #u urw
    u UpPg;
    #u SpaceWatch
    y.in = 0.02;
    y.out = 0.5;
    y.at.sca = 0.3;
    $A = 
    s:
        1
    
    G.Jsem = sub {
        my $em = shift;
        my $db = G&db;
        $em = {lines=>[$em]} if !ref $em;
        $db->notify('Js',decode_utf8(join"\n",@{em.lines}));
    };
    my $U = J.A.II.U;
    #Mn(eso=>-hush=>{s=>$U});
    
    #n and=>-jsthink
    
    #n oe=>'01-77x14','#','%hs:388,fs:99,blr:5,ig:3'
    #J.VV.N = 1;
Dub: |
    u urw
    u AmPg
    
    Rw Code;
    Atime(2);
    
    Mn($_) for @{J.ro.sc.M||[]};
    Mn("Tst"=>''=>":D");
    
    n hihi=>-alink=>"http://localhost:10094/lowcal\.html"
    
    J.VV.N = 1;
    my $j = G&A,'S';
    n Rec=>$C
pi/alink: |
    n link =>''=>C.t=>{tag=>'a',atr=>'href',href=>$s};
    
Rec: | # batchy you, web
    #u urw
    u Sugd
    u AmPg
    J.ev.o = 'SpaceFlos';
    J.ev.opl = 'fiew';
    
    Atime(2);
    
    n s=>''=>t
    
    for ( e&C ) {
        sayyl "Rec receives : ".ki $_;
    }
Code: |
    G.edit ||= 'G/way/Code';
    n edit=>0.02=>'@'=>'%id:edat,dos:flse,op:J/se/cod,to:!'
    J.se.cod &&
    n 'G/edit'=>[-cde=>'1-2']
    J.se.cod &&
    n G.edit=>[-cde=>'2-6']
    y.at.cssdel = 'transform';
    #n time =>[-timem=>'1-9x'.int rand 13]=>''.`date`
    
CodeMirror: |
    # do in iframe
    n Headstuff=>2=><<''
        <script src="../lib/codemirror.js"></script>
        <script src="../mode/xml/xml.js"></script>
        <script src="../addon/dialog/dialog.js"></script>
        <script src="../addon/search/searchcursor.js"></script>
        <script src="../addon/search/search.js"></script>
        <style type="text/css">
              .CodeMirror {border-top: 1px solid black; border-bottom: 1px solid black;}
              dt {font-family: monospace; color: #666;}
            </style>
        </head>
pi/fiew: |
    sayyl "Pi J.name receives  some .... ".wdump 3, $s;
indoch: | # Sugd from another event splitter
    warn "INDOCH";
Sugd: | # acum, regroup, persist, do batches
    u allact
    n Sugdev =>3143,<<'','%code:U,v:scJ'
        J.ev.o ||= 'indoch';
        # dubimport
        J.ev.tr = 1;
        J.uzk ||= [qw'mean onto etc'];
        J.UG ||= [];
    
    # n MuSt # instance must have storage (AmPg)
    
    # between pin and M:
    n Sugdev =>33,<<'','%code:U,v:scJ'
        @{J.UG} = grep {keys %$_} @{J.UG};
        my $y = J.oy;
        y.in = 0.1;
        y.out = 0.5;
        y.ert = 3;
        G&Sugour,$J;
        J.VV.N = 1;
    
    u allacgts
    n Sugour =>'',<<''
        my $J = $s;
        my $pi = {};
        for my $u (@{J.UG}) {
            my $k = join(' ', map{u.sc->{$_}}@{J.uzk});
            push @{$pi->{$k}||=[]}, $u;
        }
        my $M = J.oy.o.M;
        for my $k (sort keys %$pi) {
            my $v = $pi->{$k};
            my $ts = {};
            for my $u (@$v) {
                my $ses = u.sc->{ts.k};
                push @{$ts->{$ses}||=[]}, $u;
            }
            if (keys %$ts > 1) {
                my @o = sort {@{$ts->{$a}} <=> @{$ts->{$b}}} keys %$ts;
                ts.win = $ts->{$_} for pop @o;
                ts.k = 'doct';
            }
            Mn($k=>-ean=>{s=>$v,ts=>$ts});
        }
    
    #n downsave=>[-doi=>0.04]
    
AmPg: | # U at.row=1, J.ro=$read, UG=ro.sc.M=UG or ro.M=oy.o.M
    n UpPg
    
    u allact
    n Arow =>32,<<'','%code:U,v:scJ'
        J.oy.at.row = 1;
        G&tyable;
        if (my $r = J.ro = G&Jr ) {
            r.c = djson r.c;
            r.sc = djson r.sc;
            J.UG = r.sc.M if J.UG;
            $r
        }
    
    u allsvse
    n row =>4,<<'','%code:Art'
        return warn "Nonroot row: ".ki$C if !C.c.root;
        .
        my $M = J.UG || J.Oy.o.M;
        die "J.name TOO DEEP o M ". wdump 7, $M if G&oleak,$M,4;
        .
        #sayyl "J.name has ".wdump 3, $M;
        #sayyl "Got row on C.t: ".ki $at;
        my $r = J.ro ||= {};
        r.c ||= {};
        G&xot,r.sc||={},at.sc;
        delete r.sc.row;
        delete r.sc.z;
        r.sc.M = $M;
        my ($c,$sc) = map{sjson($_)} r.c, r.sc;
        .
        J.ro &&
            G&qp,<<'',C.t;
                delete from names where t = ?
        .
        #say " For C.t  : $sc";
        G&qp,<<'',C.t,0.3,$c,$sc
            insert into names (t,y,c,sc) values (?,?,?,?)
    
    #
UpPg: |
    u allacgts
    n db =>'',<<''
        use Mojo::Pg;
        my $sJ = A.J && A.J.mo.s || die "no AJmos: A.talk";
        my $pg = sJ.A.pg ||= Mojo::Pg->new('postgresql://s@/s');
        my $mJ = A.J.mo.J || die "nomoJ";
        delete mJ.A.db if mJ.A.db.process ne $$;
        mJ.A.db ||= do {
            my $db = $pg->db;
            db.process = $$;
            $db
        };
    
    n qp =>'',<<''
        G&db ->query($s,@Me);
    
    n tyable =>'',<<''
        $s ||= 'names';
        my @col = map{split','} @Me;
        push @col, 't','y real','c json','sc json';
        my $colum = join', ',map{s/:/ /;/ /?$_:"$_ text"} @col;
        my $q = "create table if not exists $s ($colum)";
        say "Create: $q from".wdump 2, [$s,@Me] ;
        G&qp,$q
    
    n qh =>'',<<''
        my @o;
        G&qp,$s,@Me ->hashes->map(sub{push @o,$_});
        wantarray ? @o : $o[0]
    
    n Jr =>'',<<''
        G&qh,<<'',$s
            select * from names where t = ?
    
pi/jsthink: |
    n ste=>1=><<'','%e'
        var to = [];
        $('body > *').each(function(i,k){
            var e = {};
            e.tag = k.tagName;
            $.each(k.attributes, function(ii,kk) {
                e[kk.name] = kk.value;
            });
            to.push(e);
        });
        a.to = to;
        //to.push(k.tag);
        a.c(' BLablah');
        .
        var d = {};
        a.entag(d, $(A.on));
        a.ethro(d, ws);
        console.log(d);
    
    
    
pi/hush: |
    y.at.wi = 5;
    n t=>1=>C.t,'%hs:287'
    (J.A.d > 3 || ref $s ne 'HASH') && return
         n '@'=>''=>"@".ki($s),'%fs:7'
    Mn($_=>-hush=>{s=>$s->{$_}}) for sort keys %$s;
    # etc
    # e
SpaceWatch: |
    u allvse
    n seoluve =>323,<<'','%code:U,v:J'
        J.pich.spaceflos = [{any=>1,u=>'SpaceWatch'}];
        
    u allvy
    n yonwatch =>223,<<'','%code:Mo,v:o'
        return if C.c.swa;
        sayyl "Seeing A.J.name   do C.t: ".wdump 1, C.y;
    
Gen: |
    u ReoCur
    y.at.ux = 1;
    n s=>2=>23
    my ($Jo) = map{_.nj}
    n Sen
    my $vs = Jo.El.Pre.vs;
    Mn(es=>-vs=>{s=>$vs});
    
Wseer: |
    u urw
    n state=>1=>"Ax Wu"
    n codeoy=>2=><<'','%jse'
        reply $('body > *').each(function(k,v){ console.log(v) });
    
urw: |
    n ReoCur
    u allvse
    n seolu =>32,<<'','%code:U,v:J'
        J.oy.at.ux = 1;
        J.oy.at.oWl = 1;
        J.ev.th ||= 'middle';
        J.ev.li ||= 'climbos';
        
ym/time: |
    my ($per,@cvs) = @{v.cut};
    A.t&$per,@cvs;
Usee: |
    u urw
    u curv=>pi=><<''
        curve 0 0.11
    
    my @l = `find life/W -type l`;
    my $keep = {map{chomp; readlink($_) =~ /^(.+)\..+?$/; $1=>$_}@l};
    my @r = `find life/W -mtime +0.6 -type f`;
    for (@r) {
        my $k = $1 if /^life\/W\/(.+)\..+?$/;
        $keep->{$k} ?
            sayre "$k \t\tis $keep->{$k}"
          : `rm $_`;
    }
    sayyl sort keys %$keep;
    #my @el = `find life/W`;
    y.in=1;
    y.out=5;
    Mn(some=>''=>{pi=>textl=>s=>$_})
        for split"\n",wdump 2, \@l;
EYZ: |
    u ReoCur
    y.at.ux = 1;
    J.VV.N = 1;
    u curv =>pi=><<''
        zoom 0  0.13
        y    0  0
        x    0  0
        curve 0 -0.03
    
    # eyes !
    y.limn = 0.2245;
    y.lum = 5;
    y.in = 0.04;
    y.out = 0.3;
    #Mn(shedful => '', {pi=>'eye',s=>'eye/Tarf/Photo serieses'});
    Mn(shedful => '', {pi=>'fi',s=>'eye/el'});
Details: |
    u ReoCur
    u curv=>pi=><<''
        curve 3 -0.2
        zoom 2 0.6
    
    y.at.ux = 1;
    J.VV.N = 1;
    
    #Rw AfghanRug;
    n $_,$_,$_,'%hs:389,fs:24,ml:-2em' for 1, 3, 5, 7, 9;
    
    J.ev.th ||= 'middle';
    J.ev.li ||= 'climbos';
    
    n undivthis=>[-dos=>0.06]
    
    #n lod=>0.06 =>'fds'=>'%id:lodo,dos:goche,wi:3'
    
    G.edit ||= 'G/way/Details';
    n edit=>0.02=>'@'=>'%id:edat,dos:flse,op:J/se/cod,to:!'
    J.se.cod &&
    n 'G/edit'=>[-cde=>'1-2']
    J.se.cod &&
    n G.edit=>[-cde=>'2-6']
    y.at.cssdel = 'transform';
    y.ope=1;
    #n time =>[-timem=>'1-9x'.int rand 13]=>''.`date`
    
    #n Tarp
    J.act = 0; # pi always
    y.in = 0.08;
    #y.lum = 1;
    y.out = 88;
    Mn($_=>-shed=>) for 'ghosts/c/48';
    
    
    #Mn($_=>-codey=>) for @{J.CO||=[]};
    #Mn(shedful => '', {pi=>'eye',s=>'eye/fug/1/lt'});
    
    n "1$_",$_,$_,'%hs:389,fs:20' for 1, 3, 5, 7, 9;
    
    return;
pi/timem: |
    Mn(dko=>''=>$_=>
        '%fs:'.(20 + int rand 70).',fw:6,hs:'.join('',map{int rand $_}5,7,8).',blr:'.int rand 4
      )
        for split ' ', $s;
AfghanRug: |
    #u ReoCur
    #y.at.ux = 1;
    #n $_,$_,$_,'%hs:389,fs:20' for 1, 3, 5, 7, 9;
    my $c;
    c.s = enth("  ஓ୶");
    c.cow = 'r4b3 a3a';
    c.mixco = '0.5 582';
    
    n nob =>''=>{nobody=>'ux'},'%sat:7'
    
    y.in = 1;
    y.out = 9;
    Mn(d =>''=>$c=>'%ht,fs:164,hs:'.int(rand(9)).'96,sha:3 3 3 034') for 1..6;
    0 &&
    n afghanrug =>'1-9x3',$c,@{Load(fixutf8(<<''))};
          - blr: 4
            fs: 152.9
            fw: 4
            ht: 1
            sat: 1
            bri: 0.3
            con: 3
            sha: 3 3 3 034
            hs: 493
            zig: 5
    
    Rw QuietVillage;
    J.VV.N = 1;
    n affg =>'12-88x8'=>$c=>'%fs:73,blr:3,hs:374,ht:1,ml:4';
    # c
QuietVillage: |
    n quiet=>2=><<'','%ht'
        <video width="1920" height="1080" autoplay controls>
            <source src="art/La Monte Young - Rag Bhairava (Excerpt).mp4">
        </video>
    
Tarp: |
    u ReoCur
    y.at.ux = 1;
    y.at.oWl = 1;
    J.VV.N = 1;
    y.ope = 1;
    y.at.dis = 0;
    #
    for (J.slow ? 1 : (1,2,3,4)) {
    
    J.tea ||= [shuffle grep /^[\/\-\.\w]+jpg$/i, glob 'eye/*/*'];
    
    my $pg = 'w/Tarpig';
    J.slow = readlink($pg) || 0;
    J.slow += 0.3;
    J.slow = 0 if J.slow >= @{J.tea};
    G&dlin,w=>J.slow,'Tarpig';
    
    #
    my $f = J.tea->[int J.slow];
    J.fast += 1 if rand 5 > 2;
    
    n "the J.slow J.fast"=>-pape=>{s=>'mild'=>thumb=>$f};
    
    Mn(f=>''=>$f=>'%dos:flse,op:J/slow,to:1');
    
    }
pi/textl: |
    my $l = sum map{ord $_} split '', $s;
    $l -= 10 until $l < 10;
    my $h = int $l;
    n text=>1=>$s,{hs=>"${h}877"}

