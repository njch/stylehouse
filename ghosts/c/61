lod/2:
   newwave: | # THE TAKER
    Rw Run;
    saygr "YEYEEEEEEEEEEEEEE";
    return 1;
recur: |
     Mojo::IOLoop->recurring($d,$cb);
vortex: |
     my $m = ar.m||[];
     my $d = ar.d||4;
     my $o = Rw pul $cs:m way;
     o.way || die;
     
     my $loopr = J.name."%loopid#o.way\t0.3";
     my $id = G.oin.bb->{$loopr};
     saybl "timer replaco J.name o.way" if $id;
     # if last hit and delta are whack
     # tiny hairs of sanity
     Mojo::IOLoop->remove($id) if $id;
     
     my $bl = {};
     my $cb = sub {
         return Mojo::IOLoop->remove(bl.id)
         if G.oin.bb->{$loopr} ne bl.id;
         Rw o.way $J;
     };
     bl.id = G.oin.bb->{$loopr} = Rw recur $d $cb;
Run: |
    # arrived from newwave:
    #  perl G/on/wag eats a wormhole of way
    #  Z/1/expro
    #  Z/5/zoc
    #   Z/1/exprob     names    lifes if ^[sh]
    #   Z/5/loD  way loadc w/c, extends way with lod/$name hash
    #   Z/5/zurc  Rw newwave || do { Rw zoybracken, Rw fresh_init }
    
    # to make more
    # wagging wormhole and w/c are one
    # intention can open it for itself
    # the z executable points ARGV points to w/*s to apply on top of each other
    # as a kind of u that gains meaning as it receives layers of language
    # so behaviour can eat the rest of its specuity
    
    my $G = Rw Gto;
    
    my $cb = sub {
        Rw Many;
    };
    Rw recur $d=1 $cb;
    
    sayyl "YEP";
Many: |
    $G || die;
    # The Beatles - Martha My Dear
    my $J;
    ($J) = G.oin = G.J ||= G.oin ||= do{
        $J = Rw Jto One;
        my $sc = {J=>$J};
        Rw jamsc $J $t:J.name $cv=0.3 $s=oo $sc;
        $J
    };
    
    n ''=>''=>{W=>J.name};
    
    my $y = G.Many||={};
    y.i++;
    my $t = hitime;
    y.la->{$t} = 1;
    sayyl "many y.i"; 
One: |
    sayyl "Doing J.name stuff...";
    n theS=>1=>{pi=>'cfile'=>s=>"life/S\.s"}
    
    n Yup
    n Hypo
    
    J.V = 1;
Gto: |
    my $G = $G;
    G.name = 'thouG';
    my $mkD = sub {
        my ($pin,$ar)=@_;
        my $D;
        D.point = $pin;
        if (my $C = ar.__D) {
            delete ar.__D;
            D.bab = C.c.s || die "N s".ki $C;
            D.noise .= C.sc.dige if C.sc.dige;
            D.Verb = 1;
        }
        D.ar = $ar;
        D.name = join ' ', D.point, sort keys %{D.ar};
        D.sign = "Z";
        D.talk = join' ',grep{defined}map{$D->{$_}}qw'sign name noise';
        $D;
    };
    G.w = sub {
        my ($pin,$ar)=@_;
        my $D = $mkD->($pin,$ar);
        if (!defined D.bab) {
            D.bab = G.way->{$pin};
        }
        if (!defined D.bab) {
            if ($pin =~ /\//) {
                #say "windshot: $pin" unless $pin =~ /^pi/;
                D.bab = fwind(G.way,$pin);
            }
        }
        if (!defined D.bab) {
            die "Not findin D.talk";
            return;
        }
        
        my $Z = $G->Doming($D);
        G.randomtask->() if G.randomtask;
        my $r; eval { $r = [ $G->D($D) ] };
        $G->Done($Z);
      
        if ($@) {
            my $ne = "Z Z.inter\n$@";
            $@ = $ne;
            D.nodie || die $@;
            $@ = "";
        }
        return wantarray ? @$r : $r->[0];
    };
    $G

