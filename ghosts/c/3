
Ajr: | # aimed at J and a line: C or t/cv    sends style => $v
      sub {
          my $s = shift;
          my $v = shift;
          my $d = shift;
          $s = '%'.$s if $s;  
          my $t = exists ar.t ? ar.t : ar.C.t;
          my $cv = exists ar.cv ? ar.cv : ar.C.y.cv;
          my $r = $t.$s."\t".$cv;
          if ($d) {
              sayre "delbbl $r  $d   J.name" for 1..5;
              Rw delbbl $J $l:t;
          }
          saybl " chuck $r     $v  >  ".J.bb->{$r} if J.V;
          !defined $v ?
            J.bb->{$r}
          : do {
              J.bz->($r, $v);
              sub { delete J.bb->{$r} } 
          };
      };
J6: |
   Rw J5 + $ok=6; 
J3: |
   Rw J5 + $ok=3; 
J5: |
   my $r = {%$ar};
   r.J = delete($r->{m})->[0] if ar.m;
   delete r.R;
   my $C;
   C.c = $r;
   return sayre "RECUR" if @F > 130;
   my $J = G.oin;
   #Jn(C.t||'', '', C.c, C.sc);
   Rw oo $J:G.oin $C;
newwave: |
    saygr "EXactly";
    G.oin = Rw JJ join;
    Rw up $J:G.oin;
    
    Rw cl/tidy;
    #Rw zoybracken;
    Rwyl 0.01 fresh_init;
    1
join:
     yJ: |
       G.oin = $J;
       'join clw'
     around: |
       sayre "J.name around:!". ki $ar;
     up: |
       # G.oin root ww:.
       Rw J5 Ha;
       Rw J5 wu;
       # iterations:
       Rw J5 toc;
     X: |
       # message goes up to wu via A
       my $oJ = J.oJ.A || die 'noway';
       Rw A/X $J:oJ $X:J;
       # to inX for the A delbbl
       Rw J5 $J $X:J;
       Rw J5 $J=J.name
       if e.S;
     inX: |
        my $J = C.sc.J;
        die "Nofound $J  C.t   C.y.cv" if !ref $J;
        die "noovewr X  C.c.X ne $J" if C.c.X ne $J;
        sayyl "KILING J.name". wdump $C if C.c.X;
        A.jr&J,$J,9;
        # ^ delete
        J.dead = 1;
        T.return = [];
        return;
toc:
     yJ: |
       'toc'
     around: |
       Rw vortex toc/up $J $d=4;
     up: | #
       # hops, rhythm aesthetics
       # things pur ambiently & incur pipes of sprawlingness into music
       # to space it out right...
       # for the mass of the atom of thought
       # wants emit with precision, figure processing/Em route into time
       
       # is a subscribe that catches up as %wantime is join bz'd
       my $oJ = G.oin;
       my $ip = {style=>'wantime'};
       my @timey = Rw tvo $J:oJ $ip;
       my @go;
       for my $j (@timey) {
           my $y = j.s;
           my $x = J.bb->{"j.l%timex\t0.3"};
           $x += $d; # vortex 4s
           if ($x >= $y) {
               $x = 0;
               push @go, oJ.bb->{"j.l%J\t0.3"} || die "no find j.l oin";
           }
           else {
               #say "ti $x -- $y";
           }
           J.bz->("j.l%timex\t0.3" => $x);
       }
       for my $J (@go) {
           sayyl "toc up: J.name\n\n";
           Rw up $J;
       }
       #say 'timing '.join', ', map{_.l} @timey;
       #saybl "makde ".F_delta();
vortex: |
     my $m = ar.m||[];
     my $d = ar.d||4;
     my $o = Rw pul $cs:m way;
     o.way || die;
     
     my $loopr = J.name."%loopid#o.way\t0.3";
     my $id = G.oin.bb->{$loopr};
     saybl "timer replaco J.name o.way" if $id;
     # if last hit and delta are whack
     # tiny hairs of sanity
     Mojo::IOLoop->remove($id) if $id;
     
     my $bl = {};
     bl.id = 
     G.oin.bb->{$loopr} = 
         $G->recur($d => sub {
             return Mojo::IOLoop->remove(bl.id)
                 if G.oin.bb->{$loopr} ne bl.id;
             Rw o.way $J $d;
         });
Ha:
   yJ: |
     'Ha'
   around: |
     my $now = hitime();
     return if J.last > $now - 0.4 || G.pslagtil > $now;
     $now - J.last < 9 && Rw vortex around $J $d=5;    
     J.last = $now;
     G.ino ||= $J;
     
     my $N = Rw tc $J;
     my $lcv;
     my $i;
     for my $d (@$N) {
         my $n = d.c.s;
         
         my $com;
         my $dont;
         if (d.sc.watime) {
             my $del = d.sc.watime - hitime;
             $com = "w\@in ".sprintf('%.3f',$del);
             if ($del > 0.02) {
                 if (d.sc.watime != d.sc.watimed) {
                     # & shift out Ha 6
                     #sayyl "WAYLAY $del to n.t";
                     my $ip = {l=>d.t,cv=>d.y.cv};
                     timer $del {
                        Rw around $J;
                     };
                     J.bz->("d.t%watimed\t".d.y.cv => d.sc.watime);
                 }
                 $dont = 1;
             }
             
         }
         #my $mers = "WAITS  ".slim(10,d.t)."  n.t\t d.y.cv  $com  ".ki (1,n.c)." \t\t";#.d.sc.pict;
         #$dont ? saybl $mers : sayyl $mers;
         next if $dont;
         
         Rw hoset + $d;
         #sayyl "RE& n.t  at d.y.cv  d.sc.pict";
         
         timer 0.001 {
             Rw oo $J:G.oin $d:n;
         };
         
         $i++;
         last if $lcv && $lcv > d.y.cv;
         $lcv = d.y.cv;
     }
paintaj: |
     aj.Wid || die "not Wid?";
     aj.hol = "H.style/H.name/H.id";
     aj.hitime = hitime;
     aj.name ||= aj.J.name;
     
fi: | #c
     my $point = ar.p || ar.pin || ar.m->[0];
     
     my $know;
     if (!ar.pin && ar.J) {
         my $J = ar.J;
         if ($point =~ /^\*\/(\w+)$/) {
             my $inway = $1;
             my $h = ar.h || G.way;
             $h = h.hooks if h.hooks;
             my @gu = @{J.yy.styleord};
             #@gu = @gu[0..5] if @gu > 6;
             my @so;
             for (@gu) {
                if (ref $h->{$_} eq 'HASH' && $h->{$_}->{$inway}) {
                    push @{$know||=[]}, "$_/$inway";
                    last if !ar.sucky;
                }
             }
         }
     }
     
     if (!$know) {
         my %wo = Rw findl +;


         my @keys = map { s/^\///; $_ } keys %wo;
         if (!ar.pin && ar.J) {
             my $J = ar.J;

             @keys = grep { my($K)=split'/',$_; J.yt->{$K} } @keys;
             my @or = @{J.yy.styleord};
             if (@or && @keys > 1) {
                 my $i = 1;
                 my $is = {map{$_=>$i++}@or};
                 @keys = sort {
                  $is->{($a=~/^(.+?)\//)[0]} <=> $is->{($b=~/^(.+?)\//)[0]}
                  } @keys;

                 if (!ar.sucky && @keys > 1) {
                     #sayre "Limiting @keys";
                     @keys = $keys[0];
                 }
             }
         }
         $know = [@keys];
     }
     saybl "With: ar.J.name  $point    @$know" if 0 && ar.J && ar.J.name eq 'shw';
     @$know
     
hoset: |
    my @r = map { d.t.($_?'%'.$_:'')."\t".d.y.cv } '', keys %{d.sc};
    delete J.bb->{$_} for @r;
    
hosin: |
    n.sc = ar.sc if ar.sc; n.c.s = n.s if exists n.s; n.y.cv = n.cv if n.cv;
    my @glu = map { '%'.$_ => n.sc->{$_} } sort keys %{n.sc};
    J.bz->(n.t."\t".n.y.cv => n.c.s, @glu);
comb: |
    # so that J.2 etcs declare needs and resume when ready
    my $iJ = G.ino || return do{warn "no loop";1}; # continues the Atime
    
    
    A.selif = Rw cscomp $C $ig:A.note;
    my $dig = dig A.selif;
    
    die "wamngle $wa" if $wa != int($wa) || $wa < 1 || $wa > 9;
    die 'noiJ' if !$iJ;
    
    my $n;
    n.sc.pict = A.selif;
    n.sc.watime = A.watime if A.watime;
    $wa = A.waov if A.waov;
    n.cv = $wa / 10;
    n.s = {%$C};
    n.t = $dig;
    
    sayyl "COMB J.name  C.t  A.ztime } to $wa \t ".ki 1,C.c;
    
    Rw hosin $J:iJ $n;
    0;
cscomp: |
    my $non = {%$C};
    my $de;$de = sub {
        my $v = shift;
        ref $v eq 'ARRAY' ?  [map{ $de->($_) } @$v]
        : !ref $v ? $v
        : v.id || die "no v".wdump(2,$v);
    };
    for my $k (qw'c sc') {
        my $v = $non->{$k} || next;
        $non->{$k} = $v = {%$v};
        for my $sk (keys %$v) {
            my $sv = $v->{$sk};
            $v->{$sk} = $de->($sv);
        }
    }
    non.cv = ''.non.cv;
    non.s = $de->(non.s);
    return sjson $non

