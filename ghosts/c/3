cscomp: |
    my $non = {%$d};
    my $de;$de = sub {
        my $v = shift;
        ref $v eq 'ARRAY' ?  [map{ $de->($_) } @$v]
        : !ref $v ? $v
        : v.id || die "no v".wdump(2,$v);
    };
    for my $k (qw'c sc') {
        my $v = $non->{$k} || next;
        $non->{$k} = $v = {%$v};
        for my $sk (keys %$v) {
            my $sv = $v->{$sk};
            $v->{$sk} = $de->($sv);
        }
    }
    non.s = $de->(non.s);
    return sjson $non
join/up: |
       # G.oin root ww:
       Rw J5 wu;
       # iterations:
       Rw J5 toc;
       Rw J5 Ha;
Ha:
   yJ: |
     'Ha'
   around: |
     G.ino ||= $J;
     J.updos ||= 1 +
         Rw vortex around $J $d=1;
     my @l = Rw tyc $J;
     
     saybl wdump 6, \@l;
     sayre "ZEV  ZEV ZEV" for 1..3;
comb: |
    # so that J.2 etcs declare needs and may rerun when ready
    my $iJ = G.ino;
    if (!$iJ) {
        sayre "No loop";
        return 1;
    }
    
    saybl "COMB ".gp($J)." d.t A.ztime } to $wa";
    my $igktk = {c=>A.note.csrm};
    A.selif = Rw cscomp $d $igktk;
    my $dig = dig A.selif;
    sayyl "$dig combackin $wa or so";
    #die "ye $wa";
    die "wamngle $wa" if $wa != int($wa) || $wa < 1 || $wa > 9;
    my $cv = $wa / 10;
    die 'noiJ' if !$iJ;
    #die 'here';
    $wa = A.waov if A.waov;
    iJ.bz->("$dig\t0.$wa" => {%$d});
    
    # sort out a timer maybe;
    # + hitime; 
    # A.waov
    # A.note.watime 

    sayyl 'jring  '.A.selif;
    sayre wdump [ 'three' ];
    A.fopi->{J.id} = $J;
    0;

