
unThaw: |
    0&&
    n NotStuff =>''=>{s=><<''},{code=>'Mo 29'}
        # should finish us C, the contAiNed are the future
        # 3actally proper
        T.not = 1; # will severato,
        # which shifts A.mo.re.$cv[]
        # swims AZs into @{A.N}
        # SNat also oseveratoes between any .v ish cv groups if @{A.N}
        # also should sort by cv above K
        # SNat before next cv after cv with v, to wide before next
        # as things feed back to ourselves via A.mo.re.$cv[]
        # which is severed (cv shifted) into a new batch of AZ 
        # apparently exude all 3* before loop off down A.N
        # it has something to do with nk in SNat
        # A/sc gets or not ^
        # things can be Wd out real hivey, Jduplicsa en namespace spag
        # they expand around 3-6
        # heres wher eit  gets creal
        # aboput the 2/3 A timey, where rm, compression unfolds
        # oir rhythm style joins
        # also how & 9s (noncompresses) out for us into a more local J
        # u W would zlide in as an Elvis clone
        # it has a high frequency
Modi: |
    # make pool, synth space, want arches
    # fork & rejoin to exciting place
    # the valley, what it means to be here in here YIN
    my $A = Rw WeBase Mo;
    my $I = A.I;
    I.d&n,$A,$C,$G,{};
    I.d&An;
    A.t&1;
    A.t&11111 || warn "NO 1";
    @{A.N}||die"nois".wdump[$C,$A];
    my $i;
    while (@{A.N}) { #                                             à¶¬
        $i++ > 5000 && die " @ Huge Modi";
        my ($A,$C,$T) = I.d&Act,$A;
        # ^this to thisv to 2, returns the finitest A, etc.
        T.not&&next;
        A.t&6;
        T.not&&next;
        I.d&flywheels; # want to outgrow
        T.not&&next;
        A.t&78;
    }
    continue { I.d&z; }
    # 9
    (A.nj) = values %{A.Js} if A.Js && keys %{A.Js} == 1;
    return $A
Modulator: |
    n Space
    n Spaci
    
    n lum
    n bal
    
    n Rings
    n Wrinkles
    n Jing
    n Jong
Wrinkles: | # space refering to itself
    u allvse
    
    n bals =>'',<<'','%code:Mo 201'
        # a non-s
        my $N = C.c.bals;
        $N = [ map { [$_] } split "\n",$N ] if !ref $N;
        my $y = C.y || die"noy";
        y.o && return sayre "bals y o already".wdump[ki $C, $y, I.d&tlM,y.o ];
        y.bal && return sayre "bals y bal already".wdump[ki $C, $y, I.d&tlM,y.bal ];
        y.bal = [];
        # have some minions to od thi:
        A.oA || die "wanting to s bab, no oA";
        Rw In $J:A.J $M:y.bal $N;
    
    # becomes path:
    n pwth =>'',<<'','%code:Mo 42'
        # 8case, to way
        $pwth =~ s/^(?!!)/!/s;
        C.c.path = $pwth;
    
    n id =>'',<<'','%code:Mo 42'
        T.at.id = $id;
    
    n pwar =>'',<<'','%code:Mo 42'
        T.at.pwar = $pwar;
    
    n path =>'',<<'','%code:Mo 421'
        # install sc path, wants idlyness (indexedness)
        T.at.path = $path;
        T.at.idly = 1 if !C.c.fo;
    
Modems: |
    n Pha
    n Jamsc
    n Timing
    J.V = 1;
Pha: |
    u allof
    n '','','%of:I'
    
    n pha =>''=><<'',{acgt=>'J,name'}
        # tracked being
        # temporal phatness, per suJ (encap $M surges within)
        if (my $x = J.phy->{$name}) {
            sayre "J.name 's $name was re entrant";
            I.d&end,$x;
            # end - maybe new stuffright as some random part of this process
            # hold yay minutes of changes in 10 second groups, etc
        }
        # bz multicasts
        my $x = J.phy->{$name} = {};
        x.begin = hitime();
        x.name = $name;
        x.J = $J;
        x.bb = {};
        x.ord = [];
        #x.tim = {};
        #x.wtf = {}; # F grab
        #x.ap = sub{}; # bz do aftering
        x.qui = 1;
        x.head = J.phl->{$name}->{l}->[-1] if J.phy->{$name};
        $x;
    
    # abandonupgrade to what's there already, early exity lop
    n bandon =>''=><<''
        delete s.J.phy->{s.name};
        s.abandoned = 1;
        if (my $x = s.head) {
            I.d&as,$s,$x;
        }
        I.d&end,$s
    
    n as =>''=><<'',{acgt=>'s,x'}
        for (qw'begin bb ord tim wtf') {
             exists $x->{$_} || next;
             my $v = $x->{$_};
             $v = [@$v] if ref $v eq 'ARRAY';
             $v = {%$v} if ref $v eq 'HASH';
             $s->{$_} = $v;
        }
    
    n end =>''=><<''
        my $y = s.J.phl->{s.name} ||= {name=>s.name, l=>[]};
        s.ended = hitime();
        delete s.J.phy->{s.name};
        shift @{y.l} while @{y.l} > 5;
        # layers ^ rolling in time index .r -> the y.l
        # so last phase of $name can be found?
        push @{y.l}, $s;
        if (s.bb) {
            my $w = @{y.l};
            y.l_bb->{$_} = $w for keys %{s.bb};
        }
        # somewhere thinks about what happened
        $y
    
    n exactl =>''=><<'','%l:#c un-ins things from J'
        my $q = shift;
        my $y = I.d&end,$s;
        my $cur = y.l->[-1];
        my $last = y.l->[-2];
        $cur eq $s || die "sidf$cur $s";
        last.bb ||= {};
        .
        my $wtf = I.d&wtfch,cur.bb,last.bb;
        .
        delete s.J.bb->{$_} for keys %{wtf.gone};
        .
        # see s.extill, time passing interesto...
        # churn stats like 30% of last disappear, 20% new
        s.wtf = $wtf;
        $wtf;
    
    # J future, Y saves
    n wtfch =>''=><<'',{acgt=>'Jb,Yb',l=>'#c diff J'}
        my $wtf = {};
        wtf.same = 1;
        $wtf->{$_} = {} for qw'new diff gone';
        .
        for (sort keys %$Jb) {
            if (!exists $Yb->{$_}) {
                wtf.new->{$_} = $Jb->{$_};
                wtf.same = 0;
            } 
            elsif ($Yb->{$_} ne $Jb->{$_}) {
                wtf.diff->{$_} = $Jb->{$_};
                wtf.same = 0;
            }
            else {
                wtf.sami++;
                wtf.still->{$_} = $Jb->{$_};
            }
            wtf.tot++;
        }
        for (grep { !exists $Jb->{$_} } sort keys %$Yb) {
            wtf.gone->{$_} = $Yb->{$_};
            wtf.same = 0;
        }
        $wtf;
    
    # the mess C-er
    # safe vs doing - sheets of J->Y, dont drop any frames
    # where we start being onlies
    n Elvis =>''=><<'',{acgt=>'J,Y',l=>'#c'}
        my $wtf = I.d&wtfch,J.bb,Y.bb;
        .
        Y.tw ||= {};
        Y.lo = {}; # compile
        .
        for my $mo (qw'gone diff new') {
            for my $r (keys %{$wtf->{$mo}}) {
                my $j = I.d&rJ,$r,$J;
                j.r = $r;
                j.lt = j.cv."\t".j.t;
                if (!j.lt=~/\S/) {
                    die "Got $r =>   ".ki $j;
                }
                if ($mo eq 'gone') {
                    delete Y.bb->{j.r};
                    delete Y.tw->{j.lt}->{j.style};
                }
                else {
                    Y.bb->{j.r} = j.s;
                    Y.tw->{j.lt}->{j.style} = j.s;
                }
                Y.lo->{j.lt}->{$mo}->{j.style} = j.s;
            }
        }
        .
        Y.tv ||= {};
        Y.v ||= {};
        Y.go = {};
        my $same = 1;
        for my $k (keys %{Y.lo}) {
            my $tf = Y.lo->{$k};
            my $cs = Y.tw->{$k};
            if (tf.new && !tf.gone && !tf.diff && keys %{tf.new} == keys %$cs) {
                $same = 0; # new line to make
            }
            if (tf.gone && !keys %$cs) {
                $same = 0; # line to disappear
                my $C = Y.go->{$k} = delete Y.tv->{$k};
                my ($cv,$t) = $k =~ /^(.+?)\t(.*)$/;
                delete Y.v->{$cv}->{$t};
                delete Y.v->{$cv} unless keys %{Y.v->{$cv}};
            }
            if (tf.diff || tf.new) {
                keys %$cs || die 'nokeys';
                my ($cv,$t) = $k =~ /^(.+?)\t(.*)$/;
                defined $cv || die "twas $k";
                my $foam = sub {
                    my $C = shift;
                    %$C = (t=>$t,y=>{cv=>$cv},c=>{},sc=>{%$cs});
                    C.c.s = delete C.sc->{''} if exists C.sc->{''};
                };
                $foam->(Y.tv->{$k} ||= {});
                $foam->(Y.v->{$cv}->{$t} ||= {});
            }
        }
        if (!$same) {
            Y.vs = [];
            Y.kvi = {};
            Y.cvi = {};
            my $i = 0;
            for my $k (sort keys %{Y.tv}) {
                my $C = Y.tv->{$k} || die "wtf $k";
                push @{Y.vs}, $C;
                Y.kvi->{$k} = $i;
                Y.cvi->{C.y.cv} ||= $i;
                $i++;
            }
        }
        .
        Y.ra = I.d&ratio,wtf.sami,wtf.tot;
        Y.rato = wtf.tot;
        Y.revs = !$same;
        .
        $Y;
    
    
    
    n Elj =>''=><<'',{acgt=>'J,name',l=>'#c with a self'}
        J.El->{$name} ||= Rw Jto - $le:J $name;
    
    n El =>''=><<'',{acgt=>'J,name',l=>'#c without a self'}
        J.El->{$name} ||= {bb=>{},name=>$name};

    
Elj: | # I usual
    my $name = ar.name || shift @{delete ar.m};
    if (my $Y = J.El->{$name}) {
        return $Y;
    }
    J.El->{$name} = Rw Jto - $le:J $name;
Timing: |
    u allof
    n '','','%of:I'
    # RAY SCUTTLER read parts, given rv and possibly since rl 
    # puts newzs in flat list, they themselves unify time etc.
    n scd =>''=><<'',{acgt=>'rv,rl'}
        my $r;
        r.z = [];
        r.oldz = [];
        undef $rl if $rl && rl.c ne rv.c;
        push @{$rl ? r.oldz : r.z}, @{rv.c};
        .
        r.in = @{rl.sc||[]};
        r.out = @{rv.sc};
        if (r.out > r.in) {
            r.ay = [r.in..(r.out - 1)];
            push @{r.oldz}, @{rv.sc}[0..r.in] if r.in;
            push @{r.z}, @{rv.sc}[@{r.ay}];
        }
        $r

    n ratio =>''=><<'',{acgt=>'o,t'}
        my $ratio = $o / ($t||1);
        0.01 * int(100*$ratio);
    
Jamsc: | # all the \t bz-io, very J2, inline thing protocol
    u allof
    n '','','%of:I'
    
    # interpreter of buzzed puit partiscules r -> j.[cv,t,style]
    # opens schema, how to interpret r to J
    n rJ =>''=><<'',{acgt=>'r,J',l=>'#c'}
        my $j;
        my $sing;
        if (J.tt) {
            $sing = 'J_tt';
            (j.cv,j.t,j.style) = $r =~ /^(.*?)\t(.*)\t(.*?)$/;
            if (!defined j.cv) {
                sayre "Hind $r  " for 1..5;
                (j.t,j.style,j.cv) = $r =~ /^(.+?)(?:%(.+))?\s+(.+?)$/;
            }
        }
        else {
            (j.t,j.style,j.cv) = $r =~ /^(.+?)(?:%(.+))?\s+(.+?)$/;
        }
        defined j.cv || die "$sing no $r    ".ki $j;
        j.s = J.bb->{$r} if $J;
        j.nos = 1 if $J && !exists J.bb->{$r};
        $j;

    # put C in bb, some towering tractor beams (ljm)
    n jamsc =>''=><<'','%l:#c'
        my $ar = $s;
        my $sc = ar.sc || {};
        my $J = ar.J || die "jamsc noj".ki$s;
        ar.C = ar.d if ar.d;
        my $t = defined ar.t ? ar.t
            : ar.j ? ar.j.l
            : ar.C ? ar.C.t : die'not';
        my $cv = defined ar.cv ? ar.cv
            : ar.j ? ar.j.cv
            : ar.C ? ar.C.cv || ar.C.y.cv : die'cvoy';
        .
        if (ar.oJ && ar.oJ ne ar.J && !ar.noR) {
            my $J = ar.oJ;
            if (my $ljm = J.A.ljm) {
                my $Me = "ar.oJ.ind ar.J.name "
                ." J.A.ljmo <<< J.name  sends:"
                ." $t\t$cv  $ljm";
                sayyl $Me if J.V || ar.J.V;
                push @$ljm, {%$ar};
            }
        }
        .
        my @fobz;
        push @fobz, [$cv,$t,undef,ar.s] if exists ar.s;
        push @fobz, [$cv,$t,$_,$sc->{$_}] for keys %$sc;
        my @tobz = map {
            my ($cv,$t,$s,$v) = @$_;
            my $r;
            if (J.tt) { # FUTU
                $r = $cv."\t".$t."\t".$s;
            }
            else {
                my $s = $s;
                $s = '%'.$s if $s;
                $r = $t.$s."\t".$cv;
            }
            if ($s) {
                ar.C.sc->{$s} = $v;
            }
            [$r,$v]
        } @fobz;
        .
        for (@tobz) {
            my ($r,$v) = @$_;
            J.bz->($r,$v);
        }
C14: | # the CIA is all over it
    # cp gip I.i, particle pullever
    if (my $c = G.pwin->(C.t, A.J.A.in)) { 
        $c = c._ || return;
        # make this a SlideEater
        # a hallucious field coorded on top of everything (I/T)
        say "C.t in: ".wdump $c if !A.J.yt.quiet;
        if (c.D) {
            c.D->($C);
        }
        # love guessing with small pools of stable
        elsif (grep {exists $c->{$_}} qw{t y c sc}) {
            I.d&xot,$C,$c;
        }
        else {
            die "howto ".ki $c;
        }
    }
Rings: | # qualitative space coupling, T phasing (Motion, C
    u allacgts
    
    n acted =>''=>{s=><<''},{code=>'Mo 1'}
        # wheels acts run into, 6* coupling
        # we should scrub away any T we understand  (exactly)
        # trace flop F and see the swims
        I.d&Tat if T.at;
        return die'tlast' if T.last;
        1;
    
    n tlM =>''=><<'',{nov=>1}
        my $os = $s;
        $s = s.M if ref $s eq 'HASH';
        ref $s eq 'ARRAY' || return "S not N/M: ".wdump[$os];
        Rw ZNews $N:s;
    
Space: |
    u allvy
    # ^ always wants a new one somewhere
    # 6* thingalloveries (tangled in self)
    # so v=yo limits C ope to C.y.o existence 
    # things can complain about not matching somewhere
    # resuming back into itselves repeatedly
    # kind of go yonder, certain travelishing
    
    n yo =>''=>{s=><<''},{code=>'Mo 21',v=>'o'}
        $o = C.y.o = {M=>$o} if ref $o eq 'ARRAY';
        o.M ||= [$C];
        # 4d jelly slower-downer
        # so we should acquire many A.t&
        # this is an EC into our C's T.oM, as s.M now
        # stackable A with stitchable others interleaved in time
        # 6 FLIES
        o.M = [grep{defined}map{
            my $d;
            d.t = _.t;
            d.y = {%{_.y}};
            d.c = {%{_.c}};
            delete d.y.cv if y.ecv;
            # allow any cv to wander from yarNgrid:
            y.cvil = 1 if defined d.y.cv;
            d.sc = {%{_.sc||{}}};
            # TRansituio, soul spread
            if (o.ou) {
                # inside our, change slightly how we see
                # spread compound
                d.c.pi = o.ou;
                d.c.s = $_;
            }
            d.sc.oJ = o.oJ if o.oJ;
            # travel agent ^
            # traveli
            Rw C14 $I $A $C:d;
            #
            A.J.V && say "AH A.J.name  ::: d.t   ".ki d.sc;
            keys %$d ? $d : undef
        }@{o.M}];
    
    # deliver news of yonderness
    # having the .o is not so important
    # just somehow the surroundings
    # since they want to effect how we nest about them
    n yon =>''=>{s=><<''},{code=>'Mo 22',v=>'o'}
         my $J = A.J;
         my $Jy = J.C.y; # pi's sea
         # surface tesion, lum
         if (my $lt = C.y.limn) {
             my $rl = int(9 * $lt * Jy.spc);
             my $was = @{o.M};
             if ($was > $rl) {
                 my @um = @{o.M};
                 @um = @um[0..$rl-1];
                 @{o.M} = @um;
                 # space mod
                 my $s = $was;
                 Jn("lim",0.7,"$was>$rl",'%fs:4,hs:7487');
             }
         }
         C.y.bal = o.M || die"nomo";
         # unless y unlimited...until
         o.J = J.most.J if $Jy && Jy.o && Jy.spc > 0.1;
         my $shut = $Jy && Jy.o && !o.J;
         C.y.over = (Jy.o && Jy.over && Jy.over || 0) + 0.06 if y.o.J;
         #sayre "Jyspace: spc:  J.d.y.spc  or aspace: Jy.aspace" if $Jy;
         # divvy space inside parent's share most J or in 3-4 of the pi
         my $sl = Jy.spc * 0.1;
         C.y.in ||= $shut ? 0.3 : $Jy ? Jy.cv + $sl : 0.1;
         C.y.out ||= $shut ? 0.4 : $Jy ? Jy.ov - $sl : 0.9;
         C.c.lumfa = 1 if y.lumfa;
Spaci: |
    u allvy
    # space foyay calcium
    # also lum + bal mingle space
    # distribute display particles
    
    n yall =>''=>{s=><<''},{code=>'Mo 221'}
        C.y = {thi => C.y} if !ref C.y;
    
    # could spiral much space away from spine
    n yin =>''=>{s=><<''},{code=>'Mo 23'}
        # build wave plot manifold
        # solar systems
        y.cv ||= 0.3 if !defined y.cv && !defined y.in;
        y.in = y.cv if defined y.cv;
        y.in ||= 0.1;
        y.out = y.in + y.space if defined y.space;
        y.out ||= 0.9; # up to, then low things big
        y.thi ||= 1; 
        y.space = y.out - y.in;
        y.space *= -1 unless y.space > 0;
        y.aspace = y.space / y.thi;
    
    n yarN =>''=>{s=><<''},{code=>'Mo 26'}
        # twist, lay into segment
        y.u.v = defined y.cv ? y.cv
            : defined y.in ? y.in
            : die "no yiny".ki$y;
        y.thi || die "Whythi".ki$C;
        # y.u. shares av, y. separates
        # difference pours out of y.bal via y.i in 32
        my @lot = map {
            my $C = I.d&xot,{},$C;
            C.y.i = $_-1;
            $C
        } 1..y.thi;
        if (@lot > 1) {
            push @{A.mo.re->{0.29}||=[]}, map{[undef,$_]}@lot;
            T.not = 1;
        }
        else {
            my ($CC) = @lot;
            $CC || die "not one?";
            %$C = %$CC;
        }
    
    n yinvout =>''=>{s=><<''},{code=>'Mo 3'}
        y.mu = 1;
    
    # * bend mu since ^
    # render microdots
    n black =>''=>{s=><<''},{code=>'Mo 34'}
        my $was = y.u.v;
        defined $was || die"noAv".ki$C;
        # in:
        y.cv = 0+sprintf '%.6f', y.u.v unless y.cvil && defined y.cv;
        y.pcv = 0+sprintf '%.6f', y.i / C.y.thi;
        # over:
        my $in = y.aspace * y.mu;
        y.u.v += $in;
        # out: 
        y.ov = sprintf '%.6f', y.u.v;
        y.spc = y.ov - y.cv;
        #
        sayyl "Bend: C.t   $was += $in       y.aspace * y.mu       muav:y.u.muav"
            if A.J.V && y.u.muav && y.u.muav != 1;
    
    n ent =>''=>{s=><<''},{code=>'Mo 37'}
        $y->{$_} = 0+sprintf('%.6f',$y->{$_}) for qw'cv ov aspace spc';
        C.sc.yspc = y.spc if C.sc.nspc;
        C.sc.ml = (C.y.over * 40)."%" if y.over;

    n pin =>''=>{s=><<''},{code=>'Mo 77'}
        return if delete T.oke;
        my $oJ = A.J;
        my $J = C.y.o && C.y.o.J || $oJ;
        my $ar = {};
        ar.s = C.c.s if exists C.c.s;
        .
        Rw jamsc + $J $oJ $C $sc:C.sc;
        .
        # man is an insect is a flame
        .
        sayyl "Hamsc! A.talk: C.t C.y.cv     ".ki(1,{c=>C.c,sc=>C.sc})
            if A.J.V;

    
bal: |
    u allvy
    # yin dating compound, arranges space (4 = given dimensions)
    n bal =>''=>{s=><<''},{code=>'Mo 223',v=>'bal'}
        y.thi = @$bal;
    
    # yin 23 - space totalled
    # things have masses
    n muav =>''=>{s=><<''},{code=>'Mo 241',v=>'bal'}
        my $total = sum(map { y.thy||1 } @$bal) || 1;
        my $over = @$bal || 1;
        y.u.muav = $over / $total;

    n balin =>''=>{s=><<''},{code=>'Mo 301',v=>'bal'}
        I.d&xot,$C,$bal->[y.i];
        
    n balou =>''=>{s=><<''},{code=>'Mo 337',v=>'bal'}
        y.mu = y.thy if exists y.thy;
        y.mu = y.mu * y.u.muav if y.u.muav;
        #
        say "A.J.C.t  /  T.t ist y.mu  among y.u.muav"
            if A.J.V && y.u.muav != 1;
    
lum: |
    u allvy
    
    n lum_thy =>''=>{s=><<''},{code=>'Mo 233',v=>'lumfa',rg=>'bal'}
        # barel! vylum
        # could put these mys on y.u.thing and loop Nautically in 32...
        my $roll = 1;
        my $lum = 3;
        my $i = 0;
        for (@$bal) {
            _.y.thy+=$lum;
            $i++;
            if ($i > $roll) {
                $lum -= $lum * 0.2 if $lum > 0.1;
            }
        }
    
    n spc_lum =>''=>{s=><<''},{code=>'Mo 37',v=>'lum',rg=>'spc'}
        # feel effects of... f eel
        my $upt = 0;
        $spc = $upt if $spc < $upt;
        # t-rewirey formulae:
        my $fs = ($spc / 0.02) * 4;
        C.sc.fs = $fs if $fs < 9;
        C.y.spc = $spc;

