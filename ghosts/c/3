

oJ3: | # MOD  being repeater  - humm
    my $J = Rw oJ31;
    Rw oJ32 + $J;
    return if T.return;
    
    if (!ref $J) {
        if (C.sc.pi) {
            #A.J.most.wq
            $J = Rw spinash $J:A.J;
        }
        elsif (!ref G.way->{$J}) {
            $J = Rw Jto $name:J;
            sayyl "J33   Made J.name";
        }
        else {
            my $o = {name=>C.c.J};
            o.style = delete C.c.style if C.c.style;
            # TODO make func like J.w&oc,style=>C.c;
            # which moves into the wall and percs lamt.
            $J = Rw JJ $o;
            sayyl "J3   Made J.name";
        }
        if (!ref G.way->{J.name}) {
            J.most.eo = 'Yesui';
            J.most.mody = 'mani';
        }
        C.sc.J = $J || die 'want23';
        C.c.s = "Swim" if !exists C.c.s;
    }
    
    my @an =  A.jr->('');
    if (@an && !exists C.c.s) {
        C.c.s = shift @an;
    }
    elsif (!@an && exists C.c.s) {
        A.jr->('',C.c.s);
    }
    die "noovewr   C.c.J ne $J" if ref C.c.J && C.c.J ne $J;
    A.jr&J,$J;
    at.J = $J;
    # ^ gets & replaces, C.sc.J now it
    
    Rw oJ4 + $J;
around: |
     inter({Jname=>ar.J.name}) if ref ar.J;
     die if !ar.J;
     if (!ar.A) {
         saybl "around -- J5 ".(ar.J ? ar.J.name : ki $ar);
         return Rw J5
     }
     die J.name unless ref G.way->{J.name} eq 'HASH';
     
     my $tw = Rw huck + */around;
     
     if (!$tw) {
        Rw up +;
        Rw out +;
     }
     
     saygr "around ! ! J.name ".F_delta()
         unless J.yt.quiet;
     
     # try return stuff? pretty aroundo
     @{(values %$tw)[0]} if $tw

vortex: |
     my $m = ar.m||[];
     my $d = ar.d||4;
     my $o = Rw pul $cs:m way;
     o.way || die;
     
     my $loopr = J.name."%loopid#o.way\t0.3";
     my $id = G.oin.bb->{$loopr};
     saybl "timer replaco J.name o.way" if $id;
     # if last hit and delta are whack
     # tiny hairs of sanity
     Mojo::IOLoop->remove($id) if $id;
     
     my $bl = {};
     bl.id = 
     G.oin.bb->{$loopr} = 
         $G->recur($d => sub {
             return Mojo::IOLoop->remove(bl.id)
                 if G.oin.bb->{$loopr} ne bl.id;
             Rw o.way $J;
         });

