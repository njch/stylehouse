
unThaw: |
    0&&
    n NotStuff =>''=>{s=><<''},{code=>'Mo 29'}
        # should finish us C, the contAiNed are the future
        # 3actally proper
        T.not = 1; # will severato,
        # which shifts A.mo.re.$cv[]
        # swims AZs into @{A.N}
        # SNat also oseveratoes between any .v ish cv groups if @{A.N}
        # also should sort by cv above K
        # SNat before next cv after cv with v, to wide before next
        # as things feed back to ourselves via A.mo.re.$cv[]
        # which is severed (cv shifted) into a new batch of AZ 
        # apparently exude all 3* before loop off down A.N
        # it has something to do with nk in SNat
        # A/sc gets or not ^
        # things can be Wd out real hivey, Jduplicsa en namespace spag
        # they expand around 3-6
        # heres wher eit  gets creal
        # aboput the 2/3 A timey, where rm, compression unfolds
        # oir rhythm style joins
        # also how & 9s (noncompresses) out for us into a more local J
        # u W would zlide in as an Elvis clone
        # it has a high frequency
Modi: |
    # make pool, synth space, want arches
    # fork & rejoin to exciting place
    # the valley, what it means to be here in here YIN
    my $A = Rw WeBase Mo;
    my $I = A.I;
    I.d&n,$A,$C,$G,{};
    I.d&An;
    A.t&1;
    A.t&11111 || warn "NO 1";
    @{A.N}||die"nois".wdump[$C,$A];
    my $i;
    while (@{A.N}) { #                                             à¶¬
        $i++ > 5000 && die " @ Huge Modi";
        my ($A,$C,$T) = I.d&Act,$A;
        # ^this to thisv to 2, returns the finitest A, etc.
        T.not&&next;
        A.t&6;
        T.not&&next;
        I.d&flywheels; # want to outgrow
        T.not&&next;
        A.t&78;
    }
    continue { I.d&z; }
    # 9
    (A.nj) = values %{A.Js} if A.Js && keys %{A.Js} == 1;
    return $A
Modulator: |
    n Space
    n Spaci
    
    n lum
    n bal
    
    n Rings
    n Wrinkles
    
    n Jing
    n Jong
Modular: |
    n Space
    n Spaci
    
    n lum
    n bal
    
    n Rings
    n Wrinkles
    
Wrinkles: | # space refering to itself
    u allvse
    
    n bals =>'',<<'','%code:Mo 201'
        # a non-s
        my $N = C.c.bals;
        $N = [ map { [$_] } split "\n",$N ] if !ref $N;
        my $y = C.y || die"noy";
        y.o && return sayre "bals y o already".wdump[ki $C, $y, I.d&tlM,y.o ];
        y.bal && return sayre "bals y bal already".wdump[ki $C, $y, I.d&tlM,y.bal ];
        y.bal = [];
        # have some minions to od thi:
        A.oA || die "wanting to s bab, no oA";
        Rw In $J:A.J $M:y.bal $N;
    
    # becomes path:
    n pwth =>'',<<'','%code:Mo 42'
        # 8case, to way
        $pwth =~ s/^(?!!)/!/s;
        C.c.path = $pwth;
    
    n id =>'',<<'','%code:Mo 42'
        C.sc.id = $id;
    
    n idly =>'',<<'','%code:Mo 42'
        C.sc.id = mkuid();
    
    n pwar =>'',<<'','%code:Mo 42'
        C.sc.pwar = $pwar;
    
    n path =>'',<<'','%code:Mo 421'
        # install sc path, wants idlyness (indexedness)
        C.sc.path = $path;
        C.sc.idly = 1 if !C.c.fo;
    
C14: | # the CIA is all over it
    # cp gip I.i, particle pullever
    if (my $c = G.pwin->(C.t, A.J.A.in)) { 
        $c = c._ || return;
        # make this a SlideEater
        # a hallucious field coorded on top of everything (I/T)
        say "C.t in: ".wdump $c if !A.J.yt.quiet;
        if (c.D) {
            c.D->($C);
        }
        # love guessing with small pools of stable
        elsif (grep {exists $c->{$_}} qw{t y c sc}) {
            I.d&xot,$C,$c;
        }
        else {
            die "howto ".ki $c;
        }
    }
Rings: | # qualitative space coupling, T phasing (Motion, CCC fuzz filtration)
    u allacgts
    n tlM =>''=><<'',{nov=>1}
        my $os = $s;
        $s = s.M if ref $s eq 'HASH';
        ref $s eq 'ARRAY' || return "S not N/M: ".wdump[$os];
        Rw ZNews $N:s;
    
Space: |
    u allvy
    # ^ always wants a new one somewhere
    # 6* thingalloveries (tangled in self)
    # so v=yo limits C ope to C.y.o existence 
    # things can complain about not matching somewhere
    # resuming back into itselves repeatedly
    # kind of go yonder, certain travelishing
    
    n yo =>''=>{s=><<''},{code=>'Mo 21',v=>'o'}
        $o = C.y.o = {M=>$o} if ref $o eq 'ARRAY';
        o.M ||= [$C];
        # 4d jelly slower-downer
        # so we should acquire many A.t&
        # this is an EC into our C's T.oM, as s.M now
        # stackable A with stitchable others interleaved in time
        # 6 FLIES
        o.M = [grep{defined}map{
            my $d;
            ref $_ || die "oM nonhashi ".wdump 2, o.M;
            d.t = _.t;
            d.y = {%{_.y}};
            d.c = {%{_.c}};
            delete d.y.cv if y.ecv;
            # allow any cv to wander from yarNgrid:
            #y.cvil = 1 if defined d.y.cv;
            d.sc = {%{_.sc||{}}};
            # TRansituio, soul spread
            if (o.ou) {
                # inside our, change slightly how we see
                # spread compound
                d.c.pi = o.ou;
                d.c.s = $_;
            }
            d.sc.oJ = o.oJ if o.oJ;
            # travel agent ^
            # traveli
            Rw C14 $I $A $C:d;
            #
            A.J.V && say "AH A.J.name  ::: d.t   ".ki d.sc;
            keys %$d ? $d : undef
        }@{o.M}];
    
    # deliver news of yonderness
    # having the .o is not so important
    # just somehow the surroundings
    # since they want to effect how we nest about them
    n yon =>''=>{s=><<''},{code=>'Mo 22',v=>'o'}
        my $J = A.J;
        my $Jy = J.C.y; # pi's sea
        # surface tesion, lum
        if (my $lt = C.y.limn) {
            Jy.spc || die "no space ! J.name - C.t keep more numbers";
            my $rl = int(9 * $lt * Jy.spc);
            my $was = @{o.M};
            C.y.rowlisp = $rl;
            C.y.rowas = $was;
            C.y.Jyspc = Jy.spc;
            if ($was > $rl) {
                my @um = @{o.M};
                @um = @um[0..$rl-1];
                @{o.M} = @um;
                # space mod
                my $s = $was;
                n limo=>0.7,"$was>$rl",'%fs:7,hs:7487';
            }
        }
        C.y.bal = o.M || die"nomo";
        # unless y unlimited...until
        o.J = J.most.J if $Jy && Jy.o && Jy.spc > 0.1;
        delete o.J if y.clos;
        my $shut = $Jy && Jy.o && !o.J;
        C.y.over = (Jy.o && Jy.over && Jy.over || 0) + 0.06 if y.o.J;
        #sayre "Jyspace: spc:  J.d.y.spc  or aspace: Jy.aspace" if $Jy;
        # divvy space inside parent's share most J or in 3-4 of the pi
        my $sl = Jy.spc * 0.01;
        $sl = 0.02 if $sl < 0.02;
        C.y.in ||= $shut ? 0.3 : $Jy ? Jy.cv + $sl : 0.1;
        C.y.out ||= $shut ? 0.4 : $Jy ? Jy.ov - $sl : 0.9;
        C.y.lum = y.lumfa if y.lumfa;
Spaci: |
    u allvy
    n '','','%of:Mo';
    # space foyay calcium
    # also lum + bal mingle space
    # distribute display particles
    # could spiral much space away from spine
    
    # build wave plot manifold
    # solar systems
    # 1 things big, 0.9 ended implies to many
    yin 23:
        y.cv ||= 0.1 if !defined y.cv && !defined y.in;
        y.in = y.cv if defined y.cv;
        y.in ||= 0.1;
        y.out = y.in + y.space if defined y.space;
        y.out ||= 0.9;
        y.thi ||= 1;
        if (my $mk = y.ert) {
            $mk += y.ert while y.thi > $mk;
            y.thi = $mk;
        }
        y.space = y.out - y.in;
        y.space *= -1 unless y.space > 0;
        y.aspace = y.space / y.thi;
    
    # twist, lay into segment
    # y.u. shares av, y. separates
    # difference pours out of y.bal via y.i in 32
    yarN 26:
        ref $y eq 'HASH' || die "Notash: ".wdump 2, $C;
        !defined y.u || ref y.u eq 'HASH' || die "Nou : y.u ".wdump 2, $y;
        y.u.v = defined y.cv ? y.cv
            : defined y.in ? y.in
            : die "no yiny".ki$y;
        y.thi || die "Whythi".ki$C;
        die ":idify" if $y ne C.y;
        my @lot = map {
            my $C = eval { I.d&xot,{},$C };
            C.y.i = $_-1;
            $@ && die "Tpp ".wdump 2, $C;
            $C
        } 1..y.thi;
        if (@lot > 1) {
            push @{A.mo.re->{0.29}||=[]}, map{[undef,$_]}@lot;
            T.not = 1;
        }
        else {
            my ($CC) = @lot;
            ref $CC eq 'HASH' || die "not one? $CC";
            %$C = %$CC;
        }
    
    yinvout 3:
        y.mu = 1;
    
    # * bend mu since ^
    # render microdots
    black 34:
        my $was = y.u.v;
        defined $was || die"noAv".ki$C;
        # in:
        y.cv = 0+sprintf '%.6f', y.u.v unless y.cvil && defined y.cv;
        y.pcv = 0+sprintf '%.6f', y.i / C.y.thi;
        # over:
        my $in = y.aspace * y.mu;
        y.u.v += $in;
        # out: 
        y.ov = sprintf '%.6f', y.u.v;
        y.spc = y.ov - y.cv;
        #
        sayyl "Bend: C.t   $was += $in       y.aspace * y.mu       muav:y.u.muav"
            if A.J.V && y.u.muav && y.u.muav != 1;
    
    ent 37:
        $y->{$_} = 0+sprintf('%.6f',$y->{$_}) for qw'cv ov aspace spc';
        C.sc.yspc = y.spc if C.sc.nspc;
        C.sc.ml = (C.y.over * 40)."%" if y.over;

    pin 77:
        return if delete T.oke;
        my $oJ = A.J;
        my $J = C.y.o && C.y.o.J || $oJ;
        my $ar = {};
        ar.s = C.c.s if exists C.c.s;
        Rw jamsc + $J $oJ $C $sc:C.sc;
        sayyl "Hamsc! A.talk: C.t C.y.cv     ".ki(1,{c=>C.c,sc=>C.sc})
            if A.J.V;

    
bal: |
    u ally
    n '','','%of:Mo';
    J.VV.N = 1;
    # yin dating compound, arranges space (4 = given dimensions)
    n bal =>223,<<'',
        y.thi = @$bal;
    
    # yin 23 - space totalled
    # things have masses
    n bal =>241,<<''
        my $total = sum(map { y.thy||1 } @$bal) || 1;
        my $over = @$bal || 1;
        y.u.muav = $over / $total;

    n bal =>301,<<''
        my $CC = $bal->[y.i];
        return T.not = 1 if ref $CC ne 'HASH';
        $CC ||= {};
        I.d&xot,$C,$CC;
        
    n bal =>337,<<''
        y.mu = y.thy if exists y.thy;
        y.mu = y.mu * y.u.muav if y.u.muav;
        #
        say "A.J.C.t  /  T.t ist y.mu  among y.u.muav"
            if A.J.V && y.u.muav != 1;
    
lum: |
    u ally
    n '','','%of:Mo'
    
    # barel! vylum
    # could put these mys on y.u.thing and loop Nautically in 32...
    n lum =>233,<<'','%rg:bal'
        my $um = {};
        (um.l,um.r) = split ',', $lum;
        $um->{$_} =
            $um->{$_} =~ /^(?:(\d+)-)??(?:(\d)+)(?:-(\d)+)?$/
            ? {i=>$1,um=>$2,o=>$3}
            : die "notunder: ".wdump 2, $um
            for grep{defined $um->{$_}} keys %$um;
        saybl "Lum C.t: ". wdump 2, $um;
        um.l.um ||= 3;
        my $lumhalvesby = (um.l.um / 2) / (um.r.um || 3);
        my $i = 0;
        for (@$bal) {
            _.y.thy+=um.l.um;
            $i++;
            if ($i > um.l.o) {
                um.l.um -= $lumhalvesby if um.l.um > 0.1;
            }
        }
    
    n lum =>37,<<'','%rg:spc'
        # feel effects of... f eel
        my $upt = 0;
        $spc = $upt if $spc < $upt;
        # t-rewirey formulae:
        my $fs = ($spc / 0.02) * 4;
        C.sc.fs = $fs;# if $fs < 9;
        C.y.spc = $spc;
Funn: |
    u allvse
    n '','','%of:Mo'
    
    n uni =>33,<<''
        my $c = ref $cs ? $cs : {};
        my @s;
        for my $i (1..(c.thi||24)) {
            my ($b, $dd) = unico(int(d.pcv*1000+$i*100), 1);
            my $entoi = $1 if $i =~ /(\d)$/;
            my $pa = $entoi > 7 ? "  " : $entoi > 3 ? " " : "";
            push @s, $pa.$b;
        }
        C.c.s = join '', @s;
    
    n cow =>33,<<''
        my @col = hexend($cs);
        my @wo = grep{/^[1-9]$/} split '', d.pcv;
        my $wi = sub { $_[0] += $_[1]; $_[0] -= 15 if 15 < $_[0]; };
        my $win = {};
        my $wc = {qw{r 0 g 1 b 2}};
        for (0,1,2) {
             my $wa = $wc->{$_};
             $win->{$_} = $cs =~ /w$wa-(\d)/ ? $1 : $_;
        }
        my $fore = join ' ', @col;
        unless ($cs =~ /no/) {
            my $norgb = $cs !~ /r|g|b/;
            for my $k (keys %$wc) {
                my $n = $wc->{$k};
                my $ad = $wo[$win->{$n}];
                # patch bay ^
                my $mult = 9;
                $mult = $1 if $cs =~ /$k(\d+)/;
                $ad *= ($mult / 9);
                $wi->($col[$n], $ad) if $norgb || $cs =~ /$k/;
            }
        }
        my $col = hexbe(@col);
        d.cs.olo.co = $col;
    
    n fs =>33,<<''
        my ($n1,$n2) = $cs =~ /^($NUM)(?:_($NUM))?/;
        # n1 already 0.4 if it wants to be tiny
        my $siz = $n1;
        if ($n2) {
            my $no = d.pcv;
            my $li = (1/$n2);
            $no -= $li until $no < $li;
            my $mu = $no / $li;
            $siz *= $mu if $mu;
        }
        d.cs.fsgy.fs = int $siz;
    
    n fsx =>33,<<''
        my $si = length(d.c.s);
        my $curve = {40=>6,30=>7,20=>9};
        for (sort keys %$curve) {
            d.cs.fsx.fs = $curve->{$_} if $si > $_
        }
Spirals: |
    u allacgts
    
    n dolphy =>'',<<''
         my $p;
         p.n = 1 + (@$s||9);
         p.ai = 0.06;
         p.modi = { map { $_ => 0.5 } 18..$phi_n };
         my $where = G&phi,$p;
         for my $lv (@$where) {
              # sort out osc way
             J.bz->(j.t."%css#phi"."\t".j.cv =>
                   'position:absolute;'
                   .'top:'.whe.x.'%;'
                   .'left:'.whe.y.'%;'
                   .'-webkit-transform:rotate('.whe.radial.'rad);'
                   .'transform-origin:-10% -10%;' # animate that bit
             ); 
             J.bz->(j.t."%tt#phiro"."\t".j.cv => "^".whe.angle);
                 # + font-size fit + whe.angle
         }
    
    n phi =>'',<<''
        my $n = s.n || 9;
        s.w ||= 100;
        s.h ||= 100;
        my $cx = s.x || (s.w / 2);
        my $cy = s.y || (s.h / 2);
        my $lg_diam = $width * 0.85;
        my $lg_rad = $lg_diam / 2;
        my $outer_rad = $width*0.45;
        my $angle_incr = s.ai || 9 / $n;
        .
          my $xy = [];
          for my $i (1..$n) {
              my $ratio = $i/$n;
              my $spiral_rad = ($ratio *1.3) * $outer_rad;
              my $angi = $angle_incr + 0.15;
              $angi *= ar.modi->{$i} if ar.modi->{$i};
              my $angle = 1.2+$i*$angi;
              my $x = $cx + cos($angle) * $spiral_rad;
              my $y = $cy + sin($angle) * $spiral_rad;
              push @$xy, {
                  radial => sprintf('%.2f', atan2($x - $cx, $y - $cy)),
                  angle => sprintf('%.3f', $angle),
                  x => sprintf('%.2f', $x),
                  y => sprintf('%.2f', $y),
              };
          }
          $xy

