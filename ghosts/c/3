
oJ31: |
    my $f = A.jr&J;
    
    my $j = C.sc.J;
    if (ref $j && ref $f && $j ne $f) {
        die ".sc J dif $f $j";
    }
    if ($f && ref $f && !f.dead) {
        C.sc.J = $f;
    }
    C.sc.J
    
oJ32: |
    if (C.c.X) {
        die "Nofound $J  C.t   C.y.cv" if !ref $J;
        die "noovewr X  C.c.X ne $J" if C.c.X ne $J;
        sayyl "DELING J.name". wdump $C if C.c.X;
        A.jr&J,$J,9;
        J.dead = 1;
        T.return = [];
        return;
    }
    # also how & 9s (noncompresses) out for us into a more local J
    # u W would zlide in as an Elvis clone
    # it has a high frequency
oJ3: | # MOD  being repeater  - humm
    my $J = Rw oJ31;
    Rw oJ32 + $J;
    return if T.return;
    
    if (!ref $J) {
        if (C.sc.pi) {
            #A.J.most.wq
            $J = Rw spinash $J:A.J;
        }
        elsif (!ref G.way->{$J}) {
            $J = Rw Jto $name:J;
            sayyl "J33   Made J.name";
        }
        else {
            my $o = {name=>C.c.J};
            o.style = delete C.c.style if C.c.style;
            # TODO make func like J.w&oc,style=>C.c;
            # which moves into the wall and percs lamt.
            $J = Rw JJ $o;
            sayyl "J3   Made J.name";
        }
        if (!ref G.way->{J.name}) {
            J.most.eo = 'Yesui';
            J.most.mody = 'mani';
        }
        C.sc.J = $J || die 'want23';
        C.c.s = "Swim" if !exists C.c.s;
    }
    my @an =  A.jr->('');
    if (@an && !exists C.c.s) {
        C.c.s = shift @an;
    }
    elsif (!@an && exists C.c.s) {
        A.jr->('',C.c.s);
    }
    die "noovewr   C.c.J ne $J" if ref C.c.J && C.c.J ne $J;
    A.jr&J,$J;
    at.J = $J;
    # ^ gets & replaces, C.sc.J now it
    
    Rw oJ4 + $J;
Elvus: |
    my $Y = Rw El;
    my $oJ = ar.oJ || $J;
    Rw Elvis + $J:oJ $Y;
    $Y

fi: | #c
     my $point = ar.p || ar.pin || ar.m->[0];
     
     my $know;
     if (!ar.pin && ar.J) {
         my $J = ar.J;
         if ($point =~ /^\*\/(\w+)$/) {
             my $inway = $1;
             my $h = ar.h || G.way;
             $h = h.hooks if h.hooks;
             my @gu = @{J.yy.styleord};
             #@gu = @gu[0..5] if @gu > 6;
             my @so;
             for (@gu) {
                if (ref $h->{$_} eq 'HASH' && $h->{$_}->{$inway}) {
                    push @{$know||=[]}, "$_/$inway";
                    last if !ar.sucky;
                }
             }
         }
     }
     
     if (!$know) {
         my %wo = Rw findl +;


         my @keys = map { s/^\///; $_ } keys %wo;
         if (!ar.pin && ar.J) {
             my $J = ar.J;

             @keys = grep { my($K)=split'/',$_; J.yt->{$K} } @keys;
             my @or = @{J.yy.styleord};
             if (@or && @keys > 1) {
                 my $i = 1;
                 my $is = {map{$_=>$i++}@or};
                 @keys = sort {
                  $is->{($a=~/^(.+?)\//)[0]} <=> $is->{($b=~/^(.+?)\//)[0]}
                  } @keys;

                 if (!ar.sucky && @keys > 1) {
                     #sayre "Limiting @keys";
                     @keys = $keys[0];
                 }
             }
         }
         $know = [@keys];
     }
     #saybl "With: ar.J.name  $point    @$know" if ar.J && ar.J.name eq 'shv';
     @$know
around: |
     inter({Jname=>ar.J.name}) if ref ar.J;
     die if !ar.J;
     if (!ar.A) {
         saybl "around -- J5 ".(ar.J ? ar.J.name : ki $ar);
         return Rw J5
     }
     die J.name unless ref G.way->{J.name} eq 'HASH';
     
     my $tw = Rw huck + */around;
     
     if (!$tw) {
        Rw up +;
        Rw out +;
     }
     
     saygr "around ! ! J.name ".F_delta()
         unless J.yt.quiet;
     
     # try return stuff? pretty aroundo
     @{(values %$tw)[0]} if $tw
J6: |
   ar.J = (delete ar.m)->[0] if ar.m;
   # do J=>m not W=>m, looser
   Rw J5 +; 
J3: |
   Rw J5 + $ok=3; 
J5: |
   return sayre "RECUR" if @F > 150;
   my $r = {%$ar};
   r.W = delete(r.m)->[0] if ar.m;
   delete r.R;
   my $J = G.oin;
   my $i = Jn('','',$r);
   my ($s) = @{i.is};
   return s.sc.J||die "no sc J";
vortex: |
     my $m = ar.m||[];
     my $d = ar.d||4;
     my $o = Rw pul $cs:m way;
     o.way || die;
     
     my $loopr = J.name."%loopid#o.way\t0.3";
     my $id = G.oin.bb->{$loopr};
     saybl "timer replaco J.name o.way" if $id;
     # if last hit and delta are whack
     # tiny hairs of sanity
     Mojo::IOLoop->remove($id) if $id;
     
     my $bl = {};
     bl.id = 
     G.oin.bb->{$loopr} = 
         $G->recur($d => sub {
             return Mojo::IOLoop->remove(bl.id)
                 if G.oin.bb->{$loopr} ne bl.id;
             Rw o.way $J;
         });

