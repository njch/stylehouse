cscomp: |
    my $non = {%$d};
    my $de;$de = sub {
        my $v = shift;
        ref $v eq 'ARRAY' ?  [map{ $de->($_) } @$v]
        : !ref $v ? $v
        : v.id || die "no v".wdump(2,$v);
    };
    for my $k (qw'c sc') {
        my $v = $non->{$k} || next;
        $non->{$k} = $v = {%$v};
        for my $sk (keys %$v) {
            my $sv = $v->{$sk};
            $v->{$sk} = $de->($sv);
        }
    }
    non.cv = ''.non.cv;
    non.s = $de->(non.s);
    return sjson $non
Ha:
   yJ: |
     'Ha'
   around: |
     my $now = hitime();
     return if J.last > $now - 0.4 || G.pslagtil > $now;
     $now - J.last < 9 && Rw vortex around $J $d=5;    
     J.last = $now;
     G.ino ||= $J;
     
     my $N = Rw tc $J;
     my $lcv;
     my $i;
     for my $d (@$N) {
         my $n = d.c.s;
         
         my $com;
         my $dont;
         if (d.sc.watime) {
             my $del = d.sc.watime - hitime;
             $com = "w\@in ".sprintf('%.3f',$del);
             if ($del > 0.02) {
                 if (d.sc.watime != d.sc.watimed) {
                     # & shift out Ha 6
                     #sayyl "WAYLAY $del to n.t";
                     my $ip = {l=>d.t,cv=>d.y.cv};
                     timer $del {
                        Rw around $J;
                     };
                     J.bz->("d.t%watimed\t".d.y.cv => d.sc.watime);
                 }
                 $dont = 1;
             }
             
         }
         #my $mers = "WAITS  ".slim(10,d.t)."  n.t\t d.y.cv  $com  ".ki (1,n.c)." \t\t";#.d.sc.pict;
         #$dont ? saybl $mers : sayyl $mers;
         next if $dont;
         
         Rw hoset + $d;
         #sayyl "RE& n.t  at d.y.cv  d.sc.pict";
         
         timer 0.001 {
             Rw oo $J:G.oin $d:n;
         };
         
         $i++;
         last if $lcv && $lcv > d.y.cv;
         $lcv = d.y.cv;
     }
somewhere: |
     my @path = ar.j.sc.J || ar.j.J;
     while (1) {
        my $l = $path[0];
        unshift @path, l.Jiter || last;
     }
     #saybl wdump 2, ["Gootblock:",@path];
     
     say "avoid: ".gp shift @path until !@path || $path[0] eq $J;
     shift @path;
     my $path = join '/', map{_.d.t} @path;
     
     my $A = J.A;
     my $v = $G->suet($A, "in/$path");
     my $amo = 1.5;
     $amo = 0.8 if e.S;
     (v._.y.thy ||= 1) *= $amo;
     say "A in assign". wdump 14, [gp($J), $path, $v];
     return;
     
     #die wdump 2, [@lspath]; 
     #my $path = join '/', reverse @lspath;
     my $M = [];
     Mn('fro',{},"$path",'{ou:file}');
     Rw J5 wut $M;
join/up: |
       # G.oin root ww:
       Rw J5 wu;
       # iterations:
       Rw J5 toc;
       Rw J5 Ha;
paintaj: |
     aj.Wid || die "not Wid?";
     aj.hol = "H.style/H.name/H.id";
     aj.hitime = hitime;
     aj.name ||= aj.J.name;
     

    
zipline: |
     if (aj.J.yt.clw) {
         Rw J5 shv $aj;
     }
     
     my $c = aj.c;
     die 'scs' if @{aj.sc};
     die 's' if aj.s;
     my $M = ['','',{W=>G.Wid},{z=>aj.c}];
     #sayyl wdump 15, $M;
     aj.c = [" a\.om({},".sjson($M).",a,{});"];
     aj.sent = 1;
     
     return 0;
     
     Rw paintaj $aj;
     # also some J.headlev readings for .i
     
     G.Wh->{aj.Wid} ||= do {
         my $ij = {}; map {
         $ij->{$_} = $aj->{$_} if !/^[sc]+/; } keys %$aj;
         ij.id = delete ij.Wid;
         ij.y = 'W';
         
         sayyl "Life! of ij.y ij.id"; 
         0->tai("ij.y/ij.id\.i", $ij);
         0->tac("V/H.style/H.name/H.id\.s", ztm($ij));
         aj.J;
     };

     Rw J5 wu $aj;
     
     aj.y ||= 'J';
     aj.yy = 'W';
     Rw aji $aj;
     Rw blabaj $aj;
     
     1
thy: |
     my $o = Rw pul + pin;
     o.pin ||= ar.p;
     my $wt = ar.anon ?
         Rw wuck $J $pin:o.pin
     :
         Rw wuck $J */o.pin;
     warn "no o.pin          for ".gp($J) if !$wt;
     
     my $nc = 1;
     
     my @keys = sort keys %$wt;
     if (my $or = J.yt.styleord) {
         my ($na,@or) = @$or;
         push @or, $na; # me is most
         my $i = 1;
         my $is = {map{$_=>$i++}reverse @or};
         @keys = sort {
          $is->{($a=~/^(.+?)\//)[0]} <=> $is->{($a=~/^(.+?)\//)[0]}
          } @keys;
          
         if (@keys > 1) {
             sayre "Limiting @keys";
             @keys = $keys[0];
         }
     }
     
     #sayyl " J.name  thys => @keys";
     
     $J = ar.oJ || $J;
     for my $k (@keys) {
         my $N = $wt->{$k};
         
         my $coi = Rw pha $J $k;
         
         my $d = ref $N ? ejson($N) : $N;
         
         coi.qui = 1 if ar.q;
         next if !ar.almod && Rw ph_same $J $x:coi $d;
         
         $N = [ map { [$_] } split "\n",$N ] if !ref $N;
         
         #say " ** waything $what from $k";
         Rw MyN $N $J;
          
         my $y = coi.exactl->();
         $nc = 0 if !y.same;
     }
     $nc = -1 if !%$wt;
     $nc
hoset: |
    my @r = map { d.t.($_?'%'.$_:'')."\t".d.y.cv } '', keys %{d.sc};
    delete J.bb->{$_} for @r;
    
hosin: |
    n.sc = ar.sc if ar.sc; n.c.s = n.s if exists n.s; n.y.cv = n.cv if n.cv;
    my @glu = map { '%'.$_ => n.sc->{$_} } sort keys %{n.sc};
    J.bz->(n.t."\t".n.y.cv => n.c.s, @glu);
comb: |
    # so that J.2 etcs declare needs and resume when ready
    my $iJ = G.ino || return do{warn "no loop";1}; # continues the Atime
    
    
    A.selif = Rw cscomp $d $ig:A.note;
    my $dig = dig A.selif;
    
    die "wamngle $wa" if $wa != int($wa) || $wa < 1 || $wa > 9;
    die 'noiJ' if !$iJ;
    
    my $n;
    n.sc.pict = A.selif;
    n.sc.watime = A.watime if A.watime;
    $wa = A.waov if A.waov;
    n.cv = $wa / 10;
    n.s = {%$d};
    n.t = $dig;
    
    #sayyl "COMB J.name  d.t  A.ztime } to $wa \t ".ki 1,d.c;
    
    Rw hosin $J:iJ $n;
    0;

