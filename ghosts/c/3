
oJ31: |
    my $f = A.jr&J;
    
    my $j = C.sc.J;
    if (ref $j && ref $f && $j ne $f) {
        die ".sc J dif $f $j";
    }
    if ($f && ref $f && !f.dead) {
        C.sc.J = $f;
    }
    
    C.sc.J
    
oJ32: |
    if (C.c.X) {
        die "Nofound $J  C.t   C.y.cv" if !ref $J;
        die "noovewr X  C.c.X ne $J" if C.c.X ne $J;
        sayyl "DELING J.name". wdump $C if C.c.X;
        A.jr&J,$J,9;
        J.dead = 1;
        T.return = [];
        return;
    }
    # also how & 9s (noncompresses) out for us into a more local J
    # u W would zlide in as an Elvis clone
    # it has a high frequency
C14: | # the CIA is all over it
    # cp gip I.i, particle pullever
    if (my $c = $G->gip(A.J.A.in, C.t)) { 
        $c = c._ || return;
        # make this a SlideEater
        # a hallucious field coorded on top of everything (I/T)
        say "C.t in: ".wdump $c if !A.J.yt.quiet;
        if (c.D) {
            c.D->($C);
        }
        # love guessing with small pools of stable
        elsif (grep {exists $c->{$_}} qw{t y c sc}) {
            I.d&extend,$C,$c;
        }
        else {
            die "howto ".ki $c;
        }
    }
oo3: | # MOD  being repeater  - humm instyead of oJ3, oJ* is
    my $J = Rw oJ31;
    # A/sc gets or not ^
    # things can be Wd out real hivey, Jduplicsa en namespace spag
    # they expand around 3-6
    # heres wher eit  gets creal
    Rw oJ32 + $J;
    # aboput the 2/3 A timey, where rm, compression unfolds
    # oir rhythm style joins
    return if T.return;
    
    if (!ref $J) {
        Rw oo33 + $J;
    }
    
oo33: |
    # doof, we are creating a J
    # A.c shall
    die "refJoo33 $J" if ref $J;
    $J = Rw Jto $name:J;
    
    if (A.c&pi) {
        j.Jiter = $J; # erse rev
        j.most->{$_} = J.most->{$_} for keys %{J.most||{}};
    }
    
    sayyl "J33   Made J.name";
    C.sc.J = $J || die 'watt';
    
    C.c.s = "Swim" if !exists C.c.s;
    my @an =  A.jr->('');
    if (@an && !exists C.c.s) {
        C.c.s = shift @an;
    }
    elsif (!@an && exists C.c.s) {
        A.jr->('',C.c.s);
    }
    die "noovewr   C.c.J ne $J" if ref C.c.J && C.c.J ne $J;
    A.jr&J,$J;
    at.J = $J;
    # ^ gets & replaces, C.sc.J now it
    
    Rw oJ4 + $J;
Space: |
    u allvy
    # ^ always wants a new one somewhere
    # 6* thingalloveries (tangled in self)
    # so v=yo means t/y/c/sc,? off nk,gk, which act=>1 if A.c ping
    # things can complain about not matching somewhere
    # v also means 6 flies N by cvoup in SNat, resuming back into itselves repeatedly
    # v could args.=gk=>$gk
    # kind of go yonder, certain travelishing
    n yo =>''=>{s=><<''},{code=>'Mo 21',v=>'o'}
        $o = C.y.o = {M=>$o} if ref $o eq 'ARRAY';
        o.M ||= [$C];
        # 4d jelly slower-downer
        # so we should acquire many A.t&
        # this is an EC into our C's T.oM, as s.M now
        # stackable A with stitchable others interleaved in time
        # 6 FLIES
           o.M = [grep{defined}map{
               my $d;
               d.t = _.t;
               d.y = {%{_.y}};
               d.c = {%{_.c}};
               delete d.y.cv;
               d.sc = {%{_.sc||{}}};
               # TR
               if (o.ou) { # inside our, change slightly how we see, spread compound
                   d.c.pi = o.ou;
                   d.c.s = $_;
               }
               d.sc.oJ = o.oJ if o.oJ;
               Rw oC43 $I $A $C:d;
               A.J.V && say "AH A.J.name  ::: d.t   ".ki d.sc;
               keys %$d ? $d : undef
           }@{o.M}];
    
    # deliver news of yonderness
    # having the .o is not so important
    # just somehow the surroundings
    # since they want to effect how we nest about them
    n yon =>''=>{s=><<''},{code=>'Mo 22',v=>'o'}
         my $J = A.J;
         my $Jy = J.C.y; # pi's sea
         if (my $lt = C.y.limn) {
             my $rl = int(9 * $lt * Jy.spc);
             my $was = @{o.M};
             if ($was > $rl) {
                 my @um = @{o.M};
                 @um = @um[0..$rl-1];
                 @{o.M} = @um;
                 # space mod
                 my $s = $was;
                 Jn("lim",0.7,"$was>$rl",'%fs:4,hs:7487');
             }
         }
         C.y.bal = o.M || die"nomo";
         # unless y unlimited...until
         o.J = J.most.J if $Jy && Jy.o && Jy.spc > 0.1;
         my $shut = $Jy && Jy.o && !o.J;
         C.y.over = (Jy.o && Jy.over && Jy.over || 0) + 0.06 if y.o.J;
         #sayre "Jyspace: spc:  J.d.y.spc  or aspace: Jy.aspace" if $Jy;
         # divvy space inside parent's share most J or in 3-4 of the pi
         my $sl = Jy.spc * 0.1;
         C.y.in ||= $shut ? 0.3 : $Jy ? Jy.cv + $sl : 0.1;
         C.y.out ||= $shut ? 0.4 : $Jy ? Jy.ov - $sl : 0.9;
         C.c.lumfa = 1 if y.lumfa;
Spaci: |
    u allvy
    
    n yall =>''=>{s=><<''},{code=>'Mo 221'}
       C.y = {thi => C.y} if !ref C.y;
           
    n yin =>''=>{s=><<''},{code=>'Mo 23'}
        # build wave manifold, fore loop
       die "cv+in".k2 $C if y.cv && y.in;
       y.in ||= 0.1; 
       y.out ||= 0.9; # up to
       y.thi ||= 1; 
       y.space = y.out - y.in; # could spiral much space away from spine
       y.space *= -1 unless y.space > 0;
       y.aspace = y.space / y.thi;
    
    0&&# 
    n yin =>''=>{s=><<''},{code=>'Mo 26'}
       # twist, lay into segment
       A.v = defined y.cv ? y.cv : defined y.in ? y.in : die "no yiny".ki$y;
       my $wJ = A.wJ;
       for (1..y.thi) {
           my $T = {};
           g.extend->($T, $C);
           T.y.i = $_-1;
           push @{A.is}, $T;
           for my $ct (@{wJ.cts.B}) {
               next unless ct.any or exists $C->{ct.t_k} && exists $C->{ct.t_k}->{ct.t};
               my $v = $C->{ct.t_k}->{ct.t} unless ct.any;
               
               wJ.ctx.B->{ct.x}->($A,$C,$g,$T,T.y);
           }
           say "KAp T.t  T.y.cv   spc=T.y.spc    (".(1+T.y.i)." / C.y.thi)" if A.J.V && C.y.thi != 1;
       }
       #sayyl wdump 2, A.is;
r2j: | # interpreter of buzzed puit partiscules r -> j.[cv,t,style]
    my $j;
    my $sing;
    if (J.tt) {
        $sing = 'J_tt';
        (j.cv,j.t,j.style) = $r =~ /^(.*?)\t(.*)\t(.*?)$/;
    }
    else {
        (j.t,j.style,j.cv) = $r =~ /^(.+?)(?:%(.+))?\s+(.+?)$/;
    }
    defined j.cv || die "$sing no $r    ".ki $j;
    j.s = ar.J.bb->{$r} if ar.J;
    j.nos = 1 if ar.J && !exists ar.J.bb->{$r};
    $j;
Ajr: | # shed A.jr bb io, aimed for J and cv,t (of C?)  send $style,$v
    sub {
        my ($s,$v,$d) = @_;
        my $isv = @_ >= 2;
        my $isd = @_ >= 3;
        my $t = exists ar.t ? ar.t : ar.C.t;
        my $cv = exists ar.cv ? ar.cv : ar.C.y.cv;
        my $r;
        if (J.tt) { # FUTU
            $r = $cv."\t".$t."\t".$s;
        }
        else {
            $s = '%'.$s if $s;
            $r = $t.$s."\t".$cv;
        }
        if ($isd) {
            sayre "delbbl $r  $d   J.name" for 1..5;
            return delete J.bb->{$r};
        }
        defined $v ? 
            saybl "J.name chuck $r     $v  <--  ".J.bb->{$r}
          : saygr "J.name read $r"
            if J.V;
        !$isv ?
          !exists J.bb->{$r} ? () : J.bb->{$r}
        : do {
            J.bz->($r, $v);
            sub { delete J.bb->{$r} } 
        };
    };
jamsc: |
    ar.C = ar.d if ar.d;
    my $t = ar.t ? ar.t
        : ar.j ? ar.j.l
        : ar.C ? ar.C.t : die'not';
    my $cv = ar.cv ? ar.cv
        : ar.j ? ar.j.cv
        : ar.C ? ar.C.cv || ar.C.y.cv : die'noy';
    if (ar.oJ && ar.oJ ne ar.J && !ar.noR) {
        my $J = ar.oJ;
        if (my $ljm = J.A.ljm) {
            my $Me = "ar.oJ.ind ar.J.name "
            ." J.A.ljmo <<< J.name  sends:"
            ." $t\t$cv  $ljm";
            sayyl $Me if J.V || ar.J.V;
            push @$ljm, {%$ar};
        }
    }
    J.bz->("$t\t".$cv => ar.s) if exists ar.s;
    for my $k (sort keys %$sc) {
        my $v = $sc->{$k};
        J.bz->("$t%$k\t".$cv => $v);
        ar.C.sc->{$k} = $v;
    }
scd: | # AJ sc looking at an ov (lv) (Y.rv) to given iv - reflect as simp[le
    my $r;
    r.in = @{ov.sc};
    r.out = @{iv.sc}-1;
    r.ay = [r.in..r.out];
    r.z = [@{iv.sc}[@{r.ay}]];
    $r

