

oJ3: | # MOD  being repeater  - humm
    my $J = Rw oJ31;
    Rw oJ32 + $J;
    return if T.return;
    
    if (!ref $J) {
        if (C.sc.pi) {
            #A.J.most.wq
            $J = Rw spinash $J:A.J;
        }
        elsif (!ref G.way->{$J}) {
            $J = Rw Jto $name:J;
            sayyl "J33   Made J.name";
        }
        else {
            my $o = {name=>C.c.J};
            o.style = delete C.c.style if C.c.style;
            # TODO make func like J.w&oc,style=>C.c;
            # which moves into the wall and percs lamt.
            $J = Rw JJ $o;
            sayyl "J3   Made J.name";
        }
        if (!ref G.way->{J.name}) {
            J.most.eo = 'Yesui';
            J.most.mody = 'mani';
        }
        C.sc.J = $J || die 'want23';
        C.c.s = "Swim" if !exists C.c.s;
    }
    
    my @an =  A.jr->('');
    if (@an && !exists C.c.s) {
        C.c.s = shift @an;
    }
    elsif (!@an && exists C.c.s) {
        A.jr->('',C.c.s);
    }
    die "noovewr   C.c.J ne $J" if ref C.c.J && C.c.J ne $J;
    A.jr&J,$J;
    at.J = $J;
    # ^ gets & replaces, C.sc.J now it
    
    Rw oJ4 + $J;
around: |
     inter({Jname=>ar.J.name}) if ref ar.J;
     die if !ar.J;
     if (!ar.A) {
         saybl "around -- J5 ".(ar.J ? ar.J.name : ki $ar);
         return Rw J5
     }
     die J.name unless ref G.way->{J.name} eq 'HASH';
     
     my $tw = Rw huck + */around;
     
     if (!$tw) {
        Rw up +;
        Rw out +;
     }
     
     saygr "around ! ! J.name ".F_delta()
         unless J.yt.quiet;
     
     # try return stuff? pretty aroundo
     @{(values %$tw)[0]} if $tw

