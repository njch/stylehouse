already: | # allready, proto WeBase
    # note ar.*
    my $s = $ar;
    my $N = s.N;
    
    if (my $oA = s.oA) {
        # preserve babs within babs
        my $D = oA.D;
        Rw babsubrip $oA $D $N
            if substr(D.bab, 0, 200) =~ /<<''/;
    }
    # and similar from-above thing ^ some point in 1
    
    my $A = {};
    A.mo = $A;
    A.N = [@$N];
    A.M = [];
    A.J = s.J || die 'noJ';
    A.am = s.am || die "unsame?";
    # ^ should then know how to v
    A.fl = ar.fl || {};
    A.I = {};
    my $dont;
    if (my $I = delete G.drop.recycling->{A.J.id}->{A.am}) {
        A.I = $I;
        $dont = 1;
        A.cv = 0.1;
    } # hit/miss to analyse, when I drops in completely we cna drop:
    unless ($dont) { # turning into some...
        ar.I = A.I;
        Rw I_Din;
        Rw C_C;
        Rw C_E;
        Rw I_D;
        Rw I_Ci;
        Rw I_Cr;
    }
    $A
In: | # I I I
    J.A.Indo && return Rw Intt;
    
    my $A = Rw already + $am=In $N;
    my $I = A.I;
    I.d&n,$A,{},$G,{};
    I.d&An;
    A.t&1;
    
    A.t&11111 || warn "NO 1";
    # 
    
    # 2821:      keys arrive as characters already:
    # prep A for A (I), J-sessioned etc stuff
    # is literal G spacer, index jointed bunch of code to check out from w
    # some comp could expectorate lots charstream rhythms ^
    # Z flow?
    # or we could do on a stick,
    # so its MZ junk dont linger in this stream
    # ie always flow outwards the sc filtery stuff.
    my $i;
    while (@{A.N}) { #
        $i++ > 1000 && die "Huge In";
        my $s = shift @{A.N};
        my $C = {};
        my $T = {};
        my $A = {%$A};
        A.mo.on = $A;
        A.s = $s;
        T.oM = [];
        I.d&n,$A,$C,$G,$T;
        I.d&An;
        A.t&2;
        
        I.d&Ci,$s;
        ($A,$C) = @{T.grabac} if T.grabac;
        
        I.d&z && next if T.not;
        I.d&Cr,$s;
        A.t&6;
        I.d&z && next if T.not;
        
        # elabourate C,
        for my $k (sort keys %{A.fl}) {
            my $v = A.fl->{$k};
            $k = $2 if $k =~ /^(\d+) (.+)$/;
            Rw ym/$k $I $J $A $C $v $G $T;
        }
        I.d&z && next if T.not;
        
        
        push @{T.oM}, $C;
        
        A.t&7;
        I.d&z;
    }
    
    I.d&recycle;
    
    my $M = ar.M;
    if ($M) {
        push @$M, uniq @{A.M}
    }
    elsif ($J) {
        map {
           Rw mani + $J $C:_
        } @{A.M}
    } else {
        die "noJM";
    }
    
I_Din: |
    I.n = sub { # A qcui
        my ($A,$C,$G,$T,$AA,$CC,$GG,$TT) = @_;
        I.nF = {A=>$AA,C=>$CC,G=>$GG,T=>$TT};
    };
    I.d = sub { # be, sub
        my $s = shift;
        my $P = I.nF ||= {};
        my $y = $I->{$s};
        if (!$y) {
            return if $s eq 'oseverato';
            die "no I way named '$s'";
        }
        $y->(P.A,P.C,P.G,P.T,@_);
    };
    I.z = sub {
        my ($A,$C,$G,$T) = @_;
        push @{A.M}, @{T.oM};
        1
    };
    I.moy = sub { # groups, to spread
        my ($A,$C,$G,$T,$s) = @_;
        my $i = A.mo.y->{$s}||die"no$s";
        my $is = $i->{C.y.p}; # things in our C's pool
        {is=>$is,N=>[map{$is->{$_}}sort keys %$is]};
    };
C_E: |  # elvission/I joinsession/c convene
    # u/n/m get here, we know ar.
    # here we step further into the light grabbing
    # parts spine up from In's A the In, using qqJ.A
    # but the broken tiles of use cassettes- culture eddies, vines of intuit
    I.An = sub { # A within faller # wants to I 2, throw subs on A directly...
        my ($A,$C,$G,$T) = @_;
        A.note = {}; # pinging csc
        A.c = sub { I.d&c,@_; };
        A.t = sub { I.d&t,@_; };
        $A
    };
    Rw C_D;
C_D: |
    I.t = sub {
        my ($A,$C,$G,$T)=splice @_,0,4;
            my ($cv,$K) = reverse @_;
            @_>2 && die "big fat time:".wdump[@_];
            $K ||= A.am||die"noam A_t";
            my $i = # much mergey extendo rubble, 
                 $G->gip($A,'J/A/I') || {};
            
            my $c = 0+("0.".$cv);
            my $ncv;
            my $re;
            my $dont;
            die'danK' if $K ne 'In';
            if (A.cv < 0.6 || $c >= 0.7) {
                if ($c >= A.cv) {
                    $ncv = $c;
                    $re = 1;
                }
                else {
                    $re = 0;
                    $dont = 1;
                    say " DeInc A.cv - $cv $c" if J.V;
                }
                die "pre bigger" if $cv < A.cv;
            }
            else {
                if ($c < A.cv) {
                    if (A.cv == 0.6) { # scoop up all on entering timezone
                        $re = 1;
                        $dont = 1; # or will IIII fall away
                    }
                    else {
                        $re = 0;
                        $dont = 1;
                    }
                }
                elsif ($c == A.cv) {
                    $re = 1;
                }
                elsif ($c > A.cv) { # and $c < 0.7
                    T.Z->{$c} = 1;
                    $re = 0;
                    $dont = 1;
                }
                else {die"nof"}
            }
            if ($cv == 7) {
                if (my $z = T.Z) {
                    my ($lo) = sort keys %$z;
                    # each thing emits just the next one
                    @{T.oM} = ();
                    push @{A.mo.re->{$lo} ||= []}, [$A,$C];
                    undef $ncv;
                }
                if (!@{A.mo.N}) {
                    my $ats = A.mo.re || {};
                    my @wa = sort keys %$ats;
                    my ($lo) = @wa;
                    if ($lo) {
                        my $ay = delete $ats->{$lo};
                        my @N = map { {AZ=>{$lo=>$_}} } @$ay;
                        #sayyl "Loop A.cv > $lo x ".@N;
                        push @{A.mo.N}, @N;
                    }
                }
            }
            
            # break off at 1,2
            I.d&ex,$i,$K=>$cv
                unless $dont;
            A.cv = $ncv if defined $ncv;
            $re;
    };
    I.ex = sub {
        my ($A,$C,$G,$T,$i,$K,$cv) = @_;
        my $c = 0+("0.".$cv);
        my $talk = "A.J.name ".(A.J.le && A.J.le.name).": $K A.cv > $c --- C.t ";
        unless ($c =~ /^0\.[1267]$/) {
            #sayyl "\t\t\t: $talk   ".keys %$i if A.J.V;
        }
        my $aim = {$K=>1};
        aim.I = 1 if $aim->{A.am};
        
        for my $k (sort keys %$i) {
            my $ii = $i->{$k};
            ref $ii eq 'HASH' || die "wei $k ".ki $i;
            
            $aim->{$k} || #sayyl("$talk \t other: $k") &&
                next;
            # ^ or what group be are doing.... looper inner higher
            
            for my $vc (sort keys %$ii) {
                my $iii = $ii->{$vc};
                
                die unless $vc < 1;
                $vc <= A.cv #&& sayre("$talk \t before: $K $vc")
                    && next;
                $vc > $c #&& sayre("$talk \t after: $K $vc")
                    && next;
                
                #sayre "intriasm $talk  \t ov: $k $vc" if $c ne $vc;
                for my $ik (sort keys %$iii) {
                    my $D = $iii->{$ik};
                    sayre "DEEE $talk $k > $vc  D.t D.y.cv  ". ki D.sc
                        if A.J.V;
                    die if D.sc.gk;
                    
                    my $act;
                    my $dont;
                    if ($k ne 'I' && D.sc.acgt) {
                        $act = 1;
                        $dont = 1 if exists A.I->{D.t};
                    }
                    
                    unless ($dont) {
                        my $paw = join"_",'',$k,$vc,D.t;
                        $paw =~ s/\W//g;
                        Rw $paw $A $C $G $T $__D:D;
                    }
                    
                    # non-I acgt means some expressed tick of the creature
                    # as osc accesses
                    if ($act) {
                        D.sc.acgt eq 's'||die "nonacgts";
                        exists A.I->{D.t}||die "acgtI D.t not up: ".ki A.I;
                        I.d&D.t,A.s;
                    }
                    
                }
            }
        }
    };
I_Cr: | # work the corner
    # kind of apply filters as they like to chew, ripping from string theirs, later congealing...
    # maybewa u and n of the ym is the way way
    # it doubles
    I.Crey = sub { # work the y corner
        my ($A,$C,$G,$T) = @_;
        if (C.y eq '') { # is or undef
            C.y = {};
        }
        elsif (C.y =~ /^($NUM)$/) {
            C.y = {cv=>$1};
        }
        elsif (C.y =~ /^($NUM)-($NUM)$/) {
            C.y = {from=>$1,to=>$2};
        }
        else {die "strung ny: C.y".wdump $C};
    };
    I.Crec = sub { # work the c corner
        my ($A,$C,$G,$T) = @_;
        if (!ar.c_is && C.c =~ I.peels) {
            C.c = I.d&peel,C.c;
        }
        else {
            C.c = {s => C.c};
        }
    };
    I.Cresc = sub { # work the c corner
        my ($A,$C,$G,$T) = @_;
        if (C.sc eq '') {
            C.sc = {};
        }
        elsif (C.sc =~ I.peels) {
            C.sc = I.d&peel,C.sc;
        }
        else { die "nostr  C.sc    ".ki $C }
    };
I_D: |
    I.Ci = sub { # 3 rip out of space
        my ($A,$C,$G,$T,$s) = @_;
        if (!ref $s) {
            I.d&string,$s;
        }
        elsif (ref $s eq 'ARRAY') {
            I.d&array,$s;
        }
        elsif (ref $s eq 'HASH') {
            I.d&hash,$s;
        }
        else { die "mmtype:$s" }
    };
    I.hash = sub {
        my ($A,$C,$G,$T,$s) = @_;
        if (s.t && s.y && s.c) {
            sayre "HASHIN no sc: ".ki $s if !s.sc;
            %$C = %$s;
            return;
        }
        # a Ci dome, In 3-4 looking at N[.+,{c}]
           s.AZ ? I.d&AZu,s.AZ
           : s.MZ ? I.d&MZu,s.MZ
           : s.EZ ? I.d&EZu,s.EZ
           : s.WZ ? I.d&WZu,s.WZ
           : s.EC ? I.d&ECu,s.EC
           : die 'hash: '.wdump($s);
    };
    I.array = sub {
        my ($A,$C,$G,$T,$s) = @_;
            if (@$s == 1) {
                my ($s) = @$s;
                ref $s && die "1striong: ".wdump $s;
                I.d&fourstring,$s
            }
            else {
                I.d&fourreal,$s
            }
    };
    I.string = sub {
        my ($A,$C,$G,$T,$s) = @_;
        die "string: $s ".wdump A.s;
    };
    I.Cr = sub { # 6 work the corner
        my ($A,$C,$G,$T) = @_;
        die"reft" if ref C.t;
        I.d&Crey if !ref C.y;
        I.d&Crec if !ref C.c;
        I.d&Cresc if !ref C.sc;
        C.y.cv /= 10 while C.y.cv <= -1 || C.y.cv >= 1;
    };
I_Ci: | # receive topu
    I.fourstring = sub { # barse
        my ($A,$C,$G,$T,$s) = @_;
        # sticks out of usual c 5 hive of MZ/awarey things
        if ($s =~ /^\s*#?\s*MZ (.+)$/) {
           I.d&MZu, $1;
        }
        # the rest of this stuff lies here more, eating a string of lumps
        # if we were reading lines the N[$line] hop would neg
        # modem sounds etc.
        # dome props, repeatable tests
        elsif ($s =~ /^\s*(#.*)$/) {
           T.not = 1;
           T.com = $1;
        }
        elsif ($s eq '') {
           T.not = 1;
           T.space = 1; # could mean sticks
        }
        else {
           my $ci = $s;
           for my $nk (qw't y c sc') {
               if ($ci =~ s/^(\S+) *//) { # some t are types of space
                   my $v = $1;
                   $v = I.d&peel,$v if $nk ne 't' && $v =~ I.peels;
                   $C->{$nk} = $v;
               }
           }
        }
    };
    I.fourreal = sub {
        my ($A,$C,$G,$T,$s) = @_;
        (C.t, C.y) = @$s;
        C.c  = $s->[2] if exists $s->[2];
        C.sc = $s->[3] if exists $s->[3];
        die'@>4'.wdump $s if @$s > 4;
        die"C.t from ".wdump $s if ref C.t; # dive
    };
    
    I.servehash = sub {
        my ($A,$C,$G,$T,$s) = @_;
          s.AZ ? I.d&AZu,s.AZ
        : s.MZ ? I.d&MZu,s.MZ
        : s.EZ ? I.d&EZu,s.EZ
        : s.WZ ? I.d&WZu,s.WZ
        : s.EC ? I.d&ECu,s.EC
        : die 'hash: '.wdump($s);
    };
    
    I.peels = qr/^[\{\%]/;
    I.peel = sub { # simple as hash from string
        my ($A,$C,$G,$T,$s) = @_;
        $s =~ s/^%// || 
            $s =~ s/^{// && $s =~ s/}$//
            || die "unpealable $s";
        my $c;
        for (split ',', $s) {
            my ($k, $v) = split ':', $_, 2;
            $v = 1 if !defined $v;
            $c->{$k} = $v;
        }
        $c||{}
    };
    I.MZu = sub { # fl apply, strangely, meta zip oi, applu guvtion
        my ($A,$C,$G,$T,$s) = @_;
        my $uM = sub {
            my ($k,$v) = @_;
            if (defined $v && $v eq '0') {
                delete A.fl->{$k}
            }
            else {
                A.fl->{$k} = $v || 1;
            }
        };
        if (ref $s eq 'HASH') {
            $uM->($_,$s->{$_}) for keys %$s;
        }
        else {
            for (split /\s+/, $s) {
                /^(.+?)(?::(.+))?$/ || die;
                $uM->($1,$2);
            }
        }
        T.not = 1;
    };
    I.iZu = sub {
        my ($A,$C,$G,$T,$s) = @_;
        my $way = 'muck';
        $way = 'fund' if $s =~ s/^\///;
        my $Z = Rw $way - $p:s $dclone=1;
    };
    I.EZu = sub {
        my ($A,$C,$G,$T,$s) = @_;
        
        my $Z = I.d&iZu,$s;
        for my $k (sort keys %$Z) {
            my $N = $Z->{$k};
            $N = [ map { [$_] } split "\n",$N ] if !ref $N;
            Rw In $M:T.oM $N;
        }
        T.not = 1;
    };
    I.WZu = sub { # clomne N appends this N, width firstappend us
        my ($A,$C,$G,$T,$s) = @_;
         
        my $Z = I.d&iZu,$s;
        for my $k (sort keys %$Z) {
            my $s = $Z->{$k};
            die wdump $s if ref $s ne 'ARRAY';
            unshift @{A.N}, @$s;
        }
        T.not = 1;
    };
    I.ECu = sub { # extend C on the way in to another dome, magnetised into our M
        # probably for collapsing roooves...
        # dumber than sc decompresphere & playing out
        # (is mailing itself further instructions, intro c, further lines)
        # an In persona, joining our M
        # push to dome
        # that must in  A
        my ($A,$C,$G,$T,$s) = @_;
        ref $s eq 'ARRAY' || die;
        my ($N,$c) = @$s;
        # take 4s v             add 3s v         next 2 
        $N = [{MZ=>'wongui'}, {MZ=>{'3 doex'=>$c}}, @$N];
        Rw In $J $M:T.oM $N;
        #Rw stwo $J $n=wongui $N;
        # ^but instead push to A.N and A.No, the sister strand Whare Y Whare
        # and A walks through t&Y, d&Whare(6)
        # turns via n&ACGT
        # the time beams mapped... a W concat couldol
        T.not = 1;
    };
    I.AZu = sub { # space spread
        my ($A,$C,$G,$T,$am) = @_;
        die 'amany' if keys %$am > 1;
        my ($cv,$ac) = %$am;
        my ($AA,$CC) = @$ac;
        I.d&n,$AA,$CC,$G,$T;
        T.grabac = [$AA,$CC]; #lexac
        if (AA.cv >= $cv) {
            warn "Double comback AA.cv $cv";
            return T.not = 1;
        }
        AA.cv = $cv;
        I.d&An;
    };
C_C: |
    I.accept = sub { # coinsciousness accept, v 1-2, OSC readex
        my ($A,$C,$G,$T,$D) = @_;
        return T.next = 1 unless I.d&Cngk,$D;
    };
    I.interpD = sub { # make csc grab exprD
        my ($A,$C,$G,$T)=splice @_,0,4;
        my ($nk,$gk) = @_;
        my $D = {};
        if (ref $nk) {
            $D = $nk
        }
        else {
            while ($gk =~ s/^%(.+?):(.+?)(?=%|$)//g) {
                D.c->{$1} = $2;
                pop @_ if @_ == 2;
            }
            if (@_ == 1) { # or from t,,,
                D.c.nk ||= 'c';
                D.c.gk ||= $nk;
            }
            elsif (@_ == 2) {
                D.c.nk = $nk;
                D.c.gk = $gk;
            }
        }
        $D
    };
    I.c = sub {
        my ($A,$C,$G,$T)=splice @_,0,4;
            my ($D) = @_;
            $D = I.d&interpD,@_ if !ref $D;
            
            exists C.c->{$_} && die "COT I".ki $C
                for qw'code if of ref';
            
            my $v = I.d&Cngk,$D;
            return () unless $v;
            
            A.note->{D.c.nk}->{D.c.gk} = $v if A.note;
            
            die 'mulitAn' if @$v > 1;
            if (D.c.as eq 'list') {
                return ref $v eq 'ARRAY' ? @$v : die'Cngk not array';
            }
            return 1;
    };
    I.Cngk = sub {
        my ($A,$C,$G,$T,$D) = @_;
        die 'nk no gk' if exists D.c.nk && !exists D.c.gk;
        return 1 if D.c.any;
        if (D.c.nk && exists $C->{D.c.nk} && exists $C->{D.c.nk}->{D.c.gk}) {
            my $v = [$C->{D.c.nk}->{D.c.gk}];
            delete $C->{D.c.nk}->{D.c.gk} if D.c.mdel;
            return $v;
        }
        die "nonnk".wdump $D unless exists D.c.nk;
        0;
    };
    I.xot = I.extend = sub {
        my ($A,$C,$G,$T,$s,$c) = @_;
        while (my($k,$v) = each %$c) {
            $s->{$k} = ref $v ? {%{$s->{$k}||{}}, %$v} : $v;
        }
    };
    I.recycle = sub {
        my ($A,$C,$G,$T) = @_;
        G.drop.recycling->{A.J.id}->{A.am} = A.I;
    };
    

Intt: |
    my $A = Rw WeBase In;
    my $I = A.I;
    I.d&n,$A,{},$G,{};
    I.d&An;
    A.t&1;
    A.t&11111 || warn "NO 1";
    my $i;
    while (@{A.N}) { #
        $i++ > 1000 && die "Huge Indi";
        my ($A,$C,$T) = I.d&Act,$A;
        T.not&&next;
        A.t&6;
        T.not&&next;
        I.d&flywheels;
        T.not&&next;
        A.t&78;
        T.not&&next;
    }
    continue { I.d&z; }
    A.t&8;
    I.d&recycle;
    ar.M ? do {
        push @{ar.M}, uniq @{A.M};
        $A
    }
    : ar.J ? map {
        Rw Modi + $J $C:_
    } @{A.M}
    : die "noJMout";
    
Indulator: | # Wain spinality
    # not allcode since uCons blank qq cone & then thing
    n Bangdesk
    n IStuff
    n KnowTime
    n SlideEa
    n C
    n Servo
    n Motion
    
Arange: |
    ar.N && ar.oA && ar.oA.D &&
    substr(ar.oA.D.bab, 0, 200) =~ /<<('\w*'|"\w*")/ && 
    Rw babsubrip $oA:ar.oA $D:ar.oA.D $N:ar.N;
    
    my $A = {};
    A.oA = ar.oA if ar.oA;
    A.J = ar.J || die 'noJ';
    A.G = $G; # so travel can G/T/Hypo
    A.mo = $A;
    (A.am) = ar.t || ar.name || @{delete ar.m};
    A.am || die "unsame?";
    $A;
WeBase: | # require N, required to return an A.I that I.n,I.An,A.t
    my $A = Rw Arange;
    A.N = [ar.C ||
        @{ar.N ||
            [[ar.t?(ar.t,'',{J=>A.J}):die"artnot: send C or N"]]
        }];
    A.M = [];
    A.talk = "A.J.name ".(A.J.le && A.J.le.name);
    A.fl = ar.fl || {};
    A.I = {};
    
    my $I = delete G.drop.recycling->{A.J.id}->{A.am};
    
    my $II = Rw collaspII $A;
    
    if ($I) {
        if (I.Ii eq II.Ii) {
            A.I = $I;
            A.cv = 0.1;
        }
        else {
            sayre "Recycloped, Diff I.Ii  --  II.Ii" if A.J.V;
            undef $I;
        }
    }
    
    A.I.Ii = II.Ii;
    
    if (!$I) {
        $I = A.I||die'basenoi';
        Rw SNtl $I;
    }
    $A
RB: | # inits A of ar C/N, pins spiral down (ret A.I that I.n,I.An,A.t)
    # non babzub, assume pbab skipped <<''s in origin
    my $A = {};
    
    A.oA = ar.oA if ar.oA;
    A.J = ar.J || die 'noJ';
    A.G = $G; # so travel can G/T/Hypo
    A.mo = $A;
    (A.am) = ar.t || ar.name || @{delete ar.m};
    A.am || die "unsame?";
    
    A.N = [ar.C || @{ar.N}];
    A.M = [];
    A.talk = "A.J.name ".(A.J.le && A.J.le.name);
    A.fl = ar.fl || {};
    A.I = {};
    
    my $I = delete G.drop.recycling->{A.J.id}->{A.am};
    
    my $II = Rw collaspII $A;
    
    if ($I) {
        if (I.Ii eq II.Ii) {
            A.I = $I;
            A.cv = 0.1;
        }
        else {
            sayre "Recycloped, Diff I.Ii  --  II.Ii" if A.J.V;
            undef $I;
        }
    }
    
    A.I.Ii = II.Ii;
    
    if (!$I) {
        $I = A.I||die'basenoi';
        Rw SNtl $I;
    }
    $A
SNtl: | # spiral Nat toolz
    I.n = sub { # A qcui
        my ($A,$C,$G,$T,$AA,$CC,$GG,$TT) = @_;
        I.nF = {A=>$AA,C=>$CC,G=>$GG,T=>$TT};
    };
    I.d = sub { # be, sub
        my $s = shift;
        my $P = I.nF ||= {};
        my $y = $I->{$s} || die "no way named '$s'";
        $y->(P.A,P.C,P.G,P.T,@_);
    };
    I.An = sub { # A within faller
        my ($A,$C,$G,$T) = @_;
        A.c = sub { die "An  ein!" };
        A.t = sub { I.d&t,@_ };
        $A
    };
    I.t = sub {
        my ($A,$C,$G,$T,@M) = @_;
        my ($cv,$K) = reverse @M;
        @M>2 && die "Massive M _ _";
        $K ||= A.am||die"noam A_t";
        
        my $i = Rw collaspII $A;
        
        my $c = 0+("0.".$cv);
        # global proteining vote against A, like W sourcing to wantups
        #saygr "Proteins A.talk: i.Ii" if G.protV || A.J.V;
        $c == 0.1 || die "Senbial proot $c: A.J.name";
        Rw SNat $A $C $G $T $I $i $K $cv;
        A.cv = $c;
    };
SNat: | # I.ex do  # it's in that, bubbles 
    # baseism
    my $s = {};
    my $c = 0+("0.".$cv);
    my $talk = "A.talk: $K A.cv > $c --- C.t ";
    
    my $aim = {$K=>1};
    aim.I = 1 if $aim->{A.am};
    
    my $yv = {};
    # make K/cv/t -> cv/K/t
    for my $k (sort keys %$i) {
        my $ii = $i->{$k};
        
        next if $k eq 'Ii';
        next if $k eq 'ooI';
        ref $ii eq 'HASH' || die "weird $k=$ii";
        
        for my $vc (sort keys %$ii) {
            my $iii = $ii->{$vc};
            die'$k !0<$vc<1' unless $vc > 0 && $vc < 1;
            $yv->{$vc}->{$k} = $iii;
        }
    }
    
    # do stuff
    my $vb; # in fractions
    for my $vc (sort keys %$yv) {
        my $is = $yv->{$vc};
        
        next if $vc <= A.cv && $vc != $c;
        next if $vc > $c;
            
        if ($vb && $vc > $vb && @{A.N}) {
            # sincing, wide order
            # various others want to be around for only some of the process...
            sayre "$vb -> $vc  bump, ". @{A.N} if A.J.V > 1;
            T.Z->{$vb} = 1;
            return T.not = 1;
        }
        for my $k (sort keys %$is) {
            my $iii = $is->{$k};
            
            next unless $aim->{$k};
            
            for my $ik (sort keys %$iii) {
                my $D = $iii->{$ik};
                
                if (my $nk = D.sc.nk) {
                    my $C = I.nF.C;
                    next if !exists $C->{$nk};
                    if (my $gk = D.sc.gk) {
                        next if !exists $C->{$nk}->{$gk};
                    }
                }
                my $act;
                my $dont;
                if (D.sc.acgt && D.sc.act) {
                    $act = 1;
                    # acgtsubs can be defined at any cv
                    # run themselves if act
                    # usu. one receiver (Ci) and the rest scheme
                    die "D.t .act gets... D.sc.act" if D.sc.act ne '1';
                    $dont = 1 if exists A.I->{D.t};
                }
                
                # schools of many fish
                $vb ||= $vc if D.sc.v;
                
                # TreeD
                $s->{$k}->{$vc}->{$ik} = $D;
                my $sep = $act ? "----" : ">>>>";
                sayre "DElEE $talk $k $sep $vc  D.t D.y.cv  ".ki D.sc
                    if A.J.V > 2;
                
                # way or acgt-setuping-way
                unless ($dont) {
                    my $paw = join"_",'',$k,$vc,D.t;
                    $paw =~ s/\W//g;
                    Rw $paw $A $C $G $T $__D:D;
                }
                
                # most tiny ticks
                if ($act) {
                    D.sc.acgt eq 's'||die "nonacgts".ki $D;
                    exists A.I->{D.t}||die "acgtI D.t not up: ".ki A.I;
                    I.d&D.t,A.s;
                }
                return if T.not;  # will &z, oseve
                return if delete T.whack;
            }
        }
    }
    
    A.J.V > 1 && keys %$s && saygr
        Rw TreeD $s $scby=gro;
    
IStuff: |
    u allacgt
    
    n d =>''=>{s=><<''},{acgt=>1,args=>'s'}
        # grease thje stomac
        shift; # imporo
        my $y = $I->{$s} || die "no way named '$s'";
        my $P = I.nF ||= {};
        P.A||die'PnoA!?'; # papto
        $y->(P.A,P.C,P.G,P.T,@_);
    
    n n =>''=>{s=><<''},{acgt=>'AA,CC,GG,TT'}
        I.nF = {A=>$AA,C=>$CC,G=>$GG,T=>$TT};
    
    n recycle =>''=>{s=><<''}
        return if I.recyttl++ > 8;
        G.drop.recycling->{A.J.id}->{A.am} = $I;
    
    n Other =>''=>{s=><<''}
        my $ar = $F[0]->{ar};
        $A = Rw RB + $t:s;
        $I = A.I;
        # midnight at the oasis
        I.d&n,$A,{},$G,{};
        I.d&An;
        A.t&1;
        A.t&11111 || warn "NO 1";
        ($A,A.I)
    
    n An =>101=>{s=><<''},{acgt=>1}
        A.note = {}; # pinging csc
        A.talk = "A.J.name ".(A.J.le && A.J.le.name);
        A.c = sub { I.d&c,@_; };
        A.e = sub { I.d&e,@_; };
        A.us = sub { I.d&us,@_; };
        A.t = sub { I.d&t,@_; };
        A.V = sub {
            my $bl = shift;
            A.J.VV && A.J.VV->{$bl}
            || A.J.V
        };
        $A
    
    n Act =>''=>{s=><<''}
        $A = {%$s};
        A.mo.ont = $A;
        A.s = shift @{A.N};
        $T = {};
        T.oM = [];
        I.d&n,$A,{},$G,$T;
        I.d&An;
        A.t&2;
        map{I.nF->{$_}}qw'A C T';
    

J5: |
   return sayre "RECUR" if @F > 150;
   my $r = {%$ar};
   r.W = ar.name || shift @{delete ar.m};
   delete r.R;
   my $J = G.oin;
   my $i = Jn('','',$r);
   my ($s) = @{i.is};
   return s.sc.J||die "no sc J";

J6: | # do J=>m not W=>m, looser
   ar.J = ar.name || shift @{delete ar.m};
   Rw J5 +; 

Cur: |
    u allcurve
    
    n zoom =>0=>1.4
    n y    =>0=>0
    n x    =>0=>0.02
    n curve=>0=>-0.2
    n curve=>0.4=>0.4
    n spin =>0.3=>2
Yup: |
    n Steev
    
    Mn(shedful => '0.1-0.7', {pi=>'seas',s=>'g/c/8 g/G/on'});
    
    J.V = 0;
     
Steev: |
    n Here=>''=>"IS STEVE"
    
Hypo: |
    J.V = 0;
    $G = Rw Gto;
    Rw Viu;
    
    u Indulator
    u Modulator
    
    n some=>''=>thang;
    G.T.Hypo = J.A.I;
    DumpFile('w/ild',G.T.Hypo);
    
    #n Wild
    #n Idle
    n Byst
    
    
Wild: |
    J.A.IIII = ['G/T/Hypo'];
    J.V = 0;
    J.A.Indo = 2;
    $G = Rw Gto;
    Rw Viu;
    
    u Indulator
    u Modulator
    
    n some=>''=>thang;
    
    G.T.Wild = J.A.I;
    Rwyl 1 dumpwild;
    J.A.I = Load(Dump(J.A.I));
    
    #Mn(shedful => '0.1-0.7', {pi=>'seas',s=>"g/c/3"});
    
    
dumpwild: |
    DumpFile('w/ild',G.T.Wild);
    say "GO GO GO" for 1..3;
Idle: |
    G.T.wir = LoadFile('w/ild');
    J.A.IIII = ['G/T/wir'];
    #J.A.IIII = ['G/T/Wild'];
    return sayre "Idlearly" if !G.T.Wild;
    J.A.Indo = 2;
    $G = Rw Gto;
    Rw Viu;
    
    
    
    
    u Cur
    
    # some random
    Mn(shedful => '0.1-0.7', {pi=>'seas',s=>"g/c/43"});
    
    return;
    n something=>''=>{pi=>'text',s=>rand(5)}
    n sto =>''=>{pi=>'warps',s=>'bueno'}
    rand(1) > 0.3 &&
    n STEVE=>0.65=>"STAVEEEV"=>'%fs:40,hs:649'
    
pi/warps: |
    n SteioL=>'1-33'=>{s=>'SSSSSSS'}=>'%fs:40,hs:540'
    #etc

wa:
   yJ: |
     'Travel aww'
   M: |
    Rw vortex $J around $d=16;
    
    n Yes=>0.2
    
    #n Wkcs
    #n Vil
    #n Vuel
    
    n laz=>0.4=>{pwth=>'lazershop',s=>'laz'}
    
    #n Tok
    #n Hosp
    #n Eosse
    #n EYZ
    #n Wander
    
    
    Rw J5 - toc;
    
    n ps=>0.3=>{pi=>'waps'}
    
    Jn(st=>0.9=>"o",'%hs:8427,fs:4');
    
Wkcs:
   yJ: |
     'Travel'
   M: |
    #yep
    
    G.way.Wkcs.curves = <<'' if 1;
    zoom 0  1.4
    curve 0 0.06
    x 0.02 0
    # etc
Yes:
   yJ: |
     'Travel'
   M: |
     J.most.eo = 'Yesui';
     n J.name, 0.9, J.name, {tag=>J.name,id=>J.id}
     
     Rw StillYes;
     
     #Mn(she dful => '', {pi=>'seas',s=>'g/c/6 g/c/7'});
     Mn(shedful => '0.1-0.7', {pi=>'seas',s=>"g/c/1 g/c/2"});
     
     # wants to A.aft{A.K} = {do Hypno}
     # where do is bundle of A.aft etc stashed things
     # like A.req = Yes, etc.
     # so itsa 77er, seeks $N for clife, def. from Jiter
     # come-back-fairly-immediately
     n Hypo=>0.05,{J=>'Hypo',pwth=>'Do:Hypo'},{fs=>33}
     n Yup=>0.075
     #n Hypo=>0.05=>{y=>Hypo=>s=>'c_pi:clife'}
Do: |
    sayyl "DOING";
    Rw J5 + $vv=6;
StillYes: |
     my $v = $G->suet($A, "in/shedful/g/c/6");
     # shedful/g/G/on/g/G/on/*c:pi:clife
     #v._.sc.fs = 22;
     my $shv = Rw J6 - shv;
     my $tr = $G->suet(shv.A, "in/Yes");
     tr._.y.thy = 0.6;
     # travel oozes outta aj ^
     # v wants u
     G.way.Yes.curves = <<'' if 1;
     zoom 0  1.6
     curve 0 -0.06
     x 0.02 0
     
     n st3vil =>0.86=>{pi=>text=>s=>'st3vil.github.com'}
     n time=>0.9=>{pi=>text=>s=>join'',`date` =~ /^(.+):\d\d( .+)$/smg}
Eosse: |
    Mn(shedful => '', {pi=>'eye',s=>'eye'});
    #y.out = 0.8 + 0.1 * (rand(3)-1.5);
    sayyl "Fo 4 A time A: $A   vs J.A ";
    Atime(4) || return;
    
EYZ:
   yJ: |
     'aww'
   curves: |
     zoom 0  0.6
     y    0  0
     x    0  0
     curve 0 0.04
   M: |
    C.sc.css = 'font-family:cursive';
    Mn(shedful => '', {pi=>'eye',s=>'eye/Tarf'});
    #Mn(ps => '', {pi=>'psfaus'});
    #Atime(4) || return die "SJIO";
    
Hosp:
   yJ: |
     'Travel'
   M: |
    my $d = Jn(qw'life 0.1 life/H/');
    
    Mn(hoisp => '',{pi=>'liv',s=>d.s}); 
Vil:
   yJ: |
      'Travel'
   M: |
      Mn(hah => {thy=>0.3}, {pi=>'eye',s=>'eye/fug'});
      
      #Jn(Vuel=>'',{W=>'Vuel'});
      
      #$J:G.oin
      
      Mn(ZIS => {thy=>0.2}, {pi=>'text',s=>"Thisway"});
Vuel:
   yJ: |
      'Travel'
   M: |
      G.way.Vuel.curves = <<'' if 1;
      zoom 0  1.6
      curve 0 -0.03
      x 0.02 0
      
      my $ua = Mojo::UserAgent->new;
      
      
      my $i = Rw J6 - Yes;
      
      
      #Rw lazershop;
      
      #my @s = Rw wuck $J */curves;
      #my $oJ = $i;#G.oin;
      #my $vs = Rw tc $J:oJ;
      #$vs = [grep { _.sc.pi eq 'clife' } @$vs ];
      #Mn(Wkcs => '', {pi=>vs=>s=>$vs});
      
      #my $rr = [map{"_.t     ".ki({N=>{y=>_.y,c=>_.c,sc=>_.sc}})}@$vs];
      #my $rr = [@$vs];
      my $rr = i.El.Duv;
      $rr = rr.rv if $rr;
      Mn(deef=>'',{pi=>'',cv=>0.8,s=>wdump 14, $rr}, {fs=>6});
Tok:
   yJ: |
      'shd Travel'
   M: |
      #J.zip == 1 &&
      my $g = {map{$_=>"$G->{$_}"}keys %$G};
      G.way.Vuel.curves = <<'' if 0;
      x 0 -0.2
      zoom 0  0.7
      curve 0 -0.3
      x 0.02 0
      
      my @s = Rw wuck $J */curves;
      
      my $oJ = G.oin;
      
      my $vs = Rw tc $J:oJ;
      #my $s = wdump $vs;
      my $rr = [map{[_.t,_.y.cv,_.sc]}@$vs];
      Mn(deef=>'',{pi=>'',s=>$rr});
Wander:
   yJ: |
      'Travel'
   M: |
      J.zip++ >= 5 && do{ J.zip = 0 };
      sayyl "J.name  J.zip" for 1..5;
      Rw J6 - Vil;
      
      
      J.zip == 1 &&
      Mn(ZIS => '', {pi=>'text',s=>"Thisway"});
      
      J.zip == 0 || J.zip == 2 &&
      Mn(ZIS => '', {pi=>'text',s=>"ones"});
      
      J.zip > 1 &&
      Mn(ZIS => '', {pi=>'text',s=>"sway"});
      
      J.zip > 2 &&
      Mn(skode => {thy=>3}, {pi=>'psfaus',s=>'THIS'});
      
      J.zip > 3 &&
      Mn(ZIStor => '', {pi=>'text',s=>"away..."});
      #sayylto "_.dead : ".gp $_ for values %{J.idly};
      #Mn(skoeede => '', {pi=>'text',s=>'THIS'});
      
      #Mn(With => 8, {J=>''}); # J with
      
      #Mn(Showi => 3, {pi=>'show',s=>8}); # any this 8

Jto: |
    my $J;
    J.id = mkuid;
    J.name = ar.name || shift @{delete ar.m};
    J.bb = {};

    J.le = ar.le if ar.le;
    J.most.J = $J;
    J.most.mody = 'mani';
    J.most.eo = 'Yesui';
    J.most.wq = 1;
    #J.A.IIII = ['G/T/Wild'];
    #J.A.Indo = 2;
    
    # GONERS
    Rw suJ $J;
    Rw Jup $J;
    # 
    
    n J.name, 0.9, J.name, {tag=>J.name,id=>J.id}
    J.uname = J.name;
    
    Rw Viu $J;
    
    return $J;
oJ2: | # HOW c grabs on, how W transifies down...  # all goners!
     #sayyl "oJJJ oJJJ ".wdump $C;
     if (C.c.J eq A.J) {
         sayre "J above A.J.name";
         delete C.c.J;
     }
     if (exists C.c.J) {
         C.c.W = C.c.J;
         if (J.name ne 'qq') {
             A.ztime = 3;
         }
         # amount of time each thing spends being the top level
         # which was... n... mani
     }
     A.ztime = delete C.c.time if C.c.time;
     
     my $nn = A.note.not;
     
     C.c.s = 'S2im' if !defined C.c.s;
     nn&c,'s';
     C.c.W && # nets
     nn&c,'W';
     my $wasW;
     if (exists C.c.pi) {
         nn&c,'pi';
         Rw opi2 + $v:C.c.pi;
     }
     elsif (exists C.c.W) {
         $wasW = 1;
         nn&c,'W';
         Rw oW2 + $v:C.c.W;
     }
     else {
         #die "misrep ".wdump 2, $C;
     }
     if (C.c.W && !$wasW) {
         if (!ref C.c.W) {
             my $Wjr = Rw Ajr $J:G.oin $t:C.c.W $cv=0.3;
             my $WJ = Wjr&J;
             sayyl "HJvae A.J.name holding C.t with WJ.name" if J.V;
             C.c.W = $WJ;
         }
         else {
             die "knew W? ".ki C.c.W;
         }
     }
oo2: | # HOW humming c grabs on, how W transifies down...
     if (C.c.J eq A.J) {
         warn "J above A.J.name";
         delete C.c.J;
     }
     if (exists C.c.J) { # W but slower? U?
         C.c.W = C.c.J;
         A.ztime = 3 if A.J.name ne 'qq';
         # amount of time each thing spends being the top level
         # which was... n... mani
     }
     A.ztime = delete C.c.time if C.c.time;
     
     sayre "No S" if !defined C.c.s;
     sayre "nadad S" if !exists C.c.s;
     my $wasW;
     if (my ($s) = A.c&pi) {
         die wdump ["NOTED pi",$C,A.note];
         Rw oopi + $s;
     }
     elsif (my ($s) = A.c&W) {
         $wasW = 1;
         die wdump ["NOTED W",$C,A.note];
         Rw ooW + $s;
     }
     else {
         #die "misrep ".wdump 2, $C;
     }
     if (C.c.W && !$wasW) {
         if (!ref C.c.W) {
             # pi also wired to W
             my $Wjr = Rw Ajr $J:G.oin $t:C.c.W $cv=0.3;
             my $WJ = Wjr&J;
             sayyl "HJvae A.J.name holding C.t with WJ.name";
             C.c.W = $WJ;
         }
         else {
             die "knew W? ".ki C.c.W;
         }
     }
opi2: | # private investigators on crunchy gravel, spreaders
    # - c. language is map to some u before 6ing
    my $v = C.c.pi;
    at.pi = $v || 'guess';
    # type of abdomin to use?
    C.c.J = 'pi';
    
    my $oJ = $J;
    $oJ = C.y.o.J if C.y.o && C.y.o.J;
    A.jr = Rw Ajr $J:oJ $C;
    
oW2: | # some get-J or weave wires protocol - hosts
    my $t = $v;
    $t = v.name if ref $t;
    at.J = ref $v ? $v : $t;
    at.W = $t;
    C.c.J ||= $v;
    
    die wdump ["onto W J.name:",$v] if ref $v && $v ne v.most.J;
    
    C.t = $t;
    # has already been 0.1 in Y
    C.y.cv ||= 0.3;
    
    A.jr = Rw Ajr $J:G.oin $t $cv=0.3;
    
    # and where the
    if (C.c.vv) {
        A.ztime = delete C.c.vv;
        A.jr&vv,9
        ->(); #delone
    }
oJ3: | # MOD  being repeater  - humm # GONER
    my $J = Rw oJ31;
    Rw oJ32 + $J;
    return if T.return;
    
    if (!ref $J) {
        if (C.sc.pi) {
            $J = Rw spinash $J:A.J;
        }
        elsif (!ref G.way->{$J}) {
            $J = Rw Jto $name:J;
            sayyl "J33   Made J.name";
        }
        else {
            my $o = {name=>C.c.J};
            o.style = delete C.c.style if C.c.style;
            # TODO make func like J.w&oc,style=>C.c;
            # which moves into the wall and percs lamt.
            $J = Rw JJ $o;
            sayyl "J3   Made J.name";
        }
        if (!ref G.way->{J.name}) {
            J.most.eo = 'Yesui';
            J.most.mody = 'mani';
        }
        C.sc.J = $J || die 'want23';
        C.c.s = "Swim" if !exists C.c.s;
    }
    
    my @an =  A.jr->('');
    if (@an && !exists C.c.s) {
        C.c.s = shift @an;
    }
    elsif (!@an && exists C.c.s) {
        A.jr->('',C.c.s);
    }
    die "noovewr   C.c.J ne $J" if ref C.c.J && C.c.J ne $J;
    A.jr&J,$J;
    at.J = $J;
    # ^ gets & replaces, C.sc.J now it
    
    Rw oJ4 + $J;
oJ31: |
    my $f = A.jr&J;
    my $j = C.sc.J;
    die ".sc J dif $f $j" if ref $j && ref $f && $j ne $f;
    C.sc.J = $f if $f && ref $f && !f.dead;
    C.sc.J
oJ32: |
    if (C.c.X) {
        die "Nofound $J  C.t   C.y.cv" if !ref $J;
        die "noovewr X  C.c.X ne $J" if C.c.X ne $J;
        sayyl "DELING J.name". wdump $C if C.c.X;
        A.jr&J,$J,9;
        J.dead = 1;
        T.return = [];
        return;
    }
    # also how & 9s (noncompresses) out for us into a more local J
    # u W would zlide in as an Elvis clone
    # it has a high frequency
        # re J 31,32,33, 9
oT6: |
    my $talk = "T J.most.J.name /// J.A.d J.name  J.A.ztime A.ztime";
    A.coi = Rw pha $J ako;
    
    if (exists C.sc.pi || J.most.ww2) {
        # telephone winch
        for (qw'ljm ljmo') {
             J.A->{$_} = J.Jiter.A->{$_}
             if J.Jiter && J.Jiter.A->{$_};
        }
        A.time = sub {
            my($JJ,$q) = @_;
            # then - is
            # crux to pi
            $J eq $JJ || die "wtf";
            # point to give up
            # so can much very, sculpt
            if ($q == 2) {
                A.ico = Rw pha $J ico;
                A.ico.qui = 1;
                A.ico.as->(A.coi);
                my $wt = A.ico.exactl->();
                
                if (wt.last && !wt.same) {
                    my $uf = join "\n", map{"$_: ".wdump(1,$wt->{$_})}
                        grep {keys %{$wt->{$_}}} qw'new diff gone';
                    saybl "$talk  2222  $uf";
                }
                
                Rw eighthnot $J
                 ? do { A.ico.wt.same = 0; }
                 : wt.same && return 0;
                
                # for jamcs screenfly
                J.A.ljm = [];
                J.A.ljmo = "fr  J.name";
                return 1;
            }
            warn "$talk other $q";
            if ($q == 8) {
                # until J.most coord attention evaporates
                # as in pulling on a list
            }
            A.ztime >= $q;
        };
    }

    my $M=[];
    my $y = {o=>$M};
    
    my $tw = Rw huck + $M $y;
    
    $tw || die "nothing! J.name";
    die "many".ki $tw if keys %$tw > 1;
    # set our C.c.s to [that], noise probe case, maybe

    Jn('z',$y) if @$M;
    
    my $sol = "?";
    # first the superstilled
    # anything T_D can arrange through time...
    # wants to join G subtly vis T and so....
    # should be no M in the first bit
    # it is just pinpricks of consciousness keeping it alive, like mtime
    # be nicer to do with an I that can T out of this whole change res patch
    if (A.ico && A.ico.wt.same) {
        my $cut = @{A.ico.ord};
        my @cc = @{A.coi.ord};
        if (@cc > $cut) {
            warn"J.name entered stuff after 2!".wdump [@cc, 
            '                 =============', @{A.ico.ord}];
        }
        A.coi.abandon->();
        if (my $ljm = J.A.ljm) {
            for my $ar (@$ljm) {
                ar.noR=1;
                Rw jamsc;
            }
        }
        sayre "SKIP $talk" if J.V || J.most.J.V;
        T.last = 1;
        $sol = "skip";
    }
    else {
        A.coi.qui = 1;
        my $wt = A.coi.exactl->();
        if (wt.same) {
            if (++J.A.wch > 4) {
                J.A.wch = 0;
                $sol = "same";
            }
            else {
               $sol = "skip";
               sayre "SAME $talk" if J.V || J.most.J.V;
                T.last = 1;
            }
        }
        else {
            $sol = "notsame";
        }
    }
    
    
oJ6: | # https://www.youtube.com/watch?v=tL8N_3tln0Y
    my $J = C.sc.J;
    my $talk = "T J.most.J.name /// J.A.d J.name  J.A.ztime  ----- A.ztime";
    sayyl "isn!   $talk       C.t " if J.most.J eq 'Hypo';
    
    unless (exists C.sc.pi) {
        return T.last = 1 unless Atime(6);
        
        my $n = sub{};
        if (A.ztime < 9) {
            my @am = A.jr&bol;
            sayre "doubly".wdump[@am] if A.jr&bol;
            $n = A.jr&bol,9;
        }
        aft {
            $n->();
            $@||return;
            sayre "BANG J.name" for 1..3;
            A.jr&bang_ts,hitime
            if J.most.J eq $J;
        };
    }
    
    %$ar = (%$ar, %{C.c});
    
    if (exists C.sc.pi) {
        Rw opi6 + $J;
    }
    elsif (J.most.wq) {
        saybl "oJ6666 C.t" unless J.yt.quiet || C.t =~ /^all/;
        my $p = J.name;
        Rw oT6 + $A $C $J $T $p;
    }
    else {
        saybl "oJ6 C.t" unless J.yt.quiet;
        Rw around + $J;
        A.roundi = 1;
    }
       
opi6: |
    die'csnod' if $C ne J.C;
    die if !ar.T;
    
    J.cv = C.c.gp.cv || C.c.cv || 0.6;
    my $s = C.c.s;
    my $path = C.sc.pi||die'nopi';
    if (J.A.d > 9) {
        $path = 'text';
        warn "J.name J.A.d limit to text";
    }
    my $pin = "pi/$path";
    
    Rw oT6 + $pin $s $u:s;
waz/up: | # a strain
    #sayre "J.name is wazing";
    if (!J.yt.nohead) {
        Rw Jhead;
        Jn(st=>0.9=>"o",'%hs:8427,fs:4');
    }
    die if !ar.T;
    Rw oT6 + $p=*/M $J $A:J.A $C:J.C $T;

oJ4: | # J.A remains, A transitory  - A.time is to couple it like I.in
    J.A ||= {first=>hitime()};
    # everytime stuff:
    #map { sayyl "A.J.name  vs J.name vs J.iter" } 1..3 if rand 9 > 8;
    
    # dep
    if (exists C.sc.pi) {
        die if J.Jiter ne A.J;
        die if J.most.J eq $J;
    }
    else {
        die if J.most.J ne $J;
    }
    
    if (C.c.time) {
        warn "CTIOME".ki $C;
        A.ztime = delete C.c.time;
    }
    A.ztime ||= 6;
    
    if (C.sc.pi) {
        J.A.d = J.Jiter.A.d + 1;
        J.ind = join '  ', ('') x J.A.d;
        J.name = "J.A.d . C.c.pi*C.t";
        J.d = J.C = $C;
        J.r = C.t."\t".C.y.cv;
        J.bz->("/\t0.9" => "y");
        A.time = sub {
             my($JJ,$q) = @_;
             A.ztime >= $q || do {
                 die "J.name  ---- JJ.name     A.ztime quuuuuu $q";
                 0
             };
        };
    }
    else {
        sayyl "Fo 4 A time A: $A   vs J.A " if J.name eq 'Eosse';
        A.time = sub {
             my($JJ,$q) = @_;
             A.ztime >= $q || do {
                 sayre "COMB J.name --- le-- JJ.name      A.ztime < $q";
                 A.jr&vv,$q;
                 0
             };
        };
    }
    
oJ42: |
    my @mis = grep{!A.note.c->{$_}}keys %{C.c};
    @mis=grep{$_ ne'J'}@mis;
    if (@mis) {
        my $cm;
        $cm->{$_} = C.c->{$_} for @mis;
        sayyl "Spesh J.name :  ".ki $cm unless J.yt.quiet;
        A.preg = $cm;
        A.ztime = 9;
    }
    
oJ43: | # the pull down
    J.A.in = $G->gip(J.Jiter.A.in, C.t)||{} if J.Jiter;
    
oC43: | # maniC pulls down travel # comep from aj compi
    if (my $c = $G->gip(A.J.A.in, C.t)) { 
        $c = c._ || return;
        say "C.t in: ".wdump $c if !A.J.yt.quiet;
        if (c.D) {
            c.D->($C);
        }
        elsif (grep {exists $c->{$_}} qw{t y c sc}) {
            g.extend->($C, $c);
        }
        else {
            die "howto ".ki $c;
        }
    }
fi: | #c
     my $point = ar.p || ar.pin || ar.m->[0];
     
     my $know;
     if (!ar.pin && ar.J) {
         my $J = ar.J;
         if ($point =~ /^\*\/(\w+)$/) {
             my $inway = $1;
             my $h = ar.h || G.way;
             $h = h.hooks if h.hooks;
             my @gu = @{J.yy.styleord};
             #@gu = @gu[0..5] if @gu > 6;
             my @so;
             for (@gu) {
                if (ref $h->{$_} eq 'HASH' && $h->{$_}->{$inway}) {
                    push @{$know||=[]}, "$_/$inway";
                    last if !ar.sucky;
                }
             }
         }
     }
     
     if (!$know) {
         my %wo = Rw findl +;


         my @keys = map { s/^\///; $_ } keys %wo;
         if (!ar.pin && ar.J) {
             my $J = ar.J;

             @keys = grep { my($K)=split'/',$_; J.yt->{$K} } @keys;
             my @or = @{J.yy.styleord};
             if (@or && @keys > 1) {
                 my $i = 1;
                 my $is = {map{$_=>$i++}@or};
                 @keys = sort {
                  $is->{($a=~/^(.+?)\//)[0]} <=> $is->{($b=~/^(.+?)\//)[0]}
                  } @keys;

                 if (!ar.sucky && @keys > 1) {
                     #sayre "Limiting @keys";
                     @keys = $keys[0];
                 }
             }
         }
         $know = [@keys];
     }
     #saybl "With: ar.J.name  $point    @$know" if ar.J && ar.J.name eq 'shv';
     @$know

oJ7: |
    my $J = C.sc.J;
    
    J.most.wq && return
    Rw J.most.eo $J;
    
    exists C.sc.pi && return Rw opi7;
    
    return if A.roundi;
    
    say "oJ7777 J.name" unless J.yt.quiet;
    Rw oJ $J geo &up $noesc=1
        if !J.most.wq;
    my $eo = J.most.eo;
    $eo || die "noeo: J.name";
    Rw $eo $J;
opi7: | # MOD pi     out cup           # REF JOIN A.c/sc
    my $J = C.sc.J;
    
    sayyl "opi7! J.most.J.name J.name" if J.most.J.V;
    my $aj = Rw J.most.eo $J $catj=1;
    
    J.Ec = [@{aj.c}];
    die wdump $aj if @{aj.sc};
       
oJ75: | # chov J
    if (C.sc.pi) {
        $v = C.sc.J || die'enoJ'.C.t;
        die "Pi v.r has s" if v.s;
        delete at.s if defined at.s;
        die "No Ec came out of v.name  on J.name" if !ref v.Ec;
        die "Pi v.r no .Ec" if !@{v.Ec};
        acum $at, 'Esc', $_ for @{v.Ec};
    }
    else {
        #say "AM v.name  rrrrr J.name";
        at.s = "Vrrr v.name";
    }
Yesui: |
    !J.most.wq && return Rw chuv;
    
    sayyl "Yesui J.name";    
    my $V = Rw Noodles $J;
    
    V.rv;
Noodles: |
    my $A = {J=>$J};
    A.talk = "A.J.name ".(A.J.le && A.J.le.name);
    # then we could I when doing:
    
    Rw Noodle + $A;
Noodle: |
    my $Y = Rw Elvus $J Pre;
    # providing the source pretend of c/sc ray anarchy
    # v to ^
    Y.il = Y.tv->{"0.9\t/"}
        || Y.tv->{"0.9\t".J.name}
        || Y.tv->{"0.9\t".J.uname}
          || die " noroot J.name: showing 0.9s: "
            .wdump [map{ki $_}values %{Y.v->{0.9}}];
    
    my $N = [grep { $_ ne Y.il } @{Y.vs}];
    push @$N, Y.il;
    A.N = [@$N];
    
    my $hup = sub {
        my $C = shift;
        my $CC = {%$C};
        $CC->{$_} = {%{$CC->{$_}}} for grep {ref $CC->{$_} eq 'HASH'} keys %$CC;
        $CC;
    };
    
    my $V = Rw El Duv;
    V.os = [];
    while (@{A.N}) {
        my $C = shift @{A.N};
        ref C.y || die"nospace".ki $C;
        ref C.y || sayre("Weird".ki$C) && next;
        
        my $k = C.y.cv."\t".C.t;
        push @{V.os}, $k unless $C eq Y.il;
        
        next unless $C eq Y.il ||
        # if change is, or just diff in perceiving it
        Rw diffre $J $C $k $Y $V;
        
        # O
        my $lv = {k=>$k};
        lv.C = $C;
        my $at = Rw OSC $A $J $C $k $Y $V $lv;
        
        my $ta = V.ta->{$k};
        my $vl = V.lv->{$k};
        
        if ('force') {
            at.c.el = 1;
            at.c.Yesui = 1 if $C eq Y.il;
            lv.force = 'el';
            lv.selfs = 1;
            lv.grab = [at.t, at.y, {el=>8}];
            lv.rmnsc = [at.t, at.y, {el=>9}];
            # and or ID
            # ID makes possible to throw into the W (most J) tiniest specs of change
            # maybe 8regate
        }
        
        # crazy has places to hide in
        my $heq = sub {
            my ($o,$t) = @_;
            if (ref $o && ref $t) {
                keys %$o == keys %$t && !grep{$o->{$_} ne $t->{$_}}keys %$o
            }
            elsif (!ref $o && !ref $t) {
                $o eq $t
            }else{0}
        };
        for my $nk (qw't y c sc V') {
            my $v = $at->{$nk};
            my $o = $ta->{$nk};
            if (!$heq->($v, $o)) {
                Rw ACT $J $C $k $Y $V $at $ta $lv $vl $nk $v $o;
            }
        }
        
        V.ta->{$k} = $hup->($at); 
        V.tv->{$k} = $hup->($C);
        
        Rw OMP $J $C $k $Y $V $at $ta $lv $vl;
        
        V.lv->{$k} = $lv;
        
        if ($C eq Y.il) {
            V.rl = $vl;
            V.rv = $lv;
        }
    }
    Rw TNews $J $talk:A.talk $rl:V.rl $rv:V.rv
        if J.V;
    $V
    # bloop
ACT: |
    my $talk = "J.name ACT $nk: $k\t";
    if (ref $v eq 'HASH') {
        my $wt = Rw wtfch $Jb:v $Yb:o;
        my $nonnew = keys %{wt.gone} || keys %{wt.diff} || keys %{wt.still};
        
        for my $wk (qw'gone diff new still') {
            for my $gk (sort keys %{$wt->{$wk}}) {
                my $talk = "$talk $wk: $gk";
                my $s = $at->{$nk}->{$gk};
                
                if ($nk eq 'V') {
                    Rw AC_V + $talk $nonnew $gk $wt $wk $s;
                }
                elsif ($nk eq 'c') {
                    Rw AC_c + $talk $nonnew $gk $wt $wk $s;
                }
                elsif ($nk eq 'sc') {
                    Rw AC_sc + $talk $nonnew $gk $wt $wk $s;
                }
                else {die"wtfis  '$nk'"}
            }
        }
        saybl "$talk    is all new" if $vl && !$nonnew && keys %{wt.new};
    }
    else {
        my $wk = !$vl ? "new" : !exists $at->{$nk} ? "gone" : "diff";
        $talk .= "$wk: ";
        if ($nk eq 't' || $nk eq 'y') {
            if ($wk ne 'new') {
                die "HOWTO $talk";
            }
            sayyl $talk if $vl;
            
            lv.op->{$nk} = 1;
        }
        else {die"wtfis $v $nk".wdump[$v,$o]}
    }
AC_c: |
    if ($wk eq 'gone') {
        die "how delete a c $gk";
        die "would have" if !$vl;
        # most of these can re c if they get confused
        # care later to grab /in, recreate holster, replace
        # or however we whatever
        # protocols for travel regroup
        
        lv.op.c->{$gk} = 9;
    }
    elsif ($wk eq 'new') {
        die "how inject a c $gk" if $vl;
        
        lv.op.c->{$gk} = 9;
    }
    elsif ($wk eq 'diff') {
        sayyl "$talk  ".slim(45,$v->{$gk})." <--- ".slim(45,$o->{$gk});
        
        if ($gk eq 's') {
        
            lv.pur.c->{$gk} = 1;
        }
        else {
            die "how to c dif $gk";
            
            lv.op.c->{$gk} = 9;
        }
    }
    elsif ($wk eq 'still') {}
    else {die 'wtwhack'.$wk}
AC_sc: |
    if ($wk eq 'gone') {
        die "how delete a c $gk";
        die "would have" if !$vl;
        # most of these can re c if they get confused
        # care later to grab /in, recreate holster, place
        # or however we whatever
        
        lv.op.sc->{$gk} = 9;
    }
    elsif ($wk eq 'new') {
        sayyl "$talk  !!!!  $v->{$gk} " unless !$nonnew;
        
        lv.pur.sc->{$gk} = 1;
    }
    elsif ($wk eq 'diff') {
        sayyl "$talk  $v->{$gk} <--- $o->{$gk}";
        
        lv.pur.sc->{$gk} = 1;
    }
    elsif ($wk eq 'still') {}
    else {die 'wtwhack'.$wk}
    
AC_V: |
    my $iv = lv.do->{$gk};
    my $ov = vl.do->{$gk};
    ov.i && (ov.i eq $o->{$gk} || warn "no ovi ogk");
    if ($wk eq 'gone') {
        ov.rmnsc || die "no remin";
        !$iv || die "gone had iv";
        # ^ sc plumb its destruction
        # can void if our c reframes by implicitly clearing 
        saybl "$talk  is GONE!" if A.V&N;
        
        lv.od.go->{$gk} = $ov;
    }
    elsif ($wk eq 'new') {
        $iv || die;
        # may like to grab the element before it
        # like a curve continuing
        saybl "$talk    new!" unless !A.V&N || !$nonnew;
        
        lv.od.new->{$gk} = $iv;
    }
    elsif ($wk eq 'diff') {
        if (iv.c eq ov.c) {
            iv.sc eq ov.sc && die "same c fluc sc $gk";
            my $in = @{iv.sc};
            my $out = @{ov.sc};
            if (@{iv.sc} > @{ov.sc}) {
                saybl "$talk GROWs" if J.V > 2;
                
                lv.od.gr->{$gk} = $iv;
            }
            else {
                warn "WTFF ".wdump 2,[$iv,$ov];
            }
        }
        else {
            saybl "$talk  REPLACES c";
            
            lv.od.over->{$gk} = $iv;
        }
    }
    elsif ($wk eq 'still') {
        lv.od.ll->{$gk} = $iv;
    }
    else {die 'wtwhack'};
OSC: | # sheets of language up to da
    my $at = {};
    
    at.t = C.t;
    at.y.cv = C.y.cv;
    #sayre "OSC7 C.t no c_s" if !exists C.c.s;
    at.c.s = C.c.s;
    at.sc = {%{C.sc}};
    delete at.sc->{$_} for qw'geo idly ml nspc path yspc';
    if (my $v = at.sc.J) { # J unifies -
        at.sc.J = v.name;
        
        my $nV = v.El->{V.name}||{};
        my $rv = nV.rv || {LIES=>"from v.name"};
        
        lv.do->{V.name} = $rv;
        at.V->{V.name} = rv.i;
    }
    if ($C eq Y.il) { # / unifies  <
        lv.voso = 1;
        for my $ik (@{V.os}) {
            my $iv = V.lv->{$ik};
            sayre("Skip self in self") && next if C.sc.J && C.sc.J eq A.J;
            lv.do->{$ik} = $iv;
            at.V->{$ik} = iv.i;
        }
    }
    at.sc.geo = ki(at.sc.geo) if at.sc.geo;
    at.y = at.y.cv if keys %{at.y} == 1 && exists at.y.cv;
    for my $up (qw'tag id') {
        at.c->{$up} = delete at.sc->{$up} if exists at.sc->{$up}
    }
    
    $at;
diffre: |
    my $heq = sub {
        my ($o,$t) = @_;
        keys %$o == keys %$t && !grep{$o->{$_} ne $t->{$_}}keys %$o;
    };
    my $toen = 1;
    
    if (my $di = Y.lo->{$k}) {
        my $not;
        if (keys %$di == 1 && di.diff) {
            my $CC = V.tv->{$k};
            if (!$CC) {
                sayre "never heard of (V_tv) diff J.name : $k ";
                return 1;
            }
            for my $tk (keys %{di.diff}) {
                if ($tk eq 'geo') {
                    $not++ if 0 && !$heq->(C.sc.geo,CC.sc.geo);
                    if ($not && 0) {
                        sayyl "Geo was $not a difference in the thing";
                        sayyl sjson(C.sc.geo);
                        saybl sjson(CC.sc.geo);
                    }
                }
                elsif ($tk eq '') {
                    $not++ unless ref C.c.s && C.sc.dige && C.sc.dige eq CC.sc.dige;
                }
                else {
                    saybl "J.name $k has diffre: $tk";
                    $not++;
                }
            }
        }
        else {
            $not = 1;
        }
        $toen = 0 if !$not;
    }
    if (!$toen) {
        if (my $JJ = C.sc.J) {
            my $ta = V.ta->{$k};
            if (my $nV = JJ.El->{V.name}) {
                my $iv = nV.rv;
                my $oi = ta.V->{V.name};
                if ($oi ne iv.i) {
                    $toen = 1;
                    #sayyl "J.name  $k   about JJ.name: $toen \n"
                    #.($toen&&" ^ iv.i\n | $oi");
                }
            }
            else {
               sayre "no El V.name on JJ.name";
            }
        }
    }
    $toen
     


siueon: |
    iroughoan anonate
paintaj: |
     aj.Wid || die "not Wid?";
     aj.hol = "H.style/H.name/H.id";
     aj.hitime = hitime;
     aj.name ||= aj.J.name;
thing2: |
   fow
hip_po: |
    tree-ish campus
    str i sin tko
things: |
    with suct ion
Mainiy: |
    things in 
Travel: # make somewhere bridge
   yJ: |
     'clw waz gui'
   sh: |
     Rw J5 shv $aj;
   Em: |
     Rw Emvil;
Emvil: |
     my $tw = Rw huck $J $aj */sh;
     $tw || die "nomount J.name";
      
     my $c = aj.c;
     die 'scs' if @{aj.sc};
     die 's' if aj.s;
     my $M = ['','',{W=>G.Wid},{z=>aj.c}];
     
     #sayyl wdump 15, $M if aj.J.name eq 'Vuel';
     aft {
         $@ || return;
         sayre "$@  !~!! ".wdump 35, $M;
     };
     aj.c = [" a\.om({},".sjson($M).",a,{});"];
     aj.sent = 1;
     
     Rw paintaj $aj;
     
     # route aj.W from ...
     G.Wh->{aj.Wid} ||= do {
         my $ij = {}; map {
         $ij->{$_} = $aj->{$_} if !/^[sc]+/; } keys %$aj;
         ij.id = delete ij.Wid;
         ij.y = 'W';
         
         sayyl "Life! of ij.y ij.id";
         0->tai("ij.y/ij.id\.i", $ij);
         0->tac("V/H.style/H.name/H.id\.s", ztm($ij));
         aj.J;
     };

     Rw J5 wu $aj;
     
     aj.y ||= 'J';
     aj.yy = 'W';
     Rw aji $aj;
     Rw blabaj $aj;
S/ghostchanges: |
    unless ($m =~ /\/k\//) {
        Rw loD;
        sayyl "loded";
        Rw recoded_init;
    }
S/wayup: |
    -f $m || die;
    delete G.drop; 
    $G->wayup($m);
    Rw loD;
    Rw recoded_init;
 

around: | # GONER
     inter({Jname=>ar.J.name}) if ref ar.J;
     die if !ar.J;
     if (!ar.A) {
         saybl "around -- J5 ".(ar.J ? ar.J.name : ki $ar);
         return Rw J5
     }
     die J.name unless ref G.way->{J.name} eq 'HASH';
     
     my $tw = Rw huck + */around;
     
     if (!$tw) {
        Rw up +;
        Rw out +;
     }
     
     saygr "around ! ! J.name ".F_delta()
         unless J.yt.quiet;
     
     # try return stuff? pretty aroundo
     @{(values %$tw)[0]} if $tw
makoo: | # BLAG
       sayre "to make some code? ".wdump [sort keys %$u];
       return;
       my $t = Rw wuck - $u */flows/*;
       my $fr = 0;   
       my $amp = G.ampampamp ||= do{$fr=1;{}};
       for my $k (sort keys %$t) {
           my $v = $t->{$k};
           my ($path,$flows,$from) = split '/', $k;
           
           Rw make/op $amp $pin:k $path $from;
       }
       my $hk = {%{R.way.hooks}};
       for my $z ($hk, $amp) {
           for my $k (keys %$z) {
               next unless $k =~ /^g_(.+)$/;
               say "Has $k";
               $z->{$1} = delete $z->{$k};
           }
       }
       my $x;
       x.wormhole.yr = $hk;  
       x.wormhole.ya = $amp;
       while (my ($dir, $v) = each %$x) {
           while (my ($k, $d) = each %$v) {
               my $y = YAML::Syck::Dump($d);
               die wdump $y if length $y < 50; 
               $y =~ s/^---//;
               encode_utf8 $y;
               fspu("$dir/$k\.yml", $y);
           }    
       }
       
       # maka yml, seeing .s is a gas leak
       `cd wormhole; cat yr\.yml ya\.yml > yb\.yml`;
       #$fr = 1;
       $fr ?
       $G->pub('S/'.$_, "reexec")
       :
       $G->pub('S/'.$_, "wayup w/yb\.yml") for 'shed','coast';
       sayyl "We o ".F_delta();
       
       Rwyl 0.1 J5 scr;
gui: # turn into some
     yJ: |
       'gui quigeo rondo' 
     out: |
       Rw oJ7;
rondo:
     yJ: |
       J.cv = 20;
       J.most.mody = 'mani';
       J.most.eo = 'chuv';
aww:
   yJ: |
     'clw gui heag sope waz Atime zipl Travel';
     
     
shd:
   sh: |
     Rw J5 shw $style=shv $aj;
   
floorish: |
    spun 0 -0.12
    zoom 0 1
    y    0  0.84 
    x    0  0
    curve 0 -0.4

shrad/curves: | 
       spun 0 0
       spin 0 0.2
       zoom 0 1.2 
       y    0  0.5
       x    0  0.6
       curve 0 1 
       # curve 0.4 0.4
       #spin 0.3 2
shv/curves: [EZ: cur/sjiv]
shw/curves: [EZ: cur/land]
  
cur/sjiv: |
       zoom 0 1.4
       y    0  0
       x    0  0.02
       curve 0 -0.2
       curve 0.4 0.4
       spin 0.3 2
cur/topd: |
       spun 0 0
       zoom 0 1.6
       y    0  0
       x    0  0.02
       curve 0 -0.3
cur/land: |
       spun 0 0.2
       zoom 0 1.6
       y    0.001  0.2
       x    0.001  0.9
       curve 0 -0.3 


newwave: | # THE TAKER
    saygr "EXactly";
    G.oin = Rw JJ join;
    Rw up $J:G.oin;
    
    Rw cl/tidy;
    #Rw zoybracken;
    Rwyl 0.01 fresh_init;
    1
lod/C:
   wam/on: noe 0.1 eye/o {ou:eye,blur:5px}
   fresh_init: |
     #die wdump [ G.way.ano];
     Rw J5 wa;
   recoded_init: |
     Rw fresh_init;
     #$G->pub('S/hut/K', 'do make/up')
     #   if $m =~ /\/k\//;  
lod/u:
   shv/curves: [EZ: floorish]
   wam/on: noe 0.1 g/k/1  {ou:eye,blur:5pt}
   fresh_init: Rw J5 wam;
   recoded_init: |
      rand(5) > 3 &&
      Rw J5 wam;
join:
     yJ: |
       G.oin = $J;
       'join clw rondo'
     around: |
       sayre "J.name    around:!". ki $ar;
     up: |
       # G.oin root ww:.
       Rw J5 Ha;
       Rw J5 wu;
       # iterations:
       Rw J5 toc;
     X: |
       # message goes up to wu via A
       my $oJ = J.oJ.A || die 'noway';
       Rw A/X $J:oJ $X:J;
       # to inX for the A delbbl
       Rw J5 $J $X:J;
       Rw J5 $J=J.name
       if e.S;
     inX: |
       die "dont join/inX";
toc:
     yJ: |
       'toc'
     around: |
       Rw vortex toc/up $J $d=3;
     up: | #
       # hops, rhythm aesthetics
       # things pur ambiently & incur pipes of sprawlingness into music
       # to space it out right...
       # for the mass of the atom of thought
       # wants emit with precision, figure processing/Em route into time
       # is a subscribe that catches up as %vv is join bz'd
       
       my $oJ = G.oin;
       
       #my $ip = {style=>'vv'};
       my $ip = {};
       my $timey = Rw tc $J:oJ $ip;
       my $tw = {};
       acum $tw, _.sc.vv, $_ for grep { _.sc.vv } @$timey;
       my $one = 0;
       for my $k (sort keys %$tw) {
           my $v = $tw->{$k};
           for my $C (@$v) {
               last if $one;
               $one = 1;
               sayyl "spawning C.t   C.y.cv   ".ki C.sc;
               my $sc = {map{$_=>C.sc->{$_}}grep{!/\W/}keys%{C.sc}};
               timer 0.001 {
                   oJn('','',$sc);
               };
           }
       }
Ha: # how not, T is
   yJ: |
     'Ha'
   around: |
     my $now = hitime();
     return if J.last > $now - 0.4 || G.pslagtil > $now;
     $now - J.last < 9 && Rw vortex around $J $d=5;    
     J.last = $now;
     G.ino ||= $J;
     
     my $N = Rw tc $J;
     my $lcv;
     my $i;
     for my $d (@$N) {
         my $n = d.c.s;
         
         my $com;
         my $dont;
         if (d.sc.watime) {
             my $del = d.sc.watime - hitime;
             $com = "w\@in ".sprintf('%.3f',$del);
             if ($del > 0.02) {
                 if (d.sc.watime != d.sc.watimed) {
                     # & shift out Ha 6
                     #sayyl "WAYLAY $del to n.t";
                     my $ip = {l=>d.t,cv=>d.y.cv};
                     timer $del {
                        Rw around $J;
                     };
                     J.bz->("d.t%watimed\t".d.y.cv => d.sc.watime);
                 }
                 $dont = 1;
             }
             
         }
         #my $mers = "WAITS  ".slim(10,d.t)."  n.t\t d.y.cv  $com  ".ki (1,n.c)." \t\t";#.d.sc.pict;
         #$dont ? saybl $mers : sayyl $mers;
         next if $dont;
         
         Rw hoset + $d;
         #sayyl "RE& n.t  at d.y.cv  d.sc.pict";
         
         timer 0.001 {
             Rw oo $J:G.oin $d:n;
         };
         
         $i++;
         last if $lcv && $lcv > d.y.cv;
         $lcv = d.y.cv;
     }
     
ok5: |
    my $J = C.sc.J||die;
       A.ztime = 1;
       A.note.not&csrm,'ok';
       
       my $co = A.jr&ok-$v;
       my $til = $co - hitime;
       # cv wave column to plant next self in
       A.waov = $v;
       # assume that v shapes delay until DNS of tension
       my $del = $v;
       if ($co && $til < 0) {
           sayre "running late: ". $til if $til < -0.1;
           A.ztime = $v if $v > A.ztime; # on there
           undef $co;
       }
       elsif (!$co) {
           $del = 0.1;
           sayyl "C.t begins";
       }
       $del *= 3.7;
       $del *= 1.2 if rand 5 > 3;
       $co ||= $del + hitime;
       
       A.watime = $co;
       die "yep";
       
       say "!! $til for A.ztime   ".ki C.c;
       A.jr&ok-$v,$co;
hoset: |
    my @r = map { d.t.($_?'%'.$_:'')."\t".d.y.cv } '', keys %{d.sc};
    delete J.bb->{$_} for @r;
    
hosin: |
    n.sc = ar.sc if ar.sc; n.c.s = n.s if exists n.s; n.y.cv = n.cv if n.cv;
    my @glu = map { '%'.$_ => n.sc->{$_} } sort keys %{n.sc};
    J.bz->(n.t."\t".n.y.cv => n.c.s, @glu);
comb: |
    # so that J.2 etcs declare needs and resume when ready
    my $iJ = G.ino || return do{warn "no loop";1}; # continues the Atime
    
    
    A.selif = Rw cscomp $C $ig:A.note;
    my $dig = dig A.selif;
    
    die "wamngle $wa" if $wa != int($wa) || $wa < 1 || $wa > 9;
    die 'noiJ' if !$iJ;
    
    my $n;
    n.sc.pict = A.selif;
    n.sc.watime = A.watime if A.watime;
    $wa = A.waov if A.waov;
    n.cv = $wa / 10;
    n.s = {%$C};
    n.t = $dig;
    
    sayyl "COMB J.name  C.t  A.ztime } to $wa \t ".ki 1,C.c;
    
    Rw hosin $J:iJ $n;
    0;
cscomp: |
    my $non = {%$C};
    my $de;$de = sub {
        my $v = shift;
        ref $v eq 'ARRAY' ?  [map{ $de->($_) } @$v]
        : !ref $v ? $v
        : v.id || die "no v".wdump(2,$v);
    };
    for my $k (qw'c sc') {
        my $v = $non->{$k} || next;
        $non->{$k} = $v = {%$v};
        for my $sk (keys %$v) {
            my $sv = $v->{$sk};
            $v->{$sk} = $de->($sv);
        }
    }
    non.cv = ''.non.cv;
    non.s = $de->(non.s);
    return sjson $non



Gto: | # is made, babbed
    my $G = $G;
    G.name = 'thouG';
    my $mkD = sub {
        my ($pin,$ar)=@_;
        my $D;
        D.point = $pin;
        
        if (my $C = ar.__D) {
            delete ar.__D;
            D.bab = C.c.s || die "N s".ki $C;
            D.noise .= C.sc.dige if C.sc.dige;
            if (my $ba = C.sc.bab) {
                sayyl "D.t has ".ki C.sc;
                D.babnon = $ba eq 'non' ? 1 : die "WHat is bab=$ba ?";
            }
            D.Verb = 1;
        }
        D.ar = $ar;
        D.name = join ' ', D.point, sort keys %{D.ar};
        D.sign = "Z";
        D.talk = join' ',grep{defined}map{$D->{$_}}qw'sign name noise';
        $D;
    };
    G.log = sub {
        fscc('w/glog',"\n".shift);
    };
    G.pwin = sub {
        my $point = shift;
        my $way = shift;
            return $way->{$point} if exists $way->{$point};
            my @path = split /\/|\./, $point;
            my $h = $way;
            for my $p (@path) {
                $h = $h->{$p};
                unless ($h) {
                    undef $h;
                    last;
                }
            }
            return $h if defined $h;
            
            return undef unless $point =~ /\*/;
            die "sat rs findy $point";
    };
    Rw Galso;
    Rw Ghuts;
    G.w = sub {
        my ($pin,$ar)=@_;
        my $D = $mkD->($pin,$ar);
        
        
        if (!defined D.bab) {
            D.bab = G.way->{$pin};
        }
        if (!defined D.bab) {
            if ($pin =~ /\//) {
                #say "windshot: $pin" unless $pin =~ /^pi/;
                D.bab = fwind(G.way,$pin);
            }
        }
        
        if (!defined D.bab && !ar.__D && ar.A) {
            my $c = ar.A;
            map{$c = $c->{$_} if $c} qw'J A II W 0.4';
            if ($c) {
                my $C = $c->{$pin};
                if ($C) {
                    c.sc.acgt && die "selected W4".ki$C;
                    ar.__D = $C;
                    $D = $mkD->($pin,$ar);
                }
            }
        }
        
        if (!defined D.bab) {
            die "Not findin D.talk";
            return;
        }
        G.log->(D.talk) if G.logs;
        
        my $Z = G.Doming->($D);
        G.randomtask->() if G.randomtask;
        my $r; eval { $r = [ G.D->($Z) ] };
        sayyl "D.talk BANG: $@" if $@ && !G.bangplu++;
        G.Done->($Z);
      
        if ($@) {
            die $@;
            $@ = "";
        }
        return wantarray ? @$r : $r->[0];
    };
    $G
Galso: | # Gooso goner # 
    G.d = sub {
        my $in = shift @_;
        my $y = G.d->{$in} || die "No way $in go GGG";
        $y->(@_); # to ACGT when 64
    };
    G.A = sub {
        my $am = shift;
        my $D = $F[0];
        my $r = D.ar;
        my $A = r.A || die 'GhnoA';
        my $I = A.I || die 'GhnoI';
        I.d&Other,$am;
    };
    # lifted from 64 Gooso
        my %T = %{G.T||{}};
        {
            package Wormhole;
            use Tie::Hash;
            use YAML::Syck;
            our @ISA = qw(Tie::StdHash);
            sub FETCH {
                my ($s,$k) = @_;
                return $s->{$k} if $k eq 'dir';
                $s->{$k} ||= do {
                    my $d = s.dir;
                    my $il = join('/', grep{defined} $d, $k);
                    my $f = "w/$il";
                    if (-d $f) {
                        my %Di;
                        tie %Di, 'Wormhole';
                        my $di = \%Di;
                        di.dir = $il;
                        $di
                    }
                    elsif (-f $f) {
                        print "Loading $f ...\n";
                        LoadFile($f);
                    }
                    else {
                        die "Wormhole sens nothing: $f";
                    }
                };
            }
        }
        tie %T, 'Wormhole';
        G.T = \%T;
    
    
        {
            package Ghoz; #
            use Tie::Hash;
            our @ISA = qw(Tie::ExtraHash);
            sub TIEHASH {
                my $class = shift;
                my $sto = bless [{},@_], $class;
                $sto
            }
            sub FETCH {
                my ($s,$k) = @_;
                my ($st,@o) = @$s;
                return $st->{$k} if exists $st->{$k};
                option:
                for my $o (@o) {
                    if (my $in = o.inp) {
                        my $v = o.o;
                        for my $i (@$in,$k) {
                            exists $v->{$i} || next option;
                            $v = $v->{$i};
                        }
                        return $v;
                    }
                    else {
                        die "Hwoto climb a ".G::ki $o;
                    }
                }
            }
        }
    G.tie = sub {
        my ($class,@Me) = @_;
        my %na;
        tie %na, $class, @Me;
        return \%na
    };
    
    G.comeback = sub {
        my $Dome = shift;
        
        my $a;
        a.name = 'r';
        a.from = $Dome;
        my $Doing = $G->Doming($a); 
        
        $G->D({D=>Dome.D, toplevel=>1, talk=>"351 dollars",name=>"comeback"});
        
        $G->Done($Doing);
        
        sayre $@ if $@; # TODO toplevely
        $@ = "";
    }
        
Ghuts: |
    G.sigstackend = sub {
        local $@;
        eval { confess( '' ) };
        my @stack = split m/\n/, $@;
        shift @stack for 1..2; # hide above this sub, G eval & '  at G...';
        @stack = @stack[0..20] if @stack > 24;
        my @stackend;
        push @stackend, shift @stack until $stack[0] =~ /g::ggggggg/ || !@stack;
        s/\t//g for @stackend;

        # write on the train thats about to derail
        my $wall = $F[0]->{SigDieStack}||=[];

        push @$wall, \@stackend;
    };
    G.sigstackwa = sub {
        return 1 if $_[0] =~ /^Use of uninitialized value/;
        if ($_[0] =~ /Deep recursion on/) {
           return if G.deepr++ < 9;
           G.deepr = 0;
           sayre "snoozing $F[0]->{talk}";
           snooze();
           return;
        }
        my @loc = caller(1);
        $@ = join "\n", @_;
        my $DOOF = G.Duck->($F[0],1);
        $@ = "";
        sayre $DOOF;
        exit;
        return 1;
    };
    G.Doming = sub {
        my $D = shift;
        die "More to DOming" if @_;
        $D = G.pyramid->($D);
        unshift @F, $D;
        D.F = [@F];
        return $D;
    };
    G.pyramid = sub {
        my $am = shift;
        confess "Ba" if ref $am ne 'HASH';

        my ($last) = @F;
        my $u = {%$am};
        if ($last) {
            push @{last.Lo||=[]}, $u;
            u.Li = $last;
        }
        else {
            push @{G.East||=[]}, $u;
        }
        u.G = $G;
        u.K = u.name || die "No Dome Name";
        u.hitime = hitime;
        u.order = H.pyramiding++;
        u.stack = stack(2,7);
        u.F = [@F];
        u.depth = 0+@F;
        u.Error = $@ if $@; #?

        $u
    };
    G.Done = sub {
        my $D = shift;
        sayre join"", ("BATS  ")x 23 if $F[0] ne $D;
        D.dolat = $@ if $@;
        $_->() for @{D._after_do||[]};
        shift @F;
        G.Duck->($D) if $@;
        $_->() for @{D._aft_etc_do||[]};
        $D
    };
    G.D = sub { #c
        my $D = shift;
        my $ar = D.ar || {};

        die "RECURSION ".@F if @F > $MAX_FCURSION;
        my $sub = D.D || do {
             D.Ds = G.Dm->($D);
             D.Ds.sub;
        };
        D.sign = 'D';
        D.talk = "D.sign D.name";
        $D = G.Doming->($D);
        my @return;
        if (ref $sub eq "CODE" && !$@) {
            local $SIG{__DIE__} = G.sigstackend;
            local $SIG{__WARN__} = G.sigstackwa;
            
            #sub ggggggg {eval{shift->(@_)}}
            wantarray ? 
            #do { @return = $sub->(D.ar)} # stack crawl wants to see ggggggg
            #: do { $return[0] = $sub->(D.ar)};
                do { @return = ggggggg($sub, D.ar) }
                : do { $return[0] = ggggggg($sub, D.ar) };
        }

        G.Done->($D); # Ducks
        D.r = [@return];

        return wantarray ? @return : shift @return
    };
    G.Dm = sub {
        my $am = shift;
        
        am.talk || confess wdump 2, $am;
        my $Ds = G.drop.Dscache->{am.talk};
        return $Ds if $Ds;
        
        die "SOMEONENONE".wdump 1, $am if ref am.bab;
        
        
        my $eval = am.bab;
        $eval = $G->parse_babble($eval) unless am.babnon;
        
        my $ar = am.ar || {};
         ar.R = $G;
        my $download = join("", map {
            'my$'.$_.'=$ar->{'.$_."}; "
            } keys %$ar)
            if %$ar;
        my $upload = join("", map {
            '$ar->{'.$_.'}=$'.$_."; "
            } keys %$ar)
            if %$ar;
            
        my $sub = "bollox";
        my $evs = 'sub { my $ar = shift; '.
        "$download\n".

        "my \@doo_return = (sub { \n\n$eval\n })->();\n"

        #."$upload"
        .'return @doo_return };';

        
        $sub = G.Doe->($evs, $ar);
            
        $@ = "nicht kompilieren!\n\n$@" if $@;
        
        $Ds = {evs=>$evs, sub=>$sub, talk=>am.talk};

        if (!$@ && ref $sub eq "CODE") {
            G.drop.Dscache->{am.talk} = $Ds;
        }
        else {
            am.bungeval = $evs;
        }
        $Ds
    };
    G.Doe = sub {
         my $D_eval_string = shift;
         my $ar = shift;
         return eval $D_eval_string;
    };
      
    G.Duck = sub { #c
        my $D = shift;
        my $nodie = shift;
        my $evs = D.Ds.evs;
        my $ar = D.ar;

        my $DOOF; 
        my $first = 1 unless $@ =~ /DOOF/;
                
        $DOOF .= "DOOF D.talk\n" if D.sign eq 'D' || $nodie;
        $DOOF .= "  D.inter" if D.inter;
        
        if ($first) {
            my $x = $1 if $@ =~ /syntax error .+ line (\d+), near/
                || $@ =~ /line (\d+)/;

            my $file = $1 if $@ =~ /at (\S+) line/;

            undef $file if $file && $file =~ /\(eval \d+\)/;
            undef $file if $file && !-f $file;

            my $code = $file ? 
            read_file($file)
            : $evs;
            
            my $eval = G.Duckling->($x, $code, $D);
            
            if (exists $D->{SigDieStack}) {
                warn "3MALTY SIGGI" if @{$D->{SigDieStack}} > 3;
                $DOOF .= "\n";
                my $i = "  ";
                for my $s ( reverse flatline($D->{SigDieStack}) ) {
                    $DOOF .= "$i- $s\n";
                    $i .= "  ";
                }
            }        
            $DOOF .= "\n$eval\n";
        }
        
        if ($first) {
            $DOOF .= ind("E    ", "\n$@\n\n")."\n\n";
        }
        else {
            my $in = D.sign eq 'D' ? "! " : "";
            $DOOF .= ind($in, "$@")."\n";
        }
        
        if ($first) {
            $DOOF .= ind('ar.', join "\n",
                map{
                 my $e = $ar->{$_};
                 my $s = "$e";
                 $s .= "(name=$e->{name})"
                     if ref $e && ref $e ne 'ARRAY'
                    && $e->{name};
                "$_ = ". $s;
                }keys %$ar); 
        }
        
        sayre "NO DIE? D.talk" if $nodie;
        return $DOOF if $nodie;
        
        D.Error = $DOOF;
        $@ = $DOOF;
        if (G.gbang++ > 110) {
            sayre "long explosion...\n$@";
            exit;
        }
        if (@F < 1) {
            # send it away
            $DOOF = join"\n",map{s/^(\! )+//smg if !/DOOF/; $_}split"\n",$DOOF;
            sayre $DOOF;
            exit;
            G.dooftip && G.dooftip->($@);
            $@ = "";
            $_->() for @{G._aft_err_do||[]};
        }
        else {
            die $@;
        }
    };
    G.Duckling = sub {
        my ($line, $code, $D) = @_;
        
        my $diag = "";
        my @code = split "\n", $code;
        my $whole = @code < 18;
        
        
        if (!D.Verb && $code =~ /^sub \{ my \$ar = shift/
            && $code =~ /return \@doo_return \};/) {
            $line -= 2 if $line;
            shift @code for 1..2;
            pop @code for 1..2;
        }
        
        
        my $xx = 0;
        my $lci;
        for my $c (@code) {
            $xx++;
            $lci = $1 if $xx < $line && $c =~ /^\s*(#\s*\d.*)$/;
            if (!defined $line) {
                $diag .= ind("  ", $c)."\n"
            }
            elsif ($xx == $line) {
                $diag .= ind("  ", $c)."\n";
                
                my $bab = (split"\n",D.bab)[$line-2];
                if ($bab ne $c) {
                    $diag .= ind("r ", $bab)."\n";
                }
            }
            elsif (!$whole && $xx > $line-5 && $xx < $line+5) {
                $diag .= ind("|  ", $c)."\n"
            }
            elsif ($whole) {
                $diag .= ind("|  ", $c)."\n"
            }
        }
        
        $diag = "$diag\n#~~~$lci" if $lci && $lci !~ /^# 0.01/;
        $diag
    };
   

Followe: | # eg th=openevent
    # (everything threes)
    u linesfollow
    u Ipifalls
    # ^ qq {cpi:lines u:followlines}
    J.VV.N = 1;
    y.ope = 1;
    y.at.oWl = 1;
    # y.at.es = 'closeline' # & a provider of closeline = Trabit
    J.ev.th = 'middle';
    J.ev.tr = 1;
    J.ev.f.line = 'openevent';
    
    sayyl "Checkin following...";
    !ref $s && $s &&
    n Follow =>''=>{pi=>cfile=>s=>$s,create=>1}
    
    n $C
linesfollow: |
    u allvse
    n '','','%of:J'
    n J =>62221,<<''
        C.c.pi eq 'lines' &&
        u followlines
    
openevent: | # $e, join Followe to Trabit as an event
    saybl "OPENEVENT J.name: for C.t called C.c.e.t";
    n Trabit=>$C
Trabit: |
    u pi3d
    u Ipifalls
    y.ope = 1;
    J.ev.th = 'middle';
    J.ev.tr = 1;
    J.ev.av = 'avel';
    n $C
avel: | # dry mounds of any velocities
    say "Travel J.name avel ".ki E.c.s;
    J.VV.N = 1;
    my $n = ++J.ieuye;
    n travel=>($n * 0.1)=>{pi=>line=>s=>E.c.s}
    # comeback &, watching whatever Norgs pha cones into time
    #n done=>($n * 0.1)=>{s=>"Delivered to ..."}

