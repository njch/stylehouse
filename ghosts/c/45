

jeocling: | # give isle
    J.pix = [{any=>1,Rw=>'jeocling'}];
    saybl "On J.name from A.J.name: ".ki A.J.at;
    u jseo
    u trWs
    y.at.isle = 'jes';
trWs: |
    u allvse
    n '','','%of:Mo'
    n W =>3211,<<''
        return if A.J.C.sc.pi eq 'trW';
        C.c.s = delete C.c.W;
        C.c.pi = 'trW';
    
pi/trW: | # uses localeo
    my $isle = C.c.isle || J.mo.J.at.isle;
    $isle || die "No isledea !? J.name of J.mo.J.name has; ".ki J.mo.J.at;
    my $f = "w/$isle/$s";
    say "J.name:   J.mo.J.name eq A.J.name";
    my $Jd = "w/$isle/J/J.mo.J.name";
    `mkdir -p $Jd` if !-d $Jd;
    if ($isle ne J.mo.J.at.isle) {
        say "$s has src over in $isle";
        my $clue = "$Jd/${s}_src_$isle";
        `touch $clue`;
        #`cd $Jd; ln -s ../../../$isle/$s ${s}_src` panic: sv_setpvn
    }
    my $jf = "$Jd/$s";
    my $traveli;
    for ($jf) {
        next unless -s $_;
        $traveli = read_file($_);
        saybl "Travel from $_: ".wdump 3,[
            $traveli
        ];
    }
    if (!$traveli && -f $f) {
        say "Found $f !";
        n $f =>3,$s,{X=>LoadFile($f)}
        `touch $jf` && sayre "Xuper $f" if !-f $jf;
    }
    else {
        say "Making  $s !";
        my $c = {map{$_=>C.c->{$_}}grep{exists C.c.->{$_}}qw'noXup{%{C.c}}
        n $s=>W=>
        `cat /dev/null > $jf`;
    }
    saybl "Donel  $jf";
    
Sweep: |
    n stylesweep
stylesweep: |
    u alljse
    n hs =>44,<<''
        $.each(s.thy,function(k,v){
            C.sc[k] and C.sc.css[v] = C.sc[k];
        });
        $.each(s.roi,function(k,v){
            var o = C.sc.css[k];
            !o and return;
            var ve = v[0];
            var ss = v[1];
            C.sc.css[ve] ||= {};
            C.sc.css[ve][ss] = o;
            delete C.sc.css[k];
        });

