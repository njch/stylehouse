Jtt: | # Jto
    my $J;
    J.id = mkuid;
    J.name = ar.t || ar.name || shift @{delete ar.m};
    J.bb = {};

    J.le = ar.le if ar.le; # nonpi Jiter
    J.most.J = $J; # pi change Jiterest
    J.mo = J.most;
    J.mo.s = G.oin;
    J.most.mody = 'mani';
    J.most.eo = 'Yesui';
    J.most.wq = 1;
    J.A.IIII = [@{G.IIII||['G/T/Wild']}];
    J.A.Indo = 2;
    
    Rw Nbz $J;
    Rw Viu $J;
    
    my $sc = {tag=>J.name,id=>J.id};
    Rw jamsc $J $t=J.name $cv=0.9 $s=J.name $sc;
    J.uname = J.name;
    J.A.keep.bb = {%{J.bb}};
    
    return $J;
qq: | # u
    # getting run t
    # qode qompiler
    # does each thing input... has out that joins up
    # networkable infinity
    # J (above)  # does u thing
    #   J qq     # gets W/thing as inbryo or stored G.oin Wemotables
    #   ^        # settles (Jbove wants out, to do n)
    #   output G compressions (+/- laws, booKed, Domes)
    # J eats   " "
    # /home/s/Music/Nurse With Wound/2004 .mp3
    # sense stream, wired with c.from = CCC (spiral cut &&)
    # A.c feed, seek oMins, could be way wider langusage (embassy work to other)
    # note Spanish order ^    ^
    
      # uCon re Y.rv.scism
        # wants to flatten to clifes over into ootrees, branching in changes
        # and branching those changes from oo Noodle into an aj
        # which adjuncts waves of newness
        # intermixing
        # this N is something to be indexed, its oo-side may exist already
        # could even stitch travel hashes, which are the most particulate
        # thrown into I
        # upon Intry to the I, II is created, some indexes throw up
        # waves of infinity crashing together
        # II can be consumed, it's is separated at the top level
        # but merges down, ts clobber
        # can fill up live as it is A.II, the recreated I in 2
        # crated from the I, surroudingings, and the II
        # falling with A, quantum state relative to G
        # sing into its ownwhere it is to be a bunch of travely jugheads
        # much easier
        # watching pha cones, concats
    
    
     # all thoughts are prayed to some beast
     # acquire Y personality:# is a 4d join! something n'd in, certain conditions already from 6...
     # whatever is high in the plain is coming at us
      # canopy
      # pi lays out in tiles
     # worked up to via aj/In jig, or T huck d&n&er
     
     # make pool, synth space, want arches
     # fork & rejoin to exciting place
     # the valley, what it means to be here in here YIN
     # ^ DESCRIBE how we're in here to
     # also the executablur
     # if something wants to mess with itself when...
     
     
    # F says how to make an A for it
    # then A.t&3 etc moves time forward, ore return is crux slot craft
    # return @$_ for A.t&3;
    # so we can hijack Ein by the something
    # and want to inject a tiny bit of code in this one circumstance
    # joins up by whether its there at all (u vic)
    # and what code=>thing is referring into... known at utime by Athing
    # all tumbling down F right behind ...
    
    # define how to throw sheets of language
    # do zis first stuff...
    # and and...
    # how cached waveforms W together as they get further down
    # the users

    # uCon renders vectors of thought into...
    # TODO many phases of u/n uCon shares/reelects bystanding I+ things
    # the qq phasing is loosely coupled to our phasing,
    #  qq appends while we J 6 T, Yesui suggests knowing branches about T too
    # so we can non-linear ajc/sc, just like re-c
    # which could clue us to which previous conversation to keep
    # Yesui reelects bits of J lying around the wormhole to make selves out of
    # like implanting n consciousness with W hop
    # based on a past prehension of part to whole
    # results magnetising tresultsv
    
    zultsv
    
    # curve falls # MAKES TRAVEL, just throw on J.Idex
    # three and two circles 
    # get that banjo
Nbz: | # receiver of buzzed out planes of N (C)   # peeler futuro, forte arbiter # suJ cloned  # other is A.jr
    J.tt = 1;
    J.bz = sub { # the cv=>t=>style r
       my $m = [@_];
       sayre "bz not 2 @$m" if @$m != 2;
       my $j={};
       while (@$m) {
           my ($r, $v) = (shift @$m, shift @$m);
           if ($r =~ /^%(\S+)/) {
               j.style = $1;
           }
           else {
               # to ivertake in here
               $j = Rw r2j $r $J;
           }
           defined j.cv || die "NOSEYV: j.cv".wdump[$j,[@_],[$r, $v]];
           
           j.r = join "\t", j.cv, j.t, j.style;
           j.s = $v;
           my @Js = $J;
           push @Js, values %{J.phy} if J.phy;
           for my $jj (@Js) {
               jj.bb->{j.r} = j.s;
               push @{jj.ord}, {%$j} if jj.ord;
               jj.tim->{j.r} = hitime() if jj.tim;
               jj.wtf->{j.r} = $F[0] if jj.wtf;
               jj.ap->($j) if jj.ap; # <<<
           }
      }
    };
    $J
Viu: | # u/n/m pinging uCon, setup part Jto
    my $eu = sub { J.uS = 1 };
    my $unu = sub {
        J.uS || return;
        Rw uCon;
        J.uS = 0;
    };
    my $dJ = sub {
        my @m = @_;
        shift @m if ref $m[0] && $m[0] eq $J;
        pop @m while $m[-1] eq '';
        @m>4&&die"mvelope>4".wdump 2, \@m;
        [@m]
    } if $ARGV[-1] ne '3';
    my $oAr = sub { # bit of dome escape vector
        my ($ar) = @_;
        my $oA = ar.oA = {};
        oA.subline = (caller(1))[2];
        oA.D = $F[0];
    };
    # 6 shul start u pha
    J.u = sub {
       $eu->();
       my $ar;
       ar.N = [$dJ->(@_)];
       ar.J = Rw Elj $J qq;
       $oAr->($ar);
       Rw In;
    };
    J.n = sub {
       $unu->();
       my $ar;
       ar.J = $J;
       ar.N = [$dJ->(@_)];
       $oAr->($ar);
       Rw In;
    };
    J.m = J.M = sub {
       $unu->();
       shift @_ if ref $_[0] && $_[0] eq $J;
       my $ar;
       ar.M = shift;
       ar.J = $J;
       ar.N = [$dJ->(@_)];
       $oAr->($ar);
       Rw In;
    };
UnPreDuv: |
    delete J.El.Pre; # diff bb-Y
    delete J.El.Duv; # diff Y-shell
    
uCon: |
    my $A = {J=>$J};
    # am U?
    A.talk = "A.J.name ".(A.J.le && A.J.le.name);
    
    my $qq = Rw Elj $J qq;
    if (my $los = qq.A.los) {
        my $Yb = qq.A.los.lbbst;
        %{qq.bb} = (%{qq.A.keep.bb||{}}, %{los.bb||{}});
        #sayyl "qq applies: ".wdump 2, 
        #    Rw wtfch $Jb:qq.bb $Yb;
        los.end->();
    }
    my $Y = Rw Noodles $J:qq;
    my $oo = Rw Elj $J oo;
    
    my $rv = Y.rv;
    if (@{rv.sc}) {
        sayre "SLIPPING SC, dropping qq past" for 1..3;
        J.on_usc->() if J.on_usc;
        snooze;
        Rw UnPreDuv $J:qq;
        return Rw uCon;
    }
    
    if (J.A.Ii eq rv.i) {
        say "uCon ---- A.talk: ".F_delta() if J.V;
    }
    else {
        my $N = [@{rv.c}];

        J.A.Ii ?
            J.A.Ii ne rv.i ?
                sayre "A.talk: Diff o J.A.Ii -> rv.i"
              : return say "A.talk: Same J.A.Ii"
          : sayre "A.talk: New uCon ! rv.i";

        Rw uThree $A $J $Y $qq $oo $rv $N;

        say "uCon ch: J.name: ".F_delta() if J.V;
    }
    if (J.A.I.U) {
        Rw In $J $t=U;
    }
    qq.A.los = Rw pha $J:qq los;
    qq.A.los.lbbst = {%{qq.bb}};
    #losI.d&pha,los;
    
uThree: | # shadow qq via oo - curve expnd
    @$N = Rw humms $J:oo $N wongui _;
    @$N = Rw humms $J:oo $N notnotcode _;
    my $sc = [@$N];
    my $s = Rw humms $J:oo $N concoi;
    #Rw humms $J:oo $N talky;
    
    
    if (!%$s) {
        sayyl "No s from: ".
            Rw ZNews $sc $nov=1;
    }
    # as the i,i,i coalesces, later
    J.A.Ii = rv.i;
    J.A.I = $s if %$s;
    delete J.A.I if !%$s;
    
    # then A.Ii sees J.A.I (+more, concat) hashrefs i aj like
    # which is a stilled wave of vectors
    # the wave can catch up to itself
    # the usual plywood spiral peel
    # made {s=>$s,ply=>'K/cv/t:D',grp=>'K/cv&c,sc,gr'}
    # climb the limbs in falling A.mo.y./..
    # you are suggesting I use more noisey code
    #saygr Rw TreeD $s $scby=gro;
    
Modems: |
    n Pha
    n Jamsc
    n Timing
    J.V = 1;
Pha: |
    u allof
    n '','','%of:I'
    
    n pha =>''=><<'',{acgt=>'J,name'}
        # tracked being
        # temporal phatness, per suJ (encap $M surges within)
        if (my $x = J.phy->{$name}) {
            sayre "J.name 's $name was re entrant";
            I.d&end,$x;
            # end - maybe new stuffright as some random part of this process
            # hold yay minutes of changes in 10 second groups, etc
        }
        # bz multicasts
        my $x = J.phy->{$name} = {};
        x.begin = hitime();
        x.name = $name;
        x.J = $J;
        x.bb = {};
        x.ord = [];
        #x.tim = {};
        #x.wtf = {}; # F grab
        #x.ap = sub{}; # bz do aftering
        x.qui = 1;
        x.head = J.phl->{$name}->{l}->[-1] if J.phy->{$name};
        $x;
    
    # abandonupgrade to what's there already, early exity lop
    n bandon =>''=><<''
        delete s.J.phy->{s.name};
        s.abandoned = 1;
        if (my $x = s.head) {
            I.d&as,$s,$x;
        }
        I.d&end,$s
    
    n as =>''=><<'',{acgt=>'s,x'}
        for (qw'begin bb ord tim wtf') {
             exists $x->{$_} || next;
             my $v = $x->{$_};
             $v = [@$v] if ref $v eq 'ARRAY';
             $v = {%$v} if ref $v eq 'HASH';
             $s->{$_} = $v;
        }
    
    n end =>''=><<''
        my $y = s.J.phl->{s.name} ||= {name=>s.name, l=>[]};
        s.ended = hitime();
        delete s.J.phy->{s.name};
        shift @{y.l} while @{y.l} > 5;
        # layers ^ rolling in time index .r -> the y.l
        # so last phase of $name can be found?
        push @{y.l}, $s;
        if (s.bb) {
            my $w = @{y.l};
            y.l_bb->{$_} = $w for keys %{s.bb};
        }
        # somewhere thinks about what happened
        $y
    
    n exactl =>''=><<'','%l:#c un-ins things from J'
        my $q = shift;
        my $y = I.d&end,$s;
        my $cur = y.l->[-1];
        my $last = y.l->[-2];
        $cur eq $s || die "sidf$cur $s";
        last.bb ||= {};
        .
        my $wtf = I.d&wtfch,cur.bb,last.bb;
        .
        delete s.J.bb->{$_} for keys %{wtf.gone};
        .
        # see s.extill, time passing interesto...
        # churn stats like 30% of last disappear, 20% new
        s.wtf = $wtf;
        $wtf;
    
    # J future, Y saves
    n wtfch =>''=><<'',{acgt=>'Jb,Yb',l=>'#c diff J'}
        my $wtf = {};
        wtf.same = 1;
        $wtf->{$_} = {} for qw'new diff gone';
        .
        for (sort keys %$Jb) {
            if (!exists $Yb->{$_}) {
                wtf.new->{$_} = $Jb->{$_};
                wtf.same = 0;
            } 
            elsif ($Yb->{$_} ne $Jb->{$_}) {
                wtf.diff->{$_} = $Jb->{$_};
                wtf.same = 0;
            }
            else {
                wtf.sami++;
                wtf.still->{$_} = $Jb->{$_};
            }
            wtf.tot++;
        }
        for (grep { !exists $Jb->{$_} } sort keys %$Yb) {
            wtf.gone->{$_} = $Yb->{$_};
            wtf.same = 0;
        }
        $wtf;
    
    # the mess C-er
    # safe vs doing - sheets of J->Y, dont drop any frames
    # where we start being onlies
    n Elvis =>''=><<'',{acgt=>'J,Y',l=>'#c'}
        my $wtf = I.d&wtfch,J.bb,Y.bb;
        .
        Y.tw ||= {};
        Y.lo = {}; # compile
        .
        for my $mo (qw'gone diff new') {
            for my $r (keys %{$wtf->{$mo}}) {
                my $j = I.d&rJ,$r,$J;
                j.r = $r;
                j.lt = j.cv."\t".j.t;
                if (!j.lt=~/\S/) {
                    die "Got $r =>   ".ki $j;
                }
                if ($mo eq 'gone') {
                    delete Y.bb->{j.r};
                    delete Y.tw->{j.lt}->{j.style};
                }
                else {
                    Y.bb->{j.r} = j.s;
                    Y.tw->{j.lt}->{j.style} = j.s;
                }
                Y.lo->{j.lt}->{$mo}->{j.style} = j.s;
            }
        }
        .
        Y.tv ||= {};
        Y.v ||= {};
        Y.go = {};
        my $same = 1;
        for my $k (keys %{Y.lo}) {
            my $tf = Y.lo->{$k};
            my $cs = Y.tw->{$k};
            if (tf.new && !tf.gone && !tf.diff && keys %{tf.new} == keys %$cs) {
                $same = 0; # new line to make
            }
            if (tf.gone && !keys %$cs) {
                $same = 0; # line to disappear
                my $C = Y.go->{$k} = delete Y.tv->{$k};
                my ($cv,$t) = $k =~ /^(.+?)\t(.*)$/;
                delete Y.v->{$cv}->{$t};
                delete Y.v->{$cv} unless keys %{Y.v->{$cv}};
            }
            if (tf.diff || tf.new) {
                keys %$cs || die 'nokeys';
                my ($cv,$t) = $k =~ /^(.+?)\t(.*)$/;
                defined $cv || die "twas $k";
                my $foam = sub {
                    my $C = shift;
                    %$C = (t=>$t,y=>{cv=>$cv},c=>{},sc=>{%$cs});
                    C.c.s = delete C.sc->{''} if exists C.sc->{''};
                };
                $foam->(Y.tv->{$k} ||= {});
                $foam->(Y.v->{$cv}->{$t} ||= {});
            }
        }
        if (!$same) {
            Y.vs = [];
            Y.kvi = {};
            Y.cvi = {};
            my $i = 0;
            for my $k (sort keys %{Y.tv}) {
                my $C = Y.tv->{$k} || die "wtf $k";
                push @{Y.vs}, $C;
                Y.kvi->{$k} = $i;
                Y.cvi->{C.y.cv} ||= $i;
                $i++;
            }
        }
        .
        Y.ra = I.d&ratio,wtf.sami,wtf.tot;
        Y.rato = wtf.tot;
        Y.revs = !$same;
        .
        $Y;
    
    
    
    n Elj =>''=><<'',{acgt=>'J,name',l=>'#c with a self'}
        J.El->{$name} ||= Rw Jto - $le:J $name;
    
    n El =>''=><<'',{acgt=>'J,name',l=>'#c without a self'}
        J.El->{$name} ||= {bb=>{},name=>$name};

    
Elj: | # I usual
    my $name = ar.name || shift @{delete ar.m};
    if (my $Y = J.El->{$name}) {
        return $Y;
    }
    J.El->{$name} = Rw Jto - $le:J $name;
Timing: |
    u allof
    n '','','%of:I'
    # RAY SCUTTLER read parts, given rv and possibly since rl 
    # puts newzs in flat list, they themselves unify time etc.
    n scd =>''=><<'',{acgt=>'rv,rl'}
        my $r;
        r.z = [];
        r.oldz = [];
        undef $rl if $rl && rl.c ne rv.c;
        push @{$rl ? r.oldz : r.z}, @{rv.c};
        .
        r.in = @{rl.sc||[]};
        r.out = @{rv.sc};
        if (r.out > r.in) {
            r.ay = [r.in..(r.out - 1)];
            push @{r.oldz}, @{rv.sc}[0..r.in] if r.in;
            push @{r.z}, @{rv.sc}[@{r.ay}];
        }
        $r

    n ratio =>''=><<'',{acgt=>'o,t'}
        my $ratio = $o / ($t||1);
        0.01 * int(100*$ratio);
    
Jamsc: | # all the \t bz-io, very J2, inline thing protocol
    u allof
    n '','','%of:I'
    
    # interpreter of buzzed puit partiscules r -> j.[cv,t,style]
    # opens schema, how to interpret r to J
    n rJ =>''=><<'',{acgt=>'r,J',l=>'#c'}
        my $j;
        my $sing;
        if (J.tt) {
            $sing = 'J_tt';
            (j.cv,j.t,j.style) = $r =~ /^(.*?)\t(.*)\t(.*?)$/;
            if (!defined j.cv) {
                sayre "Hind $r  " for 1..5;
                (j.t,j.style,j.cv) = $r =~ /^(.+?)(?:%(.+))?\s+(.+?)$/;
            }
        }
        else {
            (j.t,j.style,j.cv) = $r =~ /^(.+?)(?:%(.+))?\s+(.+?)$/;
        }
        defined j.cv || die "$sing no $r    ".ki $j;
        j.s = J.bb->{$r} if $J;
        j.nos = 1 if $J && !exists J.bb->{$r};
        $j;

    # put C in bb, some towering tractor beams (ljm)
    n jamsc =>''=><<'','%l:#c'
        my $ar = $s;
        my $sc = ar.sc || {};
        my $J = ar.J || die "jamsc noj".ki$s;
        ar.C = ar.d if ar.d;
        my $t = defined ar.t ? ar.t
            : ar.j ? ar.j.l
            : ar.C ? ar.C.t : die'not';
        my $cv = defined ar.cv ? ar.cv
            : ar.j ? ar.j.cv
            : ar.C ? ar.C.cv || ar.C.y.cv : die'cvoy';
        .
        if (ar.oJ && ar.oJ ne ar.J && !ar.noR) {
            my $J = ar.oJ;
            if (my $ljm = J.A.ljm) {
                my $Me = "ar.oJ.ind ar.J.name "
                ." J.A.ljmo <<< J.name  sends:"
                ." $t\t$cv  $ljm";
                sayyl $Me if J.V || ar.J.V;
                push @$ljm, {%$ar};
            }
        }
        .
        my @fobz;
        push @fobz, [$cv,$t,undef,ar.s] if exists ar.s;
        push @fobz, [$cv,$t,$_,$sc->{$_}] for keys %$sc;
        my @tobz = map {
            my ($cv,$t,$s,$v) = @$_;
            my $r;
            if (J.tt) { # FUTU
                $r = $cv."\t".$t."\t".$s;
            }
            else {
                my $s = $s;
                $s = '%'.$s if $s;
                $r = $t.$s."\t".$cv;
            }
            if ($s) {
                ar.C.sc->{$s} = $v;
            }
            [$r,$v]
        } @fobz;
        .
        for (@tobz) {
            my ($r,$v) = @$_;
            J.bz->($r,$v);
        }
El: | # goner
    my $name = ar.name || shift @{delete ar.m};
    my $Y = J.El->{$name} ||= {bb=>{},name=>$name};
Elvus: | # goner El with arbitrary in-J Elvi with thrust over, possibly   - c for J must be already seT
    my $Y = Rw El;
    my $oJ = ar.oJ || $J;
    Rw Elvis + $J:oJ $Y;
    $Y
J5: |
   return sayre "RECUR" if @F > 150;
   my $r = {%$ar};
   r.W = ar.name || shift @{delete ar.m};
   delete r.R;
   my $J = G.oin;
   my $i = Jn('','',$r);
   my ($s) = @{i.is};
   return s.sc.J||die "no sc J";
J6: | # do J=>m not W=>m, looser
   ar.J = ar.name || shift @{delete ar.m};
   Rw J5 +; 
collaspII: | # acquire perhaps even time 1, spiral spiraled IIII and I
    # you could make it keep A.II, which includes A.IIIII, many tiles
    my $II = A.J.A.II ||= {};
    Rw spII $A $II J/A/IIII J/A/III J/A/I;
    $II;
    
spII: | # thereis a II being passed overhead, entrance to spIII N C applier/updater
    my @N = @{ar.m};
    my @C;
    while (@N) {
        my $m = shift @N;
        my $r = G.pwin->($m, $A);
        if (ref $r eq 'ARRAY') {
            unshift @N, @$r;
        }
        elsif (ref $r eq 'HASH') {
            push @C, {t=>$m,c=>{s=>$r}};
        }
    }
    my $Ii = join " + ", map{"_.t:_.c.s"} @C;
    $Ii eq II.Ii && return;
    if (my $TI = G.TT->{$Ii}) {
        die "DifgTI " if TI.Ii ne $Ii;
        %$II = %$TI;
        $Ii eq II.Ii || die "Hiked GTT TI.Ii ne $Ii";
        return G.protV && sayyl "Hiked GTT $Ii";
    }
    else {
        G.TT->{$Ii} = $II;
    }
    II.Ii = $Ii;
    # we dive into always, should form tidy tree with D chaos at tips
    # the screening space saver, the no way out-er
    my $N = [@C];
    my $s = {};
    (
    Rw spIII $A $II $N K/cv/t $s
    =~ /stabilised/ && say("Stabilised A.talk ...") && 0
    || A.J.V > 1) &&
    saybl Rw TreeD $s $scby=gro;
    
    say "Spidered A.talk: ".F_delta if A.J.V;
spIII: |
    my $ooI = ar.ooI;
    $ooI ||= II.ooI ||= {};
    ooI.mo ||= $ooI;
    delete ooI.st if ooI.mo eq $ooI;
    my $m = [@{ar.m}];
    @$m = split '/', $m->[0] if @$m == 1;
    my $n = shift @$m;
    $n||die "Non? $n @$m ooI.ins";
    @$N||die"noNsp";
    
    my $Ii = join " + ", map{"_.t:_.c.s"} @$N;
    return "ooI.ins stabilised" if $Ii eq ooI.Ii;
    ooI.Ii = $Ii;
    
    my $E = {%$II};
    %$II = ();
    
    my $tw = {map{$_=>1} map{ keys %{_.c.s} } @$N};
    # can comission stillness
    # we all look like each other's Jesuses
    # must in N order move in changed hashes
    # but our awareness of
    my @say;
    for my $K (sort keys %$tw) {
        next if $K eq 'Ii' || $K eq 'ooI';
        if (@$m) {
            my $III = $II->{$K} = $E->{$K} ||= {};
            my $oI = ooI.K->{$K} ||= {mo=>ooI.mo};
            my $S = $s->{$K} ||= {};
            # ^ thse particles
            oI.ins = (ooI.ins&&"ooI.ins/")."$K";
            my $N = [
                map { {t=>_.t,c=>{s=>_.c.s->{$K}}} }
                grep {exists _.c.s->{$K}}
                @$N
            ];
            my $d = ar.d + 1;
            push @say,
            Rw spIII $A $II:III $ooI:oI $N $m $d $s:S;
        }
        else {
            my @C = grep {exists _.c.s->{$K}} @$N;
            # say "manyC for $K" if @C > 1;
            for (@C) {
                $s->{$K} =
                ooI.mo.st->{ooI.ins}->{_.t}->{$K} =
                    $II->{$K} = _.c.s->{$K};
            } 
            
        }
    }
    delete ooI.K->{$_} for grep {!$tw->{$_}} keys %{ooI.K};
    
    if ($ooI eq ooI.mo) {
        II.Ii = $Ii;
        II.ooI = $ooI;
    }
    join "\n",grep{defined}@say;
TreeD: |
    # $scby
    my $bydef = "^";
    my @say;
    for my $K (sort keys %$s) {
        my $vs = $s->{$K};
        for my $cv (sort keys %$vs) {
            my $tw = $vs->{$cv};
            my $g = {};
            while (my ($k,$D) = each %$tw) {
                my $gk = D.sc->{$scby} || $bydef;
                # ^
                # v
                $g->{$gk}->{$k} = $D;
            }
            for my $gk (sort keys %$g) {
                my $ts = $g->{$gk};
                push @say, sprintf ' %-9s %-6s %-18s %27s',
                    $K, $cv, $gk, join(",", sort keys %$ts);
            }
        }
    }
    join "\n", @say

