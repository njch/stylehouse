
oJ2: |
     sayyl "oJJJ oJJJ ".wdump $C;
     C.c.y ? Rw oy2
     :
     C.c.W ? Rw oW2
     :
     C.c.J ? do { # mod way over
         C.c.W = $v;
         A.ztime = 3;
         # amount of time each thing spends being the top level
         # which was... n... mani
     }
     : die "misrep ".ki $C;
opi2: | # approach - c language is map to some u before 6ing
    at.pi = $v || 'guess';
    C.c.J = 'pie';
    
    my $oJ = $J;
    $oJ = C.y.o.J if C.y.o && C.y.o.J;
    A.jr = Rw Ajr $J:oJ $C;
   
oW2: | # some get-J or weave wires protocol - hosts
    my $t = $v;
    $t = v.name if ref $t;
    at.J = ref $v ? $v : $t;
    at.W = $t;
    C.c.J ||= $v;
    
    die wdump ["onto W J.name:",$v] if ref $v && $v ne v.most.J;
    
    C.t = $t;
    # has already been 0.1 in Y
    C.y.cv ||= 0.3;
    
    A.jr = Rw Ajr $J:G.oin $t $cv=0.3;
    
    # and where the
    if (C.c.vv) {
        A.ztime = delete C.c.vv;
        A.jr&vv,9
        ->(); #delone
    }
Ajr: | # aimed at J and a K/line: C or t/cv    sends style => $v
      sub {
          my $s = shift;
          my $v = shift;
          my $d = shift;
          $s = '%'.$s if $s;  
          my $t = exists ar.t ? ar.t : ar.C.t;
          my $cv = exists ar.cv ? ar.cv : ar.C.y.cv;
          my $r = $t.$s."\t".$cv;
          if ($d) {
              sayre "delbbl $r  $d   J.name" for 1..5;
              Rw delbbl $J $l:t;
          }
          saybl " chuck $r     $v  >  ".J.bb->{$r} if J.V;
          !defined $v ?
            J.bb->{$r}
          : do {
              J.bz->($r, $v);
              sub { delete J.bb->{$r} } 
          };
      };
pidepth: |
    my $o = $J;
    my $i = 0;
    while (o.Jiter) {
        $i++; $o = o.Jiter;
    }
    $i;

