Viu: | # u/n/m ping 
    my $eu = sub { J.uS = 1 };
    my $unu = sub {
        J.uS || return;
        Rw uCon;
        J.uS = 0;
    };
    my $dJ = sub {
        my @m = @_;
        shift @m if ref $m[0] && $m[0] eq $J;
        pop @m while $m[-1] eq '';
        if (@m < 4) {
            $m[2] ||= {J=>$m[0]};
            @m == 3 || die "!!!\n".wdump[@m];
        }
        while (@m > 4) {
            die "m too big J.name ::: ".wdump 2, \@m;
        }
        [@m]
    };
    J.u = sub {
       $eu->();
       my $ar;
       ar.C = [$dJ->(@_)];
       ar.J = Rw Elj $J qq;
       Rw In;
    };
    J.n = sub {
       $unu->();
       my $ar;
       ar.J = $J;
       ar.C = [$dJ->(@_)];
       Rw In;
    };
    J.m = J.M = sub {
       $unu->();
       my $ar;
       shift @_ if ref $_[0] && $_[0] eq $J;
       ar.M = shift;
       ar.J = $J;
       ar.C = [$dJ->(@_)];
       Rw In;
    };
C_EC: |
    I.ECu = sub { # extend C on the way in to another dome, magnetised into our M
        # probably for collapsing roooves...
        # dumber than sc decompresphere & playing out
        # (is mailing itself further instructions, intro c, further lines)
        # an In persona, joining our M
        my ($A,$C,$G,$T,$s) = @_;
        ref $s eq 'ARRAY' || die;
        my ($N,$c) = @$s;
        my $E; # push to dome
        # that must in  A
        E.Ci.3.doextend = sub {
            my ($A,$C,$G,$T) = @_;
            I.d&extend,$C,$c;
        };
        say "Rein In: ";
        Rw stwo $J $n=ECReIn $N;
        #wdump 17,[$N,'====','====',$C,$s];
        Rw In $J $M:T.oM $N $E;
        # ^but instead push to A.N and A.No, the sister strand Whare Y Whare
        # and A walks through t&Y, d&Whare(6)
        # turns via n&ACGT
        # the time beams mapped... a W concat couldol
        T.not = 1;
    };
stwo: |
    my $I = Rw already;
    my $o;$o = sub { # not, nearly news (Tray n)
        my ($n,$N) = @_;
        my $t;
        my ($A,$C,$T) = ({},{},{});
        I.d&n,$A,$C,$G,$T;
        if (ref $N eq 'HASH') {
            if (N.EC) {
            saybl "wonguizlist".wdump N.EC if $n =~ /wonguizlist/;
                $t.="EC{".@{N.EC};
                N.sc.z && die'wazyECsc';
                N.sc.z = N.EC;
            }
            my $sig = join ' ', sort keys %$N;
            $sig eq 'c sc t y' || sayre "Siendg $sig";
            %$C = %$N;
        }
        elsif (ref $N eq 'ARRAY' && !ref $N->[0]) { # feel terrain
           I.d&4real,$N;
        }
        else {
           C.c.s = $N;
        }
        I.d&Cr;
        my $yc;
        if (C.y.cv && keys %{C.y} == 1) {
            $yc = "  C.y.cv";
            delete C.y;
        }
        $yc = delete(C.t).$yc;
        sayyl "! $n    $t $yc  ". ki $C;
        if (my $z = C.sc.z) {
            for my $Z (@$z) {
                $o->("$n    ", $Z);
            }
        }
    };
    $o->($n,$_) for ref $N eq 'ARRAY' ? @$N : die"topray";
    "and ..."
ym/wongui: |
    my $D = {t=>z=>y=>4=>c=>{nk=>'sc',gk=>'z',as=>'list'}};
    
    my @go = A.c->($D);
    sayyl "Slamped ".wdump 5,[$D,$C];
    for my $zi (A.c->($D)) {
        my $from = [];
        push @$from, A.c&from;
        push @$from, $C;
        my $c = {c=>{from=>$from}};
        my $s = {EC=>[$zi,$c]};
        saybl "Wiz: ";
        my $N = [$s];
        # brained crash - not dealing with list of things anymnore
        saybl wdump 8, $N;
        Rw stwo $J $n=wonguizlist $N;
        push @{A.N}, $s;
    }
uCon: |
    my $A = {J=>$J};
    
    my $qq = Rw Elj $J qq;
    my $Y = Rw Noodles $J:qq;
    my $rv = Y.rv;
    my $oo = Rw Elj $J oo;
    
    say "On J.name went qq.name =-> oo.name rv.i ";
    Rw stwo $J $n=UNbefore $N:_
    for [@{Y.rv.c},@{Y.rv.sc}];
    
    say F_delta();
    my $M = [];
    # wants to flatten to clifes, keeping pathT/t/t/t , watching pha cones
    $J = $oo;
    my $N = [
        {MZ=>'wongui'},
        @{Y.rv.c},
        @{Y.rv.sc},
    ];
    # curve falls
    Rw In $J $N $M;
    
    $N = [
        @{Y.rv.c},
        @{Y.rv.sc},
    ];
    sayyl "NJO : ".
    Rw stwo $J $n=UconedNsource $N;
    #sayyl "INJOIUT : ". wdump 55, $M;
    
    #In 
    
Elvus: | # arbitrary in-J Elvi with thrust over, possibly   - c for J must be already seT
    my $Y = Rw El;
    my $oJ = ar.oJ || $J;
    Rw Elvis + $J:oJ $Y;
    $Y
El: |
    my $name = ar.name || shift @{delete ar.m};
    my $Y = J.El->{$name} ||= {bb=>{},name=>$name};
Elj: |
    my $name = ar.name || shift @{delete ar.m};
    if (my $Y = J.El->{$name}) {
        return $Y;
    }
    J.El->{$name} = Rw Jto - $name;
J6: | # do J=>m not W=>m, looser
   ar.J = ar.name || shift @{delete ar.m};
   Rw J5 +; 
J5: |
   return sayre "RECUR" if @F > 150;
   my $r = {%$ar};
   r.W = ar.name || shift @{delete ar.m} if ar.m;
   delete r.R;
   my $J = G.oin;
   my $i = Jn('','',$r);
   my ($s) = @{i.is};
   return s.sc.J||die "no sc J";
Jto: |
    my $J;
    J.id = mkuid;
    J.name = ar.name || shift @{delete ar.m};
    J.bb = {};

    J.most.J = $J;
    J.most.mody = 'mani';
    J.most.eo = 'Yesui';
    J.most.wq = 1;
    
    # GONERS
    Rw suJ $J;
    Rw Jup $J;
    # 
    
    n J.name, 0.9, J.name, {tag=>J.name,id=>J.id}
    
    Rw Viu $J;
    
    return $J;
Nbz: | # receiver of buzzed out planes of N (C)   # peeler futuro, forte arbiter # suJ cloned  # other is A.jr
    J.tt = 1;
    J.bz = sub { # the cv=>t=>style r
       my $m = [@_];
       die "not 2 @$m" if @$m != 2;
       my $j={};
       while (@$m) {
           my ($r, $v) = (shift @$m, shift @$m);
           if ($r =~ /^%(\S+)/) {
               j.style = $1;
           }
           else {
               # to ivertake in here
               $j = Rw r2j $r $J;
           }
           defined j.cv || die "NOSEYV: j.cv".wdump[$j,[@_],[$r, $v]];
           
           j.r = join "\t", j.cv, j.t, j.style;
           j.s = $v;
           my @Js = $J;
           push @Js, values %{J.phy} if J.phy;
           for my $jj (@Js) {
               jj.bb->{j.r} = j.s;
               push @{jj.ord}, {%$j} if jj.ord;
               jj.tim->{j.r} = hitime() if jj.tim;
               jj.wtf->{j.r} = $F[0] if jj.wtf;
               jj.ap->($j) if jj.ap; # <<<
           }
      }
    };
    $J

