Viu: | # u/n/m pinging uCon, setup part Jto
    my $eu = sub { J.uS = 1 };
    my $unu = sub {
        J.uS || return;
        Rw uCon;
        J.uS = 0;
    };
    my $dJ = sub {
        my @m = @_;
        shift @m if ref $m[0] && $m[0] eq $J;
        pop @m while $m[-1] eq '';
        if (@m < 4) {
            $m[2] ||= {J=>$m[0]};
            @m == 3 || die "!!!\n".wdump[@m];
        }
        while (@m > 4) {
            die "m too big J.name ::: ".wdump 2, \@m;
        }
        [@m]
    };
    my $oAr = sub { # bit of dome escape vector
        my ($ar) = @_;
        my $oA = ar.oA = {};
        oA.subline = (caller(1))[2];
        oA.D = $F[0];
    };
    J.u = sub {
       $eu->();
       my $ar;
       ar.C = [$dJ->(@_)];
       ar.J = Rw Elj $J qq;
       $oAr->($ar);
       Rw In;
    };
    J.n = sub {
       $unu->();
       my $ar;
       ar.J = $J;
       ar.C = [$dJ->(@_)];
       $oAr->($ar);
       Rw In;
    };
    J.m = J.M = sub {
       $unu->();
       shift @_ if ref $_[0] && $_[0] eq $J;
       my $ar;
       ar.M = shift;
       ar.J = $J;
       ar.C = [$dJ->(@_)];
       $oAr->($ar);
       Rw In;
    };

C_E: |  # elvission/I joinsession/c convene
    # u/n/m get here, we know ar.
    # here we step further into the light grabbing
    # parts spine up from In's A the In, using qqJ.A
    # but the broken tiles of use cassettes- culture eddies, vines of intuit
        I.interpD = sub { # make csc grab exprD
            my ($A,$C,$G,$T)=(shift,shift,shift,shift);
            my ($nk,$gk) = @_;
            my $D = {};
            if (ref $nk) {
                $D = $nk
            }
            else {
                while ($gk =~ s/^%(.+?):(.+?)(?=%|$)//g) {
                    D.c->{$1} = $2;
                    pop @_ if @_ == 2;
                }
                if (@_ == 1) { # or from t,,,
                    D.c.nk ||= 'c';
                    D.c.gk ||= $nk;
                }
                elsif (@_ == 2) {
                    D.c.nk = $nk;
                    D.c.gk = $gk;
                }
            }
            $D
        };
    I.An = sub {
        my ($A,$C,$G,$T) = @_;
        A.note = {}; # pinging csc
        A.c = sub { # 
            my ($D) = @_;
            $D = I.d&interpD,@_ if !ref $D;
            
            exists C.c->{$_} && die "COT INTERESTING ".ki $C for qw'code if of ref';
            
            my $v = I.d&Cngk,$D;
            return () unless $v;
            
            A.note->{D.c.nk}->{D.c.gk} = $v if A.note;
            
            die 'mulitAn' if @$v > 1;
            if (D.c.as eq 'list') {
                return ref $v eq 'ARRAY' ? @$v : die'Cngk not array';
            }
            return 1;
        };
        A.t = sub {
            @_>2 && die "_ _";
            my ($cv,$K) = reverse @_;
            $K ||= A.am||die"noam A_t";
            if (my $i = J.A.I) {
                I.d&ex,$i,$K=>$cv
            }
            # man 
        };
        $A
    };
    Rw C_D;
uCon: |
    my $A = {J=>$J};
    
    my $qq = Rw Elj $J qq;
    my $Y = Rw Noodles $J:qq;
    my $rv = Y.rv;
    my $oo = Rw Elj $J oo;
    
    say "On J.name went qq.name =-> oo.name rv.i ";
    #Rw stwo $J $n=UNbefore $N:_
    #for [@{Y.rv.c},@{Y.rv.sc}];
    
    say F_delta();
    # wants to flatten to clifes, keeping pathT/t/t/t 
    # watching pha cones
    #$J = $oo;
    # curve falls # just throw J.Idex on
    
    
    my $N = [@{rv.c}];
    sayre "SLIPPING SC" if @{rv.sc};
    $N = [{MZ=>'wongui'}, @$N];
    my $M = [];
    Rw In $J:oo $N $M;
    $N = $M;
    
    my $want = [[sc=>'code']];
    Rw stwo $J $n=ourt $N $want $noz=1 $q=1;
    $N = $want;
    
    saybl "AND AGHAIN for J.name u";
    
    my $s = {};
    $N = [{MZ=>{concoi=>$s}}, @$N];
    $M = [];
    Rw In $J:oo $N $M;
    $N = $M;
    Rw stwo $J $n=again $N $noz=1;
    J.A.I = $s if %$s;
    delete J.A.I if !%$s;
    #say "Reckonon J.name: ".wdump 5, J.A.I;
    
    
     
C_D: |
    I.moy = sub {
        my ($A,$C,$G,$T,$s) = @_;
        my $i = A.mo.y->{$s}||die"no$s";
        my $is = $i->{C.y.p}; # things in our C's pool
        {is=>$is,N=>[map{$is->{$_}}sort keys %$is]};
    };
    I.ex = sub {
        my ($A,$C,$G,$T,$i,$K,$cv) = @_;
        # A wind down to K cv
        # is a wad of what matters
        # matter - time it matters
        # 
        for my $k (sort keys %$i) {
            my $ii = $i->{$k};
            sayre "extry $K $cv - $k" if $K ne $k;
            for my $vc (sort keys %$ii) {
                my $iii = $ii->{$vc};
                sayre "extry $K $cv - $k $vc" if $cv ne $vc;
                for my $ik (sort keys %$iii) {
                    my $D = $iii->{$ik};
                    if (D.sc.args) {
                        sayre "DEEE catchping $K $cv   D.t D.y.cv";
                    }
                    die if D.sc.gk;
                    my $paw = join"_",'',$k,$vc,D.t;
                    $paw =~ s/\W//g;
                    Rw $paw $A $C $G $T $__D:D;
                }
            }
        }
    };
ym/concoi: |
    my $s = C.sc.code || return;
    
    C.y.p ||= join'/',map{_.t}@{C.c.from||[]};
    C.y.cvt ||= "C.y.cv\tC.t";
    
    T.y.spr=$C if A.t&42 && $s=~/^(\^|1)$/;
    
    if ($s=~/^\^$/ && A.t&61) {
        my $i = I.d&moy,'spr';
        # this is at spray
        C.c.s = join "\n",map{
            _.sc.got = 1 if $_ ne $C;
            "#@ _.y.p\n"."_.c.s\n"
        }@{i.N};
        C.sc.code =~ s/^\^ ?//;
        C.sc.code ||= "C.t 4";
        sayyl "Com espel ".wdump 2, $C;
    }
    if (my $acgt = C.sc.acgt) {
        C.sc.args = join',','A,C,G,T',grep{$_ ne '1'}$acgt;
        undef C.sc.code if C.sc.code eq '1';
        C.sc.code ||= "I 2";
    }
    $_ = C.sc.code;
    if (/\w+ \w+/) {
        my ($K,$cv) = ($1,$2) if /^(\w+) (\d+)$/ || die "wtf '$_'  ".ki$C;
        sayyl "Ke on J.le.name  J.name  $_".ki $C;
        
        if (my $args = C.sc.args) {
            C.c.s = "A.".$K.".".C.t." = sub {\n"
                ."    my (".join(',',map{'$'.$_}split',',$args).") = \@_;\n"
                ."    my \$I = A\.I;\n"
                .join("\n",map{"    $_"}split "\n", C.c.s)."\n"
                ."};\n";
            
        }
        
        C.sc.dige = slm 12, dig C.c.s;
        $v->{$K}->{$cv}->{C.t} = $C;
        C.sc.got = 1;
    }
    
    
    
    
    if (my $y = T.y) {
        for my $k (keys %$y) {
            A.mo.y->{$k}->{C.y.p}->{C.y.cvt} = $C;
        }
    }
ym/wongui: |
    my $D = {t=>z=>y=>4=>c=>{nk=>'sc',gk=>'z',mdrl=>1,as=>'list'}};
    $C->{$_} = {%{$C->{$_}||{}}} for 'c','sc';
    
    for my $zi (A.c->($D)) {
        my $from = [
            reverse $C, reverse map{@$_} A.c&from,'%as:list'
        ];
        my $c = {c=>{from=>$from}};
        my $s = {EC=>[$zi,$c]};
        push @{A.N}, $s;
    }
stwo: |
    my $I = Rw already;
    my $sel = [] if ar.want;
    my $o;$o = sub { # not, nearly news (Tray n)
        my ($n,$N) = @_;
        my $t;
        my ($A,$C,$T) = ({},{},{});
        I.d&n,$A,$C,$G,$T;
        I.d&An;
        if (ref $N eq 'HASH') {
            my $sig = join ' ', sort keys %$N;
            $t .= "car: $sig" unless $sig eq 'c sc t y';
            %$C = %$N;
        }
        elsif (ref $N eq 'ARRAY' && !ref $N->[0]) { # feel terrain
           I.d&4real,$N;
        }
        else {
           C.c.s = $N;
        }
        I.d&Cr;
        
        my $nC = {%$C};
        my $yc;
        if (C.y.cv && keys %{C.y} == 1) {
            $yc = "  C.y.cv";
            delete nC.y;
        }
        $yc = delete(nC.t).$yc;
        if (my $f = C.c.from) {
            $n .= " _.t /" for 
                grep{ref $_ eq 'HASH' || die wdump $_}
                @$f;
        }
        
        my $s = "! $n    $t $yc  \t\t". ki $nC;
        $s =~ s/\n/â†¯/g;
        if (my $wa = ar.want) {
            my $y;
            for my $try (@$wa) {
                my @am = A.c->(@$try);
                next if !@am;
                $y++;
            }
            if ($y) {
                push @$sel, $C;
                sayyl $s unless ar.q;
            }
            else {
                saybl $s unless ar.q;
            }
        }
        else {
            saygr $s unless ar.q;
        }
        if (my $z = C.sc.z) {
            for my $Z (@$z) {
                last if ar.noz;
                $o->("$n    ", $Z);
            }
        }
    };
    $o->($n,$_) for ref $N eq 'ARRAY' ? @$N : die"topray";
    @{ar.want} = @$sel if $sel;
    "and ..."
Elvus: | # arbitrary in-J Elvi with thrust over, possibly   - c for J must be already seT
    my $Y = Rw El;
    my $oJ = ar.oJ || $J;
    Rw Elvis + $J:oJ $Y;
    $Y
El: |
    my $name = ar.name || shift @{delete ar.m};
    my $Y = J.El->{$name} ||= {bb=>{},name=>$name};
Elj: |
    my $name = ar.name || shift @{delete ar.m};
    if (my $Y = J.El->{$name}) {
        return $Y;
    }
    J.El->{$name} = Rw Jto - $le:J $name;
J6: | # do J=>m not W=>m, looser
   ar.J = ar.name || shift @{delete ar.m};
   Rw J5 +; 
J5: |
   return sayre "RECUR" if @F > 150;
   my $r = {%$ar};
   r.W = ar.name || shift @{delete ar.m} if ar.m;
   delete r.R;
   my $J = G.oin;
   my $i = Jn('','',$r);
   my ($s) = @{i.is};
   return s.sc.J||die "no sc J";
Jto: |
    my $J;
    J.id = mkuid;
    J.name = ar.name || shift @{delete ar.m};
    J.bb = {};

    J.le = ar.le if ar.le;
    J.most.J = $J;
    J.most.mody = 'mani';
    J.most.eo = 'Yesui';
    J.most.wq = 1;
    
    # GONERS
    Rw suJ $J;
    Rw Jup $J;
    # 
    
    n J.name, 0.9, J.name, {tag=>J.name,id=>J.id}
    
    Rw Viu $J;
    
    return $J;
Nbz: | # receiver of buzzed out planes of N (C)   # peeler futuro, forte arbiter # suJ cloned  # other is A.jr
    J.tt = 1;
    J.bz = sub { # the cv=>t=>style r
       my $m = [@_];
       die "not 2 @$m" if @$m != 2;
       my $j={};
       while (@$m) {
           my ($r, $v) = (shift @$m, shift @$m);
           if ($r =~ /^%(\S+)/) {
               j.style = $1;
           }
           else {
               # to ivertake in here
               $j = Rw r2j $r $J;
           }
           defined j.cv || die "NOSEYV: j.cv".wdump[$j,[@_],[$r, $v]];
           
           j.r = join "\t", j.cv, j.t, j.style;
           j.s = $v;
           my @Js = $J;
           push @Js, values %{J.phy} if J.phy;
           for my $jj (@Js) {
               jj.bb->{j.r} = j.s;
               push @{jj.ord}, {%$j} if jj.ord;
               jj.tim->{j.r} = hitime() if jj.tim;
               jj.wtf->{j.r} = $F[0] if jj.wtf;
               jj.ap->($j) if jj.ap; # <<<
           }
      }
    };
    $J

