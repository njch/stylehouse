Viu: | # u/n/m pinging uCon, setup part Jto
    my $eu = sub { J.uS = 1 };
    my $unu = sub {
        J.uS || return;
        Rw uCon;
        J.uS = 0;
    };
    my $dJ = sub {
        my @m = @_;
        shift @m if ref $m[0] && $m[0] eq $J;
        pop @m while $m[-1] eq '';
        if (@m < 4) {
            $m[2] ||= {J=>$m[0]};
            @m == 3 || die "!!!\n".wdump[@m];
        }
        while (@m > 4) {
            die "m too big J.name ::: ".wdump 2, \@m;
        }
        [@m]
    };
    my $oAr = sub { # bit of dome escape vector
        my ($ar) = @_;
        my $oA = ar.oA = {};
        oA.subline = (caller(1))[2];
        oA.D = $F[0];
    };
    J.u = sub {
       $eu->();
       my $ar;
       ar.C = [$dJ->(@_)];
       ar.J = Rw Elj $J qq;
       $oAr->($ar);
       Rw In;
    };
    J.n = sub {
       $unu->();
       my $ar;
       ar.J = $J;
       ar.C = [$dJ->(@_)];
       $oAr->($ar);
       Rw In;
    };
    J.m = J.M = sub {
       $unu->();
       shift @_ if ref $_[0] && $_[0] eq $J;
       my $ar;
       ar.M = shift;
       ar.J = $J;
       ar.C = [$dJ->(@_)];
       $oAr->($ar);
       Rw In;
    };



uCon: |
    my $A = {J=>$J};
    # am U?
    A.talk = "A.J.name ".(A.J.le && A.J.le.name);
    
    my $qq = Rw Elj $J qq;
    #qq.V = 1;
    my $Y = Rw Noodles $J:qq;
    #qq.V = 0;
    my $oo = Rw Elj $J oo;
    
    Rw uThree $A $J $Y $qq $oo;
uThree: |
    my $rv = Y.rv;
    my $N = [@{rv.c}];
    # curve falls # MAKES TRAVEL, just throw on J.Idex
    # three and two circles
    # get that banjo
    
    #return if J.A.Ii eq rv.i;
    
    sayre "A.talk: Diff o J.A.Ii -> rv.i";
    
    if (@{rv.sc}) {
        # wants to flatten to clifes over into ootrees, branching in changes
        # and branching those changes from oo Noodle into an aj
        # which adjuncts waves of newness
        # intermixing
        # this N is something to be indexed, its oo-side may exist already
        # could even stitch travel hashes, which are the most particulate
        # thrown into I
        # upon Intry to the I, II is created, some indexes throw up
        # waves of infinity crashing together
        # II can be consumed, it's is separated at the top level
        # but merges down, ts clobber
        # can fill up live as it is A.II, the recreated I in 2
        # crated from the I, surroudingings, and the II
        # falling with A, quantum state relative to G
        # sing into its ownwhere it is to be a bunch of travely jugheads
        # much easier
        # watching pha cones, concats
        sayre "SLIPPING SC" for 1..5;
        snooze;
        delete qq.El.Pre; # diff bb-Y
        delete qq.El.Duv; # diff Y-shell
        return Rw uCon;
    }
    die "sc slip" if @{rv.sc};
    
    @$N = Rw InCoil $J:oo $N wongui _;
    # sense stream, wired with c.from = CCC (spiral cut &&)
    # A.c feed, seek &= found M, could be way wider langusage (embassy work to other)
    # note Spanish order ^    ^
    @$N = Rw InCoil $J:oo $N wantcode _;
    
    oo.V=1;
    my $s = Rw InCoil $J:oo $N concoi;
    
    #Rw InCoil $J:oo $N talky;
    
    # as the i,i,i coalesces, later
    J.A.Ii = rv.i;
    J.A.I = $s if %$s;
    # then A.Ii sees J.A.I (+more, concat) hashrefs i aj like
    # which is a stilled wave of vectors
    # the wave can catch up to itself
    delete J.A.I if !%$s;
    say "Reckonon J.name: ".F_delta();
    # the usual plywood spiral peel
    # made {s=>$s,ply=>'K/cv/t:D',grp=>'K/cv&c,sc,gr'}
    my $scby = "gro";
    my $bydef = "^";
    # climb the limbs in falling A.mo.y./..
    # you are suggesting I use more noisey code
    for my $K (sort keys %$s) {
        my $vs = $s->{$K};
        for my $cv (sort keys %$vs) {
            my $tw = $vs->{$cv};
            my $g = {};
            while (my ($k,$D) = each %$tw) {
                my $gk = D.sc->{$scby} || $bydef;
                # ^
                # v
                $g->{$gk}->{$k} = $D;
            }
            for my $gk (sort keys %$g) {
                my $ts = $g->{$gk};
                saygr sprintf ' %-9s %-6s %-18s %18s',
                    $K, $cv, $gk, join(",", sort keys %$ts);
            }
        }
    }
InCoil: | # In wild packer # slipping an II in, aggregator following alllist
   ar.v ||= {};
   ar.M ||= [];
   my ($oK,$rM) = @{delete ar.m||die"nbok"};
   inter({oK=>$oK});
   $N = [{MZ=>{$oK=>ar.v}}, @$N];
   Rw In + $N;
   $rM ? @{ar.M} : ar.v
ym/wongui: | # make M flat, acum .c.from, atoms wired together like so J.most.$
    my $D = {t=>z=>y=>4=>c=>{nk=>'sc',gk=>'z',mdrl=>1,as=>'list'}};
    
    # I. for decoupling hashrefs like vasing
    $C->{$_} = {%{$C->{$_}||{}}} for 'c','sc';
    my $wire = 'from';
    
    for my $zi (A.c->($D)) {
        my $from = [
            reverse $C, reverse map{@$_} A.c&$wire,'%as:list'
        ];
        my $c = {c=>{$wire=>$from}};
        my $s = {EC=>[$zi,$c]};
        push @{A.N}, $s;
    }
ym/wantcode: |
    # could T.not and grab M
    T.not = 1 unless C.sc.code;
    # to throw a 67 to ./.. would be pushing into II 
ym/concoi: |
    my $s = C.sc.code || return;
    
    C.y.p ||= join'/',map{_.t}@{C.c.from||[]};
    C.y.cvt ||= "C.y.cv\tC.t";
    
    T.y.spr=$C if A.t&43 && $s=~/^(\^|1)$/;
    
    if ($s=~/^\^$/ && A.t&61) {
        my $i = I.d&moy,'spr';
        # this is at spray
        C.c.s = join "\n",map{
            _.sc.got = 1 if $_ ne $C;
            "#@ _.y.p\n"."_.c.s\n"
        }@{i.N};
        C.sc.code =~ s/^\^ ?//;
        C.sc.code ||= "C.t 4";
    }
    
    if (A.t&43 && C.sc.acgt) {
        # for ACGT+args in acgt, args take whole @_
        C.sc.args ||= join',','A,C,G,T',grep{$_ ne '1'}C.sc.acgt;
        undef C.sc.code if C.sc.code eq '1';
        # the I that Cs all, it is indifferent to its current
        C.sc.code ||= "I 1";
    }
    
    $_ = C.sc.code;
    if (A.t&67) {
        if (C.sc.got) {
            return T.not=1;
        }
        my $s = C.sc.code;
        if ($s =~ /\w+ \w+/) {
            $s =~ /^(\w+) (\d+)$/ || die "wtf '$_'  ".ki$C;
            my ($K,$cv) = ($1,$2); 
            $cv = 0+("0.".$cv);
            

            if (my $args = C.sc.args) {
                die "wonky C.t   of ".ki $C if C.t =~ /\W/;
                my $gl = "";
                if ($args =~ s/^(A,C,G,T,)(?!s)//) {
                    $gl .= '    my ($A,$C,$G,$T)=splice @_,0,4;'."\n";
                }
                my($sf,$sa);
                if (C.sc.subpeel) { # runs, returns T.thing
                    $sf = "(";
                    $sa = ')->($A,$C,$G,$T)';
                }
                # here some want their own I space
                # if I resolv backward winding pro-be
                # G pulls in I
                C.c.s = "A\.I.".C.t." = "
                    .$sf
                    ."sub {\n"
                    .$gl
                    ."    my (".join(',',map{'$'.$_}split',',$args).") = \@_;\n"
                    ."    my \$I = A\.I;\n"
                    .join("\n",map{"    $_"}split "\n", C.c.s)."\n"
                    ."}"
                    .$sa
                    .";\n";
            }
            else {
                C.sc.subpeel&&die"nonargs ha subpeel".ki$C
            }

            C.sc.dige = slm 12, dig C.c.s;
            C.sc.gro = join'/',map{_.t}grep{_.y.cv != 0.9}
                @{C.c.from} if C.c.from;

            $v->{$K}->{$cv}->{C.t} = $C;
        }
    }
    
    if (my $y = T.y) {
        for my $k (keys %$y) {
            A.mo.y->{$k}->{C.y.p}->{C.y.cvt} = $C;
        }
    }


ym/talky: | # make M flat, acum .c.from, atoms wired together like so J.most.$
    my $nC = {%$C};
    my $t = ar.t ||"";
    my $n = ar.n ||"";
    my $yc;
    if (C.y.cv) {
        #  && keys %{C.y} == 1
        $yc = "  C.y.cv";
        delete nC.y;
    }
    $yc = delete(nC.t).$yc;
    $n = "in:C.sc.gro";
    
    my $s = "! $n    $t $yc  \t\t". ki $nC;
    $s =~ s/\n/â†¯/g;
    say $s;
Elvus: | # arbitrary in-J Elvi with thrust over, possibly   - c for J must be already seT
    my $Y = Rw El;
    my $oJ = ar.oJ || $J;
    Rw Elvis + $J:oJ $Y;
    $Y
El: |
    my $name = ar.name || shift @{delete ar.m};
    my $Y = J.El->{$name} ||= {bb=>{},name=>$name};
Elj: |
    my $name = ar.name || shift @{delete ar.m};
    if (my $Y = J.El->{$name}) {
        return $Y;
    }
    J.El->{$name} = Rw Jto - $le:J $name;
J6: | # do J=>m not W=>m, looser
   ar.J = ar.name || shift @{delete ar.m};
   Rw J5 +; 
J5: |
   return sayre "RECUR" if @F > 150;
   my $r = {%$ar};
   r.W = ar.name || shift @{delete ar.m} if ar.m;
   delete r.R;
   my $J = G.oin;
   my $i = Jn('','',$r);
   my ($s) = @{i.is};
   return s.sc.J||die "no sc J";
Jto: |
    my $J;
    J.id = mkuid;
    J.name = ar.name || shift @{delete ar.m};
    J.bb = {};

    J.le = ar.le if ar.le;
    J.most.J = $J;
    J.most.mody = 'mani';
    J.most.eo = 'Yesui';
    J.most.wq = 1;
    
    # GONERS
    Rw suJ $J;
    Rw Jup $J;
    # 
    
    n J.name, 0.9, J.name, {tag=>J.name,id=>J.id}
    
    Rw Viu $J;
    
    return $J;
Nbz: | # receiver of buzzed out planes of N (C)   # peeler futuro, forte arbiter # suJ cloned  # other is A.jr
    J.tt = 1;
    J.bz = sub { # the cv=>t=>style r
       my $m = [@_];
       die "not 2 @$m" if @$m != 2;
       my $j={};
       while (@$m) {
           my ($r, $v) = (shift @$m, shift @$m);
           if ($r =~ /^%(\S+)/) {
               j.style = $1;
           }
           else {
               # to ivertake in here
               $j = Rw r2j $r $J;
           }
           defined j.cv || die "NOSEYV: j.cv".wdump[$j,[@_],[$r, $v]];
           
           j.r = join "\t", j.cv, j.t, j.style;
           j.s = $v;
           my @Js = $J;
           push @Js, values %{J.phy} if J.phy;
           for my $jj (@Js) {
               jj.bb->{j.r} = j.s;
               push @{jj.ord}, {%$j} if jj.ord;
               jj.tim->{j.r} = hitime() if jj.tim;
               jj.wtf->{j.r} = $F[0] if jj.wtf;
               jj.ap->($j) if jj.ap; # <<<
           }
      }
    };
    $J

