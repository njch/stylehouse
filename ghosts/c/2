

pi/head: |
    Jn(t=>0.01,C.t,'%fs:6,hs:389');
    Jn(pi=>0.02,C.sc.pi,'%fs:7');
pi/vs: |
    C.sc.nspc = 0.1;
    y.lumfa = 2;
    y.limn = 1.8;
    
    Rw pi/head;
    #$s = [map{ my ($c,$i) = unico($_,1); i.t = $c; $i } map{232+$_} 1..20];
    
    my $i = 0;
    Mn($i++=>'',{pi=>'lv',s=>$_}) for @$s;
pi/lv: |
    C.sc.nspc = 0.12;
    C.sc.nspc_max = 8;
    y.limn = 3;
    C.sc.pwth = 'somewhere';
    
    Rw pi/head;
    
    Jn(lv=>0.1=>{s=>'{'},'%fs:34,hs:3892,ml:-0.9em,mt:-2em');
    #$u = {wtf=>[map{unico($_)}4300..4305]};
    #u.c.etc = {mil =>pond=>exp=>[qw'exp re']};
    
    Rw pi/kord lv;
    
    #Jn(it=>0.2=>{pi=>'text',s=>wdump(2,$s),cv=>0.8},'%opa:0.3');
pi/guess: |
     my $cg = $G->cgp($s);
     # ^
     # v
     my ($path) = grep { $cg->{$_} } qw'canpi ARRAY HASH ref undef text';
     $path = ref $s if $path eq 'canpi';
     $path = 'code' if ref $s eq 'CODE';
     $path ||= 'wtf';
     #$path = 'J' if $wa eq 'HASH' && u.bb;
     # can stick $wa on J.wa for thrashing maths
     # funcy fuzz fields
     # mutating spiral code
     
     Rw pi/$path;
     
dg/kord:
   lv:
    - ws: dead+4 t+5 name+3 block y c sc
   hash:
    - ws: dead+4 t+3 y+2 K+2 name+3 r+3 style+1 bb+2
pi/kord: |
    C.c.k ||= ar.m ? ar.m->[0] : C.c.pi;
    my $map;# = Rw muck $pin=dg/kord/C.c.k;
    $map = G.way.dg.kord.>C.c.k;
    $map || die "no C.c.k  ".wdump 2,$C;
    $map = {found=>$map};
    my ($N) = values %$map;
    my ($in) = @$N;
    
    my @in = in.ws ? split ' ', in.ws : die "how $in";
    
    my $yin = {};
    my @ord;
    for (@in) {
        my ($t,$i) = split /\+/, $_;
        my $y = {};
        y.in.sc.>$1 = $2 while $i=~s/(\w+):(\S+)//g;
        # same^v
        y.thy = $i if $i =~ /\d+/;
        $yin->{$t} = $y;
        push @ord, $t;
    }
    
    my $r = {map{$_=>1} sort keys %$s};
    my @r = grep { delete($r->{$_}),1 if exists $r->{$_} } @ord;
    push @r, sort keys %$r;
    
    for (@r) {
        my $y = $yin->{$_}||{};
        Mn($_ => $y, {pi=>'kv',s=>[$_=>$s->{$_}]}, {mw=>'5em'});
    }
pi/liv: |
    my $s = "find $u -type f";
    Jn(for => 0.1 => $s, '%hs:2784,fs:5');
    my @m = map{chomp;$_} `$s`;
    Jn(fo => 0.2 => 'fo'.@m, '%fs:6,hs:938');
    #y.lim = 9;
    my $lim = 19;
    @m = @m[0..$lim-1] if @m > $lim;  
    Mn($_ => '', {pi=>'lif',s=>$_}) for @m;
    
    Atime(4)||return;
    
    Rwyl 0.2 delifeH $J;
pi/lif: |
      -e $u || return 
      Jn('not',0.1,'!!!!'.$u,'%hs:9385');
      
      Jn(lifen => 0.09 => 'l', '%hs:3884,fs:11');
      my $si = -s $u;
      #Jn(si => 0.1 => $si, '%hs:9584,fs:7');
      
      J.most.filey = $u;  
      
      if ($si > 8000) {
          Jn(more => 0.3, '@', '%mu:r');
      }
      else {
          my @m = read_file $u;
          Mn(C.t=>'',{pi=>'liel',s=>$_}) for @m;
      }
pi/liel: |
    $u =~ /^[\{\[]/ || return
    Jn(funny=>0.1,"$u");
    #Jn(line=>0.1,{pi=>'text',s=>$u}, '%hs:3884,fs:6');
    
    Mn(C.t=>{},{pi=>'life',s=>djson $u});
pi/life: |
    Jn('ins',0.1,{s=>'{'});
    Jn(life => 0.2 => C.s);
    my $i = {qw'hol hol pid pid now now begin now'};
    my $s = 'text';
    my $br = 1; 
    Rw kapai + $i $u $s;
    my $mf = J.most.filey;
    if (u.now && $mf && hitime() - u.now > 60*1.2) {
        C.sc.deco = 1;
        Jn(rm => 0.6 => "RM", '%hs:378');
        sayre "RM $mf";
        `rm $mf`;
    }
    
kapai: |
    my $f = [];
    my $l = [];
    for my $k (sort keys %$u) {
        my $v = $u->{$k};
        my $pi = $i->{$k};
        my $h = $pi ? $f : $l;
        $pi ||= 'text';
        push @$h, [C.t,'',{pi=>'kv',s=>[$k,$v],and=>{pi=>$pi}}];
    }
    push @$f, @$l;
    Mn(@$_) for @$f;
pi/now: |
    die if $u < 100 && $u > -100;
    my $d = hitime() - $u;
    my $dl = $d > 3*60 ? [8,873] : $d > 60 ? [6,853] : [5,634];
    my $l = Rw samv $d;
    Jn(delta=>0.1=>$l,"%fs:$dl->[0],hs:$dl->[1]");
pi/hol: |
    my ($s,$n,$i,$etc) = split '/', $u;
    die "$u is long" if $etc;
    #die "wells $u => $s"; 
    Jn(_style => 0.1 => $s, '%is:style');
    Jn(name => 0.2 => $n, '%is:name,fs:12');
    Jn(id => 0.3 => $i, '%is:id,fs:6');
    
pi/pid: |
    Jn(pid => 0.1 => $u, '%hs:483,fs:5');
    
    
pi/kv: |
    return if @F >200 || 7<
    Rw pidepth;
    
    C.sc.nspc = 0.02;
    C.sc.nspc_max = 4;
    
    my ($k,$v) = @$u;
    my $pi = C.c.and && C.c.and.pi || '';
    
    my $eel = $pi||1 ? '' : 'rad:-1.3';
    $eel .= ",fs:6,hs:3563";
    $eel = '%'.$eel if $eel;
    Jn('la',0.2,$k,$eel); # if hori
    Mn('v',0.3,{pi=>$pi,s=>$v});
pidepth: |
    my $o = $J;
    my $i = 0;
    while (o.Jiter) {
        $i++; $o = o.Jiter;
    }
    $i;
pi/keys: |
    Mn("ke__$_" => {}, {pi=>'text',s=>"$_,"}) for sort keys %$u;
pi/text: |
     J.cv < 0.4 ?
         Rw pi/foldytext
     :
     J.cv < 0.7 ?
         Rw pi/boxtext
     :
     Rw pi/fulltext
    
pi/foldytext: |
         $s =~ s/\n/↯/g;
         
         my $tev = int(J.cv * 200); # 0.4 = 100
         if (C.c.si > $tev) {
             $s = ($s=~/^(.{$tev})/s)[0];
         }
         else {
             delete C.c.si;
         }
            
         if ($s =~ /^\d{10,11}(\.\d*)?$/) {
             Jn(timestamp => 0.1 => {pi=>'now',s=>$s})
             && return;
         }
         
         J.bz->('line 0.1' => $s,
                '%css' => "background:rgba(200,30,80,0.3);color:#3f3;"
                    ."font-size:70%");
pi/boxtext: |
     C.c.si = length($s);
     
     Rw pi/foldytext;
     
     my $ni = J.c.lin if J.c.lin > 1;
     my $bi = J.c.b if J.c.b > 1;
            
            J.bz->("si/l 0.2" => "C.c.si",
            '%css' => "color:#b89;font-size:50%;position:absolute") if exists C.c.si;
            
            J.bz->('si/n 0.2' => "$ni",
            '%css' =>
            "color:#fff;font-size:50%;"
            ."position:absolute;margin-top:1.4em;") if $ni;
            
                J.bz->('si/b 0.2' => "b$bi",
                    '%css' =>
                        "color:#f89;font-size:50%;"
                        ."float:left;left:-1em") if $bi;
                   
            if (J.cv < 0.7 && $s =~ /^(# \d.+?)↯/) {
                J.bz->('line 0.1' => $1,
                '%css' => "background:rgba(200,30,80,0.3);color:#3f3;"
                    ."font-size:70%");
            }
pi/fulltext: |
     Jn(hi=>0.3=>"HI  J.cv");
     
            # 7
            my @tex = split /\n/, $s;
            #my $s = $G->vimcolor($u);
            #$s =~ s/^(<span) (class="synComment">.+?)(<\/span>)/$1 style="font-size:170%;" $2$com$3/;
            
            #$tex[0] .= " #J.cv";
            
            my $surge = int(100 * (J.cv - 0.7));
            # add interesting o to tex 0.7ishs as surge goes
            (my $one, my @o) = @tex if J.cv < 0.8;
            @tex = $one if @o;
            my $urge = $surge / 2;
            $urge = 0; # TODO colours and
            for (@o) {
                last if @tex >= $urge;
                push @tex, $_ if /^#/
                    || /R\./
                    || /\-\>/
                    || /w\ /;
            }
            
            
            my $lim = ";height:19em;overflow-y:scroll" if @tex > 19;
            $lim .= ";background:rgba(70,40,0,0.3);" if J.cv >= 0.8;
            
            my $fs = int(50 + $surge * 7);
            $fs = "font-size:$fs%;";
            
            my $s = join"\n", @tex;
            J.bz->("line 0.1" => $s, '%tag'=>'pre','%gp'=>{vimcolor=>1},
                '%css' => "margin:0.2em;background:rgba(30,30,60,1);$fs-webkit-filter:hue-rotate(80deg);$lim");
pi/HASH: |
    my $si = keys %$u;
    y.limn = 2;
    C.sc.nspc = 0.01;
    #y.lumfa = 2;
    Jn(si=>0.1, $si, '{hs:8378,fs:4}');
    #Jn(spc=>0.09, J.d.y.spc, '{hs:9373,fs:7}');
    
    Jn(Bo => 0.11, {s=>'{'},'%fs:7');
            
             return
             Jn('ends',0.2,'@','{hs:6984,ml:-0.3em}')
             if J.d.y.spc < 0.05;
             
            Jn(oB => 0.89, {s=>'}'},'%fs:7');
            
            # 3
            Rw pi/kord hash;
pi/ARRAY: |
    y.limn = 1.7;
    my $cv = J.cv ||= 0.3;
    my $si = @$u;
    
    Jn(si => 0.1 => $si, '{hs:8378,fs:4}');
    #Jn(spc=>0.09, J.d.y.spc, '{hs:9373,fs:7}');
    J.bz->('Bo 0.11' => '[');
    J.bz->('oB 0.89' => ']');
            
             return
             Jn('ends',0.2,'@','{hs:6984}')
             if J.d.y.spc < 0.07;
            
            return if $cv < 0.2;
            
            my $i = 0;
            while (exists $u->[$i]) {
                my $uu = $u->[$i];
                
                
                Mn('['.$i => {}, {pi=>'kv',s=>['['.$i,$uu]});
                $i++;
            }
pi/code: |
    Jn(code=>1=>'&','%hs:389');
pi/eye: |
     my $file = $u;
     #J.V = 1;
     #J.d.c.path = 'amp';
     Jn('ey',0.09,"ey",'{hs:636}');
     Jn('file',0.1,"$file",'{hs:277}');
     Jn($file,{o=>{}},{pi=>'ls',s=>$file});
     #J.V = 0;
pi/ls: |
     my $file = $u;
     J.d.c.pwth = 'somewhere';
     J.d.sc.tt = 'somewhere';
     J.d.sc.nspc = 0.03;
     y.lumfa = 1;
     
     Jn('fiule',0.1,{s=>C.t,pwth=>'somewhere'},'{hs:4889,sz:8/1.6,sha:2 2 2 000}');
         
     return
     Jn('ends',0.2,'@'.J.d.y.spc,'{hs:6984,ml:-0.3em}')
     if J.d.y.spc < 0.005;
     
     if (-l $file) {
         Jn('-s',0.12,'-s','{co:fca}');
         my $to = readlink $file;
         my $oo = $file;
         $oo =~ s/(^|\/)[^\/]+$//;
         undef $oo if $oo eq '' || $to =~ /^\//;
         $oo = (defined$oo?"$oo/":"").$to;
         
         Jn('sb',0.1231,"$to",'{co:f6a,sz:8/1.6}');
         
         $oo || die "$file => $oo";
         $file = $oo;
     }
     
     # cm smartIndent 
     if (!-e $file) {
         Jn("not",0.2,"!$file:$!",'{co:fca}');
     }  
     elsif (-f $file) {
         Jn('-f',0.2,'-f','%fs:7,hs:392');
         
         Mn(C.t,'',{pi=>'fi',s=>$file});
     }
     elsif (-d $file) {
         Jn('diry',0.2,'/','{hs:3555}');
         opendir(my $dh, $file) || die "can't opendir $file: $!";
         my @ma = readdir($dh);
         closedir $dh;
         
         @ma = grep {!/^\..+\.swp$/} @ma;
         @ma = sort grep {$_ ne '.' && $_ ne '..' && -e "$file/$_"} @ma;
         
         my (@fa,@la);
         map { -d "$u/$_" ? push @fa, $_ : push @la, $_ } @ma;
         @ma = (@fa,@la); 
         
         y.limn = 7;
         
         Mn($_,{},{pi=>'ls',s=>"$u/$_"}) for @ma;
     }
     
pi/fi: |
     $_ = $u;
     my $pi = /(tga|png|gif|jpe?g)$/i ? 'thumbnail' :
          /^w\/c|^g|notes\// ? 'file' :
          do { $u = C.t; 'text' };
     Mn($pi,{},{pi=>$pi,s=>$u});
     
pi/thumbnail: |
     my $size = -s $u;
     C.sc.nspc = 0.46;
     C.sc.nspc_max = 2;
     return "nontypeimage: $u" unless $u =~ /(tga|png|gif|jpe?g)$/i;
     my $mou = "public/";
     #return if $size > 3_000_000;
     my ($first) = split '/', $u;
     die "$first not $mou?" unless -e "$mou$first";
     
     my $thl = "th/$u";
     my $th = "$mou$thl";
     
     # TODO mod slowness
     # make this thumbnail J even more forky than usual
     # TODO wander 90deg radial over phatness...
     # tape twist effect coming from somewhere
     if (!-f $th && 1){#J.fop->()) {
         sayyl " thumbnail++$u";
         my $thd = $1 if $th =~ /^(.+)\/(.+)$/ || die $th;
         if (!-d $thd) {
             run 'mkdir', '-p', $thd;
         }
         if ($u =~ /(mov|avi|mp4)$/i) {
             run 'ffmpegthumbnailer -s 420 -t 20% -i '.$u.' -o '.$th
         }
         else {
             run 'convert', $u, '-thumbnail','500x500', $th
         }
     }
     #sayyl "Pi thumbnAIL of J.most.J.name";
     #J.V = 1;
     if (-f $th) {
         my $sc = {
             tag => 'img',
             src => $thl,
             height=>(24*C.y.spc).'em',
             ab=>1,
             ml=>'-3em',
             tt=>" J.d.y.spc   of C.y.cv - C.y.ov",
             zig=>2,
         };
         Jn(yowl=>0.3=>'',$sc);
     }
pi/file: |
     my $file = $u;
     defined $file || die 'nofile';
     die if C.sc.dir;
     C.sc.sz = 20;
     sayyl "oufile: $file";
     
     Jn("filename",0.1,$file,'{fs:20,hs:5563}');
     my $met = `file '$file'`;
     die $met unless $met =~ /text/;
     
     
     my $o = Rw fil/o $file;
     
     Jn('nmyd',{o=>$o});
     sayre J.r."   ".ki J.d.y;

