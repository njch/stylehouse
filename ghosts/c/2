
oJ2: |
     #sayyl "oJJJ oJJJ ".wdump $C;
     if (exists C.c.J eq A.J) {
         sayre "J above A.J.name";
         delete C.c.J;
     }
     if (exists C.c.J) {
         C.c.W = C.c.J;
         A.ztime = 3;
         # amount of time each thing spends being the top level
         # which was... n... mani
     }
     
     my $nn = A.note.not;
     
     C.c.s ||= 'Swim';
     nn&c,'s';
     C.c.W && # nets
     nn&c,'W';
     my $wasW;
     if (exists C.c.y) {
         nn&c,'y';
         Rw oy2 + $v:C.c.y;
     }
     elsif (exists C.c.pi) {
         nn&c,'pi';
         Rw opi2 + $v:C.c.pi;
     }
     elsif (exists C.c.W) {
         $wasW = 1;
         nn&c,'W';
         Rw oW2 + $v:C.c.W;
     }
     else {
         #die "misrep ".wdump 2, $C;
     }
     if (C.c.W && !$wasW) {
         if (!ref C.c.W) {
             my $Wjr = Rw Ajr $J:G.oin $t:C.c.W $cv=0.3;
             my $WJ = Wjr&J;
             sayyl "HJvae A.J.name holding C.t with WJ.name";
             C.c.W = $WJ;
         }
         else {
             die "knew W? ".ki C.c.W;
         }
     }
oy2: |
    A.note.not&c,'y';
    A.jr = Rw Ajr $J $C;
    
opi2: | # approach - c language is map to some u before 6ing
    my $v = C.c.pi;
    at.pi = $v || 'guess';
    C.c.J = 'pie';
    
    my $oJ = $J;
    $oJ = C.y.o.J if C.y.o && C.y.o.J;
    A.jr = Rw Ajr $J:oJ $C;
    
oW2: | # some get-J or weave wires protocol - hosts
    my $t = $v;
    $t = v.name if ref $t;
    at.J = ref $v ? $v : $t;
    at.W = $t;
    C.c.J ||= $v;
    
    die wdump ["onto W J.name:",$v] if ref $v && $v ne v.most.J;
    
    C.t = $t;
    # has already been 0.1 in Y
    C.y.cv ||= 0.3;
    
    A.jr = Rw Ajr $J:G.oin $t $cv=0.3;
    
    # and where the
    if (C.c.vv) {
        A.ztime = delete C.c.vv;
        A.jr&vv,9
        ->(); #delone
    }
Ajr: | # aimed at J and a K/line: C or t/cv    sends style => $v
      sub {
          my $s = shift;
          my $v = shift;
          my $d = shift;
          $s = '%'.$s if $s;  
          my $t = exists ar.t ? ar.t : ar.C.t;
          my $cv = exists ar.cv ? ar.cv : ar.C.y.cv;
          my $r = $t.$s."\t".$cv;
          if ($d) {
              sayre "delbbl $r  $d   J.name" for 1..5;
              Rw delbbl $J $l:t;
          }
          if (J.V) {
              if ( defined $v) {
                  saybl "J.name chuck $r     $v  <--  ".J.bb->{$r};
              }
              else {
                  saygr "J.name read $r";
              }
          }
          !defined $v ?
            J.bb->{$r}
          : do {
              J.bz->($r, $v);
              sub { delete J.bb->{$r} } 
          };
      };
pidepth: |
    my $o = $J;
    my $i = 0;
    while (o.Jiter) {
        $i++; $o = o.Jiter;
    }
    $i;

