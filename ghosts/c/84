
Sl: |
    #n JSlines =>W=>{s=>$J}
    
    #u alljs
    y.at.jslines = 1;
    y.at.oWl = 1;
    n reJSlines
    
    n bawls =>3=><<'','%js'
        var v = $('#msgs');
        a.m("SOmething clea r "+v);
    
    #
    #n Details
    #n Usee
    my $see = "life/S\.s";
    Mn(foland=>pi=>$see,'%dos:loadwav,qz');
    
    Mn(foland=>pi=>"life/W/ire",'%dos:zonein,qz');
    #J.mo.s.al.opt.folch = [Followe=>W=>"life/S\.s"];
    J.VV.N = 1;
    J.VV.sixes = 1;
    J.VV.sevens = 1;
    
    my ($l) = $1 if `wc -l $see` =~/(\d+)/;
    `cat /dev/null > $see` if $l > 4 && J.ever == 0 || J.ejiqd++> 3 && do{ J.ejiqd = 0; 1};
    `echo 'hello' >> $see`;
    J.ever = 1;
    
    
    my $n = J.fsjoi++;
    $n && 1;
    $n || Rw loopby $b=5 $d=16 $p=Top;
goneplay: |
    u allovse
    n '','','%of:Sev'

    # without being a match prepare the Vacuumosd iv/ov
    n Vsup =>434=><<'',{Td=>'V/*/*'}
        d.iv = lv.do->{$gk};
        d.ov = vl.do->{$gk};
        #saybl "Seen: $gk    d.iv   d.ov";
        d.ov && d.ov.i && (d.ov.i eq $o || warn "no ovi ogk  d.ov.i eq $o");
        T.noTd = 1;
    
    n Vgone =>4342=><<'',{Td=>'V/*/gone',Tdarge=>'iv,ov'}
        if (!ov.rmnsc) {
            die "no rm: A.J.name =>  C.t: C.y.k   \n".ki(C.sc)
                .wdump 3, [$at,$ta,"Cfor $gk pmtp", $vl,'','',$lv,"ESS:". $s];
        }
        !$iv || die "gone had iv";
        # ^ sc plumb its destruction
        # can void if our c reframes by implicitly clearing
        lv.od.go->{$gk} = $ov;
    
    
pi/foland: |
    n sol=>pi=>$s;
    for (A.e&C) {
        my $t = J.El.Pre.tv->{"0.1\tdos\t"};
        sayyl "PI FOLAND! ".wdump [$_,$t];
    }
pi/sol: | # file anywhere, together
    # everything this s can get a copy of the ,,,
    y.at.oWl = 1;
    n Film=>$C
    
Film: |
    J.ev.th ||= 'middle';
    y.ope = 1;
    J.VV.N = 1;
    for (A.us&C) {
        sayyl "FILM IN RIGHT PLACE: " for 1..4;
        return; # 
    }
    map {
        saybl "_.t _.sc.J.id Tango _.c.s           _.sc.pi";
        n _.c.s=>6=>{pi=>panop=>s=>$_,},'%qs'
    } A.e&C
pi/pane: |
    #u perCcsomethingtracepha
    n $_ for map{values %$_}values %$s
    
pi/panop: |
    Rw pi/anoply;
    n Follower=>$C,{},'%qs'
    
pi/anoply: |
    y.ope =  1;
    y.at.oWl = 1;
    $s || return;
    my ($t,$l) = Rw idToE;
    n $t =>{}=>{}=>{opel=>sjson($l)}
    

pi/annopl: |
    y.ope = 1;
    my ($t,$l) = Rw idToE;
    n $t =>{}=>{}=>{opel=>sjson($l)}
loadwav: |
    sayyl " F  IND SOME FOR E.c.s";
    my $mayb
    # be!  plus
    # 
    
SpaceFlos: |
    E.sc.J && E.sc.J.mo.J eq $J && return sayre "E.t iutno self E.sc.J.name";
    my $M = J.oy.o;
    Mn($_) for @{J.eM||[]};
    
    J.eM = $M;
    for (A.e&C) {
        # y.unit
        return saybl "Com\nCom" if J.El.Pre.tv->{"0.6\t$K\t"};
        
        n $K=>3=>{pi=>cfile=>s=>$K}
        
        sayyl "GOT SPACE ELVIS: C.t: "
            .(_.sc.J && "_.sc.J.mo.J.name  _.sc.J.name")
            ."  _.t   _.y.cv    linking $K";
        
        saybl "_.t _.sc.J.name Tango _.c.s ";
        n $K=>6=>{pi=>annopl=>s=>$_},"%qs"
    }
    saybl "SpaceFlos: done: ".F_delta();
Elis: |
    my $pi = E.sc.pi;
    sayyl " - _.t   _.y.cv  _.c.s :: ".ki _.c.e for @{E.c.z};
    if ($pi eq 'panop') {
        my $j = E.sc.J;
        # the key ^
        Rw SpaceFlos + $E $K:j.C.t;
    }
    elsif ($pi eq 'line') {
        sayyl "Elis: J.name provcesses: $pi: E.t E.c.s";
        Rw cJTrunk $J $C $E;
        Rw yJLong $J $C $E;
        return;
        #
        #
    }
    else {
        sayyl "EV J.name like E.t  ".wdump 2,[ E.c, E.sc ];
        $_ && return saybl "Foolowey was: $_ ".E.c.s for A.e&was;
        #
    }
    
middle: |
    my $E = Rw CsE $C;
    sayyl "midd: C.t has reactoin to: E.sc.pi: E.t: ".ki E.c.s;
    saybl "midd: Has us ticket: ".wdump 2, $_ for A.us&C;
    
    # ids are brain tickets
    if (!E.c.us || do{E.c.us.ids->[E.c.us.idi - 1] eq J.id
        && sayre("midd:le aft us landed on self: J.name")}) {
        return Rw Elis + $E;
    }
    else {
        sayre "Some other middle to J.name!" for 1..4;
        saybl "Got: J.id:".wdump 3, [E.c.us,$E];
        Rw zyeuter $A $C $J $E;
    }
Follower: | # follws E.t as file, sends lines to E.t, has panopoly of Film like things to unify changesity into therermore panoply actioney changesity

    # (everything threes)
    u linesfollow
    u Ipifalls
    y.ope = 1;
    y.cvil = 1;
    y.at.oWl = 1;
    
    
    J.mo.s.al.opt.foler = [Follower=>'W'=>{}];
    J.VV.N = 1;
    J.ev.th ||= 'middle';
    #
    n $C
yJLong: |
    my $om;
    if (E.c.us) {
        $om = J.C;
    }
    my ($mo,$ne) = @{E.c.yJ};
    mo.mo.J eq $mo || die "momo no mo: ";
    $om ||= $mo; # 
    $mo = $om;
    my $dub = ne.C.y.cv * 2;
    my $cC = mo.El.Pre.tv->{$dub."\t".ne.C.t};
    $cC || return sayyl "FIND MORE: ".wdump 3,[ne.C.t, mo.C, $dub, mo.El.Pre.tv];
    sayre "Du ne.C.t $dub  isin: ".ki $cC;
    sayyl "Was: ".ki delete E.c.us;
    $cC || die "no dubber";
    my $cJ = cC.sc.J;
    my @routes = grep {_.sc.opel} @{cJ.El.Pre.vs};
    
    for my $r (@routes) {
        say wdump 3, [map{ki ref $_ && _.sc || $_}C.c.s,$C,$E,E.c.s];
        E.c.us = {ids=>[split ',',r.t],hopel=>r.sc.opel};
        # givesd to router
        n $C
    }
yJBlab: |
    say "Vertical E:Js";
    say " - _.t   _.y.cv  ".ki(_.c.s)." :: ".ki(_.c.e)
       ."    ****** ".ki(_.sc)for map{_.C}@{C.c.yJ};
cJTrunk: |
    my $E = ar.E || ar.C;
    E.c.yJ = Rw yJTrunk $C:E;
    Rw yJBlab $C:E;
yJTrunk: | # from C.sc.J, uup
    my $jay = C.sc.J;
    my @js;
    while ($jay) {
        push @js, $jay;
        $jay = jay.Jiter || last;
    }
    [ reverse @js ];
idTrunk: |
    my $E = ar.E || ar.C;
    E.c.yJ = Rw yJTrunk $C:E;
    [ map { {id=>_.id,t=>_.C.t,cv=>_.C.y.cv} } @{E.c.yJ} ]
idToE: |
    my $ids = Rw idTrunk $C:s;
    my $mo = $ids->[0];
    my $la = $ids->[-1];
    my $l = [map{[_.t=>_.cv=>_.id]}@$ids];
    my $t = join ',',map{_.id}$mo,$la;
    return ($t,$l)
    
Usee: |
    u ReoCur
    y.at.ux = 1;
    J.VV.N = 1;
    
    my $i = int rand 19;
    sayre("CHANGING THIS\n\n\n\n") && `echo $i >> ded/$i` if int(rand 19) > 14;
    my @l = `find ded`;
    #my @l = `find life/W -type l`;
    #my @r = `find life/W -mtime 0.6`;
    #my @el = `find life/W`;
    chomp for @l;
    while (@l > 7) {
        `rm $_` for shift @l;
    }
    y.in=1;
    y.out=5;
    Mn(some=>''=>{pi=>textl=>s=>$_})
        for split"\n",wdump 2, \@l;
pi/textl: |
    my $l = sum map{ord $_} split '', $s;
    $l /= 10 until $l < 10;
    my $h = int $l;
    n text=>1=>$s,{hs=>"${h}86"}
EYZ: |
    u ReoCur
    u curv =>pi=><<''
        zoom 0  0.6
        y    0  0
        x    0  0
        curve 0 0.04
    
    Mn(shedful => '', {pi=>'eye',s=>'eye/Tarf'});
    n TeCurve =>$J
Details: |
    u ReoCur
    y.at.ux = 1;
    
    J.VV.N = 1;
    J.fkeo ||= 7;
    A.us&C && A.us&S ? J.fkeo++ : J.fkeo--;
    
    J.sdjfsiji ||= 4;
    my $n = J.sdjfsiji++;
    n b320 => '3-5x'.$n, join'',(J.fkeo) x 3;
Sight: |
    n stylehut
    n styleomi
    n stylation
    n stylers
    J.inV = 1;
    n lim=>pi=>'g/c/84'
    # could ahh...
    n JSlines =>$J
    
pi/lim: |
    n file=>pi=>{mtime=>1=>s=>$s}
    y.at.distorb = 'J/mo/J';
alljs: |
    n 'allarejs=s'=>2,{s=><<''},{code=>'In 42'}
        C.sc.acgt = 's' if !exists C.sc.acgt;
        C.sc.js = 1;
alljse: |
    n alljs
    n 'allarejse=s'=>2,{s=><<''},{code=>'In 419'}
        return T.not = 1 for
            map { A.J.A.vse->{$_} = C.c->{$_} }
            grep {exists C.c->{$_}} qw'of nk';
        my $av = A.J.A.vse;
        C.sc.of ||= av.of||'om';
        C.sc.nk ||= av.nk||'sc';
        C.sc.gk ||= C.t;
        my $cv = C.y.cv || 1;
        $cv =~ s/^0\.//;
        C.t = C.sc.of."_".C.t."_".$cv;
ym/jscoi: |
    my $s = C.sc.js || return;
    if (C.sc.acgt) {
        C.sc.args ||= join',','A,C,G,T',grep{$_ ne '1'}C.sc.acgt;
    } 
    C.sc.args || die "no args of";
    die "wonky C.t   of ".ki $C if C.t =~ /\W/;
    C.sc.args =~ s/ /,/g;
    my $poing = qr/\w+(?:\.\w+)?/;
    C.c.s =~ s/^t\&([^\s;]+)(;)?/!G\&t,$1 and return;/gm;
    C.c.s =~ s/($poing)\&(\$)?(\w+)(,[^\s;]+)?(;)?/
        my $t = $2 ? "$3" : "'$3'";
        my $h = $1 eq 'G' ? ".h(A,C,G,T,$t" : "\[$t\](A,C,G,T";
        $1.$h."$4)$5"
    /smge;
    C.c.s =~ s/^(.+) \|\|\= (.+)(;)?$/if (!$1) {
        $1 = $2
    }/gm;
    C.c.s =~ s/^(.+?) and (.+)(;)?$/if ($1) {
        $2
    }/gm for 1..3;
    C.c.s = "a.".C.t." = function(".C.sc.args.") {\n".C.c.s."};\n";
    C.sc.dige = slm 12, dig C.c.s;
    delete C.c.from; # as 7, S over
    $v->{js}->{C.y.cv}->{C.t} = $C;
ym/spots: |
    v.i ||= 0;
    v.X->{C.sc.of}->{C.y.cv}->{C.t} = $C if C.sc.of; # vetc
    v.Z->{v.i} = $C;
    push @{v.z||=[]}, $v->{l}->{v.i++} = C.c.s;
    
stylehut: |
    u alljs
    
    n e =>''=><<'',{args=>'e'}
        if (!q)
            console.log("xut "+e);
        var m;
        try { m = eval(e); }
        catch (er) { a.er(e, er); }
        m
    
    n er =>''=><<'',{args=>'e,er'}
        console.log("xutbang: ", e, er);
        var ej = {er: {e: e}};
        if (er && er.message)
            ej.er.m = er.message;
        s.reply(ej);
        a.m("!"+ (ej.er.m || e));
    
    n m =>''=><<'','%args:e'
        var d = e.substr(0,1);
        if (d == " ") {
          a.e(e);
        }
        else if (d == "[" || d == "{") {
          var N = $.parseJSON(e);
          console.log("gooftoes ", N);
          a.om({},N,a,{});
        }
        else {
          if (d == ".")
            e = '<span style="font-size:66%">'+e+'</span>';
          a.c(e);
        }

    n c =>''=><<'','%args:e'
        $('#msgs').prepend(e+"\n");
    
    n yl =>''=><<'',{args=>'delay,func'}
        setTimeout(func, delay);

    n ks =>''=><<'','%args:s'
        var ks = [];
        for (var k in s) {
            ks.push(k);
        }
        return ks.join(',');
    
styleomi: |
    u alljs
    
    n sca =>''=><<''
        while (s > 1) {
            s = s / 10;
        }
        return s;
    
    n f =>''=><<''
        var t = '';
        s and t=s
        var at = '';
        C.y.cv and at += "cv='"+C.y.cv+"'";
        t || at || console.log("No attach: "+T.alk);
        return $(A.on).find(t+'['+at+']');
    
    n inC =>''=><<''
        C = s;
        C.constructor == Array and C = {t:C[0],y:C[1],c:C[2],sc:C[3]};
        else
        C.constructor == Object and $.each(C,function(k,v) { G&$k,v }); T.not = 1;
        else
        typeof C === 'string' and C = {c: {s: C}};
        typeof C.c === 'string' and C.c = {s: C.c};
        typeof C.y === 'string' and C.y = {cv: G&sca,C.y };
        !typeof C.t === 'string' and console.log('queda',C);
        C.c ||= {};
        C.sc ||= {};
        return C;

    n h =>''=><<'',{acgt=>'way,s'}
        if (!G[way])
            throw "No way: "+way
        return G[way](A,C,G,T,s);
    
    # A falls, A.on taps each-for thing, A.W holst selves, usu not
    n An =>''=><<''
        var A = $.extend({},A);
        A.I = {};
        A.mo ||= A;
        T.d ||= 1;
        s and var k = 'e_'+s; A.e = G[k];
        return A
    
    n t =>''=><<''
        T.not and return 0;
        A.I.cv = G&sca,s;
        G&ex,A.I;
        return 1;
    
    n ex =>''=><<''
        s.ei ||= 0;
        while (1) {
            var v = A.e[s.ei];
            !v and return
            v[0] > s.cv and return
            s.ei++;
            $.each(v[1],function(i,D){
                var t = D[0];
                var sc = D[1];
                sc.nk and !C[sc.nk] and return
                sc.gk and !C[sc.nk][sc.gk] and return
                var es;
                sc.gk and es = C[sc.nk][sc.gk];
                G&$t,es;
            });
        }
    
    n Win =>''=><<''
        var W = ww[s];
        if (!W) {
            a.c("new W: "+s);
            W = ww[s] = {};
            W.Wid = s;
            W.A = {};
            W.A.W = W;
            //W.A.p = new paper.Project();
        }
        //W.A.p.activate();
        return W;
    
    n eine =>''=><<'',{acgt=>'s'}
        var K = s[0];
        var e = s[1];
        var k = 'e_'+K;
        G[k] = e;
    
    # persona perforthe webclient channels
    # so the G copies and lives from/to W
    # h reach up/down to applied layers of you
    # top level mirage is o(ww,Wid,$s) 
    # which ins ww (G.Wid for Oth), J.id (Wid)
    # and the difference is you
    n om =>''=><<''
        A = G&An,'om';
        C = G&inC,C;
        t&2;
        T.alk = 'w'+T.d+' '+C.t+' '+a.ks(C.c)+'%'+a.ks(C.sc);
        C.sc ||= {};
        C.sc.css ||= {};
        C.sc.anc ||= {};
        t&7;
stylation: |
    u alljse
    n '','','%nk:c'
    # $(A.on).fadeOut(delay, function() { $(this).remove(); });
    
    n W =>28=><<''
        A.on = $('#'+C.c.W);
        !$(A.on).length and a.c(T.alk+"  noW: "+C.c.W);
        .
        var W = G&Win,C.c.W;
        $.extend(A,W.A);
    
    n nobody =>31=><<''
        A.on = $('#'+C.c.nobody);
        !$(A.on).length and a.c("no nobody at "+C.c.nobody);
    
    # whole time... (make whote, A.t&4 ex inness..
    n el =>3=><<''
        C.sc.attr ||= {};
        var last;
        var t = C.t.replace(/\W/g,'e');
        t.length < 4 || 1 and t = 'n'+t+'n';
        var el = G&f,t;
        s == '1' || s == '9' and $(el).remove();
        s == '8' and return A.on.aft = el;
        !el and console.log("Cno find el="+el+": "+C.t+"  of "+C.y.cv);
        if (s == '1') {
            C.sc.attr.cv = C.y.cv;
            var div = $("<"+t+">", C.sc.attr);
            $(div).appendTo(A.on).each(function(i,v){el=v});
        }
        C.c.s and $(el).html(C.c.s);
        A.on = el;
   
    0 &&
    n alsonot =>'',<<''
        if (C.c.id) { 
            C.sc.attr.id = C.c.id;
            var aid = $(A.on).attr('id');
            if (aid && C.c.id) { 
                var to = '#'+aid+' #'+C.c.id;
                var ex = $(to);
                if (ex.length) {
                    a.m('rm '+ex.prop('tagName')+' '+to);
                    if (ex.prop('tagName') === 'undefined')
                       a.m('?');
                    $(ex).remove();
                }else{
                    console.log("blank rm untd "+C.t,A.C);
                }
            }
        }
stylers: |
    n stylext
    u alljse
    
    n geo =>5=><<''
        s = s.split(' ');
        var aung = s[0].match('^a(\\d+)');
        if (aung) {
            s.shift();
            aung.shift();
            C.sc.ab = aung.shift();
            //absolu
        }
        s = {x:s[0],y:s[1],rad:s[2],scale:s[3]};
        C.sc.css.top = (s.y * 100)+'%';
        C.sc.css.left = (s.x * 100)+'%';
        C.sc.css['transform-origin'] = '0% 0%';
        C.sc.css['transform'] = 'rotate('+s.rad+'rad)';
        if (s.scale)
            C.sc.css['transform'] += ' scale('+s.scale+')';
    
    n ab =>51=><<''
        if (s === '100') {
            C.sc.css.width = '100%';
            C.sc.css.height = '100%';
        }
        C.sc.css.position = 'absolute';
    
    n z =>6=><<''
        $.each(s, function(i,v) {
            //a.yl(1, function () { 
            G.om(A,v,G,{d:T.d+1});
            //});
        });
    
    n css =>59=><<''
        $.each(s, function(i,v) { $(A.on).css(i, v); });
    
    n anc =>59=><<''
        $(A.on).animate(C.sc.anc, (C.sc.ant||900));
    
stylext: |
    u alljse
    
    n cod =>59=><<''
        G&cod,s;
    
    u alljs
    n cod =>''=><<'','%args:s'
        var def = {mode:'perl',theme:'midnight',lineWrapping:true};
        var set = $.extend(def, s);
        var id = set['id'];
        delete set['id'];
        var cm = CodeMirror(document.getElementById(id), set);
        .
        cm.ididid = id;
        cm.setOption('extraKeys', {Esc:function(){a.codsav(cm)}});
        .
        cm.on('focus',function(){clof();keof();});
        cm.on('blur',function(){clon();keon();a.codsav(cm)});
        .
        $('#'+id).css('width','50%','max-height','70%','overflow','scroll');
        $('#'+id+' > .CodeMirror');//.css('height','auto');
    
    n codsav =>''=><<'','%args:s'
        var we = $('#'+s.ididid);
        a.m('AAAAAAAAAAA');
        var d = {};
        a.entag(d, we);
        d.code = cm.getValue();
        d.dig = we.attr('dig');
        a.ethro(d, ws);
        console.log(d);
reJSlines: | # could spiral intuit re$W to just this - A coney islands
    y.at.ressur = 'JSlines';
JSlines: |
    y.at.jslines = 1;
    y.ope = 1;
    n $C
EmJSlines: |
    my $N = [@{em.lines||die"Nop"}];
    @$N = Rw humms $J $N wongui _;
    @$N = sort { a.t cmp b.t }
    Rw humms $J $N notnotjs _;
    
    my $S = Rw humms $J $N spots;
    my $l = em.lines = [];
    push @$l, map{" a\.e(".sjson($_).");"} @{S.z};
    push @$l, Rw JSpots $I:S.X;
    C.c.os = 1 if !grep {/\S/} @{S.z};
    C.sc.Wc = 1;
JSpots: |
    my @sup;
    for my $K (sort keys %$I) {
        my $cvs = $I->{$K};
        my @cvs = ();
        for my $cv (sort keys %$cvs) {
            my $ts = $cvs->{$cv};
            my @ts;
            for my $t (sort keys %$ts) {
                my $D = $ts->{$t};
                my $s = {%{D.sc}};
                die "collajsee s.args" if s.args ne 'A,C,G,T,s';
                delete $s->{$_} for qw'of acgt args dige lines js';
                push @ts, [$t,$s];
            }
            push @cvs, [$cv, \@ts];
        }
        push @sup, sjson({eine=>[$K,\@cvs]});
    }
    @sup

