
Sefi: |
    u ReoCur
    y.at.anch = 'Noteal';
    y.at.ux = 1;
    y.at.oWl = 1;
    y.at.ws = 1;
    y.at.hs = '393';
    y.in = 0.03;
    y.out = 4;
    J.VV.N = 1;
    
    Rw Sefission;
Sefission: |
    my $p = 'g/c/*';
    Mn(p=>''=>$p,'%decor,hs:388,fs:15');
    
    # $f mtimes into w/wf/$fish (s/\//-/g), for its -glo:
    #  - way $k digs into w/digway/$kish
    #    - new file written & diffed and move in/over w/way/$kish
    
    my $glomet = sub {
        my $f = shift;
        my $mt = (stat $f)[9];
        my $fi = $f;
        $fi =~ s/\//-/g;
        my $wf = "w/wf/$fi";
        my $mft = (stat $wf)[9] if -f $wf;
        $mt > $mft
    };
    
    my @li = glob $p;
    for my $f (@li) {
        $glomet->($f) || next;
        # part of glo ^
        Mn($f=>-glo=>{}=>'%dis');
    }
    Mn(found=>''=>"found ".@li);
    n o=>42=>"@",'%fs:40,blr:4';
    # and so
pi/glo: | # see file glowing, flood gates of
    y.at.hs = '638';
    n f => 1 => C.t
    n changed=>2=>changed=>'%hs:857'
    
    my $d = LoadFile($s);
    `mkdir w/way` if !-d 'w/way';
    `mkdir w/digway` if !-d 'w/digway';
        
        while(my($k,$v) = each %$d) {
            $k =~ s/\//-/g;
            my $waf = "w/way/$k";
            my $wig = "w/digway/$k";
            my $dig = slm 10, dig($v);
            my $lin = readlink($wig) if -l $wig;
            if ($lin eq $dig) {
                #sayyl "$wig same ($dig)";
                next;
            }
            else {
                sayyl "Lin: $k   $dig <--- $lin" if $lin;
                sayre "No lin $wig " if !$lin;
            }
            write_file($waf."nt",$v);
            if (!-f $waf || `diff $waf ${waf}nt`) {
                Mn(gfot=>''=>"+ $k");
                `mv ${waf}nt $waf`;
            }
            else {
                `rm ${waf}nt`;
            }
            -l $wig && `unlink $wig`;
            `ln -s $dig $wig`;
        }
        
    # mtimes in wf must be after any of the inner branches ^
    my $fi = $s;
    $fi =~ s/\//-/g;
    my $wf = "w/wf/$fi";
    `mkdir w/wf` if !-d 'w/wf';
    write_file($wf,'');
    
Wjes: |
    u ReoCur
    u curv =>pi=><<''
        zoom 0  0.7
        y    0  0
        x    0  0
        curve 0 0.03
    
    J.ev.th ||= 'middle';
    J.ev.li ||= 'climbo';
    J.ev.bo ||= 'bodos';
    
    y.at.ux = 1;
    y.at.oWl = 1;
    y.at.ws = 1;
    y.at.hs = '893';
    y.in = 0.03;
    y.out = 6;
    #J.VV.N = 1;
    y.ert = 20;
    
    Mn("w/H"=>-Join);
pi/Join: |
    C.sc.dos = 'pileJup';
    y.ert = 32;
    my $dir = $s;
    -d $dir || die "No $dir";
    n Join=>0.0001=>$dir,'%decor,hs:388'
    my $jes = J.mo.jes = $J;
    (my $rd,C.c.isley) = ($1,$2) if $dir =~ /^(.+)\/(.+?)$/
        || die "DirJ not k ended: $dir";
    
    # should Atime(2) from a globby ls + this J pins
    
    my $geese = sub {
        my $f = shift;
        my $way = $1 if $f =~ /.+\/(.+?)$/;
        $way || die "noqway $f";
        my $mt = (stat $f)[9];
        my $fi = $f;
        $fi =~ s/\//-/g;
        my $wf = "w/way/$way";
        my $wt = (stat $wf)[9] if -f $wf;
        $wt > $mt
    };
    
    my $li = {map{$_=>1}glob("$dir/*")};
    delete $li->{$_} for qw'.git .gitignore';
    my @n;
    my $jf = "$dir/J";
    if (delete $li->{$jf}) {
        Rw trowil $J $s:jf;
        #Mn($jf=>-gejo=>{}=>'%dis');
    }
    else {
        sayre "No $jf in ".wdump 2, $li;
    }
    my $tow = jes.tower || die "no tower";
    my $wt = jes.trowl || die "no trowl";
    my $tal;$tal = sub {
        my ($d,$wt) = @_;
        map {
            my $v = $wt->{$_};
            my @M;
            push @M, [$_=>''=>{s=>$_,ind=>$d}];
            push @M, $tal->($d+1, $v) if keys %$v;
            @M
        } sort keys %$wt;
    };
    my $N = do { #G&NM
        my $M = [];
        my $N = [$tal->(0,$wt)];
        Mn($N);
        $M;
    };
    
    my $was = {};
    for (@$N) {
        my $s = $tow->{_.t}->{e} || next;
        _.c.isley = s.src if s.src;
        'src' ne join(' ', sort keys %$s) &&
            die "Moresutf: ".ki $s;
    }
    for (@$N) {
        my $f = _.c.isley ? "$rd/_.c.isley/_.t" : "$dir/_.t";
        if (delete($li->{$f}) || $was->{$f} || _.c.isley) {
            -f $f || die "NO isley C.t thiong $f" if _.c.isley;
            _.c.s = $f;
            _.sc.ml = _.c.ind * 3;
            if ($geese->($f)) {
                _.c.pi = 'gee';
            }
            else {
                _.c.pi = 'bl';
            }
            if (my $aw = $was->{$f}) {
                if (aw.c.ind <= _.c.ind) {
                    _.c.pi = 'gefore';
                }
                else {
                    aw.c.pi = 'gefore';
                    $was->{$f} = $_;
                }
            }
            elsif (_.c.isley) {
                _.c.pi = 'gefore';
            }
            else {
                $was->{$f} = $_;
            }
            _.sc.id = $f;
            _.sc.hs = '255';
        }
        else {
            
            _.sc.hs = '339';
        }
        _.sc.dis = 1;
    }
    
    my $i;
    _.sc.id .= 'geef'.$i++ for grep { _.c.pi eq 'gefore' } @$N;
    my $la;
    for (1..3) {
        for (@$N) {
            _.c.dropi++ if _.c.pi eq 'gefore' && $la && la.c.pi eq 'gefore'
                && la.c.ind != _.c.ind;
            $la = $_;
        }
        @$N = grep{ keys %$_ } grep { !_.c.dropi } @$N;
    }
    my $ee = jes.teeps = {};
    my $un = {};
    my @ins = grep {_.c.pi ne 'gefore'} @$N;
    $ee->{_.t} = $_ for @ins;
    $un->{_.t}++ for @ins;
    my @to = grep { $un->{$_} > 1 } keys %$un;
    sayre wdump [ "things showed up too many;", @to] if @to;
    
    Mn($N);
    
    keys %$li &&
        Mn(unc=>''=>"Uncounted: $_\n",'%ws,dis')
            for sort keys %$li;
    
    n o=>62=>"sÒ‰",'%fs:60,blr:1,opa:3';
    # and so
pi/gefore: |
    y.at.dis = y.at.ws = C.sc.qs = 1;
    my $i = C.y.i - 1;
    my $fo;
    until (fo.c.ind + 1 == C.c.ind) {
        $fo = C.y.bal->[$i--];
        last if !$fo;
    }
    fo.c.pi eq 'gefore' && sayre "GEFORE FORE: ".
        ki($fo)."\n the : ".ki $C;
    # check J/fo.t/me.t is up to $s
    n Ge =>1=> C.t,'%fs:8,hs:548,sha:1 1 4 000'
    my $mosile = J.mo.jes.C.c.isley;
    my $k = C.c.isley || $mosile
        || die "mojes doesnt know code ... C.t";
    
    my $alwk = $k ne $mosile; # fo really, but we only show the first way out
    fo.c.s || return sayre "no source file".ki($fo)."\n".ki($C);
    Rw noMt + $s:fo.c.s $k $way:C.t $alwk;
pi/bl: |
    C.sc.qs = 1;
    n way=>1=>C.t
pi/gejo: | # the dog leg trowl sketch, optional
    y.at.hs = '388';
    y.at.mt = '5';
    y.at.fs = '9';
    y.at.lh = '0.9em';
    y.at.geo = 'a100 0 0.1 1.2';
    n gate=>2=>"\n.\n.\n.\n.\n.\n.\nGasm: $s\n\n";
    $s =~ /\/J$/ || die "nogate: $s";
    my $wt = J.mo.jes.trowl;
    my $tal;$tal = sub {
        my ($d,$wt) = @_;
        join"\n",map{
            ind(join("",("  ") x $d), $_)
        }map {
            "$_".(!keys %{$wt->{$_}} ? "" : do {
                ":\n".$tal->($d+1, $wt->{$_});
            });
        }sort keys %$wt;
    };
    my $s = $tal->(0,$wt);
    Mn(eo=>''=>"\n$s");
    
pi/gee: | # an out of dater (to way)
    C.sc.qs = 1;
    my ($gate,$way) = $s =~ /^(.+)\/(.+?)$/;
    $way eq C.t || die "C.t - $way mix";
    my $tw = J.mo.jes.tower;
    my $u = $tw->{$way} || die "no topwer $way";
    n way =>1=>C.t,'%hs:389'
    
    $s || die "no source file".ki $C;
    Rw noMt + $s $k=way $way:C.t;
noMt: | # draw out of dateness
    y.clos = 1;
    $s || die "no source file".ki $C;
    $way || die "no way $s".ki $C;
    $k || die "no kind of way $s".ki $C;
    my $mt = (stat $s)[9];
    my @ott = ({k=>$k});
    for my $h (@ott) {
        my $wf = "w/h.k/$way";
        say " COmp $s ".(-f$s)."  ->  $wf ".(-f$wf) if C.t eq 'Chang';
        if (!-f $wf) {
            n no=>2=>"NO $wf",'%hs:898'
            %$h = ();
            next;
        }
        h.t = (stat $wf)[9];
    }
    if (!grep { _.t > $mt } @ott) {
        Mn("k $k",'',$k) if ar.alwk;
        return;
    }
    push @ott, {k=>'now',t=>hitime()} unless ar.nowless;
    for my $h (@ott) {
        next unless keys %$h;
        if (h.t > $mt) {
            my $d = h.t - $mt;
            $d = Rw samv $d;
            Mn("d h.k",''," $d ",'%hs:333,ml');
            Mn("k h.k",'',h.k);
        }
    }
    
trowil: | # make two forms of hierarchy from eg $s=w/u/J -> w/u/J/*/*
    my @li = glob "$s/*/*";
    my $tw = {};
    my $et = {};
    for my $f (@li) {
        my ($gate,$up,$way) = $f =~ /^(.+)\/J\/(.+?)\/(.+?)$/;
        if ($way =~ /^(.+?)_(.+)$/) {
            my ($way,$set) = ($1,$2);
            saybl "  $way trowil join thoughts: $set";
            my $st = {split '_', $set};
            my $ts = $et->{$way} ||= {};
            %$ts = (%$ts, %$st);
            next;
        }
        $up && $way || die "nope $f";
        $tw->{$up}->{n}->{$way} = 1;
        $tw->{$way}->{u}->{$up} = 1;
    }
    $tw->{$_}->{e} = $et->{$_} for keys %$et;
    my $wt = {};
    $wt->{$_} = {} for grep{!$tw->{$_}->{u}} keys %$tw;
    keys %$wt || die "No top level! Circular?";
    my @ne = $wt;
    my $i;
    while (@ne) {
        $i++ > 166 && die "$s join wanders for $i from ".@li." lines, maybe circular?";
        my @m = @ne;
        @ne = ();
        for $wt (@m) {
            for my $k (keys %$wt) {
                my $t = $tw->{$k};
                if (t.n) {
                    my $n = $wt->{$k};
                    $n->{$_} = {} for keys %{t.n};
                    push @ne, $n;
                }
                else {
                    #
                }
            }
        }
    }
    J.mo.jes.tower = $tw;
    J.mo.jes.trowl = $wt;
pileJup: | # select things into Dug
    # not =>$E properly, C is first C,c.e $E is from before $E
    my @Js = I.d&inDin,$E,'_hJ';
    @Js == 3 || return sayre("WEird look".wdump 4, [ @Js  ]) &&
        Rw talkzyh;
    my ($tW,$tJ,$tl) = @Js;
    tW.mo.J eq $tW
        || die "not most 1: ".ki $tW;
    tJ.C.sc.pi eq 'Join'
        || die "not Join 2: ".ki($tJ).saybl(wdump 2, tJ.C);
    tl.C.sc.pi =~ /^(bl|gee)$/
        || die "not bl/gee 3: ".ki $tl;
    my $jes = tJ.mo.jes;
    my $to = jes.tower;
    my @up = tl.C.t;
    while (1) {
        my $l = $up[0];
        die "if $l" if $l =~ / or /;
        my $o = $to->{$l} || die "No tower: $l ".wdump 2, $to;
        my $u = o.u || last;
        my @ops = sort keys %$u;
        if (@ops > 1) {
            my ($C,@oC) = map {jes.teeps->{$_}} $l,@ops;
            @oC = I.d&norp,'c/ind',@oC;
            @ops = map{_.t} shift @oC;
        }
        unshift @up, join(" or ", @ops);
    }
    my $path = join';',@up;
    say "Find path to tl.C.t    whichis:   $path";
    my $M = E.c.us.pick ||= [];
    Mn(founde=>-edr=>$path,{mean=>Jiter=>onto=>tJ.C.c.s});
    n Dug =>$E
    T.pos = 0;
Jiter: | # Dug Jiters, make travel for the bunch of ghost in ean
    sayyl "Jiterating ! C.t";
    # not =>$E properly, C is first C,c.e $E is from before $E
    my @Js = A.e&_hJ;
    my ($tW,$tl) = @Js[0,-1];
    tW.mo.J eq $tW || die "not most 1: ".ki $tW;
    my $ing = tl.C;
    my $ip = {map{$_=>ing.sc->{$_}}@{J.uzk}};
    ip.mean && ip.onto || die " notmeanonto compre ".ki $ing;
    ip.pi = 'edr';
    my ($gate,$way) = ip.onto =~ /^(.+)\/(.+?)$/;
    $gate && $way || die "notipono: ip.onto";
    
    my $duvi = sub {
        my $tl = shift;
        my $uv = tl.El.Duv || die "HJiter not Duv tl.name";
        map{uv.tv->{$_}}@{uv.os}
    };
    my $gre = sub {
        grep { I.d&ip,$ip,_.sc } $duvi->(shift);
    };
    my @bun = $gre->($tW);
    push @bun, $gre->($tl);
    my @s = uniq map{_.c.s} @bun;
    saybl "Make Joint stand: ".ki($ip).": ".wdump 3, \@s;
    my $r = {};
    for my $leng (@s) {
        my @l = split ';', $leng;
        @l > 1 || die "Leng not long enough: @l".wdump \@l;
        r.ops->{$l[0]}++;
        while (@l > 1) {
            my $o = shift @l;
            my $n = shift @l;
            my $f = ip.onto."/J/$o/$n";
            r.ave->{$f}++;
            unshift @l, $n;
        }
    }
    my $c = {isle=>$way};
    sayyl "You ordered: ip.onto: $way (c.isle) ".wdump $r;
    `echo 1 > $_` for keys %{r.ave};
    # jobinate (J1) or fork or acquire fork or something...
    Rw waited $J:_ $c
    for keys %{r.ops};
    T.pos = 0;
    
    
indoc: | # for notes, income
    A.us&pick || return
        Rw clack unindoc_pick;
    # ^ array of pick, can be empty meaning bring display,
    # align proteins tracks, sheer interest
    my @M = A.us&_pick;
    _.sc.doct = "J.name J.id" for @M;
    _.sc.id = "io".mkuid() for @M;
    push @{J.UG}, @M;
    sayyl "Intdoctrined J.name from A.J.name: ";
    sayyl " - ".ki $_ for @M;
Dug: | # acum, regroup, persist, do batches
    u ReoCur
    y.at.ux = 1;
    J.ev.th ||= 'middle';
    J.ev.o ||= 'indoc';
    J.ev.li ||= 'climbos';
    J.ev.tr = 1;
    
    J.uzk = [qw'mean onto etc'];
    J.UG ||= [];
    
    y.in = 0.1;
    y.out = 0.5;
    y.ert = 3;
    J.VV.N = 1;
    
    Atime(2);
    @{J.UG} = grep {keys %$_} @{J.UG};
    
    n downsave=>[-doi=>0.04]
    #saybl "J.name JUG:: ".ki $_ for @{J.UG};
    
    my $pi = {};
    for my $u (@{J.UG}) {
        my $k = join(' ', map{u.sc->{$_}}@{J.uzk});
        push @{$pi->{$k}||=[]}, $u;
    }
    for my $k (sort keys %$pi) {
        my $v = $pi->{$k};
        my $ts = {};
        for my $u (@$v) {
            my $ses = u.sc->{ts.k};
            push @{$ts->{$ses}||=[]}, $u;
        }
        if (keys %$ts > 1) {
            my @o = sort {@{$ts->{$a}} <=> @{$ts->{$b}}} keys %$ts;
            saybl "You have doct: ".wdump [ @o ];
            ts.win = $ts->{$_} for pop @o;
            ts.k = 'doct';
        }
        Mn($k=>-ean=>{s=>$v,ts=>$ts});
    }
 
downsave: | # Dug downup
    if (A.us&S ) {
        sayre "Downsave shave ".@{J.UG} for 1..3;
        @{J.UG} = ();
        return;
    }
    sayyl "downsave ! ".ki $C;
    
    my ($one,$other) = map { wdump $_, J.UG } 5,7;
    length $one == length $other || die "wdump depth 5-7 unstable: $other";
    my $dir = 'w/downsave';
    `mkdir -p $dir` if !-d $dir;
    DumpFile("$dir/C.t", J.UG);
downsave_up: |
    my $j = J.mo.J;
    my $t = j.C.t;
    my $dir = 'w/downsave';
    my $f = "$dir/$t";
    return saygr "No\ndown\nsave: $t" unless -f $f;
    my $datya = LoadFile($f);
    die "Eval $f: $@" if $@;
    die "Not dataray $f $datya" if ref $datya ne 'ARRAY';
    push @{j.UG}, map {saybl "Resuyming $t: ".ki $_;$_} @$datya;
pi/ean: | # a group, see J.uzk
    y.close = 1;
    y.ert = 6;
    n ean=>1=>"Meaning: C.t"
    (C.sc.dos) = (C.sc.mean,C.sc.onto) = (split ' ', C.t);
    Mn($s);
pi/edr: | # thing in a group
    my $ts = J.Jiter.C.c.ts; # look to ean
    n for=>1=>$s,'%fs:12,hs:347'
    n instr=>2=>" To C.sc.mean C.sc.onto"
    C.sc.dos = 'getcated';
    ts.win && $ts->{C.sc->{ts.k}} ne ts.win &&
        n move=>3=>"Æ¾",'%dos:getcated,id:whatu'
getcated: | # moves
    my @h = A.e&_hC;
    my $p = shift @h;
    my ($ic,$edr,@etc) = reverse @h;
    p.c.J.mo.J eq p.c.J || die "Nomop: ".ki $p;
    my $jugs = sub {
        my $u = shift;
        return (grep{ _.sc.id eq u.sc.id}@{J.UG})[0];
    };
    $edr = edr.c.J.C if edr.y.cv == 0.9;
    shift @etc if $etc[0] == $edr; # ^ yeah
    sayyl " HAs: ".ki $ic;
    saybl "Se edr: ".ki $edr;
    my $co = $jugs->($edr);
    sayyl "Self: ".ki $co;
    if ($ic && ic.y.cv < 0.9) {
        $_ = ic.c.s;
        /\;/ ? do {
            
        }:
        /Æ¾/ ? do {
            co.sc.etc++;
            # another layer of how to do increments, Jtinue split into sorts ops
            sayyl "Shifted  to co.s.etc";
        }
        : die " nO $_";
    }
    else {
        sayre "Guess you want to unJUG ".ki $co;
        @{J.UG} = grep{ $_ ne $co } @{J.UG};
    }
    saybl " _ _ _ ".ki $_ for $p,$edr,$ic;
    sayre " _ _ _ ".ki $_ for @etc;
    # Rw UnPreDuv $J; # opposite of help until c/sc inner properly VOD

