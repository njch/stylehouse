
Gop: |
    This abstract where ways have veins of subsistence
    passing from one wave to another, time clocks in at many angles
    anything past sensitivity
    4 is return of atscs, 5 be sequenced
    
    G would have T way to intuit, gets C and D join
    so when you G Steve, there is a slight interest in
    
Sefi: |
    u urw
    y.at.anch = 'Noteal';
    y.at.ws = 1;
    y.at.hs = '393';
    y.in = 0.03;
    y.out = 4;
    J.VV.N = 1;
    
    Rw Sefission;
Sefara: |
    my $J = G.oin;
    n Sefission;
Sefission: | # maintain g/c/* peelings to -> w/way/$K
    my $p = 'g/c/*';
    Mn(p=>''=>$p,'%decor,hs:388,fs:15');
    
    sayyl "AKiur";
    # $f mtimes into w/wf/$fish (s/\//-/g), for its -glo:
    #  - way $k digs into w/digway/$kish
    #    - new file written & diffed and move in/over w/way/$kish
    
    my $glomet = sub {
        my $f = shift;
        my $mt = (stat $f)[9];
        my $fi = $f;
        $fi =~ s/\//-/g;
        
        
        my $wf = "w/wf/$fi";
        my $mft = (stat $wf)[9] if -f $wf;
        $mt > $mft
    };
    
    my @li = glob $p;
    for my $f (@li) {
        $f =~ /(?!8)\d\d\d$/ && next;
        $glomet->($f) || next;
        # part of glo ^
        say "See $f";
        Mn($f=>-glo=>{}=>'%dis');
    }
    Mn(found=>''=>"found ".@li);
    n o=>42=>"@",'%fs:40,blr:4';
    # and so
    
pi/glo: | # see file glowing, flood gates of
    y.at.hs = '638';
    n f => 1 => C.t
    n changed=>2=>changed=>'%hs:857'
    
    my $d = LoadFile($s);
    `mkdir w/way` if !-d 'w/way';
    `mkdir w/digway` if !-d 'w/digway';
        
        while(my($k,$v) = each %$d) {
            {
                my $k = $k;
                $k =~ s/\//-/g;
                my $waf = "w/way/$k";
                # bol
                my $wig = "w/digway/$k";
                my $dig = slm 10, dig($v);
                my $lin = readlink($wig) if -l $wig;
                next if $lin eq $dig;
            }
            Rw w_way_file $k $v
            && 
            Mn(gfot=>''=>"+ $k")
        }
        
    # mtimes in wf must be after any of the inner branches ^
    my $fi = $s;
    $fi =~ s/\//-/g;
    my $wf = "w/wf/$fi";
    `mkdir w/wf` if !-d 'w/wf';
    write_file($wf,'');
    
w_way_file: |
            $k =~ s/\//-/g;
            my $waf = "w/way/$k";
            # bol
            my $wig = "w/digway/$k";
            my $dig = slm 10, dig($v);
            my $lin = readlink($wig) if -l $wig;
            if ($lin eq $dig) {
                #sayyl "$wig same ($dig)";
                return
            }
            else {
                sayyl "Lin: $k   $dig <--- $lin" if $lin;
                delete G.way.>$k;
                sayre "No lin $wig " if !$lin;
            }
            write_file($waf."nt",$v);
            if (!-f $waf || `diff $waf ${waf}nt`) {
                `mv ${waf}nt $waf`;
            }
            else {
                `rm ${waf}nt`;
            }
            -l $wig && `unlink $wig`;
            `ln -s $dig $wig`;
            return 1
Pile: |
    u ReoCur
    u curv =>pi=><<''
        zoom 0  0.7
        y    0  0
        x    0  0
        curve 0 -0.13
    
    J.ev.th ||= 'middle';
    J.ev.li ||= 'climbo';
    J.ev.bo ||= 'bodos';
    
    y.at.ux = 1;
    y.at.oWl = 1;
    y.at.ws = 1;
    y.at.hs = '893';
    y.in = 0.03;
    y.out = 6;
    J.VV.N = 1;
    y.ert = 20;
    
    Mn("w/U"=>-Join);
pi/Join: |
    C.sc.dos = 'pileJup';
    y.ert = 32;
    my $dir = $s;
    -d $dir || die "No $dir";
    n Join=>0.0001=>$dir,'%decor,hs:388'
    my $jes = J.mo.jes = $J;
    (my $rd,C.c.isley) = ($1,$2) if $dir =~ /^(.+)\/(.+?)$/
        || die "DirJ not k ended: $dir";
    
    # should Atime(2) from a globby ls + this J pins
    
    my $geese = sub {
        my $f = shift;
        my $way = $1 if $f =~ /.+\/(.+?)$/;
        $way || die "noqway $f";
        my $mt = (stat $f)[9];
        my $fi = $f;
        $fi =~ s/\//-/g;
        my $wf = "w/way/$way";
        my $wt = (stat $wf)[9] if -f $wf;
        $wt > $mt
    };
    
    my $li = {map{$_=>1}glob("$dir/*")};
    delete $li->{$_} for qw'.git .gitignore';
    my @n;
    my $jf = "$dir/J";
    if (delete $li->{$jf}) {
        Rw trowil $J $s:jf;
        #Mn($jf=>-gejo=>{}=>'%dis');
    }
    else {
        sayre "No $jf in ".wdump 2, $li;
    }
    my $tow = jes.tower || die "no tower";
    my $wt = jes.trowl || die "no trowl";
    my $tal;$tal = sub {
        my ($d,$wt) = @_;
        map {
            my $v = $wt->{$_};
            my @M;
            push @M, [$_=>''=>{s=>$_,ind=>$d}];
            push @M, $tal->($d+1, $v) if keys %$v;
            @M
        } sort keys %$wt;
    };
    my $N = do { #G&NM
        my $M = [];
        my $N = [$tal->(0,$wt)];
        Mn($N);
        $M;
    };
    
    my $was = {};
    for (@$N) {
        my $s = $tow->{_.t}->{e} || next;
        _.c.isley = s.src if s.src;
        'src' ne join(' ', sort keys %$s) &&
            sayre "elvis noise: ".ki $s;
    }
    for (@$N) {
        my $f = _.c.isley ? "$rd/_.c.isley/_.t" : "$dir/_.t";
        if (delete($li->{$f}) || $was->{$f} || _.c.isley) {
            -f $f || die "NO isley C.t thiong $f" if _.c.isley;
            _.c.s = $f;
            _.sc.ml = _.c.ind * 3;
            if ($geese->($f)) {
                _.c.pi = 'gee';
            }
            else {
                _.c.pi = 'bl';
            }
            if (my $aw = $was->{$f}) {
                if (aw.c.ind <= _.c.ind) {
                    _.c.pi = 'gefore';
                }
                else {
                    aw.c.pi = 'gefore';
                    $was->{$f} = $_;
                }
            }
            elsif (_.c.isley) {
                _.c.pi = 'gefore';
            }
            else {
                $was->{$f} = $_;
            }
            _.sc.id = $f;
            _.sc.hs = '255';
        }
        else {
            
            _.sc.hs = '339';
        }
        _.sc.dis = 1;
    }
    
    my $i;
    _.sc.id .= 'geef'.$i++ for grep { _.c.pi eq 'gefore' } @$N;
    my $la;
    for (1..3) {
        for (@$N) {
            _.c.dropi++ if _.c.pi eq 'gefore' && $la && la.c.pi eq 'gefore'
                && la.c.ind != _.c.ind;
            $la = $_;
        }
        @$N = grep{ keys %$_ } grep { !_.c.dropi } @$N;
    }
    my $ee = jes.teeps = {};
    my $un = {};
    my @ins = grep {_.c.pi ne 'gefore'} @$N;
    $ee->{_.t} = $_ for @ins;
    $un->{_.t}++ for @ins;
    my @to = grep { $un->{$_} > 1 } keys %$un;
    sayre wdump [ "things showed up too many;", @to] if @to;
    
    Mn($N);
    
    keys %$li &&
        Mn(unc=>''=>"Uncounted: $_\n",'%ws,dis')
            for sort keys %$li;
    
    n o=>62=>"sÒ‰",'%fs:60,blr:1,opa:3';
    # and so
pi/gefore: |
    y.at.dis = y.at.ws = C.sc.qs = 1;
    my $i = C.y.i - 1;
    my $fo;
    until (fo.c.ind + 1 == C.c.ind) {
        $fo = C.y.bal->[$i--];
        last if !$fo;
    }
    fo.c.pi eq 'gefore' && sayre "GEFORE FORE: ".
        ki($fo)."\n the : ".ki $C;
    # check J/fo.t/me.t is up to $s
    n Ge =>1=> C.t,'%fs:8,hs:548,sha:1 1 4 000'
    my $mosile = J.mo.jes.C.c.isley;
    my $k = C.c.isley || $mosile
        || die "mojes doesnt know code ... C.t";
    
    my $alwk = $k ne $mosile; # fo really, but we only show the first way out
    fo.c.s || return sayre "no source file".ki($fo)."\n".ki($C);
    Rw noMt + $s:fo.c.s $k $way:C.t $alwk;
pi/bl: |
    C.sc.qs = 1;
    n way=>1=>C.t
pi/gee: | # an out of dater (to way)
    C.sc.qs = 1;
    my ($gate,$way) = $s =~ /^(.+)\/(.+?)$/;
    $way eq C.t || die "C.t - $way mix";
    my $tw = J.mo.jes.tower;
    my $u = $tw->{$way} || die "no topwer $way";
    n way =>1=>C.t,'%hs:389'
    
    $s || die "no source file".ki $C;
    Rw noMt + $s $k=way $way:C.t;
noMt: | # draw out of dateness
    y.clos = 1;
    $s || die "no source file".ki $C;
    $way || die "no way $s".ki $C;
    $k || die "no kind of way $s".ki $C;
    my $mt = (stat $s)[9];
    my @ott = ({k=>$k});
    for my $h (@ott) {
        my $wf = "w/h.k/$way";
        say " COmp $s ".(-f$s)."  ->  $wf ".(-f$wf) if C.t eq 'Chang';
        if (!-f $wf) {
            n no=>2=>"NO $wf",'%hs:898'
            %$h = ();
            next;
        }
        h.t = (stat $wf)[9];
    }
    if (!grep { _.t > $mt } @ott) {
        Mn("k $k",'',$k) if ar.alwk;
        return;
    }
    push @ott, {k=>'now',t=>hitime()} unless ar.nowless;
    for my $h (@ott) {
        next unless keys %$h;
        if (h.t > $mt) {
            my $d = h.t - $mt;
            $d = Rw samv $d;
            Mn("d h.k",''," $d ",'%hs:333,ml');
            Mn("k h.k",'',h.k);
        }
    }
    
trowil: | # make two forms of hierarchy from eg $s=w/u/J -> w/u/J/*/*
    my @li = glob "$s/*/*";
    my $tw = {};
    my $et = {};
    for my $f (@li) {
        my ($gate,$up,$way) = $f =~ /^(.+)\/J\/(.+?)\/(.+?)$/;
        if ($way =~ /^(.+?)_(.+)$/) {
            my ($way,$set) = ($1,$2);
            saybl "  $way trowil join thoughts: $set";
            my $st = {};
            my $ts = $et->{$way} ||= {};
            %$ts = (%$ts, %$st);
            next;
        }
        $up && $way || die "nope $f";
        $tw->{$up}->{n}->{$way} = 1;
        $tw->{$way}->{u}->{$up} = 1;
    }
    $tw->{$_}->{e} = $et->{$_} for keys %$et;
    my $wt = {};
    $wt->{$_} = {} for grep{!$tw->{$_}->{u}} keys %$tw;
    keys %$wt || die "No top level! Circular?";
    my @ne = $wt;
    my $i;
    my @las;
    while (@ne) {
        $i++ > 600 && die "$s join wanders for $i from ".@li." lines, maybe circular? ".join"->",@las[-20..-1];
        my @m = @ne;
        @ne = ();
        for $wt (@m) {
            for my $k (sort keys %$wt) {
                my $t = $tw->{$k};
                push @las, $k;
                if (t.n) {
                    my $n = $wt->{$k};
                    $n->{$_} = {} for sort keys %{t.n};
                    push @ne, $n;
                }
                else {
                    #
                }
            }
        }
    }
    J.mo.jes.tower = $tw;
    J.mo.jes.trowl = $wt;
pileJup: | # select things into Dug
    # not =>$E properly, C is first C,c.e $E is from before $E
    my @Js = I.d&inDin,$E,'_hJ';
    @Js == 3 || return sayre("WEird look") &&
        Rw talkzyh;
    my ($tW,$tJ,$tl) = @Js;
    tW.mo.J eq $tW
        || die "not most 1: ".ki $tW;
    tJ.C.sc.pi =~ /^J/
        || die "not /^J/oinish 2: ".ki($tJ).saybl(wdump 2, tJ.C);
    tl.C.sc.pi =~ /^(bl|gee)$/
        || sayre "not bl/gee 3: ".ki $tl;
    my $jes = tJ.mo.jes;
    my $to = jes.tower;
    my @up = tl.C.t;
    while (1) {
        my $l = $up[0];
        die "if $l" if $l =~ / or /;
        my $o = $to->{$l} || die "No tower: $l ".wdump 2, $to;
        my $u = o.u || last;
        my @ops = sort keys %$u;
        if (@ops > 1) {
            my ($C,@oC) = map {jes.teeps->{$_}} $l,@ops;
            @oC = I.d&norp,'c/ind',@oC;
            @ops = map{_.t} shift @oC;
        }
        unshift @up, join(" or ", @ops);
    }
    my $path = join';',@up;
    say "Find path to tl.C.t    whichis:   $path";
    my $M = E.c.us.pick ||= [];
    my $mean = tW.at.mean || 'Jiter';
    Mn(founde=>-edr=>$path,{mean=>$mean=>onto=>tJ.C.c.s});
    n Dug =>$E
    T.pos = 0;
Jiter: | # Dug Jiters, make travel for the bunch of ghost in ean
    sayyl "Jiterating ! C.t";
    # not =>$E properly, C is first C,c.e $E is from before $E
    my @Js = A.e&_hJ;
    my ($tW,$tl) = @Js[0,-1];
    tW.mo.J eq $tW || die "not most 1: ".ki $tW;
    my $ing = tl.C;
    my $ip = {map{$_=>ing.sc->{$_}}@{J.uzk}};
    ip.mean && ip.onto || die " notmeanonto compre ".ki $ing;
    ip.pi = 'edr';
    my ($gate,$way) = ip.onto =~ /^(.+)\/(.+?)$/;
    $gate && $way || die "notipono: ip.onto";
    
    my $duvi = sub {
        my $tl = shift;
        my $uv = tl.El.Duv || die "HJiter not Duv tl.name";
        map{uv.tv->{$_}}@{uv.os}
    };
    my $gre = sub {
        grep { I.d&ip,$ip,_.sc } $duvi->(shift);
    };
    my @bun = $gre->($tW);
    push @bun, $gre->($tl);
    my @s = uniq map{_.c.s} @bun;
    saybl "Make Joint stand: ".ki($ip).": ".wdump 3, \@s;
    my $r = {};
    for my $leng (@s) {
        my @l = split ';', $leng;
        @l > 1 || die "Leng not long enough: @l".wdump \@l;
        r.ops->{$l[0]}++;
        while (@l > 1) {
            my $o = shift @l;
            my $n = shift @l;
            my $f = ip.onto."/J/$o/$n";
            r.ave->{$f}++;
            unshift @l, $n;
        }
    }
    my $c = {isle=>$way};
    sayyl "You ordered: ip.onto: $way (c.isle) ".wdump $r;
    `echo 1 > $_` for keys %{r.ave};
    # jobinate (J1) or fork or acquire fork or something...
    Rw waited $J:_ $c
    for keys %{r.ops};
    T.pos = 0;
    saybl "All done";
    
    
indoc: | # for notes, income
    A.us&pick || return
        Rw clack unindoc_pick;
    # ^ array of pick, can be empty meaning bring display,
    # align proteins tracks, sheer interest
    my @M = A.us&_pick;
    _.sc.doct = "J.name J.id" for @M;
    _.sc.id = "io".mkuid() for @M;
    push @{J.UG}, @M;
    sayyl "Intdoctrined J.name from A.J.name: ";
    sayyl " - ".ki $_ for @M;
Dug: | # acum, regroup, persist, do batches
    u urw
    u Sugd
    u UpPg
    #u AmPg
    y.at.anch = 'Noteal';
    J.ev.o ||= 'indoc';
    J.ev.tr = 1;
    y.clos = 1;
    
    J.VV.N = 1;
    n dugsoma=>0.011=>"Somdoma"
    saybl "Eyup";
    Atime(2);
    sayyl "J.name conti".join("\n -",map{ki $_}@{J.UG});
 
Sugd: | # acum, regroup, persist, do batches (downsave J.UG to Pg)
    u allact
    n Sugdev =>3143,<<'','%code:U,v:scJ'
        J.ev.o ||= 'indoc';
        # dubimport
        J.ev.tr = 1;
        J.uzk ||= [qw'mean onto etc'];
        J.UG ||= [];
    
    # n MuSt # instance must have storage (AmPg)
    
    # between pin and M:
    n Sugdev =>33,<<'','%code:U,v:scJ'
        @{J.UG} = grep {keys %$_} @{J.UG};
        my $y = J.oy;
        y.in = 0.1;
        y.out = 0.5;
        y.ert = 3;
        G&Sugour,$J;
        J.VV.N = 1;
    
    u allacgts
    n Sugour =>'',<<''
        my $J = $s;
        my $pi = {};
        for my $u (@{J.UG}) {
            my $k = join(' ', map{u.sc->{$_}}@{J.uzk});
            push @{$pi->{$k}||=[]}, $u;
        }
        my $M = J.oy.o.M;
        for my $k (sort keys %$pi) {
            my $v = $pi->{$k};
            my $ts = {};
            for my $u (@$v) {
                my $ses = u.sc->{ts.k};
                push @{$ts->{$ses}||=[]}, $u;
            }
            if (keys %$ts > 1) {
                my @o = sort {@{$ts->{$a}} <=> @{$ts->{$b}}} keys %$ts;
                ts.win = $ts->{$_} for pop @o;
                ts.k = 'doct';
            }
            Mn($k=>-ean=>{s=>$v,ts=>$ts});
        }
    
pi/ean: | # a group, see J.uzk
    #y.clos = 1;
    y.ert = 6;
    n ean=>1=>"Meaning: C.t"
    (C.sc.dos) = (C.sc.mean,C.sc.onto) = (split ' ', C.t);
    Mn($s);
pi/edr: | # thing in a group
    n for=>1=>$s,'%fs:12,hs:347'
    n instr=>2=>" To C.sc.mean C.sc.onto"
    
    my $ts = J.Jiter.C.c.ts; # look the groups
    C.sc.dos = 'getcated';
    ts.win && $ts->{C.sc->{ts.k}} ne ts.win &&
        n move=>3=>"Æ¾",'%dos:getcated,id:whatu'
getcated: | # moves on the noise splitter
    my @h = e&_hC;
    my $p = shift @h; # J
    my ($ic,$edr,@etc) = reverse @h;
    # ic is clicked, edr may not be edr...
    p.c.J.mo.J eq p.c.J || die "Nomop: ".ki $p;
    $edr = edr.c.J.C if edr.y.cv == 0.9;
    shift @etc if $etc[0] == $edr; # ^ yeah
    sayyl " HAs: ".ki $ic;
    saybl "Se edr: ".ki $edr;
    
    # broke since hiding all outgoing ids
    my $jugs = sub {
        my $u = shift;
        my @f = grep{ _.sc.id eq u.sc.id}@{J.UG};
        $f[0];
    };
    my $co = $jugs->($edr);
    sayyl "Self: ".ki $co;
    
    my ($it) = grep { _.c.s eq ic.c.s } @{J.UG};
    
    my $rm;
    if (ic.t eq 'for') {
        $rm = $it;
    }
    elsif (ic.t eq 'instr') {
        it.sc.etc++;
        sayyl "Shifted  to it.sc.etc: ".ki$it;
    }
    else {
        die "no doing for a: ".ki$ic;
    }
    @{J.UG} = grep { _.c.s ne ic.c.s } @{J.UG};
    
    saybl " _ _ _ ".ki $_ for $p,$edr,$ic;
    sayre " _ _ _ ".ki $_ for @etc;
    # Rw UnPreDuv $J; # opposite of help until c/sc inner properly VOD

