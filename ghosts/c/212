oJ2: | # HOW c grabs on, how W transifies down...  # all goners!
     #sayyl "oJJJ oJJJ ".wdump $C;
     if (C.c.J eq A.J) {
         sayre "J above A.J.name";
         delete C.c.J;
     }
     if (exists C.c.J) {
         C.c.W = C.c.J;
         if (J.name ne 'qq') {
             A.ztime = 3;
         }
         # amount of time each thing spends being the top level
         # which was... n... mani
     }
     A.ztime = delete C.c.time if C.c.time;
     
     my $nn = A.note.not;
     
     C.c.s = 'S2im' if !defined C.c.s;
     nn&c,'s';
     C.c.W && # nets
     nn&c,'W';
     my $wasW;
     if (exists C.c.pi) {
         nn&c,'pi';
         Rw opi2 + $v:C.c.pi;
     }
     elsif (exists C.c.W) {
         $wasW = 1;
         nn&c,'W';
         Rw oW2 + $v:C.c.W;
     }
     else {
         #die "misrep ".wdump 2, $C;
     }
     if (C.c.W && !$wasW) {
         if (!ref C.c.W) {
             my $Wjr = Rw Ajr $J:G.oin $t:C.c.W $cv=0.3;
             my $WJ = Wjr&J;
             sayyl "HJvae A.J.name holding C.t with WJ.name" if J.V;
             C.c.W = $WJ;
         }
         else {
             die "knew W? ".ki C.c.W;
         }
     }
oo2: | # HOW humming c grabs on, how W transifies down...
     if (C.c.J eq A.J) {
         warn "J above A.J.name";
         delete C.c.J;
     }
     if (exists C.c.J) { # W but slower? U?
         C.c.W = C.c.J;
         A.ztime = 3 if A.J.name ne 'qq';
         # amount of time each thing spends being the top level
         # which was... n... mani
     }
     A.ztime = delete C.c.time if C.c.time;
     
     sayre "No S" if !defined C.c.s;
     sayre "nadad S" if !exists C.c.s;
     my $wasW;
     if (my ($s) = A.c&pi) {
         die wdump ["NOTED pi",$C,A.note];
         Rw oopi + $s;
     }
     elsif (my ($s) = A.c&W) {
         $wasW = 1;
         die wdump ["NOTED W",$C,A.note];
         Rw ooW + $s;
     }
     else {
         #die "misrep ".wdump 2, $C;
     }
     if (C.c.W && !$wasW) {
         if (!ref C.c.W) {
             # pi also wired to W
             my $Wjr = Rw Ajr $J:G.oin $t:C.c.W $cv=0.3;
             my $WJ = Wjr&J;
             sayyl "HJvae A.J.name holding C.t with WJ.name";
             C.c.W = $WJ;
         }
         else {
             die "knew W? ".ki C.c.W;
         }
     }
opi2: | # private investigators on crunchy gravel, spreaders
    # - c. language is map to some u before 6ing
    my $v = C.c.pi;
    at.pi = $v || 'guess';
    # type of abdomin to use?
    C.c.J = 'pi';
    
    my $oJ = $J;
    $oJ = C.y.o.J if C.y.o && C.y.o.J;
    A.jr = Rw Ajr $J:oJ $C;
    
oW2: | # some get-J or weave wires protocol - hosts
    my $t = $v;
    $t = v.name if ref $t;
    at.J = ref $v ? $v : $t;
    at.W = $t;
    C.c.J ||= $v;
    
    die wdump ["onto W J.name:",$v] if ref $v && $v ne v.most.J;
    
    C.t = $t;
    # has already been 0.1 in Y
    C.y.cv ||= 0.3;
    
    A.jr = Rw Ajr $J:G.oin $t $cv=0.3;
    
    # and where the
    if (C.c.vv) {
        A.ztime = delete C.c.vv;
        A.jr&vv,9
        ->(); #delone
    }
oJ3: | # MOD  being repeater  - humm # GONER
    my $J = Rw oJ31;
    Rw oJ32 + $J;
    return if T.return;
    
    if (!ref $J) {
        if (C.sc.pi) {
            $J = Rw spinash $J:A.J;
        }
        elsif (!ref G.way->{$J}) {
            $J = Rw Jto $name:J;
            sayyl "J33   Made J.name";
        }
        else {
            my $o = {name=>C.c.J};
            o.style = delete C.c.style if C.c.style;
            # TODO make func like J.w&oc,style=>C.c;
            # which moves into the wall and percs lamt.
            $J = Rw JJ $o;
            sayyl "J3   Made J.name";
        }
        if (!ref G.way->{J.name}) {
            J.most.eo = 'Yesui';
            J.most.mody = 'mani';
        }
        C.sc.J = $J || die 'want23';
        C.c.s = "Swim" if !exists C.c.s;
    }
    
    my @an =  A.jr->('');
    if (@an && !exists C.c.s) {
        C.c.s = shift @an;
    }
    elsif (!@an && exists C.c.s) {
        A.jr->('',C.c.s);
    }
    die "noovewr   C.c.J ne $J" if ref C.c.J && C.c.J ne $J;
    A.jr&J,$J;
    at.J = $J;
    # ^ gets & replaces, C.sc.J now it
    
    Rw oJ4 + $J;
oJ31: |
    my $f = A.jr&J;
    my $j = C.sc.J;
    die ".sc J dif $f $j" if ref $j && ref $f && $j ne $f;
    C.sc.J = $f if $f && ref $f && !f.dead;
    C.sc.J
oJ32: |
    if (C.c.X) {
        die "Nofound $J  C.t   C.y.cv" if !ref $J;
        die "noovewr X  C.c.X ne $J" if C.c.X ne $J;
        sayyl "DELING J.name". wdump $C if C.c.X;
        A.jr&J,$J,9;
        J.dead = 1;
        T.return = [];
        return;
    }
    # also how & 9s (noncompresses) out for us into a more local J
    # u W would zlide in as an Elvis clone
    # it has a high frequency
        # re J 31,32,33, 9
oT6: |
    my $talk = "T J.most.J.name /// J.A.d J.name  J.A.ztime A.ztime";
    A.coi = Rw pha $J ako;
    
    if (exists C.sc.pi || J.most.ww2) {
        # telephone winch
        for (qw'ljm ljmo') {
             J.A->{$_} = J.Jiter.A->{$_}
             if J.Jiter && J.Jiter.A->{$_};
        }
        A.time = sub {
            my($JJ,$q) = @_;
            # then - is
            # crux to pi
            $J eq $JJ || die "wtf";
            # point to give up
            # so can much very, sculpt
            if ($q == 2) {
                A.ico = Rw pha $J ico;
                A.ico.qui = 1;
                A.ico.as->(A.coi);
                my $wt = A.ico.exactl->();
                
                if (wt.last && !wt.same) {
                    my $uf = join "\n", map{"$_: ".wdump(1,$wt->{$_})}
                        grep {keys %{$wt->{$_}}} qw'new diff gone';
                    saybl "$talk  2222  $uf";
                }
                
                Rw eighthnot $J
                 ? do { A.ico.wt.same = 0; }
                 : wt.same && return 0;
                
                # for jamcs screenfly
                J.A.ljm = [];
                J.A.ljmo = "fr  J.name";
                return 1;
            }
            warn "$talk other $q";
            if ($q == 8) {
                # until J.most coord attention evaporates
                # as in pulling on a list
            }
            A.ztime >= $q;
        };
    }

    my $M=[];
    my $y = {o=>$M};
    
    my $tw = Rw huck + $M $y;
    
    $tw || die "nothing! J.name";
    die "many".ki $tw if keys %$tw > 1;
    # set our C.c.s to [that], noise probe case, maybe

    Jn('z',$y) if @$M;
    
    my $sol = "?";
    # first the superstilled
    # anything T_D can arrange through time...
    # wants to join G subtly vis T and so....
    # should be no M in the first bit
    # it is just pinpricks of consciousness keeping it alive, like mtime
    # be nicer to do with an I that can T out of this whole change res patch
    if (A.ico && A.ico.wt.same) {
        my $cut = @{A.ico.ord};
        my @cc = @{A.coi.ord};
        if (@cc > $cut) {
            warn"J.name entered stuff after 2!".wdump [@cc, 
            '                 =============', @{A.ico.ord}];
        }
        A.coi.abandon->();
        if (my $ljm = J.A.ljm) {
            for my $ar (@$ljm) {
                ar.noR=1;
                Rw jamsc;
            }
        }
        sayre "SKIP $talk" if J.V || J.most.J.V;
        T.last = 1;
        $sol = "skip";
    }
    else {
        A.coi.qui = 1;
        my $wt = A.coi.exactl->();
        if (wt.same) {
            if (++J.A.wch > 4) {
                J.A.wch = 0;
                $sol = "same";
            }
            else {
               $sol = "skip";
               sayre "SAME $talk" if J.V || J.most.J.V;
                T.last = 1;
            }
        }
        else {
            $sol = "notsame";
        }
    }
    
    
oJ6: | # https://www.youtube.com/watch?v=tL8N_3tln0Y
    my $J = C.sc.J;
    my $talk = "T J.most.J.name /// J.A.d J.name  J.A.ztime  ----- A.ztime";
    sayyl "isn!   $talk       C.t " if J.most.J eq 'Hypo';
    
    unless (exists C.sc.pi) {
        return T.last = 1 unless Atime(6);
        
        my $n = sub{};
        if (A.ztime < 9) {
            my @am = A.jr&bol;
            sayre "doubly".wdump[@am] if A.jr&bol;
            $n = A.jr&bol,9;
        }
        aft {
            $n->();
            $@||return;
            sayre "BANG J.name" for 1..3;
            A.jr&bang_ts,hitime
            if J.most.J eq $J;
        };
    }
    
    %$ar = (%$ar, %{C.c});
    
    if (exists C.sc.pi) {
        Rw opi6 + $J;
    }
    elsif (J.most.wq) {
        saybl "oJ6666 C.t" unless J.yt.quiet || C.t =~ /^all/;
        my $p = J.name;
        Rw oT6 + $A $C $J $T $p;
    }
    else {
        saybl "oJ6 C.t" unless J.yt.quiet;
        Rw around + $J;
        A.roundi = 1;
    }
       
opi6: |
    die'csnod' if $C ne J.C;
    die if !ar.T;
    
    J.cv = C.c.gp.cv || C.c.cv || 0.6;
    my $s = C.c.s;
    my $path = C.sc.pi||die'nopi';
    if (J.A.d > 9) {
        $path = 'text';
        warn "J.name J.A.d limit to text";
    }
    my $pin = "pi/$path";
    
    Rw oT6 + $pin $s $u:s;
waz/up: | # a strain
    #sayre "J.name is wazing";
    if (!J.yt.nohead) {
        Rw Jhead;
        Jn(st=>0.9=>"o",'%hs:8427,fs:4');
    }
    die if !ar.T;
    Rw oT6 + $p=*/M $J $A:J.A $C:J.C $T;

oJ4: | # J.A remains, A transitory  - A.time is to couple it like I.in
    J.A ||= {first=>hitime()};
    # everytime stuff:
    #map { sayyl "A.J.name  vs J.name vs J.iter" } 1..3 if rand 9 > 8;
    
    # dep
    if (exists C.sc.pi) {
        die if J.Jiter ne A.J;
        die if J.most.J eq $J;
    }
    else {
        die if J.most.J ne $J;
    }
    
    if (C.c.time) {
        warn "CTIOME".ki $C;
        A.ztime = delete C.c.time;
    }
    A.ztime ||= 6;
    
    if (C.sc.pi) {
        J.A.d = J.Jiter.A.d + 1;
        J.ind = join '  ', ('') x J.A.d;
        J.name = "J.A.d . C.c.pi*C.t";
        J.d = J.C = $C;
        J.r = C.t."\t".C.y.cv;
        J.bz->("/\t0.9" => "y");
        A.time = sub {
             my($JJ,$q) = @_;
             A.ztime >= $q || do {
                 die "J.name  ---- JJ.name     A.ztime quuuuuu $q";
                 0
             };
        };
    }
    else {
        sayyl "Fo 4 A time A: $A   vs J.A " if J.name eq 'Eosse';
        A.time = sub {
             my($JJ,$q) = @_;
             A.ztime >= $q || do {
                 sayre "COMB J.name --- le-- JJ.name      A.ztime < $q";
                 A.jr&vv,$q;
                 0
             };
        };
    }
    
oJ42: |
    my @mis = grep{!A.note.c->{$_}}keys %{C.c};
    @mis=grep{$_ ne'J'}@mis;
    if (@mis) {
        my $cm;
        $cm->{$_} = C.c->{$_} for @mis;
        sayyl "Spesh J.name :  ".ki $cm unless J.yt.quiet;
        A.preg = $cm;
        A.ztime = 9;
    }
    
oJ43: | # the pull down
    J.A.in = $G->gip(J.Jiter.A.in, C.t)||{} if J.Jiter;
    
oC43: | # maniC pulls down travel # comep from aj compi
    if (my $c = $G->gip(A.J.A.in, C.t)) { 
        $c = c._ || return;
        say "C.t in: ".wdump $c if !A.J.yt.quiet;
        if (c.D) {
            c.D->($C);
        }
        elsif (grep {exists $c->{$_}} qw{t y c sc}) {
            g.extend->($C, $c);
        }
        else {
            die "howto ".ki $c;
        }
    }
fi: | #c
     my $point = ar.p || ar.pin || ar.m->[0];
     
     my $know;
     if (!ar.pin && ar.J) {
         my $J = ar.J;
         if ($point =~ /^\*\/(\w+)$/) {
             my $inway = $1;
             my $h = ar.h || G.way;
             $h = h.hooks if h.hooks;
             my @gu = @{J.yy.styleord};
             #@gu = @gu[0..5] if @gu > 6;
             my @so;
             for (@gu) {
                if (ref $h->{$_} eq 'HASH' && $h->{$_}->{$inway}) {
                    push @{$know||=[]}, "$_/$inway";
                    last if !ar.sucky;
                }
             }
         }
     }
     
     if (!$know) {
         my %wo = Rw findl +;


         my @keys = map { s/^\///; $_ } keys %wo;
         if (!ar.pin && ar.J) {
             my $J = ar.J;

             @keys = grep { my($K)=split'/',$_; J.yt->{$K} } @keys;
             my @or = @{J.yy.styleord};
             if (@or && @keys > 1) {
                 my $i = 1;
                 my $is = {map{$_=>$i++}@or};
                 @keys = sort {
                  $is->{($a=~/^(.+?)\//)[0]} <=> $is->{($b=~/^(.+?)\//)[0]}
                  } @keys;

                 if (!ar.sucky && @keys > 1) {
                     #sayre "Limiting @keys";
                     @keys = $keys[0];
                 }
             }
         }
         $know = [@keys];
     }
     #saybl "With: ar.J.name  $point    @$know" if ar.J && ar.J.name eq 'shv';
     @$know

