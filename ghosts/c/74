RB: | # inits A of ar C/N, pins spiral down (ret A.I that I.n,I.An,A.t)
    # non babzub, assume pbab skipped <<''s in origin
    my $A = {};
    
    A.oA = ar.oA if ar.oA;
    A.J = ar.J || die 'noJ';
    A.G = $G; # so travel can G/T/Hypo
    A.mo = $A;
    (A.am) = ar.t || ar.name || @{delete ar.m};
    A.am || die "unsame?";
    
    A.N = [ar.C || @{ar.N}];
    A.M = [];
    A.talk = "A.J.name ".(A.J.le && A.J.le.name);
    A.fl = ar.fl || {};
    A.I = {};
    
    my $I = delete G.drop.recycling->{A.J.id}->{A.am};
    
    my $II = Rw collaspII $A;
    
    if ($I) {
        if (I.Ii eq II.Ii) {
            say "Recyc A.talk! I.Ii continu" if A.J.V;
            #$I = {%$I,nF=>{}};
            A.I = $I;
            A.cv = 0.1;
        }
        else {
            sayre "Recycloped, Diff I.Ii  --  II.Ii" if A.J.V;
            undef $I;
        }
    }
    
    A.I.Ii = II.Ii;
    
    if (!$I) {
        $I = A.I||die'basenoi';
        Rw SNtl $I;
    }
    $A
Galso: | # Gooso goner # 
    G.h = sub {
        my $am = shift;
        my $D = $F[0];
        my $r = D.ar;
        my $A = r.A || die 'GhnoA';
        my $I = A.I || die 'GhnoI';
        I.d&Other,$am;
    };
    my %T = %{G.T||{}};
    G.T = \%T;
    {
        package Wormhole;
        use Tie::Hash;
        use YAML::Syck;
        our @ISA = qw(Tie::StdHash);
        sub FETCH {
            my ($s,$k) = @_;
            $s->{$k} ||= do{ 
            print "Loading w/$k ...\n" for 1..5;
            LoadFile("w/$k") };
        }
    }
    tie %T, 'Wormhole';
Seven: | # ^^^^^^^^^^^^^^^^^ is Motion, v is Sevening
    n Yesoo =>W
    n Yools =>W
    n Yuni =>W
    n Yeosleep =>W
    n Yosc =>W
    n Yeoodle =>W
    n Yeomp =>W
Yesoo: | # holst J most eo = Seve (above and below)
    u allvse
    n '','','%of:Mo'
    n J =>69,<<''
        J.most.eo = 'Sev';
        # dosgeo v Yesui as O or so
        # A pile v spiral
        # hive of change
Yools: |
    u allacgts
    
    n hup =>'',<<'','%code:Sev 1'
        my $CC = {%$s};
        $CC->{$_} = {%{$CC->{$_}}} for grep {ref $CC->{$_} eq 'HASH'} keys %$CC;
        $CC;
    
    n heq =>'',<<'',{acgt=>'o,t'}
        if (ref $o && ref $t) {
            keys %$o == keys %$t && !grep{$o->{$_} ne $t->{$_}}keys %$o
        }
        elsif (!ref $o && !ref $t) {
            $o eq $t
        }else{0}
Sev: |
    sayyl "SEV!" for 1..5;
    ar.C ||= [Elvis=>''=>{J=>$J,Y=>'Pres',V=>'Dsuv'}];
    my ($A,$I) = G.h&Sev;
    my $i;
    while (@{A.N}) {
        $i++ > 1000 && die "Huge A.am";
        my ($A,$C,$T) = I.d&Act,$A;
                T.not&&next;
        A.t&6;
                T.not&&next;
        I.d&flywheels;
                T.not&&next;
        A.t&78;
                T.not&&next;
    }
    continue { I.d&z; }
    A.t&89;
    I.d&recycle;
    A.retu;
Yuni: |
    u allvse
    n '','','%of:Sev'
    
    # time impersonator
    n Y =>2=><<'',{rg=>'J,V'}
        for my $K ('Y','V') {
            my $name = C.c->{$K};
            $name || die "No $K";
            C.c->{$K} = Rw Elj $J $name;
        }
        
    # exchange        
    n Y =>21=><<'',{rg=>'J,V'}
        Rw Elvis $J $Y;
        V.os = [];
        A.mo.retu && die "J.name's  V.name: Already is  A.mo.retu.name";
        A.mo.retu = $V;
    
    # root of etc (yin)
    n Y =>22=><<'',{rg=>'J,V'}
        my $rC = Y.tv->{"0.9\t/"}
            || Y.tv->{"0.9\t".J.name}
            || Y.tv->{"0.9\t".J.uname}
              || die " noroot J.name: showing 0.9s: "
                .wdump [map{ki $_}values %{Y.v->{0.9}}];
        rC.c.root = 1;
        my $N = [grep { $_ ne $rC } @{Y.vs}];
        push @$N, $rC;
        # T.Z.$incv = 1||$setAcv makes A,Celf, 
        # A.mo.re array others (yarN) which may Acquire
        push @{A.mo.re->{0.22}||=[]}, map{
            my $CC = I.d&hup,$_;
            # all spreads out to play Y/V
            I.d&xot,$CC,{c=>C.c};
            [undef,$CC]
        }@$N;
        T.not = 1; # or more 78ism

    n Y =>23=><<'',{rg=>'J,V'}
        C.y.k = C.y.cv."\t".C.t;
        push @{V.os}, C.y.k unless C.c.root;
        # how happening to thingk
        # must ,,,, A.t to gain perception (not mid ex but should)
        # but yeah add things as lines rejoin
        A.Iso.O = 1;
    
    n Y =>231=><<'',{rg=>'J,V'}
        return if C.c.root;
        T.to = 0;
        A.t&S,6,2;
        T.not = 1 if !delete T.to;
    
    n Y =>3=><<'',{rg=>'J,V,yk'}
        C.y.lv = {k=>$k,C=>$C};
        C.y.at = {};
        C.y.ta = V.ta->{$k};
        C.y.vl = V.lv->{$k};
        if (C.c.root) { # / continues from 3 when everything's 6
            T.Z->{0.6} = 0.3;
            T.not = 1;
        }
    
    n Y =>48=><<'',{rg=>'J,V,yk,yat'}
        V.ta->{$k} = I.d&hup,$at;
        V.tv->{$k} = I.d&hup,$C;

    n Y =>58=><<'',{rg=>'J,V,yk,ylv,yvl'}
        V.lv->{$k} = $lv;
        if (C.c.root) {
            V.rl = $vl;
            V.rv = $lv;
            Rw TNews $J $talk:A.talk $rl:V.rl $rv:V.rv
                if J.V;
        }

    
Yeosleep: | # notes in V.os of C, sees if it wants to wake up...
    u allvse
    n '','','%of:S'
    
    # if change is, or just diff in perceiving it
    # looking at refs that came from string, or who are spiraling refs
    n Y =>24=><<'',{rg=>'J,V'}
        if (my $di = Y.lo->{C.y.k}) {
            my $not;
            if (keys %$di == 1 && di.diff) {
                my $CC = V.tv->{C.y.k};
                if (!$CC) {
                    sayre "never heard of (V_tv) diff J.name : C.y.k ";
                    return 1;
                }
                for my $tk (keys %{di.diff}) {
                    if ($tk eq 'geo') {
                        T.to = 1 if 0 && !I.d&heq,C.sc.geo,CC.sc.geo;
                        if ($not && 0) {
                            sayyl "Geo was $not a difference in the thing";
                            sayyl sjson(C.sc.geo);
                            saybl sjson(CC.sc.geo);
                        }
                    }
                    elsif ($tk eq '') {
                        T.to = 1 unless ref C.c.s && C.sc.dige && C.sc.dige eq CC.sc.dige;
                    }
                    else {
                        saybl "J.name C.y.k has diffre: $tk";
                        T.to = 1;
                    }
                }
            }
            else {
                T.to = 1;
            }
        }
        T.whack = 1 if T.to;
    
    # J embed
    n Y =>25=><<'',{rg=>'J,V'}
        if (my $JJ = C.sc.J) {
            my $ta = V.ta->{C.y.k};
            if (my $nV = JJ.El->{V.name}) {
                my $iv = nV.rv;
                my $oi = ta.V->{V.name};
                if ($oi ne iv.i) {
                    T.to = 1;
                }
            }
            else {
                sayre "no El V.name on JJ.name";
            }
        }
        T.whack = 1 if T.to;
        
Yosc: | # make lv,at + write stuff on at
    u allovse
    n '','','%of:O'
    
    n Y =>31=><<''
        at.t = C.t;
        at.y.cv = C.y.cv;
        sayre "OSC7 C.t no c_s" if !exists C.c.s;
        at.c.s = C.c.s;
        at.sc = {%{C.sc}};
        delete at.sc->{$_} for qw'geo idly ml nspc path yspc';
    
    n Y =>36=><<''
        if (my $v = at.sc.J) { # J unifies -
            at.sc.J = v.name;
            .
            my $nV = v.El->{V.name}||{};
            my $rv = nV.rv || {LIES=>"from v.name"};
            .
            lv.do->{V.name} = $rv;
            at.V->{V.name} = rv.i;
        }
        if (C.c.root) { # / unifies  <
            lv.voso = 1;
            for my $ik (@{V.os}) {
                my $iv = V.lv->{$ik};
                do { sayre("Skip self in self") for 1..6 } && next
                    if C.sc.J && C.sc.J eq A.J;
                lv.do->{$ik} = $iv;
                at.V->{$ik} = iv.i;
            }
        }
    
    n Y =>38=><<''
        at.sc.geo = ki(at.sc.geo) if at.sc.geo;
        at.y = at.y.cv if keys %{at.y} == 1 && exists at.y.cv;
        # ^ to SlideEater decode array of y expressions, xotted together
        for my $up (qw'tag id') {
            at.c->{$up} = delete at.sc->{$up} if exists at.sc->{$up}
        }
        
Yeoodle: | # how is at (lv,at now & vl,ta then)
    u allovse
    n '','','%of:Sev'
    
    # is the other of this vector:
    n Y =>41=><<''
        if ('force') {
            at.c.el = 1;
            lv.force = 'el';
            lv.selfs = 1;
            lv.grab = [at.t, at.y, {el=>8}];
            lv.rmnsc = [at.t, at.y, {el=>9}];
            # ID makes possible to throw into the W
            #    (most J) tiniest specs of change
            # receiving with ID means most.J knows ID to Jpath (bottom up easy)
            #   also wants to know originating light cone 
            # - figure that once things on screen again!
            # maybe 8regate
        }
        
    n Y =>42=><<''
        for my $nk (qw't y c sc V') {
            my $v = $at->{$nk};
            my $o = $ta->{$nk};
            I.d&heq,$v,$o && next;
            Rw ACT $J $A $I $C $k $Y $V $at $ta $lv $vl $nk $v $o;
            # wants to be embedded A.t&A,3-4 per T.nk or so
            # ex flywheel arbiter more into T
        }
    
Yod: |
    u allovse
    n '','','%of:Sev'
    
    n Y =>42=><<''
        for my $nk (qw't y c sc V') {
            my $d;
            d.v = $at->{$nk};
            d.o = $ta->{$nk};
            I.d&heq,d.v,d.o && next;
            T.d->{$nk} = $d;
            if (ref d.v eq 'HASH') {
                my $wt = Rw wtfch $Jb:v $Yb:o;
                #my $nonnew = keys %{wt.gone} || keys %{wt.diff} || keys %{wt.still};
                for my $wk (qw'gone diff new still') {
                    for my $gk (sort keys %{$wt->{$wk}}) {
                        my $dd = {};
                        dd.v = $at->{$nk}->{$gk};
                        dd.o = $ta->{$nk}->{$gk};
                        d.T.d->{$gk} && die " C.t the $nk $gk ($v) was already...";
                        d.T.d->{$gk} = 
                            dd.T.d->{$wk} = $dd;
                    }
                }
            }
            else {
                my $wk = !$vl ? "new" : !exists $at->{$nk} ? "gone" : "diff";
                my $dd = {%$d};
                d.T.d.s =
                    dd.T.d->{$wk} = $dd;
            }
        }

    
    n Y =>48=><<''
        # pick T bones
    
allTdse: |
    return unless C.sc.Td;
    my $d;
    d.path = [split '/', C.sc.Td];
    d.onpa = [split '/', 'T/d'];
    d.patar = [split '/', 'nk/gk/wk'];
    d.caps = {map{$_=>1}split',',$_ for grep{$_}C.sc.Tdarge;
    C.sc.Ifs.Td = $d;
matchTd: |
    my $hy = {T=>$T};
    my $pas = sub { # pwin flexy passing tube
        my ($pin,$d) = @_;
        my $s = d.s;
        my $e = d.e;
        my @ks = $pin eq '*' ? sort keys %$s
            : exists $s->{$pin} ? $pin
            : ();
        map {
            my $dd;
            dd.e.k = $_;
            dd.s = $s->{$_};
            dd.d = d.d if d.d;
            push @in, $dd;
        } @ks
    };
    if (my $Ifs = D.sc.Ifs) {
        for my $k (keys %$Ifs) {
            my $p = $Ifs->{$k};
            my $d = $hy;
            my @in = $d;
            my $pi = 0;
            for my $pin (@{p.path}) {
                for my $pTn (@{p.onpa}) {
                    @in = map { $pas->($pTn, $_) } @in
                }
                @in = map {
                        _.od = _.d if _.d;
                        _.d = $_;
                        _.e.lk = p.patar->[$pi]||die"no idea what $pi is";
                    }
                    map { $pas->($pin, $_) } @in
                $pi++;
            }
            for my $d (@in) {
                # now inmost, .od leads above (without pTn inway)
                # and each d.e.lk calls it something $nk $gk and $wk
                my $arg;
                my $up = $d;
                
                while ($up) {
                    $arg->{up.e.lk} = up.e.k;
                    if (d.caps) { # read between the lines of $d
                        for my $k (grep{d.caps->{$_}}keys %$d) {
                            $arg->{$k} ||= $d->{$k};
                        }
                    }
                    $up = up.od;
                }
                # Z/D wad of multiplicity
                # D args $d and arg, $nk/$ov etc things plucked
                # they must stay present to later Ds as well, stored T.d path subtlates
                
                # 6 ^
                die wdump [$arg,$up];
                if (!T.noTd) {
                    #T.dd
                    # wants to be swimming with T.dd in future T.d ventures
                    # to share same $d (and any caps from upwards)
                    # and avoid less specific after more specific, or just avoid repeats
                    # shaky but index
                    # the fish is shaking but on the deck
                }
            }

        }
    }
Ydo: |
    u allovse
    # tee to 4 sc ^T.* to T looks compinkgk 6
    # this alternating data, which brings in middle terms
    # all T.d is a divable rhythm like:
    #   T.d.$nk (o/v of nk) .T.d.$gk (o/v of gk) .T.d.$wk (o/v of gk)
    # lives in pools and across pools, being beside it notes a kind of transience for it
    # for string nk the gk would be s, same o/v as nk, and also has wk
    # oseverato carte copies T.d to A.T.d 
    #     which AZ back into new T (usu most transient part)
    #     except for this shape of consciousness
    # ex to note Td acks, perhaps on T.d.*, $d, so it wanders
    # arf on anything we dont eventually understand in T.d, - total options tho
    # other flywheel stuff for lv.op button presses
    # wk = still is fine (usu)
    n Y =>4311=><<'',{Td=>'t/s/new'}
        lv.op.t = 1;
        
        
    n Y =>4312=><<'',{Td=>'y/s/new'}
        lv.op.y = 1;
    
    
    
    n Y =>4321=><<'',{Td=>'c/*/new'}
        die "how inject a c $gk" if $vl;
        lv.op.c->{$gk} = 9;
        
    n Y =>4321=><<'',{Td=>'c/*/gone'}
        die "how delete a c $gk";
        lv.op.c->{$gk} = 9;
    
    n Y =>4321=><<'',{Td=>'c/s/diff'}
        lv.pur.c->{$gk} = 1;
    
    # ^ should avoid v (matched paths)
    n Y =>4322=><<'',{Td=>'c/*/diff'}
        die "how to c dif $gk";
        lv.op.c->{$gk} = 9;
    
    
    
    n Y =>4331=><<'',{Td=>'sc/*/new'}
        lv.pur.sc->{$gk} = 1;
        
    n Y =>4331=><<'',{Td=>'sc/*/gone'}
        die "how delete a sc $gk";
        lv.op.sc->{$gk} = 9;
    
    n Y =>4331=><<'',{Td=>'sc/*/diff'}
        sayyl "C.t $nk $gk $wk:  ".slim(30,$v)." <--- ".slim(30,$o);
        lv.pur.sc->{$gk} = 1;
    
    
    
    # without being a match prepare the Vacuumosd iv/ov
    n Y =>434=><<'',{Td=>'V/*'}
        d.iv = lv.do->{$gk};
        d.ov = vl.do->{$gk};
        d.ov.i && (d.ov.i eq $o->{$gk} || warn "no ovi ogk  d.ov.i eq $o->{$gk}");
        T.noTd = 1;
    
    n Y =>4341=><<'',{Td=>'V/*/new',Tdarge=>'iv,ov'}
        # may like to grab the element before it
        # like a curve continuing
        lv.od.new->{$gk} = $iv;
    
    n Y =>4341=><<'',{Td=>'V/*/gone',Tdarge=>'iv,ov'}
        ov.rmnsc || die "no remin";
        !$iv || die "gone had iv";
        # ^ sc plumb its destruction
        # can void if our c reframes by implicitly clearing
        lv.od.go->{$gk} = $ov;
    
    n Y =>4341=><<'',{Td=>'V/*/diff',Tdarge=>'iv,ov'}
        if (iv.c eq ov.c) {
            iv.sc eq ov.sc && die "same c fluc sc $gk";
            my $in = @{iv.sc};
            my $out = @{ov.sc};
            if (@{iv.sc} > @{ov.sc}) {
                saybl "$talk GROWs" if J.V > 2;
                lv.od.gr->{$gk} = $iv;
            }
            else {
                warn "WTFF ".wdump 2,[$iv,$ov];
            }
        }
        else {
            saybl "$talk  REPLACES c";
            lv.od.over->{$gk} = $iv;
        }
    
    n Y =>4341=><<'',{Td=>'V/*/diff',Tdarge=>'iv,ov'}
        lv.od.ll->{$gk} = $iv;
    
Yeomp: | # lvigorta + write stuff on at
    u allovse
    n '','','%of:Sev'
    
    n Y =>52=><<''
        Rw sOMP $J $A $I $C $k $Y $V $at $ta $lv $vl;
notnonos: |
    n Y =>53=><<'',{rg=>'J,V,yk,yat,yta,ylv,yvl'}
        my $talk = "J.name OMP ".join"  ", ($vl?"vl":"**"),
            (map{"$_:".ki(1,$lv->{$_})}qw'pur op'), wdump 2, lv.od;
        say $talk if J.V > 2 && $vl && (lv.pur || lv.op || lv.od);
        .
        !$vl && !lv.op && die "unopposed to not-bfore";
        .
        my $ne = {};
        if (!lv.op) {
            for my $nk (keys %{lv.pur}) {
                my $sv = lv.pur->{$nk};
                if (ref $sv eq 'HASH') {
                    for my $ck (keys %$sv) {
                        $ne->{$nk}->{$ck} = $at->{$nk}->{$ck};
                    }
                }
                else {
                    ref $sv && die "wtf $sv";
                    $ne->{$nk} = $at->{$nk};
                }
            }
        }
        else {
            $ne = $at;
            # grab can also transplant inners for a minorish
            # not re-c but recreate element a move things in
            # while re-cing anything within that can't be grabbed
            # element rebuild may be crucial for undoing anything we cant undo
            # something may restate its entire c
            # including any inner c..sc tents
        }
        .
        if (lv.od) {
            Rw sVOD + $ne $talk;
        }
        .
        my $nn = sub { my $n=shift; [n.t, n.y||{}, n.c||{}, n.sc||{}] };
        if (lv.op) {
            # make sure z is full...
            lv.c = [$nn->($ne)];
            lv.sc = [];
        }
        elsif (keys %$ne) {
            die wdump [lv.op, $ne]  if lv.op;
            ne.t = at.t;
            ne.y = at.y;
            ne.c->{lv.force} = 3;
            .
            lv.c = vl.c || die"novlc";
            lv.sc = [@{vl.sc}, $nn->($ne)];
            # Rw doc 5 [lv.c,lv.sc];
            # the two pronged link
            # circuity internet
        }
        else {
            #sayyl "$talk unopposed" if J.V;
            lv.c = vl.c;
            lv.sc = vl.sc;
        }
        # but there is intended to wipe clean or just redo the surface
        # much more is liking to collapse the past into the future in degrees as the c fulls
        # pur and sc
        # handleable od
        lv.ma = ($vl?vl.ma:0)+1;
        lv.i = "lv.c ".@{lv.sc};

    
sOMP: |
    my $talk = "J.name OMP ".join"  ", ($vl?"vl":"**"),
        (map{"$_:".ki(1,$lv->{$_})}qw'pur op'), wdump 2, lv.od;
        
    say $talk if J.V > 2 && $vl && (lv.pur || lv.op || lv.od);
    
    !$vl && !lv.op && die "unopposed to not-bfore";
    
    my $ne = {};
    if (!lv.op) {
        for my $nk (keys %{lv.pur}) {
            my $sv = lv.pur->{$nk};
            if (ref $sv eq 'HASH') {
                for my $ck (keys %$sv) {
                    $ne->{$nk}->{$ck} = $at->{$nk}->{$ck};
                }
            }
            else {
                ref $sv && die "wtf $sv";
                $ne->{$nk} = $at->{$nk};
            }
        }
    }
    else {
        $ne = $at;
        # grab can also transplant inners for a minorish
        # not re-c but recreate element a move things in
        # while re-cing anything within that can't be grabbed
        # element rebuild may be crucial for undoing anything we cant undo
        # something may restate its entire c
        # including any inner c..sc tents
    }
    
    if (lv.od) {
        Rw sVOD + $ne $talk;
    }
    
    my $nn = sub { my $n=shift; [n.t, n.y||{}, n.c||{}, n.sc||{}] };
    if (lv.op) {
        # make sure z is full...
        lv.c = [$nn->($ne)];
        lv.sc = [];
    }
    elsif (keys %$ne) {
        die wdump [lv.op, $ne]  if lv.op;
        ne.t = at.t;
        ne.y = at.y;
        ne.c->{lv.force} = 3;
        
        lv.c = vl.c || die"novlc";
        lv.sc = [@{vl.sc}, $nn->($ne)];
        # Rw doc 5 [lv.c,lv.sc];
        # the two pronged link
        # circuity internet
    }
    else {
        #sayyl "$talk unopposed" if J.V;
        lv.c = vl.c;
        lv.sc = vl.sc;
    }
    # but there is intended to wipe clean or just redo the surface
    # much more is liking to collapse the past into the future in degrees as the c fulls
    # pur and sc
    # handleable od
    lv.ma = ($vl?vl.ma:0)+1;
    lv.i = "lv.c ".@{lv.sc};
sVOD: |
    my @each = lv.oso ? @{V.os} : sort keys %{lv.do};
    my $san = {map{$_=>1}keys %{lv.do}};
    
    my $ded = [];
    my $z = [];
    # occasionally wants to add/subtract from the thing
    # the whole sending rms vs moving the remainders
    # also if re-c desired soon, factor vortex
    if (my $go = lv.od.go) {
        for my $ea (sort keys %$go) {
            my $ov = $go->{$ea};
            ref ov.c || die "noovc";
            my $oov = vl.do->{$ea} if $vl;
            $ov eq $oov || die "difoov $ov, $oov";
            $san->{$ea} && die " $ea goes but still in do..";
            if (!ov.rmnsc) {
                lv.op.V->{$ea} = 1 && die " wtf";
            }
            push @$ded, ov.rmnsc;
        }
    }
    
    my $left;
    for my $ea (@each) {
        delete $san->{$ea};
        my $iv = lv.do->{$ea}||die;
        my $ov = vl.do->{$ea} if $vl;
        
        if (lv.od.new->{$ea}) {
            $ov && die "new had ov";
            if ($left && left.grab) {
                push @$z, left.grab if lv.od.ll->{left.k};
                # om lv.prepend(iv) until one
                # then last z/c:el:* gives iv.appendAfter(left)
                # chuck in the el:8 if we skip over anything
                # ie if left is od.ll this round...
                # can have no el:8 and switch everything else out
            }
            push @$z, grep{defined} @{iv.c}, @{iv.sc};
        }
        elsif (lv.od.gr->{$ea}) {
            $ov || die "novodo $ea";
            iv.c eq ov.c || die "wasn't satbv c";
            my $ray = Rw scd $rl:ov $rv:iv;
            #sayyl "gr $ea    ov.i     iv.i    ".ki $ray if J.V;
            
            push @$z, @{ray.z};
            
        }
        elsif (lv.od.over->{$ea}) {
            sayyl "OVER $ea";
            lv.selfs || die "no way to...";
            # el:1 will replace the old by t/y or something
            # chuck ids on everything?
            
            push @$z, grep{defined} @{iv.c}, @{iv.sc};
        }
        elsif (lv.od.ll->{$ea}) {
            #say "keep $ea" if J.V;
        }
        else {die "wtf $ea "}
        $left = $iv;
    }
    my @have = map { keys %{lv.od->{$_}} } grep {$_ ne "go"} keys %{lv.od};
    my $ha = {map{$_=>1}@have};
    delete $ha->{$_} for @each;
    die "difs".wdump $ha if keys %$ha;
    die "!!! forgot $_" for keys %$san;
    
    unshift @$z, @$ded if @$ded;
    
    @$z = () if C.sc.J && $J eq C.sc.J;
    
    ne.sc.z = $z if @$z;

