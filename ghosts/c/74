
Yeoodle: | # how is at (lv,at now & vl,ta then)
    u allovse
    n '','','%of:Sev'
    
    # is the other of this vector:
    n Y =>41=><<''
        if ('force') {
            at.c.el = 1;
            lv.force = 'el';
            lv.selfs = 1;
            lv.grab = [at.t, at.y, {el=>8}];
            lv.rmnsc = [at.t, at.y, {el=>9}];
            # ID makes possible to throw into the W
            #    (most J) tiniest specs of change
            # receiving with ID means most.J knows ID to Jpath (bottom up easy)
            #   also wants to know originating light cone 
            # - figure that once things on screen again!
            # maybe 8regate
        }
        
    n Y =>42=><<''
        for my $nk (qw't y c sc V') {
            my $v = $at->{$nk};
            my $o = $ta->{$nk};
            I.d&heq,$v,$o && next;
            Rw ACT $J $A $I $C $k $Y $V $at $ta $lv $vl $nk $v $o;
            # wants to be embedded A.t&A,3-4 per T.nk or so
            # ex flywheel arbiter more into T
        }
    
Yodness: |
    J.V = 1;
    n Yod =>W
    n Ydo =>W
    n YdoV =>W
    n Yex =>W
Yex: |
    u allacgts
    
    n ex =>''=>{s=><<''},{acgt=>'i,K,cv,av',nois=>'# c',code=>"Sev 1"}
        # was Rw SNat $A $C $G $T $I $i $K $cv;
        # baseism
        my $c = 0+("0.".$cv);
        my $Av = $av || A.cv;
        my $sp = $av ? " Flav $av (no A.cv)" : "";
        .
        my $talk = "A.talk: $K$sp $Av > $c --- C.t ";
        .
        my $aim = {$K=>1};
        if ($aim->{A.am}) {
            $aim->{$_} = 1 for @{A.Isl||[]};
            aim.I = 1;
        }
        .
        my $yv = {};
        # make K/cv/t -> cv/K/t
        for my $k (sort keys %$i) {
            my $ii = $i->{$k};
            .
            next if $k eq 'Ii';
            next if $k eq 'ooI';
            ref $ii eq 'HASH' || die "weird $k=$ii";
            .
            for my $vc (sort keys %$ii) {
                my $iii = $ii->{$vc};
                die'$k !0<$vc<1' unless $vc > 0 && $vc < 1;
                $yv->{$vc}->{$k} = $iii;
            }
        }
        .
        # do stuff
        my $vb; # in fractions
        for my $vc (sort keys %$yv) {
            my $is = $yv->{$vc};
            my $s = {};
            .
            next if $vc <= $Av && $vc != $c;
            next if $vc > $c;
            .
            if (0 && $K eq 'Sev') {
                saybl "We $K - $vb -> $vc  ".join', ',
                    map{"$_: ".@{A.mo.re->{$_}}} sort keys %{A.mo.re||{}};
            }
            if ($vb && $vc > $vb && (
                @{A.N} || @{A.mo.re->{$vb}||[]}
                )) {
                # sincing, wide order
                # various others want to be around for only some of the process...
                sayre "$vb -> $vc  bump, ". @{A.N} if A.J.V > 1;
                T.Z->{$vb} = 1;
                A.cv = $vb; # so we dont wind up to 6 on the way out of t
                return T.not = 1;
            }
            for my $k (sort keys %$is) {
                my $iii = $is->{$k};
                .
                next unless $aim->{$k} || (aim.I && A.Iso->{$k});
                .
                for my $ik (sort keys %$iii) {
                    my $D = $iii->{$ik};
                    .
                    if (my $nk = D.sc.nk) {
                        my $C = I.nF.C;
                        next if !exists $C->{$nk};
                        if (my $gk = D.sc.gk) {
                            next if !exists $C->{$nk}->{$gk};
                        }
                    }
                    my $act;
                    my $dont;
                    if (D.sc.acgt && D.sc.act) {
                        $act = 1;
                        # acgtsubs can be defined at any cv
                        # run themselves if act
                        # usu. one receiver (Ci) and the rest scheme
                        die "D.t .act gets... D.sc.act" if D.sc.act ne '1';
                        $dont = 1 if exists A.I->{D.t};
                    }
                    .
                    # schools of many fish
                    $vb ||= $vc if D.sc.v;
                    .
                    # TreeD
                    $s->{$k}->{$vc}->{$ik} = $D;
                    my $sep = $act ? "----" : ">>>>";
                    sayre "DElEE $talk $k $sep $vc  D.t D.y.cv  ".ki D.sc
                        if A.J.V > 2;
                    .
                    # way or acgt-setuping-way
                    unless ($dont) {
                        my $paw = join"_",'',$k,$vc,D.t;
                        $paw =~ s/\W//g;
                        Rw $paw $A $C $G $T $__D:D;
                    }
                    # most tiny ticks
                    # this ind is all flywheel
                    # it's a kind of unity that wants to be a block of code like this
                    # and #c
                    my @is = A.s;
                    my $utro;
                    if (D.sc.Ifs) {
                        @is = Rw matchTd $A $C $D $T;
                        utro.matchTd = 1;
                    }
                    if ($act) {
                        for $s (@is) {
                            D.sc.acgt eq 's'||die "nonacgts".ki $D;
                            exists A.I->{D.t}||die "acgtI D.t not up: ".ki A.I;
                            I.d&D.t,$s;
                            I.d&acted,$s if I.acted;
                            if ($utro) {
                                if (utro.matchTd) {
                                    unless (delete T.noTd) {
                                        s.d.od || die "matchd root: OOgie";
                                        s.d.od.s.T.m = 1;
                                    }
                                }
                                else { die"utrowhat ".ki $utro }
                            }
                            last if T.not || T.whack;
                        }
                    }
                    last if T.not || T.whack;
                }
                last if T.not || T.whack;
            }
            my $se = Rw TreeD $s $scby=gro
                if A.J.V > 1 && keys %$s;
            $c == 0.1 ? saygr $se : say $se if $se;
            .
            return if T.not;  # will &z, oseve
            return if delete T.whack;
        }
    
    # y
Yod: |
    u allovse
    n '','','%of:Sev'
    
    # overs Yeoodle
    n Y =>42=><<''
        for my $nk (qw't y c sc V') {
            my $v = $at->{$nk};
            my $o = $ta->{$nk};
            I.d&heq,$v,$o && next;
            my $d;
            d.v = $v;
            d.o = $o;
            T.d->{$nk} = $d;
            if (ref $v eq 'HASH') {
                my $wt = Rw wtfch $Jb:v $Yb:o;
                #my $nonnew = keys %{wt.gone} 
                #|| keys %{wt.diff} || keys %{wt.still};
                for my $wk (qw'gone diff new still') {
                    for my $gk (sort keys %{$wt->{$wk}}) {
                        my $dd = {};
                        dd.v = $at->{$nk}->{$gk};
                        dd.o = $ta->{$nk}->{$gk};
                        if ($wk eq 'new' && $nk eq 'V') {
                            dd.v || sayre "$nk $gk missing: ".wdump 5, $at;
                        }
                        d.T.d->{$gk} && die "C.t: $nk,$gk ($v) rep.";
                        d.T.d->{$gk} =
                            dd.T.d->{$wk} = $dd;
                            die wdump [$C,$d] if $wk eq 'still';
                    }
                }
            }
            else {
                my $wk = !$vl ? "new" : !exists $at->{$nk} ? "gone" : "diff";
                my $dd = {%$d};
                d.T.d.s =
                    dd.T.d->{$wk} = $dd;
            }
            sayyl "TDback $nk: ".wdump 7,$d;
        }
    
    n Y =>48=><<''
        # pick T bones
    
coiTd: |
    my $Q;
    Q.path = [split '/', C.sc.Td];
    die if @{Q.path} < 1;
    
    my $form = C.sc.Tdform || 'nk/gk/wk';
    Q.atar = [split '/', $form];
    @{Q.atar} = @{Q.atar}[0 .. (@{Q.path}-1)];
    
    Q.onpa = [split '/', 'T/d'];
    Q.caps = {map{$_=>1}split',',C.sc.Tdarge} if C.sc.Tdarge;
    # like rg but from $s
    C.sc.sr && die "already sr";
    C.sc.sr = join ',', grep{$_} d=>o=>v=>talk=> @{Q.atar}, sort keys %{Q.caps||{}};
    for my $sr (split ',', C.sc.sr) {
        die "mixo $sr" if $sr =~ /\W/;
        push @$ara, "    my \$".$sr." = s\.$sr;";
    }
    C.sc.Ifs.Td = $Q;
    
matchTd: |
    # ki/ok doesn't like $d (@in)
    my $hy = {T=>$T};
    my $pas = sub { # pwin flexy passing tube
        my ($pin,$d) = @_;
        my $s = d.s;
        my $e = d.e;
        my @ks = $pin eq '*' ? sort keys %$s
            : exists $s->{$pin} ? $pin
            : ();
        map {
            my $dd;
            dd.e.k = $_;
            dd.s = $s->{$_};
            dd.d = d.d if d.d;
            $dd;
        } @ks
    };
    my @is;
    if (my $Ifs = D.sc.Ifs) {
        for my $k (keys %$Ifs) {
            my $Q = $Ifs->{$k};
            my $d = $hy;
            my @in = {s=>$d};
            my $pi = 0;
            for my $pin (@{Q.path}) {
                for my $pTn (@{Q.onpa}) {
                    @in = map { $pas->($pTn, $_) } @in
                }
                @in = map { $pas->($pin, $_) } grep{defined} @in;
                @in = map {
                    if (_.od) { # nonroot pattern mutable (into/on/off origin s)
                        $_ = _.od.s.T.q->{_.e.k} ||= $_;
                    }
                    _.od ||= _.d if _.d;
                    _.d = $_;
                    _.e.lk = Q.atar->[$pi]||die"no idea what $pi is";
                    $_
                } grep{defined} @in;
                $pi++;
            }
            for my $d (@in) {
                # now inmost, .od leads above (without pTn inway)
                # and each d.e.lk calls it something $nk $gk and $wk
                    # and avoid less specific after more specific
                    # or just avoid repeats
                    #   
                    # shaky but index
                    # the fish is shaking but on the deck
                my $arg;
                if (keys %{d.s.T && d.s.T.q || {}}) {
                    sayre " D.t   @{Q.path}  went deeper before";#.wdump[$d,$arg,$Q];
                }
                
                my $up = $d;
                my $last = $up;
                my $i = 0;
                while ($up) {
                    $i++ > 8 && die "LAST WANDERS";
                    $arg->{up.e.lk} = up.e.k;
                    if (Q.caps) { # read between the lines of $d
                        for my $k (grep{Q.caps->{$_}}keys %{up.s}) {
                            $arg->{$k} ||= up.s->{$k};
                        }
                    }
                    $last = $up;
                    $up = up.od;
                    if ($up eq $last) {
                        sayre "D.t D.sc.Td  refers to itself as .od: ".wdump $last;
                        last;
                    }
                }
                
                arg.d = $d;
                for my $k (keys %{d.s}) {
                    next if $k eq 'T';
                    $arg->{$k} && die "Already $k arg of ".wdump[$d,$arg];
                    $arg->{$k} = d.s->{$k};
                }
                arg.talk = "D.t ($k:@{Q.path}) C.t C.y.cv: "
                    .join '/', map{$arg->{$_}} @{Q.atar};
                
                push @is, $arg;
                # Z/D wad of multiplicity
                # D args $d and arg, $nk/$ov etc things plucked
                # they must stay present to later Ds as well
                # stored T.d path subtlates
                # 6 ^
                sayre " D.t   @{Q.path}  ".ki $arg;#.wdump [arg.d.s,$arg,$d,$D];
            }

        }
    }
    @is
Ydo: |
    u allovse
    n '','','%of:Sev'
    
    # tee to 4 sc ^T.* to T looks compinkgk 6
    # this alternating data, which brings in middle terms
    # all T.d is a divable rhythm like:
    #   T.d.$nk (o/v of nk) .T.d.$gk (o/v of gk) .T.d.$wk (o/v of gk)
    # lives in pools and across pools, being beside it notes a kind of transience for it
    # for string nk the gk would be s, same o/v as nk, and also has wk
    # oseverato carte copies T.d to A.T.d 
    #     which AZ back into new T (usu most transient part)
    #     except for this shape of consciousness
    # ex to note Td acks, perhaps on T.d.*, $d, so it wanders
    # arf on anything we dont eventually understand in T.d, - total options tho
    # other flywheel stuff for lv.op button presses
    # wk = still is fine (usu)
    n Y =>4311=><<'',{Td=>'t/s/new'}
        lv.op.t = 1;
        
        
    n Y =>4312=><<'',{Td=>'y/s/new'}
        lv.op.y = 1;
    
    
    
    n Y =>4321=><<'',{Td=>'c/*/new'}
        die "how inject a c $gk" if $vl;
        lv.op2c->{$gk} = 9;
        
    n Y =>4321=><<'',{Td=>'c/*/gone'}
        die "how delete a c $gk";
        lv.op.c->{$gk} = 9;
    
    n Y =>4323=><<'',{Td=>'c/s/diff'}
        lv.pur.c->{$gk} = 1;
    
    # ^ should avoid v (matched paths)
    n Y =>4324=><<'',{Td=>'c/*/diff'}
        die "how to c dif $gk";
        lv.op.c->{$gk} = 9;
    
    
    
    n Y =>4331=><<'',{Td=>'sc/*/new'}
        lv.pur.sc->{$gk} = 1;
        
    n Y =>4332=><<'',{Td=>'sc/*/gone'}
        die "how delete a sc $gk";
        lv.op.sc->{$gk} = 9;
    
    n Y =>4333=><<'',{Td=>'sc/*/diff'}
        sayyl "C.t $nk $gk $wk:  ".slim(30,$v)." <--- ".slim(30,$o);
        lv.pur.sc->{$gk} = 1;
    
    
YdoV: |
    u allovse
    n '','','%of:Sev'
    
    # without being a match prepare the Vacuumosd iv/ov
    n Y =>434=><<'',{Td=>'V/*'}
        saybl "NO WHAT $talk". wdump 7, $d if $wk ne 'gone' && !d.v;
        d.iv = lv.do->{$gk};
        d.ov = vl.do->{$gk};
        d.ov.i && (d.ov.i eq $o->{$gk} || warn "no ovi ogk  d.ov.i eq $o->{$gk}");
        T.noTd = 1;
    
    n Y =>4341=><<'',{Td=>'V/*/new',Tdarge=>'iv,ov'}
        # may like to grab the element before it
        # like a curve continuing
        $iv || sayre("News cap no iv: ".wdump $s) && return;
        sayyl "$talk  ($iv) NEW!";
        lv.od.new->{$gk} = $iv;
    
    n Y =>4342=><<'',{Td=>'V/*/gone',Tdarge=>'iv,ov'}
        ov.rmnsc || die "no remin";
        !$iv || die "gone had iv";
        # ^ sc plumb its destruction
        # can void if our c reframes by implicitly clearing
        lv.od.go->{$gk} = $ov;
    
    n Y =>4343=><<'',{Td=>'V/*/diff',Tdarge=>'iv,ov'}
        if (iv.c eq ov.c) {
            iv.sc eq ov.sc && die "same c fluc sc $gk";
            my $in = @{iv.sc};
            my $out = @{ov.sc};
            if (@{iv.sc} > @{ov.sc}) {
                saybl "$talk GROWS" if J.V > 2;
                lv.od.gr->{$gk} = $iv;
            }
            else {
                warn "WTFF ".wdump 2,[$iv,$ov];
            }
        }
        else {
            saybl "$talk  REPLACES c";
            lv.od.over->{$gk} = $iv;
        }
    
    n Y =>4344=><<'',{Td=>'V/*/still',Tdarge=>'iv,ov'}
        say "Wegode: ".wdump 7, $d;
        lv.od.ll->{$gk} = $iv;
    

