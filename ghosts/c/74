
Yeoodle: | # how is at (lv,at now & vl,ta then)
    u allovse
    n '','','%of:Sev'
    
    # is the other of this vector:
    n Y =>41=><<''
        if ('force') {
            at.c.el = 1;
            lv.force = 'el';
            lv.selfs = 1;
            lv.grab = [at.t, at.y, {el=>8}];
            lv.rmnsc = [at.t, at.y, {el=>9}];
            # ID makes possible to throw into the W
            #    (most J) tiniest specs of change
            # receiving with ID means most.J knows ID to Jpath (bottom up easy)
            #   also wants to know originating light cone 
            # - figure that once things on screen again!
            # maybe 8regate
        }
        
    n Y =>42=><<''
        for my $nk (qw't y c sc V') {
            my $v = $at->{$nk};
            my $o = $ta->{$nk};
            I.d&heq,$v,$o && next;
            Rw ACT $J $A $I $C $k $Y $V $at $ta $lv $vl $nk $v $o;
            # wants to be embedded A.t&A,3-4 per T.nk or so
            # ex flywheel arbiter more into T
        }
    
Yod: |
    u allovse
    n '','','%of:Sev'
    
    # overs Yeoodle
    n Y =>42=><<''
        for my $nk (qw't y c sc V') {
            my $d;
            d.v = $at->{$nk};
            d.o = $ta->{$nk};
            I.d&heq,d.v,d.o && next;
            T.d->{$nk} = $d;
            if (ref d.v eq 'HASH') {
                my $wt = Rw wtfch $Jb:v $Yb:o;
                #my $nonnew = keys %{wt.gone} || keys %{wt.diff} || keys %{wt.still};
                for my $wk (qw'gone diff new still') {
                    for my $gk (sort keys %{$wt->{$wk}}) {
                        my $dd = {};
                        dd.v = $at->{$nk}->{$gk};
                        dd.o = $ta->{$nk}->{$gk};
                        d.T.d->{$gk} && die " C.t the $nk $gk ($v) was already...";
                        d.T.d->{$gk} =
                            dd.T.d->{$wk} = $dd;
                    }
                }
            }
            else {
                my $wk = !$vl ? "new" : !exists $at->{$nk} ? "gone" : "diff";
                my $dd = {%$d};
                d.T.d.s =
                    dd.T.d->{$wk} = $dd;
            }
        }
    
    n Y =>48=><<''
        # pick T bones
    
coiTd: |
    my $d;
    d.path = [split '/', C.sc.Td];
    die if @{d.path} < 1;
    
    my $form = C.sc.Tdform || 'nk/gk/wk';
    d.patar = [split '/', $form];
    @{d.patar} = @{d.patar}[0 .. (@{d.path}-1)];
    
    d.onpa = [split '/', 'T/d'];
    d.caps = {map{$_=>1}split',',$_} for grep{$_}C.sc.Tdarge;
    # like rg but from $s
    C.sc.sr && die "already sr";
    C.sc.sr = join ',', grep{$_} @{d.patar}, %{d.caps||{}};
    C.sc.Ifs.Td = $d;
matchTd: |
    my $hy = {T=>$T};
    my $pas = sub { # pwin flexy passing tube
        my ($pin,$d) = @_;
        my $s = d.s;
        my $e = d.e;
        my @ks = $pin eq '*' ? sort keys %$s
            : exists $s->{$pin} ? $pin
            : ();
        map {
            my $dd;
            dd.e.k = $_;
            dd.s = $s->{$_};
            dd.d = d.d if d.d;
            push @in, $dd;
        } @ks
    };
    if (my $Ifs = D.sc.Ifs) {
        for my $k (keys %$Ifs) {
            my $Q = $Ifs->{$k};
            my $d = $hy;
            my @in = $d;
            my $pi = 0;
            for my $pin (@{Q.path}) {
                for my $pTn (@{Q.onpa}) {
                    @in = map { $pas->($pTn, $_) } @in
                }
                @in = map {
                        if (_.d) { # nonroot pattern mutable
                            $_ = _.d.T.q->{_.e.k} ||= $_;
                        }
                        _.od = _.d if _.d;
                        _.d = $_;
                        _.e.lk = Q.patar->[$pi]||die"no idea what $pi is";
                        $_
                    }
                    map { $pas->($pin, $_) } @in;
                sayyl "$pin: Have - ".ki $_ for @in;
                $pi++;
            }
            for my $d (@in) {
                # now inmost, .od leads above (without pTn inway)
                # and each d.e.lk calls it something $nk $gk and $wk
                my $arg;
                my $up = $d;
                
                while ($up) {
                    $arg->{up.e.lk} = up.e.k;
                    if (Q.caps) { # read between the lines of $d
                        for my $k (grep{Q.caps->{$_}}keys %$d) {
                            $arg->{$k} ||= $d->{$k};
                        }
                    }
                    $up = up.od;
                }
                # Z/D wad of multiplicity
                # D args $d and arg, $nk/$ov etc things plucked
                # they must stay present to later Ds as well
                # stored T.d path subtlates
                # 6 ^
                die wdump [$arg,$up];
                if (!T.noTd) {
                    #T.dd
                    # wants to be swimming with T.dd in future T.d ventures
                    # to share same $d (and any caps from upwards)
                    # and avoid less specific after more specific
                    # or just avoid repeats
                    # shaky but index
                    # the fish is shaking but on the deck
                }
            }

        }
    }
Ydo: |
    u allovse
    # tee to 4 sc ^T.* to T looks compinkgk 6
    # this alternating data, which brings in middle terms
    # all T.d is a divable rhythm like:
    #   T.d.$nk (o/v of nk) .T.d.$gk (o/v of gk) .T.d.$wk (o/v of gk)
    # lives in pools and across pools, being beside it notes a kind of transience for it
    # for string nk the gk would be s, same o/v as nk, and also has wk
    # oseverato carte copies T.d to A.T.d 
    #     which AZ back into new T (usu most transient part)
    #     except for this shape of consciousness
    # ex to note Td acks, perhaps on T.d.*, $d, so it wanders
    # arf on anything we dont eventually understand in T.d, - total options tho
    # other flywheel stuff for lv.op button presses
    # wk = still is fine (usu)
    n Y =>4311=><<'',{Td=>'t/s/new'}
        lv.op.t = 1;
        
        
    n Y =>4312=><<'',{Td=>'y/s/new'}
        lv.op.y = 1;
    
    
    
    n Y =>4321=><<'',{Td=>'c/*/new'}
        die "how inject a c $gk" if $vl;
        lv.op2c->{$gk} = 9;
        
    n Y =>4321=><<'',{Td=>'c/*/gone'}
        die "how delete a c $gk";
        lv.op.c->{$gk} = 9;
    
    n Y =>4323=><<'',{Td=>'c/s/diff'}
        lv.pur.c->{$gk} = 1;
    
    # ^ should avoid v (matched paths)
    n Y =>4324=><<'',{Td=>'c/*/diff'}
        die "how to c dif $gk";
        lv.op.c->{$gk} = 9;
    
    
    
    n Y =>4331=><<'',{Td=>'sc/*/new'}
        lv.pur.sc->{$gk} = 1;
        
    n Y =>4332=><<'',{Td=>'sc/*/gone'}
        die "how delete a sc $gk";
        lv.op.sc->{$gk} = 9;
    
    n Y =>4333=><<'',{Td=>'sc/*/diff'}
        sayyl "C.t $nk $gk $wk:  ".slim(30,$v)." <--- ".slim(30,$o);
        lv.pur.sc->{$gk} = 1;
    
    
    
    # without being a match prepare the Vacuumosd iv/ov
    n Y =>434=><<'',{Td=>'V/*'}
        d.iv = lv.do->{$gk};
        d.ov = vl.do->{$gk};
        d.ov.i && (d.ov.i eq $o->{$gk} || warn "no ovi ogk  d.ov.i eq $o->{$gk}");
        T.noTd = 1;
    
    n Y =>4341=><<'',{Td=>'V/*/new',Tdarge=>'iv,ov'}
        # may like to grab the element before it
        # like a curve continuing
        lv.od.new->{$gk} = $iv;
    
    n Y =>4342=><<'',{Td=>'V/*/gone',Tdarge=>'iv,ov'}
        ov.rmnsc || die "no remin";
        !$iv || die "gone had iv";
        # ^ sc plumb its destruction
        # can void if our c reframes by implicitly clearing
        lv.od.go->{$gk} = $ov;
    
    n Y =>4343=><<'',{Td=>'V/*/diff',Tdarge=>'iv,ov'}
        if (iv.c eq ov.c) {
            iv.sc eq ov.sc && die "same c fluc sc $gk";
            my $in = @{iv.sc};
            my $out = @{ov.sc};
            if (@{iv.sc} > @{ov.sc}) {
                saybl "$talk GROWs" if J.V > 2;
                lv.od.gr->{$gk} = $iv;
            }
            else {
                warn "WTFF ".wdump 2,[$iv,$ov];
            }
        }
        else {
            saybl "$talk  REPLACES c";
            lv.od.over->{$gk} = $iv;
        }
    
    n Y =>4344=><<'',{Td=>'V/*/diff',Tdarge=>'iv,ov'}
        lv.od.ll->{$gk} = $iv;
    
