
Yodness: |
    J.V = 1;
    n Yod =>W
    n Ydo =>W
    n YdoV =>W
    # edub:
    n Yex =>W
    n Yools =>W
Yeoodle: | # <^ gone how is at 
    u allovse
    n '','','%of:Sev'
    
    # like actual
    n acttle =>42=><<''
        for my $nk (qw't y c sc V') {
            my $v = $at->{$nk};
            my $o = $ta->{$nk};
            I.d&heq,$v,$o && next;
            Rw ACT $J $A $I $C $k $Y $V $at $ta $lv $vl $nk $v $o;
            # wants to be embedded A.t&A,3-4 per T.nk or so
            # ex flywheel arbiter more into T
        }
    
Yod: |
    u allovse
    n '','','%of:Sev'
    
    n mkTd =>42=><<''
        for my $nk (qw't y c sc V') {
            my $v = $at->{$nk};
            my $o = $ta->{$nk};
            I.d&heq,$v,$o && next;
            my $d;
            d.v = $v;
            d.o = $o;
            if (ref $v eq 'HASH') {
                my $wt = Rw wtfch $Jb:v $Yb:o;
                for my $wk (qw'gone diff new still') {
                    for my $gk (sort keys %{$wt->{$wk}}) {
                        my $dd = {};
                        dd.v = $at->{$nk}->{$gk};
                        dd.o = $ta->{$nk}->{$gk};
                        d.T.d->{$gk} && die "C.t: $nk,$gk ($v) rep.";
                        d.T.d->{$gk} =
                            dd.T.d->{$wk} = $dd;
                    }
                }
            }
            else {
                my $wk = !$vl ? "new"
                    : !exists $at->{$nk} ? "gone"
                    : "diff";
                my $dd = {%$d};
                d.T.d.s =
                    dd.T.d->{$wk} = $dd;
            }
            T.d->{$nk} = $d;
        }


    n doTd =>48=><<''
        # pick T bones, dot Is
        # a 9 for the Td (ill 8) consciousness rendezvou
        for my $nk (sort keys %{T.d}) {
            my $d = T.d->{$nk};
            for my $gk (sort keys %{d.T.d}) {
                my $dd = d.T.d->{$gk};
                if (dd.T.m) {
                    say "Answers  $nk $gk";
                }
                elsif (dd.T.q) {
                    say "probly $nk $gk";
                }
                else {
                    sayre "Unclear $nk $gk:  ". ki $dd;
                }
            }
        }
        delete T.d;
    
Ydo: |
    u allovse
    n '','','%of:Sev'
    # togethered with force=el or so
    # tee to 4 sc ^T.* to T looks compinkgk 6
    # this alternating data, which brings in middle terms
    # all T.d is a divable rhythm like:
    #   T.d.$nk (o/v of nk) .T.d.$gk (o/v of gk) .T.d.$wk (o/v of gk)
    # lives in pools and across pools, being beside it notes a kind of transience for it
    # for string nk the gk would be s, same o/v as nk, and also has wk
    # oseverato carte copies T.d to A.T.d 
    #     which AZ back into new T (usu most transient part)
    #     except for this shape of consciousness
    # ex to note Td acks, perhaps on T.d.*, $d, so it wanders
    # arf on anything we dont eventually understand in T.d, - total options tho
    # other flywheel stuff for lv.op button presses
    # wk = still is fine (usu)
    
    n tsnew =>4311=><<'',{Td=>'t/s/new'}
        lv.op.t = 1;
    
    n ysnew =>4312=><<'',{Td=>'y/s/new'}
        lv.op.y = 1;
    
    
    
    n cnew =>4321=><<'',{Td=>'c/*/new'}
        die "how inject a c $gk" if $vl;
        lv.op.c->{$gk} = 9;
        
    n cgone =>4321=><<'',{Td=>'c/*/gone'}
        die "how delete a c $gk";
        lv.op.c->{$gk} = 9;
    
    n csdiff =>4323=><<'',{Td=>'c/s/diff'}
        lv.pur.c->{$gk} = 1;
    
    # ^ should avoid v (matched paths)
    n cdiff =>4324=><<'',{Td=>'c/*/diff'}
        warn "how to c dif $gk".slim(30,$v)." <--- ".slim(30,$o);
        lv.op.c->{$gk} = 9;
    
    
    
    n scnew =>4331=><<'',{Td=>'sc/*/new'}
        lv.pur.sc->{$gk} = 1;
        
    n scgone =>4332=><<'',{Td=>'sc/*/gone'}
        die "how delete a sc $gk";
        lv.op.sc->{$gk} = 9;
    
    n scdiff =>4333=><<'',{Td=>'sc/*/diff'}
        sayyl "C.t $nk $gk $wk: ".slim(30,$v)." <--- ".slim(30,$o);
        saybl "YEP";
        lv.pur.sc->{$gk} = 1;
    
    
YdoV: |
    u allovse
    n '','','%of:Sev'
    
    # without being a match prepare the Vacuumosd iv/ov
    n Vsup =>434=><<'',{Td=>'V/*/*'}
        d.iv = lv.do->{$gk};
        d.ov = vl.do->{$gk};
        d.ov && d.ov.i && (d.ov.i eq $o || warn "no ovi ogk  d.ov.i eq $o");
        T.noTd = 1;
    
    n Vnew =>4341=><<'',{Td=>'V/*/new',Tdarge=>'iv,ov'}
        saybl "$talk           s.d   ov";
        # may like to grab the element before it
        # like a curve continuing
        $iv || sayre("News cap no iv: ".wdump $s) && return;
        lv.od.new->{$gk} = $iv;
    
    n Vgone =>4342=><<'',{Td=>'V/*/gone',Tdarge=>'iv,ov'}
        ov.rmnsc || die "no remin";
        !$iv || die "gone had iv";
        # ^ sc plumb its destruction
        # can void if our c reframes by implicitly clearing
        lv.od.go->{$gk} = $ov;
    
    n Vdiff =>4343=><<'',{Td=>'V/*/diff',Tdarge=>'iv,ov'}
        if (iv.c eq ov.c) {
            iv.sc eq ov.sc && do {
                sayre "SAME FLUC SC $gk";
                die "same c fluc sc $gk";
            };
            my $in = @{iv.sc};
            my $out = @{ov.sc};
            if (@{iv.sc} > @{ov.sc}) {
                saybl "$talk GROWS" if J.V > 2;
                lv.od.gr->{$gk} = $iv;
            }
            else {
                warn "WTFF ".wdump 2,[$iv,$ov];
            }
        }
        else {
            saybl "$talk  REPLACES c";
            lv.od.over->{$gk} = $iv;
        }
    
    n Vstill =>4344=><<'',{Td=>'V/*/still',Tdarge=>'iv,ov'}
        say "Wegode: ".wdump 2, $d;
        lv.od.ll->{$gk} = $iv;
    

