




timery: |
    # n ^-re should mean n C.t."-re"
    n timery_re => 2 => {s=><<''},{code=>'J 42'}
        if (J.most.J eq $J) {
            # J.most.A could coord 8ish stuff. allele towerish...
            J.A.timery = {};
        }
    
    n timery_do => 7 => {s=><<''},{code=>'T 9'}
        if (my $ti = J.most.J.A.timery) {
            ti.t->{J.name} = $sol;
            $ti->{$sol}++;
            if (J.name eq 'Wkcs') {
                say "Wkcs: ". k2 {w=>{W=>$ti}};
            }
        }
allcode: |
    n 'make sc_code=1 if no'=>2,{s=><<''},{code=>'In 51'}
        if (!exists C.sc.code) {
            C.sc.code = 1;
        }
onlycode: |
    n 'skip if no sc_code'=>2,{s=><<''},{code=>'In 31'}
        if (!exists C.sc.code) {
            C.sc.code = 1;
        }
concatco: |
    n 'pool lang spines to s (^) unifying arms as surface res goes, except sc_fr=musts'=>7=>{s=><<''}
        # another frequency to this
        # tune in this into the space
        # get the layers of music to inter
        # C and D stuff
        
    
Ein: |
    u allcode
    n args=>1=>{s=><<''}
        my $N = ar.N||ar.C;
        $N = [$N] if ref $N ne 'ARRAY';
    
    n In=>2=>{s=><<''},{code=>'^'}
        my $A = Rw ready;
        A.N = $N;
        A.ti&3||return;
    
    # pi lays out in tiles
    
    n fl=>22=>{s=><<''}
        A.fl = ar.fl || {};
    n M=>24=>{s=><<''}
        A.M = [];
        
    n bangC=>26=>{s=><<''},{fr=>'musts'}; 
        aft {
            $@||return;
            $@ = "C: ".ki(I.nF.C)."\n$@";
        };
       
    # 2821:      keys arrive as characters already:
    # prep A for A (I), J-sessioned etc stuff
    # is literal G spacer, index jointed bunch of code to check out from w
    # some comp could expectorate lots charstream rhythms ^
    # Z flow?
    # or we could do on a stick,
    # so its MZ junk dont linger in this stream
    # ie always flow outwards the sc filtery stuff.
    while (@{A.N}) { #
        my $s = shift @{A.N};
        my $C = {};
        my $T = {};
        T.oM = [];
        
        I.d&n,$A,$C,$G,$T;
        
        I.d&time
        I.d&Ci,$s;
        
        I.d&z && next if T.not;
        
        # elabourate C,
        for my $k (keys %{A.fl}) {
            my $v = A.fl->{$k};
            Rw ym/$k $A $C $n:C $v $G $T;
        }
        
        I.d&Cr,$s;
         
        die "not: ".wdump 4,[$N, $C]
           if !ref C.y || !C.y || !defined C.t;
         
        push @{T.oM}, $C;
        
        I.d&z;
    }
    
    my $M = ar.M;
    if ($M) {
        push @$M, @{A.M}
    }
    elsif ($J) {
        map {
           Rw mani + $J $C:_
        } @{A.M}
    } else {
        die "noJM";
    }
     
ready: |
    
a4ready: |
    my $I = {};
    Rw I_Din $I;
    Rw C_E $I;
    Rw C_C $I;
    $I;
C_E: |
    I.accept = sub {
        my ($A,$C,$G,$T,$s) = @_;
        
        if (!ref $s) {
            die "string: $s";
        }
        elsif (ref $s eq 'ARRAY') {
            if (@$s == 1) {
                my ($s) = @$s;
                ref $s && die "1striong: ".wdump $s;
                I.d&4string,$s
            }
            else {
                I.d&4real,$s
            }
        }
        elsif (ref $s eq 'HASH') {
           s.MZ ? I.d&MZu,s.MZ
           : s.EZ ? I.d&MZu,s.EZ
           : s.WZ ? I.d&MZu,s.WZ
           : die 'hash: '.wdump($s);
        }
        else { die "mmtype:$s" }
    };
C_C: |
    I.accept = sub { # coinsciousness accept, v 1-2
        my ($A,$C,$G,$T,$D) = @_;
        
        return T.next = 1 unless D.c.any || I.d&wanteD,$D;
    };
    I.wanteD = sub {
        my ($A,$C,$G,$T,$D) = @_;
        D.c.nk && exists $C->{D.c.nk} && exists $C->{D.c.nk}->{D.c.gk}
    };
    I.extend = sub {
        my ($A,$C,$G,$T,$s,$c) = @_;
        while (my($k,$v) = each %$c) {
            $s->{$k} = ref $v ? {%{$s->{$k}||{}}, %$v} : $v;
        }
    };
At4: |
    $C||die;
    my $A = {};
    A.J = $J;
    A.C = $C;
    A.I = Rw a4ready;
    A.is = A.M = [];
    $A;
I_4: | # is a 4d join! something n'd in, certain conditions already from 6...
     # whatever is high in the plain is coming at us
     # make pool, synth space, want arches
     # fork & rejoin to exciting place
     # the valley, what it means to be here in here YIN
     my $A = Rw At4;
     # ^ DESCRIBE how we're in here to
     # also the executablur
     # if something wants to mess with itself when...
     A.note = {};
     A.note.not = sub {
         my ($nt,$k) = @_;
         A.note.>$nt.>$k = 1;
     };
     A.seen = sub {
           my ($ct) = @_;
           ct.t_k eq "c" && A.note.not&c,ct.t;
     };
     # all thoughts are prayed to some beast
     # acquire Y personality:
     A.y&upto;
     #à¶¬
     # 2.8
     my $CC = $C;
     @{A.is}||die'nois'.wdump[$C,$A];
     for my $C (@{A.is}) { # THE TIR drop at hands
           my $A = {%$A};
           A.note = {};
           A.C = $C;
           C.c || die;
           C.y.cv || die "no cv".k2 $C;
           C.r = join "\t", C.t, (C.y.cv+0);
           C.sc = {%{C.sc||{}}}; # ?
           
           # 7.9
           C.r = join "\t", C.t, (C.y.cv+0);
           my $oJ = $J;
           my $J = C.y.o && C.y.o.J || $oJ;
           if (J.V) {
           say "MOD COMPLETE J.name     ->>>   C.t C.y.cv  ".k2(C.c)
           ."                     ".k2(C.sc);
           }
           Rw jamsc $J $oJ $C $s:C.c.s $sc:C.sc;
     }
     # 9
     return $A
oJ4: | # J.A remains, A transitory  - A.time is to couple it like I.in
    J.A ||= {first=>hitime()};
    # everytime stuff:
    #map { sayyl "A.J.name  vs J.name vs J.iter" } 1..3 if rand 9 > 8;
    
    # dep
    if (exists C.sc.pi) {
        die if J.Jiter ne A.J;
        die if J.most.J eq $J;
    }
    else {
        die if J.most.J ne $J;
    }
    
    if (C.c.time) {
        warn "CTIOME".ki $C;
        A.ztime = delete C.c.time;
    }
    A.ztime ||= 6;
    
    if (C.sc.pi) {
        J.A.d = J.Jiter.A.d + 1;
        J.ind = join '  ', ('') x J.A.d;
        J.name = "J.A.d . C.c.pi*C.t";
        J.d = J.C = $C;
        J.r = C.t."\t".C.y.cv;
        J.bz->("/\t0.9" => "y");
        A.time = sub {
             my($JJ,$q) = @_;
             A.ztime >= $q || do {
                 die "J.name  ---- JJ.name     A.ztime quuuuuu $q";
                 0
             };
        };
    }
    else {
        sayyl "Fo 4 A time A: $A   vs J.A " if J.name eq 'Eosse';
        A.time = sub {
             my($JJ,$q) = @_;
             A.ztime >= $q || do {
                 sayre "COMB J.name --- le-- JJ.name      A.ztime < $q";
                 A.jr&vv,$q;
                 0
             };
        };
    }
    
oJ42: |
    my @mis = grep{!A.note.c->{$_}}keys %{C.c};
    @mis=grep{$_ ne'J'}@mis;
    if (@mis) {
        my $cm;
        $cm->{$_} = C.c->{$_} for @mis;
        sayyl "Spesh J.name :  ".ki $cm unless J.yt.quiet;
        A.preg = $cm;
        A.ztime = 9;
    }
    
oJ43: | # the pull down
    J.A.in = $G->gip(J.Jiter.A.in, C.t)||{} if J.Jiter;
    
oC43: | # maniC pulls down travel # comep from aj compi
    if (my $c = $G->gip(A.J.A.in, C.t)) { 
        $c = c._ || return;
        say "C.t in: ".wdump $c if !A.J.yt.quiet;
        if (c.D) {
            c.D->($C);
        }
        elsif (grep {exists $c->{$_}} qw{t y c sc}) {
            g.extend->($C, $c);
        }
        else {
            die "howto ".ki $c;
        }
    }

