




timery: |
    # n ^-re should mean n C.t."-re"
    n timery_re => 2 => {s=><<''},{code=>'J 42'}
        if (J.most.J eq $J) {
            # J.most.A could coord 8ish stuff. allele towerish...
            J.A.timery = {};
        }
    
    n timery_do => 7 => {s=><<''},{code=>'T 9'}
        if (my $ti = J.most.J.A.timery) {
            ti.t->{J.name} = $sol;
            $ti->{$sol}++;
            if (J.name eq 'Wkcs') {
                say "Wkcs: ". k2 {w=>{W=>$ti}};
            }
        }
allcode: |
    n 'allarecode=1'=>2,{s=><<''},{code=>'In 42'}
        C.sc.code = 1 if !exists C.sc.code;
        sayyl "Was allcode! C.t";
allacgts: |
    n allcode=>''=>{W=>'allcode'}
    n 'allareacgt=s'=>2,{s=><<''},{code=>'In 42'}
        C.sc.acgt = 's' if !exists C.sc.acgt;
        sayyl "Was acgt! C.t";
onlycode: |
    n 'skip if no sc_code'=>2,{s=><<''},{code=>'In 31'}
        T.last = 1 unless C.sc.code;
Ein: |
    u allcode
    
    # canopy
    n args=>1=>{s=><<''}
        my $N = ar.N||ar.C;
        $N = [$N] if ref $N ne 'ARRAY';
        my $I = Rw already;
        
    # pi lays out in tiles
    
    
    n Einen=>24=>{s=><<''},{code=>'^'}
        my $A;
        A.N = [@$N];
        A.I = $I;
        A.J = $J;
        A.fl = ar.fl || {};
        A.M = [];
        A.am = 'In';
    
    n bangC=>26=>{s=><<''}
        aft {
            $@||return;
            my $m = "J: J.name J.le.name";
            $m .= "\nC: ".ki I.nF.C;
            $m .= "\ns: ".wdump 3, $N unless length $m > 20;
            $@ = "$m\n$@";
        };
    
    n loop=>3=>{s=><<''}
        while (@{A.N}) { #
            my $s = shift @{A.N};
            my $C = {};
            my $T = {};
            my $A = {%$A};
            T.oM = [];
            I.d&n,$A,$C,$G,$T;
            I.d&An;
            I.d&Ci,$s;
            I.d&z && next if T.not;
            # elabourate C,
            for my $k (sort keys %{A.fl}) {
                my $v = A.fl->{$k};
                $k = $2 if $k =~ /^(\d+) (.+)$/;
                Rw ym/$k $I $J $A $C $n:C $v $G $T;
            }
            A.t&42;
            I.d&Cr,$s;
            die "not: ".wdump 4,[$N, $C]
               if !ref C.y || !C.y || !defined C.t;
            push @{T.oM}, $C;
            I.d&z;
        }
    
    n l=>7=>{s=><<''}
        my $M = ar.M;
        if ($M) {
            push @$M, @{A.M}
        }
        elsif ($J) {
            map {
               Rw mani + $J $C:_
            } @{A.M}
        } else {
            die "noJM";
        }
    
    #
ready: |
    # F says how to make an A for it
    # then A.t&3 etc moves time forward, ore return is crux slot craft
    # return @$_ for A.t&3;
    # so we can hijack Ein by the something
    # and want to inject a tiny bit of code in this one circumstance
    # joins up by whether its there at all (u vic)
    # and what code=>thing is referring into... known at utime by Athing
    # all tumbling down F right behind ...
    
    # define how to throw sheets of language
    # do zis first stuff...
    # and and...
    # how cached waveforms W together as they get further down
    # the users
ym/doex: |
    I.d&extend,$C,$v;
At4: |
    $C||die;
    my $A = {};
    A.J = $J;
    A.C = $C;
    A.I = Rw already;
    A.is = A.M = [];
    $A;
I_4: | # is a 4d join! something n'd in, certain conditions already from 6...
     # whatever is high in the plain is coming at us
     # worked up to via aj/In jig, or T huck d&n&er
     
     # make pool, synth space, want arches
     # fork & rejoin to exciting place
     # the valley, what it means to be here in here YIN
     my $A = Rw At4;
     # ^ DESCRIBE how we're in here to
     # also the executablur
     # if something wants to mess with itself when...
     A.note = {};
     A.note.not = sub {
         my ($nt,$k) = @_;
         A.note.>$nt.>$k = 1;
     };
     A.seen = sub {
           my ($ct) = @_;
           ct.t_k eq "c" && A.note.not&c,ct.t;
     };
     # all thoughts are prayed to some beast
     # acquire Y personality:
     A.y&upto;
     #à¶¬
     # 2.8
     my $CC = $C;
     @{A.is}||die'nois'.wdump[$C,$A];
     for my $C (@{A.is}) { # THE TIR drop at hands
           my $A = {%$A};
           A.note = {};
           A.C = $C;
           C.c || die;
           C.y.cv || die "no cv".k2 $C;
           C.r = join "\t", C.t, (C.y.cv+0);
           C.sc = {%{C.sc||{}}}; # ?
           
           # 7.9
           C.r = join "\t", C.t, (C.y.cv+0);
           my $oJ = $J;
           my $J = C.y.o && C.y.o.J || $oJ;
           if (J.V) {
           say "MOD COMPLETE J.name     ->>>   C.t C.y.cv  ".k2(C.c)
           ."                     ".k2(C.sc);
           }
           Rw jamsc $J $oJ $C $s:C.c.s $sc:C.sc;
     }
     # 9
     return $A
oJ4: | # J.A remains, A transitory  - A.time is to couple it like I.in
    J.A ||= {first=>hitime()};
    # everytime stuff:
    #map { sayyl "A.J.name  vs J.name vs J.iter" } 1..3 if rand 9 > 8;
    
    # dep
    if (exists C.sc.pi) {
        die if J.Jiter ne A.J;
        die if J.most.J eq $J;
    }
    else {
        die if J.most.J ne $J;
    }
    
    if (C.c.time) {
        warn "CTIOME".ki $C;
        A.ztime = delete C.c.time;
    }
    A.ztime ||= 6;
    
    if (C.sc.pi) {
        J.A.d = J.Jiter.A.d + 1;
        J.ind = join '  ', ('') x J.A.d;
        J.name = "J.A.d . C.c.pi*C.t";
        J.d = J.C = $C;
        J.r = C.t."\t".C.y.cv;
        J.bz->("/\t0.9" => "y");
        A.time = sub {
             my($JJ,$q) = @_;
             A.ztime >= $q || do {
                 die "J.name  ---- JJ.name     A.ztime quuuuuu $q";
                 0
             };
        };
    }
    else {
        sayyl "Fo 4 A time A: $A   vs J.A " if J.name eq 'Eosse';
        A.time = sub {
             my($JJ,$q) = @_;
             A.ztime >= $q || do {
                 sayre "COMB J.name --- le-- JJ.name      A.ztime < $q";
                 A.jr&vv,$q;
                 0
             };
        };
    }
    
oJ42: |
    my @mis = grep{!A.note.c->{$_}}keys %{C.c};
    @mis=grep{$_ ne'J'}@mis;
    if (@mis) {
        my $cm;
        $cm->{$_} = C.c->{$_} for @mis;
        sayyl "Spesh J.name :  ".ki $cm unless J.yt.quiet;
        A.preg = $cm;
        A.ztime = 9;
    }
    
oJ43: | # the pull down
    J.A.in = $G->gip(J.Jiter.A.in, C.t)||{} if J.Jiter;
    
oC43: | # maniC pulls down travel # comep from aj compi
    if (my $c = $G->gip(A.J.A.in, C.t)) { 
        $c = c._ || return;
        say "C.t in: ".wdump $c if !A.J.yt.quiet;
        if (c.D) {
            c.D->($C);
        }
        elsif (grep {exists $c->{$_}} qw{t y c sc}) {
            g.extend->($C, $c);
        }
        else {
            die "howto ".ki $c;
        }
    }

