allcurve: |
    # mention the oo-able profce
    u allacgts
    # so Cur 9 will state that its a curve, MZomewhere will unravel it on oo
    # oo is potentially abstractable unity, esp where things c their time
    n Dooving=>6=>{s=><<''},{code=>'In 6'}
        sayyl "Cuuuuurvix! ".ki $C;
        #A.t&63 && say "You zero! ".ki$C if C.y.cv == 0;
        # curve instructions t=>s is flowing in down cv
        # draw out atoms, x=y=0 r=0 begins
    
    #y
allcode: |
    n 'allarecode1'=>2,{s=><<''},{code=>'In 42'}
        C.sc.code = 1 if !exists C.sc.code;
allacgts: |
    n allcode =>W
    n 'allareacgt=s'=>2,{s=><<''},{code=>'In 42'}
        C.sc.acgt = 's' if !exists C.sc.acgt;
allact: |
    n allacgts =>W
    n 'allareact=1'=>2,{s=><<''},{code=>'In 42'}
        C.sc.act = 1 if !exists C.sc.act;
allvy: |
    n allact =>W
    n 'allarev=y'=>2,{s=><<''},{code=>'In 42'}
        return if C.sc.nov;
        C.sc.v = 'y'.C.sc.v;
allvc: |
    n allact =>W
    n 'allarev=c'=>2,{s=><<''},{code=>'In 422'}
        return if C.sc.nov;
        C.sc.v = 'c'.C.sc.v;
allvse: |
    n allvc =>W
    n 'allvse'=>2,{s=><<''},{code=>'In 419'}
        if (C.c.of) {
            A.J.A.vse.of = C.c.of;
            return T.not = 1;
        }
        C.sc.code ||= do {
            my $cv = C.y.cv;
            $cv =~ s/^0\.//;
            (A.J.A.vse.of||C.t)." $cv"
        };
        C.sc.v ||= C.t unless exists C.sc.v;
        (my $cv = C.y.cv) =~ s/^0\.//;
        $cv = $1 if !$cv && C.sc.code =~ /^\w+ (\d+)$/;
        $cv||die"no0 C.y.cv  ".ki $C;
        C.t .= "_$cv";
allacgt: |
    n allcode=>''=>{W=>'allcode'}
    n 'allareacgt=1'=>2,{s=><<''},{code=>'In 42'}
        #
        C.sc.acgt = '1' if !exists C.sc.acgt;
onlycode: |
    n 'skip if no sc_code'=>2,{s=><<''},{code=>'In 31'}
        T.last = 1 unless C.sc.code;
babsubrip: |
    my $l = oA.subline;
    $l -= 4; # sub head lines
    my @l = split "\n", D.bab;
    my $st = $l[$l];
    if ($st =~ /<<['"](\w*)['"]/) {
        my $mark = $1;
        $st =~ /^\S/ || die "first line start space: $st";
        $l++;
        my $ind;
        my @up;
        while (1) {
            my $s = $l[$l];
            last unless $s =~ /\S/ || $mark;
            last if $mark && $s =~ /^$mark$/;
            $ind = $1 if !defined $ind
                && ($s =~ /^(    ).*\S+/ || die "no start ind $s");
            $mark || $s =~ /^$ind(.+)$/ || last;
            push @up, $1;
            $l++;
        }
        my $co = join '', map{"$_\n"} @up;
        $co =~ s/\n\s*\.\s*\n/\n\n/sg;
        @$N == 1 || die "allcode in swa";
        my $c = $N->[0]->[2];
        if (!ref $c) {
            $c = $N->[0]->[2] = {s=>$co};
        }
        my $ck = 's';
        #$ck = $1 if $st =~ /(\w+)=><<['"](\w*)['"]/; # confuse (y)=>$s
        my $o = $c->{$ck};
        die "Swap ".wdump [$c,$ck,$o=>FOR=>$co,[@up]] unless split("\n", $o) == @up;
        $c->{$ck} = $co;
    }
humms: | # In wild packer # slipping an II in, aggregator following alllist or so, proto arirang
   ar.v ||= {};
   ar.M ||= [];
   my ($oK,$rM) = @{delete ar.m||die"nbok"};
   inter({oK=>$oK});
   $N = [{MZ=>{$oK=>ar.v}}, @$N];
   Rw In + $N;
   $rM ? @{ar.M} : ar.v
ym/wongui: | # make M flat, acum .c.from, atoms wired together like so J.most.$
    my $wire = 'from';
    return unless C.sc.z;
    for my $zi (@{C.sc.z}) {
        die 'NOZ' if !C.sc.z;
        my $from = [grep{defined}@{C.c->{$wire}||[]},$C];
        my $c = {c=>{$wire=>$from}};
        # the merging 
        push @{A.N}, {EC=>[[$zi],$c]};
    }
ym/notnotcode: |
    T.not = 1 unless exists C.sc.code;
ym/concoi: |
    my $s = C.sc.code || return;
    
    C.y.p ||= join'/',map{_.t}@{C.c.from||[]};
    C.y.cvt ||= "C.y.cv\tC.t";
    
    T.y.spr=$C if A.t&43 && $s=~/^(\^|1)$/;
    
    if ($s=~/^\^$/ && A.t&61) {
        my $i = I.d&moy,'spr';
        # this is at spray
        C.c.s = join "\n",map{
            _.sc.got = 1 if $_ ne $C;
            "#@ _.y.p\n"."_.c.s\n"
        }@{i.N};
        C.sc.code =~ s/^\^ ?//;
        C.sc.code ||= "C.t 4";
    }
    
    if (A.t&43 && C.sc.acgt) {
        # for ACGT+args in acgt, args take whole @_
        C.sc.args ||= join',','A,C,G,T',grep{$_ ne '1'}C.sc.acgt;
        undef C.sc.code if C.sc.code eq '1';
        # the I that Cs all, it is indifferent to its current
        C.sc.code ||= "I 1";
    }
    
    if (A.t&67) {
        if (C.sc.got) {
            return T.not=1;
        }
        my $s = C.sc.code;
        if ($s =~ /\w+ \w+/) {
            $s =~ /^(\w+) (\d+)$/ || die "wtf '$_'  ".ki$C;
            my ($K,$cv) = ($1,$2); 
            $cv = 0+("0.".$cv);
            
            my @ara; # ar ups and demand argsed
            
            if (my $v = C.sc.v) {
                my ($nk,$gk) = $v =~ /^([tyc]|sc)(.*)$/;
                $nk||die"strv:$v";
                C.sc.nk ||= $nk;
                C.sc.rg ||= 1 if C.sc.nk ne $nk;
                push @ara, "    my \$".$nk." = C\.".$nk.";";
                if ($gk) {
                    C.sc.gk ||= $gk;
                    push @ara, "    my \$".$gk." = C\.".$nk."\.".$gk.";";
                }
            }
            if (my $v = C.sc.rg) {
                $v = '' if $v eq '1';
                my ($nk) = C.sc.v =~ /^([tyc]|sc)(.*)$/;
                $nk ||= C.sc.nk || die"nonkrg".ki$C;
                my @no = map {[$nk,$_]} split /,/, $v;
                push @no, [C.sc.nk,C.sc.gk] if $nk ne C.sc.nk;
                for my $s (@no) {
                    push @ara, "    my \$".$s->[1]." = C\.".$s->[0]."\.".$s->[1].";";
                }
            }

            if (my $args = C.sc.args) {
                die "wonky C.t   of ".ki $C if C.t =~ /\W/;
                my $gl = "";
                my $und = "_";
                if ($args =~ s/^(A,C,G,T,)(?!s)//) {
                    $gl .= '    my ($A,$C,$G,$T,@M)=@_;'."\n";
                    $und = 'M';
                }
                my($sf,$sa);
                if (C.sc.subpeel) { # runs, returns T.thing
                    $sf = "(";
                    $sa = ')->($A,$C,$G,$T)';
                }
                # here some want their own I space
                # if I resolv backward winding pro-be
                # G pulls in I
                my $sn = "A\.I\.d"."&An;" if C.t eq 'An';
                
                unshift @ara, "    my \$I = A\.I;";
                
                C.c.s = "A\.I.".C.t." = "
                    .$sf
                    ."sub {\n"
                    .$gl
                    ."    my (".join(',',map{'$'.$_}split',',$args).") = \@".$und.";\n"
                    .join("\n",@ara)."\n"
                    .join("\n",map{"    $_"}split "\n", C.c.s)."\n"
                    ."}"
                    .$sa
                    .";$sn\n";
            }
            else {
                C.sc.subpeel&&die"nonargs ha subpeel".ki$C
            }

            C.sc.dige = slm 12, dig C.c.s;
            C.sc.gro = join'/',map{_.t}grep{_.y.cv != 0.9}
                @{C.c.from} if C.c.from;

            delete C.c.from; # as 7
            
            $v->{$K}->{$cv}->{C.t} = $C;
        }
    }
    
    if (my $y = T.y) {
        for my $k (keys %$y) {
            A.mo.y->{$k}->{C.y.p}->{C.y.cvt} = $C;
        }
    }
ym/talky: | # make M flat, acum .c.from, atoms wired together like so J.most.$
    my $nC = {%$C};
    my $t = ar.t ||"";
    my $n = ar.n ||"";
    my $yc;
    if (C.y.cv) {
        #  && keys %{C.y} == 1
        $yc = "  C.y.cv";
        delete nC.y;
    }
    $yc = delete(nC.t).$yc;
    $n = "in:C.sc.gro" if C.sc.gro;
    if (v.indcar) {
        my $th = C.c->{v.indcar} || [];
        my $am = 0 + @$th;
        $n .= join "", ("    ") x $am;
    }
    
    my $s = "! $n    $t $yc  \t\t". ki $nC;
    $s =~ s/\n/â†¯/g;
    $s =~ s/c=%\{/c/;
    $s =~ s/\}% sc= %\{/ %%% /;
    if (v.talks) {
        push @{v.talks}, $s;
    }
    else {
        say $s;
    }
ym/doex: | # extend C by v 
    I.d&xot,$C,$v;
scd: | # read parts, given rv and possibly since rl - puts newzs in flat list, they themselves unify time etc.
    my $r;
    r.z = [];
    r.oldz = [];
    undef $rl if rl.c ne rv.c;
    push @{$rl ? r.oldz : r.z}, @{rv.c};
    
    r.in = @{rl.sc||[]};
    r.out = @{rv.sc};
    if (r.out > r.in) {
        r.ay = [r.in..(r.out - 1)];
        push @{r.oldz}, @{rv.sc}[0..r.in] if r.in;
        push @{r.z}, @{rv.sc}[@{r.ay}];
    }
    $r
TNews: |
    return say "$talk: Same    rl.i eq rv.i" if rl.i eq rv.i;
    
    my $new;
    if (rl.c ne rv.c) {
        sayre "C C C C C C C";
        sayre "C C C C C C C";
        sayre "C C C C C C C";
        $new = "new!";
    }
    return sayyl "Byst und instro" if G.Byst eq $J;
    my $r = Rw scd $rl $rv;
    my $o = Rw ZNews sold $sc:r.oldz if r.oldz;
    my $n = Rw ZNews news $sc:r.z;
    
    say "$talk: ".($new||"GROWTH!");
    my $lim = sub {
        my ($s,$lim) = @_;
        my @o = split "\n", $s;
        if (@o > $lim) {
            my $more = @o - $lim;
            shift @o while @o > $lim;
            unshift @o, "... $more more ^";
        }
        join "\n", @o;
    };
    $o = $lim->($o);
    saybl $lim->($o,5) if $o;
    sayyl $n if $n;
    #$lim->($n,7)
    
ZNews: |
    my $J = G.Byst || return sayre "Cannot G-Byst-ander yet";
    my $sc = ar.sc || ar.N || ar.M || die "n lost";
    if (ref $sc->[0] && @$sc > 1) {
        return join "\n", map {
            my $sc = [$_];
            my $s = Rw ZNews $sc;
            $s =~ s/^! /oo/s;
            $s;
        } @$sc;
    }
    elsif (!ref $sc->[0] && @$sc) {
        return warn "Raw ".wdump $sc;
    }
    my $N = [@$sc];
    @$N = Rw humms $J $N wongui _
        unless ar.nov;
    my $v = {talks=>[],indcar=>'from'};
    Rw humms $J $N talky $v;
    join "\n", @{v.talks};
oJ4: | # J.A remains, A transitory  - A.time is to couple it like I.in
    J.A ||= {first=>hitime()};
    # everytime stuff:
    #map { sayyl "A.J.name  vs J.name vs J.iter" } 1..3 if rand 9 > 8;
    
    # dep
    if (exists C.sc.pi) {
        die if J.Jiter ne A.J;
        die if J.most.J eq $J;
    }
    else {
        die if J.most.J ne $J;
    }
    
    if (C.c.time) {
        warn "CTIOME".ki $C;
        A.ztime = delete C.c.time;
    }
    A.ztime ||= 6;
    
    if (C.sc.pi) {
        J.A.d = J.Jiter.A.d + 1;
        J.ind = join '  ', ('') x J.A.d;
        J.name = "J.A.d . C.c.pi*C.t";
        J.d = J.C = $C;
        J.r = C.t."\t".C.y.cv;
        J.bz->("/\t0.9" => "y");
        A.time = sub {
             my($JJ,$q) = @_;
             A.ztime >= $q || do {
                 die "J.name  ---- JJ.name     A.ztime quuuuuu $q";
                 0
             };
        };
    }
    else {
        sayyl "Fo 4 A time A: $A   vs J.A " if J.name eq 'Eosse';
        A.time = sub {
             my($JJ,$q) = @_;
             A.ztime >= $q || do {
                 sayre "COMB J.name --- le-- JJ.name      A.ztime < $q";
                 A.jr&vv,$q;
                 0
             };
        };
    }
    
oJ42: |
    my @mis = grep{!A.note.c->{$_}}keys %{C.c};
    @mis=grep{$_ ne'J'}@mis;
    if (@mis) {
        my $cm;
        $cm->{$_} = C.c->{$_} for @mis;
        sayyl "Spesh J.name :  ".ki $cm unless J.yt.quiet;
        A.preg = $cm;
        A.ztime = 9;
    }
    
oJ43: | # the pull down
    J.A.in = $G->gip(J.Jiter.A.in, C.t)||{} if J.Jiter;
    
oC43: | # maniC pulls down travel # comep from aj compi
    if (my $c = $G->gip(A.J.A.in, C.t)) { 
        $c = c._ || return;
        say "C.t in: ".wdump $c if !A.J.yt.quiet;
        if (c.D) {
            c.D->($C);
        }
        elsif (grep {exists $c->{$_}} qw{t y c sc}) {
            g.extend->($C, $c);
        }
        else {
            die "howto ".ki $c;
        }
    }

