allcurve: |
    # mention the oo-able profce
    u allacgts
    # so Cur 9 will state that its a curve, MZomewhere will unravel it on oo
    # oo is potentially abstractable unity, esp where things c their time
    n Dooving=>6=>{s=><<''},{code=>'In 6'}
        sayyl "Cuuuuurvix! ".ki $C;
        #A.t&63 && say "You zero! ".ki$C if C.y.cv == 0;
    
    #y
allcode: |
    n 'allarecode1'=>2,{s=><<''},{code=>'In 42'}
        C.sc.code = 1 if !exists C.sc.code;
allacgts: |
    n allcode=>''=>{W=>'allcode'}
    n 'allareacgt=s'=>2,{s=><<''},{code=>'In 42'}
        C.sc.acgt = 's' if !exists C.sc.acgt;
allacgt: |
    n allcode=>''=>{W=>'allcode'}
    n 'allareacgt=1'=>2,{s=><<''},{code=>'In 42'}
        C.sc.acgt = '1' if !exists C.sc.acgt;
onlycode: |
    n 'skip if no sc_code'=>2,{s=><<''},{code=>'In 31'}
        T.last = 1 unless C.sc.code;
babsubrip: |
            my $l = oA.subline;
            $l -= 4; # sub head lines
            my @l = split "\n", D.bab;
            my $st = $l[$l];
            if ($st =~ /s=><<''/) {
                $st =~ /^\S/ || die "first line start space: $st";
                $l++;
                my $ind;
                my @up;
                while (1) {
                    my $st = $l[$l];
                    last if !$st =~ /\S/;
                    $ind = $1 if !defined $ind
                        && ($st =~ /^(    ).*\S+/ || die "no start ind $st");
                    $st =~ /^$ind(.+)$/ || last;
                    push @up, $1;
                    $l++;
                }
                my $co = join '', map{"$_\n"} @up;
                $co =~ s/\n\s+\.\n/\n\n/sg;
                @$N == 1 || die "allcode in swa";
                my $c = $N->[0]->[2];
                die "Swap ".wdump [c.s=>FOR=>$co] unless split("\n", c.s) == @up;
                c.s = $co;
            }
oJ4: | # J.A remains, A transitory  - A.time is to couple it like I.in
    J.A ||= {first=>hitime()};
    # everytime stuff:
    #map { sayyl "A.J.name  vs J.name vs J.iter" } 1..3 if rand 9 > 8;
    
    # dep
    if (exists C.sc.pi) {
        die if J.Jiter ne A.J;
        die if J.most.J eq $J;
    }
    else {
        die if J.most.J ne $J;
    }
    
    if (C.c.time) {
        warn "CTIOME".ki $C;
        A.ztime = delete C.c.time;
    }
    A.ztime ||= 6;
    
    if (C.sc.pi) {
        J.A.d = J.Jiter.A.d + 1;
        J.ind = join '  ', ('') x J.A.d;
        J.name = "J.A.d . C.c.pi*C.t";
        J.d = J.C = $C;
        J.r = C.t."\t".C.y.cv;
        J.bz->("/\t0.9" => "y");
        A.time = sub {
             my($JJ,$q) = @_;
             A.ztime >= $q || do {
                 die "J.name  ---- JJ.name     A.ztime quuuuuu $q";
                 0
             };
        };
    }
    else {
        sayyl "Fo 4 A time A: $A   vs J.A " if J.name eq 'Eosse';
        A.time = sub {
             my($JJ,$q) = @_;
             A.ztime >= $q || do {
                 sayre "COMB J.name --- le-- JJ.name      A.ztime < $q";
                 A.jr&vv,$q;
                 0
             };
        };
    }
    
oJ42: |
    my @mis = grep{!A.note.c->{$_}}keys %{C.c};
    @mis=grep{$_ ne'J'}@mis;
    if (@mis) {
        my $cm;
        $cm->{$_} = C.c->{$_} for @mis;
        sayyl "Spesh J.name :  ".ki $cm unless J.yt.quiet;
        A.preg = $cm;
        A.ztime = 9;
    }
    
oJ43: | # the pull down
    J.A.in = $G->gip(J.Jiter.A.in, C.t)||{} if J.Jiter;
    
oC43: | # maniC pulls down travel # comep from aj compi
    if (my $c = $G->gip(A.J.A.in, C.t)) { 
        $c = c._ || return;
        say "C.t in: ".wdump $c if !A.J.yt.quiet;
        if (c.D) {
            c.D->($C);
        }
        elsif (grep {exists $c->{$_}} qw{t y c sc}) {
            g.extend->($C, $c);
        }
        else {
            die "howto ".ki $c;
        }
    }

