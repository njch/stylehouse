allcurve: |
    # mention the oo-able profce
    u allacgts
    # so Cur 9 will state that its a curve, MZomewhere will unravel it on oo
    # oo is potentially abstractable unity, esp where things c their time
    n Dooving=>6=>{s=><<''},{code=>'In 6'}
        sayyl "Cuuuuurvix! ".ki $C;
        #A.t&63 && say "You zero! ".ki$C if C.y.cv == 0;
        # curve instructions t=>s is flowing in down cv
        # draw out atoms, x=y=0 r=0 begins
    
    #y
allcode: |
    n 'allarecode1'=>2,{s=><<''},{code=>'In 42'}
        C.sc.code = 1 if !exists C.sc.code;
allacgts: |
    n allcode=>''=>{W=>'allcode'}
    n 'allareacgt=s'=>2,{s=><<''},{code=>'In 42'}
        C.sc.acgt = 's' if !exists C.sc.acgt;
allact: |
    n allacgts=>''=>{W=>'allacgts'}
    n 'allareact=1'=>2,{s=><<''},{code=>'In 42'}
        C.sc.act = 1 if !exists C.sc.act;
allvy: |
    n allact=>''=>{W=>'allact'}
    n 'allarev=y'=>2,{s=><<''},{code=>'In 42'}
        C.sc.v = 'y'.C.sc.v;
allacgt: |
    n allcode=>''=>{W=>'allcode'}
    n 'allareacgt=1'=>2,{s=><<''},{code=>'In 42'}
        C.sc.acgt = '1' if !exists C.sc.acgt;
onlycode: |
    n 'skip if no sc_code'=>2,{s=><<''},{code=>'In 31'}
        T.last = 1 unless C.sc.code;
babsubrip: |
    my $l = oA.subline;
    $l -= 4; # sub head lines
    my @l = split "\n", D.bab;
    my $st = $l[$l];
    if ($st =~ /s=><<''/) {
        $st =~ /^\S/ || die "first line start space: $st";
        $l++;
        my $ind;
        my @up;
        while (1) {
            my $st = $l[$l];
            last if !$st =~ /\S/;
            $ind = $1 if !defined $ind
                && ($st =~ /^(    ).*\S+/ || die "no start ind $st");
            $st =~ /^$ind(.+)$/ || last;
            push @up, $1;
            $l++;
        }
        my $co = join '', map{"$_\n"} @up;
        $co =~ s/\n\s+\.\n/\n\n/sg;
        @$N == 1 || die "allcode in swa";
        my $c = $N->[0]->[2];
        die "Swap ".wdump [c.s=>FOR=>$co] unless split("\n", c.s) == @up;
        c.s = $co;
    }
ym/wongui: | # make M flat, acum .c.from, atoms wired together like so J.most.$
    my $D = {t=>z=>y=>4=>c=>{nk=>'sc',gk=>'z',mdrl=>1,as=>'list'}};
    
    # I. for decoupling hashrefs like vasing
    $C->{$_} = {%{$C->{$_}||{}}} for 'c','sc';
    my $wire = 'from';
    
    for my $zi (A.c->($D)) {
        my $from = [
            reverse $C, reverse map{@$_} A.c&$wire,'%as:list'
        ];
        my $c = {c=>{$wire=>$from}};
        my $s = {EC=>[$zi,$c]};
        # the merging ^
        push @{A.N}, $s;
    }
ym/notnotcode: |
    T.not = 1 unless exists C.sc.code;
ym/concoi: |
    my $s = C.sc.code || return;
    
    C.y.p ||= join'/',map{_.t}@{C.c.from||[]};
    C.y.cvt ||= "C.y.cv\tC.t";
    
    T.y.spr=$C if A.t&43 && $s=~/^(\^|1)$/;
    
    if ($s=~/^\^$/ && A.t&61) {
        my $i = I.d&moy,'spr';
        # this is at spray
        C.c.s = join "\n",map{
            _.sc.got = 1 if $_ ne $C;
            "#@ _.y.p\n"."_.c.s\n"
        }@{i.N};
        C.sc.code =~ s/^\^ ?//;
        C.sc.code ||= "C.t 4";
    }
    
    if (A.t&43 && C.sc.acgt) {
        # for ACGT+args in acgt, args take whole @_
        C.sc.args ||= join',','A,C,G,T',grep{$_ ne '1'}C.sc.acgt;
        undef C.sc.code if C.sc.code eq '1';
        # the I that Cs all, it is indifferent to its current
        C.sc.code ||= "I 1";
    }
    
    if (A.t&67) {
        if (C.sc.got) {
            return T.not=1;
        }
        my $s = C.sc.code;
        if ($s =~ /\w+ \w+/) {
            $s =~ /^(\w+) (\d+)$/ || die "wtf '$_'  ".ki$C;
            my ($K,$cv) = ($1,$2); 
            $cv = 0+("0.".$cv);
            
            my @ara; # ar ups and demand argsed
            
            if (my $v = C.sc.v) {
                my ($nk,$gk) = $v =~ /^([tyc]|sc)(.+)$/
                    ||die"strv:$v";
                C.sc.nk = $nk;
                $v eq $nk &&
                    push @ara, "    my \$".$nk." = C\.".$nk.";";
                if ($gk) {
                    C.sc.gk = $gk;
                    push @ara, "    my \$".$gk." = C\.".$nk."\.".$gk.";";
                }
            }
            if (C.sc.nk) {
                die "form ".ki $C;
            }

            if (my $args = C.sc.args) {
                die "wonky C.t   of ".ki $C if C.t =~ /\W/;
                my $gl = "";
                if ($args =~ s/^(A,C,G,T,)(?!s)//) {
                    $gl .= '    my ($A,$C,$G,$T)=splice @_,0,4;'."\n";
                }
                my($sf,$sa);
                if (C.sc.subpeel) { # runs, returns T.thing
                    $sf = "(";
                    $sa = ')->($A,$C,$G,$T)';
                }
                # here some want their own I space
                # if I resolv backward winding pro-be
                # G pulls in I
                my $sn = "A\.I\.d"."&An;" if C.t eq 'An';
                
                push @ara, "    my \$I = A\.I;";
                
                C.c.s = "A\.I.".C.t." = "
                    .$sf
                    ."sub {\n"
                    .$gl
                    ."    my (".join(',',map{'$'.$_}split',',$args).") = \@_;\n"
                    .join("\n",@ara)."\n"
                    .join("\n",map{"    $_"}split "\n", C.c.s)."\n"
                    ."}"
                    .$sa
                    .";$sn\n";
            }
            else {
                C.sc.subpeel&&die"nonargs ha subpeel".ki$C
            }

            C.sc.dige = slm 12, dig C.c.s;
            C.sc.gro = join'/',map{_.t}grep{_.y.cv != 0.9}
                @{C.c.from} if C.c.from;

            $v->{$K}->{$cv}->{C.t} = $C;
        }
    }
    
    if (my $y = T.y) {
        for my $k (keys %$y) {
            A.mo.y->{$k}->{C.y.p}->{C.y.cvt} = $C;
        }
    }
ym/talky: | # make M flat, acum .c.from, atoms wired together like so J.most.$
    my $nC = {%$C};
    my $t = ar.t ||"";
    my $n = ar.n ||"";
    my $yc;
    if (C.y.cv) {
        #  && keys %{C.y} == 1
        $yc = "  C.y.cv";
        delete nC.y;
    }
    $yc = delete(nC.t).$yc;
    $n = "in:C.sc.gro";
    
    my $s = "! $n    $t $yc  \t\t". ki $nC;
    $s =~ s/\n/â†¯/g;
    say $s;
ym/doex: | # extend C by v 
    I.d&xot,$C,$v;
oJ4: | # J.A remains, A transitory  - A.time is to couple it like I.in
    J.A ||= {first=>hitime()};
    # everytime stuff:
    #map { sayyl "A.J.name  vs J.name vs J.iter" } 1..3 if rand 9 > 8;
    
    # dep
    if (exists C.sc.pi) {
        die if J.Jiter ne A.J;
        die if J.most.J eq $J;
    }
    else {
        die if J.most.J ne $J;
    }
    
    if (C.c.time) {
        warn "CTIOME".ki $C;
        A.ztime = delete C.c.time;
    }
    A.ztime ||= 6;
    
    if (C.sc.pi) {
        J.A.d = J.Jiter.A.d + 1;
        J.ind = join '  ', ('') x J.A.d;
        J.name = "J.A.d . C.c.pi*C.t";
        J.d = J.C = $C;
        J.r = C.t."\t".C.y.cv;
        J.bz->("/\t0.9" => "y");
        A.time = sub {
             my($JJ,$q) = @_;
             A.ztime >= $q || do {
                 die "J.name  ---- JJ.name     A.ztime quuuuuu $q";
                 0
             };
        };
    }
    else {
        sayyl "Fo 4 A time A: $A   vs J.A " if J.name eq 'Eosse';
        A.time = sub {
             my($JJ,$q) = @_;
             A.ztime >= $q || do {
                 sayre "COMB J.name --- le-- JJ.name      A.ztime < $q";
                 A.jr&vv,$q;
                 0
             };
        };
    }
    
oJ42: |
    my @mis = grep{!A.note.c->{$_}}keys %{C.c};
    @mis=grep{$_ ne'J'}@mis;
    if (@mis) {
        my $cm;
        $cm->{$_} = C.c->{$_} for @mis;
        sayyl "Spesh J.name :  ".ki $cm unless J.yt.quiet;
        A.preg = $cm;
        A.ztime = 9;
    }
    
oJ43: | # the pull down
    J.A.in = $G->gip(J.Jiter.A.in, C.t)||{} if J.Jiter;
    
oC43: | # maniC pulls down travel # comep from aj compi
    if (my $c = $G->gip(A.J.A.in, C.t)) { 
        $c = c._ || return;
        say "C.t in: ".wdump $c if !A.J.yt.quiet;
        if (c.D) {
            c.D->($C);
        }
        elsif (grep {exists $c->{$_}} qw{t y c sc}) {
            g.extend->($C, $c);
        }
        else {
            die "howto ".ki $c;
        }
    }

