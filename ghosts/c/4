




timery: |
    # n ^-re should mean n C.t."-re"
    n timery_re => 2 => {s=><<''},{code=>'J 42'}
        if (J.most.J eq $J) {
            # J.most.A could coord 8ish stuff. allele towerish...
            J.A.timery = {};
        }
    
    n timery_do => 7 => {s=><<''},{code=>'T 9'}
        if (my $ti = J.most.J.A.timery) {
            ti.t->{J.name} = $sol;
            $ti->{$sol}++;
            if (J.name eq 'Wkcs') {
                say "Wkcs: ". k2 {w=>{W=>$ti}};
            }
        }
allcode: |
    n 'make sc_code=1 if no'=>2,{s=><<''},{code=>'In 51'}
        C.sc.code = 1 !exists C.sc.code;
onlycode: |
    n 'skip if no sc_code'=>2,{s=><<''},{code=>'In 31'}
        C.sc.code = 1 !exists C.sc.code;
concatco: |
    n 'pool lang spines to s (^) unifying arms as surface res goes'=>7=>{s=><<''}
        # another frequency to this
        # tune in this into the space
        # get the layers of music to inter
        # C and D stuff
        
        # code is an index
            # 
        # 2821:      keys arrive as characters already:
        # prep A for A (I), J-sessioned etc stuff
        # is literal G spacer, index jointed bunch of code to check out from w
        # some comp could expectorate lots charstream rhythms ^
        # Z flow?
        # or we could do on a stick,
        # so its MZ junk dont linger in this stream
        # ie always flow outwards the sc filtery stuff.
        
Ein: |
    u allcode
    n args=>1=>{s=><<''}
        my $N = ar.N||ar.C;
        $N = [$N] if ref $N ne 'ARRAY';
    
    n In=>2=>{s=><<''},{code=>'^'}
        my $A = Rw ready;
        A.N = $N;
    
    # pi lays out in tiles
    
    n fl=>22=>{s=><<''}
        A.fl = ar.fl || {};
    n M=>24=>{s=><<''}
        A.M = [];
        
    n bangC=>26=>{s=><<''}
        aft {
            $@||return;
            $@ = "C: ".ki(I.nF.C)."\n$@";
        };
    
    n loop=>3=>{s=><<''}
        A.t&3||return;
        while (@{A.N}) { #
            my ($C,$T,$s) = ({},{},shift @{A.N});
    
    n l=>31=>{s=><<''}
            my $A = {%$A};
            T.oM = [];
            I.d&n,$A,$C,$G,$T;
            I.d&An;
            
    
    n l=>32=>{s=><<''}
            I.d&Ci,$s;
    
    n l=>33=>{s=><<''}
            I.d&z && next if T.not;

    n fl=>4=>{s=><<''}
            for my $k (keys %{A.fl}) {
                my $v = A.fl->{$k};
                Rw ym/$k $A $C $n:C $v $G $T;
            }

    n l=>5=>{s=><<''}
            I.d&Cr,$s;

    n l=>6=>{s=><<''}
            die "not: ".wdump 4,[$N, $C]
               if !ref C.y || !C.y || !defined C.t;

    n l=>67=>{s=><<''}
            push @{T.oM}, $C;

    n l=>68=>{s=><<''}
            I.d&z;
        }
    
    n l=>7=>{s=><<''}
        my $M = ar.M;
        if ($M) {
            push @$M, @{A.M}
        }
        elsif ($J) {
            map {
               Rw mani + $J $C:_
            } @{A.M}
        } else {
            die "noJM";
        }
     
ready: |
    # F says how to make an A for it
    # then A.t&3 etc moves time forward, ore return is crux slot craft
    # return @$_ for A.t&3;
    # so we can hijack Ein by the something
    # and want to inject a tiny bit of code in this one circumstance
    # joins up by whether its there at all (u vic)
    # and what code=>thing is referring into... known at utime by Athing
    # all tumbling down F right behind ...
    
    # define how to throw sheets of language
    # do zis first stuff...
    # and and...

C_E: |
    I.An = sub {
        my ($A,$C,$G,$T) = @_;
        A.note = {}; # pinging csc
        A.c = sub {
            my ($nk,$gk) = @_;
            my $D = {};
            if (ref $nk) {
                $D = $nk
            }
            else {
                if (@_ == 1) { # or from t,,,
                    D.c.nk = 'c';
                    D.c.gk = $nk;
                }
                elsif (@_ == 2) {
                    D.c.nk = $nk;
                    D.c.gk = $gk;
                }
            }
            # ^nk glue
            my $got = I.d&Cngk,$D;
            return () unless $got;
            A.note->{D.c.nk}->{D.c.gk} = $got;
            my $v = $got->[0];
            die 'mulitAn' if @$got > 1;
            if (D.c.as eq 'list') {
                return ref $v eq 'ARRAY' ? @$v : $v;
            }
            return 1;
        };
        $A
    };
C_C: |
    I.accept = sub { # coinsciousness accept, v 1-2
        my ($A,$C,$G,$T,$D) = @_;
        return T.next = 1 unless I.d&Cngk,$D;
    };
    I.Cngk = sub {
        my ($A,$C,$G,$T,$D) = @_;
        die 'nk no gk' if exists D.c.nk && !exists D.c.gk;
        return 1 if D.c.any;
        if (D.c.nk && exists $C->{D.c.nk} && exists $C->{D.c.nk}->{D.c.gk}) {
            my $v = [$C->{D.c.nk}->{D.c.gk}];
            delete $C->{D.c.nk}->{D.c.gk} if D.c.mdel;
            return $v;
        }
        die "nonnk".ki$D unless exists D.c.nk;
        0;
    };
    I.extend = sub {
        my ($A,$C,$G,$T,$s,$c) = @_;
        while (my($k,$v) = each %$c) {
            $s->{$k} = ref $v ? {%{$s->{$k}||{}}, %$v} : $v;
        }
    };
    I.ECu = sub { # extend C on the way in to another dome, magnetised into our M
        # probably for collapsing roooves...
        # dumber than sc decompresphere & playing out
        # (is mailing itself further instructions, intro c, further lines)
        # an In persona, joining our M
        my ($A,$C,$G,$T,$s) = @_;
        my ($s,$c) = @$s;
        my $E; # push to dome
        E.Ci.3.doextend = sub {
            my ($A,$C,$G,$T) = @_;
            I.d&extend,$C,$c;
        };
        Rw In + $M:T.oM $C:s $E;
        
        my $Z = I.d&iZu,$s;
        for my $k (sort keys %$Z) {
            my $s = $Z->{$k};
            die wdump $s if ref $s ne 'ARRAY';
            unshift @{A.N}, @$s;
        }
        T.not = 1;
    };
ym/wongui: |
    my $D = {t=>z=>y=>4=>c=>{nk=>'sc',gk=>'z',as=>'list'}};
    
    saybl "Slamping".  wdump 3, $C;
    for my $zi (A.c->($D)) {
        saybl wdump 3, $C;
        my $from = [[C.t,C.y]];
        unshift @$from, A.c&from;
        push @{A.N}, {EC=>[$zi,{c=>{from=>$from}}];
    }
At4: |
    $C||die;
    my $A = {};
    A.J = $J;
    A.C = $C;
    A.I = Rw already;
    A.is = A.M = [];
    $A;
I_4: | # is a 4d join! something n'd in, certain conditions already from 6...
     # whatever is high in the plain is coming at us
     
     # make pool, synth space, want arches
     # fork & rejoin to exciting place
     # the valley, what it means to be here in here YIN
     my $A = Rw At4;
     # ^ DESCRIBE how we're in here to
     # also the executablur
     # if something wants to mess with itself when...
     A.note = {};
     A.note.not = sub {
         my ($nt,$k) = @_;
         A.note.>$nt.>$k = 1;
     };
     A.seen = sub {
           my ($ct) = @_;
           ct.t_k eq "c" && A.note.not&c,ct.t;
     };
     # all thoughts are prayed to some beast
     # acquire Y personality:
     A.y&upto;
     #à¶¬
     # 2.8
     my $CC = $C;
     @{A.is}||die'nois'.wdump[$C,$A];
     for my $C (@{A.is}) { # THE TIR drop at hands
           my $A = {%$A};
           A.note = {};
           A.C = $C;
           C.c || die;
           C.y.cv || die "no cv".k2 $C;
           C.r = join "\t", C.t, (C.y.cv+0);
           C.sc = {%{C.sc||{}}}; # ?
           
           # 7.9
           C.r = join "\t", C.t, (C.y.cv+0);
           my $oJ = $J;
           my $J = C.y.o && C.y.o.J || $oJ;
           if (J.V) {
           say "MOD COMPLETE J.name     ->>>   C.t C.y.cv  ".k2(C.c)
           ."                     ".k2(C.sc);
           }
           Rw jamsc $J $oJ $C $s:C.c.s $sc:C.sc;
     }
     # 9
     return $A
oJ4: | # J.A remains, A transitory  - A.time is to couple it like I.in
    J.A ||= {first=>hitime()};
    # everytime stuff:
    #map { sayyl "A.J.name  vs J.name vs J.iter" } 1..3 if rand 9 > 8;
    
    # dep
    if (exists C.sc.pi) {
        die if J.Jiter ne A.J;
        die if J.most.J eq $J;
    }
    else {
        die if J.most.J ne $J;
    }
    
    if (C.c.time) {
        warn "CTIOME".ki $C;
        A.ztime = delete C.c.time;
    }
    A.ztime ||= 6;
    
    if (C.sc.pi) {
        J.A.d = J.Jiter.A.d + 1;
        J.ind = join '  ', ('') x J.A.d;
        J.name = "J.A.d . C.c.pi*C.t";
        J.d = J.C = $C;
        J.r = C.t."\t".C.y.cv;
        J.bz->("/\t0.9" => "y");
        A.time = sub {
             my($JJ,$q) = @_;
             A.ztime >= $q || do {
                 die "J.name  ---- JJ.name     A.ztime quuuuuu $q";
                 0
             };
        };
    }
    else {
        sayyl "Fo 4 A time A: $A   vs J.A " if J.name eq 'Eosse';
        A.time = sub {
             my($JJ,$q) = @_;
             A.ztime >= $q || do {
                 sayre "COMB J.name --- le-- JJ.name      A.ztime < $q";
                 A.jr&vv,$q;
                 0
             };
        };
    }
    
oJ42: |
    my @mis = grep{!A.note.c->{$_}}keys %{C.c};
    @mis=grep{$_ ne'J'}@mis;
    if (@mis) {
        my $cm;
        $cm->{$_} = C.c->{$_} for @mis;
        sayyl "Spesh J.name :  ".ki $cm unless J.yt.quiet;
        A.preg = $cm;
        A.ztime = 9;
    }
    
oJ43: | # the pull down
    J.A.in = $G->gip(J.Jiter.A.in, C.t)||{} if J.Jiter;
    
oC43: | # maniC pulls down travel # comep from aj compi
    if (my $c = $G->gip(A.J.A.in, C.t)) { 
        $c = c._ || return;
        say "C.t in: ".wdump $c if !A.J.yt.quiet;
        if (c.D) {
            c.D->($C);
        }
        elsif (grep {exists $c->{$_}} qw{t y c sc}) {
            g.extend->($C, $c);
        }
        else {
            die "howto ".ki $c;
        }
    }

