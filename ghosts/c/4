


oJ3: | # MOD  being repeater  - humm
    # A.jr wires us to the Jvary
    my $fo = A.jr&J;
    my $wa = C.sc.J;
    C.sc.J = $fo if $fo;
    die "diff c W-J  " if C.c.W && C.c.W ne C.c.J;
    die "scwa->Ajr'd: $wa -> $fo" if ref $wa && ref $fo && $wa ne $fo;
    ref C.sc.J && C.sc.J.dead && undef C.sc.J;
    my $J = C.sc.J;
    
    if (C.c.X) {
        die "Nofound $J  C.t   C.y.cv" if !ref $J;
        die "noovewr X  C.c.X ne $J" if C.c.X ne $J;
        sayyl "DELING J.name". wdump $C if C.c.X;
        A.jr&J,$J,9;
        J.dead = 1;
        T.return = [];
        return;
    }
    
    if (!ref $J) {
        if (C.sc.pi) {
            $J = Rw spinash $J:A.J;
        }
        else {
            my $o = {name=>C.c.J};
            ref o.name && die 'ref name'.ki $o;
            length o.name || die "no leno".ki $o;
            o.style = delete C.c.style if C.c.style;
            # TODO make func like J.w&oc,style=>C.c;
            # which moves into the wall and percs lamt.
            $J = Rw JJ $o;
            sayyl "J3   Made J.name";
        }
        C.sc.J = $J || die 'want23';
    }
    
    die "noovewr   C.c.J ne $J" if ref C.c.J && C.c.J ne $J;
    A.jr&J,$J;
    A.jr->('',"Jay");
    at.J = $J;
    # ^ gets & replaces, C.sc.J now it
    
    Rw oJ4 + $J;
oJ41: |
    #J.yy.may.noroot = 1;
    #J.bz->("/\t0.9", "y", "%tag"=>J.name);
    #J.bz->("/%id\t0.9", J.id) if !exists J.bb->{"/%id\t0.9"};
    
    J.A = {};
    J.A.first = hitime;
oJ42: |
    if (J.most.J eq $J) {
        # J.most.A could coord 8ish stuff. allele towerish...
        J.A.timery = {};
    }
    die if C.sc.pi && J.Jiter ne A.J;
    die if C.sc.pi && J.most.J eq $J;
    die if !C.sc.pi && J.most.J ne $J;
    
    A.ztime = delete C.c.time if C.c.time;
    A.ztime ||= 6;
    
    my @mis = grep{!A.note.c->{$_}}keys %{C.c};
    @mis=grep{$_ ne'J'}@mis;
    if (@mis) {
        my $cm;
        $cm->{$_} = C.c->{$_} for @mis;
        sayyl "Spesh J.name :  ".ki $cm unless J.yt.quiet;
        A.preg = $cm;
        A.ztime = 9;
    }
    
oJ43: | # the pull down
    J.A.in = $G->gip(J.Jiter.A.in, C.t)||{} if J.Jiter;
    
oC43: | # maniC pulls down travel # outside in
    if (my $c = $G->gip(A.J.A.in, C.t)) { 
        $c = c._ || return;
        say "C.t in: ".wdump $c if !A.J.yt.quiet;
        g.extend->($C, $c);
    }
oJ4: |
    # J.A remains, A transitory
    J.A || Rw oJ41;
    
    Rw oJ42;
    
    if (C.sc.pi) {
        J.A.d = J.Jiter.A.d + 1;
        J.ind = join '  ', ('') x J.A.d;
        J.name = "J.A.d . C.c.pi*C.t";
        J.d = J.C = $C;
        J.r = C.t."\t".C.y.cv;
        J.bz->("/\t0.9" => "y");
        A.time = sub {
             my($JJ,$q) = @_;
             A.ztime >= $q || do {
                 warn "J.name  ---- JJ.name     A.ztime quuuuuu $q";
                 0
             };
        };
    }
    else {
        A.time = sub {
             my($JJ,$q) = @_;
             A.ztime >= $q || do {
                 sayre "J.name ----- JJ.name      A.ztime < $q";
                 A.jr&vv,$q;
                 0
             };
        };
    }
oJ6: | # https://www.youtube.com/watch?v=tL8N_3tln0Y
    my $J = C.sc.J;
    # get to T it
    # faders instead of the do now of exo c intentions
    return T.last = 1 unless Atime(6);
    # locks/9compressionintotime
    die "doubly" if A.ztime < 9 && A.jr&bol;
    my $n = A.ztime >= 9 ? sub{} : A.jr&bol,9;
    aft { $n->(); $@||return; sayre "BANG J.name" for 1..3; };
    
    %$ar = (%$ar, %{C.c}); 
    if (exists C.sc.pi) {
        Rw opi6 + $J;
    }
    elsif (ref G.way->{J.name} eq 'HASH') {
        saybl "oJ6 C.t" unless J.yt.quiet;
        Rw around + $J;
    }
    elsif (exists G.way->{J.name}) {
        my $p = J.name;
        Rw oT6 + $p $J $A:J.A $C:J.C $T;
    }
    A.roundi = 1;
       
waz/up: | # a strain
    if (!J.yt.nohead) {
        Rw Jhead;
        Jn(st=>0.9=>"o",'%hs:8427,fs:4');
    }
    die if !ar.T;
    Rw oT6 + $p=*/M $J $A:J.A $C:J.C $T;
opi6: |
    die'csnod' if $C ne J.C;
    die if !ar.T;
    
    J.cv = C.c.gp.cv || C.c.cv || 0.6;
    my $s = C.c.s;
    my $path = C.sc.pi||die'nopi';
    if (J.A.d > 7) {
        $path = 'text';
        warn "J.name J.A.d limit to text";
    }
    my $pin = "pi/$path";
    
    Rw oT6 + $pin $s $u:s;
eighthnot: |
    my ($dir) = J.id =~ /(.)$/;
    my $lim = $dir > 6 ? 6 : $dir > 3 ? 5 : 4;
    if (J.A.tch++ > $lim) {
        J.A.tch = $lim - 4;
        return 1
    }
    return 0
oT6: |
    my $talk = "T J.most.J.name /// J.A.d J.name  J.A.ztime A.ztime";
    A.coi = Rw pha $J ako;
    if (exists C.sc.pi) {
        # telephone winch
        for (qw'ljm ljmo') {
             J.A->{$_} = J.Jiter.A->{$_}
             if J.Jiter && J.Jiter.A->{$_};
        }
        A.time = sub {
            my($JJ,$q) = @_;
            # then - is
            # crux to pi
            # point to give up
            # so can much very, sculpt
            if ($q == 2) {
                A.ico = Rw pha $J ico;
                A.ico.qui = 1;
                A.ico.as->(A.coi);
                my $wt = A.ico.exactl->();
                
                saybl "$talk  2222 ".wdump 2,
                  [wt.same,wt.new,wt.diff,wt.gone]
                    if wt.last && !wt.same;
                
                Rw eighthnot $J
                 ? do { A.ico.wt.same = 0; }
                 : wt.same && return 0;
                
                # for jamcs screenfly
                J.A.ljm = [];
                J.A.ljmo = "fr  J.name";
                return 1;
            }
            warn "$talk other $q";
            if ($q == 8) {
                # until J.most coord attention evaporates
                # as in pulling on a list
            }
            A.ztime >= $q;
        };
    };

    my $M=[];
    my $y = {o=>$M};
    
    my $tw = Rw huck + $M $y;
    
    $tw || die "nothing! J.name";
    die "many".ki $tw if keys %$tw > 1;
    # set our C.c.s to [that], noise probe case, maybe

    Jn('zoo',$y) if @$M;
    
    my $sol = "?";
    if (A.ico && A.ico.wt.same) {
        my $cut = @{A.ico.ord};
        my @cc = @{A.coi.ord};
        if (@cc > $cut) {
            warn"J.name entered stuff after 2!".wdump [@cc, 
            '                 =============', @{A.ico.ord}];
        }
        A.coi.abandon->();
        if (my $ljm = J.A.ljm) {
            for my $ar (@$ljm) {
                ar.noR=1;
                Rw jamsc;
            }
        }
        sayre "SKIP $talk" if J.V;
        T.last = 1;
        $sol = "skip";
    }
    else {
        A.coi.qui = 1;
        my $wt = A.coi.exactl->();
        if (wt.same) {
            if (++J.A.wch > 4) {
                J.A.wch = 0;
                $sol = "same";
            }
            else {
               $sol = "skip";
               sayre "RESKIP $talk" if J.V;
                T.last = 1;
            }
        }
        else {
            $sol = "notsame";
        }
    }
    
    if (my $ti = J.most.J.A.timery) {
        ti.t->{J.name} = $sol;
        $ti->{$sol}++;
        if (J.name eq 'Wkcs') {
            say "Wkcs: ". k2 {w=>{W=>$ti}};
        }
    }
    
    
oJ7: |
    return
    Rw opi7
    if ar.A && ar.C.sc.pi;
    
    
    my $J = C.sc.J;
    return if A.roundi;
    
    say "oJ7 J.name" unless J.yt.quiet;
    Rw oJ $J geo &up $noesc=1;
    my $eo = J.most.eo;
    $eo || die "noeo: J.name";
    Rw $eo $J;
opi7: | # MOD pi     out cup           # REF JOIN A.c/sc
    my $J = C.sc.J;
    
    my $aj = Rw J.most.eo $J $catj=1;
    
    die aj.s if aj.s;
    #sayre "Upto J.r go ".slim 70, sjson aj.c if @{aj.c};
    J.Ec = [@{aj.c}];
    
    
    aft { 
    $@||return;
    sayre wdump 9, aj.c;
    say "J.name :::::::::::: ".ki $C;
    };
    sjson(aj.c);
    
    
    die wdump $aj if @{aj.sc};
       
oJ75: | # chov J
    if (C.sc.pi) {
        $v = C.sc.J || die'enoJ'.C.t;
        die "Pi v.r has s" if v.s;
        delete at.s if defined at.s;
        die "No Ec came out of v.name  on J.name" if !ref v.Ec;
        die "Pi v.r no .Ec" if !@{v.Ec};
        acum $at, 'Esc', $_ for @{v.Ec};
    }
    else {
        #say "AM v.name  rrrrr J.name";
        at.s = "Vrrr v.name";
    }
ok5: |
    my $J = C.sc.J||die;
       A.ztime = 1;
       A.note.not&csrm,'ok';
       
       my $co = A.jr&ok-$v;
       my $til = $co - hitime;
       # cv wave column to plant next self in
       A.waov = $v;
       # assume that v shapes delay until DNS of tension
       my $del = $v;
       if ($co && $til < 0) {
           sayre "running late: ". $til if $til < -0.1;
           A.ztime = $v if $v > A.ztime; # on there
           undef $co;
       }
       elsif (!$co) {
           $del = 0.1;
           sayyl "C.t begins";
       }
       $del *= 3.7;
       $del *= 1.2 if rand 5 > 3;
       $co ||= $del + hitime;
       
       A.watime = $co;
       die "yep";
       
       say "!! $til for A.ztime   ".ki C.c;
       A.jr&ok-$v,$co;

