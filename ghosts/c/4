

oAiC: |
     if (my $c = $G->gip(A.J.A.in, C.t)) { # outside in
         $c = c._ || return;
         say "C.t in: ".wdump $c;
         g.extend->($C, $c);
     }
oJ2: | # MOD wo
    C.c.W = $v;
    # is a J attaching to a J
    # various ways, subsequently moded somehow
    # the way unified by the other is interesting
    # there be many out channels
    # and file handles
    # with behaviour, lack of flooding
    # we wants to be plumbed off J somehow
    # we subscribe 
    # could grab last atom in its curve, hang ourselves there somehow
    # atoms need to coalesce beautifully
    
    
    
    
    
    
    
    
    
    
    #sayyl "WW WW $v         J.name";
    A.ztime = 3;
    
oW2: | # some get-J or weave wires protocol - hosts
    my $t = $v;
    $t = v.name if ref $t;
    at.J = ref $v ? $v : $t;
    at.W = $t;
    C.c.J ||= $v;
    
    die wdump ["onto W J.name:",$v] if ref $v && $v ne v.most.J;
    
    C.t = $t;
    C.y.cv = 0.3;
    
    A.jr = Rw Ajr $J:G.oin $t $cv=0.3;
    
    # and where the 
    
    if (C.c.vv) {
        A.ztime = delete C.c.vv;
        A.jr&vv,9
        ->(); #delone
    }
opi2: | # approach
    at.pi = $v || 'guess';
    C.c.J = 'pie';
    
    my $oJ = $J;
    $oJ = C.y.o.J if C.y.o && C.y.o.J;
    A.jr = Rw Ajr $J:oJ $C;
   
oJ3: | # MOD  being repeater
    my $ca = A.jr&J; # gets W from oin(etc)  or  abdomisa
    my $sp = C.sc.J;
    C.sc.J = $ca if $ca; # resolve
    
    die "diff c W-J  " if C.c.W && C.c.W ne C.c.J;
    die "sp: $sp -> $ca" if ref $sp && ref $ca && $sp ne $ca;
    #sayre "ref CcJ J.name  ".k2 $C if ref C.c.J;
    ref C.sc.J && C.sc.J.dead && undef C.sc.J;
    return
    Rw join/inX
    if ref C.c.X;
    
    if (!ref C.sc.J) {
        if (C.sc.pi) {
            C.sc.J = Rw spinash $J;
            #sayyl "made C.t = C.sc.pi for J.most.J.name" if J.most.J.name eq 'Wkcs';
        }
        else {
            my $o = {name=>C.c.J};
            o.style = delete C.c.style if C.c.style;
            C.sc.J = Rw JJ $o;
            sayyl "J3   Made o.name";
        }
    }
    
    my $J = C.sc.J;
    die "noovewr   C.c.J ne $J" if ref C.c.J && C.c.J ne $J;
    A.jr&J,$J;
    A.jr->('',"Jay");
    at.J = $J;
    # ^ gets & replaces, C.sc.J now it
    Rw oJ4 + $J;
oJ4: |
    if (J.most.J eq $J) {
        J.most.A.time = sub {
             my ($J,$wa) = @_;
             J.A.ztime >= $wa ? 1 : do {
                 sayre gp($J)." Wants time, $wa" for 1..5;
                 #acum $A, fo => $J;
                 0;
             };
        };
    }
    die if C.sc.pi && J.Jiter ne A.J;
    die if C.sc.pi && J.most.J eq $J;
    die if !C.sc.pi && J.most.J ne $J;
    J.most.A || die;
    
    A.ztime = delete C.c.time if C.c.time;
    A.ztime ||= 6;
    
    my @mis = grep{!A.note.c->{$_}}keys %{C.c};
    @mis=grep{$_ ne'J'}@mis;
    if (@mis) {
        my $cm;
        $cm->{$_} = C.c->{$_} for @mis;
        #sayyl "Spesh J.name :  ".ki $cm unless J.yt.quiet;
        A.preg = $cm;
        A.ztime = 9;
    }
    
    my $now = hitime;
    my $from = $now - J.A.last;
    $from = sprintf'%.3f',$from;
    J.A.last = $now;
    
    J.A.time = sub {
        J.most.A.time->(@_);
    };
    
    J.A.ztime ||= C.c.time ? delete C.c.time : 6;
    
    J.A.ztime = 9 if A.ztime = 9;
    
    J.A.in = $G->gip(J.Jiter.A.in, C.t)||{} if J.Jiter;
    
    if (C.sc.pi) {
        J.A.d = J.Jiter.A.d + 1;
        J.name = "J.A.d . C.c.pi*C.t";
        J.d = J.C = $C;
        J.r = C.t."\t".C.y.cv;
        J.bz->("/\t0.9" => "y");
        
        A.time = sub {
            my ($JJ,$v) = @_;
            #A.int->{$v} = F_delta;
            return 1 if $v <= J.A.ztime;
            sayyl "TIME J.A.ztime   $v   of J.name  --- JJ.name  --";
        };
    }
    else {
        sayyl "oA3 J.name   A.ztime / J.A.ztime   $from" if !J.yt.quiet;
        A.time = sub {
             my ($JJ,$wa) = @_;
             A.ztime >= $wa ? 1 : do {
                 #Rw comb oo $J:JJ $A $d $wa;
             sayre "toooocomb $wa/   A.ztime / J.A.ztime   J.name >>>> JJ.name      ";
                 A.jr&vv,$wa;
                 0;
             };
        };
    }
oJ6: | # https://www.youtube.com/watch?v=tL8N_3tln0Y
    my $J = C.sc.J;
    Atime(6) || return T.last=1;
    
    return die "doubly"
    if A.ztime < 9 && A.jr&ok-9;
    
    return Rw opi6
    if exists C.sc.pi;
    
    my $n = A.ztime >= 9 ? sub{} : A.jr&ok-9,9;
    
    aft { $@ && do{sayre" BONG"for 1..10}; $n->(); };
    
    saybl "oJ6 C.t" unless 0 && C.sc.J.yt.quiet;
    {
        my $ar = {%{C.c}};
        Rw around + $A $C $J $T;
    }
    A.roundi = 1;
       
waz/up: |
    if (!J.yt.nohead) {
        Rw Jhead;
        Jn(st=>0.9=>"o",'%hs:8427,fs:4');
    }
    die wdump [ sort keys %$ar ] if !ar.T;
    Rw oT6 + $p=*/M $J $A:J.A $C:J.C $T;
opi6: |
    $J = C.sc.J||die;
    J.cv = C.c.gp.cv || C.c.cv || 0.6;
    die'csnod' if $C ne J.C;
    
    my $path = C.sc.pi||die'nopi';
    $path = 'text' if J.A.d > 7;
    my $pin = "pi/$path";
    
    my $s = C.c.s;
    die wdump [ sort keys %$ar ] if !ar.T;
    Rw oT6 $pin $A $C $J $T $s $u:s;
oT6: |
    A.coi = Rw pha $J ako;
    if (exists C.sc.pi) {
        A.time = sub {
            my ($JJ,$v) = @_;
            # then-is
            # crux to pi
            # point to give up
            # so can much very, sculpt
            if ($v == 2) {
                A.ico = Rw pha $J ico;
                A.ico.qui = 1;
                A.ico.as->(A.coi);
                my $wt = A.ico.exactl->();
                saybl "The two! of J.name   by JJ.name";
                saybl "At 222 J.name    //// C.t  "
                .wdump 2, [wt.same,wt.new,wt.diff,wt.gone] if !wt.same;
                
                return 0 if wt.same; # & not too long ago
                
                # for jamcs screenfly
                J.most.R.ljm = [];
                return 1;
            }
            A.int->{$v} = F_delta;
            return 1 if $v >= J.A.ztime;
            sayyl "TIME J.A.ztime   $v   of J.name  --- JJ.name  --";
        };
    };

    my $M=[];
    my $y = {o=>$M};
    
    my $tw = Rw huck + $M $y; 
    $tw || die "nothing! J.name";
    die "many".ki $tw if keys %$tw > 1;

    Jn('zoo',$y) if @$M;
    
    if (A.ico && A.ico.wt.same) {
        my $cut = @{A.ico.ord};
        my @cc = @{A.coi.ord};
        if (@cc > $cut) {
            warn"J.name entered stuff after 2!".wdump [@cc, 
            '                 =============', @{A.ico.ord}];
        }
        A.coi.abandon->();
        if (my $ljm = J.most.R.ljm) {
            for my $ar (@$ljm) {
                ar.noR=1;
                Rw jamsc;
            }
        }
        sayre "Skipping out on J.name           J.most.J.name";
        T.last = 1;
    }
    else {
        A.coi.qui = J.name ne 'Wkcs';
        my $wt = A.coi.exactl->();
        if (wt.same) {
            if (++A.wch > 4) {
                A.wch = 0;
            }
            else {
               sayre "Skipping out on J.name    A.ztime t:A.wch     J.most.J.name";
                T.last = 1;
            }
        }
    }
    
oJ7: |
    return
    Rw opi7
    if ar.A && ar.C.sc.pi;
    
    
    my $J = C.sc.J;
    return if A.roundi;
    
    say "oJ7 J.name" unless J.yt.quiet;
    Rw oJ $J geo &up $noesc=1;
    my $eo = J.most.eo;
    $eo || die "noeo: J.name";
    Rw $eo $J;
opi7: | # MOD pi     out cup           # REF JOIN A.c/sc
    my $J = C.sc.J;
    
    my $aj = Rw J.most.eo $J $catj=1;
    
    die aj.s if aj.s;
    #sayre "Upto J.r go ".slim 70, sjson aj.c if @{aj.c};
    J.Ec = [@{aj.c}];
    
    
    aft { 
    $@||return;
    sayre wdump 9, aj.c;
    say "J.name :::::::::::: ".ki $C;
    };
    sjson(aj.c);
    
    
    die wdump $aj if @{aj.sc};
       
oJ75: | # chov J
    if (C.sc.pi) {
        die wdump $C if !ref C.sc.J;
        $v = C.sc.J || die'enoJ'.C.t;
        die "Pi v.r has s" if v.s;
        delete at.s if defined at.s;
        die wdump $C if !ref v.Ec;
        die "Pi v.r no .Ec" if !@{v.Ec};
        acum $at, 'Esc', $_ for @{v.Ec};
    }
    else {
        #say "AM v.name  rrrrr J.name";
        at.s = "Vrrr v.name";
    }
ok5: |
    my $J = C.sc.J||die;
       A.ztime = 1;
       A.note.not&csrm,'ok';
       
       my $co = A.jr&ok-$v;
       my $til = $co - hitime;
       # cv wave column to plant next self in
       A.waov = $v;
       # assume that v shapes delay until DNS of tension
       my $del = $v;
       if ($co && $til < 0) {
           sayre "running late: ". $til if $til < -0.1;
           A.ztime = $v if $v > A.ztime; # on there
           undef $co;
       }
       elsif (!$co) {
           $del = 0.1;
           sayyl "C.t begins";
       }
       $del *= 3.7;
       $del *= 1.2 if rand 5 > 3;
       $co ||= $del + hitime;
       
       A.watime = $co;
       die "yep";
       
       say "!! $til for A.ztime   ".ki C.c;
       A.jr&ok-$v,$co;

