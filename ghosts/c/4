TheKnobbies: |
    u allsvse
    
    n lumquest =>5=><<''
         J.lum.lev->("knobs\t0.08" => sub {
             my $J2 = shift; 
             J2 bz lable 0.1 "knobs "
             J2.lev->("knobs\t0.2" => sub {
               my $J3 = shift;
               J3 bz slide 0.2 "<input type=range min=1 value=$cra max=9 step=0.25>", "%ishtml"=>1, "%idly" => 'slide', '%css'=>'font-size:50%'
             });
         }); 

    n stylesheest =>5=><<''
            input[type=range] {
                -webkit-appearance: none;
                background: black;
                height: 2px;
            }
            input[type=range]::-webkit-slider-thumb {
              -webkit-appearance: none;
              background: url(i/copper_anodes.jpg);
              height: 12px;
              width: 12px;
              border-radius: 6px;
              cursor: crosshair;
              box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d;
            }
       

Oscgrin: |
    u allacgts
    
    J.V = 2;
    n mksc =>''=><<''
        my $t = I.d&mos,C.c;
        while(my($k,$v) = each %$t) {
            C.sc.>$k = $v;
        }
        return;
        
    # language expansion
    n mos =>''=><<''
        my @t = split ',',$s;
        for (@t) {
            my ($k, $v) = split ':', $_;
            $T.>$k = $v;
        }
    
    n meat =>''=><<'',{acgt=>'k,v'}
        my $f = $v;
        my $mv = C.sc->{$k};
        $f = I.d&mean,$f,$mv;
        C.sc->{$k} = $f;

    n mean =>''=><<'',{acgt=>'to,fro,mix'}
        $mix ||= 0.5;
        my $yu = $fro - $to;
        $yu = $yu * $mix;
        $fro -= $yu;
        $fro
    
    # it
    n cole =>''=><<''
        my $h;
        (h.r, h.g, h.b, h.a) = ($1, $2, $3, $4)
            if $s =~ /^(\w)(\w)(\w)(\w)?$/ || die "not cole: $s";
        if (defined h.a) {
           # do an rgba(255,255,255,1)
           for my $k (qw'r g b a') {
               my $e = $h->{$k};
               $e = "$e$e" if length $e == 1; # out of 255
               $h->{$k} = hex $e;
           }
           h.la = sprintf '%.2f', h.la / 255; # out of 1
           return "rgba(h.r,h.g,h.b,h.a)";
        }
        else {
           return sprintf "#%s%s%s", h.r, h.g, h.b;
        }
    
    # ray lih, unhassley
    n hsle =>''=><<''
        my @m;
        for ($s) {
            @m = split ' ', $_;
            last if @m == 3 || @m == 4;
            @m = split /\./, $_;
            last if @m == 3 || @m == 4;
            @m = split '', $_;
            last if @m == 3 || @m == 4;
            @m = ();
        }
        @m || die "not hsle: $s";
        my $h;
        (h.h, h.s, h.l, h.a) = map{0+("0.".$_)}@m;
        .
        h.h = h.h * 360 if h.h < 1;
        .
        $h->{$_} = ($h->{$_}*100).'%' for 's','l';
        .
        my $al = ", h.a" if defined h.a;
        "hsl".($al?'a':'')."(h.h, h.s, h.l$al)";
    
    # decide space unit TODO init soon
    n empc =>''=><<''
        $s .= 'em' if $s !~ /(%|em|px)/;
        $s =~ s/^-?0em$/0%/;
        $s
    
Oscapps: |
    u allsvse
    n '','','%of:Not'
    # all but intercepted sc is sc
    # 
    
    n nspc =>2=><<''
        my $J = C.sc.J;
        my $squ = C.sc.yspc || J.d.y.spc;
        my $ratio = $squ / $s;
        my $sl = sprintf '%.2f', $ratio;
        my $cl = 0.02;
        my $max = C.sc.nspc_max || 1;
        $sl = $max if $sl > $max;
        if ($sl > 1+$cl || $sl < 1-$cl) {
            saybl "Abo nspc $sl";
            return;
            C.sc.geo ? 
            C.sc.geo.scale = $sl
            :
            C.sc.tr.scale = $sl;
        }
    
    n enid =>59=><<''
        at.id = $s;
        at.c.nobody = 1; 
        at.t = j.l;
        #say "enid j.l ::::  C.sc.at.sc.ab   ".k2 $at;
        at.sc.ab = '100';
        .
        if (my $J = C.sc.J) {
            die "DIffnoiw";
            my $aj = C.sc.J.oJ.A.W->[-1];
            my $l = aj.c->[0];
            if (!aj.sent && ref $l) {
                my ($t,$y,$c,$sc) = @$l;
                if ($t eq j.l) {
                    die if c.id ne at.id;
                    %$sc = (%$sc,%{at.sc});
                    at._aux = 1;
                }
            }
        }
    
    n css =>555=><<''
        $s = join ';', map{"$_:$s->{$_}"} sort keys %$s if ref $s eq 'HASH';
        for my $set (split ';', $s) {
            my ($k,$s) = split ':', $set;
            at.sc.css->{$k} = $s;
        }
    
    n src =>556=><<''
        at.c.src = $s;
    
    # long range stuff reporting, use A.sv the toplevel intergatr
    # like sort by A.sv length and number
    # also putting a particular object behind an id... blessing
    # weird sortes is the ways
    # even urls are like this, we making up a short url or so
    # keeping bits of short urls percolating up from where
    # wants to find C, which may unify to ...
    n idly =>58=><<''
        my $id = mkuid();
        my $qual = '';
        at.c.id && sayre "Blessing C.t with $qual ($id -> at.c.id)";
        at.c.id = $id;
        #J.idyl->($J, $id, $j);
        sayre "idly C.t  J.name J.r    ".ki C.sc;
        
    n lp =>5=><<''
        at.c.ht = 1;
    
    n ishtml =>5=><<''
        at.c.ht = 1;
        
    n tt =>5=><<''
        at.c.title = $s;
        
    n canvas =>5=><<''
        at.c.canvas = $s;
        
    n type =>51=><<''
        at.c.type = $s;
        at.c.ht = 1;
        sayre "at.t at.y cannot have a title: $_" for grep{defined} delete at.c.title;
        
    n tag =>5=><<''
        at.c.tag = $s;
        
    n at =>5=><<''
        die;
        $s =~ /^(?:(\S+):)?(\S+)$/;
        $at->{$1} = $2;
        
    n atrp =>5=><<''
        die "heloarp";
        at.rp = $s;
        
    n path =>5=><<''
        # to compuile J.ys
        
    n origin =>5=><<''
        # better than W via c pi and W
        
    n pwar =>5=><<''
        # to suggest
        
    n Joint =>5=><<''
        # Something
TheAttractor: |
    u allsvse
        
    m @$_
    for @{Load(<<'')}
     -
      - sz
      - 3.1
      - |
        my $si = length(C.c.s);
        ($s, my $lim) = split '/',$s;
        my $di = $s/$si;
        $di = $lim if $lim && $di > $lim;
        I.d&meat,fsi=>$di;
        I.d&meat,fsi=>1 if $di > 2;
        return;
        #        $fs = "font-size:$fs%;";
        #        if ($si > $tev) {
        #            $text = ($text=~/^(.{$tev})/s)[0];
        #        }
     -
      - deco # splurge many, get this pipe sorted...
      - 3.2
      - |
        at.sc.css->{"text-decoration"} = "underline";
     -
      - is # colour from value spinner
      - 3.2
      - |
        my ($t,$z) = split ':', $s;
        $z ||= C.c.s;
        my $i = sum map { ord $_ } split '', $z;
        $i -= 9 until $i < 10;
        C.sc.hs = "${i}75";
     -
      - mu # timers
      - 3.2
      - |
        if ($s eq 'g') {
            C.c.s || die "nos : ".wdump 2, $C;
            C.c.s = Rw mugwu $d:C.c.s;
            C.sc.hs ||= "576";
        }
        else {
            die "how mu $s? C.s";
        }
     -
      - poi # pointer-events
      - 3.2
      - |
        at.sc.css->{"pointer-events"} = ($s =~ /^([1ay])/ ? 'all' : 'none');
     -
      - at # fossicks
      - 3
      - |
         $at.>$_ = $s.>$_ for keys %$s;
     -
      - tag #
      - 3
      - |
         at.tag = $s;
     -
      - sha # it
      - 3
      - |
         my @m = split m/\s/, $s;
         $m[-1] = I.d&cole,$m[-1];
         at.sc.css->{"text-shadow"} = sprintf '%dpx %dpx %dpx %s', @m;
     -
      - co # it
      - 3.3
      - |
        at.sc.css->{"color"} = I.d&cole,$s;
     -
      - hs # color: hsla
      - 3.3
      - |
        at.sc.css->{"color"} = I.d&hsle,$s;
     - #c ground etc
      - zi 
      - 3
      - |
        at.sc.css->{"z-index"} = 0+$s;
     -
      - zig # it alley, primary, ground
      - 3
      - |
        at.sc.css->{"z-index"} = 0+($s-20);
     -
      - zie # suuuuuu, ether
      - 3
      - |
         at.sc.css->{"z-index"} = 0+($s-10);
     -
      - bgi # background image
      - 3.2
      - |
         at.sc.css->{"background-image"} = "url('$s')";
     -
      - bg # background something
      - 3.2
      - |
         at.sc.css->{"background"} = "$s";
     -
      - bgh # background hsla
      - 3.2
      - |
         at.sc.css->{"background-color"} = I.d&hsle,$s;
     -
      - fsi # it
      - 6.9
      - |
         at.sc.css.>font-size = int($s*100).'%';
     -
      - fs # it
      - 7
      - |
         $s *= 9;
         at.sc.css.>font-size = int($s).'%';
     -
      - fw # it
      - 7
      - |
        at.sc.css->{"font-weight"} = int($s*100);
     -
      - ws # it
      - 7
      - |
        if ($s eq 'p') { 
            $s = 'pre';
        }
        if ($s eq 'n') {
            $s = 'nowrap';
        }
        at.sc.css->{"white-space"} = $s;
     - #c filterszzzz weird style using com to agg.
      - opa # seetrhu
      - 3
      - |
         at.sc.css->{"opacity"} = $s;
     -
      - tro #
      - 3.6
      - |
        at.sc.css->{"transform-origin"} = $s;
     -
      - rad # radial tr
      - 3.6
      - |
        C.sc.tr.rotate = $s.'rad' if $s;
     -
      - scale # zzz tr
      - 3.6
      - |
        C.sc.tr.scale = $s;
     -
      - tr # filterszzzz weird style using com to agg.
      - 3.7
      - |
        at.sc.css->{"-webkit-transform"} = join' ', map {"$_($s->{$_})"} keys %$s;
     -
      - of
      - 3.7
      - |
        C.sc.css->{"-webkit-filter"} = join' ', map {"$_($s->{$_})"} keys %$s;
     -
      - blr # it
      - 3.6
      - |
        C.cs.of.blur = $s.'px';
     -
      - sat # it saturation
      - 3.6
      - |
        C.cs.of.saturate = $s;
     -
      - con # it contrast
      - 3.6
      - |
        C.cs.of.contrast = $s;
     -
      - bri # it bright
      - 3.6
      - |
        C.cs.of.brightness = $s;
     -
      - hue # it bright
      - 3.6
      - |
        C.cs.of->{'hue-rotate'} = $s.'deg';
     -
      - sep # it old
      - 3.6
      - |
        C.cs.of.sepia = $s;
     -
      - inv # it old
      - 3.6
      - |
        C.cs.of.invert = $s;
     -
      - gray # it old
      - 3.6
      - |
        C.cs.of.grayscale = $s;
     - #c limbic space
      - ls # it
      - 3
      - |
        C.sc.css->{"letter-spacing"} = g.empc->($s);
     -
      - lh # it
      - 3
      - |
        C.sc.css->{"line-height"} = g.empc->($s);
     -
      - ml # it
      - 3
      - |
        C.sc.css->{"margin-left"} = g.empc->($s);
     -
      - mr # it
      - 3
      - |
        C.sc.css->{"margin-right"} = g.empc->($s);
     -
      - mt # it
      - 3
      - |
        C.sc.css->{"margin-top"} = g.empc->($s);
     -
      - mb # it
      - 3
      - |
        C.sc.css->{"margin-bottom"} = g.empc->($s);
     -
      - m # margrin
      - 3
      - |
        C.sc.css->{margin} = $s;
     -
      - right # yep
      - 3.4
      - |
        C.sc.css->{right} = $s;
     -
      - left # yep
      - 3.4
      - |
        C.sc.css->{left} = $s;
     -
      - top # yep
      - 3.4
      - |
        C.sc.css->{top} = $s;
     -
      - bottom # yep
      - 3.4
      - |
        C.sc.css->{bottom} = $s;
     -
      - mw # y
      - 3.4
      - |
        C.sc.css->{"max-width"} = $s;
     -
      - mh # y
      - 3.4
      - |
        C.sc.css->{"max-height"} = $s;
     -
      - miw # y
      - 3.4
      - |
        C.sc.css->{"min-width"} = $s;
     -
      - width # y
      - 3.4
      - |
        C.sc.css->{"width"} = $s;
     -
      - height # y
      - 3.4
      - |
        C.sc.css->{"height"} = $s;
     -
      - over # y 
      - 3.4
      - |
        C.sc.css->{"overflow"} = $s;
     -
      - float # y 
      - 3.4
      - |
        C.sc.css->{"float"} = $s;
     -
      - bo # border
      - 3.4
      - |
        C.sc.css->{"border"} = $s;




Sight: |
    n stylehut
    n styleomi
    n stylation
    n stylers
    n stylext
    J.inV = 1;
    #n lim=>pi=>'g/c/84'
    # could ahh...
    J.V = 1;
    n JSlines =>$J
    
pi/lim: |
    n file=>pi=>{mtime=>1=>s=>$s}
    y.at.distorb = 'J/mo/J';
alljs: |
    n 'allarejs=s'=>2,{s=><<''},{code=>'In 42'}
        C.sc.acgt = 's' if !exists C.sc.acgt;
        C.sc.js = 1;
alljse: |
    n alljs
    n 'allarejse=s'=>2,{s=><<''},{code=>'In 419'}
        return T.not = 1 for
            map { A.J.A.vse->{$_} = C.c->{$_} }
            grep {exists C.c->{$_}} qw'of nk';
        my $av = A.J.A.vse;
        C.sc.of ||= av.of||'om';
        C.sc.nk ||= av.nk||'sc';
        C.sc.gk ||= C.t;
        my $cv = C.y.cv || 1;
        $cv =~ s/^0\.//;
        C.t = C.sc.of."_".C.t."_".$cv;
reJSlines: | # could spiral intuit re$W to just this - A coney islands
    y.at.ressur = 'JSlines';
JSlines: |
    y.at.jslines = 1;
    y.ope = 1;
    n $C
thank: | # J, as self consuming other, s=other, !e
    # I.d&take,$s
    # does its own phasing
    say "thank J.name ! ";
    my $oJ = C.c.s;
    ref $oJ && oJ.bb || die "NoJ:".ki $oJ;
    my $so = J.oJ->{oJ.name} ||= {};
    # mong beans
    # is {M:name,W:id} coupling, so pi is {file:g/c/1} etc
    my $Y = oJ.El.Duv;
    my $rv = Y.rv;
    if (@{rv.sc}) {
        sayre "J.name SLI!P!P!ING SC !!! !!! !!!" for 1..5;
        sleep 4;
    }
    if (rv.i eq so.rv.i) {
        say "J.name receiving same oJ.name";
        return;
    }
    so.rv = $rv;
    my $N = [@{rv.c}];
    # get that banjo
    @$N = Rw humms $J $N wongui _;
    @$N = Rw humms $J $N notnotjs _;
    my $S = Rw humms $J $N jscoi;
    my $sc = [@$N];
    #sayyl "J.name from oJ.name:\n". 
    #Rw ZNews $sc $nov=1;
    # feed also cones?
    n $_ =>''=>{pi=>pane=>s=>$S->{$_}} for sort keys %$S;
    # panes
Chang: |
    #u slowmoving
    J.pix = {any=>1,u=>'codeo'};
    u codeo
    y.at.isle = 'u';
    
    #
    n lum
    n bal
    #n stylation
    #y.at.jslines = 2;
    #J.VV.N = 1;
codeo: | # the in osc ^
    u allsvse
    n '','','%of:Art'
    # root lv.II <- at.V.*.rv.II
    # plucked Ktv spots X running upwards
    n code =>5=><<''
        sayyl "Have code     A.J.name the C.t  via ".ki C.sc;
        lv.op.sc.code = 1;
        return sayre "C.t is js running ooze" if !C.sc.acgt;
        my $v = {};
        Rw ym/conoi $A $C:at $G $T $v;
        lv.X = $v;
     
    n J =>7=><<''
        return sayre "BanJ" if C.c.root;
        my $rv = lv.do.Duv || die "Noduv";
        rv.X || sayre "Not Xceiving C.t";
        lv.X && die "Smodwiu X X";q
        lv.X ||= rv.X;
        #lv.do->{V.name} = $rv;
    
    n root =>7=><<'','%nv:croot'
        lv.X ||= vl.X || {My=>"self"};
        my $src = [];
        for my $k (@{C.c.V.os}) {
            my $kv = lv.do->{$k} || die "nondo $k";
            push @$src, [$k,kv.X] if kv.X;
        }
        Rw spII $A $II:lv.X $src;
        #saybl "C.t top:".wdump 4,[lv.X];
        saybl "From: ".join', ',map{$_->[0]}@$src;
    
    n '','','%of:em'
    n isle =>3=><<''
        my $X = C.y.lv.X || die "no X on J.name for isl $isle";
        Rw down $f=$isle/C.t $s:X;
    
jshang: |
    #u slowmoving
    J.pix = {any=>1,u=>'jseo'};
    u jseo
    y.at.isle = 'j';
    
    #
    n jspa
    #n stylation
    #y.at.jslines = 2;
    #J.VV.N = 1;
jseo: | # the in osc ^
    u allsvse
    J.NN.V = 1;
    n '','','%of:Art'
    n js =>2=><<''
        sayyl "Have fopr A.J.name the C.t  via ".ki C.sc;
        lv.op.sc.js = 1;
        return sayre "C.t is js running ooze" if !C.sc.acgt;
        my $v = {}; # spots indexes
        Rw ym/jscoi $A $C:at $G $T $v;
        lv.X = $v;

    n J =>7=><<''
        return sayre "BanJ" if C.c.root;
        my $rv = lv.do.Duv || die "Noduv";
        rv.X || sayre "Not Xceiving C.t";
        lv.X ||= rv.X;
        #lv.do->{V.name} = $rv;
    
    n root =>7=><<'','%nv:croot'
        lv.X ||= vl.X || {My=>"self"}; # disappears
        my $src = [];
        for my $k (@{C.c.V.os}) {
            my $kv = lv.do->{$k} || die "nondo $k";
            push @$src, [$k,kv.X] if kv.X;
        }
        Rw spII $A $II:lv.X $src;
        saybl "C.t top:".wdump 4,[lv.X];
    
    n '','','%of:em'
    n isle =>3=><<''
        my $X = C.y.lv.X || die "no X on J.name for isl $isle";
        Rw down $f=$isle/C.t $s:X;
    
slowmoving: |
    u allvse
    n '','','%of:Mo'
    n J=>435=><<''
        saybl " *" for 1..2;
        saybl " * THink about resu J.name  ".ki $C;
        saybl " *" for 1..2;
EmJSlines: |
    my $N = [@{em.lines||die"Nop"}];
    @$N = Rw humms $J $N wongui _;
    @$N = sort { a.t cmp b.t }
    Rw humms $J $N notnotjs _;
    
    if (C.sc.jslines == 2) {
        sayre "HEavily JSLINES: J.name";
        my ($don,$not);
        for (@$N) {
            ++$don && next if _.sc.args;
            $not++;
            sayre " the _.t  has not been processed .... ".ki _.sc;
        }

        if ($not && !$don) {
            sayyl "In Em jscoi $don done, $not remain";
            my $II = Rw humms $J $N jscoi;
            # N will be changed...
            sayre "DedstilL: _.t   ".ki _.sc 
                for grep{!_.sc.args} @$N;
        }
        elsif (!$not && $don) {
            say "Is good jscoi";
        }
        else {
            die "Mis somewhere".wdump 3, $N;
        }
    }
    
    my $S = Rw humms $J $N spots;
    if (S.X) {
        my $lv = C.y.lv;
        my $vl = C.y.vl;
        if (vl.X) {
            Rw qsp $I:S.X $II:vl.X;
            #sayre "Should under at: ". wdump 3, vl.X;
        }
        lv.X = {%{S.X}};
        delete S.X->{$_} for 'ooI','Ii';
        sayyl "Alltook: ".F_delta();
    }
    
    my $l = em.lines = [];
    push @$l, map{" a\.e(".sjson($_).");"} @{S.z};
    push @$l, Rw JSpots $II:S.X;
    C.c.os = 1 if !grep {/\S/} @{S.z};
    C.sc.Wc = 1;
qsp: | # ensure II underneath I, no-9 X stretcher (jslines alljsers when jslines all lv.X)
    for my $K (keys %$II) {
        die "ooIIi" if $K eq 'Ii' || $K eq 'ooI';
        my $cvs = $II->{$K};
        my @cvs = ();
        for my $cv (keys %$cvs) {
            my $ts = $cvs->{$cv};
            my @ts;
            for my $t (keys %$ts) {
                $I->{$K}->{$cv}->{$t} ||= $ts->{$t};
            }
        }
    }
ym/jscoi: |
    my $s = C.sc.js || return;
    if (C.sc.acgt) {
        sayre "acgt js: C.t already C.sc.args" if C.sc.args;
        C.sc.args ||= join',','A,C,G,T',grep{$_ ne '1'}C.sc.acgt;
    }
    die "wonky C.t   of ".ki $C if C.t =~ /\W/;
    C.sc.args =~ s/ /,/g;
    my $poing = qr/\w+(?:\.\w+)?/;
    C.c.s =~ s/^t\&([^\s;]+)(;)?/!G\&t,$1 and return;/gm;
    C.c.s =~ s/($poing)\&(\$)?(\w+)(,[^\s;]+)?(;)?/
        my $t = $2 ? "$3" : "'$3'";
        my $h = $1 eq 'G' ? ".h(A,C,G,T,$t" : "\[$t\](A,C,G,T";
        $1.$h."$4)$5"
    /smge;
    C.c.s =~ s/^(.+) \|\|\= (.+)(;)?$/if (!$1) {
        $1 = $2
    }/gm;
    C.c.s =~ s/^(.+?) and (.+)(;)?$/if ($1) {
        $2
    }/gm for 1..3;
    C.c.s = "a.".C.t." = function(".C.sc.args.") {\n".C.c.s."};\n";
    C.sc.dige = slm 12, dig C.c.s;
    delete C.c.from; # as 7, S over
    $v->{js}->{C.y.cv}->{C.t} = $C;
JSpots: |
    my @sup;
    for my $K (sort keys %$II) {
        die "ooIIi" if $K eq 'Ii' || $K eq 'ooI';
        my $cvs = $II->{$K};
        my @cvs = ();
        for my $cv (sort keys %$cvs) {
            my $ts = $cvs->{$cv};
            my @ts;
            for my $t (sort keys %$ts) {
                my $D = $ts->{$t};
                my $s = {%{D.sc}};
                die "collajsee s.args".ki $D if s.args ne 'A,C,G,T,s';
                delete $s->{$_} for qw'of acgt args dige lines js';
                push @ts, [$t,$s];
            }
            push @cvs, [$cv, \@ts];
        }
        push @sup, sjson({eine=>[$K,\@cvs]});
    }
    @sup
ym/spots: |
    v.i ||= 0;
    v.X->{C.sc.of}->{C.y.cv}->{C.t} = $C if C.sc.of; # vetc
    v.Z->{v.i} = $C;
    push @{v.z||=[]}, $v->{l}->{v.i++} = C.c.s;
    
stylehut: |
    u alljs
    
    n e =>''=><<'',{args=>'e'}
        if (!q)
            console.log("xut "+e);
        var m;
        try { m = eval(e); }
        catch (er) { a.er(e, er); }
        m
    
    n er =>''=><<'',{args=>'e,er'}
        console.log("xutbang: ", e, er);
        var ej = {er: {e: e}};
        if (er && er.message)
            ej.er.m = er.message;
        s.reply(ej);
        a.m("!"+ (ej.er.m || e));
    
    n m =>''=><<'','%args:e'
        var d = e.substr(0,1);
        if (d == " ") {
          a.e(e);
        }
        else if (d == "[" || d == "{") {
          var N = $.parseJSON(e);
          console.log("gooftoes ", N);
          a.om({},N,a,{});
        }
        else {
          if (d == ".")
            e = '<span style="font-size:66%">'+e+'</span>';
          a.c(e);
        }

    n c =>''=><<'','%args:e'
        $('#msgs').prepend(e+"\n");
    
    n yl =>''=><<'',{args=>'delay,func'}
        setTimeout(func, delay);

    n ks =>''=><<'','%args:s'
        var ks = [];
        for (var k in s) {
            ks.push(k);
        }
        return ks.join(',');
    
styleven: |
    u alljs
    
    n entag =>''=><<'',{args=>'d,tag'}
          d.name = tag.attr('name');
          var ids = [];
          while (tag.length) {
              var nam = tag.prop('tagName');
              var id = tag.attr('id');
              if (!d.id && id)
                  d.id = id;
              if (id)
                  ids.unshift(id);
              if (nam === 'WW') {
                  d.W = id;
                  d.ux = ids[1];
                  break;
              }
              tag = tag.parent();
          }
          d.ids = ids;
styleomi: |
    u alljs
    
    n sca =>''=><<''
        while (s > 1) {
            s = s / 10;
        }
        return s;
    
    n f =>''=><<''
        var t = '';
        s and t=s
        var at = '';
        C.y.cv and at += "cv='"+C.y.cv+"'";
        t || at || console.log("No attach: "+T.alk);
        return $(A.on).find(t+'['+at+']');
    
    n inC =>''=><<''
        C = s;
        C.constructor == Array and C = {t:C[0],y:C[1],c:C[2],sc:C[3]};
        else
        C.constructor == Object and $.each(C,function(k,v) { G&$k,v }); T.not = 1;
        else
        typeof C === 'string' and C = {c: {s: C}};
        typeof C.c === 'string' and C.c = {s: C.c};
        typeof C.y === 'string' and C.y = {cv: G&sca,C.y };
        !typeof C.t === 'string' and console.log('queda',C);
        C.c ||= {};
        C.sc ||= {};
        return C;

    n h =>''=><<'',{acgt=>'way,s'}
        if (!G[way])
            throw "No way: "+way
        return G[way](A,C,G,T,s);
    
    # A falls, A.on taps each-for thing, A.W holst selves, usu not
    n An =>''=><<''
        var A = $.extend({},A);
        A.I = {};
        A.mo ||= A;
        T.d ||= 1;
        s and var k = 'e_'+s; A.e = G[k];
        return A
    
    n t =>''=><<''
        T.not and return 0;
        A.I.cv = G&sca,s;
        G&ex,A.I;
        return 1;
    
    n ex =>''=><<''
        s.ei ||= 0;
        while (1) {
            var v = A.e[s.ei];
            !v and return
            v[0] > s.cv and return
            s.ei++;
            $.each(v[1],function(i,D){
                var t = D[0];
                var sc = D[1];
                sc.nk and !C[sc.nk] and return
                sc.gk and !C[sc.nk][sc.gk] and return
                var es;
                sc.gk and es = C[sc.nk][sc.gk];
                G&$t,es;
            });
        }
    
    n Win =>''=><<''
        var W = ww[s];
        if (!W) {
            a.c("new W: "+s);
            W = ww[s] = {};
            W.Wid = s;
            W.A = {};
            W.A.W = W;
            //W.A.p = new paper.Project();
        }
        //W.A.p.activate();
        return W;
    
    n eine =>''=><<''
        var K = s[0];
        var e = s[1];
        var k = 'e_'+K;
        G[k] = e;
    
    # persona perforthe webclient channels
    # so the G copies and lives from/to W
    # h reach up/down to applied layers of you
    # top level mirage is o(ww,Wid,$s) 
    # which ins ww (G.Wid for Oth), J.id (Wid)
    # and the difference is you
    
    n om =>''=><<''
        A = G&An,'om';
        C = G&inC,C;
        t&2;
        T.alk = 'w'+T.d+' '+C.t+' '+a.ks(C.c)+'%'+a.ks(C.sc);
        C.sc ||= {};
        C.sc.css ||= {};
        C.sc.anc ||= {};
        t&7;
    
    n nn =>''=><<''
        A.W.bb ||= {};
        A.bb ||= A.W.bb;
        if (s) {
            a.c("Cinfdo");
        }
        A.bb[C.y.cv] ||= {};
        A.bb[C.y.cv][C.t] ||= {};
        return A.bb[C.y.cv][C.t];
    
stylation: |
    u alljse
    n '','','%nk:c'
    # $(A.on).fadeOut(delay, function() { $(this).remove(); });
    
    n W =>28=><<''
        A.on = $('#'+C.c.W);
        !$(A.on).length and a.c(T.alk+"  noW: "+C.c.W);
        var W = G&Win,C.c.W;
        $.extend(A,W.A);
    
    n nobody =>31=><<''
        A.on = $('#'+C.c.nobody);
        !$(A.on).length and a.c("no nobody at "+C.c.nobody);
    
    # whole time... (make whote, A.t&4 ex inness..
    n el =>3=><<''
        C.sc.attr ||= {};
        var last;
        var t = C.t.replace(/\W/g,'e');
        t.length < 4 || 1 and t = 'n'+t+'n';
        var el = G&f,t;
        s == '1' || s == '9' and $(el).remove();
        s == '8' and return A.on.aft = el;
        !el and console.log("Cno find el="+el+": "+C.t+"  of "+C.y.cv);
        if (s == '1') {
            C.sc.attr.cv = C.y.cv;
            C.c.tag and t = C.c.tag;
            var div = $("<"+t+">", C.sc.attr);
            $(div).appendTo(A.on).each(function(i,v){el=v});
        }
        delete C.sc.attr;
        .
        A.bb = G&nn;
        if (A.bb.cod) {
            C.c.cod ||= '3';
        }
        if (typeof C.c.s === 'string' && !C.c.cod) {
            C.c.ht and $(el).html(C.c.s);
            else
            $(el).text(C.c.s);
        }
        A.on = el;
   
    n el =>4=><<''
        var f = ['id','src','dig'];
        var fl = function (v,z) {
            C.sc.attr and C.sc.attr[v] = z;
            else {
                $(A.on).attr(v,z);
            }
        };
        $.each(f,function(i,v) {
            C.sc[v] and fl(v, C.sc[v])
            else
            C.c[v] and fl(v, C.c[v])
        });
stylers: |
    u alljse
    
    n geo =>5=><<''
        s = s.split(' ');
        var aung = s[0].match('^a(\\d+)');
        if (aung) {
            s.shift();
            aung.shift();
            C.sc.ab = aung.shift();
            //absolu
        }
        s = {x:s[0],y:s[1],rad:s[2],scale:s[3]};
        C.sc.css.top = (s.y * 100)+'%';
        C.sc.css.left = (s.x * 100)+'%';
        C.sc.css['transform-origin'] = '0% 0%';
        C.sc.css['transform'] = 'rotate('+s.rad+'rad)';
        if (s.scale)
            C.sc.css['transform'] += ' scale('+s.scale+')';
    
    n ab =>51=><<''
        if (s === '100') {
            C.sc.css.width = '100%';
            C.sc.css.height = '100%';
        }
        C.sc.css.position = 'absolute';
    
    n z =>6=><<''
        $.each(s, function(i,v) {
            //a.yl(1, function () { 
            G.om(A,v,G,{d:T.d+1});
            //});
        });
    
    n cssdel =>589=><<''
        var re = s.split(',');
        $.each(re,function(i,v){ delete C.sc.css[v] });
    
    n css =>59=><<''
        if (typeof s === 'string') {
            var re = s.split(';');
            s = {};
            $.each(re,function(i,v){
                var kv = v.split(':');
                s[kv[0]] = kv[1];
            });
        }
        $.each(s, function(i,v) { $(A.on).css(i, v); });
    
    n anc =>59=><<''
        $(A.on).animate(C.sc.anc, (C.sc.ant||900));
    
stylext: |
    u alljse
    n '','','%nk:c'
    
    n cod =>59=><<''
        var cm = A.bb.cod;
        .
        if (typeof s === 'string') {
            if (s === '3') {
                !cm and return a.c('no cod !');
                s = {};
            }
            else {
                s = {mode:'perl'};
                cm = 0;
            }
        }
        .
        var def = {mode:'perl',theme:'midnight',lineWrapping:true};
        var set = $.extend(def, s);
        cm and $.each(set,function(k,v){ cm.setOption(k,v) });
        !cm and cm = CodeMirror(A.on, set);
        A.bb.cod = cm;
        .
        if (C.c.s) {
            C.c.s !== A.bb.jus and cm.setValue(C.c.s);
            else { a.c('vv vv'+C.t); }
        }
        cm.refresh();
        .
        var sav = function(){ 
            G&codsav,cm;
        };
        cm.setOption('extraKeys', {Esc:sav});
        cm.on('focus',function(){a.c('Cofuc');clof();keof();});
        cm.on('blur',function(){a.c('Cofus');clon();keon();sav();});
    
    #    $('#'+id).css('width','15em','max-height','70%','overflow','scroll');
    #    $('#'+id+' > .CodeMirror');//.css('height','auto');
    
    u alljs
    n codsav =>''=><<''
        var cm = s;
        a.c('AA AA '+C.t);
        var d = {};
        a.entag(d, $(A.on));
        A.bb.jus = d.code = cm.getValue();
        d.dig = $(A.on).attr('dig');
        a.ethro(d, ws);
        console.log(d);
Canvasc: |
    u alljs
    # & sitting
    die 'relartd';
    
    n ps =>''=><<'','%args:s'
        with (paper) {
          try {
            eval(s);
          }
          catch (er) {
            a.er(s, er);
          }
        }
    
    n doya =>''=><<''
        # animation frame
        console.log('de rock'); 
        // and!
        // etc https://github.com/tweenjs/tween.js/blob/master/docs/user_guide.md
    
    n pzl =>''=><<''
        with(paper){
            var shape = new Path.RegularPolygon(view.center,3, 100);
            .
            shape.fillColor = '#8C8A00';
            view.onFrame = function (event) {
                shape.rotate(1);
                shape.fillColor.hue += 1;
                .
                shape.position.x += shape.bounds.width / 50;
                if (shape.bounds.left > view.size.width) {
                    shape.position.x = -shape.bounds.width;
                }
            }
        }
    
    n sitandspin =>''=><<''
        with (paper) {
            var project = new Project;
            var mousePoint = view.center;
            var amount = 30;
            var colors = ['red', 'black', 'blue', 'black'];

            for (var i = 0; i < amount; i++) {
                var rect = new Rectangle([5, 0], [25, 25]);
                rect.center = mousePoint;
                var path = new Path.Rectangle(rect, 6);
                path.fillColor = colors[i % 4];
                var scale = (1 - i / amount) * 25;
                path.scale(scale);
            }

            view.onMouseMove = function (event) {
                mousePoint = event.point;
                a.m('mm!');
            }

            var children = project.activeLayer.children;
            view.onFrame = function (event) {
                paper.uplg.update(event);
                
                for (var i = 1, l = children.length; i < l; i++) {
                    var item = children[i];
                    var delta = (mousePoint - item.position) / (i + 5);
                    item.rotate((Math.sin((event.count + i) / 10)+0.617) * 3);
                    if (delta.length > 0.1)
                        item.position += delta;
                    item.fillColor.hue += 1;
                    var shape = item;
                    shape.position.x += shape.bounds.width / 50;
                    if (shape.bounds.left > view.size.width) {
                        shape.position.x = -shape.bounds.width;
                    } 
                }
            }
        }
    
Funstuff: |
    u alljs
    # paperscope (with (paper) {...}) FUN STUFF! spines!
    
    n funstuff =>''=><<''
        project.clear(); 
        a.sitandspin();
        //a.pzl();
    
    # pAaq2_PkypY?t=24
    # http://jsfiddle.net/M78zz/
    n Re =>''=><<''
        // <div id="ytplayer"></div>
    
    n yt =>''=><<''
        var d = {};
        d.playerVars = C.c || {};
        d.height = '390';
        d.width = '640';
        d.videoId = C.t;
        console.log(' yepeppp', C);
        etc.pla = A.player = new YT.Player('ytplayer', d);
        console.log(' yepeppp', d, A.player);
    
    # compression jsc ^, js v
    n ytapi =>''=><<''
        // makes element src: https://www.youtube.com/player_api
    
    n ytr =>''=><<''
        //$('canvas#display').attr('width'=>'100%', height=>'100%');
        function onYouTubeIframeAPIReady() {
            etc.ytread = 1;
        }
JSosC: |
    u allsvse
    
    n args =>5=><<''
        # quack
    
    n jsc =>5=><<''
        my $args = cs.args || 'A,C,G,T';
        at.c = 'e';
        at.s =  "a.".j.l." = function (".$args.") {\n".at.s."};\n";
    
    n js =>5=><<''
        if (1 || cs.src) {
            at.tag = 'script';
            at.type = cs.type || 'text/javascript';
            at.title = undef;
            at.src = cs.src if cs.src;
        }
        else {
            at.c = 'o';
            at.s =   [J.id, 'do', at.s];
        }
    
    n st =>5=><<''
        at.tag = 'style';
        at.type = 'text/css';
    
    n ps =>5=><<''
        at.c = 'o'; # etc
        at.s = [J.id, 'ps', at.s];
        at.pur = 1; # TODO local lumi
    
    n yt =>5=><<''
        my $n = {};
        (n.t, my $ma) = split /\?/, $v;
        $ma = {map{split '=', $_, 2}split '&', $ma};
        .
        n.c.autoplay = 1 if ma.t;
        n.c.start = ma.t if ma.t;
        .
        #die "$v   :". wdump $n;
        at.pur = 1; # TODO local lumi
        at.c = 'o';
        at.s = [J.id, yt => [n.t,n.y,n.c,n.sc]];
        #<iframe width="420" height="315" src="https://www.youtube.com/embed/DyVnwKcb0YY#t=958" frameborder="0" autoplay="1" start="958" allowfullscreen></iframe>

