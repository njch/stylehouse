stylehut: |
    u perl/file
    n ACGT
    n doi=>'',<<'','%code=1'
      Rw j phon;
    
ACGT: |
    
lazershop: |
    #my $g = Rw Jto Gee;
    Rw j - Gee;
    
phon: |
    n Jh=>0.01
    n lazershop
Jh: |
    n J.name=>1,J.name
    
j: |
    my $J = ar.J ||= G.eoin ||= Rw Jto - sea;
    my ($t) = @{delete ar.m};
    say "Look for $t in J.name";
    return if $t eq 'qq';
    
    #u somewhereei
    
    my ($s) = Jn('','',{W=>$t});
    return s.sc.J||die "no sc J".wdump 3,[$t,$s];
    
    
somewherei: |
    u jbz
jbz: |
    u mody=>=>so
qq: |
    # getting run t
    # qode qompiler
    # does each thing input... has out that joins up
    # J (above)  # does u thing
    #   J qq     # gets W/thing as inbryo or stored G.oin Wemotables
    #   ^        # settles (Jbove wants out, to do n)
    #   output G compressions (+/- laws)
    # J eats   " "
    
    
    #
Jto: |
     my $J;
     J.id = mkuid;
     (J.name) = @{delete ar.m};
     J.bb = {};
     J.phy = {};
     J.phl = {};
     
     J.most.J = $J;
     J.most.mody = 'mani';
     J.most.eo = 'Yesui';
     J.tt = 1;
     
     J.u = sub {
         my $ar;
         ar.J = Rw j $J qq;
         ar.N = [[@_]];
         sayyl "J.name U! @_";
         Rw MyN;
         # & concert overworld
     };
     J.n = sub {
         my $ar;
         ar.J = $J;
         ar.N = [[@_]];
         Rw MyN;
     };
     J.m = sub {
         my $ar;
         ar.M = shift;
         ar.J = $J;
         ar.N = [[@_]];
         Rw MyN;
     };
     J.bz = sub { #c
         my $m = [@_];
         die "not 2 @$m" if @$m != 2;
         my $j={};
         while (@$m) {
             my ($r, $v) = (shift @$m, shift @$m);
             if ($r =~ /^%(\S+)/) {
                 j.style = $1;
             }
             else {
                 $j = Rw r2j $r $J;
             }
             defined j.cv || die "NOSEYV: j.cv".wdump[$j,[@_],[$r, $v]];
             
             j.r = join "\t", j.cv, j.t, j.style;
             j.s = $v;
             my @Js = $J;
             push @Js, values %{J.phy} if J.phy;
             for my $jj (@Js) {
                 jj.bb->{j.r} = j.s;
                 push @{jj.ord}, {%$j} if jj.ord;
                 jj.tim->{j.r} = hitime() if jj.tim;
                 jj.wtf->{j.r} = $F[0] if jj.wtf;
                 jj.ap->($j) if jj.ap; # <<<
             }
        }
     };
     $J
     
r2j: |
    my $j;
    if (J.tt) {
        (j.cv,j.t,j.style) = $r =~ /^(.*?)\t(.*)\t(.*?)$/;
    }
    else {
        (j.t,j.style,j.cv) = $r =~ /^(.+?)(?:%(.+))?\s+(.+?)$/;
    }
    defined j.cv || die "(tt=J.tt) no $r    ".ki $j;
    j.s = ar.J.bb->{$r} if ar.J;
    $j;
    
Yesui: |
    my $aj = Rw chuv;
    Rw Noodles $J;
    $aj;
Noodles: |
    my $Y = Rw El Pre;
    
    Rw Elvis $J $Y;
    
    Y.il = Y.tv->{"0.9\t/"}||die'noroot';
    my @to = grep { $_ ne Y.il } @{Y.vs};
    push @to, Y.il;
    # coordinate / to ajup chunks of @to
    
    my $hup = sub {
        my $C = shift;
        my $CC = {%$C};
        $CC->{$_} = {%{$CC->{$_}}} for grep {ref $CC->{$_} eq 'HASH'} keys %$CC;
        $CC;
    };
    my $heq = sub {
        my ($o,$t) = @_;
        if (ref $o && ref $t) {
        keys %$o == keys %$t && !grep{$o->{$_} ne $t->{$_}}keys %$o
        }
        elsif (!ref $o && !ref $t) {
        $o eq $t
        }else{0}
    };
    
    
    my $V = Rw El Duv;
    my $ot={};
    my $tt={};
    my @nos;
    for my $C (@to) {
        ref C.y || die"nospace".ki $C;
        ref C.y || next;
        
        my $k = C.y.cv."\t".C.t;
        push @nos, $k unless $C eq Y.il;
        $ot->{$k} = 1;
        
        next unless $C eq Y.il ||
        # if change is, or just diff in perceiving it
        Rw diffre $J $C $k $Y $V;
        
        $tt->{$k} = $C;
        
        # O
        my $at = Rw OSC $J $C $k $Y $V;
        
        # so now flop at into on
        # V
        # re-c if sc missing or unable to makeup diff
        # always see into J c/sc we want
        
        my $ta = V.ta->{$k};
        my $vl = V.lv->{$k};
        my $lv = {};
        my $cl = {};
        
        if ($C eq Y.il) {
            my $rec = 0;
            # selectively replace/drop old
            #  "  hold keeps, drop others
            for my $kg (keys %{Y.go}) {
                my $gv = V.lv->{$kg};
                if (gv.rmnsc) {
                    acum $cl, sc => gv.rmnsc;
                }
                sayyl "Goners:  $kg ";
                # if the medium supports it
                # sc the removal of something we still c
                # find .c removability
                # replace our c 
            }
            #saybl "tlive: ".wdump 2, [sort keys %$tt];
            for my $ik (@nos) {
                my $iv = lv.do->{$ik} = V.lv->{$ik};
                my $ov = vl.do->{$ik};
                my $note = "c:".(iv.c eq ov.c ?"--":"ch!")
                    ." sc:".(iv.sc eq ov.sc ?"--":"ch!");
                sayyl "DKOW $k $note   ---  iv.etc $ik";
                
            }
            
            if (vl._Yvs eq Y.vs) {
                sayyl "Vs stable";
                at.sc.z = ta.sc.z;
            }
            else {
                at.sc.z = [map{V.lv->{$_}}@nos];
                #die "Was ".wdump[$V];
                lv._Yvs = "Y.vs";
                say "$k Yvs become   lv._Yvs - vl._Yvs";
            }
            #at.z = 
        }
        # can sc the new /-zc
        
        #sayyl "J.name live once: $k    ".wdump 4, V.lv->{$k};
        
        at.c.name = J.name;
        if ('force') {
            at.c.el = 1;
            lv.rmnsc = [at.t, at.y, {el=>9}];
        }
        V.ta->{$k} = $hup->($at);
        V.tv->{$k} = $hup->($C);
        
        for my $nk (qw't y c sc') {
            my $v = $at->{$nk};
            if (!$heq->($v, $ta->{$nk})) {
                sayyl " $k   the $nk";#$v $ta->{$nk} is diff: ".ki($v);
            }
            else {
                sayre " $k  thje $nk";
            }
        }
        
        lv.ma = lv.ma+1;
        lv.c = [[at.t, at.y, at.c, at.sc]];
        lv.sc = [];
        V.lv->{$k} = $lv;
        
        if ($C eq Y.il) {
            V.rv = $lv;
        }
        
        saygr "At  now:  ".ki($at)."\nvs  then: ".ki($ta);
        
    }
    
    my $o = keys %$tt;
    my $t = keys %$ot;
    my $ine = Rw ratio $o $t;
    sayyl "THe J.name was Y.ra     y Y.to               $ine   ";
    #.wdump([sort keys %{V.lv}]) if J.name eq 'Yes';
    
    #say wdump 15, V.rv if J.name eq 'Yes';
    
    # bloop
OSC: | # sheets of language up to da
        my $at = {};
        
        at.t = C.t;
        at.y.cv = C.y.cv;
        sayre "C.t no s" if !exists C.c.s;
        at.c.s = C.c.s;
        at.sc = {%{C.sc}};
        delete at.sc->{$_} for qw'geo idly ml nspc path yspc';
        if (my $v = at.sc.J) {
            at.sc.J = v.name;
            my $nV = v.El.Duv || do { 
                sayre "noduv $k";
                {rv=>{LIES=>"from v.name"}}
            };
            sayyl "Can see v.name   from J.name   C.t  C.y.cv";
            # unifies us-most or so fro
            #|| sayre "J.name of v.name is not from here: ".wdump 2, v.El;
            my $rv = nV.rv;
            say "For v.name   ::: ".ki $rv;
            # we have some change to embed
            at.sc.z = $rv;
        }
        at.sc.geo = ki(at.sc.geo) if at.sc.geo;
        at.y = at.y.cv if keys %{at.y} == 1 && exists at.y.cv;
        
        $at;
        
Sun/oo: [somoe]
diffre: |
        my $heq = sub {
            my ($o,$t) = @_;
            keys %$o == keys %$t && !grep{$o->{$_} ne $t->{$_}}keys %$o;
        };
        my $toen = 1;
        
        if (my $di = Y.lo->{$k}) {
            my $not;
            if (keys %$di == 1 && di.diff) {
                my $CC = V.tv->{$k};
                if (!$CC) {
                    sayre "never heard of (V_tv) diff J.name : $k ";
                    return 1;
                }
                for my $tk (keys %{di.diff}) {
                    if ($tk eq 'geo') {
                        $not++ if 0 && !$heq->(C.sc.geo,CC.sc.geo);
                        if ($not && 0) {
                            sayyl "Geo was $not a difference in the thing";
                            sayyl sjson(C.sc.geo);
                            saybl sjson(CC.sc.geo);
                        }
                    }
                    elsif ($tk eq '') {
                        $not++ unless ref C.c.s && C.sc.dige && C.sc.dige eq CC.sc.dige;
                    }
                    else {
                    
                        saybl "Somewhere else ch  C.t tk $tk";
                        $not++;
                    }
                }
            }
            else {
                $not = 1;
            }
            $toen = 0 if !$not;
        }
        if (!$toen) {
            if (my $JJ = C.sc.J) {
                if (my $nV = JJ.El->{V.name}) {
                    my $TT = V.ta->{$k};
                    sayyl "J.name  Wonder about $k  JJ.name:  ".wdump 1, nV.rv;
                    #my $vl = V.lv->{$k};
                    saybl "Vs: ".wdump 3, $TT;
                }
                else {
                   sayre "no El V.name on JJ.name";
                }
            }
            say "after J";
            $toen = 0;
        }
        $toen
     
wtfch: |   
    my $wtf = {};
    wtf.same = 1;
    $wtf->{$_} = {} for qw'new diff gone';
    
       for (sort keys %$Jb) {
           if (!exists $Yb->{$_}) {
               wtf.new->{$_} = $Jb->{$_};
               wtf.same = 0;
           } 
           elsif ($Yb->{$_} ne $Jb->{$_}) {
               wtf.diff->{$_} = $Jb->{$_};
               wtf.same = 0;
           }
           else {
               wtf.sami++;
           }
           wtf.tot++;
       }
       for (grep { !exists $Jb->{$_} } sort keys %$Yb) {
           wtf.gone->{$_} = $Yb->{$_};
           wtf.same = 0;
       }
       $wtf;
El: |
    my $name = shift @$m;
    my $Y = J.El->{$name} ||= {bb=>{},name=>$name};
    return $Y
Elvis: |
    my $wtf = Rw wtfch $Jb:J.bb $Yb:Y.bb;
    
    Y.tw ||= {};
    Y.lo = {};
    
    for my $mo (qw'gone diff new') {
        for my $r (keys %{$wtf->{$mo}}) {
            my $j = Rw r2j $r $J;
            j.r = $r;
            j.lt = j.cv."\t".j.t;
            if (!j.lt=~/\S/) {
                die "Got $r =>   ".ki $j;
            }
            
            if ($mo eq 'gone') {
                delete Y.bb->{j.r};
                delete Y.tw->{j.lt}->{j.style};
            }
            else {
                Y.bb->{j.r} = j.s;
                Y.tw->{j.lt}->{j.style} = j.s;
            }
            Y.lo->{j.lt}->{$mo}->{j.style} = j.s;
        }
    }
    
    Y.tv ||= {};
    Y.go = {};
    my $same = 1;
    for my $k (keys %{Y.lo}) {
        my $tf = Y.lo->{$k};
        my $cs = Y.tw->{$k};
        if (tf.new && !tf.gone && !tf.diff && keys %{tf.new} == keys %$cs) {
            $same = 0; # new line to make
        }
        if (tf.gone && !keys %$cs) {
            $same = 0; # line to disappear
            my $C = Y.go->{$k} = delete Y.tv->{$k};
        }
        if (tf.diff || tf.new) {
            keys %$cs || die 'nokeys';
            my ($cv,$t) = $k =~ /^(.+?)\t(.+)$/;
            defined $cv || die;
            
            my $C = Y.tv->{$k} ||= {};
            %$C = (t=>$t,y=>{cv=>$cv},c=>{},sc=>$cs);
            C.c.s = delete C.sc->{''} if exists C.sc->{''};
        }
    }
    if (!$same) {
        Y.vs = [];
        for my $k (sort keys %{Y.tv}) {
            my $C = Y.tv->{$k} || die "wtf $k";
            push @{Y.vs}, $C;
        }
        sayre "vs re: ".@{Y.vs};
    }
    
    Y.ra = Rw ratio $o:wtf.sami $t:wtf.tot;
    Y.rato = wtf.tot;
    Y.revs = !$same;
    
    
    $Y;
ratio: |
    my $ratio = $o / $t;
    0.01 * int(100*$ratio);
    
sea: |
    u 8ou;
8ou: |
    u Ver
blus: |
    u 
    

