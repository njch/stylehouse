oJ7: |
    my $J = C.sc.J;
    
    J.most.wq && return
    Rw J.most.eo $J;
    
    exists C.sc.pi && return Rw opi7;
    
    return if A.roundi;
    
    say "oJ7777 J.name" unless J.yt.quiet;
    Rw oJ $J geo &up $noesc=1
        if !J.most.wq;
    my $eo = J.most.eo;
    $eo || die "noeo: J.name";
    Rw $eo $J;
opi7: | # MOD pi     out cup           # REF JOIN A.c/sc
    my $J = C.sc.J;
    
    sayyl "opi7! J.most.J.name J.name" if J.most.J.V;
    my $aj = Rw J.most.eo $J $catj=1;
    
    J.Ec = [@{aj.c}];
    die wdump $aj if @{aj.sc};
       
oJ75: | # chov J
    if (C.sc.pi) {
        $v = C.sc.J || die'enoJ'.C.t;
        die "Pi v.r has s" if v.s;
        delete at.s if defined at.s;
        die "No Ec came out of v.name  on J.name" if !ref v.Ec;
        die "Pi v.r no .Ec" if !@{v.Ec};
        acum $at, 'Esc', $_ for @{v.Ec};
    }
    else {
        #say "AM v.name  rrrrr J.name";
        at.s = "Vrrr v.name";
    }
Yesui: |
    !J.most.wq && return Rw chuv;
    
    my $V = Rw Noodles $J;
    
    V.rv;
Noodles: |
    my $A = {J=>$J};
    A.talk = "A.J.name ".(A.J.le && A.J.le.name);
    # then we could I when doing:
    
    
    my $Y = Rw Elvus $J Pre;
    # providing the source pretend of c/sc ray anarchy
    # v to ^
    Y.il = Y.tv->{"0.9\t/"}
        || Y.tv->{"0.9\t".J.name}
        || Y.tv->{"0.9\t".J.uname}
          || die " noroot J.name: showing 0.9s: "
            .wdump [map{ki $_}values %{Y.v->{0.9}}];
    
    my $N = [grep { $_ ne Y.il } @{Y.vs}];
    push @$N, Y.il;
    A.N = [@$N];
    
    my $hup = sub {
        my $C = shift;
        my $CC = {%$C};
        $CC->{$_} = {%{$CC->{$_}}} for grep {ref $CC->{$_} eq 'HASH'} keys %$CC;
        $CC;
    };
    
    my $V = Rw El Duv;
    V.os = [];
    while (@{A.N}) {
        my $C = shift @{A.N};
        ref C.y || die"nospace".ki $C;
        ref C.y || sayre("Weird".ki$C) && next;
        
        my $k = C.y.cv."\t".C.t;
        push @{V.os}, $k unless $C eq Y.il;
        
        next unless $C eq Y.il ||
        # if change is, or just diff in perceiving it
        Rw diffre $J $C $k $Y $V;
        
        # O
        my $lv = {k=>$k};
        lv.C = $C;
        my $at = Rw OSC $A $J $C $k $Y $V $lv;
        
        my $ta = V.ta->{$k};
        my $vl = V.lv->{$k};
        
        if ('force') {
            at.c.el = 1;
            lv.force = 'el';
            lv.selfs = 1;
            lv.grab = [at.t, at.y, {el=>8}];
            lv.rmnsc = [at.t, at.y, {el=>9}];
            # and or ID
            # ID makes possible to throw into the W (most J) tiniest specs of change
            # maybe 8regate
        }
        
        # crazy has places to hide in
        my $heq = sub {
            my ($o,$t) = @_;
            if (ref $o && ref $t) {
                keys %$o == keys %$t && !grep{$o->{$_} ne $t->{$_}}keys %$o
            }
            elsif (!ref $o && !ref $t) {
                $o eq $t
            }else{0}
        };
        for my $nk (qw't y c sc V') {
            my $v = $at->{$nk};
            my $o = $ta->{$nk};
            if (!$heq->($v, $o)) {
                Rw ACT $J $C $k $Y $V $at $ta $lv $vl $nk $v $o;
            }
        }
        
        V.ta->{$k} = $hup->($at); 
        V.tv->{$k} = $hup->($C);
        
        Rw OMP $J $C $k $Y $V $at $ta $lv $vl;
        
        V.lv->{$k} = $lv;
        
        if ($C eq Y.il) {
            V.rl = $vl;
            V.rv = $lv;
        }
    }
    Rw TNews $J $talk:A.talk $rl:V.rl $rv:V.rv
        if J.V;
    $V
    # bloop

ACT: |
    my $talk = "J.name ACT $nk: $k\t";
    if (ref $v eq 'HASH') {
        my $wt = Rw wtfch $Jb:v $Yb:o;
        my $nonnew = keys %{wt.gone} || keys %{wt.diff} || keys %{wt.still};
        
        for my $wk (qw'gone diff new still') {
            for my $gk (sort keys %{$wt->{$wk}}) {
                my $talk = "$talk $wk: $gk";
                my $s = $at->{$nk}->{$gk};
                
                if ($nk eq 'V') {
                    Rw AC_V + $talk $nonnew $gk $wt $wk $s;
                }
                elsif ($nk eq 'c') {
                    Rw AC_c + $talk $nonnew $gk $wt $wk $s;
                }
                elsif ($nk eq 'sc') {
                    Rw AC_sc + $talk $nonnew $gk $wt $wk $s;
                }
                else {die"wtfis  '$nk'"}
            }
        }
        saybl "$talk    is all new" if $vl && !$nonnew && keys %{wt.new};
    }
    else {
        my $wk = !$vl ? "new" : !exists $at->{$nk} ? "gone" : "diff";
        $talk .= "$wk: ";
        if ($nk eq 't' || $nk eq 'y') {
            if ($wk ne 'new') {
                die "HOWTO $talk";
            }
            sayyl $talk if $vl;
            
            lv.op->{$nk} = 1;
        }
        else {die"wtfis $v $nk".wdump[$v,$o]}
    }
AC_c: |
    if ($wk eq 'gone') {
        die "how delete a c $gk";
        die "would have" if !$vl;
        # most of these can re c if they get confused
        # care later to grab /in, recreate holster, replace
        # or however we whatever
        # protocols for travel regroup
        
        lv.op.c->{$gk} = 9;
    }
    elsif ($wk eq 'new') {
        die "how inject a c $gk" if $vl;
        
        lv.op.c->{$gk} = 9;
    }
    elsif ($wk eq 'diff') {
        sayyl "$talk  ".slim(45,$v->{$gk})." <--- ".slim(45,$o->{$gk});
        
        if ($gk eq 's') {
        
            lv.pur.c->{$gk} = 1;
        }
        else {
            die "how to c dif $gk";
            
            lv.op.c->{$gk} = 9;
        }
    }
    elsif ($wk eq 'still') {}
    else {die 'wtwhack'.$wk}
AC_sc: |
    if ($wk eq 'gone') {
        die "how delete a c $gk";
        die "would have" if !$vl;
        # most of these can re c if they get confused
        # care later to grab /in, recreate holster, place
        # or however we whatever
        
        lv.op.sc->{$gk} = 9;
    }
    elsif ($wk eq 'new') {
        sayyl "$talk  !!!!  $v->{$gk} " unless !$nonnew;
        
        lv.pur.sc->{$gk} = 1;
    }
    elsif ($wk eq 'diff') {
        sayyl "$talk  $v->{$gk} <--- $o->{$gk}";
        
        lv.pur.sc->{$gk} = 1;
    }
    elsif ($wk eq 'still') {}
    else {die 'wtwhack'.$wk}
    
AC_V: |
    my $iv = lv.do->{$gk};
    my $ov = vl.do->{$gk};
    ov.i && (ov.i eq $o->{$gk} || warn "no ovi ogk");
    if ($wk eq 'gone') {
        ov.rmnsc || die "no remin";
        !$iv || die "gone had iv";
        # ^ sc plumb its destruction
        # can void if our c reframes by implicitly clearing 
        saybl "$talk  is GONE!";
        
        lv.od.go->{$gk} = $ov;
    }
    elsif ($wk eq 'new') {
        $iv || die;
        # may like to grab the element before it
        # like a curve continuing
        saybl "$talk    new!" unless !$nonnew;
        
        lv.od.new->{$gk} = $iv;
    }
    elsif ($wk eq 'diff') {
        if (iv.c eq ov.c) {
            iv.sc eq ov.sc && die "same c fluc sc $gk";
            my $in = @{iv.sc};
            my $out = @{ov.sc};
            if (@{iv.sc} > @{ov.sc}) {
                saybl "$talk GROWs" if J.V > 2;
                
                lv.od.gr->{$gk} = $iv;
            }
            else {
                warn "WTFF ".wdump 2,[$iv,$ov];
            }
        }
        else {
            saybl "$talk  REPLACES c";
            
            lv.od.over->{$gk} = $iv;
        }
    }
    elsif ($wk eq 'still') {
        lv.od.ll->{$gk} = $iv;
    }
    else {die 'wtwhack'};
OSC: | # sheets of language up to da
    my $at = {};
    
    at.t = C.t;
    at.y.cv = C.y.cv;
    sayre "OSC7 C.t no c_s" if !exists C.c.s;
    at.c.s = C.c.s;
    at.sc = {%{C.sc}};
    delete at.sc->{$_} for qw'geo idly ml nspc path yspc';
    if (my $v = at.sc.J) { # J unifies -
        at.sc.J = v.name;
        
        my $nV = v.El->{V.name}||{};
        my $rv = nV.rv || {LIES=>"from v.name"};
        
        lv.do->{V.name} = $rv;
        at.V->{V.name} = rv.i;
    }
    if ($C eq Y.il) { # / unifies  <
        lv.voso = 1;
        for my $ik (@{V.os}) {
            my $iv = V.lv->{$ik};
            sayre("Skip self in self") && next if C.sc.J && C.sc.J eq A.J;
            lv.do->{$ik} = $iv;
            at.V->{$ik} = iv.i;
        }
    }
    at.sc.geo = ki(at.sc.geo) if at.sc.geo;
    at.y = at.y.cv if keys %{at.y} == 1 && exists at.y.cv;
    for my $up (qw'tag id') {
        at.c->{$up} = delete at.sc->{$up} if exists at.sc->{$up}
    }
    
    $at;
diffre: |
    my $heq = sub {
        my ($o,$t) = @_;
        keys %$o == keys %$t && !grep{$o->{$_} ne $t->{$_}}keys %$o;
    };
    my $toen = 1;
    
    if (my $di = Y.lo->{$k}) {
        my $not;
        if (keys %$di == 1 && di.diff) {
            my $CC = V.tv->{$k};
            if (!$CC) {
                sayre "never heard of (V_tv) diff J.name : $k ";
                return 1;
            }
            for my $tk (keys %{di.diff}) {
                if ($tk eq 'geo') {
                    $not++ if 0 && !$heq->(C.sc.geo,CC.sc.geo);
                    if ($not && 0) {
                        sayyl "Geo was $not a difference in the thing";
                        sayyl sjson(C.sc.geo);
                        saybl sjson(CC.sc.geo);
                    }
                }
                elsif ($tk eq '') {
                    $not++ unless ref C.c.s && C.sc.dige && C.sc.dige eq CC.sc.dige;
                }
                else {
                    saybl "J.name $k has diffre: $tk";
                    $not++;
                }
            }
        }
        else {
            $not = 1;
        }
        $toen = 0 if !$not;
    }
    if (!$toen) {
        if (my $JJ = C.sc.J) {
            my $ta = V.ta->{$k};
            if (my $nV = JJ.El->{V.name}) {
                my $iv = nV.rv;
                my $oi = ta.V->{V.name};
                if ($oi ne iv.i) {
                    $toen = 1;
                    #sayyl "J.name  $k   about JJ.name: $toen \n"
                    #.($toen&&" ^ iv.i\n | $oi");
                }
            }
            else {
               sayre "no El V.name on JJ.name";
            }
        }
    }
    $toen
     

