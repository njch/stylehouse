
oJ31: |
    my $f = A.jr&J;
    
    my $j = C.sc.J;
    if (ref $j && ref $f && $j ne $f) {
        die ".sc J dif $f $j";
    }
    if ($f && ref $f && !f.dead) {
        C.sc.J = $f;
    }
    
    C.sc.J
    
oJ32: |
    if (C.c.X) {
        die "Nofound $J  C.t   C.y.cv" if !ref $J;
        die "noovewr X  C.c.X ne $J" if C.c.X ne $J;
        sayyl "DELING J.name". wdump $C if C.c.X;
        A.jr&J,$J,9;
        J.dead = 1;
        T.return = [];
        return;
    }
    # also how & 9s (noncompresses) out for us into a more local J
    # u W would zlide in as an Elvis clone
    # it has a high frequency
oo3: | # MOD  being repeater  - humm
    my $J = Rw oJ31;
    # A/sc gets or not ^
    # things can be Wd out real hivey, Jduplicsa en namespace spag
    # they expand around 3-6
    # heres wher eit  gets creal
    Rw oJ32 + $J;
    # aboput the 2/3 A timey, where rm, compression unfolds
    # oir rhythm style joins
    return if T.return;
    
    if (!ref $J) {
        Rw oo33 + $J;
    }
    
oo33: |
    # doof, we are creating a J
    # A.c shall
    die "refJoo33 $J" if ref $J;
    $J = Rw Jto $name:J;
    
    if (A.c&pi) {
        j.Jiter = $J; # erse rev
        j.most->{$_} = J.most->{$_} for keys %{J.most||{}};
    }
    
    sayyl "J33   Made J.name";
    C.sc.J = $J || die 'watt';
    
    C.c.s = "Swim" if !exists C.c.s;
    my @an =  A.jr->('');
    if (@an && !exists C.c.s) {
        C.c.s = shift @an;
    }
    elsif (!@an && exists C.c.s) {
        A.jr->('',C.c.s);
    }
    die "noovewr   C.c.J ne $J" if ref C.c.J && C.c.J ne $J;
    A.jr&J,$J;
    at.J = $J;
    # ^ gets & replaces, C.sc.J now it
    
    Rw oJ4 + $J;
Elvis: | # safe vs doing - oJ
    my $wtf = Rw wtfch $Jb:J.bb $Yb:Y.bb;
    
    Y.tw ||= {};
    Y.lo = {};
    
    for my $mo (qw'gone diff new') {
        for my $r (keys %{$wtf->{$mo}}) {
            my $j = Rw r2j $r $J;
            j.r = $r;
            j.lt = j.cv."\t".j.t;
            if (!j.lt=~/\S/) {
                die "Got $r =>   ".ki $j;
            }
            
            if ($mo eq 'gone') {
                delete Y.bb->{j.r};
                delete Y.tw->{j.lt}->{j.style};
            }
            else {
                Y.bb->{j.r} = j.s;
                Y.tw->{j.lt}->{j.style} = j.s;
            }
            Y.lo->{j.lt}->{$mo}->{j.style} = j.s;
        }
    }
    
    Y.tv ||= {};
    Y.go = {};
    my $same = 1;
    for my $k (keys %{Y.lo}) {
        my $tf = Y.lo->{$k};
        my $cs = Y.tw->{$k};
        if (tf.new && !tf.gone && !tf.diff && keys %{tf.new} == keys %$cs) {
            $same = 0; # new line to make
        }
        if (tf.gone && !keys %$cs) {
            $same = 0; # line to disappear
            my $C = Y.go->{$k} = delete Y.tv->{$k};
        }
        if (tf.diff || tf.new) {
            keys %$cs || die 'nokeys';
            my ($cv,$t) = $k =~ /^(.+?)\t(.+)$/;
            defined $cv || die "twas $k";
            
            my $C = Y.tv->{$k} ||= {};
            %$C = (t=>$t,y=>{cv=>$cv},c=>{},sc=>$cs);
            C.c.s = delete C.sc->{''} if exists C.sc->{''};
        }
    }
    if (!$same) {
        Y.vs = [];
        for my $k (sort keys %{Y.tv}) {
            my $C = Y.tv->{$k} || die "wtf $k";
            push @{Y.vs}, $C;
        }
        #sayre "vs re: ".@{Y.vs};
    }
    
    Y.ra = Rw ratio $o:wtf.sami $t:wtf.tot;
    Y.rato = wtf.tot;
    Y.revs = !$same;
    
    
    $Y;
wtfch: |   
    my $wtf = {};
    wtf.same = 1;
    $wtf->{$_} = {} for qw'new diff gone';
    
       for (sort keys %$Jb) {
           if (!exists $Yb->{$_}) {
               wtf.new->{$_} = $Jb->{$_};
               wtf.same = 0;
           } 
           elsif ($Yb->{$_} ne $Jb->{$_}) {
               wtf.diff->{$_} = $Jb->{$_};
               wtf.same = 0;
           }
           else {
               wtf.sami++;
               wtf.still->{$_} = $Jb->{$_};
           }
           wtf.tot++;
       }
       for (grep { !exists $Jb->{$_} } sort keys %$Yb) {
           wtf.gone->{$_} = $Yb->{$_};
           wtf.same = 0;
       }
       $wtf;

