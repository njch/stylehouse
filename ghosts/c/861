
pi/shed: |
    y.lum = 1;
    n what=>1=>"C.t shed: $s",'%hs:258'
    my ($j)=map{_.nj}
    Mn($s=>-yaml=>);
    
pi/yaml: |
    C.c.mtime = 1;
    y.at.serv = 'packyaml';
    y.at.osci = 1;
    Rw pi/file;
    -f $s || return
    n 404 =>2=>"404: $s",'%hs:388';
    y.limn = 7;
    
    Atime(2)||return saybl "\nIs J.name ico\n"; 
    
    my @l = read_file($s);
    sayyl "Reading for $s" for 1..4;
    push @l, {};
    my ($t,$s,$e,$i);
    for my $l (@l) {
        if (ref $l || $l =~ /^(\S.*): \|(.*)\n/) {
            my @new = ($1,'',$2);
            if (defined $t) {
                my $ind = $1 if $s =~ /^(\s+)\S/ || die "Noin stya: $l";
                $s =~ s/^$ind//sgm;
                my $sc;
                sc.vert = $i;
                sc.ontop = $e if length $e;
                sc.dig = slm(6, dig($s));
                sayre "INsert ! Ya $t";
                Mn($t=>'pi:yam'=>{s=>$s},$sc);
                saybl "Don $t";
            }
            ($t,$s,$e) = @new;
            $i = 0;
        }
        else {
            $l !~ /\S/ && next || die "no t aft $l" if !$t;
            $s .= $l;
            $i++;
        }
    }
pi/yam: |
    C.sc.dos = 'hijack';
    
    J.mo.yam = $C;
    
    n it =>1=>C.t=>'%hs:748,fw:3'
    C.sc.hs = int(rand 9).'74';
    saybl " - -yamin C.t";
    n dig=>1=>C.sc.dig,'%hs:388'
    C.sc.ontop &&
    n also=>2=>C.sc.ontop,'%hs:864'
    #Mn(C.t=>-te=>$s);



pi/alink: |
    n link =>''=>C.t=>{tag=>'a',atr=>'href',href=>$s};

pi/pre: |
    y.at.qs = 1;
    n pre =>1=>{s=>$s}=>'%tag:pre'
    

pi/uptime: |
    my ($l) = reverse split ': ', `uptime`;
    n uptime=>2=>$l
pi/sensors: |
    y.at.ws = 1;
    J.diel += 0.4;
    n diel =>1=>"D ".int(J.diel)
    Atime(2) || return;
    my $com = "sensors";
    $com = "ssh v '$com'" if `hostname` !~ /v/;
    my @l = `$com`;
    my @k = qw'pi co no';
    @l = grep{$_} map{/^(Core 0|temp1):\s+(\S+)/ && $2} @l;
    s/^.*?(\d+).*$/$1/ for @l;
    $_ = shift(@k).": $_   " for @l;
    m yolt=>'',$_ for @l;
    
