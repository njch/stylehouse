Sun/oo: [somoe]
Jto: |
    my $J;
    J.id = mkuid;
    J.name = ar.name || (@{delete ar.m})[0];
    J.bb = {};

    J.most.J = $J;
    J.most.mody = 'mani';
    J.most.eo = 'Yesui';
    J.most.wq = 1;
    
    Rw suJ $J;
    Rw Jup $J;
    
    n J.name, 0.9, J.name, {tag=>J.name,id=>J.id}
    
    Rw Viu $J;
    
    return $J;
    
    J.bz = sub { # the cv=>t=>style r
       my $m = [@_];
       die "not 2 @$m" if @$m != 2;
       my $j={};
       while (@$m) {
           my ($r, $v) = (shift @$m, shift @$m);
           if ($r =~ /^%(\S+)/) {
               j.style = $1;
           }
           else {
               $j = Rw r2j $r $J;
           }
           defined j.cv || die "NOSEYV: j.cv".wdump[$j,[@_],[$r, $v]];
           
           j.r = join "\t", j.cv, j.t, j.style;
           j.s = $v;
           my @Js = $J;
           push @Js, values %{J.phy} if J.phy;
           for my $jj (@Js) {
               jj.bb->{j.r} = j.s;
               push @{jj.ord}, {%$j} if jj.ord;
               jj.tim->{j.r} = hitime() if jj.tim;
               jj.wtf->{j.r} = $F[0] if jj.wtf;
               jj.ap->($j) if jj.ap; # <<<
           }
      }
    };
    $J
Viu: |
    my $eu = sub { J.uS = 1 };
    my $unu = sub {
        J.uS || return;
        Rw uCon;
        J.uS = 0;
    };
    my $dJ = sub {
        my @m = @_;
        if (ref $m[0]) {
            if ($m[0] eq $J) {
                shift @m;
            }
            else {
                die "nJinto: ".wdump 2, [@_];
            }
        }
        pop @m while $m[-1] eq '';
        if (@m < 4) {
            $m[2] ||= {J=>$m[0]};
            @m == 3 || die "!!!\n".wdump[@m];
        }
        while (@m > 4) {
            my $wat = pop @m;
            $wat eq '' || die "got some $wat  f n".wdump 2, \@m;
        }
        [@m]
    };
    J.u = sub {
       $eu->();
       my $ar;
       ar.C = [$dJ->(@_)];
       ar.J = Rw j $J qq;
       Rw I;
    };
    J.n = sub {
       $unu->();
       my $ar;
       ar.J = $J;
       ar.C = [$dJ->(@_)];
       Rw I;
    };
    J.m = sub {
       $unu->();
       my $ar;
       ar.M = shift;
       ar.J = $J;
       ar.C = [$dJ->(@_)];
       Rw I;
    };
uCon: |
    my $A = {J=>$J};
    my $J = Rw j $J qq;
    my $Y = Rw Noodles $J;
    my $rv = Y.rv;
    
    say "On A.J.name  post J.name: rv.i ";#.wdump 33, [Y.rv.i, Y.rv.c, Y.rv.sc];
    say F_delta();
    
Run: |
    my $G = Rw Gto;
    my $cb = sub {
        Rw Many;
    };
    Rw recur $d=1 $cb;
    
    sayyl "YEP";
Many: |
    my $J = G.oin;
    if (!$J) {
        my $t = "One";
        $J = Rw Jto $name:t;
        my $sc;
        sc.J = $J;
        Rw jamsc $J $t $cv=0.3 $s:t $sc;
        G.oin = $J
    }
    n One=>0.3=>{J=>$J,time=>6}
    
    my $y = G.Many||={};
    y.i++;
    my $t = hitime;
    y.la->{$t} = 1;
    sayyl "many y.i"; 
One: |
    sayyl "Doing J.name stuff...";
    n theS=>1=>{pi=>'cfile'=>s=>"life/S\.s"}
    J.V = 0;
Gto: |
    my $G = $G;
    G.w = sub {
        my ($pin,$ar)=@_;
        my $D;
        D.point = $pin;
        D.ar = $ar;
        D.name = join ' ', D.point, sort keys %{D.ar};
        D.sign = "Z";
        D.talk = "D.sign D.name";
        
        D.bab = G.way->{$pin};
        if (!defined D.bab) {
            if ($pin =~ /\//) {
                D.bab = fwind(G.way,$pin);
            }
            if (!defined D.bab) {
                sayre "Not findin D.talk";
                return;
            }
            else {
                #say "Trick shot: $pin"
            }
        }
        else {
            #say "Shot: $pin";
        }
        
        my $Z = $G->Doming($D);
        G.randomtask->() if G.randomtask;
        my $r; eval { $r = [ $G->D($D) ] };
        $G->Done($Z);
      
        if ($@) {
            my $ne = "Z Z.inter\n$@";
            $@ = $ne;
            D.nodie || die $@;
            $@ = "";
        }
        return wantarray ? @$r : $r->[0];
    };
    $G
Joldbz: |
     J.bz = sub { 
           my $j = {%$j};
           my $ad = [@_];
           my %j = %$j;
           while (@$ad) {
               my ($k, $v) = (shift @$ad, shift @$ad);
               
               my $comp = $k =~ /^(%|\+)/;
               my $j = {%j} if $comp;
               if ($comp) {
                   $k =~ s/^\+// if $comp;
                   j.t .= $k if $comp;
               }
               else {
                   (j.t, j.cv) = $k =~ /^(.+)\s+(.+?)$/;
                   %j = %$j;
               }
               defined j.cv || die "NOSEYV: j.cv".wdump[$j,[@_],[$k, $v]];
               j.r = j.t."\t".j.cv;
               j.s = $v;
               
               my @Js = $J;
               push @Js, values %{J.phy} if J.phy;
               for my $jj (@Js) {
                   jj.bb->{j.r} = j.s;
                   push @{jj.ord}, {%$j} if jj.ord;
                   jj.tim->{j.r} = hitime() if jj.tim;
                   jj.wtf->{j.r} = $F[0] if jj.wtf;
                   jj.ap->($j) if jj.ap;
               }
           }
           wantarray ? ($j, 
               sub{J.bz->(%$j, @_)} # TODO fucked, get some weed and fix it
           ) : $j
     };
     
j: |
    my $name = shift @$m;
    my $Y = J.El->{$name};
    return $Y if $Y;
    J.El->{$name} = Rw Jto - $name;
    
stylehut: |
    u perl/file
    n ACGT
    n doi=>'',<<'','%code=1'
      Rw j phon;
    
ACGT: |
    # /home/s/Music/Nurse With Wound/2004 Shipwreck Radio Volume One (Seven Sonic Structures From UtvÃ¦r) 2xCD/disc 2/04 - june 20.mp3


somewherei: |
    u jbz
    n fgeijji dsfji
    n jidj jfiewji
    
jbz: |
    u mody=>=>so
qq: |
    # getting run t
    # qode qompiler
    # does each thing input... has out that joins up
    # J (above)  # does u thing
    #   J qq     # gets W/thing as inbryo or stored G.oin Wemotables
    #   ^        # settles (Jbove wants out, to do n)
    #   output G compressions (+/- laws)
    # J eats   " "
    
    
    #

