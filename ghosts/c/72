RB: | # inits A of ar C/N, pins spiral down (ret A.I that I.n,I.An,A.t)
    # non babzub, assume pbab skipped <<''s in origin
    my $A = {};
    
    A.oA = ar.oA if ar.oA;
    A.J = ar.J || die 'noJ';
    A.G = $G; # so travel can G/T/Hypo
    A.mo = $A;
    (A.am) = ar.t || ar.name || @{delete ar.m};
    A.am || die "unsame?";
    
    A.N = [ar.C || @{ar.N}];
    A.M = [];
    A.talk = "A.J.name ".(A.J.le && A.J.le.name);
    A.fl = ar.fl || {};
    A.I = {};
    
    my $I = delete G.drop.recycling->{A.J.id}->{A.am};
    
    my $II = Rw collaspII $A;
    
    if ($I) {
        if (I.Ii eq II.Ii) {
            say "Recyc A.talk! I.Ii continu" if A.J.V;
            #$I = {%$I,nF=>{}};
            A.I = $I;
            A.cv = 0.1;
        }
        else {
            sayre "Recycloped, Diff I.Ii  --  II.Ii" if A.J.V;
            undef $I;
        }
    }
    
    A.I.Ii = II.Ii;
    
    if (!$I) {
        $I = A.I||die'basenoi';
        Rw SNtl $I;
    }
    $A
Galso: | # Gooso goner # 
    G.h = sub {
        my $am = shift;
        my $D = $F[0];
        my $r = D.ar;
        my $A = r.A || die 'GhnoA';
        my $I = A.I || die 'GhnoI';
        I.d&Other,$am;
    };
    my %T = %{G.T||{}};
    G.T = \%T;
    {
        package Wormhole;
        use Tie::Hash;
        use YAML::Syck;
        our @ISA = qw(Tie::StdHash);
        sub FETCH {
            my ($s,$k) = @_;
            $s->{$k} ||= do{ 
            print "Loading w/$k ...\n" for 1..5;
            LoadFile("w/$k") };
        }
    }
    tie %T, 'Wormhole';
Seven: | # ^^^^^^^^^^^^^^^^^ is Motion, v is Sevening
    n Yesoo =>W
    n Yools =>W
    n Yuni =>W
    n Yeosleep =>W
    n Yosc =>W
    n Yeoodle =>W
    n Yeomp =>W
Yesoo: | # hoist in J most eo = Seve (above and below)
    u allvse
    n '','','%of:Mo'
    n J =>69,<<''
        J.most.eo = 'Sev';
        # dosgeo v Yesui as O or so
        # A pile v spiral
        # hive of change
Yools: |
    u allacgts
    
    n hup =>'',<<'','%code:Sev 1'
        my $CC = {%$s};
        $CC->{$_} = {%{$CC->{$_}}} for grep {ref $CC->{$_} eq 'HASH'} keys %$CC;
        $CC;
    
    n heq =>'',<<'',{acgt=>'o,t'}
        if (ref $o && ref $t) {
            keys %$o == keys %$t && !grep{$o->{$_} ne $t->{$_}}keys %$o
        }
        elsif (!ref $o && !ref $t) {
            $o eq $t
        }else{0}
    
    # pwin flexy passing tubes, to atoms
    n pas =>'',<<'',{acgt=>'pin,d'}
        my $s = d.s;
        my $e = d.e;
        my @ks = $pin eq '*' ? sort keys %$s
            : exists $s->{$pin} ? $pin
            : ();
        map {
            my $dd;
            dd.e.k = $_;
            dd.s = $s->{$_};
            dd.d = d.d if d.d;
            $dd;
        } @ks
    
    n pass =>'',<<'',{acgt=>'pin,s'}
        @$s = grep{defined} map { I.d&pas,$pin,$_ } grep{defined} @$s;
    
    n convog =>'',<<'',{acgt=>'in,Q'}
        Q.path && Q.onpa || die "learn more";
        for my $pin (@{Q.path}) {
            for my $pTn (@{Q.onpa}) {
                I.d&pass,$pTn,$in;
            }
            I.d&pass,$pin,$in;
        }
    
    n scIfs =>''=><<''
        my @is;
        my $Ifs = D.sc.Ifs;
        for my $k (keys %$Ifs) {
            my $Q = $Ifs->{$k};
            .
            my $in = [{s=>{T=>$T}}];
            my $pi = 0;
            for my $pin (@{Q.path}) {
                for my $pTn (@{Q.onpa}) {
                    I.d&pass,$pTn,$in;
                }
                I.d&pass,$pin,$in;
                @$in = map {
                    if (_.d) { # nonroot pattern mutable (into/on/off origin s)
                        my $su = $_;
                        $_ = _.d.s.T.q->{_.e.k} ||= $_;
                        say "_.e.k con $_ tas $su" if $_ ne $su;
                    }
                    _.od ||= _.d if _.d;
                    _.d = $_;
                    _.e.lk = Q.atar->[$pi]||die"no idea what $pi is";
                    $_
                } grep{defined} @$in;
                $pi++;
            }
            .
            for my $d (@$in) {
                # now inmost, .od leads above (without pTn inway)
                # and each d.e.lk calls it something $nk $gk and $wk
                    # and avoid less specific after more specific
                    # or just avoid repeats
                    #   
                    # shaky but index
                    # the fish is shaking but on the deck
                my $arg;
                my $up = $d;
                my $last = $up;
                my $i = 0;
                while ($up) {
                    $i++ > 8 && die "LAST WANDERS";
                    $arg->{up.e.lk} = up.e.k;
                    if (Q.caps) { # read between the lines of $d
                        for my $k (grep{Q.caps->{$_}} keys %$up) {
                            $arg->{$k} ||= $up->{$k};
                        }
                    }
                    $last = $up;
                    $up = up.od;
                    if ($up eq $last) {
                        sayre "D.t D.sc.Td  refers to itself as .od: ".wdump $last;
                        last;
                    }
                }
                arg.d = $d;
                for my $k (keys %{d.s}) {
                    next if $k eq 'T';
                    $arg->{$k} && die "Already $k arg of ".wdump[$d,$arg];
                    $arg->{$k} = d.s->{$k};
                }
                if (keys %{d.s.T && d.s.T.q || {}}) {
                    sayre " D.t   @{Q.path} d.s.v went deeper before";#.wdump[$d,$arg,$Q];
                }
                arg.talk = "D.t ($k:@{Q.path}) C.t C.y.cv:\t"
                    .join '/', map{$arg->{$_}} @{Q.atar};
                push @is, $arg;
                # Z/D wad of multiplicity
                # D args $d and arg, $nk/$ov etc things plucked
                # they must stay present to later Ds as well
                # stored T.d path subtlates
                # 6 ^
                sayre "arg.talk  ".ki $arg if A.J.V;
            }
        }
        @is
    
Sev: |
    ar.C ||= [Elvis=>''=>{J=>$J,Y=>'Pre',V=>'Duv'}];
    my ($A,$I) = G.h&Sev;
    my $i;
    sayyl "SEV! J.name" for 1..3;
    while (@{A.N}) {
        $i++ > 1000 && die "Huge A.am";
        my ($A,$C,$T) = I.d&Act,$A;
                T.not&&next;
        A.t&6;
                T.not&&next;
        I.d&flywheels;
                T.not&&next;
        A.t&78;
                T.not&&next;
    }
    continue { I.d&z; }
    A.t&89;
    I.d&recycle;
    A.retu;
Yuni: |
    u allvse
    n '','','%of:Sev'
    
    # time impersonator
    n JYV =>2=><<'',{rg=>'J,V',v=>'Y'}
        for my $K ('Y','V') {
            my $name = C.c->{$K};
            $name || die "No $K";
            C.c->{$K} = Rw Elj $J $name;
        }
        
    # exchange        
    n dElvis =>21=><<'',{rg=>'J,V',v=>'Y'}
        Rw Elvis $J $Y;
        V.os = [];
        A.mo.retu && die "J.name's  V.name: Already is  A.mo.retu.name";
        A.mo.retu = $V;
    
    # root of etc (yin)
    n root =>22=><<'',{rg=>'J,V',v=>'Y'}
        my $rC = Y.tv->{"0.9\t/"}
            || Y.tv->{"0.9\t".J.name}
            || Y.tv->{"0.9\t".J.uname}
              || die " noroot J.name: showing 0.9s: "
                .wdump [map{ki $_}values %{Y.v->{0.9}}];
        rC.c.root = 1;
        my $N = [grep { $_ ne $rC } @{Y.vs}];
        push @$N, $rC;
        # T.Z.$incv = 1||$setAcv makes A,Celf, 
        # A.mo.re array others (yarN) which may Acquire
        push @{A.mo.re->{0.22}||=[]}, map{
            my $CC = I.d&hup,$_;
            # all spreads out to play Y/V
            I.d&xot,$CC,{c=>C.c};
            [undef,$CC]
        }@$N;
        T.not = 1; # or more 78ism

    n Y =>23=><<'',{rg=>'J,V'}
        C.y.k = C.y.cv."\t".C.t;
        push @{V.os}, C.y.k unless C.c.root;
        # how happening to thingk
        # must ,,,, A.t to gain perception (not mid ex but should)
        # but yeah add things as lines rejoin
        A.Iso.O = 1;
    
    n Y =>231=><<'',{rg=>'J,V'}
        return if C.c.root;
        T.to = 0;
        A.t&S,6,2;
        T.not = 1 if !delete T.to;
    
    n Y =>3=><<'',{rg=>'J,V,yk'}
        C.y.lv = {k=>$k,C=>$C};
        C.y.at = {};
        C.y.ta = V.ta->{$k};
        C.y.vl = V.lv->{$k};
        if (C.c.root) { # / continues from 3 when everything's 6
            T.Z->{0.6} = 0.3;
            T.not = 1;
        }
    
    n Y =>49=><<'',{rg=>'J,V,yk,yat'}
        V.ta->{$k} = I.d&hup,$at;
        V.tv->{$k} = I.d&hup,$C;

    n Y =>58=><<'',{rg=>'J,V,yk,ylv,yvl'}
        V.lv->{$k} = $lv;
        if (C.c.root) {
            V.rl = $vl;
            V.rv = $lv;
            Rw TNews $J $talk:A.talk $rl:V.rl $rv:V.rv
                if J.V;
        }

    

