RB: | # inits A of ar C/N, pins spiral down (ret A.I that I.n,I.An,A.t)
    # non babzub, assume pbab skipped <<''s in origin
    my $A = {};
    
    A.oA = ar.oA if ar.oA;
    A.J = ar.J || die 'noJ';
    A.G = $G; # so travel can G/T/Hypo
    A.mo = $A;
    (A.am) = ar.t || ar.name || @{delete ar.m};
    A.am || die "unsame?";
    
    A.N = [ar.C || @{ar.N}];
    A.M = [];
    A.talk = "A.J.name ".(A.J.le && A.J.le.name);
    A.fl = ar.fl || {};
    A.I = {};
    
    my $I = delete G.drop.recycling->{A.J.id}->{A.am};
    
    my $II = Rw collaspII $A;
    
    if ($I) {
        if (I.Ii eq II.Ii) {
            say "Recyc A.talk! I.Ii continu" if A.J.V;
            #$I = {%$I,nF=>{}};
            A.I = $I;
            A.cv = 0.1;
        }
        else {
            sayre "Recycloped, Diff I.Ii  --  II.Ii" if A.J.V;
            undef $I;
        }
    }
    
    A.I.Ii = II.Ii;
    
    if (!$I) {
        $I = A.I||die'basenoi';
        Rw SNtl $I;
    }
    $A
Galso: | # Gooso goner # 
    G.h = sub {
        my $am = shift;
        my $D = $F[0];
        my $r = D.ar;
        my $A = r.A || die 'GhnoA';
        my $I = A.I || die 'GhnoI';
        I.d&Other,$am;
    };
    my %T = %{G.T||{}};
    G.T = \%T;
    {
        package Wormhole;
        use Tie::Hash;
        use YAML::Syck;
        our @ISA = qw(Tie::StdHash);
        sub FETCH {
            my ($s,$k) = @_;
            $s->{$k} ||= do{ 
            print "Loading w/$k ...\n" for 1..5;
            LoadFile("w/$k") };
        }
    }
    tie %T, 'Wormhole';
Seven: | # ^^^^^^^^^^^^^^^^^ is Motion, v is Sevening
    n Yesoo =>W
    n Yools =>W
    n Yuni =>W
    n Yeosleep =>W
    n Yosc =>W
    n Yeoodle =>W
    n Yeomp =>W
Yesoo: | # hoist in J most eo = Seve (above and below)
    u allvse
    n '','','%of:Mo'
    n J =>69,<<''
        J.most.eo = 'Sev';
        # dosgeo v Yesui as O or so
        # A pile v spiral
        # hive of change
Yex: |
    u allacgts
    
    n ex =>''=>{s=><<''},{acgt=>'i,K,cv,av',nois=>'# c',code=>"Sev 1"}
        # was Rw SNat $A $C $G $T $I $i $K $cv;
        # baseism
        my $c = 0+("0.".$cv);
        my $Av = $av || A.cv;
        my $sp = $av ? " Flav $av (no A.cv)" : "";
        .
        my $talk = "A.talk: $K$sp $Av > $c --- C.t ";
        .
        my $aim = {$K=>1};
        if ($aim->{A.am}) {
            $aim->{$_} = 1 for @{A.Isl||[]};
            aim.I = 1;
        }
        .
        my $yv = {};
        # make K/cv/t -> cv/K/t
        for my $k (sort keys %$i) {
            my $ii = $i->{$k};
            .
            next if $k eq 'Ii';
            next if $k eq 'ooI';
            ref $ii eq 'HASH' || die "weird $k=$ii";
            .
            for my $vc (sort keys %$ii) {
                my $iii = $ii->{$vc};
                die'$k !0<$vc<1' unless $vc > 0 && $vc < 1;
                $yv->{$vc}->{$k} = $iii;
            }
        }
        .
        # do stuff
        my $vb; # in fractions
        for my $vc (sort keys %$yv) {
            my $is = $yv->{$vc};
            my $s = {};
            my $x = {};
            my $xrd = [];
            .
            next if $vc <= $Av && $vc != $c;
            next if $vc > $c;
            .
            if (0 && $K eq 'Sev') {
                saybl "We $K - $vb -> $vc  ".join', ',
                    map{"$_: ".@{A.mo.re->{$_}}} sort keys %{A.mo.re||{}};
            }
            if ($vb && $vc > $vb && (
                @{A.N} || @{A.mo.re->{$vb}||[]}
                )) {
                # sincing, wide order
                # various others want to be around for only some of the process...
                sayre "$vb -> $vc  bump, ". @{A.N} if A.J.V > 1;
                T.Z->{$vb} = 1;
                A.cv = $vb; # so we dont wind up to 6 on the way out of t
                return T.not = 1;
            }
            for my $k (sort keys %$is) {
                my $iii = $is->{$k};
                .
                next unless $aim->{$k} || (aim.I && A.Iso->{$k});
                .
                for my $ik (sort keys %$iii) {
                    my $D = $iii->{$ik};
                    .
                    if (my $nk = D.sc.nk) {
                        my $C = I.nF.C;
                        next if !exists $C->{$nk};
                        if (my $gk = D.sc.gk) {
                            next if !exists $C->{$nk}->{$gk};
                        }
                    }
                    my $act;
                    my $dont;
                    if (D.sc.acgt && D.sc.act) {
                        $act = 1;
                        # acgtsubs can be defined at any cv
                        # run themselves if act
                        # usu. one receiver (Ci) and the rest scheme
                        die "D.t .act gets... D.sc.act" if D.sc.act ne '1';
                        $dont = 1 if exists A.I->{D.t};
                    }
                    .
                    # way or acgt-setuping-way
                    unless ($dont) {
                        my $paw = join"_",'',$k,$vc,D.t;
                        $paw =~ s/\W//g;
                        Rw $paw $A $C $G $T $__D:D;
                    }
                    # most tiny ticks
                    # this ind is all flywheel
                    # it's a kind of unity that wants to be a block of code like this
                    # and #c
                    my @is = A.s;
                    #
                    @is = I.d&scIfs,D.sc.Ifs if D.sc.Ifs;
                    #
                    sayre("Skip D.t")&&next if !@is;
                    #.2 || wdump 4,[map{
                    #    my $s = $_;
                    #    !ref $s ? $s : map {
                    #        my $v = $s->{$_};
                    #        "$_: $v ".ki $v;
                    #    } sort keys %$s;
                    #}D.sc.Ifs,"++++++++++++++",T.d])
                    if ($act) {
                        push @$xrd, [$k,$ik];
                        my $Ds = $x->{$k}->{$ik} ||= {};
                        say "Scupa";
                        Ds.D = $D;
                        Ds.is = \@is;
                        D.sc.its = @is;
                        # pin down poles
                        #I.cv = $vc;
                        #I.vb = $vb;
                        # draw curvles as spirals done
                    }
                    .
                    # TreeD
                    $s->{$k}->{$vc}->{$ik} = $D;
                }
            }
            my $se = Rw TreeD $s $scby=gro
                if A.J.V > 1 && keys %$s;
            $c == 0.1 ? saygr $se : say $se if $se;
            .
            for my $kik (@$xrd) {
                my ($k,$ik) = @$kik;
                my $Ds = $x->{$k}->{$ik};
                my $D = Ds.D;
                for my $s (@{Ds.is}) {
                    #ref $s eq 'HASH' || die "nothash $s ".wdump 4, $Ds;
                    D.sc.acgt eq 's'||die "nonacgts".wdump $D;
                    exists A.I->{D.t}||die "acgtI D.t not up: ".wdump A.I;
                    if (ref $s eq 'HASH' && exists s.talk) {
                        saybl "s.talk           s.d ";
                    }
                    #sayre "DElEE $talk $k $vc $ik  D.t D.y.cv     ".ki D.sc
                    #    if A.J.V > 1;
                    #say " for ".ki $s if A.J.V > 1;
                    .
                    I.d&D.t,$s;
                    #saybl "Done $talk D.t D.y.cv  ".ki D.sc
                    #    if A.J.V > 1;
                    .
                    I.acted and I.d&acted,$s;
                    if (my $ut = delete T.ut) {
                        if (ut.matchTd) {
                            unless (delete T.noTd) {
                                s.d.od || die "matchd root: OOgie";
                                s.d.od.s.T.m = 1;
                            }
                        }
                        else { die"utrowhat ".wdump 2, $ut }
                    }
                    .
                    # schools of many fish (not upcv if !@is)
                    $vb ||= $vc if D.sc.v;
                    last if T.not || T.whack;
                }
                last if T.not || T.whack;
            }
            .
            return if T.not;  # will &z, oseve
            return if delete T.whack;
        }
    
    # y
    
    n scIfs =>''=><<'','%als:#c'
        my @is;
        for my $k (keys %$s) {
            my $Q = $s->{$k};
            .
            my $in = [{s=>{T=>$T}}];
            my $pi = 0;
            for my $pin (@{Q.path}) {
                for my $pTn (@{Q.onpa}) {
                    I.d&pass,$pTn,$in;
                }
                I.d&pass,$pin,$in;
                @$in = map {
                    if (_.d) { # nonroot pattern mutable (into/on/off origin s)
                        my $su = $_;
                        $_ = _.d.s.T.q->{_.e.k} ||= $_;
                        #say "_.e.k con $_ tas $su" if $_ ne $su;
                    }
                    _.od ||= _.d if _.d;
                    _.d = $_;
                    _.e.lk = Q.atar->[$pi]||die"no idea what $pi is";
                    $_
                } grep{defined} @$in;
                $pi++;
                last if !@$in;
            }
            .
            for my $d (@$in) {
                # now inmost, .od leads above (without pTn inway)
                # and each d.e.lk calls it something $nk $gk and $wk
                    # and avoid less specific after more specific
                    # or just avoid repeats
                    #   
                    # shaky but index
                    # the fish is shaking but on the deck
                my $arg;
                my $up = $d;
                my $last = $up;
                my $i = 0;
                while ($up) {
                    $i++ > 8 && die "LAST WANDERS";
                    $arg->{up.e.lk} = up.e.k;
                    if (Q.caps) {
                        for my $k (grep{Q.caps->{$_}} keys %$up) {
                            $arg->{$k} ||= $up->{$k};
                        }
                    }
                    $last = $up;
                    $up = up.od;
                    if ($up eq $last) {
                        sayre "D.t D.sc.Td  refers to itself as .od: ".wdump $last;
                        last;
                    }
                }
                .
                arg.d = $d;
                .
                for my $k (keys %{d.s}) {
                    next if $k eq 'T';
                    $arg->{$k} && die "Already $k arg of ".wdump[$d,$arg];
                    $arg->{$k} = d.s->{$k};
                }
                .
                my $fo = "    ";
                $fo = "444 " if keys %{d.s.T && d.s.T.q || {}};
                .
                arg.talk = "C.t $fo($k:@{Q.path}) C.t C.y.cv:\t"
                    .join '/', map{$arg->{$_}} @{Q.atar};
                push @is, $arg;
                # Z/D wad of multiplicity
                # D args $d and arg, $nk/$ov etc things plucked
                # they must stay present to later Ds as well
                # stored T.d path subtlates
                # 6 ^
                sayre "arg.talk  ".ki $arg if A.J.V;
            }
        }
        @is
    

