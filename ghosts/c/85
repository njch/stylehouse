

yJLong: | # node read at here using event origin's apoly C.t (trhe ky)
    sayyl "Elis: J.name provcesses: E.sc.pi: E.t E.c.s";
    # c.z from CsE does path, this gets singularity of Js
    E.c.yJ ||
    Rw cJTrunk $J $C $E;
    
    # ne.C.t is name of re (s) aggregate pano to read
    my ($mo,$ne) = @{E.c.yJ};
    mo.mo.J eq $mo || die "momo no mo: mo.name";
    my $om = E.c.z->[0];
    $om = om.sc.J;
    #
    $om eq $J || die "om not on: om.name <-> J.name";
    
    my $dub = ne.C.y.cv * 2;
    my $t = $dub."\t".ne.C.t;
    my $cC = om.El.Pre.tv->{$t};
    $cC || return sayre "FIND MORE: ".wdump 3,[$t, om.El.Pre.tv];
    my $cJ = cC.sc.J;
    $cJ || die "No dubJar: om.name  and $t";
    my @routes = grep {_.sc.opel} @{cJ.El.Pre.vs};
    
    @routes || die "no routes for cJ.name";
    for my $r (@routes) {
        E.c.us = {ids=>[split ',',r.t],hopel=>r.sc.opel};
        say "givesd to router: r.t  => r.sc.opel";
        n $C
    }
    
climbo: | # hop down tv, for hJ
    my $tj = $J;
    my $h = djson E.c.us.hopel;
    my $i = -1;
    my @hopin;
    for my $l (@$h) {
        $i++;
        my ($t,$cv,$id) = @$l;
        if ($i == 0 && $id eq J.id) {
            #say "hop 1 is J.name";
        }
        else {
            my $vt = $cv."\t".$t;
            my $tv = tj.El.Pre.tv;
            $tj = $tv->{$vt}
                || return sayre "NO $vt on tj.name!!!"
                .wdump 3, [$l, OF=>$h,HAD=>$tv];
            $tj = tj.sc.J || die "no J on tj.t";
        }
        push @hopin, $tj;
        #sayyl "hop - tj.name";
    }
    E.c.hJ = [@hopin];
    
    #sayyl "Found a tj.name";
    
    return sayre("JevBo: J.ev.bo: J.name  C.sc.J.name  E.sc.J.name") &&
        Rw J.ev.bo
        if J.ev.bo;
    
    Rw clack;
    
SpaceFlos: | # node write, collected goo sticks (active agent & hi wires) gets E.t to thingdex routes to remote by C
    return sayre "E.t iutno self E.sc.J.name\n\n\n\n"
        if E.sc.J && E.sc.J.mo.J eq $J;
    
    my $K = E.c.s.t;

    #return saybl "Com\nCom" if J.El.Pre.tv->{"0.6\t$K"};
    sayyl "SPACE ELVIS: C.t: "
        .(E.sc.J && "E.sc.J.mo.J.name  E.sc.J.name");
    $K || die "noK?";
    if (my $so = J.ev.so) {
        my ($h) = map{_.nj}
        n $K=>3=>{pi=>$so=>s=>$K}

        E.c.s.sc.pi || die "E.t Ecs Holding strange: ".wdump 2, E.c.s;

        E.c.s.c.h = $h;
        # esc gas radar, sol can embed or so
    }
    #
    my $opl = J.ev.opl || 'annopl';
    n $K=>6=>{pi=>$opl=>s=>$E},"%qs"

    saybl "SpaceFlos: done: ".F_delta();
    
Elis: |
    E.c.trJ eq $J && return
        Rw clack Doublysendo;
    E.c.trJ = $J;
    J.ev.av && sayre("On to J.name: J.ev.av") && # on arrival
        Rw J.ev.av;
    
    J.ev.li && return
        sayyl("JevLi: J.ev.li: J.name  C.sc.J.name  E.sc.J.name") &&
        Rw J.ev.li;
    
    my $f = J.ev.f;
    $f = {split':',$f,2} if !ref $f;
    for my $pi (keys %$f) {
        E.sc.pi eq $pi || next;
        my $d = $f->{$pi};
        my $pin = ref $d ? die "ref f d in $pi" : $d;
        sayyl "Elis: $pi to $pin";
        return
        Rw $pin;
    }
    
    E.sc.was && return saybl "E.t was: $_ ".E.c.s;
    
    # double take aft writedown
    J.ev.tr && return
        Rw J.ev.th;
    
    Rw clack + Elisi;
    
    
middle: |
    my $E = Rw CsE $C;
    say "midd: C.t has E.t: E.c.s ".(E.c.us && "(us)");
    # us, ids are brain tickets, tractorbeam does Elis first time
    if (J.ev.tr && E.c.trJ ne $J || !E.c.us || E.c.us.ids->[E.c.us.idi - 1] eq J.id) {
        Rw Elis + $E;
    }
    else {
        Rw zyeuter $A $C $J $E;
    }
clack: |
    sayyl "UNclassified something F-1 at J.name";
    saybl "M<essage: ".wdump ar.m if ar.m;
    saybl wdump J.ev;
    
    Rw talkzyh;
    
talkzyh: |
    # z is the waypoints, 
    # yJ the yonder (origin) stack, 
    # hJ the here stack
    for my $k (qw'z yJ hJ') {
        saybl("no $k") && next unless E.c->{$k};
        saybl "$k $k $k $k $k $k" for 1..2;
        sayyl ref _.sc ? ki $_ : " - _.name    ". ki _.C.sc for @{E.c->{$k}};
    }
    
yJBlab: |
    say "Vertical E:Js";
    say " - _.t   _.y.cv  ".ki(_.c.s)." :: ".ki(_.c.e)
       ."    ****** ".ki(_.sc)for map{_.C}@{C.c.yJ};
cJTrunk: |
    my $E = ar.E || ar.C;
    E.c.yJ = Rw yJTrunk $C:E;
    #Rw yJBlab $C:E;
yJTrunk: | # from C.sc.J, uup
    my $jay = C.sc.J;
    my @js;
    while ($jay) {
        push @js, $jay;
        $jay = jay.Jiter || last;
    }
    [ reverse @js ];
idTrunk: |
    my $E = ar.E || ar.C;
    E.c.yJ = Rw yJTrunk $C:E;
    [ map { {id=>_.id,t=>_.C.t,cv=>_.C.y.cv} } @{E.c.yJ} ]
idToE: |
    my $ids = Rw idTrunk $C:s;
    my $mo = $ids->[0];
    my $la = $ids->[-1];
    my $l = [map{[_.t=>_.cv=>_.id]}@$ids];
    my $t = join ',',map{_.id}$mo,$la;
    return ($t,$l)
    

