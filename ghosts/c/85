
threJ: | # Sav Sav # elvis moves
    u allvse
    # heaven's above me on a street called love
    n J =>344,<<'','%code:oJ'
        my $ins = sub { my $J = shift; $J ne J.mo.J ? "J.mo.J.name ' J.name" : J.name };
        if (C.c.e) {
            my $new = !J.A.first ? "(first!)":"";
            A.V&E &&
            say $ins->(A.J)."   is elvising to  ".$ins->($J)." $new\n    "
                ." C.t  ".ki(C.c)."     ".ki(C.sc);
            C.c.elv = delete C.c.e if $new;
            # do over after osc (or time2 could in middle)
            # donow, may wat
            A.Iso.th = 1;
        }
        else {
            A.J eq $J && die sayre "THreJ does Celt A.J.name   ".(C.c.e && ki C.c.e);
            #saybl $ins->(A.J)." can create -----> ".$ins->($J);
            if (J.ev.amb) {
                Rw J.ev.amb $J;
            }
        }
    
    # fit e into 2
    n J =>632114142,<<'','%code:J'
        return if exists C.sc.pi;
        A.time = sub {
            my ($JJ,$q) = @_;
            $J eq $JJ || die "wtfJure  J.name   vs JJ.name";
            my $r = 1;
            if ($q == 2) {
                A.Subtle.time = 1;
                A.t&time,3,19;
                $r = 0 if T.pos == 0; # def 1, 0 if no change
                return $r;
            }
            .
            warn "T.alk other $q";
            if ($q == 8) {
                # until J.most coord attention evaporates
                # as in pulling on a list
            }
            $r
        }
    
    
    # coming to a known thing, engage wave lasso
    #   vector may want to wake up itself,
    #   e could time2 in, pre-osc 7 or post-osc 76
    #   also the e could know if its an incoming list,
    # bringing into the handler ...
    n '','','%of:th'
    n e =>36,<<'','%rg:J'
        $J || warn "e no J";
        # no J being tricks for handulation, event energy, unless T.oke
        delete A.Iso.oJ;
        .
        Rw hevt $J e36;
        .
        if (T.oke) {
            die "thoughts of a thous J.name" if A.J eq $J;
            delete A.Iso.th;
            A.Iso.oJ = 1;
            A.ztime = 6;
            return say "Tanking into J.name";
        }
        T.pos = 1 unless defined T.pos;
        T.pos &&
            Rw waito $J $C;
    
    # cancels proto this (threes)
    n J =>4,<<''
        return;
    
    # communication log, join proton, usually no trace of other in the self
    n e =>769,<<'','%rg:J'
        T.oke = 1; # unpin
    
    
    # T.oke means the vector wants to immediately handle e itself
    # or must m/osc some truth for the question, eg creating geo
    # the answer is laid along the tracks
    n elv =>2,<<'','%rg:J,code:time'
        C.c.e = delete C.c.elv;
        .
        Rw hevt $J elv2;
        .
        T.pos = 1 unless defined T.pos;
        # time true, complete vector, unless we cat a list
    
    
    n elv =>76,<<'','%rg:J,code:oJ'
        C.c.e = delete C.c.elv;
        .
        Rw hevt $J elv76;
        .
        if (T.oke) {
            die "76 thoughtself J.name" if A.J eq $J;
            say "Tanking 76 into J.name";
            Rw waited $J;
            return;
        }
        T.pos = 1 unless defined T.pos;
        T.pos &&
            Rw waito $J $C;
    
hevt: | # nonself sends you (the mount) (C.c.e) (to middle, from e ev)
    my $pin = J.ev.th || 'hopend';
    saygr "In!to J.name  $pin      ".join', ', @{ar.m};
    Rw $pin + $J;
hopend: | # event end default that T.oke into pin
    my $E = Rw CsE $C;
    C.c.e = $E;
    T.oke = 1;
Elis: |
    E.c.trJ eq $J && return
        Rw clack Doublysendo;
    E.c.trJ = $J;
    J.ev.av && sayre("On to J.name: J.ev.av") && # on arrival
        Rw J.ev.av;
    
    J.ev.o && A.J ne $J && return
        saygr("othero: J.ev.o: A.J.name to J.name  C.sc.J.name  E.sc.J.name") &&
        Rw J.ev.o;
    
    J.ev.li && return
        saygr("JevLi: J.ev.li: A.J.name to J.name  ---  C.sc.J.name  E.sc.J.name") &&
        Rw J.ev.li;
        
    my @done;
    my @be = $E;
    my @not;
    being: while (@be) {
        my $E = shift @be;
        if (my $f = J.ev.f) {
            $f = {split':',$f,2} if !ref $f;
            for my $pi (keys %$f) {
                E.sc.pi eq $pi || next;
                my $d = $f->{$pi};
                my $pin = ref $d ? die "ref f d in $pi" : $d;
                A.V&E &&
                sayyl "Elis: $pi to $pin";
                push @done, $E;
                Rw $pin + $E;
                next being;
            }
        }
        if (my $t = J.ev.t) {
            say "J.name t for ".ki $E;
            for my $k (keys %$t) {
                E.t eq $k || next;
                my $pin = $t.>$k;
                if (ref $pin) {
                    die "More: ".ki $pin if 's' ne join' ',keys %$pin;
                    for my $i (keys %$pin) {
                        $i eq 's' || die "More to $k/$i: ".ki $t;
                        my $do = $pin.>$i;
                        $do eq 'M' || die "More to $k/$i: $do";
                        my $M = djson E.c.s;
                        push @be, @$M;
                        sayyl "MUltied E.t for ".@$M
                            ."  (".join', ',map{ref$_ eq'HASH'?
                            _.t : ki $_}@$M;
                    }
                    next being;
                }
                push @done, $E;
                say "t match: $k";
                Rw $pin + $E;
                next being;
            }
        }
        push @not, $E;
    }
    return if !@not;
    for my $E (@not) {
        if (E.sc.was) {
            saybl "E.t was: $_ ".E.c.s;
            next;
        }
        # double take aft writedown
        if (J.ev.tr) {
            Rw J.ev.th;
            next;
        }
        Rw clack + $E Elisi;
    }
    
CsE: | # collasp C.c.e& tube, decode line, gives E
    my $C = $C;
    my $z = [];
    while ($C) {
        push @$z, $C;
        $C = C.c.e;
    }
    my ($m,$E) = [];
    ($C,@$m,$E) = @$z;
    $E = pop @$m if !$E;
    die "No E".wdump $z if !$E;
    
    # interesting maps, exfolat:
    E.c.z = $z;
    E.c.m = $m;
    
    # & any
    if (!E.c.us && E.c.s =~ /^\{/) {
        E.c.us = eval{djson E.c.s};
        if (keys %{E.c.us} == 1 && E.c.us.event) {
            E.c.us = E.c.us.event;
        }
        die "KGAO: $@\n\n cs: E.c.s" if $@;
    }
    return $E
    
middle: |
    my $E = Rw CsE $C;
    A.V&E &&
    say "midd: C.t has E.t ".(E.c.us && "(us)");
    # us, ids are brain tickets, tractorbeam does Elis first time
    my $us = E.c.us;
    if (J.ev.tr && E.c.trJ ne $J
        || !$us
        || us.ids && us.ids->[E.c.us.idi - 1] eq J.id
        || us.p && do { my $tcv = us.p->[E.c.us.p_i - 1]; $tcv && $tcv->[0] eq J.name }
        ) {
        Rw Elis + $E;
    }
    else {
        Rw zyeuter + $E;
    }
    
zyeuter: | # via closeline on handling Trabit, resolve into Giddiness pile G.Wh, may network
    # c z is Croute of energy from event listener
    # c us is decoded event hash from s, is trust
    my $u = E.c.us;
    # send on with $C, next closeline shall re idi, maybe redime asapish
    # te .e modalism focuses on how to recursion
    # the line/pipe compresses as it substrates certainly
    # wants can do as J 8, fishing/finishing zom
    # could fork & do asap but rezoom results sluggishly
    # for an oozey process that writes small high quality about etc.
    my $oth;
    if (ref u.ids eq 'ARRAY') {
        my $res = sub {
            my $id = shift;
            # idyl || G.Wh
            G.Wh->{$id} || G.W->{$id};
        };
        # v should maybe just C pipeline ($z)
        u.idi ||= 0;
        my $i = 0;
        for my $id (@{u.ids}) {
            my $oJ = $res->($id);
            my $ta;
            if ($i == 0) {
                $oJ || die "alien space going $id";
                $ta = "Got this G";
            }
            elsif ($oJ) {
                $ta = "Would in";
            }
            if ($oJ && u.idi == $i) {
                u.idi = $i+1;
                $oth = $oJ;
                $ta .= " ~Routo $i";
            }
            my $name = $oJ ? oJ.name : "UNKNOWN";
            sayyl " ^ $id: $name    $ta" if A.V&V;
            last if $oth;
            $i++;
        }
        u.idi = $i+1;
    }
    elsif (ref u.p eq 'ARRAY') {
        my $res = sub {
            my $t = shift;
            G.M->{$t}
        };
        # v should maybe just C pipeline ($z)
        u.p_i ||= 0;
        my $i = 0;
        for my $t (@{u.p}) {
            my ($t) = @$t;
            my $oJ = $res->($t);
            my $ta;
            if ($i == 0) {
                $oJ || die "alien space going $t: ".wdump 2,G.M;
                $ta = "Got this G";
            }
            elsif ($oJ) {
                $ta = "Would in";
            }
            if ($oJ && u.p_i == $i) {
                u.p_i = $i+1;
                $oth = $oJ;
                $ta .= " ~Routo $i";
            }
            my $name = $oJ ? oJ.name : "UNKNOWN";
            sayyl " ^ $t: $name    $ta";# if A.V&V;
            last if $oth;
            $i++;
        }
        u.p_i = $i+1;
    }
    else {
        die "Quackvent: ".wdump $u;
    }
    $oth || die "no others ".ki $u;
    sayyl "Routing J.name: C.t   ---> oth.name";
    my $oJ = $J;
    if (my $J = $oth) {
        # e stackin, very end has anoth stackin that we travel & do
        n J.C.t,$C,$oJ
    }
    T.pos = 0;
    
yJLong: | # node read at here using event origin's apoly C.t (trhe ky)
    sayyl "Elis: J.name provcesses: E.sc.pi: E.t E.c.s";
    # c.z from CsE does path, this gets singularity of Js
    E.c.yJ ||= Rw yJTrunk $C:E;
    
    # ne.C.t is name of re (s) aggregate pano to read
    my ($mo,$ne) = @{E.c.yJ};
    mo.mo.J eq $mo || die "momo no mo: mo.name";
    my $om = E.c.z->[0];
    $om = om.sc.J;
    #
    $om eq $J || die "om not on: om.name <-> J.name";
    
    my $dub = ne.C.y.cv * 2;
    my $t = $dub."\t".ne.C.t;
    my $cC = om.El.Pre.tv->{$t};
    $cC || return sayre "FIND MORE: ".wdump 3,[$t, om.El.Pre.tv];
    my $cJ = cC.sc.J;
    $cJ || die "No dubJar: om.name  and $t";
    my @routes = grep {_.sc.opel} @{cJ.El.Pre.vs};
    
    @routes || die "no routes for cJ.name";
    for my $r (@routes) {
        E.c.us = {ids=>[split ',',r.t],hopel=>r.sc.opel};
        say "givesd to router: r.t  => r.sc.opel";
        n $C
    }
    
climbos: |
    J.ev.bo ||= 'bodos';
    Rw climbo;
climbo: | # hop down tv, for hJ
    my $tj = $J;
    my $h = E.c.us.hopel ?
        djson E.c.us.hopel
        :
        E.c.us.ids ?
        [map{[undef,undef,$_]}@{E.c.us.ids}]
        :
        E.c.us.p ?
        [map{[@$_,undef]}@{E.c.us.p}]
        :
        die "No way to climb into J.name with: ".wdump 2, E.c.us;
    shift @$h until !@$h || $h->[0]->[-1] eq J.id || $h->[0]->[0] eq J.name;
    !@$h && die "no hold";
    my @C;
    my $i = -1;
    for my $l (@$h) {
        $i++;
        my $f;
        my ($t,$cv,$id) = @$l;
        if ($i == 0 && ($id eq J.id || $t eq J.name)) {
            #say "hop 1 is J.name";
            $f = tj.C;
        }
        elsif (defined $t && defined $cv) {
            my $vt = $cv."\t".$t;
            my $tv = tj.El.Pre.tv;
            $f = $tv->{$vt}
                || return sayre "NO $vt on tj.name!!!"
                .wdump 3, [$l, OF=>$h,HAD=>$tv];
            
            #f.sc.J || die "no J for $t $cv on tj.t tj.name: ".sayyl wdump 2, $f;
        }
        elsif (defined $id) {
            my $oj = Rw lookiDuv $J:tj $id;
            $f = $oj || return sayre "No J on oj.name $id . .. ";
        }
        else {
            die "L hop: $i ? ".wdump 3, $h;
        }
        if ($f && f.y.cv == 0.9 && !f.sc.J) {
            saybl "SKipping: ".ki $f;
            next;
        }
        sayyl "Found: f.t";
        push @C, $f;
        my $fo = $tj;
        $tj = f.sc.J;
        if (!$tj && f.y.cv == 0.9) {
            $tj = f.c.J;
            $tj eq $fo || die "Tried to J find ".ki($f)
                ."\n but its cJ: tj.name   ne   fo.name";
        }
    }
    E.c.hJ = [grep{defined}map{_.sc.J}@C];
    E.c.hC = [@C];
    
    return sayre("JevBo: J.ev.bo: J.name  C.sc.J.name  E.sc.J.name") &&
        Rw J.ev.bo
        if J.ev.bo;
    
    Rw clack;
    
bodos: |
    my ($e,$pin,$ba) = map { ($_,_.sc.dos) }
        grep {_.sc.dos}
        @{E.c.hC},map{_.C}@{E.c.hJ};
    $e || return 
        Rw clack UNFOUNDCLIMB;
    
    sayyl "%dos: e.t  says   dos=$pin";
    $pin || die "nopindos ".wdump 4,[$e];
    Rw $pin;
lookiDuv: | # search Duv.ids, Duv.vs deeply for ids, returns the C with sc.J
    my @pos = $J;
    my $d = ar.d || 3;
    my @got;
    for (1..$d) {
        @got = grep{defined} map{ _.El.Duv.ids->{$id} } @pos;
        last if @got;
        my @onp = @pos;
        @pos = map{ @{_.El.Pre.vs||do{sayre "NO VS on _.name";[]}} }@pos;
        # ^^ eats Js, get C
        @got = grep{ _.sc.id eq $id || _.sc.J && _.sc.J.id eq $id } @pos;
        last if @got;
        @got = map {_.c.J.C}
            grep{ _.y.cv == 0.9 && do{
                saybl "Seem to have 9: _.c.J.name _.c.J.bb ".ki $_;
                saygr "Also $id for _.c.J.id   (_.c.J.name)";
                sayyl "Hado ".ki $_ for @onp;
            _.c.J && _.c.J.id eq $id } } @pos;
        last if @got;
        # vv feed back as Js
        @pos = grep{defined} map{_.sc.J} @pos;
    }
    #@got = map{ _.sc.J || die "$id id no J: ".ki $_ }@got;
    @got == 1 || sayre("Not found $id ! ".@got."\n".wdump(4,\@pos)) && return;
    shift @got;
clack: |
    sayyl "UNclassified something at J.name";
    sayre "M<essage: ar.m" if ar.m;
    saygr "J.name ev: ".ki J.ev;
    saybl "e\&us: ".ki E.c.us if E.c.us;
    
    Rw talkzyh;
    
talkzyh: |
    # z is the waypoints, 
    # yJ the yonder (origin) stack, 
    # hJ the here stack
    for my $k (qw'z yJ hJ hC') {
        saybl("no $k") && next unless E.c->{$k};
        saybl "$k $k $k $k $k $k" for 1..2;
        for (@{E.c->{$k}}) {
            if (ref _.sc) {
                $_ = G&hup,$_;
                _.y = _.y.cv if ref _.y;
                sayyl "   _.t  _.y \t".ki {c=>_.c,sc=>_.sc};
            }
            else {
                sayyl " - _.name    ". ki _.C.sc;
            }
        }
    }
    
yJTrunk: | # from C.sc.J, uup
    my $jay = C.sc.J;
    my @js;
    while ($jay) {
        push @js, $jay;
        $jay = jay.Jiter || last;
    }
    [ reverse @js ];
idTrunk: |
    my $E = ar.E || ar.C;
    E.c.yJ = Rw yJTrunk $C:E;
    [ map { {id=>_.id,t=>_.C.t,cv=>_.C.y.cv} } @{E.c.yJ} ]
idToE: |
    my $ids = Rw idTrunk $C:s;
    my $mo = $ids->[0];
    my $la = $ids->[-1];
    my $l = [map{[_.t=>_.cv=>_.id]}@$ids];
    my $t = join ',',map{_.id}$mo,$la;
    return ($t,$l)
    

