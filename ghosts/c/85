

yJLong: | # node read at here using event origin's apoly C.t (trhe ky)
    sayyl "Elis: J.name provcesses: E.sc.pi: E.t E.c.s";
    # c.z from CsE does path, this gets singularity of Js
    E.c.yJ ||= yJTrunk $C:E;
    
    # ne.C.t is name of re (s) aggregate pano to read
    my ($mo,$ne) = @{E.c.yJ};
    mo.mo.J eq $mo || die "momo no mo: mo.name";
    my $om = E.c.z->[0];
    $om = om.sc.J;
    #
    $om eq $J || die "om not on: om.name <-> J.name";
    
    my $dub = ne.C.y.cv * 2;
    my $t = $dub."\t".ne.C.t;
    my $cC = om.El.Pre.tv->{$t};
    $cC || return sayre "FIND MORE: ".wdump 3,[$t, om.El.Pre.tv];
    my $cJ = cC.sc.J;
    $cJ || die "No dubJar: om.name  and $t";
    my @routes = grep {_.sc.opel} @{cJ.El.Pre.vs};
    
    @routes || die "no routes for cJ.name";
    for my $r (@routes) {
        E.c.us = {ids=>[split ',',r.t],hopel=>r.sc.opel};
        say "givesd to router: r.t  => r.sc.opel";
        n $C
    }
    
climbos: |
    J.ev.bo ||= 'bodos';
    Rw climbo;
climbo: | # hop down tv, for hJ
    my $tj = $J;
    my $h = E.c.us.hopel ?
        djson E.c.us.hopel
        :
        E.c.us.ids ?
        [map{[undef,undef,$_]}@{E.c.us.ids}]
        :
        die "No way to climb into J.name with: ".wdump 2, E.c.us;
    shift @$h until !@$h || $h->[0]->[-1] eq J.id;
    !@$h && die "no hold";
    my @C;
    my $i = -1;
    for my $l (@$h) {
        $i++;
        my $f;
        my ($t,$cv,$id) = @$l;
        if ($i == 0 && $id eq J.id) {
            #say "hop 1 is J.name";
            $f = tj.C;
        }
        elsif (defined $t && defined $cv) {
            my $vt = $cv."\t".$t;
            my $tv = tj.El.Pre.tv;
            $f = $tv->{$vt}
                || return sayre "NO $vt on tj.name!!!"
                .wdump 3, [$l, OF=>$h,HAD=>$tv];
            f.sc.J || die "no J on tj.t";
        }
        elsif (defined $id) {
            my $oj = Rw lookiDuv $J:tj $id;
            $f = $oj || return sayre "No J on oj.name $id . .. ";
        }
        else {
            die "L hop: $i ? ".wdump 3, $h;
        }
        sayyl "Found: ".ki $f;
        push @C, $f;
        my $fo = $tj;
        $tj = f.sc.J;
        if (!$tj && f.y.cv == 0.9) {
            $tj = f.c.J;
            $tj eq $fo || die "Tried to J find ".ki($f)
                ."\n but its cJ: tj.name   ne   fo.name";
        }
    }
    E.c.hJ = [grep{defined}map{_.sc.J}@C];
    E.c.hC = [@C];
    
    return sayre("JevBo: J.ev.bo: J.name  C.sc.J.name  E.sc.J.name") &&
        Rw J.ev.bo
        if J.ev.bo;
    
    Rw clack;
    
bodos: |
    my ($e,$pin,$ba) = map { ($_,_.sc.dos) }
        grep {_.sc.dos}
        @{E.c.hC},map{_.C}@{E.c.hJ};
    $e || return 
        Rw clack UNFOUNDCLIMB;
    
    sayyl "%dos: e.t  says   dos=$pin";
    $pin || die "nopindos ".wdump 4,[$e];
    Rw $pin;
lookiDuv: | # search Duv.ids, Duv.vs deeply for ids, returns the C with sc.J
    my @pos = $J;
    my $d = ar.d || 3;
    my @got;
    for (1..$d) {
        @got = grep{defined} map{ _.El.Duv.ids->{$id} } @pos;
        last if @got;
        my @onp = @pos;
        @pos = map{ @{_.El.Pre.vs||do{sayre "NO VS on _.name";[]}} }@pos;
        # ^^ eats Js, get C
        @got = grep{ _.sc.id eq $id || _.sc.J && _.sc.J.id eq $id } @pos;
        last if @got;
        @got = map {_.c.J.C}
            grep{ _.y.cv == 0.9 && do{
                saybl "Seem to have 9: _.c.J.name _.c.J.bb ".ki $_;
                saygr "Also $id for _.c.J.id   (_.c.J.name)";
                sayyl "Hado ".ki $_ for @onp;
            _.c.J && _.c.J.id eq $id } } @pos;
        last if @got;
        # vv feed back as Js
        @pos = grep{defined} map{_.sc.J} @pos;
    }
    #@got = map{ _.sc.J || die "$id id no J: ".ki $_ }@got;
    @got == 1 || sayre("Not found $id ! ".@got."\n".wdump(4,\@pos)) && return;
    shift @got;
clack: |
    sayyl "UNclassified something F-1 at J.name";
    saybl "M<essage: ".wdump ar.m if ar.m;
    saybl wdump J.ev;
    
    Rw talkzyh;
    
talkzyh: |
    # z is the waypoints, 
    # yJ the yonder (origin) stack, 
    # hJ the here stack
    for my $k (qw'z yJ hJ hC') {
        saybl("no $k") && next unless E.c->{$k};
        saybl "$k $k $k $k $k $k" for 1..2;
        sayyl ref _.sc ? ki $_ : " - _.name    ". ki _.C.sc for @{E.c->{$k}};
    }
    
yJTrunk: | # from C.sc.J, uup
    my $jay = C.sc.J;
    my @js;
    while ($jay) {
        push @js, $jay;
        $jay = jay.Jiter || last;
    }
    [ reverse @js ];
idTrunk: |
    my $E = ar.E || ar.C;
    E.c.yJ = Rw yJTrunk $C:E;
    [ map { {id=>_.id,t=>_.C.t,cv=>_.C.y.cv} } @{E.c.yJ} ]
idToE: |
    my $ids = Rw idTrunk $C:s;
    my $mo = $ids->[0];
    my $la = $ids->[-1];
    my $l = [map{[_.t=>_.cv=>_.id]}@$ids];
    my $t = join ',',map{_.id}$mo,$la;
    return ($t,$l)
    

