

yJLong: | # node read at here using event origin's apoly C.t (trhe ky)
    sayyl "Elis: J.name provcesses: E.sc.pi: E.t E.c.s";
    # c.z from CsE does path, this gets singularity of Js
    E.c.yJ ||
    Rw cJTrunk $J $C $E;
    
    # ne.C.t is name of re (s) aggregate pano to read
    my ($mo,$ne) = @{E.c.yJ};
    mo.mo.J eq $mo || die "momo no mo: mo.name";
    my $om = E.c.z->[0];
    $om = om.sc.J;
    #
    $om eq $J || die "om not on: om.name <-> J.name";
    
    my $dub = ne.C.y.cv * 2;
    my $t = $dub."\t".ne.C.t;
    my $cC = om.El.Pre.tv->{$t};
    $cC || return sayre "FIND MORE: ".wdump 3,[$t, om.El.Pre.tv];
    my $cJ = cC.sc.J;
    $cJ || die "No dubJar: om.name  and $t";
    my @routes = grep {_.sc.opel} @{cJ.El.Pre.vs};
    
    @routes || die "no routes for cJ.name";
    for my $r (@routes) {
        E.c.us = {ids=>[split ',',r.t],hopel=>r.sc.opel};
        say "givesd to router: r.t  => r.sc.opel";
        n $C
    }
    
climbo: | # hop down tv, for hJ
    my $tj = $J;
    my $h = djson E.c.us.hopel;
    my $i = -1;
    my @hopin;
    for my $l (@$h) {
        $i++;
        my ($t,$cv,$id) = @$l;
        if ($i == 0 && $id eq J.id) {
            #say "hop 1 is J.name";
        }
        else {
            my $vt = $cv."\t".$t;
            my $tv = tj.El.Pre.tv;
            $tj = $tv->{$vt}
                || return sayre "NO $vt on tj.name!!!"
                .wdump 3, [$l, OF=>$h,HAD=>$tv];
            $tj = tj.sc.J || die "no J on tj.t";
        }
        push @hopin, $tj;
        #sayyl "hop - tj.name";
    }
    E.c.hJ = [@hopin];
    
    #sayyl "Found a tj.name";
    
    return sayre("JevBo: J.ev.bo: J.name  C.sc.J.name  E.sc.J.name") &&
        Rw J.ev.bo
        if J.ev.bo;
    
    Rw clack;
    
Elis: |
    J.ev.li && return
        sayyl("JevLi: J.ev.li: J.name  C.sc.J.name  E.sc.J.name") &&
        Rw J.ev.li;
    
    E.sc.pi eq 'panop' && return
        Rw SpaceFlos + $E;
    
    
    E.sc.was && return saybl "E.t was: $_ ".E.c.s;
    
    return
        Rw yJLong $J $C $E
        if E.sc.pi eq 'line';
    
    Rw clack;
    
middle: |
    my $E = Rw CsE $C;
    say "midd: C.t has E.t: E.c.s ".(E.c.us && "(us)");
    # us, ids are brain tickets
    if (!E.c.us || E.c.us.ids->[E.c.us.idi - 1] eq J.id) {
        Rw Elis + $E;
    }
    else {
        Rw zyeuter $A $C $J $E;
    }
clack: |
    sayyl "UNclassified something F-1 at J.name";
    saybl wdump J.ev;
    
    Rw talkzyJhJ;
    
talkzyJhJ: |
    # z is the waypoints, 
    # yJ the yonder (origin) stack, 
    # hJ the here stack
    for my $k (qw'z yJ hJ') {
        saybl "$k $k $k $k $k $k" for 1..2;
        sayyl ref _.sc ? ki $_ : " - _.name    ". ki _.C.sc for @{E.c->{$k}};
    }
    
yJBlab: |
    say "Vertical E:Js";
    say " - _.t   _.y.cv  ".ki(_.c.s)." :: ".ki(_.c.e)
       ."    ****** ".ki(_.sc)for map{_.C}@{C.c.yJ};
cJTrunk: |
    my $E = ar.E || ar.C;
    E.c.yJ = Rw yJTrunk $C:E;
    #Rw yJBlab $C:E;
yJTrunk: | # from C.sc.J, uup
    my $jay = C.sc.J;
    my @js;
    while ($jay) {
        push @js, $jay;
        $jay = jay.Jiter || last;
    }
    [ reverse @js ];
idTrunk: |
    my $E = ar.E || ar.C;
    E.c.yJ = Rw yJTrunk $C:E;
    [ map { {id=>_.id,t=>_.C.t,cv=>_.C.y.cv} } @{E.c.yJ} ]
idToE: |
    my $ids = Rw idTrunk $C:s;
    my $mo = $ids->[0];
    my $la = $ids->[-1];
    my $l = [map{[_.t=>_.cv=>_.id]}@$ids];
    my $t = join ',',map{_.id}$mo,$la;
    return ($t,$l)
    

