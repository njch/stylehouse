

yJLong: | # node read at here using event origin's apoly C.t (trhe ky)
    sayyl "Elis: J.name provcesses: E.sc.pi: E.t E.c.s";
    # c.z from CsE does path, this gets singularity of Js
    E.c.yJ ||= yJTrunk $C:E;
    
    # ne.C.t is name of re (s) aggregate pano to read
    my ($mo,$ne) = @{E.c.yJ};
    mo.mo.J eq $mo || die "momo no mo: mo.name";
    my $om = E.c.z->[0];
    $om = om.sc.J;
    #
    $om eq $J || die "om not on: om.name <-> J.name";
    
    my $dub = ne.C.y.cv * 2;
    my $t = $dub."\t".ne.C.t;
    my $cC = om.El.Pre.tv->{$t};
    $cC || return sayre "FIND MORE: ".wdump 3,[$t, om.El.Pre.tv];
    my $cJ = cC.sc.J;
    $cJ || die "No dubJar: om.name  and $t";
    my @routes = grep {_.sc.opel} @{cJ.El.Pre.vs};
    
    @routes || die "no routes for cJ.name";
    for my $r (@routes) {
        E.c.us = {ids=>[split ',',r.t],hopel=>r.sc.opel};
        say "givesd to router: r.t  => r.sc.opel";
        n $C
    }
    
climbo: | # hop down tv, for hJ
    my $tj = $J;
    my $h = E.c.us.hopel ?
        djson E.c.us.hopel
        :
        E.c.us.ids ?
        [map{[undef,undef,$_]}@{E.c.us.ids}]
        :
        die "No way to climb into J.name with: ".wdump 2, E.c.us;
    shift @$h until !@$h || $h->[0]->[-1] eq J.id;
    !@$h && die "no hold";
    my @C;
    my $i = -1;
    for my $l (@$h) {
        sayyl "for   @$l";
        $i++;
        my $f;
        my ($t,$cv,$id) = @$l;
        if ($i == 0 && $id eq J.id) {
            say "hop 1 is J.name";
            $f = tj.C;
        }
        elsif (defined $t && defined $cv) {
            my $vt = $cv."\t".$t;
            my $tv = tj.El.Pre.tv;
            $f = $tv->{$vt}
                || return sayre "NO $vt on tj.name!!!"
                .wdump 3, [$l, OF=>$h,HAD=>$tv];
            f.sc.J || die "no J on tj.t";
        }
        elsif (defined $id) {
            my $oj = Rw lookiDuv $J:tj $id;
            sayyl "Found: ".ki $oj;
            $f = $oj || return sayre "No J on oj.name $id . .. ";
        }
        else {
            die "L hop: $i ? ".wdump 3, $h;
        }
        push @C, $f;
        $tj = f.sc.J;
        #sayyl "hop - tj.name";
    }
    E.c.hJ = [grep{defined}map{_.sc.J}@C];
    E.c.hC = [@C];
    sayyl "Found a tj.name";
    
    return sayre("JevBo: J.ev.bo: J.name  C.sc.J.name  E.sc.J.name") &&
        Rw J.ev.bo
        if J.ev.bo;
    
    Rw clack;
    
bodos: |
    my ($e,$pin,$ba) = map { ($_,_.sc.dos) }
        grep {_.sc.dos}
        @{E.c.hC},map{_.C}@{E.c.hJ};
    $e || return 
        Rw clack UNFOUNDCLIMB;
    
    sayyl "%dos: e.t  says   dos=$pin";
    $pin || die "nopindos ".wdump 4,[$e];
    Rw $pin;
lookiDuv: | # look at Duv.ids and even ((Duv.vs)) deeply for ids
    my @pos = $J;
    my $d = ar.d || 3;
    my @got;
    for (1..$d) {
        @got = grep{defined} map{ _.El.Duv.ids->{$id} } @pos;
        last if @got;
        @pos = map{ @{_.El.Pre.vs||do{sayre "NO VS on _.name";[]}} }@pos;
        @got = grep{ _.sc.id eq $id || _.sc.J && _.sc.J.id eq $id } @pos;
        last if @got;
        @pos = grep{defined} map{_.sc.J} @pos;
    }
    #@got = map{ _.sc.J || die "$id id no J: ".ki $_ }@got;
    @got == 1 || return sayre "Not found $id ! ".@got;
    shift @got;
SpaceFlos: | # node write, collected goo sticks (active agent & hi wires) gets E.t to thingdex routes to remote by C
    return sayre "E.t iutno self E.sc.J.name\n\n\n\n"
        if E.sc.J && E.sc.J.mo.J eq $J;
    
    my $K = E.c.s.t;

    #return saybl "Com\nCom" if J.El.Pre.tv->{"0.6\t$K"};
    sayyl "SPACE ELVIS: C.t: "
        .(E.sc.J && "E.sc.J.mo.J.name  E.sc.J.name");
    $K || die "noK?";
    if (my $so = J.ev.so) {
        my ($h) = map{_.nj}
        n $K=>3=>{pi=>$so=>s=>$K}

        E.c.s.sc.pi || die "E.t Ecs Holding strange: ".wdump 2, E.c.s;

        E.c.s.c.h = $h;
        # esc gas radar, sol can embed or so
    }
    #
    my $opl = J.ev.opl || 'annopl';
    n $K=>6=>{pi=>$opl=>s=>$E},"%qs"

    saybl "SpaceFlos: done: ".F_delta();
    
Elis: |
    E.c.trJ eq $J && return
        Rw clack Doublysendo;
    E.c.trJ = $J;
    J.ev.av && sayre("On to J.name: J.ev.av") && # on arrival
        Rw J.ev.av;
    
    J.ev.li && return
        sayyl("JevLi: J.ev.li: J.name  C.sc.J.name  E.sc.J.name") &&
        Rw J.ev.li;
    
    my $f = J.ev.f;
    $f = {split':',$f,2} if !ref $f;
    for my $pi (keys %$f) {
        E.sc.pi eq $pi || next;
        my $d = $f->{$pi};
        my $pin = ref $d ? die "ref f d in $pi" : $d;
        sayyl "Elis: $pi to $pin";
        return
        Rw $pin;
    }
    
    E.sc.was && return saybl "E.t was: $_ ".E.c.s;
    
    # double take aft writedown
    J.ev.tr && return
        Rw J.ev.th;
    
    Rw clack + Elisi;
    
    
middle: |
    my $E = Rw CsE $C;
    say "midd: C.t has E.t: E.c.s ".(E.c.us && "(us)");
    # us, ids are brain tickets, tractorbeam does Elis first time
    if (J.ev.tr && E.c.trJ ne $J || !E.c.us || E.c.us.ids->[E.c.us.idi - 1] eq J.id) {
        Rw Elis + $E;
    }
    else {
        Rw zyeuter $A $C $J $E;
    }
clack: |
    sayyl "UNclassified something F-1 at J.name";
    saybl "M<essage: ".wdump ar.m if ar.m;
    saybl wdump J.ev;
    
    Rw talkzyh;
    
talkzyh: |
    # z is the waypoints, 
    # yJ the yonder (origin) stack, 
    # hJ the here stack
    for my $k (qw'z yJ hJ hC') {
        saybl("no $k") && next unless E.c->{$k};
        saybl "$k $k $k $k $k $k" for 1..2;
        sayyl ref _.sc ? ki $_ : " - _.name    ". ki _.C.sc for @{E.c->{$k}};
    }
    
yJTrunk: | # from C.sc.J, uup
    my $jay = C.sc.J;
    my @js;
    while ($jay) {
        push @js, $jay;
        $jay = jay.Jiter || last;
    }
    [ reverse @js ];
idTrunk: |
    my $E = ar.E || ar.C;
    E.c.yJ = Rw yJTrunk $C:E;
    [ map { {id=>_.id,t=>_.C.t,cv=>_.C.y.cv} } @{E.c.yJ} ]
idToE: |
    my $ids = Rw idTrunk $C:s;
    my $mo = $ids->[0];
    my $la = $ids->[-1];
    my $l = [map{[_.t=>_.cv=>_.id]}@$ids];
    my $t = join ',',map{_.id}$mo,$la;
    return ($t,$l)
    

