Travel:
   yJ: |
     'clw waz gui TravelingMeans'
   Em: |
     sayyl "TRAVEL EM  aj.J.name" for 1..5;
     if (aj.J.yt.clw) {
         Rw J5 shv $aj;
     }
     
     my $c = aj.c;
     die 'scs' if @{aj.sc};
     die 's' if aj.s;
     my $M = ['','',{W=>G.Wid},{z=>aj.c}];
     #sayyl wdump 15, $M;
     aj.c = [" a\.om({},".sjson($M).",a,{});"];
     aj.sent = 1;
     
     Rw paintaj $aj;
     
     # also some J.headlev readings for .i
     aj.sent = 1;
     
     # route aj.W from ...
     G.Wh->{aj.Wid} ||= do {
         my $ij = {}; map {
         $ij->{$_} = $aj->{$_} if !/^[sc]+/; } keys %$aj;
         ij.id = delete ij.Wid;
         ij.y = 'W';
         
         sayyl "Life! of ij.y ij.id";
         0->tai("ij.y/ij.id\.i", $ij);
         0->tac("V/H.style/H.name/H.id\.s", ztm($ij));
         aj.J;
     };

     Rw J5 wu $aj;
     
     aj.y ||= 'J';
     aj.yy = 'W';
     Rw aji $aj;
     Rw blabaj $aj;
     
newwave: |
    saygr "EXactly";
    G.oin = Rw JJ join;
    Rw up $J:G.oin;
    
    #Rw zoybracken;
    Rwyl 1 fresh_init;
    1
join:
     yJ: |
       G.oin = $J;
       my $bz = J.bz;
       J.bz = sub {
           say "  bz ".join'      ',@_;
           $bz->(@_);
       };
       'join clw'
     up: |
       # G.oin root ww:
       Rw J5 wu;
       # iterations:
       Rw J5 toc;
       Rw J5 Ha;

     in: |
       my $oJ = $J;
       $J = G.oin;
       if (my $X = J.bb->{"oJ.name%J\t0.3"}) {
           Rw join/X $J:X;
       }
       saygr "Joining in oJ.name";
       Jn(oJ.name, 0.3, {J=>$oJ}, {});
       J.idJy->{oJ.id} = $oJ;
     X: |
       my $oJ = $J;
       $J = G.oin;
       my $is = J.bb->{"oJ.name%J\t0.3"};
       warn "not latest oJ.name... delete both ".wdump 3,[$is,$oJ] if $is ne $oJ;
       for my $oJ ($oJ, $is) {
           Rw J5 wu $X:oJ;
           Rw delbbl $J $l:oJ.name;
           oJ.dead = 1; # etcrise
       }
       sayyl "delete is.name";
       if (e.S) {
           Rw J5 $name;
       }
toc:
     yJ: |
       'toc'
     around: |
       Rw vortex toc/up $J $d=4;
     up: | #
       # hops, rhythm aesthetics
       # things pur ambiently & incur pipes of sprawlingness into music
       # to space it out right...
       # for the mass of the atom of thought
       # wants emit with precision, figure processing/Em route into time
       
       my $oJ = G.oin;
       my $ip = {style=>'wantime'};
       my @timey = Rw tvo $J:oJ $ip;
       my @go;
       for my $j (@timey) {
           my $y = j.s;
           my $x = J.bb->{"j.l%timex\t0.3"};
           $x += $d; # vortex 4s
           if ($x >= $y) {
               $x = 0;
               push @go, oJ.bb->{"j.l%J\t0.3"} || die "no find j.l oin";
           }
           else {
               #say "ti $x -- $y";
           }
           J.bz->("j.l%timex\t0.3" => $x);
       }
       for my $J (@go) {
           sayyl "toc up: J.name\n\n";
           Rw up $J;
       }
       #say 'timing '.join', ', map{_.l} @timey;
       #saybl "makde ".F_delta();
wa:
   yJ: |
     'Travel aww'
   M: |
    Rw vortex $J around $d=6;
    sayyl "Here in J.name sy";
    #Rw J6 - Wkcs; 
    Rw J6 - Vil;
    Rw J6 - Vuel;
    #Rw J6 - Hosp;
    #Rw J6 - Eosse;
    #Rw J6 - EYZ;
    #Rw J6 - Wander;
    
    Jn(st=>0.9=>"o",'%hs:8427,fs:4');
    Rwyl 0.01 waps;
Wkcs:
   yJ: |
     'Travel'
   M: |
    sayyl "J.name" for 1..5;
    Mn(shedful => '', {pi=>'seas',s=>'w/d'});
    
Vil:
   yJ: |
      'Travel'
   M: |
      Mn(hah => {thy=>1}, {pi=>'eye',s=>'eye/fug'});
      
      Mn(ZIS => {thy=>0.1}, {pi=>'text',s=>"Thisway"});
Vuel:
   yJ: |
      'Travel'
   M: |
      #J.zip == 1 &&
      my $g = {map{$_=>"$G->{$_}"}keys %$G};
      G.way.Vuel.curves = <<'';
      zoom 0  0.7
      curve 0 0.3
      x 0.02 0.2
      
      my @s = Rw wuck $J */curves;
      #sayyl wdump [@s];
      
      
      my $vs = Rw tc $J:G.oin;
      Mn(deef=>'',{pi=>'vs',s=>$vs});

Wander:
   yJ: |
      'Travel'
   M: |
      J.zip++ >= 5 && do{ J.zip = 0 };
      sayyl "J.name  J.zip" for 1..5;
      Rw J6 - Vil;
      
      
      J.zip == 1 &&
      Mn(ZIS => '', {pi=>'text',s=>"Thisway"});
      
      J.zip == 0 || J.zip == 2 &&
      Mn(ZIS => '', {pi=>'text',s=>"ones"});
      
      J.zip > 1 &&
      Mn(ZIS => '', {pi=>'text',s=>"sway"});
      
      J.zip > 2 &&
      Mn(skode => {thy=>3}, {pi=>'psfaus',s=>'THIS'});
      
      J.zip > 3 &&
      Mn(ZIStor => '', {pi=>'text',s=>"away..."});
      #sayylto "_.dead : ".gp $_ for values %{J.idly};
      #Mn(skoeede => '', {pi=>'text',s=>'THIS'});
      
      #Mn(With => 8, {J=>''}); # J with
      
      #Mn(Showi => 3, {pi=>'show',s=>8}); # any this 8
pi/show: |
     my $oJ = J.Jiter;
     
     
     
around: |
     inter({Jname=>ar.J.name}) if ref ar.J;
     my $tw = Rw huck + */around;
     
     if (!$tw) {
        Rw up +;
        Rw out +;
     }
     
     saygr "around ! ! J.name ".F_delta()
     unless J.yt.quiet;
     # try return stuff? pretty aroundo
     @{(values %$tw)[0]} if $tw
waz/up: |
      my $coi = Rw pha $J $k=jo;
      my $M=[];
      my $y = {o=>$M};
      my $A = J.A;
      A.ztime ||= 2;
      my $C = J.d;
      
      Rw Jhead;
      
      Rw suck */M $A $J $C $M $y;
      
      Jn('zoo',$y) if @$M;

      Jn(st=>0.9=>"o",'%hs:8427,fs:4');
      coi.qui = 1;
      coi.exactl->();
      
pi3: |
       my $oJ = $J;
       $oJ = C.y.o.J if C.y.o && C.y.o.J;
       # ^ string cheesae
       my $ca = oJ.bb->{C.t."%J\t".C.y.cv};
       $J = $ca || Rw spinash $J;
       
       my $A = J.most.A||{};
       $A = J.A = {%$A};
       A.in = $G->gip(J.Jiter.A.in, C.t)||{};
       J.A.coi = Rw pha $J ako;
       
       at.J = $J;
       at.pi = C.c.pi || 'guess';
       J.d = J.C = $C
       
       ; # jo ma in lo
       J.r = d.r; # be adjusting this xor
       Rw mkJid $J;
       J.bz->("/\t0.9" => "y");
pi6: |
       my $oJ = $J;
       $J = C.sc.J||die;
       
       my $A = J.A;
       my $T = {};
       
       my $M=[];
       my $y = {o=>$M};
       
       $v = C.sc.J||die;
       v.cv = C.c.gp.cv || C.c.cv || 0.6;
       die'csnod' if v.d ne $d || v.d.c ne d.c;
       
       my $path = C.sc.pi||die;
       $path = 'text' if J.A.d > 5;
       
       # sayyl "A kv    J.yg";
    
       # G is... suck */etc with trails
       # 
       my $u = C.c.s;
       
       Rw pi/$path $A $J $u $s:u $C $M $y; 
       
       Jn('zoo',$y) if @$M;
       
       A.coi.qui = 1;
       A.coi.exactl->();
pi/guess: |
     my $cg = $G->cgp($s);
     # ^
     # v
     my ($path) = grep { $cg->{$_} } qw'canpi ARRAY HASH ref undef text';
     $path = ref $s if $path eq 'canpi';
     $path = 'code' if ref $s eq 'CODE';
     $path ||= 'wtf';
     #$path = 'J' if $wa eq 'HASH' && u.bb;
     # can stick $wa on J.wa for thrashing maths
     # funcy fuzz fields
     # mutating spiral code
     
     Rw pi/$path;
     
pi7: |
       $v = C.sc.J||die;
       # can pin/ping light source of con paral
       my $name = v.most.eo || die "noeo";
       
       my $aj = Rw $name $J:v $catj=1;
       die aj.s if aj.s;
       
       #sayre "Upto J.r go ".slim 70, sjson aj.c if @{aj.c};
       v.Ec = [@{aj.c}];
       die wdump $aj if @{aj.sc};
       
gui: # turn into some
     yJ: |
       J.cv = 20;
       J.most.mody = 'mani';
       J.most.eo = 'chuv';
       'gui quigeo' 
     out: |
       #sayyl "gui GGEO OUTING J.name";
       Rw oJ $J geo &up $noesc=1;
       Rw chuv;
TravelingMeans:
   yJ: |
     my $A = J.A = J.most.A = {}; 
     A.time = sub{ 
         my ($J,$wa) = @_;
         J.A.ztime >= $wa ? 1 : do {
             sayre gp($J)." Wants time, $wa";
             acum $A, fo => $J;
             0;
         };
     };
     'splain';
Jeight: | # oo J hits
       my $ar = {%{d.c}};
       ar.J=d.s;
       
       return d.s if !A.hav && A.jr&ok-9;
       my $n = A.hav ? sub{} : A.jr&ok-9,9;
       
       Rw around;
       
       $n->();
enje: |  # travinje
               if (my $b = $G->gip(A.J.A.in, d.t)) { # outside in
                   $b = b._ || return;
                   say "d.t in: ".wdump $b;
                   g.extend->($d, $b);
               }

