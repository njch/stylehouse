Travel:
   yJ: |
     'clw waz gui TravelingMeans'
   Em: |
     if (aj.J.yt.clw) {
         Rw J5 shv $aj;
     }
     
     my $c = aj.c;
     die 'scs' if @{aj.sc};
     die 's' if aj.s;
     my $M = ['','',{W=>G.Wid},{z=>aj.c}];
     #sayyl wdump 15, $M;
     aj.c = [" a\.om({},".sjson($M).",a,{});"];
     aj.sent = 1;
     
     Rw paintaj $aj;
     
     # also some J.headlev readings for .i
     aj.sent = 1;
     
     # route aj.W from ...
     G.Wh->{aj.Wid} ||= do {
         my $ij = {}; map {
         $ij->{$_} = $aj->{$_} if !/^[sc]+/; } keys %$aj;
         ij.id = delete ij.Wid;
         ij.y = 'W';
         
         sayyl "Life! of ij.y ij.id";
         0->tai("ij.y/ij.id\.i", $ij);
         0->tac("V/H.style/H.name/H.id\.s", ztm($ij));
         aj.J;
     };

     Rw J5 wu $aj;
     
     aj.y ||= 'J';
     aj.yy = 'W';
     Rw aji $aj;
     Rw blabaj $aj;
     
   Io: |  # travinje
               if (my $b = $G->gip(A.J.A.in, d.t)) { # outside in
                   $b = b._ || return;
                   say "d.t in: ".wdump $b;
                   g.extend->($d, $b);
               }


noibz/yJ: |
       my $bz = J.bz;
       J.bz = sub {
           say "# J.name bz ".join'      ',@_;
           $bz->(@_);
       };
    
wa:
   yJ: |
     'Travel aww'
   M: |
    Rw vortex $J around $d=16;
    
    Rw J6 - Wkcs; 
    Rw J5 - Vil;
    #Rw J6 - Vuel;
    #Rw J6 - Hosp;
    Rw J6 - Eosse;
    #Rw J6 - EYZ;
    #Rw J6 - Wander;
    
    Jn(st=>0.9=>"o",'%hs:8427,fs:4');
    Rwyl 0.01 waps;
Wkcs:
   yJ: |
     'Travel'
   M: |
    sayyl "J.name" for 1..5;
    Mn(shedful => '', {pi=>'seas',s=>'w/d'});
    
Vil:
   yJ: |
      'Travel'
   M: |
      Mn(hah => {thy=>0.3}, {pi=>'eye',s=>'eye/fug'});
      J.V = 1;
      
      Jn(Vuel=>'',{W=>'Vuel'});
      
      J.V = 0;
      #$J:G.oin
      
      Mn(ZIS => {thy=>2}, {pi=>'text',s=>"Thisway"});
Vuel:
   yJ: |
      'Travel'
   M: |
      #J.zip == 1 &&
      my $g = {map{$_=>"$G->{$_}"}keys %$G};
      G.way.Vuel.curves = <<'' if 0;
      x 0 -0.2
      zoom 0  0.7
      curve 0 0.3
      x 0.02 0
      
      my @s = Rw wuck $J */curves;
      
      my $oJ = Rw J5 - shv;
      
      my $vs = Rw tc $J:oJ;
      #my $s = wdump $vs;
      my $rr = [map{[_.t,_.y.sc,_.sc.J]}@$vs];
      Mn(deef=>'',{pi=>'',s=>$rr});
Wander:
   yJ: |
      'Travel'
   M: |
      J.zip++ >= 5 && do{ J.zip = 0 };
      sayyl "J.name  J.zip" for 1..5;
      Rw J6 - Vil;
      
      
      J.zip == 1 &&
      Mn(ZIS => '', {pi=>'text',s=>"Thisway"});
      
      J.zip == 0 || J.zip == 2 &&
      Mn(ZIS => '', {pi=>'text',s=>"ones"});
      
      J.zip > 1 &&
      Mn(ZIS => '', {pi=>'text',s=>"sway"});
      
      J.zip > 2 &&
      Mn(skode => {thy=>3}, {pi=>'psfaus',s=>'THIS'});
      
      J.zip > 3 &&
      Mn(ZIStor => '', {pi=>'text',s=>"away..."});
      #sayylto "_.dead : ".gp $_ for values %{J.idly};
      #Mn(skoeede => '', {pi=>'text',s=>'THIS'});
      
      #Mn(With => 8, {J=>''}); # J with
      
      #Mn(Showi => 3, {pi=>'show',s=>8}); # any this 8
pi/show: |
     my $oJ = J.Jiter;
     
     
     
around: |
     inter({Jname=>ar.J.name}) if ref ar.J;
     if (!ar.A) {
         #die " J5 ah $d   J.name". join'  ', sort keys %$ar;
         return Rw J5
         
     }
     
     
     my $tw = Rw huck + */around;
     
     if (!$tw) {
        Rw up +;
        Rw out +;
     }
     
     saygr "around ! ! J.name ".F_delta()
     unless J.yt.quiet;
     # try return stuff? pretty aroundo
     @{(values %$tw)[0]} if $tw
waz/up: |
      my $coi = Rw pha $J $k=jo;
      my $M=[];
      my $y = {o=>$M};
      my $A = J.A;
      A.ztime ||= 2;
      my $C = J.C;
      
      Rw Jhead;
      
      Rw suck */M $A $J $C $M $y;
      
      Jn('zoo',$y) if @$M;

      Jn(st=>0.9=>"o",'%hs:8427,fs:4');
      coi.qui = 1;
      coi.exactl->();
      
Ajr: | # aimed at J and a line: C or t/cv    sends style => $v
      sub {
          my $s = shift;
          my $v = shift;
          my $d = shift;
          $s = '%'.$s if $s;  
          my $t = exists ar.t ? ar.t : ar.C.t;
          my $cv = exists ar.cv ? ar.cv : ar.C.y.cv;
          my $r = $t.$s."\t".$cv;
          if ($d) {
              sayre "delbbl $r  $d   J.name" for 1..5;
              Rw delbbl $J $l:t;
          }
          saybl " chuck $r     $v  >  ".J.bb->{$r} if J.V;
          !defined $v ?
            J.bb->{$r}
          : do {
              J.bz->($r, $v);
              sub { delete J.bb->{$r} } 
          };
      };
pie:
    yJ: |
      saybl "som.";









gui: # turn into some
     yJ: |
       J.cv = 20;
       J.most.mody = 'mani';
       J.most.eo = 'chuv';
       'gui quigeo' 
     out: |
       Rw oJ7;
TravelingMeans:
   yJ: |
     my $A = J.A = J.most.A = {}; 
     A.time = sub{ 
         my ($J,$wa) = @_;
         J.A.ztime >= $wa ? 1 : do {
             sayre gp($J)." Wants time, $wa";
             acum $A, fo => $J;
             0;
         };
     };
     'splain';

