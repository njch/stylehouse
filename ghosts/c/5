Travel:
   yJ: |
     'clw waz gui TravelingMeans'
   Em: |
     if (aj.J.yt.clw) {
         Rw J5 shv $aj;
     }
     
     my $c = aj.c;
     die 'scs' if @{aj.sc};
     die 's' if aj.s;
     my $M = ['','',{W=>G.Wid},{z=>aj.c}];
     #sayyl wdump 15, $M;
     aj.c = [" a\.om({},".sjson($M).",a,{});"];
     aj.sent = 1;
     
     Rw paintaj $aj;
     
     # also some J.headlev readings for .i
     aj.sent = 1;
     
     # route aj.W from ...
     G.Wh->{aj.Wid} ||= do {
         my $ij = {}; map {
         $ij->{$_} = $aj->{$_} if !/^[sc]+/; } keys %$aj;
         ij.id = delete ij.Wid;
         ij.y = 'W';
         
         sayyl "Life! of ij.y ij.id";
         0->tai("ij.y/ij.id\.i", $ij);
         0->tac("V/H.style/H.name/H.id\.s", ztm($ij));
         aj.J;
     };

     Rw J5 wu $aj;
     
     aj.y ||= 'J';
     aj.yy = 'W';
     Rw aji $aj;
     Rw blabaj $aj;
     
   Io: |  # travinje
               if (my $b = $G->gip(A.J.A.in, d.t)) { # outside in
                   $b = b._ || return;
                   say "d.t in: ".wdump $b;
                   g.extend->($d, $b);
               }
J6: |
   Rw J5 + $ok=6; 
J5: |
   my $r = {%$ar};
   r.J = delete($r->{m})->[0] if ar.m;
   delete r.R;
   my $d;
   d.c = $r;
   return sayre "RECUR" if @F > 130;
   Rw oo $J:G.oin $d;
newwave: |
    saygr "EXactly";
    G.oin = Rw JJ join;
    Rw up $J:G.oin;
    
    Rw cl/tidy;
    #Rw zoybracken;
    Rwyl 0.01 fresh_init;
    1
join:
     yJ: |
       G.oin = $J;
       my $bz = J.bz;
       J.bz = sub {
           say "#  bz ".join'      ',@_;
           $bz->(@_);
       };
       'join clw'
     up: |
       # G.oin root ww:
       Rw J5 wu;
       # iterations:
       Rw J5 toc;
       Rw J5 Ha;

     in: |
       my $oJ = $J;
       $J = G.oin;
       if (my $X = J.bb->{"oJ.name%J\t0.3"}) {
           Rw join/X $J:X;
       }
       Jn(oJ.name, 0.3, {J=>$oJ}, {});
       J.idJy->{oJ.id} = $oJ;
     X: |
       my $oJ = $J;
       $J = G.oin;
       my $is = J.bb->{"oJ.name%J\t0.3"};
       warn "not latest oJ.name... delete both ".wdump 3,[$is,$oJ] if $is ne $oJ;
       for my $oJ ($oJ, $is) {
           Rw J5 wu $X:oJ;
           Rw delbbl $J $l:oJ.name;
           oJ.dead = 1; # etcrise
       }
       sayyl "delete is.name";
       if (e.S) {
           Rw J5 $name;
       }
toc:
     yJ: |
       'toc'
     around: |
       Rw vortex toc/up $J $d=4;
     up: | #
       # hops, rhythm aesthetics
       # things pur ambiently & incur pipes of sprawlingness into music
       # to space it out right...
       # for the mass of the atom of thought
       # wants emit with precision, figure processing/Em route into time
       
       my $oJ = G.oin;
       my $ip = {style=>'wantime'};
       my @timey = Rw tvo $J:oJ $ip;
       my @go;
       for my $j (@timey) {
           my $y = j.s;
           my $x = J.bb->{"j.l%timex\t0.3"};
           $x += $d; # vortex 4s
           if ($x >= $y) {
               $x = 0;
               push @go, oJ.bb->{"j.l%J\t0.3"} || die "no find j.l oin";
           }
           else {
               #say "ti $x -- $y";
           }
           J.bz->("j.l%timex\t0.3" => $x);
       }
       for my $J (@go) {
           sayyl "toc up: J.name\n\n";
           Rw up $J;
       }
       #say 'timing '.join', ', map{_.l} @timey;
       #saybl "makde ".F_delta();
wa:
   yJ: |
     'Travel aww'
   M: |
    Rw vortex $J around $d=6;
    
    #Rw J6 - Wkcs; 
    Rw J6 - Vil;
    #Rw J6 - Vuel;
    #Rw J6 - Hosp;
    #Rw J6 - Eosse;
    #Rw J6 - EYZ;
    #Rw J6 - Wander;
    
    Jn(st=>0.9=>"o",'%hs:8427,fs:4');
    Rwyl 0.01 waps;
Wkcs:
   yJ: |
     'Travel'
   M: |
    sayyl "J.name" for 1..5;
    Mn(shedful => '', {pi=>'seas',s=>'w/d'});
    
Vil:
   yJ: |
      'Travel'
   M: |
      Mn(hah => {thy=>0.3}, {pi=>'eye',s=>'eye/fug'});
      J.V = 1;
      
      Jn(Vuel=>'',{W=>'Vuel'});
      
      J.V = 0;
      #$J:G.oin
      
      Mn(ZIS => {thy=>2}, {pi=>'text',s=>"Thisway"});
Vuel:
   yJ: |
      'Travel'
   M: |
      #J.zip == 1 &&
      my $g = {map{$_=>"$G->{$_}"}keys %$G};
      G.way.Vuel.curves = <<'';
      x 0 -0.2
      zoom 0  0.7
      curve 0 0.3
      x 0.02 0
      
      my @s = Rw wuck $J */curves;
      #sayyl wdump [@s];
      
      
      my $vs = Rw tc $J:G.oin;
      Mn(deef=>'',{pi=>'vs',s=>$vs});
Wander:
   yJ: |
      'Travel'
   M: |
      J.zip++ >= 5 && do{ J.zip = 0 };
      sayyl "J.name  J.zip" for 1..5;
      Rw J6 - Vil;
      
      
      J.zip == 1 &&
      Mn(ZIS => '', {pi=>'text',s=>"Thisway"});
      
      J.zip == 0 || J.zip == 2 &&
      Mn(ZIS => '', {pi=>'text',s=>"ones"});
      
      J.zip > 1 &&
      Mn(ZIS => '', {pi=>'text',s=>"sway"});
      
      J.zip > 2 &&
      Mn(skode => {thy=>3}, {pi=>'psfaus',s=>'THIS'});
      
      J.zip > 3 &&
      Mn(ZIStor => '', {pi=>'text',s=>"away..."});
      #sayylto "_.dead : ".gp $_ for values %{J.idly};
      #Mn(skoeede => '', {pi=>'text',s=>'THIS'});
      
      #Mn(With => 8, {J=>''}); # J with
      
      #Mn(Showi => 3, {pi=>'show',s=>8}); # any this 8
pi/show: |
     my $oJ = J.Jiter;
     
     
     
around: |
     inter({Jname=>ar.J.name}) if ref ar.J;
     my $tw = Rw huck + */around;
     
     if (!$tw) {
        Rw up +;
        Rw out +;
     }
     
     saygr "around ! ! J.name ".F_delta()
     unless J.yt.quiet;
     # try return stuff? pretty aroundo
     @{(values %$tw)[0]} if $tw
waz/up: |
      my $coi = Rw pha $J $k=jo;
      my $M=[];
      my $y = {o=>$M};
      my $A = J.A;
      A.ztime ||= 2;
      my $C = J.d;
      
      Rw Jhead;
      
      Rw suck */M $A $J $C $M $y;
      
      Jn('zoo',$y) if @$M;

      Jn(st=>0.9=>"o",'%hs:8427,fs:4');
      coi.qui = 1;
      coi.exactl->();
      
Ajr: | # aimed at J and a line: C or t/cv    sends style => $v
      sub {
          my $s = shift;
          my $v = shift;  
          $s = '%'.$s if $s;  
          my $t = exists ar.t ? ar.t : ar.C.t;
          my $cv = exists ar.cv ? ar.cv : ar.C.y.cv;
          my $r = $t.$s."\t".$cv;
          !defined $v ?
            J.bb->{$r}
          : do {
              J.bz->($r, $v);
              sub { delete J.bb->{$r} } 
          };
      };
pie:
    yJ: |
      saybl "som.";
oJ2: | # 
    die "what the hell";
oW2: | # some get-J protocol
    my $t = T.J = T.W = $v;
    
    A.jr = Rw Ajr $J:G.oin $t $cv=0.3;
opi2: | # approach
    T.pi = $v || 'guess';
    T.J = 'pie';
    
    my $oJ = $J;
    $oJ = C.y.o.J if C.y.o && C.y.o.J;
    A.jr = Rw Ajr $J:oJ $C;
   
oJ3: | # MOD  being repeater
    my $ca = A.jr&J;
    C.sc.J = $ca if $ca; # resolve
     die wdump 3, $A;
    
    if (!ref C.sc.J) {
        if (C.sc.pi) {
            C.sc.J = Rw spinash $J;
        }
        else {
            my $o = {name=>d.c.J};
            C.sc.J = Rw JJ $o;
            sayyl "J3   Made o.name";
        }
    }
    
    my $J = C.sc.J;
    A.jr&J,$J;
       
    if (C.sc.pi) {
       my $A = J.most.A||{};
       $A = J.A = {%$A};
       
       A.in = $G->gip(J.Jiter.A.in, C.t)||{};
       
       J.A.coi = Rw pha $J ako;
       
       J.d = J.C = $C;
       J.r = C.r;
       
       J.bz->("/\t0.9" => "y");
    }
oJ6: |
    C.sc.pi && return
    Rw opi6;
    
    my $ar = {%{C.c}};
    ar.J=C.sc.J||die'noj';

    return C.s if !A.hav && A.jr&ok-9;
    
    my $n = A.hav ? sub{} : A.jr&ok-9,9;
    aft { $@ && do{sayre" BONG"for 1..10}; $n->(); };

    Rw around;
       
opi6: |
       my $oJ = $J;
       $J = C.sc.J||die;
       
       my $A = J.A;
       my $T = {};
       
       my $M=[];
       my $y = {o=>$M};
       
       $v = C.sc.J||die'noj';
       v.cv = C.c.gp.cv || C.c.cv || 0.6;
       die'csnod' if v.d ne $d || v.d.c ne d.c;
       
       my $path = C.sc.pi||die'nopi';
       $path = 'text' if J.A.d > 5;
       
       
       my $s = C.c.s;
       Rw pi/$path $A $J $u:s $s $C $M $y; 
       
       
       
       Jn('zoo',$y) if @$M;
       
       
       
       A.coi.qui = 1;
       A.coi.exactl->();
oJ67: | # around-out)   Em $aj ins   who knows about the A.J we are... 
    Rw oJ $J geo &up $noesc=1;
    Rw J.most.eo;
    # 
pi67: | # MOD pi     out cup           # REF JOIN A.c/sc
    my $J = C.sc.J||die;
    
    my $aj = Rw J.most.eo $J $catj=1;
    
    die aj.s if aj.s;
    #sayre "Upto J.r go ".slim 70, sjson aj.c if @{aj.c};
    J.Ec = [@{aj.c}];
    die wdump $aj if @{aj.sc};
       
oJ75: | # OUT J
    if (C.sc.pi) {
        $v = C.sc.J || die'enoJ'.C.t;
        die "Pi v.r has s" if v.s;
        delete at.s if defined at.s;
        die "Pi v.r no .Ec" if !@{v.Ec};
        acum $at, 'Esc', $_ for @{v.Ec};
    }
gui: # turn into some
     yJ: |
       J.cv = 20;
       J.most.mody = 'mani';
       J.most.eo = 'chuv';
       'gui quigeo' 
     out: |
       Rw oJ67;
TravelingMeans:
   yJ: |
     my $A = J.A = J.most.A = {}; 
     A.time = sub{ 
         my ($J,$wa) = @_;
         J.A.ztime >= $wa ? 1 : do {
             sayre gp($J)." Wants time, $wa";
             acum $A, fo => $J;
             0;
         };
     };
     'splain';

