Oth: |
    # rising 
    #Rw dumpGoinbb;
    J.A.tid++;
    n All
    
    'Oth'ne$s&&
    n $s
    # randonly pour time ^
    T.nose = 1;
    
dumpGoinbb: |
    my $bb = G.oin.bb;
    my $gg = G.oin.ddlwpp ||= {};
    saygr wdump 1, [ map{ 
        my $o = $gg->{$_};
        my $v = $bb->{$_};
        $gg->{$_} = $v;
        "$_:    $bb->{$_} ".($o ? $o ne $v ? "(o: $o)" : "(o)" : "");
    }grep{/J$/}sort keys %$bb];
All: |
    #n ww
    #Rw dumpGoinbb;
    #J.V = 1;
    n Byst
    n Check
    
Byst: | # the random for news interro
    G.Byst = $J;
    
Check: |
    Rw Loading;
    n wa =>''=>{pi=>'waps'}
    
    
Rig: | # Wild
    u Indulator
    u Modulator
    u Modems
    J.V = 1;
    n s=>''=>t
    Rw dow $Rig:J.A.I;
    # trigbacky, like there is a whole plateu of links aft tests
    `cp w/Rig w/Wild`;
    
Sit: | # linkup Seate, Remy
    n Seate
    n Remy
    
Seate: | # Seven
    u Seven
    n s=>''=>t
    # use Wild as always, Seate just the Seven thing for use with another Wild
    Rw dow $Seate:J.A.I;
    T.nose = 1; # dont Sev (next run may use trouble)
    
Remy: | # mix Wild + Seate = Remy, to becomer Wild as things join Rig
    J.A.IIII = ['G/T/Wild','G/T/Seate'];
    n s=>''=>t
    Rw dow $Remy:J.A.II;
    # do tests... contigo
    # merge/split things into Seate-good, Seate-bung etc
    
Eel: | # most wild (furthest from Wild, goes in circle)
    # u whateverworkon
    #u WhoAmI
    n s=>''=>t
    Rw dow $Eel:J.A.I;
    T.nose = 1; # dont Sev (next run may use trouble)
    # do tests... contigo
    # merge/split things into Seate-good, Seate-bung etc
    
Driver: |
    # takes over ghostality for ever
    J.A.IIII = G.IIII = ['G/T/Remy','G/T/Eel'];
    n Car
Car: |
    my $r = J.foib++;
    $r > 0 &&
    n foib =>''=>"foib$r",'%fs:'.(30 * (($r+1) / 3))
    
    
    n sto => 2 => {pi=>'ARRAY',s=>[THing=>With=>"The $r"]}
    
    #!$r &&
    #Rw wayt $d=4 $p=Top;
    n sjei => 3 => 'Steilrofoam'
    n jury => '2-7x8' => '$(000'
    
Stoops: |
    u grows
    n theS=>1=>{pi=>'cfile'=>s=>"life/S\.s"},'%ong:1'
    
    
grows: |
    u allacgts
    n notice =>''=><<'','%code:O 3,v:scong'
        # runs when ong things oscillate at all after init
        die "ONGSCILLATE";
        
Draw: | # most wild (furthest from Wild, goes in circle)
    u IIpifalls
    u pi3d
    u stopi_clife
    u clifeGkeeps
    n s=>''=>t
    Rw dow $Draw:J.A.I;
    # do tests... contigo
    # merge/split things into Seate-good, Seate-bung etc
    
Dwight: |
    J.A.IIII = [@{G.IIII},'G/T/Draw'];
    u SevWo
    
    J.V = 2;
    n s=>''=>t
    J.V = 1;
    #J.inV = 1;
    
    my $lot = "g/G/on";# g/G/way g/0/G g/G/cis";
    n shedful => '0.1-0.7', {pi=>'seas',s=>$lot}
    
    n s =>8=>"Stevewashere!".int(rand(9)),'%fs:30'
    
    J.fsjoi++ ||
    Rw loopby $b=0.2 $d=17 $p=Top;
        
Wight: |
    u SevWo
    n JSea
    J.V = 1;
    n s=>''=>t
    # could ahh...
    sayyl "HIHI ".wdump 1, $A;
    
ww: | # open this ghost
    u SevWo
    u uxWout
    
    n ww =>0.9,{},"%id:J.id,tt:H.ol,poi:0,ab:100,bgh:33.5.3.1"
    #G.Wid = J.id;
    #unshift @{aj.c}, jsq " \$('#ux').append(%s);", $s;
uxWout: |
    u allacgts
    #n ztojsM =>''=><<''
        # yellow
        #die "HWELO";
    
    
Wool: |
    u allacgts
    n JrW =>''=><<'',{acgt=>'J,r,lines'}
        my $em;
        em.lines = $lines;
        em.hitime = hitime();
        em.is.W = J.id;
        em.is.M = J.name;
        em.id = J.id.'.'.r.out;
        .
        G.Wh->{em.is.W} ||= do {
            sayyl "Life! of W em.is.W";
            my $me = I.d&hup,$em;
            delete me.lines;
            $me = sjson $me;
            sayyl "Would write $me";
            I.d&writef,"life/W/em.is.W\.i",$me;
            # kind of wants lvish pointerism
            # osc idly (was around before) would keep j etc, 
            # handy for travelish reentrances by third parties
            # Jmosts must subscribe to the Goin osc...
            # which give them a G-finding W above their own W
            # which they dont know about, it's routed to...
            $J
        };
        .
        my $append = @{r.oldz};
        I.d&writef,"life/W/em.is.W\.c",em.lines,$append;
        .
        I.d&writef,"life/J/em.id\.c",em.lines;
        # 
        my $catch = sjson {y=>J=>id=>em.id};
        I.d&writef,"life/J\.s",$catch,1;
        
    
    n writef =>''=><<'',{acgt=>'f,s,append'}
        saybl "SZOY: $f    ".slim(300,$s)." APPEND: $append";
        (my $d = $f) =~ s/\/[^\/]+?$//;
        unless (-d $d) {
            say "Making -d $d ...";
            `mkdir -p $d`;
        }
        .
        my $li = ref $s eq 'ARRAY' ? join("",map{/\n$/?$_:"$_\n"}@$s)
            : !ref $s ? $s
            : die "Wsome other $f type: $s";
        $li = encode_utf8 $li;
        .
        my $wa = {};
        wa.append = 1 if $append;
        .
        write_file($f,$wa,$li);
SevJs: |
    n Wool
    u allovse
    n '','','%of:Sev'
    
    n rootout =>582=><<'','%v:root'
        return unless A.J.most.J eq A.J || A.J.C.c.Wo;
SevWo: |
    n Wool
    u allovse
    n '','','%of:Sev'
    
    n rootout =>582=><<'','%v:root'
        return unless A.J.most.J eq A.J || A.J.C.c.Wo;
        # Wencaps the Wubstance behind the Jaulted door
        # good for clouding away entropy from the foundation
        my $r = Rw scd $rl:vl $rv:lv;
        # so so, wants to separate heaps
        return unless @{r.z};
        aft {
            $@ || return;
            sayre "$@  !~!! ".wdump 12, $r;
        };
        my $jsdo;
        if (I.ztojsM) {
            $jsdo = I.d&ztojsM,r.z;
        }
        else {
            my $M = ['','',{W=>G.oin.id},{z=>r.z}];
            $jsdo = [" a\.om({},".sjson($M).",a,{});"];
        }
        sayyl wdump 2,$r;
        I.d&JrW,$J,$r,$jsdo
    
paintaoj: |
     G.Wh->{aj.Wid} ||= do {
         my $ij = {}; map {
         $ij->{$_} = $aj->{$_} if !/^[sc]+/; } keys %$aj;
         ij.id = delete ij.Wid;
         ij.y = 'W';
         
         sayyl "Life! of ij.y ij.id";
         0->tai("ij.y/ij.id\.i", $ij);
         0->tac("V/H.style/H.name/H.id\.s", ztm($ij));
         aj.J;
     };
     aj.Wid || die "not Wid?";
     aj.hol = "H.style/H.name/H.id";
     aj.hitime = hitime;
     aj.name ||= aj.J.name;
Head: |
    n dsko
    #Rw dumpGoinbb;
    J.fsjoi++ ||
    Rw loopfourby $d=5 $p=Top;
    #J.V = 1;
Gapitan: |
    #u Uminy
    my $r = J.sdfffi++;
    # shoves Dwight etc into PieceMe (or something with PieceMe)
    # which shall keep eating it
    #my $D =
    #n Dwight
    #n PieceMe =>''=>{W=>PieceMe=>In=>D.nj}
    # TODO ^
    !$r &&
    Rw loopfourby $d=5 $p=Top;
    say "Jay: J.name ::: $J";
loopfourby: |
    Rw loopby + $b=4;
loopby: |
    map {
      $_ *= $b || 4;
      Rw wayt $d:_ $p=Top;
    } 1..$d;
PieceMe: | # many accumey
    u Uminy;
    n s=>''=>t
    J.V = 1;
Uminy: |
    u allvse
    n '','','%of:J'
    
    # c.In is given by A.J  - a transient offender
    # the process of In from there
    # c.In handled outside of main spout,
    # main spout diffed incase it overrides natives,
    # which should immediately something...
    n In =>8,<<'','%rg:cJ'
        my $oJ = A.J; # transient offender
        sayyl wdump 2,[map{_.name}$oJ,$In,$J];
        Rw Eatup $J $oJ $In;
    
Eatup: | # on behalf of oJ, follow In
    my $self = $J;
    my $J = Rw Elj $J In;
    my $f =
    n In.name =>''=>{pi=>deal=>s=>$In}
pi/deal: |
    # etnrop
    sayyl "PI DEAL";
    
    
    
Perl: |
    u allrawperl
    n PerlHead
    n Ibegin =>''=><<''
        my $I = {};
    
    n IStuff
    n KnowTime
    # adapts acgtsy spirals into etc
    # this all popped into
    J.V = 1;
    
PerlHead: |
    n perlhead =>0.01=><<'',{code=>"P 1"}
        #!/usr/bin/perl
        use strict;
        use warnings;
    
    
    #
    

