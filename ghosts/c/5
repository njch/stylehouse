Yup: |
    n Steev
    Mn(shedful => '0.1-0.7', {pi=>'seas',s=>'g/c/8 g/G/on'});
    J.V = 0;
     
Steev: |
    n Here=>''=>"IS STEVE"
    
Hypo: |
    J.V = 0;
    $G = Rw Gto;
    sayyl "Viewi  g...... J.A.ztime - A.ztime" for 1..2;
    
    Rw Viu;
    #u timery
    u Ein
    u Einond
    #u Shr
    
    #n stod=>''=>{pi=>ajyp=>s=>Duv=>W=>'Yup'}
    n sto =>''=>{pi=>'waps'}
    
    n something=>''=>{s=>rand(5)}
AJo: |
    my $aj = {Wid=>J.Jo.id,J=>J.Jo,id=>mkuid};
    #sayyl "N AJo ".wdump 3,[rv.i,rv.c,rv.sc];
    sayyl "N Ajo rv.i";
    
Shr: |
    n Towil=>''=>{},{code=>'J 67'=>way=>'AJo'}
      
arecode: |
    Mn(tocode=>''=>{}=>{code=>'I 4'=>some=>"thiung"});
    Mn(Umust=>6=>{}=>{code=>'U'=>also=>"something"});
qq: |
    # getting run t
    # qode qompiler
    # does each thing input... has out that joins up
    # J (above)  # does u thing
    #   J qq     # gets W/thing as inbryo or stored G.oin Wemotables
    #   ^        # settles (Jbove wants out, to do n)
    #   output G compressions (+/- laws)
    # J eats   " "
    
    
    #
# /home/s/Music/Nurse With Wound/2004 .mp3
fi: | #c
     my $point = ar.p || ar.pin || ar.m->[0];
     
     my $know;
     if (!ar.pin && ar.J) {
         my $J = ar.J;
         if ($point =~ /^\*\/(\w+)$/) {
             my $inway = $1;
             my $h = ar.h || G.way;
             $h = h.hooks if h.hooks;
             my @gu = @{J.yy.styleord};
             #@gu = @gu[0..5] if @gu > 6;
             my @so;
             for (@gu) {
                if (ref $h->{$_} eq 'HASH' && $h->{$_}->{$inway}) {
                    push @{$know||=[]}, "$_/$inway";
                    last if !ar.sucky;
                }
             }
         }
     }
     
     if (!$know) {
         my %wo = Rw findl +;


         my @keys = map { s/^\///; $_ } keys %wo;
         if (!ar.pin && ar.J) {
             my $J = ar.J;

             @keys = grep { my($K)=split'/',$_; J.yt->{$K} } @keys;
             my @or = @{J.yy.styleord};
             if (@or && @keys > 1) {
                 my $i = 1;
                 my $is = {map{$_=>$i++}@or};
                 @keys = sort {
                  $is->{($a=~/^(.+?)\//)[0]} <=> $is->{($b=~/^(.+?)\//)[0]}
                  } @keys;

                 if (!ar.sucky && @keys > 1) {
                     #sayre "Limiting @keys";
                     @keys = $keys[0];
                 }
             }
         }
         $know = [@keys];
     }
     #saybl "With: ar.J.name  $point    @$know" if ar.J && ar.J.name eq 'shv';
     @$know
babsubrip: |
            my $l = oA.subline;
            $l -= 4; # sub head lines
            my @l = split "\n", D.bab;
            my $st = $l[$l];
            if ($st =~ /s=><<''/) {
                $st =~ /^\S/ || die "first line start space: $st";
                $l++;
                my $ind;
                my @up;
                while (1) {
                    my $st = $l[$l];
                    last if !$st =~ /\S/;
                    $ind = $1 if !defined $ind
                        && ($st =~ /^(    ).*\S+/ || die "no start ind $st");
                    $st =~ /^$ind(.+)$/ || last;
                    push @up, $1;
                    $l++;
                }
                my $co = join '', map{"$_\n"} @up;
                @$N == 1 || die "allcode in swa";
                my $c = $N->[0]->[2];
                die "Swap ".wdump [c.s=>FOR=>$co] unless split("\n", c.s) == @up;
                c.s = $co;
            }

