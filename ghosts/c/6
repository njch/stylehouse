
Travel:
   yJ: |
     'clw waz gui'
   sh: |
     Rw J5 shv $aj;
   Em: |
     my $tw = Rw huck $J $aj */sh;
     $tw || die "nomount J.name";
      
     my $c = aj.c;
     die 'scs' if @{aj.sc};
     die 's' if aj.s;
     my $M = ['','',{W=>G.Wid},{z=>aj.c}];
     
     #sayyl wdump 15, $M if aj.J.name eq 'Vuel';
     aft {
     $@ || return;
     sayre "$@  !~!! ".wdump 35, $M;
     };
     aj.c = [" a\.om({},".sjson($M).",a,{});"];
     aj.sent = 1;
     
     Rw paintaj $aj;
     
     # route aj.W from ...
     G.Wh->{aj.Wid} ||= do {
         my $ij = {}; map {
         $ij->{$_} = $aj->{$_} if !/^[sc]+/; } keys %$aj;
         ij.id = delete ij.Wid;
         ij.y = 'W';
         
         sayyl "Life! of ij.y ij.id";
         0->tai("ij.y/ij.id\.i", $ij);
         0->tac("V/H.style/H.name/H.id\.s", ztm($ij));
         aj.J;
     };

     Rw J5 wu $aj;
     
     aj.y ||= 'J';
     aj.yy = 'W';
     Rw aji $aj;
     Rw blabaj $aj;
somewhere: |
     my @path = ar.j.sc.J || ar.j.J;
     while (1) {
        my $l = $path[0];
        unshift @path, l.Jiter || last;
     }
     #saybl wdump 2, ["Gootblock:",@path];
     
     say "avoid: ".gp shift @path until !@path || $path[0] eq $J;
     shift @path;
     my $path = join '/', map{_.C.t} @path;
     
     my $A = J.A;
     my $v = $G->suet($A, "in/$path");
     my $amo = 1.5;
     $amo = 0.8 if e.S;
     (v._.y.thy ||= 1) *= $amo;
     say "A in assign". wdump 14, [gp($J), $path, $v];
     return;
     
     #die wdump 2, [@lspath]; 
     #my $path = join '/', reverse @lspath;
     my $M = [];
     
     Mn('fro',{},"$path",'{ou:file}');
     
     Rw J5 wut $M;

oJ6: | # https://www.youtube.com/watch?v=tL8N_3tln0Y
    my $J = C.sc.J;
    # get to T it
    # faders instead of the do now of exo c intentions
    my $talk = "T J.most.J.name /// J.A.d J.name  J.A.ztime  ----- A.ztime";
    #sayyl "J.name lisn! C.t    $talk ";
    sayyl "isn!   $talk       C.t " if J.most.J eq 'Hypo';
    
    return T.last = 1 unless Atime(6);
    # locks/9compressionintotime
    die "doubly" if A.ztime < 9 && A.jr&bol;
    my $n = A.ztime >= 9 ? sub{} : A.jr&bol,9;
    aft { $n->(); $@||return; sayre "BANG J.name" for 1..3; };
    
    %$ar = (%$ar, %{C.c});
    if (exists C.sc.pi) {
        Rw opi6 + $J;
    }
    elsif (ref G.way->{J.name} eq 'HASH') {
        saybl "oJ6 C.t" unless J.yt.quiet;
        Rw around + $J;
        A.roundi = 1;
    }
    elsif (exists G.way->{J.name}) {
        saybl "oJ6666 C.t" unless J.yt.quiet;
        my $p = J.name;
        Rw oT6 + $p $J $A:J.A $C:J.C $T;
    }
       
opi6: |
    die'csnod' if $C ne J.C;
    die if !ar.T;
    
    J.cv = C.c.gp.cv || C.c.cv || 0.6;
    my $s = C.c.s;
    my $path = C.sc.pi||die'nopi';
    if (J.A.d > 7) {
        $path = 'text';
        warn "J.name J.A.d limit to text";
    }
    my $pin = "pi/$path";
    
    Rw oT6 + $pin $s $u:s;
waz/up: | # a strain
    #sayre "J.name is wazing";
    if (!J.yt.nohead) {
        Rw Jhead;
        Jn(st=>0.9=>"o",'%hs:8427,fs:4');
    }
    die if !ar.T;
    Rw oT6 + $p=*/M $J $A:J.A $C:J.C $T;
eighthnot: |
    my ($dir) = J.id =~ /(.)$/;
    my $lim = $dir > 6 ? 6 : $dir > 3 ? 5 : 4;
    if (J.A.tch++ > $lim) {
        J.A.tch = $lim - 4;
        return 1
    }
    return 0
oT6: |
    my $talk = "T J.most.J.name /// J.A.d J.name  J.A.ztime A.ztime";
    A.coi = Rw pha $J ako;
    if (exists C.sc.pi) {
        # telephone winch
        for (qw'ljm ljmo') {
             J.A->{$_} = J.Jiter.A->{$_}
             if J.Jiter && J.Jiter.A->{$_};
        }
        A.time = sub {
            my($JJ,$q) = @_;
            # then - is
            # crux to pi
            $J eq $JJ || die "wtf";
            # point to give up
            # so can much very, sculpt
            if ($q == 2) {
                A.ico = Rw pha $J ico;
                A.ico.qui = 1;
                A.ico.as->(A.coi);
                my $wt = A.ico.exactl->();
                
                if (wt.last && !wt.same) {
                    my $shuf = join "\n", map{"$_: ".wdump(1,$wt->{$_})}
                        grep {keys %{$wt->{$_}}} qw'new diff gone';
                    saybl "$talk  2222   $shuf";
                }
                
                Rw eighthnot $J
                 ? do { A.ico.wt.same = 0; }
                 : wt.same && return 0;
                
                # for jamcs screenfly
                J.A.ljm = [];
                J.A.ljmo = "fr  J.name";
                return 1;
            }
            warn "$talk other $q";
            if ($q == 8) {
                # until J.most coord attention evaporates
                # as in pulling on a list
            }
            A.ztime >= $q;
        };
    };

    my $M=[];
    my $y = {o=>$M};
    
    my $tw = Rw huck + $M $y;
    
    $tw || die "nothing! J.name";
    die "many".ki $tw if keys %$tw > 1;
    # set our C.c.s to [that], noise probe case, maybe

    Jn('z',$y) if @$M;
    
    my $sol = "?";
    if (A.ico && A.ico.wt.same) {
        my $cut = @{A.ico.ord};
        my @cc = @{A.coi.ord};
        if (@cc > $cut) {
            warn"J.name entered stuff after 2!".wdump [@cc, 
            '                 =============', @{A.ico.ord}];
        }
        A.coi.abandon->();
        if (my $ljm = J.A.ljm) {
            for my $ar (@$ljm) {
                ar.noR=1;
                Rw jamsc;
            }
        }
        sayre "SKIP $talk" if J.V || J.most.J.V;
        T.last = 1;
        $sol = "skip";
    }
    else {
        A.coi.qui = 1;
        my $wt = A.coi.exactl->();
        if (wt.same) {
            if (++J.A.wch > 4) {
                J.A.wch = 0;
                $sol = "same";
            }
            else {
               $sol = "skip";
               sayre "SAME $talk" if J.V || J.most.J.V;
                T.last = 1;
            }
        }
        else {
            $sol = "notsame";
        }
    }
    
    if (my $ti = J.most.J.A.timery) {
        ti.t->{J.name} = $sol;
        $ti->{$sol}++;
        if (J.name eq 'Wkcs') {
            say "Wkcs: ". k2 {w=>{W=>$ti}};
        }
    }
    

