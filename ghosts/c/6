




Travel:
   yJ: |
     my $A = J.A = J.most.A = {}; 
     A.time = sub{ 
         my ($J,$wa) = @_;
         J.A.ztime >= $wa ? 1 : do {
             sayre gp($J)." Wants time, $wa";    
             acum $A, fo => $J;
             0;
         };
     };
     'clw waz gui'
   sh: |
     Rw J5 shv $aj;
   Em: |
     my $tw = Rw huck $J $aj */sh;
     $tw || die "nomount J.name";
     
     my $c = aj.c;
     die 'scs' if @{aj.sc};
     die 's' if aj.s;
     my $M = ['','',{W=>G.Wid},{z=>aj.c}];
     
     #sayyl wdump 15, $M if aj.J.name eq 'Vuel';
     
     aj.c = [" a\.om({},".sjson($M).",a,{});"];
     aj.sent = 1;
     
     Rw paintaj $aj;
     
     # route aj.W from ...
     G.Wh->{aj.Wid} ||= do {
         my $ij = {}; map {
         $ij->{$_} = $aj->{$_} if !/^[sc]+/; } keys %$aj;
         ij.id = delete ij.Wid;
         ij.y = 'W';
         
         sayyl "Life! of ij.y ij.id";
         0->tai("ij.y/ij.id\.i", $ij);
         0->tac("V/H.style/H.name/H.id\.s", ztm($ij));
         aj.J;
     };

     Rw J5 wu $aj;
     
     aj.y ||= 'J';
     aj.yy = 'W';
     Rw aji $aj;
     Rw blabaj $aj;
somewhere: |
     my @path = ar.j.sc.J || ar.j.J;
     while (1) {
        my $l = $path[0];
        unshift @path, l.Jiter || last;
     }
     #saybl wdump 2, ["Gootblock:",@path];
     
     say "avoid: ".gp shift @path until !@path || $path[0] eq $J;
     shift @path;
     my $path = join '/', map{_.d.t} @path;
     
     my $A = J.A;
     my $v = $G->suet($A, "in/$path");
     my $amo = 1.5;
     $amo = 0.8 if e.S;
     (v._.y.thy ||= 1) *= $amo;
     say "A in assign". wdump 14, [gp($J), $path, $v];
     return;
     
     #die wdump 2, [@lspath]; 
     #my $path = join '/', reverse @lspath;
     my $M = [];
     Mn('fro',{},"$path",'{ou:file}');
     Rw J5 wut $M;
shd:
   sh: |
     Rw J5 shw $style=shv $aj;
   
   
shrad/curves: | 
       spun 0 0
       spin 0 0.2
       zoom 0 1.2 
       y    0  0.5
       x    0  0.6
       curve 0 1 
       # curve 0.4 0.4
       #spin 0.3 2
shv/curves: [EZ: cur/sjiv]
shw/curves: [EZ: cur/land]
  
cur/sjiv: |
       zoom 0 1.2
       y    0  0
       x    0  0.02
       curve 0 -0.2
       curve 0.4 0.4
       spin 0.3 2
cur/topd: |
       spun 0 0
       zoom 0 1.6
       y    0  0
       x    0  0.02
       curve 0 -0.3
cur/land: |
       spun 0 0.2
       zoom 0 1.6
       y    0.001  0.2
       x    0.001  0.9
       curve 0 -0.3 

