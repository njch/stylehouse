Jing: | # higher crinkles
    n Jlaces =>W
    n Jndi =>W
    # ^ 2,3
    n Jamping =>W
    n Jumps =>W
    # ^ 4:6,7
Jamping: | # timing of 6 & 7
    u allvse
    
    n '','','%of:Mo'
    
    # time out
    n J =>434,<<''
        $J = C.c.J = C.sc.J;
        # A falls
        # J.A persists
        J.A.first ||= hitime();
        if (C.sc.W && G.oin ne $J) {
            my $lev = G.oin.A.tid;
            if (J.A.tidi) {
                if ((J.A.tidi + 3) > $lev) {
                    A.ztime = 4;
                }
                else {
                    undef J.A.tidi;
                }
            }
        }
        sayre "same A.J.name =- J.name" if A.J eq $J;
        if (exists C.sc.pi) {
            die 'JiternotAJ' if J.Jiter ne A.J;
            die 'pimostJ'if J.most.J eq $J;
        }
        else {
            die 'esel' if J.most.J ne $J;
        }
        A.ztime ||= 6;
        A.time && die "Had atime";
        A.time = sub { # A.t& cover, serve single digit ad hocs, like 2
            my ($JJ,$q) = @_;
            die"JTIMEJ" if $JJ ne $J;
            A.ztime >= $q
        };
        if (C.sc.pi) {
            J.A.d = J.Jiter.A.d + 1;
            J.ind = join '  ', ('') x J.A.d;
            J.name = "J.A.d. C.c.pi*C.t";
            J.d = J.C = $C;
            A.ztime = 6 if A.ztime < 6;
        }
        A.talk .= "J: J.name";
Jumps: | # doing of 6 & 7
    u allvse
    
    n '','','%of:Mo'
    
    # https://www.youtube.com/watch?v=tL8N_3tln0Y
    n J =>6,<<''
        my $talk = "T A.cv A.ztime J.most.J.name       J.name";
        Atime(6) || return do {
            say"$talk   SKive!" if A.J.V;
            T.nose = 1;
        };
        sayyl "J6 ! C.t C.y.cv A.talk";
        A.t&J,7,1;
    
    n J =>7,<<''
        return if T.nose;
        return sayre "Tsame=T.same J.name" if T.same;
        say "oJ77 77 J.name -> J.most.eo" unless J.yt.quiet || C.sc.pi;
        Rw J.most.eo $J $A;
        # dos geo ^ Yesui
    
Jong: | # time holes
    n Jiterbug =>W
    n Juperfi =>W
Jiterbug: |
    u allvse
    
    # J2 locatre code
    n J =>6211,<<''
        return if exists C.c.pi;
        .
        if (A.ztime < 9) {
            if (A.jr&bol) {
                sayre "STOPPING ".ki($C) for 1..3;
            }
            A.bangdesk.aft.unblocknine = A.jr&bol,9;
        }
        A.bangdesk.bang.bang_ts = sub {
            A.jr&bang_ts,hitime
        };
        .
        C.c.pin = J.name;

    n J =>6212,<<''
        return unless exists C.c.pi;
        die'csnod' if $C ne J.C;
        J.cv = C.c.gp.cv || C.c.cv || 0.6;
        my $path = C.sc.pi||die'nopi';
        if (J.A.d > 9) {
            $path = 'text';
            warn "J.name J.A.d limit to text";
        }
        C.c.pin = "pi/$path";
        
    # J63 overlay light cones
    # the use-full
    n J =>631,<<''
        T.alk = "T A.cv J.most.J.name /// J.name  A.ztime";
        sayre "T.alk !" if J.V && J.A.d < 3;
        A.coi = Rw pha $J ako;
        # ^ would want bangdesk catchundo
        # but lets just have forked recently and discard errors
   
    # J66 T code exetcjer
    n J =>66,<<''
        my $M=[];
        my $y = {o=>$M};
        my $ar = {%{C.c}};
        #sayre "no ars" if !exists ar.s;
        ar.s = '' if !exists ar.s;
        ar.u = ar.s;
        ar.pin = C.c.pin || die "nopin";
        .
        Rw ar.pin + $A $C $G $T $J $M $y;
        # set our C.c.s to [that], noise probe case, maybe
        Jn('z',$y) if @$M;
        # T may cause big recoil of Mo/J, miss pha closures:

    # full exact light ^ may take over (whack) from the usual given full cone:
    n J =>677,<<''
        A.coi.qui = 1;
        my $wt = A.coi.exactl->();
        if (wt.same) {
            if (++J.A.wch > 4) {
                J.A.wch = 0;
                # ^ rate to avoid v see J 632 eighthnot
            }
            else {
               sayre "SAME T.alk" if J.V || J.most.J.V;
               T.same = 1;
            }
        }
    
cutland: |
    Rw $pin;
Juperfi: |
    u allvse
    # the use-less - in a good way
    n J =>632,<<''
        return unless exists C.sc.pi;
        .
        map { # telephone winch
             J.A->{$_} = J.Jiter.A->{$_}
             if J.Jiter && J.Jiter.A->{$_};
        } qw'ljm ljmo';
        .
        A.time = sub {
            my($JJ,$q) = @_;
            $J eq $JJ || die "wtfJure";
            # wanna A.t&T,2,0 us to difference streams
            # they could be xot maps or code to run
            # then all over things 
            .
            if ($q == 2) {
                A.ico = Rw pha $J ico;
                A.ico.qui = 1;
                A.ico.as->(A.coi);
                my $wt = A.ico.exactl->();
                .
                if (wt.last && !wt.same) {
                    my $uf = join "\n", map{"$_: ".wdump(1,$wt->{$_})}
                        grep {keys %{$wt->{$_}}} qw'new diff gone';
                    saybl "T.talk  2222  $uf";
                }
                .
                Rw eighthnot $J
                 ? do { A.ico.wt.same = 0; }
                 : wt.same && return 0;
                .
                # for jamcs screenfly
                J.A.ljm = [];
                J.A.ljmo = "fr  J.name";
                return 1;
            }
            .
            warn "T.alk other $q";
            if ($q == 8) {
                # until J.most coord attention evaporates
                # as in pulling on a list
            }
            A.ztime >= $q;
        };
    
    # J67 if early exact light
    n J =>672,<<''
        return unless A.ico && A.ico.wt.same;
        # first the superstilled
        # anything T_D can arrange through time...
        # wants to join G subtly vis T and so....
        # should be no M in the first bit
        # it is just pinpricks of consciousness keeping it alive, like mtime
        # be nicer to do with an I that can T out of this whole change res patch
        my $cut = @{A.ico.ord};
        my @cc = @{A.coi.ord};
        if (@cc > $cut) {
            warn"J.name entered stuff after 2!".wdump [@cc, 
            '                 =============', @{A.ico.ord}];
        }
        A.coi.abandon->();
        if (my $ljm = J.A.ljm) {
            for my $ar (@$ljm) {
                ar.noR=1;
                Rw jamsc;
            }
        }
        sayre "SKIP T.alk" if J.V || J.most.J.V;
        T.whack = 1; # exit A.t&J
        T.same = 1; # exit Mo, T.not but not, kind of unlet ztime6->7
    

