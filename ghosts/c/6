Jing: | # higher crinkles
    n Jlaces =>W
    n Jndi =>W
    
Jlaces: |
    u allvse
    
    # early, do later
    n J =>0.211=>{s=><<''},{code=>'Mo 3211'}
        C.c.W = $J;
        die "In self: J.name" if $J eq A.J;
        A.ztime = 3 if A.J.name ne 'qq'; # break off
        
    n time =>0.212=>{s=><<''},{code=>'Mo 3212'}
        A.ztime = delete C.c.time;
        
    n pi =>0.213=>{s=><<''},{code=>'Mo 3213'}
        # crunch gravel, spreaders
        # - c. language is map to some u before 6ing
        ref $pi && die"refpi: ".wdump 2, $pi;
        T.at.pi = $pi || 'guess';
        C.c.J = 'pi'; # c.J causal
        my $oJ = A.J;
        # where this pi goes to
        # should be aj wander once 8 bodies float
        $oJ = C.y.o.J if C.y.o && C.y.o.J;
        .
        A.jr = Rw Ajr $J:oJ $C;
        sayyl "pi oJ.name";
    
    # Weave wires protocol, host pools
    n W =>0.213=>{s=><<''},{code=>'Mo 32132'}
        my $cv = 0.3;
        my $jr = Rw Ajr $J:G.oin $t:W $cv;
        if (C.c.pi) {
            C.c.W = jr&J;
            return;
        }
        my $t = $W;
        $t = W.name if ref $t;
        T.at.W = $t;
        T.at.J = ref $W ? $W : $t;
        C.c.J ||= $W;
        C.t = $t;
        C.y.cv ||= do { sayyl"Auto Wormole pitch C.t = $cv"; $cv };
        A.jr = $jr;
        # and where the thrust
        if (C.c.vv) {
            A.ztime = delete C.c.vv;
            A.jr&vv,9,9
        }
        sayyl "W";
    
Jndi: |
    u allvse
    
    # resolve
    n J =>0.31,<<'','%code:Mo 431'
        my $f = A.jr&J;
        my $j = C.sc.J;
        ref $j && ref $f && ($j eq $f || die ".sc J dif $f $j");
        # should T.at so vis, substrate insecting
        C.c.J = T.at.J = $f if $f && ref $f && !f.dead;
    
    n X =>0.32,<<'','%code:Mo 432'
        my $J = C.sc.J;
        sayyl "DELING J.name".ki$C;
        $J || die "X no J";
        ref $J || die "Nofound $J  C.t   C.y.cv";
        $X eq $J || die "noovewr X  C.c.X ne $J";
        A.jr&J,$J,9;
        J.dead = 1;
        # SNat bail, we have balin by now so hole in space this time
        T.not = 1;
    
    n J =>0.33,<<'','%code:Mo 433'
        return if ref $J;
        $J = Rw Jto $name:J;
        J.V = 1;
        ref $J || die 'watt'.$J;
        if (exists C.c.pi) {
            J.Jiter = A.J; # erse rev
            J.most->{$_} = A.J.most->{$_} for keys %{A.J.most||{}};
        }
        sayyl "J33   Made J.name";
        T.at.J = $J;
        A.jr&J,$J; # sc, c, and on sphere
        .
        sayre "A.talk: No s in C.t" if !exists C.c.s;
        sayre "A.talk: Non s in C.t" if !defined C.c.s;
        die "noovewr   C.c.J ne $J" if ref C.c.J && C.c.J ne $J;
        
    # time out
    n J =>0.34,<<'','%code:Mo 434'
        $J = C.c.J = C.sc.J;
        # A falls
        # J.A persists
        J.A ||= {first=>hitime()};
        die "same A.J.name =- J.name" if A.J eq $J;
        if (exists C.sc.pi) {
            die 'JiternotAJ' if J.Jiter ne A.J;
            die 'pimostJ'if J.most.J eq $J;
        }
        else {
            die 'esel' if J.most.J ne $J;
        }
        A.ztime ||= 6;
        if (C.sc.pi) {
            J.A.d = J.Jiter.A.d + 1;
            J.ind = join '  ', ('') x J.A.d;
            J.name = "J.A.d . C.c.pi*C.t";
            J.d = J.C = $C;
            A.time = sub {die "PROTO PI TIME CA"};
        }
        else {
            A.time = sub {die "PROTO J TIME CA"};
        }

    # https://www.youtube.com/watch?v=tL8N_3tln0Y
    n J =>0.6=>,<<'','%code:Mo 6'
        my $talk = "T J.most.J.name /// J.A.d J.name  J.A.ztime  ----- A.ztime";
        sayyl "isn!   $talk       C.t ";
        # pi runs controlled by mostJ
        # which is run when A.ztime uppity, convene
        return T.not = 1 unless exists C.sc.pi || Atime(6);
        A.t&J,7,1;
    
    n J =>0.7,<<'','%code:Mo 7'
        say "oJ7777 J.name" unless J.yt.quiet || C.sc.pi;
        Rw J.most.eo $J;
        # dos geo ^ Yesui
    
Jong: | # time holes
    n Jiterbug =>W
    n Juperfi =>W
Jiterbug: |
    u allvse
    # J2 locatre code
    n J =>0.6211,<<'','%code:J 6211'
        return if exists C.c.pi;
        C.c.pin = J.name;
        .
        if (A.ztime < 9) {
            my @am = A.jr&bol;
            die "doubly".wdump [@am] if A.jr&bol;
            A.bangdesk.aft.unblocknine = A.jr&bol,9;
        }
        A.bangdesk.bang.bang_ts = sub {
            A.jr&bang_ts,hitime
        };

    n pi =>0.6212,<<'','%code:J 6212'
        my $J = C.c.J;
        die'csnod' if $C ne J.C;
        J.cv = C.c.gp.cv || C.c.cv || 0.6;
        my $path = C.sc.pi||die'nopi';
        if (J.A.d > 9) {
            $path = 'text';
            warn "J.name J.A.d limit to text";
        }
        C.c.pin = "pi/$path";
        saybl "pi: C.c.pin";
        
    # J63 overlay light cones
    # the use-full
    n J =>0.631,<<'','%code:J 631'
        T.alk = "T J.most.J.name /// J.A.d J.name  A.ztime";
        sayre "T.alk !";
        A.coi = Rw pha $J ako;
        # ^ would want bangdesk catchundo
        # but lets just have forked recently and discard errors
Juperfi: |
    u allvse
    # the use-less - in a good way
    n J =>0.632,<<'','%code:J 632'
        return unless exists C.sc.pi;
        .
        map { # telephone winch
             J.A->{$_} = J.Jiter.A->{$_}
             if J.Jiter && J.Jiter.A->{$_};
        } qw'ljm ljmo';
        .
        A.time = sub {
            my($JJ,$q) = @_;
            $J eq $JJ || die "wtfJure";
            # wanna A.t&T,2,0 us to difference streams
            # they could be xot maps or code to run
            # then all over things 
            .
            if ($q == 2) {
                A.ico = Rw pha $J ico;
                A.ico.qui = 1;
                A.ico.as->(A.coi);
                my $wt = A.ico.exactl->();
                .
                if (wt.last && !wt.same) {
                    my $uf = join "\n", map{"$_: ".wdump(1,$wt->{$_})}
                        grep {keys %{$wt->{$_}}} qw'new diff gone';
                    saybl "T.talk  2222  $uf";
                }
                .
                Rw eighthnot $J
                 ? do { A.ico.wt.same = 0; }
                 : wt.same && return 0;
                .
                # for jamcs screenfly
                J.A.ljm = [];
                J.A.ljmo = "fr  J.name";
                return 1;
            }
            .
            warn "T.alk other $q";
            if ($q == 8) {
                # until J.most coord attention evaporates
                # as in pulling on a list
            }
            A.ztime >= $q;
        };
    
    # J66 T code exetcjer
    n J =>0.66,<<'','%code:J 66'
        my $M=[];
        my $y = {o=>$M};
        my $ar = {%{C.c}};
        ar.u = ar.s;
        die "no ars" if !exists ar.s;
        ar.pin = C.c.pin || die "nopin";
        .
        my $tw = Rw huck + $A $C $G $T $J $M $y;
        # TODO: my $tw = Rw huck $A $C $G $T + $M $y;
        # place %$ar in + in the new ar
        .
        $tw || die "nothing! J.name";
        sayre "SWel didit";
        die "many".ki $tw if keys %$tw > 1;
        # set our C.c.s to [that], noise probe case, maybe
        Jn('z',$y) if @$M;
        # T may cause big recoil of Mo/J, miss pha closures:
    
    # J67 exact light
    n J =>0.672,<<'','%code:J 672'
        return unless A.ico && A.ico.wt.same;
        # first the superstilled
        # anything T_D can arrange through time...
        # wants to join G subtly vis T and so....
        # should be no M in the first bit
        # it is just pinpricks of consciousness keeping it alive, like mtime
        # be nicer to do with an I that can T out of this whole change res patch
        my $cut = @{A.ico.ord};
        my @cc = @{A.coi.ord};
        if (@cc > $cut) {
            warn"J.name entered stuff after 2!".wdump [@cc, 
            '                 =============', @{A.ico.ord}];
        }
        A.coi.abandon->();
        if (my $ljm = J.A.ljm) {
            for my $ar (@$ljm) {
                ar.noR=1;
                Rw jamsc;
            }
        }
        sayre "SKIP T.alk" if J.V || J.most.J.V;
        T.whack = 1; # exit A.t&J
        T.same = 1; # exit Mo, T.not but not, kind of unlet ztime6->7
    
    # ^ may take over (whack) from the usual given full cone:
    n J =>0.677,<<'','%code:J 677'
        A.coi.qui = 1;
        my $wt = A.coi.exactl->();
        if (wt.same) {
            if (++J.A.wch > 4) {
                J.A.wch = 0;
                # ^ rate to avoid v see J 632 eighthnot
            }
            else {
               sayre "SAME T.alk" if J.V || J.most.J.V;
               T.same = 1;
            }
        }
    

