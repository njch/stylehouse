Jing: | # higher crinkles
    n Jlaces =>W
    n Jndi =>W
    
Jlaces: |
    u allvse
    
    n '','','%of:Mo'
    
    # early, do later
    n J =>3211,<<''
        C.c.W = $J;
        die "In self: J.name" if $J eq A.J;
        A.ztime = 3 if A.J.name ne 'qq'; # break off
        
    n time =>3212,<<''
        A.ztime = delete C.c.time;
        
    # crunch gravel, spreaders
    n pi =>3213,<<''
        # - c. language is map to some u before 6ing
        ref $pi && die"refpi: ".wdump 2, $pi;
        T.at.pi = $pi || 'guess';
        C.c.J = 'pi';
        my $oJ = A.J;
        $oJ = C.y.o.J if C.y.o && C.y.o.J;
        A.jr = Rw Ajr $J:oJ $C;
    
    # Weave wires protocol, host pools
    n W =>32132,<<''
        my $jr = Rw Ajr $J:G.oin $t:W $cv=0.3;
        .
        return C.c.W = jr&J if C.c.pi; # doing research
        A.jr = $jr; # being
        .
        my $t = $W;
        $t = W.name if ref $t;
        T.at.W = $t;
        T.at.J = ref $W ? $W : $t;
        C.c.J ||= $W;
        C.t = $t;
        C.y.cv ||= 0.3;
        # and where the thrust
        if (C.c.vv) {
            A.ztime = delete C.c.vv;
            A.jr&vv,'',9
        }
    
Jndi: |
    u allvse
    
    n '','','%of:Mo'
    
    # resolve,<<''
    n J =>431,<<''
        my $f = A.jr&J;
        my $j = C.sc.J;
        ref $j && ref $f && ($j eq $f || die ".sc J dif $f $j");
        # should T.at so vis, substrate insecting
        C.c.J = T.at.J = $f if $f && ref $f && !f.dead;
    
    n X =>432,<<''
        my $J = C.sc.J;
        sayre "DELING J.name".ki$C;
        $J || die "X no J";
        ref $J || die "Nofound $J  C.t   C.y.cv";
        $X eq $J || die "noovewr X  C.c.X ne $J";
        A.jr&J,$J,9;
        J.dead = 1;
        # SNat bail, we have balin by now so hole in space this time
        T.not = 1;
    
    n J =>433,<<''
        return if ref $J;
        $J = Rw Jto $name:J;
        ref $J || die 'watt'.$J;
        if (exists C.c.pi) {
            J.Jiter = A.J; # erse rev
            J.most->{$_} = A.J.most->{$_} for keys %{A.J.most||{}};
        }
        # til the I train shows up:
        J.V = 1 if A.J.V == 2 || J.most.J.inV;
        J.A.Indo = 2;
        J.A.III = ['G/T/Wild'];
        C.c.s ||= 'Wildy';
        # 
        sayyl "J33   Made J.name" unless J.Jiter;
        T.at.J = $J;
        A.jr&J,$J; # sc, c, and on sphere
        .
        sayre "A.talk: No s in C.t" if !exists C.c.s;
        sayre "A.talk: Non s in C.t" if !defined C.c.s;
        die "noovewr   C.c.J ne $J" if ref C.c.J && C.c.J ne $J;
        
    # time out
    n J =>434,<<''
        $J = C.c.J = C.sc.J;
        # A falls
        # J.A persists
        J.A ||= {first=>hitime()};
        sayre "same A.J.name =- J.name" if A.J eq $J;
        if (exists C.sc.pi) {
            die 'JiternotAJ' if J.Jiter ne A.J;
            die 'pimostJ'if J.most.J eq $J;
        }
        else {
            die 'esel' if J.most.J ne $J;
        }
        A.ztime ||= 6;
        A.time && die "Had atime";
        A.time = sub {
            my ($JJ,$q) = @_;
            die"JTIMEJ" if $JJ ne $J;
            A.ztime >= $q
        };
        if (C.sc.pi) {
            J.A.d = J.Jiter.A.d + 1;
            J.ind = join '  ', ('') x J.A.d;
            J.name = "J.A.d. C.c.pi*C.t";
            J.d = J.C = $C;
        }

    # https://www.youtube.com/watch?v=tL8N_3tln0Y
    n J =>6,<<''
        my $talk = "T A.cv J.most.J.name       J.name";
        return T.not = 1 unless exists C.sc.pi || 
            Atime(6);
        A.t&J,7,1;
    
    n J =>7,<<''
        say "oJ77 77 J.name" unless J.yt.quiet || C.sc.pi;
        Rw J.most.eo $J;
        # dos geo ^ Yesui
    
Jong: | # time holes
    n Jiterbug =>W
    n Juperfi =>W
Jiterbug: |
    u allvse
    
    # J2 locatre code
    n J =>6211,<<''
        return if exists C.c.pi;
        .
        if (A.ztime < 9) {
            if (A.jr&bol) {
                sayre "STOPPING ".ki($C) for 1..3;
            }
            A.bangdesk.aft.unblocknine = A.jr&bol,9;
        }
        A.bangdesk.bang.bang_ts = sub {
            A.jr&bang_ts,hitime
        };
        .
        C.c.pin = J.name;

    n J =>6212,<<''
        return unless exists C.c.pi;
        die'csnod' if $C ne J.C;
        J.cv = C.c.gp.cv || C.c.cv || 0.6;
        my $path = C.sc.pi||die'nopi';
        if (J.A.d > 9) {
            $path = 'text';
            warn "J.name J.A.d limit to text";
        }
        C.c.pin = "pi/$path";
        
    # J63 overlay light cones
    # the use-full
    n J =>631,<<''
        T.alk = "T A.cv J.most.J.name /// J.name  A.ztime";
        sayre "T.alk !" if J.A.d < 3;
        A.coi = Rw pha $J ako;
        # ^ would want bangdesk catchundo
        # but lets just have forked recently and discard errors
   
    # J66 T code exetcjer
    n J =>66,<<''
        my $M=[];
        my $y = {o=>$M};
        my $ar = {%{C.c}};
        sayre "no ars" if !exists ar.s;
        ar.s = '' if !exists ar.s;
        ar.u = ar.s;
        ar.pin = C.c.pin || die "nopin";
        .
        my $tw = Rw huck + $A $C $G $T $J $M $y;
        # TODO: my $tw = Rw huck $A $C $G $T + $M $y;
        # place %$ar in + in the new ar
        .
        die "manyornon: J.name: ".ki $tw if keys %$tw != 1;
        # set our C.c.s to [that], noise probe case, maybe
        Jn('z',$y) if @$M;
        # T may cause big recoil of Mo/J, miss pha closures:

    # full exact light ^ may take over (whack) from the usual given full cone:
    n J =>677,<<''
        A.coi.qui = 1;
        my $wt = A.coi.exactl->();
        if (wt.same) {
            if (++J.A.wch > 4) {
                J.A.wch = 0;
                # ^ rate to avoid v see J 632 eighthnot
            }
            else {
               sayre "SAME T.alk" if J.V || J.most.J.V;
               T.same = 1;
            }
        }
    
Juperfi: |
    u allvse
    # the use-less - in a good way
    n J =>632,<<''
        return unless exists C.sc.pi;
        .
        map { # telephone winch
             J.A->{$_} = J.Jiter.A->{$_}
             if J.Jiter && J.Jiter.A->{$_};
        } qw'ljm ljmo';
        .
        A.time = sub {
            my($JJ,$q) = @_;
            $J eq $JJ || die "wtfJure";
            # wanna A.t&T,2,0 us to difference streams
            # they could be xot maps or code to run
            # then all over things 
            .
            if ($q == 2) {
                A.ico = Rw pha $J ico;
                A.ico.qui = 1;
                A.ico.as->(A.coi);
                my $wt = A.ico.exactl->();
                .
                if (wt.last && !wt.same) {
                    my $uf = join "\n", map{"$_: ".wdump(1,$wt->{$_})}
                        grep {keys %{$wt->{$_}}} qw'new diff gone';
                    saybl "T.talk  2222  $uf";
                }
                .
                Rw eighthnot $J
                 ? do { A.ico.wt.same = 0; }
                 : wt.same && return 0;
                .
                # for jamcs screenfly
                J.A.ljm = [];
                J.A.ljmo = "fr  J.name";
                return 1;
            }
            .
            warn "T.alk other $q";
            if ($q == 8) {
                # until J.most coord attention evaporates
                # as in pulling on a list
            }
            A.ztime >= $q;
        };
    
    # J67 if early exact light
    n J =>672,<<''
        return unless A.ico && A.ico.wt.same;
        # first the superstilled
        # anything T_D can arrange through time...
        # wants to join G subtly vis T and so....
        # should be no M in the first bit
        # it is just pinpricks of consciousness keeping it alive, like mtime
        # be nicer to do with an I that can T out of this whole change res patch
        my $cut = @{A.ico.ord};
        my @cc = @{A.coi.ord};
        if (@cc > $cut) {
            warn"J.name entered stuff after 2!".wdump [@cc, 
            '                 =============', @{A.ico.ord}];
        }
        A.coi.abandon->();
        if (my $ljm = J.A.ljm) {
            for my $ar (@$ljm) {
                ar.noR=1;
                Rw jamsc;
            }
        }
        sayre "SKIP T.alk" if J.V || J.most.J.V;
        T.whack = 1; # exit A.t&J
        T.same = 1; # exit Mo, T.not but not, kind of unlet ztime6->7
    

