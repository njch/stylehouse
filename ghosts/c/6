Jaya: |
    =pod
    J holds an A with a time 
      ex holds
    =cut
    n Jetro
Jing: | # higher crinkles
    n Jlaces
    n Joot
    # ^ 2,3
    n Jamping
    n Jumps
    
    n Foli
    
    n Jiterbug
    n Juperfi
    # ^ 4:6,7
Jlaces: | # wires of together
    u allvse
    
    n '','','%of:Mo'
    
    n J =>3211,<<''
        C.c.W = $J unless ref C.c.W;
        ref C.c.W || !ref $J || C.c.W eq J.name || die "J.name isn't".ki(C.c);
        !ref C.c.W || !ref $J || C.c.W eq $J || die "nzoWJ".ki(C.c);
        # avoid 6ing, its doubling orso
        A.ztime = 3 if A.J.name ne 'qq'; # break off
        
    # crunch gravel, spreaders
    n pi =>3213,<<''
        # - c. language is map to some u before 6ing
        ref $pi && die"refpi: ".wdump 2, $pi;
        C.sc.pi = $pi || 'guess';
        C.c.J = 'pi';
        my $oJ = A.J;
        $oJ = C.y.o.J if C.y.o && C.y.o.J;
        A.jr = Rw Ajr $J:oJ $C;
    
    # Weave wires protocol, host pools
    n W =>3214,<<''
        my $t = $W;
        $t = W.name if ref $t;
        my $jr = Rw Ajr $J:G.oin $t $cv=0.3;
        .
        return C.c.W = die "SOIDNG RESEAR(pi with W)".ki $C
            if C.c.pi; # doing research
        A.jr = $jr; # being
        .
        C.sc.W = $t;
        C.sc.J = ref $W ? $W : $t;
        # going over J should be same...
        C.c.J ||= $W;
        C.t = $t;
        C.y.cv ||= 0.3;
        # and where the thrust (J.A?)
        if (C.c.vv) {
            A.ztime = delete C.c.vv;
            A.jr&vv,'',9
        }
    
Joot: | # RW between being schute and J =+-   its A.jr
    u allvse
    
    n '','','%of:Mo'
    
    # resolve,<<'', right on Space/black, as in where is the thing now
    n J =>341,<<''
        my $f = A.jr&J;
        my $j = C.sc.J;
        ref $j && ref $f && ($j eq $f || die ".sc J dif $f $j");
        # hilum & tie sc so vis, substrate insecting
        C.c.J = C.sc.J = $f if $f && ref $f && !f.dead;
        A.Iso.oJ = 1; # getting pinned into J
        
    n X =>342,<<''
        my $J = C.sc.J;
        sayre "DELING J.name".ki$C;
        $J || die "X no J";
        ref $J || die "Nofound $J  C.t   C.y.cv";
        $X eq $J || die "noovewr X  C.c.X ne $J";
        A.jr&J,$J,9;
        J.dead = 1;
        # SNat bail, we have balin by now so hole in space this time
        T.not = 1;
    
    n '','','%of:oJ'
    
    n J =>343,<<''
        return if ref $J;
        $J = Rw Jto $name:J;
        # DROP
        G.Wids->{J.id} && G.W->{J.id} ne $J && die "runup J.name";
        G.Wids->{J.id} = $J;
        ref $J || die 'watt'.$J;
        if (exists C.c.pi) {
            J.Jiter = A.J; # erse rev
            J.most->{$_} = A.J.most->{$_} for keys %{A.J.most||{}};
        }
        # til the I train shows up:
        J.V = J.most.J.inV || 1 if A.J.V == 2 || J.most.J.inV;
        J.A.Indo = 2;
        sayyl "J33   Made J.name" unless J.Jiter;
        C.c.J = C.sc.J = $J;
        A.jr&J,$J;

    n J =>344,<<''
        die "In self: J.name" if $J eq A.J;
    
    
Jamping: | # timing of 6 & 7
    u allvse
    
    n '','','%of:Mo'
        
    n time =>436,<<''
        A.ztime = delete C.c.time;
    
    n '','','%of:oJ'
    
    # time out
    n J =>434,<<''
        $J = C.c.J = C.sc.J;
        J.name || die "WNO ".wdump 4, $C;
        # TODO: soft acuminy over \d esp. until .bb or something
        A.mo.Js->{J.name} = $J;
        # A falls
        # A.mo exits
        # J.A persists
        J.A.first ||= hitime();
        if (C.sc.W && G.oin ne $J) {
            my $lev = G.oin.A.tid;
            if (J.A.tidi && (J.A.tidi + 3) > $lev) {
                A.ztime ||= 4;
            }
            else {
                J.A.tidi = $lev;
            }
        }
        sayre "same A.J.name inside J.name" if A.J eq $J;
        if (exists C.sc.pi) {
            sayre "JiternotAJ J.Jiter.name ne A.J.name" if J.Jiter ne A.J;
            die 'pimostJ'if J.most.J eq $J;
        }
        else {
            die 'esel'.wdump [J.C, J.most.J.C] if J.most.J ne $J;
        }
        A.ztime ||= 6;
        A.time && sayre "Had atime";
        A.time = sub { # A.t& cover, serve single digit ad hocs, like 2
            my ($JJ,$q) = @_; die"JTIMEJ" if $JJ ne $J;
            A.ztime >= $q
        };
        if (C.sc.pi) {
            J.A.d = J.Jiter.A.d + 1;
            J.ind = join '  ', ('') x J.A.d;
            J.name = "J.A.d. C.c.pi*C.t";
            J.d = $C;
            A.ztime = 6 if A.ztime < 6;
        }
        J.C = $C;
        A.talk .= " J: J.name";
Jumps: | # oJ doing of 6 & 7
    u allvse
    n '','','%of:oJ'
    # https://www.youtube.com/watch?v=tL8N_3tln0Y
    # have the timesack, Subtle means even wide N J completely per C
    # bumps within decide servi
    # like being ones selves
    n J =>61,<<''
        T.alk = "A.talk  TT  A.ztime";
        Atime(6) || return do {
            say "SKive! T.alk" if A.V&skive;
            T.nose = 1;
        };
        sayyl "J6 ! T.alk" unless !A.V&sixes || C.sc.pi || T.alk =~ /^all/;
        A.Subtle.J = 1;
        A.t&J,9,1;
    
    # if T.same and no J action, rv says if concealed J action
    # with some clues maybe, and a thin foundation W that leads to more
    # W you may have around, for the dependency file
    # there would be idly stuff, pi protocols registered to subscribe notifies
    # wants to check Js for action
    # pi columns could be optimised # A light leaks
    #return sayre "same T.alk" if T.same;
    n J =>71,<<''
        T.nose && return A.V&nose && sayre "nose T.alk";
        if (!J.A.II.Sev) {
            my $A = {J=>$J,G=>$G};
            Rw collaspII $A;
        }
        J.most.eo = 'Sev' if J.A.II.Sev;
        say "oJ77 77 T.alk     -> J.most.eo"
            unless J.most.eo ne 'Sev' || !A.V&sevens
                || J.yt.quiet || C.sc.pi || T.alk =~ /^all/;
        Rw J.most.eo $J $A;
    
Foli: | # non driven trevil
    u allvse
    n '','','%of:J'
    n J =>6211211,<<''
        J.le && return;
        my $x = [];
        for my $j (A.J, J.mo.J) {
            my $pix = j.pix;
            push @$x, ref $pix eq 'ARRAY' ? @$pix : $pix if $pix;
            if (my $pich = j.pich) {
                push @$x, ref $_ eq 'ARRAY' ? @$_ : $_ for values %$pich;
            }
        }
        @$x || return;
        my @m = ref $x eq 'ARRAY' ? @$x : $x;
        for my $x (@m) {
            if (x.pi ? C.c.pi eq x.pi : 
                x.any ? 1 :
                0) {
                saygr "matched: J.name ::: ".ki $x if A.V&T;
                .
                x.u &&
                u x.u
                .
                C.c.pi = C.sc.pi = x.pito if x.pito;
                .
                x.Rw &&
                    Rw x.Rw $J $y:J.oy;
            }
            # up!
        }
Foldout: |
        my @m = ref $x eq 'ARRAY' ? @$x : $x;
        for my $x (@m) {
            if (x.pi ? C.c.pi eq x.pi : 
                x.any ? 1 :
                0) {
                saygr "matched: J.name ::: ".ki $x if A.V&T;
                
                x.u &&
                u x.u
                
                C.c.pi = C.sc.pi = x.pito if x.pito;
                
                x.Rw &&
                    Rw x.Rw;
            }
            # up!
        }
Jiterbug: |
    u allvse
    n '','','%of:J'
    # ^ or C.t be II's K
    # last minute resolves of the self
    
    n J =>6211,<<''
        my $y;
        my $M = y.o.M = [];
        my $qq = I.d&Elj,$J,'qq';
        A.hqq = qq.A.hqq = I.d&pha,$qq,'hqq';
        J.oy = $y;
        J.at ||= G&tie,Ghoz=>{inp=>['oy','at'],o=>$J};
        .
        return if exists C.c.pi;
        .
        if (A.ztime < 9) {
            if (A.jr&bol) {
                sayre "STOPPING ".ki($C) for 1..3;
                # TODO stop
            }
            A.bangdesk.aft.unblocknine = A.jr&bol,9;
        }
        A.bangdesk.bang.bang_ts = sub {
            A.jr&bang_ts,hitime
        };
        .
        C.c.pin ||= J.name;
    
    n J =>6212,<<''
        return unless exists C.c.pi;
        .
        #sayre'csnod'.wdump 2, [$C, J.C] if $C ne J.C;
        #J.C = $C;
        J.cv = (C.c.gp && C.c.gp.cv) || C.c.cv || 0.6;
        my $path = C.sc.pi||die'nopi';
        if (J.A.d > 9) {
            $path = 'text';
            warn "J.name J.A.d limit to text";
        }
        C.c.pin = "pi/$path";
    
    n J =>631,<<''
        I.d&exactl,A.hqq;
        A.coi = I.d&pha,$J,'ako';
    
    # set our C.c.s to [that], noise probe case, maybe
    n J =>66,<<''
        my $ar = {%{C.c}};
        ar.s = '' if !exists ar.s;
        ar.u = ar.s;
        ar.pin = C.c.pin || die "nopin";
        my $y = J.oy;
        my $M = y.o.M;
        .
        Rw ar.pin + $A $C $G $T $I $J $M $y;
        .
        Rw Jamroot $J $y if y.at;
        if (T.iM) {
            J.Oy || die "no JOy J.name";
            ref J.Oy.o eq 'HASH' || die "J.name oYo not hash/picked up";
            ref J.Oy.o.M eq 'ARRAY' || die "J.name oYoM not array";
            push @$M, @{J.Oy.o.M};
        }
        J.Oy = $y;
        if (@$M) {
            n z=>$y=>{}
        }
    
    # T may cause big recoil of Mo/J, miss pha closures:
    # full exact light ^ may take over (whack) from the usual given full cone:
    n J =>677,<<''
        my $y = J.oy;
        Rw Jamroot $J $y if y.at;
        # leaving the above
        if (J.oy.ope) {
            sayyl "Leaving J.name open pha..." if A.V&ope;
            I.d&end,A.coi;
            return;
        }
        A.coi.qui = 1;
        my $wt = I.d&exactl,A.coi;
        if (wt.same) {
            if (++J.A.wch > 4) {
                J.A.wch = 0;
                # ^ rate to avoid v see J 632 eighthnot
            }
            else {
               sayre "SAME T.alk" if A.V&SAME;
               T.same = 1;
            }
        }
    
Jamroot: |
    my $t = J.C.c.pi ? J.uname : J.name;
    my $sc = ar.sc || delete ar.y.at || delete J.oy.at;
    Rw jamsc $J $t $cv=0.9 $sc;
    %{J.at} = (%{J.at||{}},%{$sc||{}});
    $sc;
Juperfi: |
    u allvse
    n '','','%of:J'
    
    # use less -
    n J =>632,<<''
        #return 1 unless exists C.sc.pi;
        .
        map { # telephone winch, propaganda (top-er levels receiving stuff)
             J.A->{$_} = J.Jiter.A->{$_}
             if J.Jiter && J.Jiter.A->{$_};
        } qw'ljm ljmo';
        .
        A.time = sub {
            my($JJ,$q) = @_;
            $J eq $JJ || die "wtfJure  J.name   vs JJ.name";
            # wanna A.t&T,2,0 us to difference streams
            # they could be xot maps or code to run
            # then all over things 
            .
            if ($q == 2) {
                my $sc = Rw Jamroot $J $C:J.C $y:J.oy if J.oy.at;
                .
                A.ico = I.d&pha,$J,'ico';
                A.ico.qui = 1;
                I.d&as,A.ico,A.coi;
                my $wtf = I.d&exactl,A.ico;
                .
                if (wtf.last && !wtf.same) {
                    my $uf = join "\n", map{"$_: ".wdump(1,$wtf->{$_})}
                        grep {keys %{$wtf->{$_}}} qw'new diff gone';
                    saybl "T.alk  2222  $uf";
                }
                .
                my $iM = 1 if sc.osci && J.mo.J.act;
                my $stick = !J.mo.J.act && !$iM && # travel part
                    Rw eighthnot $J;
                if (!$stick) { # am sticking
                    my ($o,$O) = (J.oy,J.Oy);
                    for (grep{$o->{$_} ne $O->{$_}} 
                        grep{!ref $o->{$_}} keys %$o) {
                        $stick = 1; # unless y.? nonref changed, or wider spacer
                        saybl "J.name unstuck due to ychange: $_:"
                            ." $o->{$_} ne $O->{$_}";
                    }
                }
                # rhythm^
                if ($stick) {
                    A.ico.wtf.same = 0;
                }
                elsif (wtf.same) {
                    T.iM = $iM if $iM;
                    return 0;
                }
                .
                # for the lift, osc should Jiter ne A.J and pd it
                J.A.ljm = [];
                J.A.ljmo = "fr  J.name";
                return 1;
            }
            .
            warn "T.alk other $q";
            if ($q == 8) {
                # until J.most coord attention evaporates
                # as in pulling on a list
            }
            A.ztime >= $q;
        };
    
    # if early exact light, no A.ico if not to (to)... scIfy thing (sees ACGT)
    # first the superstilled
    # anything T_D can arrange through time...
    # wants to join G subtly vis T and so....
    # should be no M in the first bit
    # it is just pinpricks of consciousness keeping it alive, like mtime
    # be nicer to do with an I that can T out of this whole change res patch
    n J =>672,<<''
        return unless A.ico && A.ico.wtf.same;
        my $cut = @{A.ico.ord};
        my @cc = @{A.coi.ord};
        if (@cc > $cut) {
            warn"J.name entered stuff after 2!".wdump [@cc, 
            '                 =============', @{A.ico.ord}];
        }
        I.d&bandon,A.coi;
        if (my $ljm = J.A.ljm) {
            for my $s (@$ljm) {
                s.noR=1;
                I.d&jamsc,$s;
            }
        }
        sayre "SKIP T.alk";# if J.V || J.most.J.V;
        T.whack = 1; # exit A.t&J
        T.same = 1; # exit Mo, T.not but not, kind of unlet ztime6->7
    

