
C:
 - K: Do #c
   BcS: name D
   S:
     styles: -te
     Z: {background: '#044'}
     content_D: |
       $name;
   E:
     _D: |
       Sw B/D;
 - K: Emb #c
   Z:
      color: rgba(255,200,200,0.4)
      font-size: 200%
      position: absolute
      left: -1em
      top: -7px
      flit:
        blur: 6px
   S:
      content_D: |
        ui.K
 - K: Codlue #c
   S:
     content_D: |
       return w $ui print if ui.K =~ /File|Do|Ghost/;
       
       my $pri = lc ui.K;
       my $db = {%{ui.B}};
       my $s = ui.K;
       $s .= "(".gpty($_).")" for grep{defined} delete $db->{$pri};
       if (defined db.name) {
           $s .= "(db.name)";
           $db = {};
       }
       delete $db->{ui.Li.i.K};
       $s .= ki($db) if %$db && S.q < 3;
       return $s;
 - K: D #c
   Gw: 1
   S:
     styles: -te tu
R:
 - K: sur
   findway: R_sur
     
P:

 - GAK: D #c
   InC:
       W:
         Ss: [u, x, X]
         S:
           styles: OxO z NZ
       M:
         S:
           styles: OxO
       ux:
         spawn: []
P_sud:
 - Do code: waylay code;
 - Do uxd: w uxd;
 - Do H: say "Garble";
 - Do r: H.G w reexec;
 - Do Ü¤: $H->pub('S/hut/o', 'reextet');
 - Do tidy: $H->pub('S/hut/o', 'Hiwtidy');
 - Do Otile:  $H->pub('S/hut/O', 'retile');
 - Do Zr: $H->pub('S/hut/Z', 'reexec');
 - Do Or: $H->pub('S/hut/O', 'reexec');
 - Do Cr: $H->pub('S/hut/C', 'reexec');
 - Do Sr: $H->pub('S/hut/S', 'reexec');
 - Do D: w makeD;
hooks:
  D:
    print: |
        "S.K S.name";
    S: 
      content_D: | 
        w G.theR S[$S, $u];
      ishtml: 1
    E:
      _D: |
        G.theD = $S;
        sayyl "To ".$S->pi;
        w G.theR E[$S, $e];
    flows_D: |
      w G.theR setup[$S];
  fresh_init: |
    w ikey;
    G.TV = {};
    G.R->phat(G.TV);
  humms_D: |
    waylay mux(u=>$u);
  mux: |
    my $D = K G:D;
    my $a = {%$ar};
    my $u = delete a.u;
    my $MR = G.R;
    a.v ||= 7;
    $D w mux[$MR,$a,$u];
  any_init: |
    my $js = " return {el:elvis, x: screen.width, y: screen.height} ";
    my $cb = sub { saygr wdump(2,shift) };
    H.G w jaw[$js, $cb];
    $H->pub('S/hut/O', 'retile');
  recoded_init: |
    w mux;
    #die wdump($thing);
  
  percolate: |
    G.theR = $G->R('sur');
    w makeD unless K D;
    if (H.name eq 'D') {
        waylay 1 beD;
    }
  beD: |
        my $W = K G:U ->K('W');
        W.Z->{'background-color'} = '#fca';
        # TODO # w mux(u=>$W,v=>4);
        w ave(i=>$W);
  makeD: |
    my $name = ar.name || "J".G.Jnumb++;
    my $u = {K=>'D',name=>$name};
    my $D = w G.R fuu[$u]; 
    sayyl "made ++ ".$D->pi;
    G.theD = $D;
    w are;
    $D;
  are: | #c chang->queue U xing
    w makeD(ur=>'f') unless G.theD;
    # TODO # w mux(u=>G.theD, v=>3); # or 2 to up code?
    w mux(u=>G.theD);
    G.theR;
  ikey: | # $G assumes keydo
    H.keydo = sub {
        my $e = shift; 
        my $S = G.theD;
        sayyl "To ".$S->pi;
        w G.theR keys[$e, $S];
    };
  ave: |
    if (ar.Dname) {
        my @Ds = grep {_.K eq 'D' && _.name eq ar.Dname} @{G.R.A.n_C};
        (G.theD) = @Ds;
        G.theD ? 
        sayyl "ave - has ar.Dname - ".G.theD->pi :
        sayyl "ave - MAKING ar.Dname";
        G.theD ||= w makeD(name => ar.Dname);
    }
    my $R = w are;
    ar.S = G.theD;
    if (ar.Sup) {
        $R->dfrom({u=>ar.S, s=>ar.Sup}); # passes moods, anything
    }
    sayyl "ave into: ". join "\t", $G->pi, $R->pi, ar.S->pi, ar.i;
    w $R Sud/in;
  Dave: |
    my $g = $G;
    saybl "DAVING ar.Dname";
    if (!$g) {
        #ar.way = join ' ', 'C', (ar.way||'C/nv');
        #my $P = [{GAK => "$K ar.way"}];
        #$g = H.G w percs[$P];
    }
    
    sayre "Okay now Dave is ".$g->pi;
    $g w ave;
  stylekeysort: |
      my @r = sort keys %$d;
      
      if (grep { /^\[/ } @r) { 
          my $by = { map {
              my $p = $_;
              $p =~ s/^\[(\d+)/'['.sprintf('%08d', $1)/e;
              $p => $_
           } @r };
           @r = map { $by->{$_} } sort keys %$by;
      }
      @r
  event: |
    saybl $G->pi." G.K   EEEEEE ".$i->pi;
    w ikey;
    
        G.envsub && do { say "envsub"; delete(G.envsub)->($i); next };
        if (e.S) {
            w $i zoum;
        }
        else {
            w $i E/_D;
        }

  remux: |
    my $U = K G:U;
    my $a = {%$ar};
    my $u = delete a.u;
    my $MR = G.R;
    $U w remux[$MR,$a,$u];
  unchanged: |
      my ($u) = values %$ar;
      $u = G.theD || die $u if ref $u ne 'C';
      0->accum(G.Vu => ig => $u);

