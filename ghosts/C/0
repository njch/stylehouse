name: code
C:

 - K: Do #c
   BcS: name D
   print: |
     "$name S.on";
   S:
     styles: -te
     Z: {background: '#044'}
   E:
     _D: |
       Sw B/D;
   ux:
     spawn:
       - K: Codlue
 - K: Emb #c
   Z:
      color: rgba(255,200,200,0.4)
      font-size: 200%
      position: absolute
      left: -1em
      top: -7px
      flit:
        blur: 6px
   S:
      content_D: |
        ui.K
 - K: Codlue #c
   S:
     content_D: |
       return w $ui print if ui.K =~ /File|Do|Ghost/;
       
       my $pri = lc ui.K;
       my $db = {%{ui.B}};
       my $s = ui.K;
       $s .= "(".gpty($_).")" for grep{defined} delete $db->{$pri};
       if (defined db.name) {
           $s .= "(db.name)";
           $db = {};
       }
       delete $db->{ui.Li.i.K};
       $s .= ki($db) if %$db && S.q < 3;
       return $s;
 - K: D #c
   flows_D: |
     $R = B.R = $G->R($R||die);
     R.name .= " S.B.name";
     R.A->umv("", "Rand");
     S.A->umk($R, "Doer");
     $G->{S.B.name} = $R;
     w vAK/setup[$R];
   S:
     styles: -te tu
     ishtml: 1
     content_D: | 
       if (B.R) {
         B.m = w vAK/S[$R];
       }
       B.m;
P:
 - K: Do #c
   B:
     name: title
     D: |
        G:Ϡ w grabkeys(GG=>$G);
   flows_D: |
     B.name = "H.style H.name ! open C" ;
     #$G->wayb(H.G => $S->s(K => "Disc", way => "S/retile", Dish => $S));
 
 - Do Z: |
     G:Ϡ w retile; 
 - Do RW: |
       G.O w ux(GG=>$G);
       
 - Do uxd: |
       w uxd; 
       
 - Do keon: |
       H.G w z/keon;
       
 - Do switch: |
       G.ri++;
       my $r = w vAK/are;
       S.on = r.name;
       w chang(u=>$S);
 - K: D #c sur
   B: 
     name: one
     R: surf
    
 - K: D #c sur
   B: 
     name: twofer
     R: surf
    
 - GAK: U #c
   InC:
       W:
         Ss: [u, x, X]
         S:
           styles: OxO z NZ
       M:
         S:
           styles: OxO
       ux:
         spawn: []
R:
 - K: surf
   in_R:
     
     S: 
       gpnew: 1
       rowlimit: 18
       e: 0.6
       key:
          0: Num/out
          number: Num/in
          E: Vit/up
          R: Vit/down
          T: gp/tognew
          Y: Chew/in
          A: Spl/A
          S: Spl/S
          D: Spl/D
          F: Spl/F
          G: Spl/G
       w!C:
          Vit:
            up: |
                R.S.e += 0.1;
            down: |
                R.S.e -= 0.1;
          gp:
            tognew: |
                sayyl "gpnew going ".(R.S.gpnew = !R.S.gpnew);
          Chew:
            in: |
              die "hi!";
              # make rows tally uniqs of small voltages
              # for either this set or all the sets of n_what in A
              # line up similar
              # all this boxing in
          Spl:
            G: |
              # to ghost from here
            F: |
              # F junk?
              w seetry;
            D: |
              # to data dump
              R.S.rowing = "D";   
            S: |
              # to styley
              R.S.rowing = "S";
            A: |
              # heredity
          Num:
            out: |
              if (R.ksuc && $k eq "0") {
                  return R.ksuc = ""
              }
              return $R->popJtrav
            in: |
              R.ksuc .= $k;
              my $j = R.a.ro->{R.ksuc};
              
              $j || return sayre "no j ye for R.ksuc";
              sayyl "got j for R.ksuc";

              R.ksuc = "";

              my ($hop) = j.ac =~ /^(\W\w+)/;
              R.J.trav .= $hop; 
hooks:
  fresh_init: |
    H.keydo = sub { w key(e=>shift); };
 
  recoded_init: |
    w vAK/are; 
  trythis: |
    "one thing";
  seetry: |
    saygr "Trying!!!!" for 1..5;
    my @lot = w trythis;
    my $f = $F[0];
    my $R = w vAK/are;
    my $a = {i=>$f};
    w vAK/sudden_i[$R, $a];
    sayyl "Trithings: $_ " for @lot;
  percolate: |
    w uxd;
  a: |
    my ($k,$etc) = %$ar;
    my ($u) = 0->rei({K=>$k});
    w chang[$u];
    $u;
  key: |
    my $k = e.k;
    my $R = w vAK/are;
    w vAK/key[$R, $k, $e];
  vAK:
    are: | #c chang->queue U xing
      my (@us) = 0->rei({K=>'D'});
      G.ri = 0 if !exists $us[G.ri];
      my $u = $us[G.ri];
      w chang[$u];
      u.B.R
    setup: | #c
        $R->from(delete R.in_R) if R.in_R;
        R.J ||= { 
            from => $R,
            trav => '{G',
        };
        R.J ||= {
            from => $H,
            trav => "{G{GGs",
        };
        say "Made ".$R->pi;
        #w R.S.w $_/in({}) for keys %{R.S.w};
    key: | #c
      sayyl join"  ", ($k) x 13 for 1..4;
      $R->key($k, $e);
      my $key = "$k";
      $key = "S$key" if e.S;
      # some instyle hooks letters to apply
      my $do = R.S.key->{$key};
      if (!$do) {
            # looser
          my $or = "number" if $key =~ /[0-9]/;
          $do = R.S.key->{$or} if $or;
      }
      say "lettering $key => $do";
      
      R.G w R.S.w $do if $do;
      
    sudden_i: | #c ebrace flying embryo J
      R.J = { from => a.i };
    
    S: | #c void vAKcess R::S heist
        # 1
        R.a = shift || {};
        
        # s messed by R plumbing, sure
        R.s = $R->dus; 
        R.s.HASH.oh = 0.7;
            
        my $agp = {R=>$R, cv=>1};
        # 2
        R.a.e ||= R.S.e || die;
        R.a.i ||= $R->uni;
        R.a.tr.rowlimit = R.S.rowlimit || 9*4;
        # TODO ^ tunes the rowiness
        # which is the first variable to other distortions
        # like furthering voltiness until yay many Whats of pi
        # there'd be a gravity somewhere
        # Amps can be when style uniqness raised?
        # 3
        $R->du;
        warn "nod" unless R.a.d; 
        # 4
        w vAK/durows[$R];
        
        # 5 in space # TODO forkstyles & ongoingness
        my $way = "S_5_".(R.S.rowing||"S");
        my @rows = w vAK/$way;
        
        
        # 6 on sphere
        my $frompi = w vAK/gp(%$agp, cv => 0.2, u => R.J.from);
        my $topi   = w vAK/gp(%$agp, cv => 0.2, u => R.a.i);

        # 7
        my $html = join "\n",
             "@!@".$R->f(white => $frompi)
            ."  ".$R->f(black => R.J.trav),
            
            "R.S.e = ".$R->f(white_fs150 => $topi),
            
            @rows;

        # 6
        # TODO more style synapse rejoins after delib fork exp
        # reflect style injection round corner
        # throw style into ux recipe
        
        # 8

        # shrink this webbing into a space in our webbing
        my $lines = split /\n/, $html;
        my $o = 12;
        my $fs;
        if ($lines > $o) {
            $fs = 100 * $o / $lines;
            $fs *= -1 if $fs < 0;
            $fs = "font-size:".$fs."%;";
            sayre "$lines become $fs";
        }
        #sayre "$lines lines" for 1..5;

        qq{<pre style="$fs;background: rgba(80,50,22,0.3);">$html</pre>}
      
    S_5_D: | #c dataey synapse
        wdump(1, R.a.i);
    S_5_S: | #c quick ROWING on the style synapse
        # this and the rows' $a is plumbed up...
        my $agp = {R=>$R, cv=>1};
        my @rows;
        
        my $si = @{R.a.r};
        my @i = w wind[$si];
            say "$si > 9 wound: @i";
        sayyl "============" for 1..4;
        
        
        
        sayyl "Rows: ".@{R.a.r}; #c
        sayyl "Is: ".@i;
        my $i = 1;
        # folding styles in
        my $ro = R.a.ro = {};
        
        my @rows;
        for my $r (@{R.a.r}) {
            my $li = shift @i || die "out of eyes".wdump(2, [@i, $ro]);;
            my $j = $ro->{$li} = {};
            j.li = $li;
            (j.ac, j.u) = @$r;
            (j.t, j.cv) = split /\s+/, j.ac;
            
            # plumbs a ripple of the dus action that got the rows for R
            # close to the thing
            j.pi = w vAK/gp(%$agp, u => j.u, cv => j.cv);
            
            j.row = 
            join "  ",                 map { $R->f(@$_) }
              [ black =>         j.t  ],
              [ red_fs80 =>     j.cv ],
              [ blue_fs120 =>     j.li ],
              [ white_fs120 =>     j.pi ],;
            push @rows, j.row;
        }
        @rows

    
    durows: | #c
      my $d = R.a.d;
      my @r = sort keys %$d if $d;
      if (grep { /^\[/ } @r) { 
           my $by = { map {
               my ($i) = /^\[(\d+)/;
               $i+0 => $_;
           } @r };
           @r = map { $by->{$_} } sort { $a<=>$b } keys %$by;
      }
      R.a.r = [map {[ $_, $d->{$_} ]} @r ];

    
    gp: | #c vAK gp
        # data styler by decaying voltage (cultage)
        # returns the embs, overlapping twists of data and style
        # as in du output
        # but extra stuff can be anywhere
        # a du is a map, lines of locator vectors value
        
        # usually { "locator vector" => $value }
        # but only 
        #return $u->pi if u can pi # braid wants bit of pi somewhere too
        # gpty: 
        G.gp_inarow++;
        $cv = 0.1 if $cv < 0.1;
        G.wit = sub {
            '<t style="color:#'.($_[1] || '8f9').';">'.shift.'</t>'
        };
        G.wt = sub {
            '<t style="'.$_[1].'">'.shift.'</t>'
        };
        
        
        my $c = w vAK/cgp[$u];
        
        my $a = { # traveller - magnetic fishing rod - plumbing
            # receives a.bb - abdomin, core/whole, inside details poke outwards
            cv => $cv,
            R => $R,
        };
        my $arr = {
            a => $a, # @_
            u => $u,
            c => $c,
            R => $R,
        };
        
        my @bpi = qw'ARRAY HASH ref undef text canpi';
        my $wa = "wtf";
        for my $b (@bpi) {
            if ($c->{$b}) {
                $wa = $b;
                last;
            }
        }
        if ($wa eq "canpi") {
            $wa = ref $u;
            $arr->{$wa} = $u;
        }

        my $gppi = $G->findway('vAK/gp_pi');
        $gppi->{$wa} || die "not $wa equip";


        
        my @spi = w vAK/gp_pi/$wa(%$arr);
        
        arr.spi = \@spi;
        
        my @s = w vAK/makaout(%$arr); 
        
        G.gp_inarow--;

        R.S.gpnew ? join("", @s) : G::gp($u);
    makaout: | #c
            my @s;
            if (!a.bb) {
                my $r = ref $u;
                if ($spi->[0] =~ s/^$r //) {
                    $r = G.wit->($r, "cfa") if G.wit;
                    unshift @$spi, $r;
                }
                return @$spi;
            }
            
            if (my $vos = a.bb) {
                sayyl "GOT BB ".G::gp($u);
                # grep up to our voltage
                for my $vo (sort keys %{a.bb}) {
                    next if $vo > a.cv; # TODO in the middle
                    my $d = a.bb->{$vo};
                    $d = $d->() if ref $d eq 'CODE';
                    a.o->{$vo} = $d;
                }
                
                # sort out...
                # stringing outing should start working around here
                my @s;
                for my $vo (sort keys %{a.o}) {
                    my $v = a.o->{$vo};
                    for my $vk (sort keys %$v) {
                        next if $vk =~ /^_/;
                        my $s = $v->{$vk};
                        push @s, $s;
                    }
                }
                $spi = join ' ', @s;
            }
            
            if (a.o) {
                my $vcv = a.cv - 0.2;
                # modification of the above %{a.o} chunk...
                for my $vo (sort keys %{a.o}) {
                    my $v = a.o->{$vo};
                    for my $vk (sort keys %$v) {
                        next if $vk =~ /^_/;
                        my $w;
                        $w = "cfa" if $vk eq 'thi';
                        $w = "3f3" if $vk eq 'K';
                        $w = "ca6" if $vk =~ /ame$/;
                        $w = "000;font-size:30%" if $vk eq 'id';
                        my $s = $v->{$vk};
                        # if v._u, $vk=for, has pi string worked out
                        # but we want to get more of ourself in there
                        # so vakgp...
                        $s = w vAK/gp(R=>$R, u=>v._u, cv=>$vcv) if
                            v._u && $vcv >= $vo;
                            
                        next if $vk eq 'K' && $s eq a.o->{0.1}->{name};
                        
                        $w .= '" title="'.$vk;
                        $s = G.wit->($s, $w) if $w;
                        push @s, $s;
                    }
                }
            } else {
                die "bb then no o?";
            }
            
            @s
    gp_pi: #c
      wtf: | #c
        "know $u"
      ARRAY: | #c
            my @s;
            if (!@$u) {
                @s = "[]";
            }
            else {
                my $vcv = a.cv - 0.2; # TODO another sort of decay
                my $si = @$u;
                @s = (
                    G.wit->($si, "fff;font-size:50%"),
                );
                if ($vcv <= 0.1) {
                    push @s, "[]";
                }
                else {
                    push @s,  '[';
                    my $i = 0;
                    my @us;
                    while (exists $u->[$i]) {
                        my $ui = $u->[$i];
                        push @us,
                            w vAK/gp(R=>$R, u=>$ui, cv=>$vcv);
                        last if $i++ > 9;
                    }
                    push @s, join(', ', @us),
                    ']';
                }
            }
            @s
      HASH: | #c
            my $v = {%$u};
            my $si = keys %$v;
            my @s = (
                G.wit->($si, "fff;font-size:50%"),
            );
            my $vcv = a.cv - 0.2;
            if ($vcv >= 0.1) {
                my @ks;
                push @ks, "K" && delete v.K if v.K;
                push @ks, sort keys %$v;
                # like sorting the hashy du planet rows
                # all about dividing lines to the length
                # so after a simple voltage rolloff occurs
                # you might like to realise how much induction was got
                # and bend voltages up slightly so everything looks yay infoey
                my @kv;
                for my $k (@ks) {
                    my $uu = $u->{$k};
                    if ($vcv >= 0.2) {
                        my $v = w vAK/gp(R=>$R, u=>$uu, cv=>$vcv);
                        push @kv, ',' if @kv;
                        push @kv, G.wit->($k, "acf");
                        push @kv, ':',
                            G.wt->($v, "font-size:75%") if $vcv > 0.1;
                    }
                    elsif ($vcv >= 0.1) {
                        push @kv, ',' if @kv;
                        push @kv, G.wit->($k, "acf");
                    }
                }
                # wrap? tabul? frond?
                push @s,
                    "{",
                    @kv,
                    "}",
            }
            else {
                push @s,
                    "{}",
            }
            @s
      ref: | #c weird ref
            # looks for patterns from anywhere for clues
            (
                $wit->(ref($u), "333;font-size:50%"),
                $wit->(gname($u)),
            )
      undef: | #c
            '~'
      text: | #c
            my $line = $u;
            # these resistances to content
            # width enthusiasm
            # q factor
            # squeeze into space, less stuff as we q away from here
            # so layers inside {d{u 0.4 $u make for easy ux peeling, decay
            # after we made it up, quickly as we are making up new stuff
            my @s;
            my $adhow;
            if (c.lin > 1) {
                $line = join '↯', split /\n/, $u; 
                $adhow = 1;
            }
            my $tev = a.cv * 125; # 0.4 = 100
            my $howad = ".c.lin".".c.len".".c.b";
            my $trev = $tev - length($howad);
            
            if (length($line) > $tev) {
                $line = ($line=~/^(.{$trev})/s)[0];
                $adhow = 1;
            }

            push @s, G.wit->($howad, "88b;font-size:60%") if $adhow;
            $line = G.wit->($line, "3f3");
            push @s, $line;
            @s
      A: | #c
        my $cv = a.cv ||= 0.3;
        a.bb = {
            0 => { thi => ref $u },
            0.1 => { name => u.name },
            0.2 => { K => u.K },
        };
        a.bb->{0.2} = sub { 
            my $pi = w vAK/gp(%$a, u=>A.i, cv=>$cv-0.2);
            { for => $pi, _u => A.i }  
        };
      G: | #c
        $G->pi;
      T: | #c
        $T->pi;
      R: | #c
        $R->pi;
      W: | #c
        $W->pi;
      C: | #c
        my $cv = a.cv ||= 0.3;
        a.bb = {
            0 => { thi => ref $u },
            0.1 => { name => u.name },
            0.2 => { K => u.K },
        };
        my $two = a.bb->{0.2}; # has u.K 
        # it's like C$name↯$K ...
        two.aa = "↯"; # put 
        if (C.B && C.B.name) {
            two.maa = "Bname:";
            two.mame = C.B.name;
        }
        
        
        
        my $print;
        if ((defined C.print || C.Gw) && G::wish(G=>C.G)) {
            eval { $print = C.G w $C print({}); };
            $@ = "" if $@;
        }
        
        my %s = map { $_=>1 } grep { /^[a-z]/ } keys %$C; 
        delete $s{id};
        my @or = qw'name point timer', keys %s;
        
        my $c;
        my $b;
        for my $k (@or) {
            next if !$k;
            next if !exists $C->{$k};
            my $t = $C->{$k};
            next if !defined $t;
            next if ref $t;
            next if $t =~ /\n/; 
            my $slim = slim(20,20,$t);
            $b->{$k} = $slim;
            $c->{$k} = $slim if $k eq "point";
            say wdump($c) if $k eq "point";
        }
        
        c.B = "B:". w vAK/gp(%$a, u=>C.B, cv=>0.2) if C.B;
        a.bb->{0.3} = $c;
        a.bb->{0.4} = $b;
        
        my $B;
        
        if (C.B) {
            if (a.cv > 0.2) {
                if (join(",", sort keys %{C.B}) eq "Lu,ui") {
                    $B = "ui=(".C.B.ui->pint();
                }
                $B ||= G::slim(50,30,G::ki(C.B))        
            }
        }
    cgp: | #c data guess chart
        my $c = {};
        if (!defined $u){
            c.undef = 1;
        } else {
            if (my $ref = ref $u) {
                c.ARRAY = 1 if $ref eq "ARRAY";
                c.HASH = 1 if $ref eq "HASH";
                c.CODE = 1 if $ref eq "CODE";
                c.canpi = 1 if !%$c && $u->can('pi');
                for (qw'A C G T     R') {
                      $c->{$_} = 1 if $ref eq $_;
                }
                c.ref = $ref if !%$c;
            }
            else {
                if (ref \$u eq 'SCALAR') {
                    c.text = 1;
                    c.len = length($u);
                    c.lin = scalar split /\n/, $u;
                    c.b = scalar split /\n\n/, $u;
                    c.number = $u =~ /^(?:\d+\.)?\d+$/;
                    c.wordy = $u =~ /\w+/;
                }
                else { die "wtf is $u" };
            }
        }
        $c
            
      
        
        
        
  wind: | #c
    my $s = 9;
    return 1..$s if $si <= $s;
    my $wind = $si - 9;
    my $from = 6;
    my $for = 3;
    
      my @i;
    
            my $la = $wind / $for;
            my $za = int $la;
            
            my $y;
            my @wind = 1..$wind;
            my @ys = $from..$from+$for-1;
            my $yi = 0;
            while (@wind) {
                my $win = shift @wind;
                
                my $at = $ys[$yi];
                $y->{$at}++;
                
                $yi++;
                $yi = 0 if !exists $ys[$yi];
            }
            
            for my $wi (1..$s) {
                
                if (my $la = $y->{$wi}) {
                    my @la = 1..$la+1;
                    for my $pl (@la) {
                        push @i, "$wi$pl";
                    }
                }
                else {
                    push @i, $wi;
                }
            }
            
            @i
            
  
  elvibe: |
    H.G w z/keon;
    
  event: |
    sayyl "Event relating to ".$u->pi;
    0->visTp({L=>$L},'Fun');
    for (1) {
        G.envsub && do { say "envsub"; delete(G.envsub)->($u); next };
        e.S && do { w $u zoum; next };
        w $u E/_D;
        #waylay uxd;
    }
    sw (ar.u) if e.S;
  uxd: |
    return unless G.GG.U;
    my $chi = G.Vu.U;
    G.Vu.U = [];
    if (!ar.full && $chi && @$chi) {
        my @i = uniq grep { defined } map { _.Lo && _.Lo.i } @$chi;
        #sw[i=>@i, U=>@$chi];
        say "part uxd ".@$chi;
        @$chi = uniq grep { defined } @$chi, @i;
        say "abode : ".$_->pi for @i;
        G.GG.U->w('ux', {is => $chi});
    }
    else {
        my @o = 0->scGre({});
        my $full = ar.full ? "FULL":"full";
        saygr "Codon $full uxd";
        0->sing(alluxd => sub { Say "uxing...";
            G.GG.U->w('ux', {Ls=>\@o});
        }, begin => 0.001);
    }
  chang: |
      push @{G.Vu.U||=[]}, $u if u.G eq $G;
      die "WEIRD u.G.name on u.K " if u.G ne $G;
      0->sing(uxd => sub { w uxd; });
    
  v:
    ch: |
      die "V who?";
      w chang;
  T:
    traction: |
      w chang[$u];
recoded_Cways: 1

