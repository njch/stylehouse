name: code
C:

 - K: Do #c
   BcS: name D
   print: |
     "$name S.on";
   S:
     styles: -te
     Z: {background: '#044'}
   E:
     _D: |
       Sw B/D;
   ux:
     spawn:
       - K: Codlue
 - K: Emb #c
   Z:
      color: rgba(255,200,200,0.4)
      font-size: 200%
      position: absolute
      left: -1em
      top: -7px
      flit:
        blur: 6px
   S:
      content_D: |
        ui.K
 - K: Codlue #c
   S:
     content_D: |
       return w $ui print if ui.K =~ /File|Do|Ghost/;
       
       my $pri = lc ui.K;
       my $db = {%{ui.B}};
       my $s = ui.K;
       $s .= "(".gpty($_).")" for grep{defined} delete $db->{$pri};
       if (defined db.name) {
           $s .= "(db.name)";
           $db = {};
       }
       delete $db->{ui.Li.i.K};
       $s .= ki($db) if %$db && S.q < 3;
       return $s;
 - K: D #c
   flows_D: |
     $R = B.R = $G->R($R||die);
     R.theD = $S;
     R.name .= " S.B.name";
     R.A->umv("", "Rand");
     S.A->umk($R, "Doer");
     $G->{S.B.name} = $R;
     w R_sur/setup[$R];
     Sw flot_D[$R];
   S:
     styles: -te tu
     ishtml: 1
     content_D: | 
       if (B.R) {
         B.m = w R_sur/S[$R];
       }
       B.m;
P:
 - K: D #c sur
   B: 
     R: sur
    
 - GAK: U #c
   InC:
       W:
         Ss: [u, x, X]
         S:
           styles: OxO z NZ
       M:
         S:
           styles: OxO
       ux:
         spawn: []

hooks:
  fresh_init: |
    w ikey;
    G.arp = [1..1024];
    
  recoded_init: |
    w R_wayray;
  
  percolate: |
    w R_wayray;
    w uxd;
  ikey: | # $G assumes keydo
    H.keydo = sub { w key(e=>shift); };
  key: |
    my $k = e.k;
    my $R = w R_sur/are;
      sayyl join"  ", ($k) x 13 for 1..2;
      
      my $key = "$k";
      $key = "S$key" if e.S;
      # some instyle hooks letters to apply
      my $cuz = $G->findway("R_n/key");
      my $do = $cuz->{$key};
      
      $do ||= do {
          my $or = "number" if $key =~ /[0-9]/;
          $cuz->{$or} if $or;
      };
      $do ||= "wtf";
      
      sayyl join"  ", ($do) x 13 for 1..2;
      
      R.G w R_n/$do[$R, $k, $e];
      
  ave: |
    my $R = w R_sur/are;
    my $a = {%$ar};
    w R_n/Sud/in[$R, $a];
 
  R_wayray: |
    sayyl "Re sur";
    # 2 # have just been way init, relay origins
    my $Ds = [];
    for ($G->findway('R_sur')) {
        while (my ($K, $D) = each %$_) {
            push @$Ds, {K => $K,D => $D};
        }
    }
    my $surDs = $G->findway('R_sur_Ds');
    @$surDs = @$Ds;
    
    my @zs = flatline $G->findway('R_zs'); # to begin
    
    
    my $In = 0->findway('R_sur');
    
    w RZ_Ds[$Ds, $In];

    # 9
    #w ave(i=>$In);
    sayyl "wayrays ".$G->F_delta;
  RZ_Ds: |
    # 1
    my $a = ar.a || {};
    my $R = G.sur;
    w phat[$R,$a];
    
    # 2
    a.wy = {};
    
    # 3
    my $wz;
    for (@$Ds) {
        $wz->{_.K} && die "dup _.K";
        $wz->{_.K} = $_;
    }
    
    
    # 4
    w RZ_Ds_humm[$a, $Ds];
    
    # 7
    my $Dz;
    my @r = w stylekeysort(d=>a.bb);
    for my $r (@r) {
        my $b = a.bb->{$r};
        my ($l, $com, $vo) = $r =~ /^(\S+?)(\#\S+)? (.+)$/;
        if ($com) {
            exists $Dz->{$l}->{$vo} || die;
            my $v = $Dz->{$l}->{$vo};
            $com = "# $vo $com".($b ? " $b" : "");
            $v = "$com\n$v";
            $Dz->{$l}->{$vo} = $v;
        }
        else {
            $Dz->{$l}->{$vo} = $b;
        }
    }
    
    # 8
    while (my ($K, $bz) = each %$Dz) {
        a.wy->{$K} = join "\n", map {$bz->{$_}} sort keys %$bz
    }
    %$In = %{a.wy};
    
  RZ_Ds_humm: |
      for my $D (grep {_.D} @$Ds) {
        if (ref D.D eq "HASH") {
            a.wy->{D.K} = D.D; # TODO wants to be shoved down du
            next;
        }
        my $i = 0.001;
        my @cs;
        my $up = sub {
            a.bz->("D.K $i" => join "\n", @cs) if @cs;
            @cs = ();
        };
        for my $l (split "\n", D.D) {
            if ($l =~ /^\s*# (\d\S*)/) {
                my $ni = $1;
                $up->();
                $i = $ni;
            }
            push @cs, $l;
        }
        $up->();
      }


      for my $D (grep {_.babz} @$Ds) {
        for my $ba (keys %{D.babz}) {
            my $b = D.babz->{$ba};
            my $l = $ba;
            if ($l =~ s/(\#\S+)//) {
                a.bz->($ba => undef)
            }
            if (ref $b) {
                #b.from # style grab, additive
            }
            else {
                a.bz->($l => $b);
            }
        }
      }
  R_zs:
    - K: Aun
      babz:
        'S#unifromA 1.16': |
          sayre "YEYEYEYYE" for 1..9;
          my $unifro = {
              i => R.J.from || die,
              t => R.J.trav || "",
          };
          R.a.i ||= w R_sur/uni(%$unifro);
  R_n: #c       
        key: #c
          0: Num/out
          number: Num/in
          E: Vit/up
          R: Vit/down
          Y: Chew/in
          A: Spl/A
          S: Spl/S
          D: Spl/D
          F: Spl/F
          G: Spl/G
          W: Q/way
          SR: Q/Redisy
        Q: #c
            way: |
              R.J = {
                  from => $R,
                  trav => '{S{w',
              };
            Redisy: |
              R.J = {
                from => [sort H.r->keys("*")],
                trav => '',
              }
        Vit: #c
            up: |
                R.S.e += 0.1;
            down: |
                R.S.e -= 0.1;
        Chew: #c
            in: |
              die "hi!";
        Spl: #c
            G: | #c to ghost from here
              my $R = w R_sur/are;
              my $a = {i=>$R};
              w R_n/Sud/in[$R, $a];
            F: | #c # F junk?
              saygr "Trying!!!!" for 1..5;
              my @lot = w trythis;
              my $f = $F[0];
              my $R = w R_sur/are;
              my $a = {i=>$f};
              w R_n/Sud/in[$R, $a];
              sayyl "Trithings: $_ " for @lot;
            D: | #c
                sayre "Yeahp";
                my $P = Load(<<'');
                 - GAK: deadC C

                H.G w percs[$P];
            S: | #c
                my $a;
                my $R = w R_sur/are;
                my ($GG) = grep { $_ ne $G && _.name eq "C" } @{H.G.GGs};
                a.i = $GG w R_sur/are;
                w R_n/Sud/in[$R, $a];
            A: | #c
              # heredity
        Num: #c
            out: |
              return R.ksuc = "" if R.ksuc && $k eq "0";
              return $R->popJtrav
            in: |
              R.ksuc .= $k;
              my $j = R.a.ro->{R.ksuc};
              
              if (!$j) {
                    w unchanged[$R];
                  return sayre "no j ye for R.ksuc";
              }
              sayyl "got $j j.t j.cv for R.ksuc";

              R.ksuc = "";

              my ($hop) = split /(?=\{|\[)/, j.t;
              R.J.trav .= $hop; 
        Sud: #c
           in: |    #c ebrace flying embryo J
                R.J = { from => a.i };
                R.J.trav = a.t if a.t;
    
  R_sur_Ds: [] #c holds origin R_sur while R_n is complicated into R_sur
  R_sur: #c
    are: | #c chang->queue U xing
      my (@us) = 0->rei({K=>'D'});
      G.ri = 0 if !exists $us[G.ri];
      my $u = $us[G.ri];
      w chang[$u];
      u.B.R
    setup: | #c
        $R->from(delete R.in_R) if R.in_R;
        R.J ||= { 
            from => $G,
        };
        R.S.rowlimit = 24;
        R.S.e = 0.6;
        
        R.S.ss_Ds = Load(<<'');
                  n: |
                     n.HASH = {};
                  Ai: |
                     Ai.A = {};
                  Gi: |
                     my $likes = {map{$_=>1}qw{G ways}};
                     Gi.HASH = {
                      it => sub {
                        my $h = shift;
                        my @r = map { { K=>$_, k=>"{".$_, v=>$h->{$_} } } sort keys %$h
                      },
                     };
        
        if (my $ssDs = delete R.S.ss_Ds) {
            for my $k (sort keys %$ssDs) { # or K array who knows
                my $u = R.S.ss->{$k} = $R->dus;
                my $D = $ssDs->{$k};
                $G->D({bab=>$D, ar=>{$k=>$u}});
            }
        }
        
        say "Made ".$R->pi;
        #w R.S.w $_/in({}) for keys %{R.S.w};
    uni: | #c
      #  from => $H,
      #  trav => "{G{GGs",
      my @tr = split /(?=\{|\[)/, $t;
      
      for (@tr) {
          /^(.)(.+)$/;
          say "Sapped $i       $1 $2";
          last if $1 eq " ";
          $i = $i->{$2} if $1 eq "{";
          $i = $i->[$2] if $1 eq "[" && (ref $i eq 'ARRAY' || die "NOT!");
      }
      if ($t =~ m/^.+? (.+)$/) {
          say "Had some more: $1";
      }
      $i
    
    
    shj: | #c
      my $j;
      j.r = $r;
      j.s = $d->{$r};
      (j.t, j.cv) = split /\s+/, j.r, 2;
      (j.cv, my @e) = split /\s+/, j.cv;
      j.ev = \@e if @e;
      $j
    
    
    as: | #c
        my $j = {};
        my $do;
        $do = sub {
            my $j = {%$j};
            my $ad = [@_];
            my %j = %$j;
            while (@$ad) {
                my ($k, $v) = (shift @$ad, shift @$ad);
                
                my $comp = $k =~ /^(%|\+)/;
                my $j = {%j} if $comp;
                if ($comp) {
                    $k =~ s/^\+// if $comp;
                    j.t .= $k if $comp;
                }
                else {
                    (j.t, j.cv) = split /\s+/, $k, 2;
                    %j = %$j;
                }
                j.cv || die;
                j.r = "j.t j.cv";
                j.s = $v;
                $bb->{j.r} = j.s;
            }
            sub{$do->(%$j, @_)}
        };
        $do
    gpfro: | #c
      my ($R, $aser, $l, $u, $cv, @etc) = @$a;
      
      my $gp = {R=>$R, u=>$u, cv=>$cv};
      my $v = w R_sur/gp(a => $gp);
            
      $aser->($l => $v,
          '%gp' => $gp,
          @etc,
      );
    S: | #c void R_surcess R::S heist
        # 0.1
        my $a = R.a = ar.a ||= {};
        w phat;
        
        # 0.2
        R.a.e ||= R.S.e || die;
        
        # 1.16
        my $unifro = {
            i => R.J.from || die,
            t => R.J.trav || "",
        };
        R.a.i ||= w R_sur/uni(%$unifro);
        
        # 2 s messed by R plumbing, sure
        R.a.s = R.S.s || $R->dus;
        R.a.s.HASH.oh = 0.2;
        R.a.s.SCALAR.it = sub {
            my $i = 0;
            map { { k => $i++, v=> $_ } } split "\n\n", shift;
        };
        
        R.a.tr.rowlimit = R.S.rowlimit || 9*2;
        
        # 3
        $R->du;
        
        # 4
        w R_sur/S_4;
        
        # 4.1
        a.fro->('H 0.01' => $H, 0.2);
        
        a.fro->('G 0.02' => $G, 0.2, '+_fro' => ' ');
        
        a.fro->('R 0.11' => $R, 0.2, '+_fro' => ' ');
        
        # 4.2
        a.fro->('R_J_from 0.12' => R.J.from, 0.2);
        
        a.fro->('R_J_trav 0.13' => R.J.trav, 0.2, '%sf' => 'black_fs120'); 
        
        a.bz->('R_S_e 0.2' => R.S.e, '%sf' => 'white');
        
        a.fro->('R_a_i 0.21' => R.a.i, 0.2);
        
        a.bz->('Js 0.29' => "\n");
        
        # 6
        my $html = w R_sur/makaout(R=>$R, a=>R.a, cv => 0);
        
        # TODO more style synapse rejoins after delib fork exp
        # reflect style injection round corner
        # fits
        # throw style into ux light
        
        # 8

        # proto fits: shrink this webbing into a space in our webbing
        my @sty;
        
        my $o = 12;
        my $lines = split /\n/, $html;
        if ($lines > $o) {
            my $fs = 100 * $o / $lines;
            $fs *= -1 if $fs < 0;
            push @sty, "font-size:$fs%";
        }
        push @sty, "background:rgba(80,50,22,0.3)"; 
        push @sty, "white-space:pre";
        push @sty, "font-family:mono";
        push @sty, "display:block";
        push @sty, "overflow-wrap:break-word";
        my $sty = join ";", @sty; 
        qq{<span style="$sty"><span>$html<span></span>}
      
    S_4: | #c
        my $d = a.d; # from du
        
        my @r = w stylekeysort[$d];
        my $si = @r;
        my @i = w wind[$si];
        my $ro = R.a.ro = {}; # wind round
        my $i = 0;
        for my $r (@r) {
            my $j = w R_sur/shj[$r, $d];
            my $li = j.li = shift @i || die;
            $ro->{$li} = $j;
            if ($i > 0) {
                 a.bz->("${li}0_Bs 0.3 0.3${li}0" => "\n");
            }
            a.bz->("${li}_li 0.3 0.3${li}1", j.li,
                '%sf', 'blue_fs120');
                
            my $t = j.t;
            $t .= join("", (" ") x (6 - length($t))) if length($t) < 6;
            a.bz->("${li}_k 0.3 0.3${li}2", $t,
                '%sf', 'black');
           
            my $cv = j.cv;
            $cv =~ s/^0//;
            a.bz->("${li}_cv 0.3 0.3${li}22", $cv,
                '%sf', 'red_fs80');
            
            a.fro->("${li}_s 0.3 0.3${li}4", j.s, j.cv,
                '%sf', 'white_fs120');
            $i++; 
        }
    gp: | #c R_sur gp
        G.gp_inarow++;
        my $a = ar.a || {};
        a.cv = ar.cv if ar.cv;
        a.R = ar.R if ar.R;
        a.u = ar.u if ar.u;
        a.cv = 0.1 if a.cv < 0.1;
        my $u = a.u;
        
        my $c = w R_sur/cgp[$u]; # guesses
        
        my $arr = {
            a => $a, # @_
            u => $u,
           # c => $c,
            R => a.R,
        };
        
        my ($wa) = grep { $c->{$_} } qw'canpi ARRAY HASH ref undef text';
        $wa ||= 'wtf';
        
        if ($wa eq "canpi") { # supply $self
            $wa = ref $u;
            $arr->{$wa} = $u if $wa ne 'G';
        }

        my $gppi = $G->findway('R_sur/gp_pi');
        $gppi->{$wa} || die "not $wa equip";


        
        my @spi = w R_sur/gp_pi/$wa(%$arr);
        
        arr.spi = \@spi;
        
        my $html = w R_sur/makaout(%$arr);
        $html =~ s/\n//;
        G.gp_inarow--;
        $html
    makaout: | #c
        my $cv = ar.cv;
        $cv = a.cv if !defined $cv;
        
        return w R_sur/maka_nobb if !a.bb;
        
        my @s;

        w R_sur/maka_3; # apply styles ...
        
        my @r = w stylekeysort(d=>a.bb);
        
        a.o = {}; # by voltage, peel
        for my $r (@r) {
                my ($l, $vo, $or) = split /\s+/, $r; # split style, vectory
                
                saygr "igggy $l $vo > a.cv" && next if $cv && $vo > $cv;
                
                $or = $vo if !defined $or;
                
                my $o = a.o->{$or} ||= []; 
                push @$o, $r;
        }
        # modification of the above %{a.o} chunk...
            
            
            #thingness_appearance
            my $th = {};
            my $ap = {};
            my @int;
            for my $ov (sort keys %{a.o}) {
                 my $o = a.o->{$ov};
                 
                 for my $r (@$o) {
                     my $s = a.bb->{$r};
                     my ($l, $vo) = split /\s+/, $r; # split style, vectory
                     ($l, my $style) = split '%', $l;
                     
                     my $in = $style ? $ap : $th;
                     my $j = {
                         l => $l,
                         s => $s,
                         vo => $vo,
                     };
                     if ($style) {
                         my $o = $ap->{$l} ||= [];
                         j.style = $style;
                         push @$o, $j
                     }
                     else {
                         if (exists $in->{$l}) {
                             warn "replacemont $l $vo";
                         }
                         $th->{$l} = $j;
                         push @int, $l;
                     }
                }
            }
            
            
            for my $thl (@int) {
                my $j = $th->{$thl} || next;
                my $o = delete $ap->{$thl};
                my $l = j.l;
                my $s = j.s;
                
                # top volt for thing selection: # whattage
                next if $l eq 'K' && a.bb->{"name 0.1"} =~ $s;
                next if $l eq 'name' && a.bb->{"K 0.2"} =~ $s
                    && $s ne a.bb->{"K 0.2"};
                
                die "reffy $s in $l" if ref $s;
                sayyl "for the $l\t\t$s j.vo" if ar.db;
                
                my $ishtml;
                my $css = [];
                for my $oj (@$o) {
                    saybl "        sdtyle! oj.style oj.s" if ar.db; 
                    if (oj.style eq "css") {
                        push @$css, oj.s;
                    }
                    elsif (oj.style eq "gp") {
                        # has a way to $a the gp action within...
                        $ishtml = 1;
                    }
                    elsif (oj.style eq "sf") {
                        push @$css, map { $R::f->{$_} || 
                        die "no style $_"} split '_', oj.s;
                    }
                    else {
                        die "style oj.style = oj.s \t for $l";
                    }
                }
                
                my $at;
                at.style = join ';', @$css;
                at.title = $l;
                $at = join " ", map { $_.'="'.$at->{$_}.'"' } 
                    grep { $at->{$_} } sort keys %$at;
                if (!$ishtml) {
                    $s = encode_entities($s);
                    $s =~ s/\\n/\n/g;
                    die if $s =~ /\\n/;
                }
                $s = "<t $at>$s</t>" if $s;
                push @s, $s;
            }
            
            if (%$ap) {
                sayre "Extr a appearance: ".wdump($ap);
            }
            
            @s = "nose? ".@r if !@s;
            say wdump(2, a.bb) if !@s; 
            #die "nose? $u" if !@s;
            
            join("", @s);
    gp_pi: #c
      wtf: | #c
        "know $u"
      ARRAY: | #c
            my $cv = a.cv ||= 0.3;
            w phat[$R, $a];
            
            my $si = @$u;
            a.bz->('si 0.1' => $si, '%css' => "color:#fff;font-size:50%");
            a.bz->('Bo 0.1 0.11' => '[');
            a.bz->('oB 0.1 0.9' => ']');
            
            return if $cv < 0.2;
            
            my $ki = 0;
            my $i = 0;
            while (exists $u->[$i]) {
                my $uu = $u->[$i];
                if ($ki > 0) {
                    $ki++;
                    a.bb->{"[${ki}_Bs 0.2"} = ',';
                    $ki++;
                }
                
                my $vcv = a.cv - 0.2; # dus bend for $k
                $vcv = 0.1 if $vcv < 0.1;
                if (1) {
                    a.fro->("[${ki}_v 0.2", $uu, $vcv,
                    
                        "%css" => "font-size:75%");
                    $ki++;
                }
                
                $i++;
                if ($i >= 5) {
                    a.bz->("more 0.2 0.886" => "@",
                    
                        '%sf' => "blue");
                    last;
                }
            }
      HASH: | #c
            my $v = {%$u};
            my $cv = a.cv ||= 0.3;
            w phat[$R, $a];
            
            my @r = keys %$v;
            my $si = @r;
            a.bz->('si 0.1' => $si, 'si%css 0.1' => "color:#fff;font-size:50%");
            
            
            
            a.bz->("Bo 0.1 0.11" => '{');
            a.bz->('oB 0.1 0.9' => '}');
            
            return if $cv < 0.2;
            
            @r = sort @r;
            for my $be ('K', 'name') {
                unshift @r, $be if $G->deaccum({u=>\@r},u=>$be);
            }
            
            my $ki = 0;
            my $i = 0;
            for my $k (@r) {
                my $uu = $u->{$k};
                
                if ($ki > 0) {
                    $ki++;
                    a.bb->{"[${ki}_Bs 0.2"} = ',';
                    $ki++;
                }
                a.bz->("[${ki}_k 0.2" => $k,
                    
                    "\%css 0.2" => "color:#acf;font-size:80%");
                    
                    
                my $keyi = $ki;
                $ki++;
                my $vcv = a.cv - 0.2; # dus bend for $k
                
                if ($vcv >= 0.2) {
                
                    a.bz->("[${ki}_Bi 0.2" => ':');
                    
                    $ki++;
                    
                    a.fro->("[${ki}_v 0.2" => $uu, $vcv,
                    
                        '%css 0.2' => "font-size:75%");

                }
                
                $i++;
                if ($i >= 5) {
                    a.bz->("more 0.2 0.886" => "@",
                    
                        '%sf' => "blue");
                    last;
                }
            }
      ref: | #c weird ref
            ">?$u"
      code: | #c
        "CODE";
      undef: | #c
            '~'
      text: | #c
            my $text = $u;
            w phat[$R,$a];
            
            my @s;
            my $adhow;
            if ($text =~ /\n/) {
                $text = join '↯', split /\n/, $text; 
                $adhow = 1;
            }
            my $tev =  a.cv * 125; # 0.4 = 100
            my $trev = int $tev;
            
            my $si = length($text);
            if ($si > $tev) {
                $text = ($text=~/^(.{$trev})/s)[0];
            }
            else {
                undef $si;
            }
            
            my $ni = a.c.lin if a.c.lin > 1;
            my $bi = a.c.b if a.c.b > 1;
            
            if ($si) {
                a.bz->("#more 0.9" => "@",

                    "%sf" => "blue");
            }
            
                a.bz->("si/l 0.1" => "$si",
                    '%css' => "color:#b89;font-size:50%;position:absolute") if $si;
                a.bz->('si/n 0.1' => "$ni",
                    '%css' =>
                        "color:#fff;font-size:50%;"
                        ."position:absolute;margin-top:1.4em;") if $ni;
                a.bz->('si/b 0.1' => "b$bi",
                    '%css' =>
                        "color:#f89;font-size:50%;"
                        ."float:left;left:-1em") if $bi;
            
            a.bz->('line 0.2' => $text,
                '%css' => "background:rgba(200,30,80,0.3);color:#3f3;"
                    ."font-size:70%");
            
      A: | #c
        my $cv = a.cv ||= 0.3;
        a.bb = {};
        a.bb->{"thi 0"} = ref $u;
        return if $cv < 0.1;
        a.bb->{"name 0.1"} = u.name;
        return if $cv < 0.2;
        a.bb->{"K 0.2"} = u.K;
        
        do {
            my $gp = {R=>$R, u=>A.i, cv=>0.2};
            my $v = w R_sur/gp(a => $gp);
            a.bb->{"i 0.2"} = $v;
            a.bb->{"i%gp 0.2"} = $gp;
        };
        return if $cv < 0.3;
        do {
            my $un;
            map { push @{$un->{_.un}||=[]}, $A->{_.k} }
            grep { /^(u|n)/ && do { $_ = {un=>$1, k=>$_} } } keys %$A;
            
            
            #        a.bb->{"[${ki}#then 0.2"} = ',';
            #a.bb->{"[${ki}_k 0.2"} = $k; # could this be ${ki}_a?
            #    a.bb->{"[${ki}_k\%css 0.2"} = "color:#acf;font-size:80%";
            my $gp = {R=>$R, u=>$un, cv=>0.4};
            my $v = w R_sur/gp(a => $gp);
            
            a.bb->{"un 0.3"} = $v;
            a.bb->{"un%gp 0.3"} = $gp;
        };
      G: | #c
        my $cv = a.cv ||= 0.3;
        a.bb = {};
        a.bb->{"thi 0"} = ref $u;
        return if $cv < 0.1;
        a.bb->{"name 0.1"} = u.name;
        return if $cv < 0.2;
        a.bb->{"K 0.2"} = u.K;
        
      T: | #c
        $T->pi;
      H: | #c
        w phat[$R,$a];
        a.bz->('thi 0.01' => 'H');
        a.bz->("name 0.06" => H.style,
            '%css' => "color:white;font-size:40%;margin-left:-1.5em;position:absolute;");
        a.bz->("K 0.1" => H.name,
            '%css' => "color:black;font-size:80%;margin-left:-0.667em;position:absolute;");
        
      R: | #c
        my $cv = a.cv ||= 0.3;
        a.bb = {};
        a.bb->{"thi 0"} = ref $u;
        return if $cv < 0.1;
        a.bb->{"name 0.1"} = u.name;
        return if $cv < 0.2; 
        a.bb->{"K 0.2"} = u.K;
        
      W: | #c
        "W W.K W.G.name ".$W->uhigh;
      C: | #c
        my $cv = a.cv ||= 0.3;
        a.bb = {};
        a.bb->{"thi 0"} = ref $u;
        return if $cv < 0.1;
        a.bb->{"name 0.1"} = u.name;
        
        return if $cv < 0.2;
        
        a.bb->{"K 0.2"} = u.K;
        a.bb->{"K%css 0.2"} = "color:#3f3";
        
        if (C.B && C.B.name) {
            a.bb->{"B_name 0.2"} = C.B.name;
            a.bb->{"B_name%css 0.2"} = "color:#3f3"; 
        }
        
        return if $cv < 0.3;
        
        if (C.G && (defined C.print || C.Gw)) {
            my $p = C.G->w('print' => {}, $C, {nodie=>1});
            a.bb->{"print 0.3"} = $p if defined $p;
        }
        
        # dusseldorf
        my %s = map { $_=>1 } grep { /^[a-z]/ } keys %$C;
        delete $s{id};
        my @or = qw'name point timer', keys %s; 
        
        my $c; 
        my $b; 
        for my $k (@or) {
            next if !defined $k;
            next if !exists $C->{$k};
            my $t = $C->{$k};
            next if !defined $t;
            next if ref $t;
            next if $t =~ /\n/; 
            my $slim = slim(20,20,$t);
            
            a.bb->{"$k 0.4"} = $slim if $cv >= 0.4; # also a dus fuzz away
            
            a.bb->{"$k 0.3"} = $slim if $k eq "point"; # pyramid
        }
        
        if (C.B && %{C.B}) {
            my $gp = {R=>$R, u=>C.B, cv=>0.2};
            my $v = w R_sur/gp(a => $gp);
            
            a.bb->{"B 0.3"} = $v;
            a.bb->{"B%gp 0.3"} = $gp;
        }
        # should return text if no $a...
    cgp: | #c data guess chart
        my $c = {};
        if (!defined $u){
            c.undef = 1;
        } else {
            if (my $ref = ref $u) {
                c.ARRAY = 1 if $ref eq "ARRAY";
                c.HASH = 1 if $ref eq "HASH";
                c.CODE = 1 if $ref eq "CODE";
                c.canpi = 1 if !%$c && $u->can('pi');
                for (qw'A C G T     R') {
                      $c->{$_} = 1 if $ref eq $_;
                }
                c.ref = $ref if !%$c;
            }
            else {
                if (ref \$u eq 'SCALAR') {
                    c.text = 1;
                    c.len = length($u);
                    c.lin = scalar split /\n/, $u;
                    c.b = scalar split /\n\n/, $u;
                    c.number = $u =~ /^(?:\d+\.)?\d+$/;
                    c.wordy = $u =~ /\w+/;
                }
                else { die "wtf is $u" };
            }
        }
        $c
    maka_3: | #c # scan a.bb and add more styles././
            for my $k (%{a.bb}) {
                if ($k =~ /^(\S*(?:oB|Bo|Bi))\s+(.+)$/) {
                    a.bb->{"$1\%css $2"} = "color:black";
                }
                if ($k =~ /^thi\s+(.+)$/) {
                    a.bb->{"thi\%css"} = "text-decoration:underline";
                }
                if ($k =~ /^name\s+(.+)$/) {
                    a.bb->{"name\%css"} = "color:#f93";
                }
            }
    maka_nobb: | #c
                my $spi = ar.spi || die;
                my $r = ref ar.u;
                if ($spi->[0] =~ s/^$r //) {
                    $r = G.wit->($r, "cfa") if G.wit;
                    unshift @$spi, $r;
                }
                return join "", @$spi;
      

            
      
        
        
        
  phat: |
        a.bb = {};
        a.bz = w R_sur/as(bb=>a.bb);
        a.fro = sub {
            my $fro = [$R, a.bz, @_];
            w R_sur/gpfro(a=>$fro);
        };
  stylekeysort: |
      my @r = sort keys %$d;
      
      if (grep { /^\[/ } @r) { 
          my $by = { map {
              my $p = $_;
              $p =~ s/^\[(\d+)/'['.sprintf('%08d', $1)/e;
              $p => $_
           } @r };
           @r = map { $by->{$_} } sort keys %$by;
      }
      @r
  wind: | #c
    my $s = 9;
    return 1..$s if $si <= $s;
    my $wind = $si - 9;
    my $from = 6;
    my $for = 3;
    
      my @i;
    
            my $la = $wind / $for;
            my $za = int $la;
            
            my $y;
            my @wind = 1..$wind;
            my @ys = $from..$from+$for-1;
            my $yi = 0;
            while (@wind) {
                my $win = shift @wind;
                
                my $at = $ys[$yi];
                $y->{$at}++;
                
                $yi++;
                $yi = 0 if !exists $ys[$yi];
            }
            
            for my $wi (1..$s) {
                
                if (my $la = $y->{$wi}) {
                    my @la = 1..$la+1;
                    for my $pl (@la) {
                        push @i, "$wi$pl";
                    }
                }
                else {
                    push @i, $wi;
                }
            }
            
            @i
            
  
  elvibe: |
    H.G w z/keon;
    
  event: |
    saybl $G->pi." G.K   EEEEEE ".$u->pi;
    w ikey;
    0->visTp({L=>$L},'Fun');
    for (1) {
        G.envsub && do { say "envsub"; delete(G.envsub)->($u); next };
        e.S && do { w $u zoum; next };
        w $u E/_D;
        #waylay uxd;
    }
    sw (ar.u) if e.S;
  uxd: |
    return unless G.GG.U;
    my $chi = G.Vu.U;
    G.Vu.U = [];
    if (!ar.full && $chi && @$chi) {
        my @i = uniq grep { defined } map { _.Lo && _.Lo.i } @$chi;
        #sw[i=>@i, U=>@$chi];
        say "part uxd ".@$chi;
        @$chi = uniq grep { defined } @$chi, @i;
        say "abode : ".$_->pi for @i;
        G.GG.U->w('ux', {is => $chi});
    }
    else {
        my @o = 0->scGre({});
        my $full = ar.full ? "FULL":"full";
        saygr "Codon $full uxd";
        0->sing(alluxd => sub { Say "uxing...";
            G.GG.U->w('ux', {Ls=>\@o});
        }, begin => 0.001);
    }
  chang: |
      push @{G.Vu.U||=[]}, $u if u.G eq $G;
      die "WEIRD u.G.name on u.K " if u.G ne $G;
      0->sing(uxd => sub { w uxd; });
  unchanged: |
      my ($u) = values %$ar;
      $u = u.theD || die if ref $u ne 'C';
        0->deaccum(G.Vu, 'U', $u);
  v:
    ch: |
      die "V who?";
      w chang;
  T:
    traction: |
      w chang[$u];
recoded_Cways: 1

