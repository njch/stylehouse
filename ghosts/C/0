name: coocoo
C:
 - K: Do #c
   BcS: name D
   print: |
     "$name S.on";
   S:
     styles: -te
     Z: {background: '#044'}
   E:
     _D: |
       Sw B/D;
   ux:
     spawn:
       - K: Codlue
 - K: Emb #c
   Z:
      color: rgba(255,200,200,0.4)
      font-size: 200%
      position: absolute
      left: -1em
      top: -7px
      flit:
        blur: 6px
   S:
      content_D: |
        ui.K
 - K: Codlue #c
   S:
     content_D: |
       return w $ui print if ui.K =~ /File|Do|Ghost/;
       
       my $pri = lc ui.K;
       my $db = {%{ui.B}};
       my $s = ui.K;
       $s .= "(".gpty($_).")" for grep{defined} delete $db->{$pri};
       if (defined db.name) {
           $s .= "(db.name)";
           $db = {};
       }
       delete $db->{ui.Li.i.K};
       $s .= ki($db) if %$db && S.q < 3;
       return $s;
 - K: D #c
   Gw: 1
   S:
     styles: -te tu
     ishtml: 1
R:
 - K: sur
   Rways:
     
P:
 - K: D #c sur
   B: 
     R: sur
    
 - GAK: U #c
   InC:
       W:
         Ss: [u, x, X]
         S:
           styles: OxO z NZ
       M:
         S:
           styles: OxO
       ux:
         spawn: []
hooks:
  D:
    S: 
      content_D: | 
         if (B.R) {
           B.m = w $R S;
         }
         B.m;
    flows_D: |
       $R = B.R = G.theR;
       R.theD = $S;
       R.A->umv("", "R");
       S.A->umk($R, "Doer");
       
       w $R setup;
  fresh_init: |
    G.theR = $G->R('sur');
    w ikey;
  any_init: |
    w R_wayray;
  recoded_init: |
    w uxd;
  
  percolate: |
    w uxd(full=>1);
  are: | #c chang->queue U xing
    my $R = G.theR;
    if (my $u = R.theD) {
        w chang[$u];
    }
    $R
  ikey: | # $G assumes keydo
    my $R = G.theR;
    H.keydo = sub { w $R keys(e=>shift); };
  ave: |
    my $R = w are;
    my $a = {%$ar};
    w $R Sud/in[$a];
 
  R_wayray: |
    my $S; # the R: - source Rway thing rayed
    my $GG = $G;
    my $R = G.theR;
    my $source = "R_sur";
    my $a = {};
    
    my $Ds=[];
    for my $Rsur (0->findway("${source}s")) {
        # passing phase, should beam in
        push @$Ds, map { { K=>$_, D=>$Rsur->{$_} } } keys %$Rsur;
    }
    die unless @$Ds;
    
    my @zs = flatline $G->findway("${source}z");
    push @$Ds, @zs;
    @$Ds = grep { !_.spesh } @$Ds;
    
    a.Ds = $Ds;
    a.Dh = {};
    a.Dz = {};
     # have setting somewhere for whatever
    # fan out all style poss behind the source name
    # then wild R cranking + speshness distill their source from this pool
    
    w RZ_Ds_humm[$a];
    
    w RZ_Ds_traction[$a, $R, $GG];
    
    R.way ||= R.A->spawn('C');
    R.way.name = "Rw!";
    R.way->from({hooks=>a.Dh});
    

    sayyl "wayrays ".$G->F_delta;
  RZ_Ds_humm: |
    a.bb = {};
    my $Ds = a.Ds;
    
        @$Ds = map { 
            my $D = $_;
            !ref D.D ? $D : do {
                my $_K = D.K;
                map { { K=>"$_K/$_", D=>D.D->{$_} } } keys %{D.D}
            }
        } @$Ds;
        
        die "durp" if @$Ds != uniq map {_.K} @$Ds;
        
        for my $D (grep {_.D} @$Ds) {
            my $i = 0.001;
            my @cs;
            my $up = sub {
                a.bb->{"D.K $i"} = join "\n", @cs if @cs;
                @cs = ();
            };
            for my $l (split "\n", D.D) {
                if ($l =~ /^\s*# (\d\S*)/) {
                    my $ni = $1;
                    $up->();
                    $i = $ni;
                }
                push @cs, $l;
            }
            $up->();
        }

        for my $D (grep {_.n_D} @$Ds) {
            # TODO want to be R centric, make style for these.....
            a.Dh->{key}->{$_} = "D.K/D.key->{$_}" for keys %{D.key||{}};
            a.Dh->{D.K} = D.n_D;
        }


        for my $D (grep {_.babz} @$Ds) {
          for my $ba (keys %{D.babz}) {
              my $b = D.babz->{$ba};
              my $l = $ba;
              if ($l =~ s/(\#\S+)//) {
                  a.bb->{$ba} = undef;
              }
              if (ref $b) {
                  #b.from # style grab, additive
              }
              else {
                  a.bb->{$l} = $b;
              } 
          }
        }
  RZ_Ds_traction: |
    # pool the style of code together for this R crazy
    # look at each $r in the source style way dimension
    
    # 7
    my $Dz = a.Dz;
    my @r = w stylekeysort(d=>a.bb);
    for my $r (@r) {
        my $b = a.bb->{$r};
        my ($l, $com, $vo) = $r =~ /^(\S+?)(\#\S+)? (.+)$/;
        if ($com) {
            # should just attach them near the style
            # with one more phase of comment joining
            # also non-replace mode, maybe something of z D namespace
            exists $Dz->{$l}->{$vo} || die;
            my $v = $Dz->{$l}->{$vo};
            $com = "# $vo $com".($b ? " $b" : "");
            $v = "$com\n$v";
            $Dz->{$l}->{$vo} = $v;
        }
        else {
            $Dz->{$l}->{$vo} = $b;
        }
    }
    
    # 8
    my $Dh = a.Dh;
    while (my ($l, $bz) = each %$Dz) {
        my $ac = join'',map{"{$_"}split'/',$l;
        
        my $babble = join "\n", map {$bz->{$_}} sort keys %$bz;
        
        $R->loadup($Dh, $ac, $babble);
    }

  stylekeysort: |
      my @r = sort keys %$d;
      
      if (grep { /^\[/ } @r) { 
          my $by = { map {
              my $p = $_;
              $p =~ s/^\[(\d+)/'['.sprintf('%08d', $1)/e;
              $p => $_
           } @r };
           @r = map { $by->{$_} } sort keys %$by;
      }
      @r
  wind: | #c
    my $s = 9;
    return 1..$s if $si <= $s;
    my $wind = $si - 9;
    my $from = 6;
    my $for = 3;
    
      my @i;
    
            my $la = $wind / $for;
            my $za = int $la;
            
            my $y;
            my @wind = 1..$wind;
            my @ys = $from..$from+$for-1;
            my $yi = 0;
            while (@wind) {
                my $win = shift @wind;
                
                my $at = $ys[$yi];
                $y->{$at}++;
                
                $yi++;
                $yi = 0 if !exists $ys[$yi];
            }
            
            for my $wi (1..$s) {
                
                if (my $la = $y->{$wi}) {
                    my @la = 1..$la+1;
                    for my $pl (@la) {
                        push @i, "$wi$pl";
                    }
                }
                else {
                    push @i, $wi;
                }
            }
            
            @i
            
  
  elvibe: |
    H.G w z/keon;
    
  event: |
    saybl $G->pi." G.K   EEEEEE ".$u->pi;
    w ikey;
    0->visTp({L=>$L},'Fun');
    for (1) {
        G.envsub && do { say "envsub"; delete(G.envsub)->($u); next };
        e.S && do { w $u zoum; next };
        w $u E/_D;
        #waylay uxd;
    }
    sw (ar.u) if e.S;
  uxd: |
    my $chi = G.Vu.U;
    G.Vu.U = [];
    if (!ar.full && $chi && @$chi) {
        my @i = uniq grep { defined } map { _.Lo && _.Lo.i } @$chi;
        #sw[i=>@i, U=>@$chi];
        say "part uxd ".@$chi;
        @$chi = uniq grep { defined } @$chi, @i;
        say "abode : ".$_->pi for @i;
        G.GG.U->w('ux', {is => $chi});
    }
    else {
        my @o = 0->scGre({});
        my $full = ar.full ? "FULL":"full";
        saygr "Codon $full uxd";
        0->sing(alluxd => sub { Say "uxing...";
            G.GG.U->w('ux', {Ls=>\@o});
        }, begin => 0.001);
    }
  chang: |
      push @{G.Vu.U||=[]}, $u if u.G eq $G;
      die "WEIRD u.G.name on u.K " if u.G ne $G;
      0->sing(uxd => sub { w uxd; }, again=>1);
  unchanged: |
      my ($u) = values %$ar;
      $u = u.theD || die if ref $u ne 'C';
      0->deaccum(G.Vu, 'U', $u);
  v:
    ch: |
      die "V who?";
      w chang;
  T:
    traction: |
      w chang[$u];
recoded_Cways: 1

