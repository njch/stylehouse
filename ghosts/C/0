name: code
C:
 - K: J #c
   styles: 
   flows_D: |
     S.e = 9 if !defined S.e;
     B.lines = [$H->hitime];
     #my $cm = 0->TafuBl("CodeMirror", {C => $S});
     # cm.Z.padding = "1em";
   
   
 - K: Dos #c
 
 - K: Do #c
   BcS: name D
   print: |
     $name
   S:
     aZ: {background: '#044'}
   E:
     _D: |
       $D->();
   ux:
     spawn:
       - K: Codlue
 - K: Emb #c
   Z:
      color: rgba(255,200,200,0.4)
      font-size: 200%
      position: absolute
      left: -1em
      top: -7px
      flit:
        blur: 6px
   S:
      content_D: |
        ui.K
 - K: Oud #c
   flows_D: |
     # some some
   Codon: |
     0->visTp_TafuBlA({i=>$S}, [Codon => { file => $file }]);
       
 - K: Codlue #c
   S:
     content_D: |
       return w $ui print if ui.K =~ /File|Do|Ghost/;
       
       my $pri = lc ui.K;
       my $db = {%{ui.B}};
       my $s = ui.K;
       $s .= "(".gpty($_).")" for grep{defined} delete $db->{$pri};
       if (defined db.name) {
           $s .= "(db.name)";
           $db = {};
       }
       delete $db->{ui.Li.i.K};
       $s .= ki($db) if %$db && S.q < 3;
       return $s;
 - K: KV #c
   eadu: |
      my @stuff = ("for ".gp($u),
      map {
          my $de = gp($d->{$_});
          qq{$_    <span style="color:white;">$de</span>} 
          }  sort keys %$d);
      B.lines = \@stuff;
      Say "lines ".(0+@stuff);
      return;
      my $t = {};
      for my $k (sort keys %$d) {
          my ($fit) = $k =~ /^(\W\w+)/;
          my $ft = $t->{$fit} ||= 0->TafuB(Code => {fit=>$fit,lines=>[]});
          $G->L($ft, $S);
          my $de = gp($d->{$k});
          my $l = qq{$k    <span style="color:white;">$de</span>} ;
          push @{ft.B.lines}, $l;
      }
      
   some: |
       return join("\n", @{$lines}[0..130]);
   
   ux:
     spawn:
      - K: Codlue
      - K: pre
        S:
          ishtml: 1
          content_D: |
            w $ui some;
           
 - K: D #c
   S:
     ishtml: 1
     content_D: |
       if (B.R) {
         B.m = w vAK[$R];
       }
       "<pre>B.m</pre>"
Rs:
  - K: surfboard
P:
 - K: Do
   B:
     name: title
     D: |
        G:Ï  w grabkeys(GG=>$G);
   flows_D: |
     B.name = "H.style H.name ! open C";
     #$G->wayb(H.G => $S->s(K => "Disc", way => "S/retile", Dish => $S));
     
 - GAK: U
   InC:
           W:
             Ss: [u, x, X]
             S:
               styles: OxO z NZ
           M:
             S:
               styles: OxO
             Z: {background: rgba(80,50,22,1)}
           ux:
             spawn: []
hooks:
  fresh_init: |
    H.keydo = sub { w key(e=>shift); };
    
    G.R ||= $G->R;
  percolate: |
    # HI for 1..2
    # wants to be in/of P: and handlers for K/GG in'ing
    
    my $R = $G->R("surfboard");
    G.vaD = w anD[$R];
    sayre "Percolating G.name" for 1..6;
    my $Dos = $G->findway("per_Do");
    for my $k (sort keys %$Dos) {
        say "gun $k";
        my $v = $Dos->{$k};
        my $wk = $k;
        $wk = "D/$wk" if ref $v;
        # + indject scraps from $v into the T
        my $way = "per_Do/$wk";
        # TRub or _0 itself can Route
        sayyl "$v Do $k to $way";
        0->TRub(
            (ref $v ? ('{i' => $v) : ()), # or C->from somehow
            '{i{K' => 'Do',
            '{i{B' => { name => $k, D => sub { w $way; } },
        );
    }
    w uxd(full=>1);
  recoded_init:
    #w retile;
  a: |
    my ($k,$etc) = %$ar;
    my ($u) = 0->rei({K=>$k});
    w chang[$u];
    $u;
  key: |
    my $k = e.k;
    sayyl join"  ", ($k) x 13 for 1..4;
    
    # call w R/e without $R but with $e for $G->$R hop
    my $D = w a(D=>"");
    my $R = D.B.R;
    say "Found ".$D->pi;
    
    # call w $R key
    $R->key($k);
  vAK: |
    R.J ||= {
        from => $H,
        trav => "{G{GGs",
    };
    R.S ||= {
        e => 0.3,
    };
    
    my $j;
    for my $k (@{G.A.n}) {
        $j->{k.i.K}++
    }
    $j = {};
    
    $R->S;
    
  S:
    duthis: |
      my $u = ar.u || G.ulast;
      G.ulast = $u; 
      $u = $u;
      my $d = w S/duff[$u];
      w S/ducode[$d, $u];
      
    ducode: |
      my $KV = $G->TafuB(KV => {});
      w $KV eadu[$d, $u];
      
    duff: |
      my $s = $G->dus();
      s.A.oh = 0.2;
      s.G.oh = 1;
      $G->du({i=>$u, s=>$s, e=>2});
  anD: |
    0->TafuB(D=>$ar);

  elvibe: |
    H.G w z/keon;
  per_Do:
    RW: |
       G.O w ux(GG=>$G);
    uxd: |
       w uxd;
    keon: |
       H.G w z/keon;
  puur:
    swek: |
      Say "Awaits";
      G.envsub = sub {
        my $u = shift;
        sw[ $u, map { $_->pi } @{u.A.n} ];
      };
      
    du: |
      w S/duthis;
    seek: |
       Say "Awaits";
       G.envsub = sub {
         my $u = shift;
         $u = u.A;
         w S/duthis[$u];
       }
    bake: |
       Say "Awaits";
       G.envsub = sub {
         my $u = shift;
         sw(u.A->path);
         for (@{ u.A.n }) {
             _.styles =~ s/brick8/brick3/ || _.styles =~ s/brick3/brick8/;
         }
       };
    J: |
       for my $j (0->rei({K=>"J"})) {
           0->del($j);
       }
       0->TafuB(J => {});
  event: |
    sayyl "Event relating to ".$u->pi;
    0->visTp({L=>$L},'Fun');
    for (1) {
        G.envsub && do { say "envsub"; delete(G.envsub)->($u); next };
        e.S && do { w $u zoum; next };
        w $u E/_D;
        #waylay uxd;
    }
    sw (ar.u) if e.S;
  uxd: |
    return unless G.GG.U;
    my $chi = G.Vu.U;
    G.Vu.U = [];
    if (!ar.full && $chi && @$chi) {
        my @i = uniq grep { defined } map { _.Lo && _.Lo.i } @$chi;
        #sw[i=>@i, U=>@$chi];
        say "part uxd ".@$chi;
        @$chi = uniq grep { defined } @$chi, @i;
        say "abode : ".$_->pi for @i;
        G.GG.U->w('ux', {is => $chi});
    }
    else {
        my @o = 0->scGre({});
        my $full = ar.full ? "FULL":"full";
        saygr "Codon $full uxd";
        0->sing(alluxd => sub { Say "uxing...";
            G.GG.U->w('ux', {Ls=>\@o});
        }, begin => 0.001);
    }
  chang: |
      push @{G.Vu.U||=[]}, $u if u.G eq $G;
      die "WEIRD u.G.name on u.K " if u.G ne $G;
      0->sing(uxd => sub { w uxd; });
    
  v:
    ch: |
      die "V who?";
      w chang;
  T:
    traction: |
      w chang[$u];
recoded_Cways: 1

