name: code
C:

 - K: Do #c
   BcS: name D
   print: |
     $name
   S:
     styles: -te
     Z: {background: '#044'}
   E:
     _D: |
       Sw B/D;
   ux:
     spawn:
       - K: Codlue
 - K: Emb #c
   Z:
      color: rgba(255,200,200,0.4)
      font-size: 200%
      position: absolute
      left: -1em
      top: -7px
      flit:
        blur: 6px
   S:
      content_D: |
        ui.K
 - K: Codlue #c
   S:
     content_D: |
       return w $ui print if ui.K =~ /File|Do|Ghost/;
       
       my $pri = lc ui.K;
       my $db = {%{ui.B}};
       my $s = ui.K;
       $s .= "(".gpty($_).")" for grep{defined} delete $db->{$pri};
       if (defined db.name) {
           $s .= "(db.name)";
           $db = {};
       }
       delete $db->{ui.Li.i.K};
       $s .= ki($db) if %$db && S.q < 3;
       return $s;
 - K: D #c
   flows_D: |
     $R = B.R = $G->R($R||die);
     w vAK/setup[$R];
   S:
     styles: -te tu
     ishtml: 1
     content_D: | 
       if (B.R) {
         B.m = w vAK/S[$R];
       }
       B.m;
P:
 - K: Do #c
   B:
     name: title
     D: |
        G:Ϡ w grabkeys(GG=>$G);
   flows_D: |
     B.name = "H.style H.name ! open C";
     #$G->wayb(H.G => $S->s(K => "Disc", way => "S/retile", Dish => $S));
 
 - Do Z: |
     G:Ϡ w retile;
 - Do RW: |
       G.O w ux(GG=>$G);
       
 - Do uxd: |
       w uxd;
       
 - Do keon: |
       H.G w z/keon;
       
 - K: D #c sur
   B: 
     R: surfboard
    
 - GAK: U #c
   InC:
           W:
             Ss: [u, x, X]
             S:
               styles: OxO z NZ
               Z: {overflow-y: scroll}
           M:
             S:
               styles: OxO
           ux:
             spawn: []
R:
 - K: surfboard
   in_R:
     S: 
       key:
          E: Vit/up
          R: Vit/down
          T: gp/tognew
          Y: Chew/in
          A: Spl/A
          S: Spl/S
          D: Spl/D
          F: Spl/F
          G: Spl/G
hooks:
  fresh_init: |
    H.keydo = sub { w key(e=>shift); };
  recoded_init: |
    w vAK/are;
  percolate: |
    w uxd;
  a: |
    my ($k,$etc) = %$ar;
    my ($u) = 0->rei({K=>$k});
    w chang[$u];
    $u;
  key: |
    my $k = e.k;
    my $R = w vAK/are;
    w vAK/key[$R, $k, $e];
  vAK:
    are: | # chang->queue U xing
      my ($u) = 0->rei({K=>'D'});
      w chang[$u];
      u.B.R
    setup: |
        for my $k (keys %$R) {
            if ($k =~ /^in_R$/) {
                $R->from(delete($R->{$k}));
            }
            say wdump(2,$R);

            # TODO $R->up
        }
        R.J ||= {
            from => $R,
        };
        R.J ||= {
            from => $H,
            trav => "{G{GGs",
        };
        R.S.gpnew = 1;
        R.S.rowlimit = 2*9; 
        R.S.e ||= 0.6;
        R.S.w = R.A->spawn('C');
        
        R.S.w->from(Load(<<''));
          Vit:
            up: |
                R.S.e += 0.1;
            down: |
                R.S.e -= 0.1;
          gp:
            tognew: |
                sayyl "gpnew going ".(R.S.gpnew = !R.S.gpnew);
          Chew:
            in: |
              die "hi!";
              # make rows tally uniqs of small voltages
              # for either this set or all the sets of n_what in A
              # line up similar
              # all this boxing in
          Spl:
            G: |
              # to ghost from here
            F: |
              # F junk?
            D: |
              # to data dump
              R.S.rowing = "D";
            S: |
              # to styley
              R.S.rowing = "S";
            A: |
              # heredity
        
        #w R.S.w $_/in({}) for keys %{R.S.w};
        
        R.S.key = Load(<<'');
        

    key: |
      sayyl join"  ", ($k) x 13 for 1..4;
      $R->key($k, $e);
      my $key = "$k";
      $key = "S$key" if e.S;
      # some instyle hooks letters to apply
      my $do = R.S.key->{$key};
      say "lettering $key => $do";
      R.G w R.S.w $do if $do;
    gp: | #c vAK gp
        #return $u->pi if u can pi # braid wants bit of pi somewhere too
        # gpty: 
        R.gp_inarow++;
        $cv = 0.1 if $cv < 0.1;
        my $wit = sub {
            '<t style="color:#'.($_[1] || '8f9').';">'.shift.'</t>'
        };
        my $wt = sub {
            '<t style="'.$_[1].'">'.shift.'</t>'
        };
        
        my @s;
        my $c = w vAK/cgp(u=>$u);
        
        if (c.ARRAY) { #c
            if (!@$u) {
                @s = "[]";
            }
            else {
                my $vcv = $cv - 0.1;# @$u;
                my $si = @$u;
                @s = (
                    $wit->($si, "fff;font-size:50%"),
                );
                if ($vcv <= 0.1) {
                    push @s, "[]";
                }
                else {
                    push @s,  '[';
                    my $i = 0;
                    my @us;
                    while (exists $u->[$i]) {
                        my $ui = $u->[$i];
                        push @us,
                            w vAK/gp(R=>$R, u=>$ui, cv=>$vcv);
                        last if $i++ > 9;
                    }
                    push @s, join(', ', @us),
                    ']';
                }
            }
        }
        elsif (c.HASH) { #c
            my $v = {%$u};
            my $si = keys %$v;
            @s = (
                $wit->($si, "fff;font-size:50%"),
            );
            my $vcv = $cv - 0.2;
            if ($vcv >= 0.2) {
                my @ks;
                push @ks, "K" && delete v.K if v.K;
                push @ks, sort keys %$v;
                # like sorting the hashy du planet rows
                # all about dividing lines to the length
                my @kv;
                for my $k (@ks) {
                    my $uu = $u->{$k};
                    if ($vcv >= 0.2) {
                        my $v = w vAK/gp(R=>$R, u=>$uu, cv=>$vcv);
                        push @kv, ',' if @kv;
                        push @kv, $wit->($k, "acf");
                        push @kv, ':',
                            $wt->($v, "font-size:75%") if $vcv > 0.1;
                    }
                }
                # wrap? tabul? frond?
                push @s,
                    "{",
                    @kv,
                    "}",
            }
            else {
                push @s,
                    "{}",
            }
        }
        elsif (c.ref) { # weird ref
            # looks for patterns from anywhere for clues
            @s = (
                $wit->(ref($u), "333;font-size:50%"),
                $wit->(gname($u)),
            ),
        }
        elsif (c.undef) {
            @s = '~';
        }
        elsif (c.text) { #c
            my $line = $u;
            # these resistances to content
            # width enthusiasm
            # q factor
            # squeeze into space, less stuff as we q away from here
            # so layers inside {d{u 0.4 $u make for easy ux peeling, decay
            # after we made it up, quickly as we are making up new stuff
            
            my $adhow;
            if (c.lin > 1) {
                $line = join '↯', split /\n/, $u; 
                $adhow = 1;
            }
            my $tev = $cv * 125; # 0.4 = 100
            my $howad = ".c.lin".".c.len".".c.b";
            my $trev = $tev - length($howad);
            
            if (length($line) > $tev) {
                $line = ($line=~/^(.{$trev})/s)[0];
                $adhow = 1;
            }

            push @s, $wit->($howad, "88b;font-size:60%") if $adhow;
            $line = $wit->($line, "3f3");
            push @s, $line;
        }
        else {
            # something we know
            if (c.canpi) { #c
                my $r = ref $u;
                my $a = {cv=>$cv}; # traveller - magnetic fishing rod
                my $pi = $r =~/^(G|A|C)$/ ? do {
                    my $vos = {
                        0 => { thi => ref $u },
                        0.1 => { name => u.name },
                        0.2 => { K => u.K },
                    };
                    if ($r eq "A") {
                        #$vos->{0.1} = { id => u.id };
                        $vos->{0.2} = sub{{ for => ">".u.i->pi(), _u => u.i }};
                    }
                    if ($r eq "C") {
                        #$vos->{0.1} = { id => u.id };
                        my $C = $u;
                        
                        
                        my $two = $vos->{0.2}; # has u.K
                        # it's like C$name↯$K ...
                        two.aa = "↯"; # put 
                        if (C.B && C.B.name) {
                            two.maa = "Bname:";
                            two.mame = C.B.name;
                        }
                        
                        
                        my $print;
                        if ((defined C.print || C.Gw) && G::wish(G=>C.G)) {
                            eval { $print = C.G w $C print({}); };
                            $@ = "" if $@;
                        }

                        my $B;
                        
                        if (C.B) {
                            if (a.cv > 0.2) {
                                if (join(",", sort keys %{C.B}) eq "Lu,ui") {
                                    $B = "ui=(".C.B.ui->pint();
                                }
                                $B ||= G::slim(50,30,G::ki(C.B))        
                            }
                        }
                        $vos->{0.3} = sub{
                              my $b = {};
                            if (C.B) {
                                b.B = "B:$B";
                                b._u = C.B;
                            }
                            $b;
                        };
                    }
                    for my $vo (sort keys %$vos) {
                        if ($cv >= $vo) {
                            my $d = $vos->{$vo};
                            $d = $d->() if ref $d eq 'CODE';
                            a.o->{$vo} = $d;
                        }
                    }
                    my @s;
                    for my $vo (sort keys %{a.o}) {
                        my $v = a.o->{$vo};
                        for my $vk (sort keys %$v) {
                            next if $vk =~ /^_/;
                            my $s = $v->{$vk};
                            push @s, $s;
                        }
                    }
                    join ' ', @s;
                } : $u->pi;
                if (a.o) { #c
                    my $vcv = $cv - 0.2;
                    # modification of the above %{a.o} chunk...
                    for my $vo (sort keys %{a.o}) {
                        my $v = a.o->{$vo};
                        for my $vk (sort keys %$v) {
                            next if $vk =~ /^_/;
                            my $w;
                            $w = "cfa" if $vk eq 'thi';
                            $w = "ca6" if $vk =~ /ame$/;
                            $w = "000;font-size:30%" if $vk eq 'id';
                            my $s = $v->{$vk};
                            # if v._u, $vk=for, has pi string worked out
                            # but we want to get more of ourself in there
                            # so vakgp...
                            $s = w vAK/gp(R=>$R, u=>v._u, cv=>$vcv) if
                                v._u && $vcv >= $vo;
                            next if $vk eq 'K' && $s eq a.o->{0.1}->{name};
                            $s = $wit->($s, $w) if $w;
                            push @s, $s;
                        }
                    }
                    
                } else {
                    if ($pi =~ s/^$r //) {
                        push @s, $wit->($r, "cfa");
                        push @s, $pi;
                    }
                }
            }
            else {
                push @s, "know $u";
            }
        }
        
        R.gp_inarow--;

        R.S.gpnew ? join("", @s) : G::gp($u);
    cgp: | #c data guess chart
        my $c = {};
        if (!defined $u){
            c.undef = 1;
        } else {
            if (my $ref = ref $u) {
                c.ARRAY = 1 if $ref eq "ARRAY";
                c.HASH = 1 if $ref eq "HASH";
                c.CODE = 1 if $ref eq "CODE";
                c.canpi = 1 if !%$c && $u->can('pi');
                for (qw'A C G T     R') {
                      $c->{$_} = 1 if $ref eq $_;
                }
                c.ref = $ref if !%$c;
            }
            else {
                if (ref \$u eq 'SCALAR') {
                    c.text = 1;
                    c.len = length($u);
                    c.lin = scalar split /\n/, $u;
                    c.b = scalar split /\n\n/, $u;
                    c.number = $u =~ /^(?:\d+\.)?\d+$/;
                    c.wordy = $u =~ /\w+/;
                }
                else { die "wtf is $u" };
            }
        }
        $c
            
      
        
        
        
    S: | #c vAK S
        $R->S; # 1-4
    

        # 5
        # quick style synapse
        my @rows;
        my $i = 1;
        my $agp = {R=>$R, cv=>1};
        sayyl "Rows: ".@{R.a.r};
        for my $r (@{R.a.r}) {
            my ($ac, $li) = @$r;
            my ($a, $cv) = split /\s+/, $ac;
            
            my $pi = w vAK/gp(%$agp, u => $li, cv => $cv);
            
            $ac =~ s/\s+/ /g;
            
            push @rows,
            join "  ", map { $R->f(@$_) }
                [ black => $a ],
              [ red_fs80 => $cv ],
              [ blue_fs80 => $i++ ],
              [ white_fs120 => $pi ],
        }
        
        @rows = wdump(1, R.a.i) if R.S.rowing eq "D";

        my $frompi = w vAK/gp(%$agp,  u => R.J.from);
        my $topi = w vAK/gp(%$agp, u => R.a.i);

        my $Jpi = "@!@".$R->f(white => $frompi)
            ."  ".$R->f(black => R.J.trav);
            
        my $title = "R.S.e = ".$R->f(white_fs150 => $topi);

        my $html = join "\n", $Jpi, $title, @rows;

        # 6
        # TODO more style synapse rejoins after delib fork exp
        # reflect style injection round corner
        # throw style into ux recipe
        
        # 8

        # shrink this webbing into a space in our webbing
        my $lines = split /\n/, $html;
        my $o = 12;
        my $fs;
        if ($lines > $o) {
            $fs = 100 * $o / $lines;
            $fs *= -1 if $fs < 0;
            $fs = "font-size:".$fs."%;";
            sayre "$lines become $fs";
        }
        #sayre "$lines lines" for 1..5;

        qq{<pre style="$fs;background: rgba(80,50,22,0.3);">$html</pre>}
  elvibe: |
    H.G w z/keon;
    
  event: |
    sayyl "Event relating to ".$u->pi;
    0->visTp({L=>$L},'Fun');
    for (1) {
        G.envsub && do { say "envsub"; delete(G.envsub)->($u); next };
        e.S && do { w $u zoum; next };
        w $u E/_D;
        #waylay uxd;
    }
    sw (ar.u) if e.S;
  uxd: |
    return unless G.GG.U;
    my $chi = G.Vu.U;
    G.Vu.U = [];
    if (!ar.full && $chi && @$chi) {
        my @i = uniq grep { defined } map { _.Lo && _.Lo.i } @$chi;
        #sw[i=>@i, U=>@$chi];
        say "part uxd ".@$chi;
        @$chi = uniq grep { defined } @$chi, @i;
        say "abode : ".$_->pi for @i;
        G.GG.U->w('ux', {is => $chi});
    }
    else {
        my @o = 0->scGre({});
        my $full = ar.full ? "FULL":"full";
        saygr "Codon $full uxd";
        0->sing(alluxd => sub { Say "uxing...";
            G.GG.U->w('ux', {Ls=>\@o});
        }, begin => 0.001);
    }
  chang: |
      push @{G.Vu.U||=[]}, $u if u.G eq $G;
      die "WEIRD u.G.name on u.K " if u.G ne $G;
      0->sing(uxd => sub { w uxd; });
    
  v:
    ch: |
      die "V who?";
      w chang;
  T:
    traction: |
      w chang[$u];
recoded_Cways: 1

