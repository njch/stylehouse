name: code
C:

 - K: Do #c
   BcS: name D
   print: |
     "$name S.on";
   S:
     styles: -te
     Z: {background: '#044'}
   E:
     _D: |
       Sw B/D;
   ux:
     spawn:
       - K: Codlue
 - K: Emb #c
   Z:
      color: rgba(255,200,200,0.4)
      font-size: 200%
      position: absolute
      left: -1em
      top: -7px
      flit:
        blur: 6px
   S:
      content_D: |
        ui.K
 - K: Codlue #c
   S:
     content_D: |
       return w $ui print if ui.K =~ /File|Do|Ghost/;
       
       my $pri = lc ui.K;
       my $db = {%{ui.B}};
       my $s = ui.K;
       $s .= "(".gpty($_).")" for grep{defined} delete $db->{$pri};
       if (defined db.name) {
           $s .= "(db.name)";
           $db = {};
       }
       delete $db->{ui.Li.i.K};
       $s .= ki($db) if %$db && S.q < 3;
       return $s;
 - K: D #c
   flows_D: |
     $R = B.R = $G->R($R||die);
     R.name .= " S.B.name";
     R.A->umv("", "Rand");
     S.A->umk($R, "Doer");
     $G->{S.B.name} = $R;
     w vAK/setup[$R];
     Sw flot_D[$R];
   S:
     styles: -te tu
     ishtml: 1
     content_D: | 
       if (B.R) {
         B.m = w vAK/S[$R];
       }
       B.m;
P:
 - K: Do #c
   B:
     name: title
     D: |
        G:Ϡ w grabkeys(GG=>$G);
   flows_D: |
     B.name = "H.style H.name ! open C" ;
     #$G->wayb(H.G => $S->s(K => "Disc", way => "S/retile", Dish => $S));
 
 - Do Z: |
     G:Ϡ w retile; 
 - Do RW: |
       G.O w ux(GG=>$G);
       
 - Do uxd: |
       w uxd; 
       
 - Do keon: |
       H.G w z/keon;
       
 - Do switch: |
       G.ri++;
       my $r = w vAK/are;
       S.on = r.name;
       w chang(u=>$S);
 - K: D #c sur
   B: 
     name: one
     R: surf
    
 - K: D #c sur
   B: 
     name: twofer
     R: surf
   flot_D: |
     R.J = { from => $R, trav => '{S{w' };
 - GAK: U #c
   InC:
       W:
         Ss: [u, x, X]
         S:
           styles: OxO z NZ
       M:
         S:
           styles: OxO
       ux:
         spawn: []
R:
 - K: surf
   in_R:
     
     S: 
       gpnew: 1
       rowlimit: 24
       e: 0.6
       key: #c
          0: Num/out
          number: Num/in
          E: Vit/up
          R: Vit/down
          Y: Chew/in
          A: Spl/A
          S: Spl/S
          D: Spl/D
          F: Spl/F
          G: Spl/G
          W: Rock/way
       w!C: #c
          Rock:
            way: |
              R.J = {
                  from => $R,
                  trav => '{S{w',
              };
            igloo: |
              R.J = {
                  from => $H,
                trav => '{G{GGs',
              }
          Vit:
            up: |
                R.S.e += 0.1;
            down: |
                R.S.e -= 0.1;
          gp:
            tognew: |
                sayyl "gpnew going ".(R.S.gpnew = !R.S.gpnew);
          Chew:
            in: |
              die "hi!";
          Spl:
            G: |
              # to ghost from here
            F: |
              # F junk?
              w seetry;
            D: |
              # to data dump
              R.S.rowding = !R.S.rowding;   
            S: |
              # to styley
              #R.S.rowing = "S";
            A: |
              # heredity
          Num: #c
            out: |
              if (R.ksuc && $k eq "0") {
                  return R.ksuc = ""
              }
              return $R->popJtrav
            in: |
              R.ksuc .= $k;
              my $j = R.a.ro->{R.ksuc};
              
              $j || return sayre "no j ye for R.ksuc";
              sayyl "got j for R.ksuc";

              R.ksuc = "";

              my ($hop) = j.ac =~ /^(\W\w+)/;
              R.J.trav .= $hop; 
       ss_Ds: #c schematic
         n: |
             n.HASH = {};
         Ai: |
             Ai.A = {};
         Gi: |
           my $likes = {map{$_=>1}qw{G ways}};
           Gi.HASH = {
              it => sub {
                my $h = shift;
                my @r = map { { K=>$_, k=>"{".$_, v=>$h->{$_} } } sort keys %$h
              },
           };
hooks:
  fresh_init: |
    H.keydo = sub { w key(e=>shift); };
    G.arp = [1..1024];
  recoded_init: |
    w vAK/are; 
  trythis: |
    "one thing";
  seetry: |
    saygr "Trying!!!!" for 1..5;
    my @lot = w trythis;
    my $f = $F[0];
    my $R = w vAK/are;
    my $a = {i=>$f};
    w vAK/sudden_i[$R, $a];
    sayyl "Trithings: $_ " for @lot;
  percolate: |
    w uxd;
  a: |
    my ($k,$etc) = %$ar;
    my ($u) = 0->rei({K=>$k});
    w chang[$u];
    $u;
  key: |
    my $k = e.k;
    my $R = w vAK/are;
    w vAK/key[$R, $k, $e];
  vAK:
    are: | #c chang->queue U xing
      my (@us) = 0->rei({K=>'D'});
      G.ri = 0 if !exists $us[G.ri];
      my $u = $us[G.ri];
      w chang[$u];
      u.B.R
    setup: | #c
        $R->from(delete R.in_R) if R.in_R;
        R.J ||= { 
            from => $R,
            trav => '{G',
        };
        
        if (my $ssDs = delete R.S.ss_Ds) {
            for my $k (sort keys %$ssDs) { # or K array who knows
                my $u = R.S.ss->{$k} = $R->dus;
                my $D = $ssDs->{$k};
                $G->D({bab=>$D, ar=>{$k=>$u}});
            }
        }
        
        say "Made ".$R->pi;
        #w R.S.w $_/in({}) for keys %{R.S.w};
    key: | #c
      sayyl join"  ", ($k) x 13 for 1..2;
      
      my $key = "$k";
      $key = "S$key" if e.S;
      # some instyle hooks letters to apply
      my $do = R.S.key->{$key};
      $do ||= do {
          my $or = "number" if $key =~ /[0-9]/;
          R.S.key->{$or} if $or;
      };
      $do ||= "wtf";
      
      sayyl join"  ", ($do) x 13 for 1..2;
      
      R.G w R.S.w $do;
      
    sudden_i: | #c ebrace flying embryo J
      R.J = { from => a.i };
    
    uni: | #c
      my $J = R.J || die;
      my $i = J.from || die;
      my $t = J.trav || "";
      #  from => $H,
      #  trav => "{G{GGs",
      my @tr = $t =~ m/(\W\w+)/sg;
      
      
      for (@tr) {
          /^(.)(.+)$/;
          say "Snapped $i       $1 $2";
          last if $1 eq " ";
          $i = $i->{$2} if $1 eq "{";
          $i = $i->[$2] if $1 eq "[" && (ref $i eq 'ARRAY' || die "NOT!");
      }
      if ($t =~ m/^.+? (.+)$/) {
          say "Had some more: $1";
      }
      $i
    S: | #c void vAKcess R::S heist
        # 1
        R.a = shift || {};
        R.a.e ||= R.S.e || die;
        R.a.i ||= w vAK/uni[$R]; # find tip along the trav
        # s messed by R plumbing, sure
        R.s = R.S.s || $R->dus;
        my $agp = {R=>$R, cv=>1};
        R.a.tr.rowlimit = R.S.rowlimit || 9*2;
        R.a.bb = {};
        
        # 3
        $R->du;
        
        # 4
        w vAK/S_4;
        my $a = R.a;
        
        do {
            a.bb->{"Jfro 0.1"} = "@!@";
            
            my $gp = {R=>$R, u=>R.J.from, cv=>0.2};
            my $v = w vAK/gp(a => $gp);
            
            a.bb->{"R_J_from 0.1"} = $v;
            a.bb->{"R_J_from%sf 0.1"} = 'white';
            a.bb->{"R_J_from%gp 0.1"} = $gp;
            
            a.bb->{"R_J_trav 0.1"} = R.J.trav;
            a.bb->{"R_J_trav%sf 0.1"} = 'black';
        };
        do {
            my $gp = {R=>$R, u=>R.a.i, cv=>0.2};
            my $v = w vAK/gp(a => $gp);
            
            a.bb->{"R_S_e 0.2"} = R.S.e;
            a.bb->{"R_a_i 0.2"} = $v;
            a.bb->{"R_a_i%sf 0.2"} = 'white';
            a.bb->{"R_a_i%gp 0.2"} = $gp;
        };
        a.bb->{"Js 0.29"} = "\n";
        
        say a.bb->{"R_J_from 0.1"} ." trav: ". a.bb->{"R_J_trav 0.1"} ." thing: ".a.bb->{"R_a_i 0.2"};
        # 7
        my $html = w vAK/makaout(R=>$R, a=>R.a);
        
        # 6
        # TODO more style synapse rejoins after delib fork exp
        # reflect style injection round corner
        # throw style into ux recipe
        
        # 8

        # shrink this webbing into a space in our webbing
        my $lines = split /\n/, $html;
        my $o = 12;
        my @sty;
        my $fs;
        if ($lines > $o) {
            $fs = 100 * $o / $lines;
            $fs *= -1 if $fs < 0;
            push @sty, "font-size:$fs%";
        }
        push @sty, "background:rgba(80,50,22,0.3)"; 
        push @sty, "white-space:pre";
        push @sty, "font-family:mono";
        my $sty = join ";", @sty; 
        qq{<div style="$sty"><span>$html<span></div>}
      
    shj: | #c
      my $j;
      j.r = $r;
      j.s = $d->{$r};
      
      (j.t, j.cv) = split /\s+/, j.r, 2;
      (j.cv, my @e) = split /\s+/, j.cv;
      j.ev = \@e if @e;
      $j
    S_4: | #c
        my $a = R.a;
        my $d = a.d; # from du
        
        my @r = w stylekeysort[$d];
        my $si = @r;
        my @i = w wind[$si];
        my $ro = R.a.ro = {}; # wind round
        my $i = 0;
        for my $r (@r) {
            my $j = w vAK/shj[$r, $d];
            my $li = j.li = shift @i || die;
            $ro->{$li} = $j;
            if ($i > 0) {
                 a.bb->{"${li}0_Bs 0.3 0.3${li}0"} = "\n";
            }
            a.bb->{"${li}_li 0.3 0.3${li}1"} = j.li;
            a.bb->{"${li}_li%sf 0.3 0.3${li}1"} = 'blue_fs120';
            a.bb->{"${li}_k 0.3 0.3${li}2"} = j.t;
            a.bb->{"${li}_k%sf 0.3 0.3${li}2"} = 'black';
            
            a.bb->{"${li}_cv 0.3 0.3${li}3"} = j.v;
            a.bb->{"${li}_cv%sf 0.3 0.3${li}3"} = 'red_fs80';
            
            my $gp = {R=>$R, u=>j.s, cv=>j.cv};
            my $v = w vAK/gp(a => $gp);
            
            a.bb->{"${li}_s 0.3 0.3${li}4"} = $v;
            a.bb->{"${li}_s%sf 0.3 0.3${li}4"} = 'white_fs120';
            a.bb->{"${li}_s%gp 0.3 0.3${li}4"} = $gp;
            $i++;
        }
    gp: | #c vAK gp
        
        G.gp_inarow++;
        my $a = ar.a || {};
        a.cv = ar.cv if ar.cv;
        a.R = ar.R if ar.R;
        a.u = ar.u if ar.u;
        a.cv = 0.1 if a.cv < 0.1;
        my $u = a.u;
        
        my $c = w vAK/cgp[$u]; # guesses
        
        my $arr = {
            a => $a, # @_
            u => $u,
            c => $c,
            R => a.R,
        };
        
        my @bpi = qw'ARRAY HASH ref undef text canpi';
        my $wa = "wtf";
        for my $b (@bpi) {
            if ($c->{$b}) {
                $wa = $b;
                last;
            }
        }
        if ($wa eq "canpi") { # supply $self
            $wa = ref $u;
            $arr->{$wa} = $u;
        }

        my $gppi = $G->findway('vAK/gp_pi');
        $gppi->{$wa} || die "not $wa equip";


        
        my @spi = w vAK/gp_pi/$wa(%$arr);
        
        arr.spi = \@spi;
        
        my @s = w vAK/makaout(%$arr); 
        
        G.gp_inarow--;

        join("", @s);
    makaout: | #c
            my @s;
            if (!a.bb) {
                my $spi = ar.spi || die;
                my $r = ref ar.u;
                if ($spi->[0] =~ s/^$r //) {
                    $r = G.wit->($r, "cfa") if G.wit;
                    unshift @$spi, $r;
                }
                return @$spi;
            }
            
            # scan a.bb and add more styles././
            for my $k (%{a.bb}) {
                if ($k =~ /^(\S*(?:oB|Bo|Bi))\s+(.+)$/) {
                    a.bb->{"$1\%css $2"} = "color:black";
                }
            }
            
            my @r = w stylekeysort(d=>a.bb);
            
            a.o = {}; # by voltage, peel
            for my $r (@r) {
                my ($l, $vo, $or) = split /\s+/, $r; # split style, vectory
                
                saygr "igggy $l $vo > a.cv" && next if a.cv && $vo > a.cv;
                
                $or = $vo if !defined $or;
                
                my $o = a.o->{$or} ||= []; 
                push @$o, $r;
            }
            
            my $vcv = a.cv - 0.2; # dus bend
            # modification of the above %{a.o} chunk...
            
            
            #thingness_appearance #c
            my $th = {};
            my $ap = {};
            my @int;
            for my $ov (sort keys %{a.o}) {
                 my $o = a.o->{$ov};
                 
                 for my $r (@$o) {
                     my $s = a.bb->{$r};
                     my ($l, $vo) = split /\s+/, $r; # split style, vectory
                     ($l, my $style) = split '%', $l;
                     
                     my $in = $style ? $ap : $th;
                     my $j = {
                         l => $l,
                         s => $s,
                         vo => $vo,
                     };
                     if ($style) {
                         my $o = $ap->{$l} ||= [];
                         j.style = $style;
                         push @$o, $j
                     }
                     else {
                         if (exists $in->{$l}) {
                             warn "replacemont $l $vo";
                         }
                         $th->{$l} = $j;
                         push @int, $l;
                     }
                }
            }
            
            say "\n\n yo : ar.u \t\t ".(0+@r) if ar.db;
            
            
            for my $thl (@int) {
                my $j = $th->{$thl} || next;
                my $o = delete $ap->{$thl};
                my $l = j.l;
                my $s = j.s;
                
                # top volt for thing selection: # whattage
                next if $l eq 'K' && $s eq a.bb->{"name 0.1"};
                
                die "reffy $s in $l" if ref $s;
                sayyl "for the $l\t\t$s j.vo" if ar.db;
                
                my $ishtml;
                my $css = [];
                for my $oj (@$o) {
                    saybl "        sdtyle! oj.style oj.s" if ar.db; 
                    if (oj.style eq "css") {
                        push @$css, oj.s;
                    }
                    elsif (oj.style eq "gp") {
                        # has a way to $a the gp action within...
                        $ishtml = 1;
                    }
                    elsif (oj.style eq "sf") {
                        push @$css, map { $R::f->{$_} || die "no style $_"} split '_', oj.s;
                    }
                    else {
                        die "style oj.style = oj.s \t for $l";
                    }
                }
                
                my $at;
                at.style = join ';', @$css;
                at.title = $l;
                $at = join " ", map { $_.'="'.$at->{$_}.'"' } 
                    grep { $at->{$_} } sort keys %$at;
                $s = encode_entities($s) unless $ishtml;
                $s = "<t $at>$s</t>" if $s;
                push @s, $s;
            }
            
            if (%$ap) {
                sayre "Extr a appearance: ".wdump($ap);
            }
            
            @s = "nose?" if !@s;
            #die "nose? $u" if !@s;
            
            join("", @s);
    gp_pi: #c
      wtf: | #c
        "know $u"
      ARRAY: | #c
            my $cv = a.cv ||= 0.3;
            a.bb = {};
            my $si = @$u;
            
            a.bb->{'si 0.1'} = $si;
            a.bb->{'si%css 0.1'} = "color:#fff;font-size:50%";
            a.bb->{'Bo 0.1 0.11'} = '[';
            a.bb->{'oB 0.1 0.9'} = ']';
            
            return if $cv < 0.2;
            
            my $ki = 0;
            my $i = 0;
            while (exists $u->[$i]) {
                my $uu = $u->[$i];
                if ($ki > 0) {
                    $ki++;
                    a.bb->{"[${ki}#then 0.2"} = ',';
                    $ki++;
                }
                
                my $vcv = a.cv - 0.2; # dus bend for $k
                if ($vcv >= 0.2) {
                    my $gp = {R=>$R, u=>$uu, cv=>$vcv};
                    my $v = w vAK/gp(a => $gp);
                    a.bb->{"[${ki}_v 0.2"} = $v;
                    a.bb->{"[${ki}_v%css 0.2"} = "font-size:75%";
                    a.bb->{"[${ki}_v%gp 0.2"} = $gp;
                }
                if ($i >= 14) {
                    $ki++;
                    a.bb->{"[${ki}#more 0.2"} = (@$u - $i);
                    last;
                }
                $i++;
            }
      HASH: | #c
            my $v = {%$u};
            my $cv = a.cv ||= 0.3;
            a.bb = {};
            my @r = sort keys %$v;
            my $si = @r;
            
            a.bb->{'si 0.1'} = $si;
            a.bb->{'si%css 0.1'} = "color:#fff;font-size:50%";
            
            a.bb->{'Bo 0.1 0.11'} = '{';
            a.bb->{'oB 0.1 0.9'} = '}';
            
            return if $cv < 0.2;
            
            
            my @ks;
            push @ks, "K" && delete v.K if v.K;
            push @ks, sort keys %$v;
            
            my $ki = 0;
            for my $k (@ks) {
                my $uu = $u->{$k};
                
                if ($ki > 0) {
                    $ki++;
                    a.bb->{"[$ki 0.2"} = ',';
                    $ki++;
                }
                a.bb->{"[${ki}_k 0.2"} = $k; # could this be ${ki}_a?
                a.bb->{"[${ki}_k\%css 0.2"} = "color:#acf;font-size:80%";
                my $keyi = $ki;
                $ki++;
                my $vcv = a.cv - 0.2; # dus bend for $k
                if ($vcv >= 0.2) {
                    my $gp = {R=>$R, u=>$uu, cv=>$vcv};
                    my $v = w vAK/gp(a => $gp);
                    a.bb->{"[${ki}_Bi 0.2"} = ':'; # could be more "on" the _k
                    $ki++;
                    a.bb->{"[${ki}_v 0.2"} = $v;
                    a.bb->{"[${ki}_v%css 0.2"} = "font-size:75%";
                    a.bb->{"[${ki}_v%gp 0.2"} = $gp;
                }
            }
      ref: | #c weird ref
            # looks for patterns from anywhere for clues
            (
                $wit->(ref($u), "333;font-size:50%"),
                $wit->(gname($u)),
            )
      undef: | #c
            '~'
      text: | #c
            my $text = $u;
            a.bb = {};
            
            my @s;
            my $adhow;
            if ($text =~ /\n/) {
                $text = join '↯', split /\n/, $u; 
                $adhow = 1;
            }
            my $tev =  a.cv * 125; # 0.4 = 100
            my $trev = int $tev;
            
            my $si = length($text);
            if ($si > $tev) {
                $text = ($text=~/^(.{$trev})/s)[0];
            }
            else {
                undef $si;
            }
            
            my $ni = c.lin if c.lin > 1;
            my $bi = c.b if c.b > 1;
            
            if ($si) {
                # was trucated
                a.bb->{'Bo 0.1 0.11'} = "'";
                a.bb->{'oB 0.1 0.9'} = "'";
            }
            if ($si) {    
                a.bb->{'si/l 0.1'} = "$si";
                a.bb->{'si/l%css 0.1'} =
                "color:#b89;font-size:50%;position:absolute";
            }
            if ($ni) {
                a.bb->{'si/n 0.1'} = "$ni";
                a.bb->{'si/n%css 0.1'} = 
                "color:#fff;font-size:50%;position:absolute;margin-top:1.4em;";
            }
            if ($bi && 0) {
                a.bb->{'si/b 0.1'} = "b$bi";
                a.bb->{'si/b%css 0.1'} = 
                "color:#f89;font-size:50%;float:left;left:-1em";
            }
            
            a.bb->{"line 0.2"} = $text;
            a.bb->{"line%css 0.2"} =
            "background:rgba(200,30,80,0.3);color:#3f3;font-size:70%";
            
      A: | #c
        my $cv = a.cv ||= 0.3;
        a.bb = {};
        a.bb->{"thi 0"} = ref $u;
        return if $cv < 0.1;
        a.bb->{"name 0.1"} = u.name;
        return if $cv < 0.2;
        a.bb->{"K 0.2"} = u.K;
        
        my $vcv = $cv - 0.2;
        my $gp = {R=>$R, u=>A.i, cv=>$vcv};
        my $v = w vAK/gp(a => $gp);
        a.bb->{"i 0.2"} = $v;
        a.bb->{"i%gp 0.2"} = $gp;
      G: | #c
        $G->pi;
      T: | #c
        $T->pi;
      H: | #c
        $H->pi;
      R: | #c
        $R->pi;
      W: | #c
        "W W.K W.G.name ".$W->uhigh;
      C: | #c
        my $cv = a.cv ||= 0.3;
        a.bb = {};
        a.bb->{"thi 0"} = ref $u;
        a.bb->{"thi%css 0"} = "color:#9fa"; # TODO chunk by hash c space
        return if $cv < 0.1;
        a.bb->{"name 0.1"} = u.name;
        a.bb->{"name%css 0.1"} = "color:#ff3";
        
        return if $cv < 0.2;
        
        a.bb->{"K 0.2"} = u.K;
        a.bb->{"K%css 0.2"} = "color:#3f3";
        
        if (C.B && C.B.name) {
            a.bb->{"maa 0.2"} = "Bname:";
            a.bb->{"mame 0.2"} = C.B.name;
        }
        
        return if $cv < 0.3;
        
        if (C.G && (defined C.print || C.Gw)) {
            my $p = C.G->w('print' => {}, $C, {nodie=>1});
            a.bb->{"print 0.3"} = $p if defined $p;
        }
        
        # dusseldorf
        my %s = map { $_=>1 } grep { /^[a-z]/ } keys %$C;
        delete $s{id};
        my @or = qw'name point timer', keys %s;
        
        my $c;
        my $b;
        for my $k (@or) {
            next if !defined $k;
            next if !exists $C->{$k};
            my $t = $C->{$k};
            next if !defined $t;
            next if ref $t;
            next if $t =~ /\n/; 
            my $slim = slim(20,20,$t);
            
            a.bb->{"$k 0.4"} = $slim if $cv >= 0.4; # also a dus fuzz away
            
            a.bb->{"$k 0.3"} = $slim if $k eq "point"; # pyramid
        }
        
        if (C.B) {
            a.bb->{"B 0.3"} = w vAK/gp(%$a, u=>C.B, cv=>0.2) if C.B;
        }
        # should return text if no $a...
    cgp: | #c data guess chart
        my $c = {};
        if (!defined $u){
            c.undef = 1;
        } else {
            if (my $ref = ref $u) {
                c.ARRAY = 1 if $ref eq "ARRAY";
                c.HASH = 1 if $ref eq "HASH";
                c.CODE = 1 if $ref eq "CODE";
                c.canpi = 1 if !%$c && $u->can('pi');
                for (qw'A C G T     R') {
                      $c->{$_} = 1 if $ref eq $_;
                }
                c.ref = $ref if !%$c;
            }
            else {
                if (ref \$u eq 'SCALAR') {
                    c.text = 1;
                    c.len = length($u);
                    c.lin = scalar split /\n/, $u;
                    c.b = scalar split /\n\n/, $u;
                    c.number = $u =~ /^(?:\d+\.)?\d+$/;
                    c.wordy = $u =~ /\w+/;
                }
                else { die "wtf is $u" };
            }
        }
        $c
            
      
        
        
        
  stylekeysort: |
      my $d = ar.d;
      my $r = ar.r;
      my @r = $r ? @$r : sort keys %$d;
      
      if (grep { /^\[/ } @r) { 
          my $by = { map {
              my $p = $_;
              $p =~ s/^\[(\d+)/'['.sprintf('%08d', $1)/e;
              $p => $_
           } @r };
           @r = map { $by->{$_} } sort keys %$by;
      }
      @r
  wind: | #c
    my $s = 9;
    return 1..$s if $si <= $s;
    my $wind = $si - 9;
    my $from = 6;
    my $for = 3;
    
      my @i;
    
            my $la = $wind / $for;
            my $za = int $la;
            
            my $y;
            my @wind = 1..$wind;
            my @ys = $from..$from+$for-1;
            my $yi = 0;
            while (@wind) {
                my $win = shift @wind;
                
                my $at = $ys[$yi];
                $y->{$at}++;
                
                $yi++;
                $yi = 0 if !exists $ys[$yi];
            }
            
            for my $wi (1..$s) {
                
                if (my $la = $y->{$wi}) {
                    my @la = 1..$la+1;
                    for my $pl (@la) {
                        push @i, "$wi$pl";
                    }
                }
                else {
                    push @i, $wi;
                }
            }
            
            @i
            
  
  elvibe: |
    H.G w z/keon;
    
  event: |
    sayyl "Event relating to ".$u->pi;
    0->visTp({L=>$L},'Fun');
    for (1) {
        G.envsub && do { say "envsub"; delete(G.envsub)->($u); next };
        e.S && do { w $u zoum; next };
        w $u E/_D;
        #waylay uxd;
    }
    sw (ar.u) if e.S;
  uxd: |
    return unless G.GG.U;
    my $chi = G.Vu.U;
    G.Vu.U = [];
    if (!ar.full && $chi && @$chi) {
        my @i = uniq grep { defined } map { _.Lo && _.Lo.i } @$chi;
        #sw[i=>@i, U=>@$chi];
        say "part uxd ".@$chi;
        @$chi = uniq grep { defined } @$chi, @i;
        say "abode : ".$_->pi for @i;
        G.GG.U->w('ux', {is => $chi});
    }
    else {
        my @o = 0->scGre({});
        my $full = ar.full ? "FULL":"full";
        saygr "Codon $full uxd";
        0->sing(alluxd => sub { Say "uxing...";
            G.GG.U->w('ux', {Ls=>\@o});
        }, begin => 0.001);
    }
  chang: |
      push @{G.Vu.U||=[]}, $u if u.G eq $G;
      die "WEIRD u.G.name on u.K " if u.G ne $G;
      0->sing(uxd => sub { w uxd; });
    
  v:
    ch: |
      die "V who?";
      w chang;
  T:
    traction: |
      w chang[$u];
recoded_Cways: 1

