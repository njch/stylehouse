
C:
 - K: Do #c
   BcS: name D
   S:
     styles: -te
     Z: {background: '#044'}
     content_D: |
       $name;
   E:
     _D: |
       Sw B/D;
 - K: Emb #c
   Z:
      color: rgba(255,200,200,0.4)
      font-size: 200%
      position: absolute
      left: -1em
      top: -7px
      flit:
        blur: 6px
   S:
      content_D: |
        ui.K
 - K: Codlue #c
   S:
     content_D: |
       return w $ui print if ui.K =~ /File|Do|Ghost/;
       
       my $pri = lc ui.K;
       my $db = {%{ui.B}};
       my $s = ui.K;
       $s .= "(".gpty($_).")" for grep{defined} delete $db->{$pri};
       if (defined db.name) {
           $s .= "(db.name)";
           $db = {};
       }
       delete $db->{ui.Li.i.K};
       $s .= ki($db) if %$db && S.q < 3;
       return $s;
 - K: D #c
   Gw: 1
   S:
     styles: -te tu
R:
 - K: sur
   findway: R_sur
     
P:
 - GAK: U #c
   InC:
       W:
         Ss: [u, x, X]
         S:
           styles: OxO z NZ
         Z:
           overflow-y: scroll
       M:
         S:
           styles: OxO
       ux:
         spawn: []
 - GAK: D #c
   InC:
       W:
         Ss: [u, x, X]
         S:
           styles: OxO z NZ
         Z:
           background-color: black
       M:
         S:
           styles: OxO
       ux:
         spawn: []
P_sud:
 - Do code: waylay code;
 - Do uxd: w uxd;
 - Do H: say "Garble";
 - Do r: H.G w reexec;
 - Do Ü¤: $H->pub('S/hut/o', 'reextet');
 - Do tidy: $H->pub('S/hut/o', 'Hiwtidy');
 - Do Otile:  $H->pub('S/hut/O', 'retile');
 - Do Zr: $H->pub('S/hut/Z', 'reexec');
 - Do Or: $H->pub('S/hut/O', 'reexec');
 - Do Cr: $H->pub('S/hut/C', 'reexec');
 - Do Sr: $H->pub('S/hut/S', 'reexec');
 - Do D: w makeD;
hooks:
  D:
    print: |
        "S.K S.name";
    S: 
      content_D: | 
        w G.theR S[$S, $u];
      ishtml: 1
    E:
      _D: |
        G.theD = $S;
        sayyl "To ".$S->pi;
        w G.theR E[$S, $e];
    flows_D: |
      w G.theR setup[$S];
  fresh_init: |
    w ikey;
    G.TV = {};
    G.R->phat(G.TV);
  any_init: |
    my $js = " return {el:elvis, x: screen.width, y: screen.height} ";
    my $cb = sub { saygr wdump(2,shift) };
    H.G w jaw[$js, $cb];
    $H->pub('S/hut/O', 'retile');
  recoded_init: |
    w mux;
  
  percolate: |
    G.theR = $G->R('sur');
    w makeD unless G.way =~ /C\/\D/ || w G.R fi(f=>{K=>'D'});
    if (H.name eq 'D') {
        waylay 1 beD;
    }
    w uxd(full=>1);
    waylay jmux(u=>G.theD);
  beD: |
        my $W = K G:U ->K('W');
        W.Z->{'background-color'} = '#fca';
        # TODO # w mux(u=>$W,v=>4);
        w uxd(full=>1);
        w ave(i=>$W);
  makeD: |
    my $name = ar.name || "J".G.Jnumb++;
    my $u = {K=>'D',name=>$name};
    my $D = w G.R fuu[$u]; 
    sayyl "made ++ ".$D->pi;
    G.theD = $D;
    w are;
    $D;
  are: | #c chang->queue U xing
    w makeD(ur=>'f') unless G.theD;
    # TODO # w mux(u=>G.theD, v=>3); # or 2 to up code?
    w chang(u=>G.theD);
    G.theR;
  ikey: | # $G assumes keydo
    H.keydo = sub {
        my $e = shift; 
        my $S = G.theD;
        sayyl "To ".$S->pi;
        w G.theR keys[$e, $S];
    };
  ave: |
    if (ar.Dname) {
        my @Ds = grep {_.K eq 'D' && _.name eq ar.Dname} @{G.R.A.n_C};
        (G.theD) = @Ds;
        sayyl "ave - has ar.Dname - ".G.theD->pi if G.theD;
        sayyl "ave - MAKING ar.Dname" if !G.theD;
        G.theD ||= w makeD(name => ar.Dname);
    }
    my $R = w are;
    ar.S = G.theD;
    if (ar.Sup) {
        $R->dfrom({u=>ar.S, s=>ar.Sup}); # passes moods, anything
    }
    sayyl "ave into: ". join "\t", $G->pi, $R->pi, ar.S->pi, ar.i;
    w $R Sud/in;
  Dave: |
    my $g = G:$K;
    
    saybl "DAVING ar.Dname" for 1..3;
    #return;
    if (!$g) {
        saybl "NOT FOUND G $K";
        ar.way = join ' ', 'C', (ar.way||'C/nv');
        my $P = [{GAK => "$K ar.way"}];
        $g = H.G w percs[$P];
    }
    
    sayre "Okay now Dave is ".$g->pi;
    $g w ave;
  stylekeysort: |
      my @r = sort keys %$d;
      
      if (grep { /^\[/ } @r) { 
          my $by = { map {
              my $p = $_;
              $p =~ s/^\[(\d+)/'['.sprintf('%08d', $1)/e;
              $p => $_
           } @r };
           @r = map { $by->{$_} } sort keys %$by;
      }
      @r
  event: |
    saybl $G->pi." G.K   EEEEEE ".$i->pi;
    w ikey;
    
        G.envsub && do { say "envsub"; delete(G.envsub)->($i); next };
        if (e.S) {
            w $i zoum;
        }
        else {
            w $i E/_D;
        }
  uxd: |
    my $U = K G:U;
    
    my $chi = G.Vu.U;
    G.Vu.U = [];
    my $TV = {%{G.TV.bb}};
    G.R->phat(G.TV);
    
    my $ment = { map{_.id=>1} values %$TV };
    @$chi = grep { !$ment->{_.id} } @$chi;
    if (%$ment) {
        $U w ux[$TV];
        return unless @$chi || ar.full;
    }
    
    saygr "CHi now: ".@$chi;
    G.R->phat(G.TV);
    
    if (!ar.full && $chi && @$chi) {
        @$chi = uniq @$chi;
        return sayyl "iggy uxd" if !@$chi;
        say "ux parti : ".$_->pi for @$chi;
        my $U = K G:U;
        $U w ux(part => $chi);
    }
    else {
        my $full = ar.full ? "FULL":"full";
        saygr "Codon $full uxd";
        0->sing(alluxd => sub {
            sayyl "uxing... G.name G.K";
            my @is = w G.R fi(f=>{});
            saygr "uxing ".$_->pi for @is;
            my $is = \@is;
            $U w ux[$is];
        }, begin => 0.001);
    }
  mux: |
    my $u = ar.u;
    w chang[$u] if $u;
    w jmux;
  jmux: |
    my $D = K G:D;
    my $a = {%$ar};
    my $u = delete a.u;
    my $MR = G.R;
    $D w mux[$MR,$a,$u];
  remux: |
    my $U = K G:U;
    my $a = {%$ar};
    my $u = delete a.u;
    my $MR = G.R;
    $U w remux[$MR,$a,$u];
  chang: |
      die "u.G.name ! " if u.G ne $G;
      saybl "CHANG ".$u->pi;
      my $v = ar.v || 1;
      G.TV.bz->("u.id $v", $u);
      
      push @{G.Vu.U||=[]}, $u if u.G eq $G;
      die "WEIRD u.G.name on u.K " if u.G ne $G;
      #w mux; # is:
      0->sing(uxd => sub { w uxd; }, again=>1);
  unchanged: |
      my ($u) = values %$ar;
      $u = G.theD || die $u if ref $u ne 'C';
      0->accum(G.Vu => ig => $u);

