
C:
 - K: Do #c
   BcS: name D
   S:
     styles: -te
     Z: {background: '#044'}
     content_D: |
       $name;
   E: |
     Sw B/D;
 - K: Emb #c
   Z:
      color: rgba(255,200,200,0.4) 
      font-size: 200%
      position: absolute
      left: -1em 
      top: -7px 
      flit:
        blur: 6px
   S:
      content_D: |
        ui.K
 - K: Codlue #c
   S:
     content_D: |
       return w $ui print if ui.K =~ /File|Do|Ghost/;
       
       my $pri = lc ui.K;
       my $db = {%{ui.B}};
       my $s = ui.K;
       $s .= "(".gpty($_).")" for grep{defined} delete $db->{$pri};
       if (defined db.name) {
           $s .= "(db.name)";
           $db = {};
       }
       delete $db->{ui.Li.i.K};
       $s .= ki($db) if %$db && S.q < 3;
       return $s;
 - K: D #c
   Gw: 1
   S:
     styles: -te tu
 - K: E #c
   S:
     wayout_sendo_D: |
     
Ray:
 - K: sur
   findway: R_sur     
     
P_sud:
 - Do code: waylay code;
 - Do uxd: w uxd;
 - Do H: say "Garble";
 - Do r: H.G w reexec;
 - Do Ü¤: $H->pub('S/hut/o', 'reextet');
 - Do tidy: $H->pub('S/hut/o', 'Hiwtidy');
 - Do Otile:  $H->pub('S/hut/O', 'retile');
 - Do Zr: $H->pub('S/hut/Z', 'reexec');
 - Do Or: $H->pub('S/hut/O', 'reexec');
 - Do Cr: $H->pub('S/hut/C', 'reexec');
 - Do Sr: $H->pub('S/hut/S', 'reexec');
 - Do D: w makeD;
hooks:
  D:
    print: |
        "S.K S.name";
    S: 
      ishtml: 1
      content_D: |
        w G.theR S[$S, $u];
    E:
      _D: |
        G.theD = $S; # funny singu
        sayyl "To ".$S->pi;
        w G.theR E[$S, $e];
    flows_D: |
      w G.theR setup[$S]; # J level
  fresh_init: |
    w ikey;
    H.nosuddendeath = 1;
  humms_D: |
    if (u.A.u_Rnon_C->[0] eq $G) {
        waylay mux(u=>$u);
    } # else G hum avoid cos it must be deep in RNA somewhere
  dies_D: |
    #return if K R:J;
    if (u.A.u_Rnon_C->[0] eq $G) {
        waylay mux(u=>$u);
    }
    #waylay mux(u=>$u);
    sayre "DEAD! $u ".$u->pi;
    
  any_init: |
    #w wtf;
  percolate_R: |
    G.theR = $G->R('sur');
    
  percolate: |
    w makeD unless K D;
    H.swa = sub {
        my $i = @_ > 1 ? [@_] : shift;
        my $Dname = 'J0';
        w Dave[$i,$Dname];
    };
  makeD: |
    my $name = ar.name || "J".G.jumb.Jnumb++; # additively
    my $u = {K=>'D',name=>$name};
    my $D = w G.R fuu[$u]; 
    sayyl "made ++ ".$D->pi;
    G.theD = $D;
    w are;
    $D;
  are: | #c chang->queue U xing
    #w makeD(ur=>'f')
    die unless G.theD;
    # TODO # w mux(u=>G.theD, v=>3); # or 2 to up code?
    # ^ so we can use this to compile code as W
    # in Wl/R::etcetc.lib and some G->w switch or so, autoload?
    w mux(u=>G.theD);
    G.theR;
  ikey: | # $S assumes keyzition
  ave: |
    if (ar.Dname) {
        my @Ds = grep {_.K eq 'D' && _.name eq ar.Dname} @{G.R.A.n_C};
        (G.theD) = @Ds;
        G.theD ? 
        sayyl "ave - has ar.Dname - ".G.theD->pi :
        sayyl "ave - MAKING ar.Dname";
        G.theD ||= w makeD(name => ar.Dname);
    }
    my $R = w are;
    ar.S = G.theD;
    if (ar.Sup) {
        $R->dfrom({u=>ar.S, s=>ar.Sup}); # passes moods, anything
    }
    sayyl "ave into: ". join "\t", $G->pi, $R->pi, ar.S->pi, ar.i;
    w $R Sud/in;
  pv: |
    my $n = ar.n || 1;
    my $name = "RD$n"; # TODO good naming aspect
    sayre "            Daving $name => ".slim(30,30,gp($i));
    my $dg = H.G K G:C;
    my $t = ar.t || '';
    $dg w Dave(K=>"C",Dname=>$name,i=>$i,t=>$t);
              
    
  Dave: |
    my $g = $G;
    saybl "DAVING ar.Dname";
    if (!$g) {
        #ar.way = join ' ', 'C', (ar.way||'C/nv');
        #my $P = [{GAK => "$K ar.way"}];
        #$g = H.G w percs[$P];
    }
    $g w ave;
  stylekeysort: |
      my @r = sort keys %$d;
      
      if (grep { /^\[/ } @r) { 
          my $by = { map {
              my $p = $_;
              $p =~ s/^\[(\d+)/'['.sprintf('%08d', $1)/e;
              $p => $_
           } @r };
           @r = map { $by->{$_} } sort keys %$by;
      }
      @r
  event: |
    return if i.K ne 'D';
    saybl $G->pi." G.K   EEEEEE ".$i->pi;
    w ikey;
    
    return sayre e.type;
    if (e.type eq 'key') {
        my $e = shift; 
        my $S = G.theD;
        sayyl "To ".$S->pi;
        w G.theR keys[$e, $S];
    }
    
        G.envsub && do { say "envsub"; delete(G.envsub)->($i); next };
        if (e.S) {
            w $i zoum;
        }
        else {
            w $i E/_D;
        }
  unchanged: |
      my ($u) = values %$ar;
      $u = G.theD || die $u if ref $u ne 'C';
      0->accum(G.Vu => ig => $u);
  wtf: |
    my $js = " return {el:elvis, x: screen.width, y: screen.height} ";
    my $cb = sub { saygr wdump(2,shift) };
    H.G w jaw[$js, $cb];
    $H->pub('S/hut/O', 'retile');

