name: code
C:

 - K: Do #c
   BcS: name D
   print: |
     $name
   S:
     styles: -te
     Z: {background: '#044'}
   E:
     _D: |
       Sw B/D;
   ux:
     spawn:
       - K: Codlue
 - K: Emb #c
   Z:
      color: rgba(255,200,200,0.4)
      font-size: 200%
      position: absolute
      left: -1em
      top: -7px
      flit:
        blur: 6px
   S:
      content_D: |
        ui.K
 - K: Codlue #c
   S:
     content_D: |
       return w $ui print if ui.K =~ /File|Do|Ghost/;
       
       my $pri = lc ui.K;
       my $db = {%{ui.B}};
       my $s = ui.K;
       $s .= "(".gpty($_).")" for grep{defined} delete $db->{$pri};
       if (defined db.name) {
           $s .= "(db.name)";
           $db = {};
       }
       delete $db->{ui.Li.i.K};
       $s .= ki($db) if %$db && S.q < 3;
       return $s;
 - K: D #c
   flows_D: |
     $R = B.R = $G->R($R||die);
     R.J ||= {
       from => $H,
       trav => "{G{GGs",
     };
     R.S ||= {
         e => 0.6,
     };
   S:
     styles: -te tu
     ishtml: 1
     content_D: | 
       if (B.R) {
         B.m = w vAK/S[$R];
       }
       B.m;
P:
 - K: Do #c
   B:
     name: title
     D: |
        G:Ϡ w grabkeys(GG=>$G);
   flows_D: |
     B.name = "H.style H.name ! open C";
     #$G->wayb(H.G => $S->s(K => "Disc", way => "S/retile", Dish => $S));
 
 - Do Z: |
     G:Ϡ w retile;
 - Do RW: |
       G.O w ux(GG=>$G);
       
 - Do uxd: |
       w uxd;
       
 - Do keon: |
       H.G w z/keon;
       
 - K: D #c sur
   B: 
     R: surfboard
    
 - GAK: U #c
   InC:
           W:
             Ss: [u, x, X]
             S:
               styles: OxO z NZ
               Z: {overflow-y: scroll}
           M:
             S:
               styles: OxO
           ux:
             spawn: []
hooks:
  fresh_init: |
    H.keydo = sub { w key(e=>shift); };
  any_init: |
    
  percolate: |
    w uxd;
  a: |
    my ($k,$etc) = %$ar;
    my ($u) = 0->rei({K=>$k});
    w chang[$u];
    $u;
  key: |
    my $k = e.k;
    my $R = w vAK/are;
    w vAK/key[$R, $k, $e];
  vAK:
    are: |
      my ($u) = 0->rei({K=>'D'});
      w chang[$u];
      u.B.R
    key: |
      sayyl join"  ", ($k) x 13 for 1..4;
      $R->key($k, $e);
      if (e.S) {
          if ($k eq 2) {
              R.stylin = 2;
          }
      }
      
    S: |
      my $html = $R->S; # 4
    

        # 5
        # quick style synapse
        my @rows;
        my $i = 1;
        for my $r (@{R.a.r}) {
            my $lev = G::gp($r->[1]);
            $lev = G::slim(96,80,$lev);
            push @$r, $lev;
            my ($ac, $li, $pi) = @$r;
            $ac =~ s/\s+/ /g;
            
            push @rows,
            join "  ", map { $R->f(@$_) }
                [ black => $ac ],
              [ blue_fs80 => $i++ ],
              [ white_fs120 => $pi ],
        }

        # 6
        # TODO more style synapse rejoins after delib fork exp
        # reflect style injection round corner
        # throw style into ux recipe

        my $title = "= ".$R->f(white_fs150 => G::gp(R.a.i));
        my $Jpi = "@!@".$R->f(white => G::gp(R.J.from))
            ."  ".$R->f(black => R.J.trav);

        my $html = join "\n", $Jpi, $title, @rows;

      # 8
    
       my $lines = split /\n/, $html;
       my $o = 12;
       my $fs;
       if ($lines > $o) {
           $fs = 100 * $o / $lines;
           $fs *= -1 if $fs < 0;
           $fs = "font-size:".$fs."%;";
           sayre "$lines become $fs";
           
       }
       sayre "$lines lines" for 1..5;
       
       qq{<pre style="$fs;background: rgba(80,50,22,0.3);">$html</pre>}
  elvibe: |
    H.G w z/keon;
    
  event: |
    sayyl "Event relating to ".$u->pi;
    0->visTp({L=>$L},'Fun');
    for (1) {
        G.envsub && do { say "envsub"; delete(G.envsub)->($u); next };
        e.S && do { w $u zoum; next };
        w $u E/_D;
        #waylay uxd;
    }
    sw (ar.u) if e.S;
  uxd: |
    return unless G.GG.U;
    my $chi = G.Vu.U;
    G.Vu.U = [];
    if (!ar.full && $chi && @$chi) {
        my @i = uniq grep { defined } map { _.Lo && _.Lo.i } @$chi;
        #sw[i=>@i, U=>@$chi];
        say "part uxd ".@$chi;
        @$chi = uniq grep { defined } @$chi, @i;
        say "abode : ".$_->pi for @i;
        G.GG.U->w('ux', {is => $chi});
    }
    else {
        my @o = 0->scGre({});
        my $full = ar.full ? "FULL":"full";
        saygr "Codon $full uxd";
        0->sing(alluxd => sub { Say "uxing...";
            G.GG.U->w('ux', {Ls=>\@o});
        }, begin => 0.001);
    }
  chang: |
      push @{G.Vu.U||=[]}, $u if u.G eq $G;
      die "WEIRD u.G.name on u.K " if u.G ne $G;
      0->sing(uxd => sub { w uxd; });
    
  v:
    ch: |
      die "V who?";
      w chang;
  T:
    traction: |
      w chang[$u];
recoded_Cways: 1

