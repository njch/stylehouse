name: code
C:
 - K: J #c
   styles: 
   flows_D: |
     S.e = 9 if !defined S.e;
     B.lines = [$H->hitime];
     #my $cm = 0->TafuBl("CodeMirror", {C => $S});
     # cm.Z.padding = "1em";
   
   
 - K: Dos #c
 
 - K: Do #c
   BcS: name D
   print: |
     $name
   S:
     aZ: {background: '#044'}
   E:
     _D: |
       $D->();
   ux:
     spawn:
       - K: Codlue
 - K: Emb #c
   Z:
      color: rgba(255,200,200,0.4)
      font-size: 200%
      position: absolute
      left: -1em
      top: -7px
      flit:
        blur: 6px
   S:
      content_D: |
        ui.K
 - K: Oud #c
   flows_D: |
     # some some
   Codon: |
     0->visTp_TafuBlA({i=>$S}, [Codon => { file => $file }]);
       
 - K: Codlue #c
   S:
     content_D: |
       return w $ui print if ui.K =~ /File|Do|Ghost/;
       
       my $pri = lc ui.K;
       my $db = {%{ui.B}};
       my $s = ui.K;
       $s .= "(".gpty($_).")" for grep{defined} delete $db->{$pri};
       if (defined db.name) {
           $s .= "(db.name)";
           $db = {};
       }
       delete $db->{ui.Li.i.K};
       $s .= ki($db) if %$db && S.q < 3;
       return $s;
 - K: KV #c
   eadu: |
      my @stuff = ("for <h2>".gp($u)."</h2>",
      map {
          my $de = gp($d->{$_});
          qq{$_    <span style="color:white;">$de</span>} 
          }  sort keys %$d);
      B.lines = \@stuff;
      Say "lines ".(0+@stuff);
      return;
      my $t = {};
      for my $k (sort keys %$d) {
          my ($fit) = $k =~ /^(\W\w+)/;
          my $ft = $t->{$fit} ||= 0->TafuB(Code => {fit=>$fit,lines=>[]});
          $G->L($ft, $S);
          my $de = gp($d->{$k});
          my $l = qq{$k    <span style="color:white;">$de</span>} ;
          push @{ft.B.lines}, $l;
      }
      
   some: |
       return join("\n", @{$lines}[0..130]);
   
   ux:
     spawn:
      - K: Codlue
      - K: pre
        S:
          ishtml: 1
          content_D: |
            w $ui some;
           
 - K: D #c
   S:
     ishtml: 1
     content_D: |
       if (B.Dm) {
         B.m = B.Dm->();
         say B.m;
       }
       "S.K <pre>B.m</pre>"
hooks:
  fresh_init: |
    0->GAK(U => G!U);
    0->InjC(G.GG.U => Load(<<''));
         C:
           W:
             Ss: [u, x, X]
           M:
             Z: {background: rgba(100,66,33,0.4), width: 60%, height: 100%, position: absolute}
           ux:
             spawn: []
  recoded_init: |
    delete G.Vu;  
    #w S/duthis;
    
  any_init: |
    G.db = 0;
  vAK: |
    my $j;
    for my $k (@{G.A.n}) {
        $j->{k.i.K}++
    }
    $j = ddump($j);
  S:
    duthis: |
      my $u = ar.u || G.ulast;
      G.ulast = $u; 
      $u = $u;
      my $d = w S/duff[$u];
      w S/ducode[$d, $u];
      
    ducode: |
      my $KV = $G->TafuB(KV => {});
      w $KV eadu[$d, $u];
      
    duff: |
      my $s = $G->dus();
      s.A.oh = 0.2;
      s.G.oh = 1;
      $G->du({i=>$u, s=>$s, e=>2});
  anD: |
    0->TafuB(D=>$ar);
  percolate: |
    w anD(m=>"HI $_") for 1..2;
    w anD(Dm=>sub { w vAK; });
    
    my $Dos = $G->findway("per_Do");
    for my $k (sort keys %$Dos) {
        say "gun $k";
        0->TafuB(Do => {
            name => $k, D => sub { w per_Do/$k; },
        });
    }
    
    w uxd(full=>1);
  per_Do:
    swek: |
      Say "Awaits";
      G.envsub = sub {
        my $u = shift;
        sw[ $u, map { $_->pi } @{u.A.n} ];
      };
      
    du: |
      w S/duthis;
    seek: |
       Say "Awaits";
       G.envsub = sub {
         my $u = shift;
         $u = u.A;
         w S/duthis[$u];
       }
    bake: |
       Say "Awaits";
       G.envsub = sub {
         my $u = shift;
         sw(u.A->path);
         for (@{ u.A.n }) {
             _.styles =~ s/brick8/brick3/ || _.styles =~ s/brick3/brick8/;
         }
       };
    RW: |
       G.O w ux(GG=>$G);
    uxd: |
       w uxd;
    J: |
       for my $j (0->rei({K=>"J"})) {
           0->del($j);
       }
       0->TafuB(J => {});
  event: |
    sayyl "Event relating to ".$u->pi;
    0->visTp({L=>$L},'Fun');
    for (1) {
        G.envsub && do { say "envsub"; delete(G.envsub)->($u); next };
        e.S && do { w $u zoum; next };
        w $u E/_D;
        #waylay uxd;
    }
    sw (ar.u) if e.S;
  uxd: |
    my $chi = G.Vu.U;
    G.Vu.U = [];
    if (!ar.full && $chi && @$chi) {
        my @i = uniq grep { defined } map { _.Lo && _.Lo.i } @$chi;
        #sw[i=>@i, U=>@$chi];
        say "part uxd ".@$chi;
        @$chi = uniq grep { defined } @$chi, @i;
        say "abode : ".$_->pi for @i;
        G.GG.U->w('ux', {is => $chi});
    }
    else {
        my @o = 0->scGre({});
        saygr "Codon full uxd";
        0->sing(alluxd => sub { Say "uxing...";
            G.GG.U->w('ux', {Ls=>\@o});
        }, begin => 0.001);
    }
  chang: |
      push @{G.Vu.U||=[]}, $u if u.G eq $G;
      0->sing(uxd => sub { w uxd; });
    
  v:
    ch: |
      w chang;
  T:
    traction: |
      w v/ch[$u];
recoded_Cways: 1

