name: code
C:
 - K: J #c
   styles: 
   flows_D: |
     S.e = 9 if !defined S.e;
     B.lines = [$H->hitime];
     #my $cm = 0->TafuBl("CodeMirror", {C => $S});
     # cm.Z.padding = "1em";
   
   

 - K: Do #c
   BcS: name D
   print: |
     $name
   S:
     styles: -te
     Z: {background: '#044'}
   E:
     _D: |
       Sw B/D;
   ux:
     spawn:
       - K: Codlue
 - K: Emb #c
   Z:
      color: rgba(255,200,200,0.4)
      font-size: 200%
      position: absolute
      left: -1em
      top: -7px
      flit:
        blur: 6px
   S:
      content_D: |
        ui.K

 - K: Codlue #c
   S:
     content_D: |
       return w $ui print if ui.K =~ /File|Do|Ghost/;
       
       my $pri = lc ui.K;
       my $db = {%{ui.B}};
       my $s = ui.K;
       $s .= "(".gpty($_).")" for grep{defined} delete $db->{$pri};
       if (defined db.name) {
           $s .= "(db.name)";
           $db = {};
       }
       delete $db->{ui.Li.i.K};
       $s .= ki($db) if %$db && S.q < 3;
       return $s;
 - K: KV #c
   eadu: |
      my @stuff = ("for ".gp($u),
      map {
          my $de = gp($d->{$_});
          qq{$_    <span style="color:white;">$de</span>} 
          }  sort keys %$d);
      B.lines = \@stuff;
      Say "lines ".(0+@stuff);
      return;
      my $t = {};
      for my $k (sort keys %$d) {
          my ($fit) = $k =~ /^(\W\w+)/;
          my $ft = $t->{$fit} ||= 0->TafuB(Code => {fit=>$fit,lines=>[]});
          $G->L($ft, $S);
          my $de = gp($d->{$k});
          my $l = qq{$k    <span style="color:white;">$de</span>} ;
          push @{ft.B.lines}, $l;
      }
      
   some: |
       return join("\n", @{$lines}[0..130]);
   
   ux:
     spawn:
      - K: Codlue
      - K: pre
        S:
          ishtml: 1
          content_D: |
            w $ui some;
           
 - K: D #c
   flows_D: |
     B.R = $G->R(B.R||die);
   S:
     styles: -te tu
     ishtml: 1
     content_D: |
       if (B.R) {
         B.m = w vAK[$R];
       }
       "<pre>B.m</pre>"
Rs:
  - K: surfboard
P:
 - K: Do
   B:
     name: title
     D: |
        G:Ï  w grabkeys(GG=>$G);
   flows_D: |
     B.name = "H.style H.name ! open C";
     #$G->wayb(H.G => $S->s(K => "Disc", way => "S/retile", Dish => $S));
     
 - Do RW: |
       G.O w ux(GG=>$G);
       
 - Do uxd: |
       w uxd;
       
 - Do keon: |
       H.G w z/keon;
       
 - K: D
   B: 
     R: surfboard
    
 - GAK: U
   InC:
           W:
             Ss: [u, x, X]
             S:
               styles: OxO z NZ
               Z: {overflow-y: scroll}
           M:
             S:
               styles: OxO
             Z: {background: rgba(80,50,22,1)}
           ux:
             spawn: []
hooks:
  fresh_init: |
    H.keydo = sub { w key(e=>shift); };
  percolate: |
    w uxd;
  a: |
    my ($k,$etc) = %$ar;
    my ($u) = 0->rei({K=>$k});
    w chang[$u];
    $u;
  key: |
    my $k = e.k;
    sayyl join"  ", ($k) x 13 for 1..4;
    
    # call w R/e without $R but with $e for $G->$R hop
    my $D = w a(D=>"");
    my $R = D.B.R;
    say "Found ".$D->pi;
    
    # call w $R key
    $R->key($k);
  vAK: |
    R.J ||= {
        from => $H,
        trav => "{G{GGs",
    };
    R.S ||= {
        e => 0.3,
    };
    
    my $j;
    for my $k (@{G.A.n}) {
        $j->{k.i.K}++
    }
    $j = {};
    
    $R->S;
  elvibe: |
    H.G w z/keon;
    
  event: |
    sayyl "Event relating to ".$u->pi;
    0->visTp({L=>$L},'Fun');
    for (1) {
        G.envsub && do { say "envsub"; delete(G.envsub)->($u); next };
        e.S && do { w $u zoum; next };
        w $u E/_D;
        #waylay uxd;
    }
    sw (ar.u) if e.S;
  uxd: |
    return unless G.GG.U;
    my $chi = G.Vu.U;
    G.Vu.U = [];
    if (!ar.full && $chi && @$chi) {
        my @i = uniq grep { defined } map { _.Lo && _.Lo.i } @$chi;
        #sw[i=>@i, U=>@$chi];
        say "part uxd ".@$chi;
        @$chi = uniq grep { defined } @$chi, @i;
        say "abode : ".$_->pi for @i;
        G.GG.U->w('ux', {is => $chi});
    }
    else {
        my @o = 0->scGre({});
        my $full = ar.full ? "FULL":"full";
        saygr "Codon $full uxd";
        0->sing(alluxd => sub { Say "uxing...";
            G.GG.U->w('ux', {Ls=>\@o});
        }, begin => 0.001);
    }
  chang: |
      push @{G.Vu.U||=[]}, $u if u.G eq $G;
      die "WEIRD u.G.name on u.K " if u.G ne $G;
      0->sing(uxd => sub { w uxd; });
    
  v:
    ch: |
      die "V who?";
      w chang;
  T:
    traction: |
      w chang[$u];
recoded_Cways: 1

