C:
 - K: Con #c waiting for tension

R_Jz:
 - K: ash #c woosh
   n_D:
     life: |
       die;
       sayre "GOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO" for 1..12;
       J.yy.jiter = 'borg';
 - K: afghanrug #c
   n_D:
     mods:
        -
          - afghanrug
          - in: 0.1
            out: 0.9
            thi: 13
          - s:   ஓ୶
            cow: rgb f3a
            mixco: 0.5 582
          - blr: 4
            fs: 152.9
            sat: 1
            bri: 0.3
            con: 3
            sha: 3 3 3 034
            zi: 5
 - K: fiz_ave #c
   n_D:
     mods:
        - 
          - sqww
          - in: 0.001
            out: 0.8
            thi: 28
          - s: ஓ୶
            cow: rgb 155
            mixco: 0.4 300
            zim: 4^v1
          - blr: 5
            sat: 6
            sha: 5 5 5 000
            fs: 141
            ml: -0.1em
 - K: flax #c
   n_D:
     mods:
        - 
          - flax
          - 21
          - s: ॐॐॐॐॐॐ
            cow: rg 86e
            zim: 5^v0.5*2
            mixco: 0.61 050
          - blr: 2
            fs: 54.9 
            #hs: 44.3.4.8
 - K: ocean #c
   n_D:
     mods:
       -
         - ocean-squi
         - 16 # rivm add space every 1/3 so these go @ ~ ~ @ ~ ~ or so
         - s: '~'
         - fs: 24
           zi: 3
       -
         - ocean-eddy
         - 8
         - cow: f33
           #unico: 132
           s: '@'
         - fs: 73
           zi: 2
 - K: oci #c
   n_D:
     mods:
       -
         - ociw
         - 16 # rivm add space every 1/3 so these go @ ~ ~ @ ~ ~ or so
         - s: '|'
           cow: b 127
         - fs: 22 # TODO local zoom...
           co: aaf
           sha: 3 3 5 fff
           opa: 0.5
           zi: 6
 - K: theself #c CURVE domer
   n_D:
     yJup: |
       J.yy.round.id = 3;
       die;
       'theself', 'sur'
     curves: |
         ["spun 0" => 0.025], 
         ["curve 1" => 0.211],
         ["zoom 0" => 0.35],
         ["zoom 0.21" => 0.45],
         ["y 0" => 0],
         ["x 0" => 0.8],
         ["x 0.1" => 0.7],
         ["curve 0.3" => -0.111],
         
     mods: |
       [sq   => 10,  '~'],
       #[sqat   => 20,  '^', {}, 'color:blue', in => 10, ],
       #[sqat   => 20,  'v', {}, 'color:blue', out => 10, ],


 - K: ii/Jhead #c J _
   D: |
       my $at = ar.out || 0.01;
       
       my $oM = [];
       
       Rw mi $m:_ $oM for
          ['J', '', {pwth=>'hull/mk:Jself',fo=>[$J,0.1]}];
       Rw the + Jhead $oM;
       
       my $d = Rw om/lev $J $oM Jhead $at;
       say "JHead scoop: ".wdump 4, $d;
       # make lev: Jhead $at 
       Rw yo + $d;
 - K: ii/ornate #c arabic ornate parenthesis
   D: |
       my $gl = ar.out ? '﴿' : '﴾';
       my $at = ar.out || ar.in || 0.01;
       my $d;
       d.t = 'ornate';
       d.y.at = $at;
       d.c.s = $gl;
       d.sc = {qw{ fs 230   hs 4.3.7.5   zip 3   blr 5   zi 3   rad 1}};
       # 3
       # detect $M and upload, or return $d hoping for a mod stick outside?
       Rw yo + $d;
 - K: ii/cap #c ha zom
   D: |
     
       my ($vli) = grep{_.style eq 'traveli'} @{rr.sjs};
       my $M = [
           ['_', '', {s=>rr.j.l}, {fs=>18, co=>'38f'}],
           ['=','', {}, {fs=>12,co=>'000'}],
           ['i', 'sur/to:/', {fo=>[vli.s,0.1]}],
       ];
       my ($vly) = grep{_.style eq 'travely'} @{rr.sjs};
       if ($vly && @{vly.s}) {
           my $s = " ".join(" ",@{vly.s})." ";
           push @$M,
               ['travely', '', {s=>$s, wsp=>1}],
               ['S', '', {fo=>[rr.j.s, 0.2]}],
       }   
       # ^ all that within v
       
       my $d = Rw om/lev $oM:M cap;
       return $d;
       my $lev = sub {
           my $J2 = shift;
           Rw mo/pwth $J:J2 $M 0.1-0.3; 
       };
       ['cap','', {lev=>$lev}]
 - K: ii/bod #c boodle am   labegy ( pi
   D: |
       my $in = rr.in; # TODO whereto?
       my $out = rr.out;
       my $phi = ($out - $in) * rr.thi; # normal lines per 0.1
       my $thi = $phi * 2; # oundo big window, bod small
       
       my $j = rr.j;
       my $sjs = rr.sjs;
       my $u = j.s;
       say "bod $in <--> $out  $thi     j.r"; # TODO say big
       
       # how to what = @{rr.sjs}
       my $o = Rw oundo $thi $u;
       
       warn "More o.more" if o.more;
       my @M;
       for my $r (@{o.r}) {
           my $M = [];
           
           # SZOOOOOOOOOOOM
           push @$M, Rw ii/labegy $r;
           
           push @$M, Rw ii/pi $r;
           
           my $c;
           c.path = r.path;
           my $d = Rw om/lev $oM:M $t:r.r $c;
           push @M, $d;
           next;
           
           my $lev = sub {
               my $J2 = shift;
               my $q = 1;
               Rw mo/pwth $J:J2 $M 0.1-0.3 $q;
               # chain that ^ into c of that v to fractionate by 0
               # pyramoid the tape nice by this chaining
           };
           
           push @M, [r.r, r.path, {lev=>$lev}];
       }
       @M
 - K: ii/labegy #c suitcase handle
   D: |
        # TODO add a style that colours it after round
        # TODO curve
        # TODO shared labels
        # TODO culture
        # TODO unwind cv into colours variously
        # TODO make a tiny maka thing for $k decor, tiny styled tags
        my ($c,$sc);
        
        c.s = r.r;
        
        sc.ws = 'p';
        sc.ab = 'right:0.5em';
        
        my $si = length(r.r);
        my $curve = {qw{
        40 60
        30 70
        20 80
        }};
        for (sort keys %$curve) {
            sc.fs = $curve->{$_} if $si > $_
        }
        # $Magnetise
        {t=>'lab', '', $c, $sc}
 - K: ii/pi #c THE WHOLE GHUTS
   D: |
       my ($c,$sc);
       
       c.fo = [r.s, 0.6];
       c.path = r.path;
       
       sc.ws = 'n';
       sc.ab = 'left:1em';
       sc.mw = '14em';
       sc.over = 'hidden';
       
       {t=>'pi', '', $c, $sc}

