R_Jz:
 - K: pipathg #c sticks pi/$y || finds a stick
   D: |
     my $u = J.u;
     die if J.wa;
     my $wa = J.y || do {
         J.c = $R->cgp($u);
         # ^
         
         # v
         my ($wa) = grep { J.c->{$_} } qw'canpi ARRAY HASH ref undef text';
         $wa = ref $u if $wa eq 'canpi';
         $wa ||= 'wtf';
         $wa;
     };
     # can stick $wa on J.wa for thrashing maths
     # funcy fuzz fields
     # mutating spiral code
     my $way;
     for my $try ("pi/$wa", "$wa/pi") {
         my $m = [$try];
         $way = $try if Rw wuck $m;
     }
     
     $way || die "not $wa equip anywhere"; # more
     $way
     

 - K: mkJid #c
   D: |
     J.isJid = J.replaceJid || $H->mkuid;
     Rw idyl $J $id:J.isJid;
 - K: idyl #c some fistful of Js for event
   D: |
     my $yl = J.Jmost.idly->{$id} = {};
     yl.J = $J;
     yl.j = ar.j if ar.j;
 - K: forkpi #c whias
   spesh: 1
   spesh_D: |
     H.name eq "O" || $DB::sub # perl -dw cannot fork # websockets cannot fork?
   babz:
        'gp 2.5': |
            if (J.cv > 0.2 && !J.replaceJid && !J.q) {
                my $la = {%$J};
                la.replaceJid = J.isJid; #$H->mkuid;
                push @{G.jumb.forkpis ||= []}, $la;
                J.forking = $la;
                J.cv = 0.1;
            }
        'spit 8.8': |
            if (my $pias = delete G.jumb.forkpis) {
                # these could be forked right away
                # if they can wait for the M muxing J if they reach O first
                die;
                $G->timer(0, sub {
                    Rw forkpi/pias $J $pias;
                });
            }
        'gp 7.1': |
            J.forking.wash = $H->dig(J.s) if J.forking;
        'spit 2.88': |
            kill 'KILL', $_ for @{delete G.forkpi_tokill || []};
   n_D:
        pias: |
            if (my $pid = fork()) {
                my $Sftk = G.forkpi_tokill ||= [];
                push @$Sftk, $pid;
                return
            }
            H.forked = H.isforked = 1;
            # able to report error
            # not EV reaction in the child, handles confused
            # must exit so nothing else can happen
            
            my $bail = sub{ kill 'KILL', $$; exit };
            
            $G->accum($G0, _aft_err_do => $bail);
            $G->accum($F[0], _aft_etc_do => $bail);
            
            sayyl "pier Forked... ";
            
            my @js;
            my $group = 3;
            for my $a (@$pias) {
                a.replaceJid || do {
                    warn "Jid missing... ". gp($a)
                    ."\n".gp(a.u)."\nJiter: ".gp a.Jiter;
                    next;
                };
                Rw gp $J:a;
                my $html = a.s;
                next if a.wash eq $H->dig($html);
                my $set = ejson($html);
                my $id = a.replaceJid || die wdump(2,$a);
                my $js = qq{ \$('#$id').replaceWith($set);};
                push @js, $js;
                if (@js >= $group) {
                    $H->send(join('', @js));
                    @js = ();
                }
            }
            $H->send(join '', @js) if @js;
            saygr "pier done ".F_delta;
            
 - K: gp #c R_sur gp gone
   babz:
     'suJ 3.1': |
       # another little con tent, backeting a harmonic sur-ish portal
       J.fro = $by->(sub {
           my $j = shift;
           j.u = delete j.s;
           j.cv = shift @{j.etc};
           %$j = (%$j, %{delete j.cv}) if ref j.cv;
           Rw gp $J:j;
       });
   D: |
     G.jumb.gp_inarow++;
     die "Wwas";
     aft { G.jumb.gp_inarow-- };
     J.cv = 0.1 if J.cv < 0.1;
     J.bz->("/\t0.9" => "yep");
     # 2
     J.isJid = J.replaceJid || $H->mkuid;
     undef J.isJid if G.jumb.gp_inarow > 1;
     J.idyl->($J, J.isJid) if J.isJid;
     # 3
     
     # TODO J pass over # maka suction
     # don't need to close it up right now...
     # top down injection gos
     
     my $u = J.u;
     my $wa = J.wa || do {
         J.c = $R->cgp($u);
         # ^
         
         # v
         my ($wa) = grep { J.c->{$_} } qw'canpi ARRAY HASH ref undef text';
         $wa = ref $u if $wa eq 'canpi';
         $wa ||= 'wtf';
         $wa;
     };
     # can stick $wa on J.wa for thrashing maths
     # funcy fuzz fields
     # mutating spiral code
     
     R.way->find("pi/$wa") || die "not $wa equip"; # more
     
     # 5 forking swivel injecty redis, etc etc
     # set up more consciously the stylepliers of 5

     # 6
     Rw pi/$wa $J $u;
     
     # next floatation device...
         for my $k (%{J.bb}) {
             if ($k =~ /^(\S*(?:oB|Bo|Bi|Bs))\s+(.+)$/) {
                 J.bb->{"$1\%css#maka25\t$2"} = "color:black";
             }
             if ($k =~ /^thi\s+(.+)$/) {
                 J.bb->{"thi\%css#maka25\t$1"} = "text-decoration:underline";
             }
             if ($k =~ /^name\s+(.+)$/) {
                 J.bb->{"name\%css#maka25\t$1"} = "color:#f93;";
             }
             if ($k =~ /^K\s+(.+)$/) {
                 J.bb->{"K%css#maka25\t$1"} = "color:#3f3";
             }
         }
     
     # 7
     J.s = Rw maka $J $u;
     # can pin/ping light source of con
     
     # 8
     
     # 9
     J.Jiter.bz->(J.r => J.s,    '%gp' => $J,    @{J.etc});
     
 - K: fom #c fractal of arg unpack for arrayish c.pi? u (not thing), cv (not thi), y->piway or $c
   D: |
     my $cs = ar.cs || ar.m;
     my $o = Rw pul $cs u cv{+} y;
     if (my $J = ar.J) {
         %$o = (%$J, %$o);
     }
     $o;
     # PLACE ON TOP: 
     my $o = {};
     warn "foing d.r d.s";
     if (ref $cs eq 'ARRAY') {
         my $zero = 0;
         $o = Rw fom $cs $J:zero;
     }
     else {
         %$o = %$cs;
     }
     
 - K: lplumb #c abomdin, a level, subby plumbing, tin gplumb
   babz:
     'suJ 3.2': |
       J.lev = $by->(sub {
           my $j = shift;
           j.sub = delete j.s;
           Rw lplumb $J:j;
       });
   D: |
     J.bz->("/\t0.9" => "yep");
     J.isJid = J.replaceJid || $H->mkuid;
     J.idyl->($J, J.isJid) if J.isJid;
     
     J.sub->($J);
     J.s = Rw maka $a:J;
     J.Jiter.bz->(J.r => J.s,
         '%lp' => $J,
         @{J.etc},
     );
 - K: forkin #c stick fork in
   babz:
     'spit 2.89': |
       kill 'KILL', $_ for @{delete J.fopikil || []};
     'spit 8.9': | # forking
       if (%{J.fopi||{}}) {
           my $Js = [values %{delete J.fopi}];
           Rw foping $J $Js;
       }
     'foping 2': |
       if (my $pid = fork()) {
           push @{J.fopikil||=[]}, $pid;
           return
       }
       H.forked = H.forking = H.isforked = 1;
       my $bail = sub{ kill 'KILL', $$; exit };
       $G->accum($G0, _aft_err_do => $bail);
       $G->accum($F[0], _aft_etc_do => $bail);
       # able to report error
       # not EV reaction in the child, handles confused
       # must exit so nothing else can happen
 - K: fopi #c enqueue/shadow-
   babz:
     'suJ 3.5': |
       # to put something off til forking
       # so false when in shadow
       J.fop = $by->(sub { # a little J (pi) 
           return 1 if H.forking;
           Rw fopi $J;
           return 0;
       });
   D: |
     J.isJid ||= Rw mkJid $J;
     J.Jmost.fopi->{J.isJid} = $J;
     # these could be forked right away
     # if they can wait for the M muxing J if they reach O first
     # graphable evens it
 - K: foping #c carbon coopy of pi 4 # could be a global wag jaw, Js swim
   D: |
     say @$Js." fops, forking for: ".gp($J);
     # 3 after the gguts from forkin
     saybl "   Forked... ";
     
     # little qv teether, batch for finer grained things, timely
     my @js;
     my $group = 3;
     for my $cs (@$Js) {
         
         Rw pir $cs;
         
         cs.s = Rw maka $J:cs;
         
         cs.isJid || die 'noJid'.wdump 2,$cs;
         
         push @js, sprintf " \$('#%s').replaceWith(%s);",
             cs.isJid, ejson(cs.s);
         
         if (@js >= $group) {
             $H->send(join('', @js));
             @js = ();
         }
      }
      $H->send(join '', @js) if @js;
      
      saybl "  d...";
 - K: pir #c
   D: |
     cs.yg = Rw pipathg $J:cs;
     
     Rw cs.yg $J:cs $u:cs.u;
     
     Rw oldschool $J:cs;
mod c:
 - K: s #c d.c.s -> d.s
   mod 3.1: |
     d.s = $cs;
 - K: pi #c modulapi
   mod#pi 3.3: | #c
     ref $cs && die wdump $cs;
     my $y = $cs;
     $cs = d.c.pi = Rw spinash $J;
     cs.y = $y;
     cs.d = $d;
     cs.most->{$_} = cs.d.g->{$_} for keys %{cs.d.g||{}};
     # be adjusting this:
     cs.r = cs.d.r;
     Rw mkJid $J:cs;
     cs.bz->("/ 0.9" => "y");
   mod#pi 3.4: | #c
     cs.cv = d.c.gp.cv || 0.6;
     cs.u = d.s;
     die'csnod' if cs.d ne $d;
     
     Rw pir $cs;
   mod#pi 3.5: | #c
   mod#pi 3.7: | #c
     # can pin/ping light source of con
     cs.s = Rw maka $J:cs;
     d.s = cs.s;
     #sayyl "itlbe: ".slim 130, d.s;
     d.cs.pi.pi = $cs;
   mod#pi 3.8: | #c fork... when mod swivels its nice.
esc c:
 - K: pi #c ag
   esc 3.5: |
     die if !v.r;
     '%gp' => $v 
 - K: oldschool #c GOPING
   D: |
     # next floatation device...
         for my $k (%{J.bb}) {
             if ($k =~ /^(\S*(?:oB|Bo|Bi|Bs))\s+(.+)$/) {
                 J.bb->{"$1\%css#maka25\t$2"} = "color:black";
             }
             if ($k =~ /^thi\s+(.+)$/) {
                 J.bb->{"thi\%css#maka25\t$1"} = "text-decoration:underline";
             }
             if ($k =~ /^name\s+(.+)$/) {
                 J.bb->{"name\%css#maka25\t$1"} = "color:#f93;";
             }
             if ($k =~ /^K\s+(.+)$/) {
                 J.bb->{"K%css#maka25\t$1"} = "color:#3f3";
             }
         }

