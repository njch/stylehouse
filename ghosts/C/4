R_Jz:
 - K: pipathg #c sticks pi/$y || finds a stick
   D: |
     my $u = J.u;
     die if J.wa;
     my $wa = J.y || do {
         J.c = $R->cgp($u);
         # ^
         
         # v
         my ($wa) = grep { J.c->{$_} } qw'canpi ARRAY HASH ref undef text';
         $wa = ref $u if $wa eq 'canpi';
         $wa ||= 'wtf';
         $wa;
     };
     # can stick $wa on J.wa for thrashing maths
     # funcy fuzz fields
     # mutating spiral code
     my $way;
     for my $try ("pi/$wa", "$wa/pi") {
         my $m = [$try];
         $way = $try if Rw wuck $m;
     }
     
     $way || die "not $wa equip anywhere"; # more
     $way
     

 - K: mkJid #c
   D: |
     J.isJid = J.replaceJid || $H->mkuid;
     Rw idyl $J $id:J.isJid;
 - K: idyl #c some fistful of Js for event
   D: |
     my $yl = J.Jmost.idly->{$id} = {};
     yl.J = $J;
     yl.j = ar.j if ar.j;

 - K: lplumb #c abomdin, a level, subby plumbing, tin gplumb
   babz:
     'suJ 3.2': |
       J.lev = $by->(sub {
           my $j = shift;
           j.sub = delete j.s;
           Rw lplumb $J:j;
       });
   D: |
     J.bz->("/\t0.9" => "yep");
     J.isJid = J.replaceJid || $H->mkuid;
     J.idyl->($J, J.isJid) if J.isJid;
     
     J.sub->($J);
     J.s = Rw maka $a:J;
     J.Jiter.bz->(J.r => J.s,
         '%lp' => $J,
         @{J.etc},
     );
 - K: forkin #c stick fork in
   babz:
     'spit 2.89': |
       kill 'KILL', $_ for @{delete J.fopikil || []};
     'spit 8.9': | # forking
       if (%{J.fopi||{}}) {
           my $Js = [values %{delete J.fopi}];
           Rw foping $J $Js;
       }
     'foping 2': |
       if (my $pid = fork()) {
           push @{J.fopikil||=[]}, $pid;
           return
       }
       H.forked = H.forking = H.isforked = 1;
       my $bail = sub{ kill 'KILL', $$; exit };
       $G->accum($G0, _aft_err_do => $bail);
       $G->accum($F[0], _aft_etc_do => $bail);
       # able to report error
       # not EV reaction in the child, handles confused
       # must exit so nothing else can happen
 - K: fopi #c enqueue/shadow-
   babz:
     'suJ 3.5': |
       # to put something off til forking
       # so false when in shadow
       J.fop = $by->(sub { # a little J (pi) 
           return 1 if H.forking;
           Rw fopi $J;
           return 0;
       });
   D: |
     J.isJid ||= Rw mkJid $J;
     J.Jmost.fopi->{J.isJid} = $J;
     # these could be forked right away
     # if they can wait for the M muxing J if they reach O first
     # graphable evens it
 - K: foping #c carbon coopy of pi 4 # could be a global wag jaw, Js swim
   D: |
     say @$Js." fops, forking for: ".gp($J);
     # 3 after the gguts from forkin
     saybl "   Forked... ";
     
     # little qv teether, batch for finer grained things, timely
     my @js;
     my $group = 3;
     for my $cs (@$Js) {
         
         Rw pir $cs;
         
         cs.s = Rw maka $J:cs;
         
         cs.isJid || die 'noJid'.wdump 2,$cs;
         
         push @js, sprintf " \$('#%s').replaceWith(%s);",
             cs.isJid, ejson(cs.s);
         
         if (@js >= $group) {
             $H->send(join('', @js));
             @js = ();
         }
      }
      $H->send(join '', @js) if @js;
      
      saybl "  d...";
 - K: pir #c
   D: |
     cs.yg = Rw pipathg $J:cs;
     
     Rw cs.yg $J:cs $u:cs.u;
     
     Rw oldschool $J:cs;
mod c:
 - K: s #c d.c.s -> d.s
   mod 3.1: |
     d.s = $cs;
 - K: pi #c modulapi
   not: |
     fractal of arg unpack for arrayish c.pi?
     u (not thing), cv (not thi), y->piway or $c
     
   mod#pi 3.3: | #c
     ref $cs && die wdump $cs;
     my $y = $cs;
     $cs = d.c.pi = Rw spinash $J;
     cs.y = $y;
     cs.d = $d;
     cs.most->{$_} = cs.d.g->{$_} for keys %{cs.d.g||{}};
     # be adjusting this:
     cs.r = cs.d.r;
     Rw mkJid $J:cs;
     cs.bz->("/ 0.9" => "y");
   mod#pi 3.4: | #c
     cs.cv = d.c.gp.cv || 0.6;
     cs.u = d.s;
     die'csnod' if cs.d ne $d;
     
     Rw pir $cs;
   mod#pi 3.5: | #c
   mod#pi 3.7: | #c
     # can pin/ping light source of con
     cs.s = Rw maka $J:cs;
     d.s = cs.s;
     #sayyl "itlbe: ".slim 130, d.s;
     d.cs.pi.pi = $cs;
   mod#pi 3.8: | #c fork... when mod swivels its nice.
esc c:
 - K: pi #c ag
   esc 3.5: |
     die if !v.r;
     '%gp' => $v 
 - K: oldschool #c GOPING
   D: |
     # next floatation device...
         for my $k (%{J.bb}) {
             if ($k =~ /^(\S*(?:oB|Bo|Bi|Bs))\s+(.+)$/) {
                 J.bb->{"$1\%css#maka25\t$2"} = "color:black";
             }
             if ($k =~ /^thi\s+(.+)$/) {
                 J.bb->{"thi\%css#maka25\t$1"} = "text-decoration:underline";
             }
             if ($k =~ /^name\s+(.+)$/) {
                 J.bb->{"name\%css#maka25\t$1"} = "color:#f93;";
             }
             if ($k =~ /^K\s+(.+)$/) {
                 J.bb->{"K%css#maka25\t$1"} = "color:#3f3";
             }
         }

