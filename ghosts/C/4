R_Jz:
 - K: lplumb #ctin gplumb om din, level sub
   D: |
     J.bz->("/\t0.9" => "yep");
     die J.id if J.id;
     J.id = mkuid;
     J.idyl->($J, J.id) if J.id;
     
     J.sub->($J);
     J.s = Rw maka $a:J;
     J.Jiter.bz->(J.r => J.s,
         '%lp' => $J,
         @{J.etc},
     );
 - K: suJ #c bbdomining for any sorta J
   D: |
     J.bb = {};
     J.ord = [];
     J.phy = {};
     J.phl = {};
     
     J.idyl = sub { #c
         my ($J, $id, $oj) = @_;
         J.most.J.idly->{$id} = {J=>$J, j=>$oj};
     };
     J.lev = sub { #c
         die wdump [@_]; 
         my $j = Rw spinash $J;
         j.r = shift;
         # this is a tent it is
         j.sub = shift;
         Rw lplumb $J:j;
     };
     J.fop = sub { #c a little J (pi)
         return 1 if H.forking;
         Rw fopi $J;
         return 0;
     };
     J.no = J.n = sub { #c a little J (pi)
         my $m = [@_];
         Rw Mno $m;
     };
     
     my $j = {};
     J.bz = sub { #c
           my $j = {%$j};
           my $ad = [@_];
           my %j = %$j;
           while (@$ad) {
               my ($k, $v) = (shift @$ad, shift @$ad);
               
               my $comp = $k =~ /^(%|\+)/;
               my $j = {%j} if $comp;
               if ($comp) {
                   $k =~ s/^\+// if $comp;
                   j.t .= $k if $comp;
               }
               else {
                   (j.t, j.cv) = $k =~ /^(.+)\s+(.+?)$/;
                   %j = %$j;
               }
               defined j.cv || die "NOSEYV: j.cv".wdump($j);
               j.r = j.t."\t".j.cv;
               j.s = $v;
               
               my @Js = $J;
               push @Js, values %{J.phy} if J.phy;
               for my $jj (@Js) {
                   jj.bb->{j.r} = j.s;
                   push @{jj.ord}, {%$j} if jj.ord;
                   jj.tim->{j.r} = hitime() if jj.tim;
                   jj.wtf->{j.r} = $F[0] if jj.wtf;
               }
           }
           wantarray ? ($j, 
               sub{J.bz->(%$j, @_)} # TODO fucked, get some weed and fix it
           ) : $j
     };
 - K: pipathg #c sticks pi/$y || finds a stick
   D: |
     my $u = J.u;
     die if J.wa;
     my $wa = J.y || do {
         J.c = $G->cgp($u);
         # ^
         
         # v
         my ($wa) = grep { J.c->{$_} } qw'canpi ARRAY HASH ref undef text';
         $wa = ref $u if $wa eq 'canpi';
         $wa ||= 'wtf';
         $wa = 'J' if $wa eq 'HASH' && u.bb;
         $wa;
     };
     # can stick $wa on J.wa for thrashing maths
     # funcy fuzz fields
     # mutating spiral code
     my $way;
     for my $try ("pi/$wa", "$wa/pi") {
         my $m = [$try];
         my $t = Rw wuck $m;
         $way = $try if $t;
         last if $way;
     }
     
     $way || die "not $wa equip anywhere"; # more
     $way
     
 - K: mkJid #c
   D: |
     J.id = mkuid;
     Rw idyl $J $id:J.id;
 - K: idyl #c some fistful of Js for event
   D: |
     my $yl = J.most.J.idly->{$id} = {};
     yl.J = $J;
     yl.j = ar.j if ar.j;
 - K: forkin #c stick fork in
   n_D:
     spit_ret: |
       kill 'KILL', $_ for @{delete J.fopikil || []};
     spit_post: |
       if (%{J.fopi||{}}) {
           my $Js = [values %{delete J.fopi}];
           Rw foping $J $Js;
       }
 - K: fopi #c enqueue/shadow- # suJ J.fop -> here
   D: |
     J.id ||
     Rw mkJid $J;
     J.most.J.fopi->{J.id} = $J;
     # these could be forked right away
     # if they can wait for the M muxing J if they reach O first
     # graphable evens it

 - K: foping #c carbon coopy of pi 4 # could be a global wag jaw, Js swim
   D: |
     say @$Js." fops, forking for: ".gp($J);
     
       if (my $pid = fork()) {
           push @{J.fopikil||=[]}, $pid;
           return
       }
       H.forked = H.forking = H.isforked = 1;
       my $bail = sub{ kill 'KILL', $$; exit };
       acum $G, _aft_err_do => $bail;
       acum $F[0], _aft_etc_do => $bail;
       # able to report error
       # not EV reaction in the child, handles confused
       # must exit so nothing else can happen
       
     # 3 after the gguts from forkin
     saybl "   Forked... ";
     
     # little qv teether, batch for finer grained things, timely
     my @js;
     my $group = 3;
     for my $cs (@$Js) {
         
         Rw pir $cs;
         
         cs.s = Rw maka $J:cs;
         
         cs.id || die 'noJid'.wdump 2,$cs;
         
         push @js, sprintf " \$('#%s').replaceWith(%s);",
             cs.id, ejson(cs.s);
         
         if (@js >= $group) {
             $H->send(join('', @js));
             @js = ();
         }
      }
      $H->send(join '', @js) if @js;
      
      saybl "  d...";
 - K: pir #c pi J trio centered: figure pi g (J.yg), do pi/J.yg, 1-d pattern recog
   D: |
     J.yg = Rw pipathg $J;
     
     Rw J.yg $J $u:J.u $C:J.d;
     
     Rw oldschool $J;
 - K: oldschool #c GOPING
   D: |
     # next floatation device...
     for (%{J.bb}) {
         J.bb->{"$1\%css#maka25\t$2"} = "color:black"
             if /^(\S*(?:oB|Bo|Bi|Bs))\s+(.+)$/;
         J.bb->{"thi\%css#maka25\t$1"} = "text-decoration:underline"
             if /^thi\s+(.+)$/;
         J.bb->{"name\%css#maka25\t$1"} = "color:#f93;"
             if /^name\s+(.+)$/;
         J.bb->{"K%css#maka25\t$1"} = "color:#3f3"
             if /^K\s+(.+)$/;
     }
C mod#pi:
 -
  - pi #c modulapi
  - 3.3
  - |
     ref $cs && die wdump $cs;
     my $y = $cs;
     $cs = d.c.pi = Rw spinash $J;
     cs.y = $y;
     cs.d = $d;
     cs.most->{$_} = cs.d.g->{$_} for keys %{cs.d.g||{}};
     # be adjusting this:
     cs.r = cs.d.r;
     Rw mkJid $J:cs;
     cs.bz->("/\t0.9" => "y");
 -
  - pi #c modulapi
  - 3.4
  - |
     cs.cv = d.c.gp.cv || d.c.cv || 0.6;
     cs.u = d.s;
     die'csnod' if cs.d ne $d;
     
     Rw pir $cs;
 -
  - pi #c
  - 3.7
  - |
     # can pin/ping light source of con
     cs.s = Rw maka $J:cs;
     d.s = cs.s;
     #sayyl "itlbe: ".slim 130, d.s;
     d.cs.pi.pi = $cs;
 -
  - pi #c fork... when mod swivels its nice.
  - 3.8
  - |
    # koobla
 -
  - pwth #c -> !some/path exp. 8ery, 8ing
  - 3.1
  - |
     my $path = $cs;
     $path = "!$path" unless $path =~ /^\W/;
     c.path && die;
     c.path = $path;
     
 -
  - path #c install cs path
  - 3.2
  - |
     d.cs.pwth.path = $cs;
     d.cs.pwth.idly = 1 unless c.fo; # will prov
     d.cs.pwth.tt = "$cs";
     # later style %idly when %path but no /%id
 -
  - pwar #c take $ar cs path
  - 3.2
  - |
     d.cs.pwar.pwar = $cs;
 -
  - id #
  - 3
  - |
    d.cs.id.id = $cs;
 -
  - J #c
  - 3
  - |
     d.cs.J.J = $cs;
     
C esc:
 -
  - pi #c ag
  - 3.5
  - |
     die if !v.r;
     '%gp' => $v 
 -
  - pwar #
  - 3
  - |
     '%pwar'=>$v
 -
  - path #
  - 3
  - |
     '%path'=>$v
 -
  - idly #
  - 3
  - |
     '%idly'=>$v
 -
  - id #
  - 3
  - |
     '%id'=>$v
 -
  - J #
  - 3
  - |
     '%J'=>$v

