name: code
dials: { thuxrw => 1 }
GG:
 - K: xC
   way: T/ux
   In:
     C:
       W:
         Ss: [u, x, X]
       M:
         Ss: [oud]
         Z: {background: rgba(0,100,50,0.4), overflow: scroll, width: 30%, height: 100%, position: absolute}
       ux:
         styles: tc
         spawn:
           - K: Codw
S:
 - K: oud #c sidecar
   Ss:
    - K: CodeMirror
      css:
        - height:auto
    - K: codwide
      css:
        - width:30%
    - K: tc
      css: 
        - border-bottom:1px solid black
        - padding-left:2em
        - float:left
        - position:relative
        - width:calc(100% - 2em)
        - background:rgba(150,100,50,0.1)
    - K: nonpadl
      css:
        - padding-left:0em
C:
 - K: Sources
   styles: -tc
   S:
     Z:
       width: 20em
   travels_D: |
     0->TafuBl(Dir => {dir => "/s"});
   
 - K: Dir
   flows_D: |
     S.name = "dir=$dir";
   travels_D: |
     my @finds = map { 0->fs_glob($_) } "$dir/style*", "$dir/not";
     push @finds,  map { 0->fs_find($_) } "$dir/ghosts";
     @finds = grep { !/T|H|L/ } @finds;
     for my $file (@finds) {
         0->TafuBl(File => { file => $file });
     }
 
 - K: File
   flows_D: |
     $G->timer(0.1, sub { Sw E/_D; w uxd; }) if $file =~ /Ï /;
   E:
     _D: |
       Say "In Eveent S.K $file";
       my $ou = 0->TafuB(Oud => { oud => S.Lo.i }); # of Dir or so
       w $ou Codon[$file];
       
 - K: Oud
   flows_D: |
     # some some
   Codon: |
     
     0->visTp_TafuBlA({i=>$S}, [Codon => { file => $file }]);
       
 - K: Codw
   S:
     content_D: |
       my $pri = lc ui.K;
       my $db = {%{ui.B}};
       my $s = ui.K;
       $s .= "(".gpty($_).")" for grep{defined} delete $db->{$pri};
       if (defined db.name) {
           $s .= "(db.name)";
           $db = {};
       }
       delete $db->{ui.Li.i.K};
       $s .= ki($db) if %$db && S.q < 3;
       return $s;
       
 - K: Tital
   S:
     content_D: |
       "ui.title"
       

 - K: Codon
   styles: nonpadl
   Gw: 1
   ux:
     spawn:
      - K: h2
        S:
          styles: red h2
          tag: yh2
          content_D: |
            "C ar.ui.B.name";
     
 - K: Chunks
   styles: bg018 nonpadl
   travels_D: |
     my @CBs = w chunkify[$Codon];
     0->TafuBl(Chunk => $_) for @CBs;
   ux:
     spawn:
      - K: Codw
        q: 3
   
 - K: Chunk
   flows_D: |
     my $C = T.i;
     B.name = B.i;
     S.title = w Chunk/title[$S];
   E:
     S_D: |
          S.styles = 0->Stytog(S.styles => 'z4');
     _D: |
       0->TafuBl("CodeMirror", {C => $S});
   S:
     styles: wanderleft3em antrail nonpadl
   ux:
     spawn:
      - K: Codw
      - K: Tital
        styles: h2 contrim
 - K: Code #c
   S:
     make_lines_html: |
       S.G->w(vimcolor => {string => join("\n", @{$lines})});
   ux:
     spawn:
      - K: pre
        S:
          ishtml: 1
          styles: cos5
          content_D: |
            w $ui S/make_lines_html(e=>'');
           
 - K: CodeMirror #c
   flows_D: |
     #die sw($S);
     T.t = join "\n", "y", @{C.B.lines};
   S:
     sendo_init_D: |
         my $ux = $S->LioO('ux');
         my $cmc = "CodeMirror(document.getElementById('".ux.at.id."'), { "
             ."value: '".0->jsq(join "\n", @{C.B.lines})."', "
            ."mode:  'perl'"
             ."});";
         $H->JS($cmc);
 - K: yaml #c
   arr_if: |
     -f $thing && $thing =~ /odon/ && 1
   foreach_travel:
     each: Way::load_yaml($thing);
     
 - K: 'wc -l'
   arr_if: |
     0 && -f $thing;
   foreach_travel:
     each: (split /\s+/, `wc -l $thing`)[0];
 
 - K: Ooogida
   styles: sativo
hooks:
  recoded_init: |
    my @a = 0->rei({K=>"Chunk"});
    my $s = $a[3];
    sw[$a[3]];
    s.title .= "blook";
    w uxd; 
  percolate: |
    0->TafuB(Sources => {});
    waylay uxd;
  Codon:
    flows_D: |
      w $S load_file_lines;
    travels_D: |
      0->TafuBl(Chunks => { Codon => $S });
    E:
      _D: |
        my $Ch = 0->Ato($S => "Chunks");
        sw([$S,$Ch]) for 1;
        Ch.styles = 0->Stytog(Ch.styles => 'z4');
        # ^ future: A Chunks;.style>tog # means $S/Chunks
        # or $Codon/Chunks # from non-$S wayspace...
        # this kinda stuff wants code sitting right across there more closely...
            
    load_file_lines: |
      die "no stylefile" unless $file;
      w $S stylefile_super;
      B.code = $H->slurp($file);
      w $S load_code;
      
    stylefile_super: |
      $_ = $file;
      B.name ||= do {
          /(ghost)s\/(.+)$/ ? $2 :
          /(lib)\/(.+)\.pm$/ ? $2 : $_
      };
      B.flav = $1 if /(ghost)s\// || /(lib)\// || /(not)$/;
      S.Li.t = B.name;

    load_code: |
      B.code ||= $code;
      B.lines = [ map { s/\n$//s; $_ } split "\n", $code ];
  
  Chunk:
    title: |
      my $lines = S.B.lines;
      my $l;
      for ($lines->[0] || $lines->[1]) {
          $l = $1 if
                 /- K: (.+)$/ms
              || /(\w+):[ \|]/
              || /(G\.U\.\w+) = sub {/;
            
          $l||=$_;
          
          s/$HASHC.*$//s, s/:\s*$// for $l;
      }
      return $l;
  chunkify: |
    my $C = $Codon;
    my $c = "#"."c";
    my @stuff = ([]);
    my $ghost = C.B.flav eq "ghost";
    my $not = C.B.flav eq "not";
    for my $l (@{ C.B.lines }) {
        defined $l || die "no defined l! C.B.name";
        
        push @stuff, []
        
        if
              @{$stuff[-1]} > 0
            && (
                ($ghost||$not) && $l =~ /^\w+|^  \w+/
                ||
                $l =~ /$c/
                ||
                !$ghost && $l =~ /^\S+.+ \{(?:\s+\#.+?)?$/gm
            );
            
        push @{ $stuff[-1] }, $l;
    }
    my @CBs;
    my $i = 0;
    for my $s (@stuff) {
        push @CBs, {
            Codon => $Codon,
            i => $i++,
            rows => scalar(@$s),
            lines => $s,
        };
    }
    T.L.t = "Cx". 0+@CBs ." lx". 0+@{C.B.lines};
    return @CBs;
  vimcolor: |
    my $h = Hostinfo::enhash($string);
    my $k = "vimcolor-$h";
    H.r.gest->($k, sub {
        use Text::VimColor;
        my $syntax = Text::VimColor->new(
            string => $string,
            filetype => 'perl',
        );
        return $syntax->html;
    });
  event: |
    sayyl "Event relating to ".pint(L.i);
    0->visTp({L=>$L},'Fun');
    sw ($ar) if e.S;
    # try and hit E/elabourateness and then blunten until whatever
    if (e.S) {
        w $u zoum;
    }
    else {
        w $u E/_D;
    }
    waylay uxd;
  uxd: |
    my @o = 0->scGre({});
    my @new;
    for my $oo (reverse @o) {
        if (findO('ux', oo.i.o)) {
            last if @new;
        }
        else {
            push @new, oo.i;
        }
    }
    #my $how = @new ? {is=>\@new} : ;
    G.GG.xC->w('ux', {Ls=>\@o});

