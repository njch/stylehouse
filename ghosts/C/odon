name: code
C:
 - K: styledir
   flows_D: |
     T.t = $dir;
   travels_D: |
     my @finds = map { 0->fs_glob($_) } "$dir/style*", "$dir/not";
     push @finds,  map { 0->fs_find($_) } "$dir/ghosts";
     @finds = grep { !/T|H|L/ } @finds;
     for my $file (@finds) {
         0->TafuBl(stylefile => { file => $file });
     }
 
 - K: stylefile
   Ki: styledir
   flows_D: |
     T.t = $file;
   y:
     t:
       event: |
         Say "In Eveent";
         0->TafuB(Codon => { stylefile => L.t });
     
 - K: Codon #c
   flows_D: |
     my $Codon = T.i;
     w codonify[$Codon]; # slurp & split
   travels_D: |
     my $Codon = T.i;
     0->TafuBl(Chunks => { Codon => $Codon });
   S:
     styles: te
     spawn:
      - K: i
      - K: h2
        styles: red
        content_D: |
          "C S.B.Lu.i.B.name"
     
 - K: Chunks #c
   travels_D: |
     my @CBs = w chunkify[$Codon];
     0->TafuBl(Chunk => $_) for @CBs;
   
 - K: Chunk
   print: |
     "C S.B.i";
   flows_D: |
     my $C = T.i;
     T.t = C.B.lines->[0] || C.B.lines->[1];
     T.t||= ki(C.B);
   S:
     spawn:
      - K: t
   y:
     t:
       event: |
         0->TafuBl("CodeMirror", { Chunk => T.i });
 
 - K: CodeMirror #c
   flows_D: |
     my $CM = T.i;
     my $Ch = CM.B.Chunk;
     die "YEPO " if S.B.Ch == $Ch;
     my $C = CM.Lo.i;
     T.t = join "\n", "y", @{Ch.B.lines};
   S:
     spawn:
      - K: div
        S:
          class: cm
      - K: i
     S:
       sendo_init_D: |
         die "Jquery all that";
       
 - K: yaml #c
   arr_if: |
     -f $thing && $thing =~ /odon/ && 1
   foreach_travel:
     each: Way::load_yaml($thing);
     
 - K: 'wc -l'
   arr_if: |
     0 && -f $thing;
   foreach_travel:
     each: (split /\s+/, `wc -l $thing`)[0];
     
dials:
  max_depth: 3
hooks:
  percolate: |
    0->TafuB(styledir => {dir => "/s"});
    
  codonify: |
     my $C = $Codon;
     $_ = C.B.stylefile;
     my $code = $H->slurp($_) if $_;
     C.B.name ||= do {
         /(ghost)s\/(.+)$/ ? $2 :
         /(lib)\/(.+)\.pm$/ ? $2 : $_
     };
     C.B.flav = $1 if /(ghost)s\// || /(lib)\// || /(not)$/;
     T.t = C.B.name;
     $code = C.B.code if C.B.code;
     C.B.lines = [ map { s/\n$//s; $_ } split "\n", $code ];
  
  chunkify: |
    my $C = $Codon;
    my $c = "#"."c";
    my @stuff = ([]);
    my $ghost = C.B.flav eq "ghost";
    my $not = C.B.flav eq "not";
    for my $l (@{ C.B.lines }) {
        defined $l || die "no defined l! C.B.name";
        
        push @stuff, []
        
        if
              @{$stuff[-1]} > 0
            && (
                ($ghost||$not) && $l =~ /^\w+|^  \w+/
                ||
                $l =~ /$c/
                ||
                !$ghost && $l =~ /^\S+.+ \{(?:\s+\#.+?)?$/gm
            );
            
        push @{ $stuff[-1] }, $l;
    }
    my @CBs;
    my $i = 0;
    for my $s (@stuff) {
        push @CBs, {
            Codon => $Codon,
            i => $i++,
            rows => scalar(@$s),
            lines => $s,
        };
    }
    T.L.t = "Cx". 0+@CBs ." lx". 0+@{C.B.lines};
    return @CBs;
  event: |
    sayyl "Event relating to ".pint(L.i);
    0->visTp({L=>$L},'Fun');
    my $y = "";
    $y = "/".ar.uy.K if ar.uy;
    sayyl "IOsa y $y event";
    sw($ar);
    $G->w("y$y/event", $ar, L.i);
    waylay uxd;
  uxd: |
    G.ux->w('ux', {W=>$G->W});
  Earr: |
    # scan events etc.
  

