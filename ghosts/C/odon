name: code
dials: { thuxrw: 1 }

S:
 - K: oud #c sidecar
   Ss:
    - K: CodeMirror
      css:
        - height:auto
    - K: codwide
      css:
        - width:30%
    - K: tc
      css: 
        - float:left
        - position:relative
        - width:calc(100%)
    - K: bgblack
      css:
        - background:black
    - K: fw7
      css:
        - font-weight:700
    - K: brick3
      css:
        - width:33%
        - font-size:160%
    - K: brick4
      css:
        - width:25%
        - font-size:145%
    - K: brick8
      css:
        - width:12%
        - font-size:font-size:125%
    - K: padl
      css:
        - padding-left:0.5em
    - K: wid5
      css:
        - width:50%
    - K: wid2
      css:
        - width:20%
    - K: disnon
      css:
        - display:none
    - K: blubo
      css:
        - 'border:1em solid blue'

 - K: Action
   Ss:
    - K: sources
C:
 - K: Sources #c
   styles: -tc blagga
   S:
     Z:
       -webkit-column-count: 2
   travels_D: |
     0->TafuBl(Dir => {dir => "/s/ghosts/C"});
     0->TafuBl(Dir => {dir => "/s/ghosts/S"});
     0->TafuBl(Ghosts => {});
   
 - K: Dir #c
   styles: padl
   flows_D: |
     S.name = "dir=$dir";
   travels_D: |
     my @finds = sort map { 0->fs_find($_) } $dir; 
     for my $file (@finds) {
         0->TafuBl(File => { file => $file });  
     }
 
 - K: File #c
   styles: brick3 fw7
   print: |
     return $1 if B.file =~ /\/ghosts\/(.+)/;
   E:
     _D: |
       Say "In Eveent S.K $file";
       my $ou = 0->TafuB(Oud => { oud => S.Lo.i }); # of Dir or so
       w $ou Codon[$file];
       
 - K: Ghosts #c
   styles: padl
   travels_D: |
     for my $GG (@{ H.G.GGs }) {
         my $Go = 0->TafuBl(Ghost => { GG => $GG });
     }
   
   
 - K: Ghost #c
   styles: padl brick8
   Z:
     color: \#fca
   flows_D: |
     S.Ve ||= 1;
     S.B.name = GG.name;
   print: |
     B.name
   S:
     aZ: {background: '#044'}
   E:
     _D: |
       0->TafuBl(Junk => {J => $GG});
       S.Ve+=e.C?0.25:-0.5;
       
 - K: J #c
   styles: 
   flows_D: |
     S.e = 9 if !defined S.e;
     B.lines = [$H->hitime];
     #my $cm = 0->TafuBl("CodeMirror", {C => $S});
     # cm.Z.padding = "1em";
   
   
 - K: Do #c
   BcS: name D
   styles: brick4
   print: |
     "D $name";
   S:
     aZ: {background: '#044'}
   E:
     _D: |
       $D->();
       
 - K: Oud #c
   flows_D: |
     # some some
   Codon: |
     0->visTp_TafuBlA({i=>$S}, [Codon => { file => $file }]);
       
 - K: Codlue #c
   S:
     content_D: |
       return w $ui print if ui.K =~ /File|Do|Ghost/;
       
       my $pri = lc ui.K;
       my $db = {%{ui.B}};
       my $s = ui.K;
       $s .= "(".gpty($_).")" for grep{defined} delete $db->{$pri};
       if (defined db.name) {
           $s .= "(db.name)";
           $db = {};
       }
       delete $db->{ui.Li.i.K};
       $s .= ki($db) if %$db && S.q < 3;
       return $s;
       
 - K: Tital #c
   S: {content_D: "ui.title"}
       
 - K: Codon #c
   Gw: 1
   styles: bgblack
   ux:
     spawn:
      - K: h2
        S:
          styles: red h2
          tag: yh2
          content_D: |
            "C ar.ui.B.name";
     
 - K: Chunks #c
   styles: bg018
   travels_D: |
     my @CBs = w chunkify[$Codon];
     0->TafuBl(Chunk => $_) for @CBs;
   ux:
     spawn:
      - K: Codlue
        q: 3
   
 - K: Code #c
   styles: blubo;
   flows_D: |
     B.lines ||= B.C.B.lines; # aba codon?
     B.lines = [split "\n", B.lines] unless ref B.lines eq 'ARRAY';
   some: |
       return join("\n", @{$lines}[0..130]);
   S:
     make_lines_html: |
       return Sw some;
       return join("\n", @{$lines});
       S.G->w(vimcolor => {string => join("\n", @{$lines})});
   ux:
     spawn:
      - K: pre
        S:
          ishtml: 1
          styles: cos5
          content_D: |
            w $ui S/make_lines_html(e=>'');
           
 - K: KV #c
   styles: blubo
   eadu: |
      my @stuff = ("for <h2>".gp($u)."</h2>",
      map {
          my $de = gp($d->{$_});
          qq{$_    <span style="color:white;">$de</span>} 
          }  sort keys %$d);
      B.lines = \@stuff;
      Say "lines ".(0+@stuff);
      my $t = {};
      for my $k (sort keys %$d) {
          my ($fit) = $k =~ /^(\W\w+)/;
          my $ft = $t->{$fit} = 0->TafuB(Code => {fit=>$fit,lines=>[]});
          $G->L($S, $ft);
          my $de = gp($d->{$k});
          my $l = qq{$k    <span style="color:white;">$de</span>} ;
          ;
          
      }
      
   some: |
       return join("\n", @{$lines}[0..130]);
   ux:
     spawn:
      - K: pre
        S:
          ishtml: 1
          styles: cos5
          content_D: |
            w $ui some;
           
 - K: CodeMirror #c
   S:
     sendo_init_D: |
         my $ux = $S->LioO('ux');
         "var cm = CodeMirror(document.getElementById('".ux.at.id."'), { "
             ."value:'".0->jsq(join "\n", @{C.B.lines})."', "
            ."mode:'perl',"
            ."theme:'base16-dark',"
            ."});"
            ."cm".".on('focus', function(){ clof();keof(); });"
            ."cm".".on('blur', function(){ clon();keon(); });";
     
   ux: {spawn: []}
 - K: yaml #c
   arr_if: |
     -f $thing && $thing =~ /odon/ && 1
   foreach_travel:
     each: Way::load_yaml($thing);
     
 - K: 'wc -l'
   arr_if: |
     0 && -f $thing;
   foreach_travel:
     each: (split /\s+/, `wc -l $thing`)[0];
 
 - K: Ooogida
   styles: sativo
hooks:
  fresh_init: |
    0->GAK(U => G!U);
    0->InjC(G.GG.U => Load(<<''));
         C:
           W:
             Ss: [u, x, X]
           M:
             Ss: [oud]
             Z: {background: rgba(0,100,50,0.3), overflow-y: scroll, overflow: visible, width: 30%, height: 100%, position: absolute, left: 10%}
           ux:
             styles: tc
             spawn:
               - K: Codlue
  recoded_init: |
    delete G.Vu;  
    w S/duthis;
    
    w uxd(full=>1); 
  any_init: |
    G.db = 0;
  S:
    duthis: |
      my $u = ar.u || G.ulast;
      G.ulast = $u; 
      $u = $u;
      my $d = w S/duff[$u];
      w S/ducode[$d, $u];
      
    ducode: |
      my $KV = $G->TafuB(KV => {});
      w $KV eadu[$d, $u];
      
    duff: |
      my $s = $G->dus();
      s.A.oh = 0.2;
      s.G.oh = 1;
      $G->du({i=>$u, s=>$s, e=>2});
  percolate: |
    my $s = 0->TafuB(Sources => {});
    my $Dos = $G->findway("per_Do");
    for my $k (sort keys %$Dos) {
        say "gun $k";
        0->TafuB(Do => {
            name => $k, D => sub { w per_Do/$k; },
        });
    }
    
    #sw($stuff);
    w S/duthis(u=>$s);
    Say "perc Codon to uxd";
    w uxd(full=>1)
  per_Do:
    du: |
      w S/duthis;
    seek: |
       Say "Awaits";
       G.envsub = sub {
         my $u = shift;
         w S/duthis[$u];
       }
    bake: |
       Say "Awaits";
       G.envsub = sub {
         my $u = shift;
         sw(u.A->path);
         for (@{ u.A.n }) {
             _.styles =~ s/brick8/brick3/ || _.styles =~ s/brick3/brick8/;
         }
       };
    RW: |
       G.O w ux(GG=>$G);
    uxd: |
       w uxd;
    J: |
       for my $j (0->rei({K=>"J"})) {
           0->del($j);
       }
       0->TafuB(J => {});
      
  Codon:
    flows_D: |
      w $S load_file_lines;
    travels_D: |
      0->TafuBl(Chunks => { Codon => $S });
    E:
      _D: |
        if (e.C) {
            return 0->delfrom($S);
        }
        my @ch = 0->Ato($S => "Chunks");
        unless (@ch) {
            return Sw travels_D;
        }
        for (@ch) {
            0->Stytog($_ => 'z4');
            for (map { 0->Ato($_ => "Code.*") } 0->Ato($_ => "Chunk")) {
                0->Stytog($_ => 'disnon');
            }
        }
        0->Stytog($S => 'wid2');
        # ^ future: A Chunks;.style>tog # means $S/Chunks
        # or $Codon/Chunks # from non-$S wayspace...
        # this kinda stuff wants code sitting right across there more closely...
            
    load_file_lines: |
      die "no stylefile" unless $file;
      w $S stylefile_super;
      B.code = $H->slurp($file);
      w $S load_code;
      
    stylefile_super: |
      for ($file) {
      B.name ||= do {
          /(ghost)s\/(.+)$/ ? $2 :
          /(lib)\/(.+)\.pm$/ ? $2 : $_
      };
      B.flav = $1 if /(ghost)s\// || /(lib)\// || /(not)$/;
      }
      S.Li.t = B.name;

    load_code: |
      B.code ||= $code;
      B.lines = [ map { s/\n$//s; $_ } split "\n", $code ];
  
  Chunk:
    title: |
      my $lines = S.B.lines;
      my $l;
      for ($lines->[0] || $lines->[1]) {
          $l = $1 if
                 /- K: (.+)$/ms
              || /(\w+):[ \|]/
              || /(G\.U\.\w+) = sub {/;
            
          $l||=$_;
          
          s/$HASHC.*$//s, s/:\s*$// for $l;
      }
      return $l;
  chunkify: |
    my $C = $Codon;
    my $c = "#"."c";
    my @stuff = ([]);
    my $ghost = C.B.flav eq "ghost";
    my $not = C.B.flav eq "not";
    for my $l (@{ C.B.lines }) {
        defined $l || die "no defined l! C.B.name";
        
        push @stuff, []
        
        if
              @{$stuff[-1]} > 0
            && (
                ($ghost||$not) && $l =~ /^\w+|^  \w+/
                ||
                $l =~ /$c/
                ||
                !$ghost && $l =~ /^\S+.+ \{(?:\s+\#.+?)?$/gm
            );
            
        push @{ $stuff[-1] }, $l;
    }
    my @CBs;
    my $i = 0;
    for my $s (@stuff) {
        push @CBs, {
            Codon => $Codon,
            i => $i++,
            rows => scalar(@$s),
            lines => $s,
        };
    }
    T.L.t = "Cx". 0+@CBs ." lx". 0+@{C.B.lines};
    return @CBs;
  vimcolor: |
    my $h = $H->dig($string);
    my $k = "vimcolor-$h";
    H.r.gest->($k, sub {
        use Text::VimColor;
        my $syntax = Text::VimColor->new(
            string => $string,
            filetype => 'perl',
        );
        return $syntax->html;
    });
  event: |
    sayyl "Event relating to ".$u->pi;
    0->visTp({L=>$L},'Fun');
    for (1) {
        G.envsub && do { say "envsub"; delete(G.envsub)->($u), next };
        e.S && do { w $u zoum; next };
        w $u E/_D;
    }
    sw (ar.u) if e.S;
    waylay uxd;
  uxd: |
    my $chi = G.Vu.U;
    G.Vu.U = [];
    if (!ar.full && $chi && @$chi) {
        my @i = uniq grep { defined } map { _.Lo && _.Lo.i } @$chi;
        #sw[i=>@i, U=>@$chi];
        say "part uxd ".@$chi;
        @$chi = uniq grep { defined } @$chi, @i;
        say "abode : ".$_->pi for @i;
        G.GG.U->w('ux', {is => $chi});
    }
    else {
        my @o = 0->scGre({});
        saygr "Codon full uxd";
        0->sing(alluxd => sub { Say "BACK!"; G.GG.U->w('ux', {Ls=>\@o}); });
    }
  v:
    ch: |
      push @{G.Vu.U||=[]}, $u if u.G eq $G;
  T:
    traction: |
      w v/ch[$u];
recoded_Cways: 1

