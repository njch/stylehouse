name: code
C:
 - K: styledir
   flows_D: |
     T.t = $dir;
   travels_D: |
     my @finds = map { 0->fs_glob($_) } "$dir/style*", "$dir/not";
     push @finds,  map { 0->fs_find($_) } "$dir/ghosts";
     @finds = grep { !/T|H|L/ } @finds;
     for my $file (@finds) {
         0->TafuBl(stylefile => { file => $file });
     }
 
 - K: stylefile
   Ki: styledir
   flows_D: |
     T.t = $file;
     $file =~ /Ï / && $G->timer(1, sub { w $S y/t/event; });
   y:
     t:
       event: |
         Say "In Eveent S.K $file";
         0->TafuB(Codon => { stylefile => S.Li.t });
         waylay uxd;
     
 - K: Codon #c
   Gw: 1
   S:
     styles: blah
   u_from:
     spawn:
      - K: i
      - K: h2
        S:
          styles: red h2
          tag: yh2
          content_D: |
            "C ui.B.name"
     
 - K: Chunks #c
   S:
     styles: bg018
   travels_D: |
     my @CBs = w chunkify[$Codon];
     0->TafuBl(Chunk => $_) for @CBs;
   
 - K: Chunk
   Gw: 1
   u_from:
     spawn:
      - K: i
        S:
          content_D: |
            "C ui.B.i"
      - K: t
        S:
          styles: brazibro nottoobig
          content_D: |
            w $ui title;
 - K: Code #c
   Gw: 1
   spawn: []
 - K: CodeMirror #c
   flows_D: |
     my $CM = T.i;
     my $Ch = CM.B.Chunk;
     die "YEPOggg " if S.B.Ch == $Ch;
     my $C = CM.Lo.i;
     T.t = join "\n", "y", @{Ch.B.lines};
   S:
     sendo_init_D: |
         my $cmc = "CodeMirror(document.getElementById('".S.at.id."'), { "
             ."value: 'function myScript(){return 100;}\n', "
            ."mode:  'javascript'"
             ."});";
         $H->JS($cmc);
       
   u_from:
     spawn:
      - K: div
        S:
          class: cm
      - K: i
 - K: yaml #c
   arr_if: |
     -f $thing && $thing =~ /odon/ && 1
   foreach_travel:
     each: Way::load_yaml($thing);
     
 - K: 'wc -l'
   arr_if: |
     0 && -f $thing;
   foreach_travel:
     each: (split /\s+/, `wc -l $thing`)[0];
     
dials:
  max_depth: 3
hooks:
  percolate: |
    0->TafuB(styledir => {dir => "/s"});
  Chunk:
    title: |
      my $l;
      my $some=  $lines->[0] || $lines->[1];
      for ($some) {
          $l = $1 if /(\w+):[ \|]/;
      }
      $l ||= $some;
      return $l;
    flows_D: |
      my $C = T.i;
      T.t = C.B.lines->[0] || C.B.lines->[1];
      T.t||= ki(C.B);    
    y:
      t:
        event: |
          0->TafuBl("Code", $B);
  Code:
    S:
      ishtml: 1
      content_D: |
        return "~~~~" unless B.i < 4;
        my $string = join("\n", @{$lines});
        $G->w(vimcolor => {string => $string});
  Codon:
    flows_D: |
      w $S load_stylefile_lines;
      
    travels_D: |
      0->TafuBl(Chunks => { Codon => $S });
            
    load_stylefile_lines: |
      die "no stylefile" unless $stylefile;
      w $S stylefile_super;
      B.code = $H->slurp($stylefile);
      w $S load_code;
      
    stylefile_super: |
      $_ = $stylefile;
      B.name ||= do {
          /(ghost)s\/(.+)$/ ? $2 :
          /(lib)\/(.+)\.pm$/ ? $2 : $_
      };
      B.flav = $1 if /(ghost)s\// || /(lib)\// || /(not)$/;
      S.Li.t = B.name;

    load_code: |
      B.code ||= $code;
      B.lines = [ map { s/\n$//s; $_ } split "\n", $code ];
  
  chunkify: |
    my $C = $Codon;
    my $c = "#"."c";
    my @stuff = ([]);
    my $ghost = C.B.flav eq "ghost";
    my $not = C.B.flav eq "not";
    for my $l (@{ C.B.lines }) {
        defined $l || die "no defined l! C.B.name";
        
        push @stuff, []
        
        if
              @{$stuff[-1]} > 0
            && (
                ($ghost||$not) && $l =~ /^\w+|^  \w+/
                ||
                $l =~ /$c/
                ||
                !$ghost && $l =~ /^\S+.+ \{(?:\s+\#.+?)?$/gm
            );
            
        push @{ $stuff[-1] }, $l;
    }
    my @CBs;
    my $i = 0;
    for my $s (@stuff) {
        push @CBs, {
            Codon => $Codon,
            i => $i++,
            rows => scalar(@$s),
            lines => $s,
        };
    }
    T.L.t = "Cx". 0+@CBs ." lx". 0+@{C.B.lines};
    return @CBs;
  vimcolor: |
    my $h = Hostinfo::enhash($string);
    return G.redis->{"vimcolor-$h"} ||= do {
        use Text::VimColor;
        my $syntax = Text::VimColor->new(
            string => $string,
            filetype => 'perl',
        );
        '<pre>'.$syntax->html.'</pre>';
    };
  event: |
    sayyl "Event relating to ".pint(L.i);
    0->visTp({L=>$L},'Fun');
    my $y = "";
    $y = "/".ar.uy.K if ar.uy;
    sayyl "IOsa y $y event";
    $G->w("y$y/event", $ar, L.i);
    waylay uxd;
  uxd: |
    G.ux->w('ux', {W=>$G->W});
  Earr: |
    # scan events etc.
  

