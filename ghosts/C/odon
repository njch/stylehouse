name: code
dials: { thuxrw: 1 }

S:
 - K: oud #c sidecar
   Ss:
    - K: CodeMirror
      css:
        - height:auto
    - K: codwide
      css:
        - width:30%
    - K: tc
      css: 
        - border-bottom:1px solid black
        - float:left
        - position:relative
        - width:calc(100%)
        - background:rgba(150,100,50,0.3)
    - K: padl
      css:
        - padding-left:0.5em
    - K: wid5
      css:
        - width:50%
    - K: wid2
      css:
        - width:20%
    - K: disnon
      css:
        - display:none
C:
 - K: Sources
   styles: -tc
   S:
     Z:
       -webkit-column-count: 2
   travels_D: |
     0->TafuBl(Dir => {dir => "/s"});
     0->TafuBl(Ghosts => {});
   
 - K: Dir #c
   styles: padl
   flows_D: |
     S.name = "dir=$dir";
   travels_D: |
     my @finds = map { 0->fs_glob($_) } "$dir/style*", "$dir/not";
     push @finds,  map { 0->fs_find($_) } "$dir/ghosts";
     @finds = grep { !/T|H|L/ } @finds;
     for my $file (@finds) {
         0->TafuBl(File => { file => $file });
     }
 
 - K: File
   styles: padl
   E:
     _D: |
       Say "In Eveent S.K $file";
       my $ou = 0->TafuB(Oud => { oud => S.Lo.i }); # of Dir or so
       w $ou Codon[$file];
       
 - K: Ghosts #c
   styles: padl
   travels_D: |
     for my $GG (@{ H.G.GGs }) {
         my $Go = 0->TafuBl(Ghost => { GG => $GG });
     }
   
   
 - K: Ghost
   styles: padl
   flows_D: |
     S.Ve ||= 1;
     S.B.name = GG.name;
   S:
     aZ: {background: '#044'}
   E:
     _D: |
       S.Ve+=e.C?0.25:-0.5;
       
 - K: Oud
   flows_D: |
     # some some
   Codon: |
     0->visTp_TafuBlA({i=>$S}, [Codon => { file => $file }]);
       
 - K: Codw
   S:
     content_D: |
       my $pri = lc ui.K;
       my $db = {%{ui.B}};
       my $s = ui.K;
       $s .= "(".gpty($_).")" for grep{defined} delete $db->{$pri};
       if (defined db.name) {
           $s .= "(db.name)";
           $db = {};
       }
       delete $db->{ui.Li.i.K};
       $s .= ki($db) if %$db && S.q < 3;
       return $s;
       
 - K: Tital
   S: {content_D: "ui.title"}
       

 - K: Codon
   Gw: 1
   ux:
     spawn:
      - K: h2
        S:
          styles: red h2
          tag: yh2
          content_D: |
            "C ar.ui.B.name";
     
 - K: Chunks
   styles: bg018
   travels_D: |
     my @CBs = w chunkify[$Codon];
     0->TafuBl(Chunk => $_) for @CBs;
   ux:
     spawn:
      - K: Codw
        q: 3
   
 - K: Chunk
   flows_D: |
     my $C = T.i;
     B.name = B.i;
     S.title = w Chunk/title[$S];
   E:
     _D: |
       if (e.C) {
           return 0->delfrom($S);
       }
       return 0->TafuBl("CodeMirror", {C => $S});
       return 0->TafuBl("Code", {C => $S});
   S:
     styles: wanderleft3em antrail
   ux:
     spawn:
      - K: Tital
        styles: h2 contrim
 - K: Code #c
   flows_D: |
     B.lines = C.B.lines;
   S:
     make_lines_html: |
       S.G->w(vimcolor => {string => join("\n", @{$lines})});
   ux:
     spawn:
      - K: pre
        S:
          ishtml: 1
          styles: cos5
          content_D: |
            w $ui S/make_lines_html(e=>'');
           
 - K: CodeMirror #c
   S:
     sendo_init_D: |
         my $ux = $S->LioO('ux');
         "var cm = CodeMirror(document.getElementById('".ux.at.id."'), { "
             ."value:'".0->jsq(join "\n", @{C.B.lines})."', "
            ."mode:'perl',"
            ."theme:'base16-dark',"
            ."});"
            ."cm".".on('focus', function(){ clof();keof(); });"
            ."cm".".on('blur', function(){ clon();keon(); });";
   ux: {spawn: []}
 - K: yaml #c
   arr_if: |
     -f $thing && $thing =~ /odon/ && 1
   foreach_travel:
     each: Way::load_yaml($thing);
     
 - K: 'wc -l'
   arr_if: |
     0 && -f $thing;
   foreach_travel:
     each: (split /\s+/, `wc -l $thing`)[0];
 
 - K: Ooogida
   styles: sativo
hooks:
  fresh_init: |
    0->GAK(xC => G!T/ux);
    0->InjC(G.GG.xC => Load(<<''));
         C:
           W:
             Ss: [u, x, X]
           M:
             Ss: [oud]
             Z: {background: rgba(0,100,50,0.9), overflow: visible, width: 30%, height: 100%, position: absolute, left: 10%}
           ux:
             styles: tc
             spawn:
               - K: Codw
  recoded_init: |
    my @a = 0->rei({K=>"Chunk"});
    my $s = $a[3]; #WETF
    say sw[achunk=>$s];
    Say "Yep";
    die "hi";
    delete G.Vu;
    w uxd; 
  percolate: |
    0->TafuB(Sources => {});
    saygr "perc Codon to uxd";
    waylay uxd;
  Codon:
    flows_D: |
      w $S load_file_lines;
    travels_D: |
      0->TafuBl(Chunks => { Codon => $S });
    E:
      _D: |
        if (e.C) {
            return 0->delfrom($S);
        }
        my @ch = 0->Ato($S => "Chunks");
        unless (@ch) {
            return Sw travels_D;
        }
        for (@ch) {
            0->Stytog($_ => 'z4');
            for (map { 0->Ato($_ => "Code.*") } 0->Ato($_ => "Chunk")) {
                0->Stytog($_ => 'disnon');
            }
        }
        0->Stytog($S => 'wid2');
        # ^ future: A Chunks;.style>tog # means $S/Chunks
        # or $Codon/Chunks # from non-$S wayspace...
        # this kinda stuff wants code sitting right across there more closely...
            
    load_file_lines: |
      die "no stylefile" unless $file;
      w $S stylefile_super;
      B.code = $H->slurp($file);
      w $S load_code;
      
    stylefile_super: |
      $_ = $file;
      B.name ||= do {
          /(ghost)s\/(.+)$/ ? $2 :
          /(lib)\/(.+)\.pm$/ ? $2 : $_
      };
      B.flav = $1 if /(ghost)s\// || /(lib)\// || /(not)$/;
      S.Li.t = B.name;

    load_code: |
      B.code ||= $code;
      B.lines = [ map { s/\n$//s; $_ } split "\n", $code ];
  
  Chunk:
    title: |
      my $lines = S.B.lines;
      my $l;
      for ($lines->[0] || $lines->[1]) {
          $l = $1 if
                 /- K: (.+)$/ms
              || /(\w+):[ \|]/
              || /(G\.U\.\w+) = sub {/;
            
          $l||=$_;
          
          s/$HASHC.*$//s, s/:\s*$// for $l;
      }
      return $l;
  chunkify: |
    my $C = $Codon;
    my $c = "#"."c";
    my @stuff = ([]);
    my $ghost = C.B.flav eq "ghost";
    my $not = C.B.flav eq "not";
    for my $l (@{ C.B.lines }) {
        defined $l || die "no defined l! C.B.name";
        
        push @stuff, []
        
        if
              @{$stuff[-1]} > 0
            && (
                ($ghost||$not) && $l =~ /^\w+|^  \w+/
                ||
                $l =~ /$c/
                ||
                !$ghost && $l =~ /^\S+.+ \{(?:\s+\#.+?)?$/gm
            );
            
        push @{ $stuff[-1] }, $l;
    }
    my @CBs;
    my $i = 0;
    for my $s (@stuff) {
        push @CBs, {
            Codon => $Codon,
            i => $i++,
            rows => scalar(@$s),
            lines => $s,
        };
    }
    T.L.t = "Cx". 0+@CBs ." lx". 0+@{C.B.lines};
    return @CBs;
  vimcolor: |
    my $h = Hostinfo::enhash($string);
    my $k = "vimcolor-$h";
    H.G.r.gest->($k, sub {
        use Text::VimColor;
        my $syntax = Text::VimColor->new(
            string => $string,
            filetype => 'perl',
        );
        return $syntax->html;
    });
  event: |
    sayyl "Event relating to ".pint(L.i);
    0->visTp({L=>$L},'Fun');
    sw ($ar) if e.S;
    # try and hit E/elabourateness and then blunten until whatever
    if (e.S) {
        w $u zoum;
    }
    else {
        w $u E/_D;
    }
    waylay uxd;
  uxd: |
    my $chi = G.Vu.xC;
    G.Vu.xC = [];
    if ($chi && @$chi) {
        say "part uxd ".@$chi;
        G.GG.xC->w('ux', {is => $chi});
    }
    else {
        my @o = 0->scGre({});
        saygr "Codon full uxd";
        0->sing(alluxd => sub { Say "BACK!"; G.GG.xC->w('ux', {Ls=>\@o}); });
    }
  v:
    ch: |
      push @{G.Vu.xC||return}, $u if u.G eq $G;
  T:
    traction: |
      w v/ch[$u];
recoded_Cways: 1

