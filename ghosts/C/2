R_Jz:
 - K: ii/Jhead #c J _
   D: |
       my $M = [];
       
       #Rw ii/J1 + $M;
       my $n = ["Jay", '0.1', 
           {pwth=>'hull/mk:Jself',fo=>[$J,0.1]},
           {sha=>'3 5 2 330',fs=>20},
       ];
       Rw Mn $J $n;
       # TODO wtf that onto $M overwrites others
       #Rw wtf $M ITsa 0.03 $s $sc;
       
       Rw the + $M Jhead;
       Rw the + $M Jim;
       Rw doc $M;
       
       say "----------------".ki $_ for @$M;
       my $V = 1;
       
       my $at = ar.out || 0.001;
       my $sc = {fs=>19};
       Rw om/lev + $oM:M Jhead $at $V $sc;
       sayre "over\n\n";
       
 - K: ii/cap #c ha zom
   D: |
       
       my $M = [];
       Rw ii/infrom + $M;
       my $at = 0.03;
       Rw om/lev + $oM:M bwaga $at;
       $M = [];
       #sayyl "INFROM: ".wdump$M;
       # root ^
       # travel v
       # cend pwth
       
       Rw ii/capstyle + $M;
       
       #say "ii/cap: ".ki$rr;
       my $t = '/'.x.j.t.'-cap';
       Rw om/lev + $oM:M $t;
 - K: ii/capstyle #c
   D: |
     return if J.yaw.ii_capstyle.non;
       my $sw = {};
       for (grep {!/^(travely|ori)$/} sort keys %{x.sc}) {
           $sw->{$_} = x.sc->{$_};
       }
       return unless %$sw;
       my $c = {fo=>[$sw,0.7], cow=>'rgb 38f'};
       my $sc = {fs=>26};
       Rw wtf + caps $c;
 - K: ii/infrom #c
   D: |
     my $t = '_';
     my $un = {co=>'38f'};
     Rw wtf + $t $s:x.j.l $sc:un;
     
     $t = '=';
     my $esc = {fs=>12,co=>'000',sha=>'3 3 3 fff'};
     Rw wtf + $t $sc:esc;
     
     if (x.sc.ori) {
         $t = 'i';
         my $ic = {pwth=>'sur/to:/',fo=>[(x.sc.ori),0.4]};
         Rw wtf + $t $c:ic;
     }
     if (x.sc.ts) {
         my $s = x.sc.ts - H.uptime;
         $s = sprintf '%.2f', $s;
         my $sc = {co=>'33f5'};
         Rw wtf + zetime $s $sc;
     }
     
     my $vl = x.sc.travely;
     if ($vl && @$vl) {
           my $s = join(" ",'',@$vl,'');
           Rw wtf + travely $s;
           my $c = {fo=>[x.j.s, 0.2]};
           Rw wtf + S $c;
     }
     
 - K: ix/suro #c
   D: |
      my $j = x.j;
      my $coi = Rw pha $J $k:j.l;
      my $M = [];
      
      # innessy
      Rw ii/cap $J $x $M;
      #v v v v v v v
      # v v v v v v
      my $bit = Rw buck */bod $J;
      Rw $bit $J $x $M;
      # ^ ^ ^ ^ ^ ^
      #^ ^ ^ ^ ^ ^ ^
      
      say "surM:   ".join ',  ', map{_.t} @$M;
      
      die if !@$M;
      
      Rw om/bal $J $oM:M $t:j.t $in:x.in $out:x.out;
      coi.end->();
 - K: sur/bod #c boodle am $rr into $M: lab,pi, lab,pi ...
   D: |
       my $in = x.in; # TODO whereto?
       my $out = x.out;
       my $phi = ($out - $in) * (x.thi || 2); # normal lines per 0.1
       my $thi = $phi; # oundo big window, bod small
       
       say "bod $in <--> $out  $thi     x.j.r"; # TODO say big
       
       my $o = Rw oundo $thi $x;
       say "Oundo: ". join ', ', map{"$_"} @{o.r};
       warn "More o.more" if o.more;
       my $M = [];
       for my $r (@{o.r}) {
           r.r || die"nor".ki$r;
           my $oM = [];
           # SZOOOOOOOOOOOM
           Rw ii/labegy $x $r $M:oM;
           Rw ii/pi $x $r $M:oM;
           # ^ pass $thi, pool resources
           
           my $c = {%{r.c||{}}};
           #sayyl "iibod: ". ki $r;
           
           
           Rw om/lev + $oM $M $t:r.r $c;
       }
       if (o.more) {
           Rw ii/more $x $o $M;
       }
       Rw iM + $oM:M;
 - K: ii/labegy #c suitcase handle
   D: |
     my $d;
     d.t = 'lab';
     d.c.s = r.r;
     d.sc.ws = 'p';
     d.sc.ab = 'right:0.5em';
     d.c.fsx = "25";
     Rw iiJM + $d;
 - K: ii/pi #c THE WHOLE GHUTS, X & L line the squiggles of inness $x and oundo $r
   D: |
     my $d;
     d.t = 'pi';
     
     my $o = {};
     o.u = r.s;
     o.cv = 0.6;
     my $pi = [r.s, 0.6];
     push @$pi, r.c.pi if r.c.pi; # pi mod from ou
     d.c.fo = $pi;
     d.c.path = r.path;
     # structureal elements jump into the pipe lining
     d.c.L = $r;
     d.c.X = $x;
       
     d.sc.ws = 'n';
     d.sc.ab = 'left:1em';
     d.sc.mw = '14em';
     d.sc.over = 'hidden';
     
     Rw iiJM + $d;

