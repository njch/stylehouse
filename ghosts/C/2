R_Jz:

 - K: waits #c
   D: |
    my $towait = ar.towait || 1;
    my $to = ar.to;
    
    my $max = max map { _.div } @$to;
    _.span = $max / _.div for @$to;
    
    my $tot = sum map { _.span } @$to;
    my $one = $towait / $tot;
    
    my $ord = {};
    for my $t (@$to) {
        my $waits = $one * t.span;
        $waits = sprintf("%.7f", $waits);
        t.waits = $waits;
        push @{ $ord->{$waits} ||= [] }, $t
    }
    return $ord;
    
 - K: inness #cc soy packets everywhere # THINGNESS as onness
   D: |
      w mux(u=>$J) if ar.r; # slower reintro - calc entropy
      
      say "inness of ". gp $J;
      say "r: ".ki ar.r if ar.r;
      J.on ||= Rw tent on;
      J.on.yy.conroll.dont ||= 1;
      
      my $ye = Rw suck + */ines;
      
      return sayre "inness override ".$J->pi if $ye;
      die if J.name =~ /mash/;
      
      # right handed receiver of 8s, informs to humm etc.
      # would involve many uish and the types of perception we want to see
      # laying out the plane of attack
      # just has to find a corner of it as 3
      # ^ inject 6
      # but first...
      # t distributable, listy compressible pass space
      # ^ recursor... incubator
      # v def
      my $o = J.onei ||= {i=>$G};
      my $r = ar.r;
      %$o = (i => r.i) if r.i;
      
      o.t||=[];
      
      if (ref r.t eq 'ARRAY') {
          o.t = [@{r.t}];
      }
      else {
          push @{o.t}, r.t if r.t;
      }
      
      # do this from u%ut, branch climber
      # ^^^ exactly, tip sits around the rim, styles ping flows
      my $i = o.i;
      for my $t (@{o.t}) {
          sayyl "   -trav $i       $t";
          $i = $R->suets($i, $t);
      }
      sayyl "Inness: ".slim(130,gp(o.i))."     "
        .join("   ", @{o.t})." ----> ".slim(130,gp $i)
            if $i ne o.i;

      # on ventrickles already, look at the path for clues
      # if last t was {bb 55 stylse
      # the tree of loveliness to hook in as things fly by again soon...
      
      # like J.yy.inness.wants to fold back all the uninteresting stuff
      # also show the groups of phases etc
      # styles from on become humming/rounding protocols
      #
      
      J.on bz u 0.1 $i
      J.on bz u%ori 0.1 J.onei.i
      J.on bz u%travely 0.1 J.onei.t
      if (r.sc) {
          for my $k (sort keys %{r.sc}) {
             my $v = r.sc->{$k};
             J.on bz u%$k 0.1 $v
          }
      }
      
 - K: whack #c the <, smash bit off end of stick
   D: |
     my $o = J.onei;
     if (@{o.t||[]}) {
         pop @{o.t};
     }
     else {
         o.i =~ s/\/[^\/]+$//;
     }
 - K: pi/scbund #c the sc attachment, could go editable + back
   D: |
     Jn(sc => 0.3, ki($u), '{fs:7,co:314,sha:1 1 3 fff}');

     
 - K: ix/suro #c SURO SOMETHING SWIRLS VERY (lvs)
   D: |
      my $j = x.j;
      my $coi = Rw pha $J $k:j.l;
      my $M = [];
      
      # innessy
      # slap Js at various voltages
      # Js that C something
      
      Mn(x.j.l.'-cap' => '',{pi=>'infrom',s=>$x,gp=>{cv=>0.2},pwth=>'intoo'});
      
      #v v v v v v v
      # v v v v v v
      Rw ii/bod $J $x $M;
      # ^ ^ ^ ^ ^ ^
      #^ ^ ^ ^ ^ ^ ^
      
      say "surM:   ".join ',  ', map{_.t} @$M;
      
      die if !@$M;
      
      
      Rw om/bal $J $oM:M $t:j.t $in:x.in $out:x.out $V=1;
      coi.end->();
      sayyl "coi.name got ". keys %{coi.bb};
 - K: ii/bod #c boodle am $rr into $M: lab,pi, lab,pi ...
   D: |
       my $in = x.in; # TODO whereto?
       my $out = x.out;
       my $thi = x.thi;
       
       sayyl "x.in - x.out     x.thi";
       
       my $o = Rw oundo $thi $x;
       
       # pha
       # o.dig
       
       my $oM = [];
       for my $r (@{o.r}) {
           defined r.t || die"nor".ki$r;
           next if r.skip;
           my $M = [];
           # SZOOOOOOOOOOOM animated, passing landmarks
           
           Rw ii/labegy $x $r $M;
           #v v v v v v v
           # v v v v v v
           Rw ii/pi $x $r $M;
           # ^ ^ ^ ^ ^ ^
           #^ ^ ^ ^ ^ ^ ^
           # ^ pass $thi, pool resources
           
           my $rc = {};
           # whole line magneted styles etc...
           rc.path = r.c.path if r.c.path;
           Rw om/lev + $oM:M $M:oM $t:r.t $c:rc;
       }
       if (o.more) {
           Rw ii/more $x $o $M:oM;
       }
       Rw iM + $oM;
 - K: ii/pi #c THE WHOLE GHUTS, see d.c.gp ghost plumbing  & d.g.(x|r) for geo sync suro
   D: |
     my $d;
     d.g.x = $x;
     d.g.r = $r;
     d.t = 'pi';
     # structureal elements jump into the pipe lining
     d.c = {%{r.c||{}}};
     d.c.pi ||= '';
     
     d.c.s ||= r.s;
     d.c.gp.cv ||= 0.6;
     
     d.c.path ||= r.path;
       
     d.sc = {%{r.sc||{}}};
     d.sc.ws = 'n';
     d.sc.ab = 'left:0.1em';
     
     Rw iiJM + $d;
 - K: ii/labegy #c suitcase handle # elemental locus of travel/path fields
   D: |
     my $d;
     d.g.x = $x;
     
     d.g.r = $r;
     
     d.t = 'lab';
     
     d.c = {%{r.lab_c||{}}};
     
     d.c.s = r.t;
     d.c.pi ||= 'lab';
     d.c.fsx = "25";
     
     # selection piways
     d.sc = {%{r.lab_sc||{}}};
     d.sc.ws = 'p';
     #d.sc.fs = 30 if x.phi > 0.4;
     #sayyl ki d.g.x;
     
     d.sc.ab = 'right:0.5em'; 
     
     Rw iiJM + $d;
     # the lasty tangvely, sandy mod hooks beVow
 - K: pi/lab #c round corner, where one bit/type/hum of noise splits others
   D: |
     my $r = J.d.g.r;
     Jn(wtf => '', $u, '{zi:15,sha:2 3 6 ccf,fw:16,co:3f4}');
     
 - K: ii/time #c
   D: |
     # say # ago and js hookup increment into human
     my $rtime = sprintf '%.2f', $time - H.uptime;
     # time since H started? since the J started?
     Rw Mn + $n:_ for
     ['zetime', '', {s=>$rtime}, {co=>'33f5'}];
 - K: ii/Jhead #c J _
   D: |
     Rw Jhead;
 - K: Jhead #c
   D: |
       Jn(Jhead => 0.01, {pi=>'Jhead'});
 - K: pi/Jhead #c
   D: |
      Jn(name => 0.1, {pi=>'Jname',s=>J.most.J},"{is:Hname:H.name}");
      
      Jn(Hname => 0.2, "H.name", 
               '{sha:3 5 2 330,co:ff59,fs:12,ab:1,ml:0.3em}')
           if H.name ne 'C';
      
      Jn(X => 0.3, {pi=>'Jkill',s=>J.most.J});
      #Jn(W => 0.4, {s=>'W',pwth=>'Wdo'}, {fs=>'8'}); 
      Jn(t => 0.6, {s=>'t',pwth=>'cl/tidy'}, {fs=>7,ml=>'1em'});
      Jn(S => 0.7, {s=>'S',pwth=>'rez'}, {fs=>9});
      #Jn(S => 0.8, {s=>'oo',pwth=>'kilo'}, {fs=>9});
      
       # TODO collapse upwards button
 - K: kilo #c
   D: |
      $G->pub('S/hut/o', 'reexec');
 - K: headi #c
   n_D:
     Jhead: | #
       MZ pwth
       t      cl/tidy    {} {co:ffff}
       C      cl/reC     {} {co:b238}
       #
       #z  J5:zoy       {} {co:48d}
       #ඬ  J5:wam      {} {co:f85}
       #ƾ  J5:oot       {} {co:8ff}
 - K: pi/Jkill #c
   D: |
       my $xc = {pwth=>'join/X',s=>'X'};
       my $xsc = {co=>'f34',fs=>'13'};
       if (J.cv < 0.3) {
           #xsc.fs = 14;
           xsc.ab = 'left:0.3em';
           #xsc.zi = 44;
       }
       Jn(x => '', $xc, $xsc);
     
 - K: pi/Jname #c
   D: |
      my $name = u.name; 
      ($name, my $soob) = ($1,$2) if $name =~ /^(.+)(-.+?)$/;
      Jn(name => '', "$name", '{sha:3 5 2 330,fs:15}');
      Jn(oob => '', "$soob", '{sha:3 5 2 330,co:a359,fs:6,ml:-0.4em}') if defined $soob;
       

