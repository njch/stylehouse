R_Jz:
 - K: onl/cut #c
   D: |
     $scsort||die;
     @$onl = reverse
         sort { a.sc->{$scsort} <=> b.sc->{$scsort} }
         grep { defined _.sc->{$scsort} || die'no %'.$scsort.' on: '._.j.r }
         @$onl;
     my @in;
     my @cut;
     push @{ @in < 4 ? \@in : \@cut }, $_ for @$onl;
     for my $x (@cut) {
         delete J.bb->{_.r} for x.j, values %{x.sj};
     }
     @$onl = @in;
     $onl
     
 - K: very #c tak tlv into space, ready for lx/suro
   D: |
       my $onl = ar.onl;
       $onl ||= Rw tlv $J;
       
       my $phi = $out - $in; # <-0.8->
       my $thi = $phi / (@$onl||1); # or indi
       # thi vs $onl individuality
       my $tin = $in;
       for my $x (@$onl) {
           # go higher and pipe mods to squish space, vary $thi (other ways to)
           x.thi = $tot / $thi;
           x.phi = $thi;
           x.in = $tin;
           x.out = $tin + $thi;
           $tin = x.out; # next
           # space volve, indi...
           #die "x.j.r   shall x.thi    ($tot $phi)";
           
           my $j = x.j;
           if (!J.q) {
               say "up on ".$J->pi."    j.r    ".slim 200, gp(j.s);
               say "   * _.r          => ".gp(_.s) for values %{x.sj};
               say "up around x.in <-> x.out"
           }
       }
       $onl
       
 - K: inness #cc soy packets everywhere # THINGNESS as onness
   D: |
      w mux(u=>$J) if ar.r; # slower reintro - calc entropy
      
      say "inness of ". gp $J;
      say "r: ".ki ar.r if ar.r;
      J.on ||= Rw tent on;
      J.on.yy.conroll.dont ||= 1;
      
      my $ye = Rw suck + */ines;
      
      #die wdump $ye if J.name =~ /mash/;
      
      if ($ye) {
      sayre "inness override ".$J->pi;
      return
      }
      die if J.name =~ /mash/;
      
      # right handed receiver of 8s, informs to humm etc.
      # would involve many uish and the types of perception we want to see
      # laying out the plane of attack
      # just has to find a corner of it as 3
      # ^ inject 6
      # but first...
      # t distributable, listy compressible pass space
      # ^ recursor... incubator
      # v def
      my $o = J.onei ||= {i=>$G};
      my $r = ar.r;
      %$o = (i => r.i) if r.i;
      
      o.t||=[];
      
      if (ref r.t eq 'ARRAY') {
          o.t = [@{r.t}];
      }
      else {
          push @{o.t}, r.t if r.t;
      }
      
      # do this from u%ut, branch climber
      # ^^^ exactly, tip sits around the rim, styles ping flows
      my $i = o.i;
      for my $t (@{o.t}) {
          sayyl "   -trav $i       $t";
          $i = $R->suets($i, $t);
      }
      sayyl "Inness: ".slim(130,gp(o.i))."     "
        .join("   ", @{o.t})." ----> ".slim(130,gp $i)
            if $i ne o.i;

      # on ventrickles already, look at the path for clues
      # if last t was {bb 55 stylse
      # the tree of loveliness to hook in as things fly by again soon...
      
      # like J.yy.inness.wants to fold back all the uninteresting stuff
      # also show the groups of phases etc
      # styles from on become humming/rounding protocols
      #
      
      J.on bz u 0.1 $i
      J.on bz u%ori 0.1 J.onei.i
      J.on bz u%travely 0.1 J.onei.t
      if (r.sc) {
          for my $k (sort keys %{r.sc}) {
             my $v = r.sc->{$k};
             J.on bz u%$k 0.1 $v
          }
      }
      

 - K: pi/infrom #c
   D: |
     my $x = $u;
     Jn('_', '', "x.j.l", '{co:38f}');
     Jn('=', '', {}, '{fs:22,co:000,sha:3 3 3 fff}');
     
     # or anywhere w e came through
     # root ^
     # travel v
     # cend pwth
     Jn('ori','',
           {s=>x.sc.ori, pi=>'', gp=>{cv=>0.2}, pwth=>'sur/to:/'},
           '{hue:100,fs:18}')
           if exists x.sc.ori;
     
     # quick reverse, snap bits off i
     Jn('<','',{pwth=>'whack'},'{fs:16,co:314,sha:1 1 3 fff}');
     
     
     my $in = {%{x.sc}};
     delete in.ori;
     delete in.travely if ref in.travely eq 'ARRAY' && !@{in.travely};
     if (%$in) {
         Jn('x-sc','',{pi=>'capstyle',s=>$in},{fs=>13 ,co=>'314',sha=>'1 1 3 fff'});
     }
     if (my $time = x.sc.ts) { # can't be zero, so relative
         Rw ii/time + $time;
     }
 - K: ix/suro #c
   D: |
      my $j = x.j;
      my $coi = Rw pha $J $k:j.l;
      my $M = [];
      
      # innessy
      my $cv = x.sc.capcv || 0.4;
      Mn('/'.x.j.t.'-cap' => '',
      {pi=>'infrom',s=>$x,gp=>{cv=>$cv},pwth=>'intoo'});
      
      #v v v v v v v
      # v v v v v v
      Rw ii/bod $J $x $M;
      # ^ ^ ^ ^ ^ ^
      #^ ^ ^ ^ ^ ^ ^
      
      say "surM:   ".join ',  ', map{_.t} @$M;
      
      die if !@$M;
      
      Rw om/bal $J $oM:M $t:j.t $in:x.in $out:x.out;
      coi.end->();
 - K: intoo #c
   D: |
     #die J2.Jmost->pi ."          ".wdump ;
     Rw surf $i:J2.d.c.s;
 - K: ii/bod #c boodle am $rr into $M: lab,pi, lab,pi ...
   D: |
       my $in = x.in; # TODO whereto?
       my $out = x.out;
       my $phi = ($out - $in) * (x.thi || 2); # normal lines per 0.1
       my $thi = $phi; # oundo big window, bod small
       my $whi = $thi * (x.sc.whim || 2);
       sayre "bod     $in    $out     x $thi     x.j.r"; # TODO say big
       
       my $o = Rw oundo $thi $whi $x;
       
       my $oM = [];
       for my $r (@{o.r}) {
           defined r.r || die"nor".ki$r;
           next if r.skip;
           my $M = [];
           # SZOOOOOOOOOOOM animated, passing landmarks
           
           Rw ii/labegy $x $r $M;
           #v v v v v v v
           # v v v v v v
           Rw ii/pi $x $r $M;
           # ^ ^ ^ ^ ^ ^
           #^ ^ ^ ^ ^ ^ ^
           # ^ pass $thi, pool resources
           
           my $rc = {};
           # whole line magneted styles etc...
           rc.path = r.c.path if r.c.path;
           Rw om/lev + $oM:M $M:oM $t:r.r $c:rc;
       }
       if (o.more) {
           Rw ii/more $x $o $M:oM;
       }
       Rw iM + $oM;
 - K: ii/pi #c THE WHOLE GHUTS, see d.c.gp ghost plumbing  & d.g.(x|r) for geo sync suro
   D: |
     my $d;
     d.g.x = $x;
     d.g.r = $r;
     d.t = 'pi';
     # structureal elements jump into the pipe lining
     d.c = {%{r.c||{}}};
     d.c.pi ||= '';
     
     d.c.s ||= r.s;
     d.c.gp.cv ||= 0.6;
     
     d.c.path ||= r.path;
       
     d.sc = {%{r.sc||{}}};
     d.sc.ws = 'n';
     d.sc.ab = 'left:3em';
     
     Rw iiJM + $d;
 - K: ii/labegy #c suitcase handle # elemental locus of travel/path fields
   D: |
     my $d;
     d.g.x = $x;
     d.g.r = $r;
     d.t = 'lab';
     d.c = {%{r.lab_c||{}}};
     d.c.s = r.r;
     d.c.pi ||= 'lab';
     d.c.fsx = "25";
     # selection piways
     d.sc = {%{r.lab_sc||{}}};
     d.sc.ws = 'p';
     #d.sc.fs = 30 if x.phi > 0.4;
     sayyl ki d.g.x;
     d.sc.ab = 'right:0.5em'; 
     Rw iiJM + $d;
     # the lasty tangvely, sandy mod hooks beVow
 - K: pi/lab #c round corner, where one bit/type/hum of noise splits others
   D: |
     my $r = J.d.g.r;
     Jn(wtf => '', $u, '{zi:15,sha:2 3 6 ccf,fw:16,co:3f4}');
     
 - K: pi/capstyle # the sc attachment
   D: |
     Jn( intersc => '',
       {pi=>'',s=>$u,gp=>{cv=>0.7}},
       '{fs:3,co:314,sha:1 1 3 fff}');

     
 - K: whack #c the <, smash bit off end of stick
   D: |
     my $o = J.onei;
     if (@{o.t||[]}) {
         die;
     }
     else {
         o.i =~ s/\/[^\/]+$//;
     }

