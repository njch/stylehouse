R_Jz:

 - K: ii/Jhead #c J _
   D: |
       my $M = [];
       my $cv = ar.cv || 0.4;
       
       my $name = J.name;
       my ($nas, $nac) = split '-', $name, 2;
       
       my $nsc = {sha=>'3 5 2 330',fs=>15};
       Rw wtf $M $t:nas $sc:nsc;
       
       my $nacsc = {sha=>'3 5 2 330',co=>'a359',fs=>9};
       Rw wtf $M $t:nac $sc:nacsc;
       
       
       my $xc = {pwth=>'hull/mk:X'};
       my $xsc = {co=>'f34',fs=>'13'};
       if ($cv < 0.3) {
           xsc.fs = 14;
           xsc.ab = 1;
           xsc.left = '0.3em';
           xsc.zi = 44;
       }
       Rw wtf $M x $c:xc $sc:xsc;
       
       # TODO collapse upwards button
       
       #Rw Mn $J $n;
       # TODO wtf that onto $M overwrites others
       #Rw wtf $M ITsa 0.03 $s $sc;
       if ($cv > 0.3) {
           Rw the + $M Jhead; 
           Rw the + $M Jim;
           Rw doc $M;
       }
       my $at = ar.out || 0.001;
       my $sc;
       sc.fs = $cv > 0.2 ? 19 : 9;
       Rw om/lev + $oM:M Jhead $at $sc;
 - K: sur/Jhead #c
   D: |
       MZ pwth
       ඬ  shed:eye      {} {co:f85}
       ƾ  jin:oot       {} {co:8ff}
       G  sur/to:G
       Js sur/to:Jung {} {co:68d,fs:5}
 - K: ii/infrom #c
   D: |
     Rw Mn + $n:_ for
     grep{$_}
     ['_', '', {s=>x.j.l}, {co=>'38f'}],
     ['=', '', {}, {fs=>12,co=>'000',sha=>'3 3 3 fff'}],
     x.sc.ori && 
     ['i', '', {s=>x.sc.ori, pi=>'', pwth=>'sur/to:/', gp=>{cv=>0.1}}, {}];
     
     
     if (my $time = x.sc.ts) { # can't be zero, so relative
         Rw ii/time + $time;
     }
     
     if (my $vl = x.sc.travely) {
         Rw ii/travely + $vl;
     }
 - K: ii/travely #
   D: |
     return unless $vl && @$vl;
     Rw Mn + $n:_ for
     ['travely', '', {s=>join(" ",'',@$vl,'')}],
     ['S', '', {pi=>'',s=>x.js,gp=>{cv=>0.2}}];
     
 - K: ii/time #
   D: |
     # say # ago and js hookup increment into human
     my $rtime = sprintf '%.2f', $time - H.uptime;
     # time since H started? since the J started?
     Rw Mn + $n:_ for
     ['zetime', '', {s=>$rtime}, {co=>'33f5'}];
 - K: ii/capstyle ##c
   D: |
       return if J.yaw.ii_capstyle.non;
       
       my $sw = {};
       for (grep {!/^(travely|ori)$/} sort keys %{x.sc}) {
           $sw->{$_} = x.sc->{$_};
       }
       return unless %$sw;
       my $c = {fo=>[$sw,0.7], cow=>'rgb 38f'};
       my $sc = {fs=>26};
       Rw wtf + caps $c;
 - K: ii/cap #c ha zom
   D: |
       # root ^
       # travel v
       # cend pwth
       my $M = [];
       Rw ii/infrom + $M;
       my $at = 0.0001;
       
       Rw ii/capstyle + $M;
       
       Rw Mn $M $n:_ for
       ['<','',{pwth=>'whack'},{fs=>16,co=>'314'}];
       
       #say "ii/cap: ".ki$rr;
       my $t = '/'.x.j.t.'-cap';
       my $sc = {zi=>'3'};
       Rw om/lev + $oM:M $t $at;
 - K: ix/suro #c
   D: |
      my $j = x.j;
      my $coi = Rw pha $J $k:j.l;
      my $M = [];
      
      # innessy
      Rw ii/cap $J $x $M;
      #v v v v v v v
      # v v v v v v
      Rw ii/bod $J $x $M;
      # ^ ^ ^ ^ ^ ^
      #^ ^ ^ ^ ^ ^ ^
      
      say "surM:   ".join ',  ', map{_.t} @$M;
      
      die if !@$M;
      
      Rw om/bal $J $oM:M $t:j.t $in:x.in $out:x.out;
      coi.end->();
 - K: ii/bod #c boodle am $rr into $M: lab,pi, lab,pi ...
   D: |
       my $in = x.in; # TODO whereto?
       my $out = x.out;
       my $phi = ($out - $in) * (x.thi || 2); # normal lines per 0.1
       my $thi = $phi; # oundo big window, bod small
       my $whi = $thi * (x.sc.whim || 2);
       say "bod $in <--> $out  $thi     x.j.r"; # TODO say big
       
       my $o = Rw oundo $thi $whi $x;
       #say "Oundo: ". join ', ', map{"$_"} @{o.r};
       warn "More o.more" if o.more;
       my $M = [];
       for my $r (@{o.r}) {
           r.r || die"nor".ki$r;
           my $oM = [];
           # SZOOOOOOOOOOOM animated, passing landmarks
           
           my $d;
           d.g.x = $x;
           d.g.r = $r;
           
           Rw ii/labegy $d $r $M:oM;
           #v v v v v v v
           # v v v v v v
           Rw ii/pi $d $r $M:oM;
           # ^ ^ ^ ^ ^ ^
           #^ ^ ^ ^ ^ ^ ^
           # ^ pass $thi, pool resources
           
           my $rc = {};
           # whole line magneted styles etc...
           rc.path = r.c.path if r.c.path;
           Rw om/lev + $oM $M $t:r.r $c:rc;
       }
       if (o.more) {
           Rw ii/more $x $o $M;
       }
       Rw iM + $oM:M;
 - K: whack #c the <, smash bit off end of stick
   D: |
     my $o = J.onei;
     if (@{o.t||[]}) {
         die;
     }
     else {
         o.i =~ s/\/[^\/]+$//;
     }
 - K: inness #cc soy packets everywhere # THINGNESS as onness
   D: |
      w mux(u=>$J) if ar.r; # slower reintro - calc entropy
      # right handed receiver of 8s, informs to humm etc.
      # would involve many uish and the types of perception we want to see
      # laying out the plane of attack
      # just has to find a corner of it as 3
      # ^ inject 6
      # but first...
      # t distributable, listy compressible pass space
      J.on = Rw tent on;
      J.on.yy.conroll.dont = 1;
      # ^ recursor... incubator
      # v def
      my $o = J.onei ||= {i=>$G};
      
      
      my $r = ar.r;
      %$o = (i => r.i) if r.i;
      o.t||=[];
      
      if (ref r.t eq 'ARRAY') {
          o.t = [@{r.t}];
      }
      else {
          push @{o.t}, r.t if r.t;
      }
      
      # do this from u%ut, branch climber
      my $i = o.i;
      for my $t (@{o.t}) {
          sayyl "   -trav $i       $t";
          $i = $R->suets($i, $t);
      }
      sayyl "Inness: ".gp(o.i)."     "
        .join("   ", @{o.t})." ----> ".gp $i
            if $i ne o.i;

      # on ventrickles already, look at the path for clues
      # if last t was {bb 55 stylse
      # the tree of loveliness to hook in as things fly by again soon...
      
      # like J.yy.inness.wants to fold back all the uninteresting stuff
      # also show the groups of phases etc
      # styles from on become humming/rounding protocols
      #
      
      J.on bz u 0.1 $i
      J.on bz u%ori 0.1 J.onei.i
      J.on bz u%travely 0.1 J.onei.t
      if (r.sc) {
          for my $k (sort keys %{r.sc}) {
             my $v = r.sc->{$k};
             J.on bz u%$k 0.1 $v
          }
      }
      

