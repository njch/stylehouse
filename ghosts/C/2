R_Jz:
 - K: very #c tak tlv into space, ready for lx/suro
   D: |
       my $lvs = ar.lvs ||= Rw tlv $J;
       
       my $sec = $out - $in; # <-0.8->
       my $thi = $sec / (@$lvs||1); # or indi
       
       # thi of $lv individuality
       my $tin = $in;
       for my $x (@$lvs) {
           # go higher and pipe mods to squish space, vary $thi (other ways to)
           x.thi = $tot * $thi;
           x.phi = $thi;
           x.in = $tin;
           x.out = $tin + $thi;
           $tin = x.out; # next
           # space volve, indi...
           saybl "blbl x.j.r   $tot * $thi =  x.thi    ($tot $sec)";
           
           my $j = x.j;
           if (!J.q) {
               say "up on ".gp($J)."    j.r    ".slim 200, gp(j.s);
               say "   * _.r          => ".gp(_.s) for values %{x.sj};
               say "up around x.in <-> x.out"
           }
       }
       $lvs
       
 - K: onl/cut #c
   D: |
     $scsort||die;
     @$onl = reverse
         sort { a.sc->{$scsort} <=> b.sc->{$scsort} }
         grep { defined _.sc->{$scsort} || die'no %'.$scsort.' on: '._.j.r }
         @$onl;
     my @in;
     my @cut;
     push @{ @in < 4 ? \@in : \@cut }, $_ for @$onl;
     for my $x (@cut) {
         delete J.bb->{_.r} for x.j, values %{x.sj};
     }
     @$onl = @in;
     $onl
     
 - K: waits #c
   D: |
    my $towait = ar.towait || 1;
    my $to = ar.to;
    
    my $max = max map { _.div } @$to;
    _.span = $max / _.div for @$to;
    
    my $tot = sum map { _.span } @$to;
    my $one = $towait / $tot;
    
    my $ord = {};
    for my $t (@$to) {
        my $waits = $one * t.span;
        $waits = sprintf("%.7f", $waits);
        t.waits = $waits;
        push @{ $ord->{$waits} ||= [] }, $t
    }
    return $ord;
    
 - K: inness #cc soy packets everywhere # THINGNESS as onness
   D: |
      w mux(u=>$J) if ar.r; # slower reintro - calc entropy
      
      say "inness of ". gp $J;
      say "r: ".ki ar.r if ar.r;
      J.on ||= Rw tent on;
      J.on.yy.conroll.dont ||= 1;
      
      my $ye = Rw suck + */ines;
      
      return sayre "inness override ".$J->pi if $ye;
      die if J.name =~ /mash/;
      
      # right handed receiver of 8s, informs to humm etc.
      # would involve many uish and the types of perception we want to see
      # laying out the plane of attack
      # just has to find a corner of it as 3
      # ^ inject 6
      # but first...
      # t distributable, listy compressible pass space
      # ^ recursor... incubator
      # v def
      my $o = J.onei ||= {i=>$G};
      my $r = ar.r;
      %$o = (i => r.i) if r.i;
      
      o.t||=[];
      
      if (ref r.t eq 'ARRAY') {
          o.t = [@{r.t}];
      }
      else {
          push @{o.t}, r.t if r.t;
      }
      
      # do this from u%ut, branch climber
      # ^^^ exactly, tip sits around the rim, styles ping flows
      my $i = o.i;
      for my $t (@{o.t}) {
          sayyl "   -trav $i       $t";
          $i = $R->suets($i, $t);
      }
      sayyl "Inness: ".slim(130,gp(o.i))."     "
        .join("   ", @{o.t})." ----> ".slim(130,gp $i)
            if $i ne o.i;

      # on ventrickles already, look at the path for clues
      # if last t was {bb 55 stylse
      # the tree of loveliness to hook in as things fly by again soon...
      
      # like J.yy.inness.wants to fold back all the uninteresting stuff
      # also show the groups of phases etc
      # styles from on become humming/rounding protocols
      #
      
      J.on bz u 0.1 $i
      J.on bz u%ori 0.1 J.onei.i
      J.on bz u%travely 0.1 J.onei.t
      if (r.sc) {
          for my $k (sort keys %{r.sc}) {
             my $v = r.sc->{$k};
             J.on bz u%$k 0.1 $v
          }
      }
      
 - K: whack #c the <, smash bit off end of stick
   D: |
     my $o = J.onei;
     if (@{o.t||[]}) {
         pop @{o.t};
     }
     else {
         o.i =~ s/\/[^\/]+$//;
     }
 - K: pi/infrom #c
   D: |
     my $x = $u;
     Jn('onl', 0.1, "x.j.l", '{co:38f,fs:12}');
     
     Jn('is',0.102,{s=>':',pwth=>'whack'},'{fs:20,co:314,sha:1 1 3 fff}');
     
     Jn('s', 0.11, {pi=>'',s=>x.j.s},'{fs:15}');
     
     
     
     my $in = {%{x.sc}};
     Jn('sc',0.3, {pi=>'scbund',s=>$x},
         {fs=>23 ,co=>'314',sha=>'1 1 3 fff'});
     
     if (my $time = x.sc.ts) { # can't be zero, so relative
         Rw ii/time + $time;
     }
 - K: pi/scbund #c the sc attachment, could go editable + back
   D: |
     my $x = $u;
     Jn(sc => 0.3, ki(x.sc), '{fs:7,co:314,sha:1 1 3 fff}');

     
 - K: ix/suro #c SURO SOMETHING SWIRLS VERY (lvs)
   D: |
      my $j = x.j;
      my $coi = Rw pha $J $k:j.l;
      my $M = [];
      
      # innessy
      # slap Js at various voltages
      # Js that C something
      
      Mn(x.j.l.'-cap' => '',
      {pi=>'infrom',s=>$x,gp=>{cv=>3},pwth=>'intoo'});
      
      #v v v v v v v
      # v v v v v v
      Rw ii/bod $J $x $M;
      # ^ ^ ^ ^ ^ ^
      #^ ^ ^ ^ ^ ^ ^
      
      say "surM:   ".join ',  ', map{_.t} @$M;
      
      die if !@$M;
      
      Rw om/bal $J $oM:M $t:j.t $in:x.in $out:x.out;
      coi.end->();
      sayyl "coi.name got ". keys %{coi.bb};
 - K: oundo #c hound god from a crux of inness $x
   D: |
     my $o = {r=>[]};
     # fills up @r to $thi
     # also $plucky to select hash key order
     # a space for tiny-part-of-huge-set access
     
     my $u = x.j.s;
     my $sc = x.sc;
     
     # $plucky could rate the things it gets passed
     # and the $thi yins up out here
     
     sc.ou ||= 'text' if !ref $u;
     sc.ou ||= 'array' if ref $u eq 'ARRAY';
     sc.ou ||= 'code' if ref $u eq 'CODE';
     sc.ou ||= 'hash';
     
     # further dimensional sc if {} or something?
     # so the spec can curve data all the way
     Rw ou/sc.ou + $u $o $x $sc;
     
     sc.grp &&
     Rw og/sc.grp + $u $o $x $sc;
     
     # $r rows over the contents
     # r.c probably for pi, other stuff may pick stuff up...
     
     o.thi = @{o.r};
     $o
 - K: ii/bod #c boodle am $rr into $M: lab,pi, lab,pi ...
   D: |
       my $in = x.in; # TODO whereto?
       my $out = x.out;
       my $thi = x.thi;
       
       sayyl "x.in - x.out     x.thi";
       
       my $o = Rw oundo $thi $x;
       
       # pha
       # o.dig
       
       my $oM = [];
       for my $r (@{o.r}) {
           defined r.t || die"nor".ki$r;
           next if r.skip;
           my $M = [];
           # SZOOOOOOOOOOOM animated, passing landmarks
           
           Rw ii/labegy $x $r $M;
           #v v v v v v v
           # v v v v v v
           Rw ii/pi $x $r $M;
           # ^ ^ ^ ^ ^ ^
           #^ ^ ^ ^ ^ ^ ^
           # ^ pass $thi, pool resources
           
           my $rc = {};
           # whole line magneted styles etc...
           rc.path = r.c.path if r.c.path;
           Rw om/lev + $oM:M $M:oM $t:r.t $c:rc;
       }
       if (o.more) {
           Rw ii/more $x $o $M:oM;
       }
       Rw iM + $oM;
 - K: ii/pi #c THE WHOLE GHUTS, see d.c.gp ghost plumbing  & d.g.(x|r) for geo sync suro
   D: |
     my $d;
     d.g.x = $x;
     d.g.r = $r;
     d.t = 'pi';
     # structureal elements jump into the pipe lining
     d.c = {%{r.c||{}}};
     d.c.pi ||= '';
     
     d.c.s ||= r.s;
     d.c.gp.cv ||= 0.6;
     
     d.c.path ||= r.path;
       
     d.sc = {%{r.sc||{}}};
     d.sc.ws = 'n';
     d.sc.ab = 'left:0.1em';
     
     Rw iiJM + $d;
 - K: ii/labegy #c suitcase handle # elemental locus of travel/path fields
   D: |
     my $d;
     d.g.x = $x;
     
     d.g.r = $r;
     
     d.t = 'lab';
     
     d.c = {%{r.lab_c||{}}};
     
     d.c.s = r.t;
     d.c.pi ||= 'lab';
     d.c.fsx = "25";
     
     # selection piways
     d.sc = {%{r.lab_sc||{}}};
     d.sc.ws = 'p';
     #d.sc.fs = 30 if x.phi > 0.4;
     #sayyl ki d.g.x;
     
     d.sc.ab = 'right:0.5em'; 
     
     Rw iiJM + $d;
     # the lasty tangvely, sandy mod hooks beVow
 - K: pi/lab #c round corner, where one bit/type/hum of noise splits others
   D: |
     my $r = J.d.g.r;
     Jn(wtf => '', $u, '{zi:15,sha:2 3 6 ccf,fw:16,co:3f4}');
     
 - K: ii/time #c
   D: |
     # say # ago and js hookup increment into human
     my $rtime = sprintf '%.2f', $time - H.uptime;
     # time since H started? since the J started?
     Rw Mn + $n:_ for
     ['zetime', '', {s=>$rtime}, {co=>'33f5'}];
 - K: ii/Jhead #c J _
   D: |
     Rw Jhead;
 - K: Jhead #c
   D: |
       my $M = [];
       my $cv = ar.cv || 0.4;
       
       Mn(name => '', {pi=>'Jname',s=>$J,gp=>{cv=>$cv}});
       
       Mn(Hname => '', "H.name", 
               '{sha:3 5 2 330,co:ff59,fs:12,ab:1,ml:0.3em}')
           if H.name ne 'C';
       
       Mn(X => '', {pi=>'Jkill',s=>$J,gp=>{cv=>$cv}});
       
       Mn(W => '', {s=>'W',pwth=>'Wdo'}, {fs=>'8'}); 

       # TODO collapse upwards button
       
       #Rw Mn $J $n;
       # TODO wtf that onto $M overwrites others
       #Rw wtf $M ITsa 0.03 $s $sc;
       if ($cv > 0.3) {
           Rw the + $M Jhead; 
           Rw the + $M Jim;
           Rw doc $M;
       }
       my $at = ar.out || 0.001;
       my $sc;
       sc.fs = $cv > 0.2 ? 19 : 9;
       Rw om/lev + $oM:M Jhead $at $sc;
 - K: pi/Jkill #c
   D: |
       my $xc = {pwth=>'join/X',s=>'X'};
       my $xsc = {co=>'f34',fs=>'13'};
       if (J.cv < 0.3) {
           #xsc.fs = 14;
           xsc.ab = 'left:0.3em';
           #xsc.zi = 44;
       }
       Jn(x => '', $xc, $xsc);
     
 - K: pi/Jname #c
   D: |
      my $name = u.name;
      ($name, my $soob) = ($1,$2) if $name =~ /^(.+)(-.+?)$/;
      Jn(name => '', "$name", '{sha:3 5 2 330,fs:15}');
      Jn(oob => '', "$soob", '{sha:3 5 2 330,co:a359,fs:6,ml:-0.4em}') if defined $soob;
       

