R_Jz:
 - K: ii/Jhead #c J _
   D: |
       my $at = ar.out || 0.01;
       
       my $M = [];
       
       Rw Mn $n:_ $M for
          ['J', '', {pwth=>'hull/mk:Jself',fo=>[$J,0.1]}];
       Rw the + Jhead $M;
       
       Rw dock $M;
       
       Rw om/lev + $oM:M Jhead $at;
 - K: ix/suro #c
   D: |
      my $j = x.j;
      my $coi = Rw pha $J $k:j.l;
      my $M = [];
      
      # innessy
      Rw sur/bod $x $M;
      #v v v v v v v
      # v v v v v v
      Rw ii/cap $x $M;
      # ^ ^ ^ ^ ^ ^
      #^ ^ ^ ^ ^ ^ ^

      say "surM:   t:_.t    y:".ki(_.y)."        c:".ki(_.c)."       sc:".ki(_.sc) for @$M;
      die if !@$M;
      my $V = 1;
      Rw om/bal $J $oM:M $t:j.t $in:x.in $out:x.out $V;
      coi.end->();
 - K: ii/cap #c ha zom
   D: |
       my $vli = x.sc.ori || die;
       
       my $N = [
           ['_', '',         {s=>x.j.l}, {co=>'38f'}],
           ['=', '',         {}, {fs=>12,co=>'000',sha=>'3 3 3 fff'}],
           ['i', 'sur/to:/', {fo=>[x.sc.ori,0.4]}],
       ];
       if (x.sc.travely && @{x.sc.travely}) {
           my $s = " ".join(" ",@{x.sc.travely})." ";
           push @$N,
               ['travely', '', {s=>$s, wsp=>1}],
               ['S',       '', {fo=>[x.j.s, 0.2]}],
       }
       
       my $M = [];
       # cend pwth
       Rw MyN $N $M pwth;
       
       Rw ii/capstyle + $M;
       
       #say "ii/cap: ".ki$rr;
       my $t = x.j.t.'-cap';
       Rw om/lev + $oM:M $t;
 - K: ii/capstyle #c
   D: |
       my $sw = {};
       for (grep {!/^(travely|ori)$/} sort keys %{x.sc}) {
           $sw->{$_} = x.sc->{$_};
       }
       return unless %$sw;
       my $c = {fo=>[$sw,0.7], cow=>'rgb 38f'};
       Rw wtf + caps $c;
 - K: sur/bod #c boodle am $rr into $M: lab,pi, lab,pi ...
   D: |
       my $in = x.in; # TODO whereto?
       my $out = x.out;
       my $phi = ($out - $in) * x.thi; # normal lines per 0.1
       my $thi = $phi * 2; # oundo big window, bod small
       
       say "bod $in <--> $out  $thi     x.j.r"; # TODO say big
       
       my $o = Rw oundo $thi $x;
       say "Oundo: ". join ', ', map{"$_"} @{o.r};
       warn "More o.more" if o.more;
       my $M = [];
       for my $r (@{o.r}) {
           r.r || die"nor".ki$r;
           my $oM = [];
           # SZOOOOOOOOOOOM
           Rw ii/labegy $x $r $M:oM;
           Rw ii/pi $x $r $M:oM;
           # ^ pass $thi, pool resources
           
           my $c = {%{r.c||{}}};
           #sayyl "iibod: ". ki $r;
           
           
           Rw om/lev + $oM $M $t:r.r $c;
       }
       if (o.more) {
           Rw ii/more $x $o $M;
       }
       Rw iM + $oM:M;

