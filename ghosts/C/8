R_surz:
    - K: chr0 #c
      spesh: 1
      babz:
         'S 4.01': |
           for my $i (1..10) {
               my $c;
               for my $ii (1..25) {
                   $c = 250 + ($i * 100) + $ii;
                   my $ch = unico($c);
                   a.bz->("ch_$c 3.011" , $ch);
               }
               a.bz->("ch_${c}_nl 3.011" => "\n");
           }
    - K: forkpi #c
      spesh: 0
      spesh_D: |
        H.name eq "O" || $DB::sub # perl -dw cannot fork # websockets cannot fork?
      babz:
        'gp#fork_layert 5.6': | 
            if (a.cv > 0.2 && !a.replaceJid && !a.q && $wa ne 'text') {
                my $la = {%$a};
                a.isJid = la.replaceJid = $H->mkuid;
                my $lyt = R.lastS.layert ||= [];
                push @$lyt, $la;
                a.forking = $la;
                a.cv = 0.1;
            }
        'S#waylayert_pias 8.8': |
            if (my $pias = delete S.layert) {
                # my $it = natatime 5, @$pias;
                # TODO they come back out of order of attachment 
                # fork only the top level pi, not pi within pi?
                $G->timer(0, sub {
                    w $R forkpi/pias[$S, $pias];
                });
            }
        'gp 6.2': |
            R.lastS.a.pis->{a.isJid} = $a; # TODO J pass over # maka suction
        'gp 7.1': |
            a.forking.wash = $H->dig($html) if a.forking;
        'S#tidy 0.113': |
            if (my $tokill = delete S.forkpi_tokill) {
                kill 'KILL', $_ for @$tokill;
            }
      n_D:
        pias: |
            if (my $pid = fork()) {
                my $Sftk = S.forkpi_tokill ||= [];
                push @$Sftk, $pid;
                return
            }
            H.db = H.pg->db;
            H.isforked = 1;
            # child must exit, after reporting error
            # so nothing else can happen. listening db handle gone anyway?
            my $bail = sub{ exit };
            $G->accum($G0, _aft_err_do => $bail);
            $G->accum($F[0], _aft_etc_do => $bail);
            
            sayyl "pier Forked... ";
            
            my @js;
            my $group = 3;
            for my $a (@$pias) {
                my $html = w $R gp[$a];
                next if a.wash eq $H->dig($html);
                my $set = $H->ejson($html);
                my $id = a.replaceJid || die;
                my $js = qq{ \$('#$id').replaceWith($set);};
                push @js, $js;
                if (@js >= $group) {
                    $H->send(join('', @js));
                    @js = ();
                }
            }
            $H->send(join '', @js) if @js;
            saygr "pier done ".F_delta;
            
    - K: playn #c
      babz:
        'S 3.1131': |
          if (S.mod.outlike) {
              a.bz->('a 4' => a.i, '%ishtml'=>1);
              #$R->dfrom({u=>a.bb, s=>a.i});
              last Sguts;
          }
        'S 2.514333': |
          if (S.mod.double) { # 
              saybl "YEYEYE";
              if (ref a.i eq 'ARRAY') {
              saybl "YEYEYELLLLLLLLLo";
                  a.i = a.i->[2];
              }
          }
          
        'S 3.214': |
          if (S.mod.double) { # 
              my $an = {u=>a.i, cv=>0.8, q=>1};
              my $jo = w $R gp(a=>$an);
              my $anH = {u=>a.i, cv=>0.8, q=>1, wa=>'HASH2'};
              my $j = w $R gp(a=>$anH);
              
              my $something = {
                  #%{an.bb},
                  %{anH.bb},
              };
              
              my $name = S.name.".";
              my $ano = {
                  Dname=>$name.'1', i=>{%{anH.bb}},
              };
              w Dave(%$ano);
              
              my $anm = {
                  Dname=>$name.'2', i=>{%{an.bb}},
              };
              w Dave(%$anm);
              
              my $anc = {
                  Dname=>$name.'3', i=>$j, Sup => {mood=>{outlike=>1}},
              };
              w Dave(%$anc);
              
          }

