R_Jz:
 - K: ii/standingtext #c
   D: |
     # find standing waves, columns with something there all the way down
     Rw doc $m $d
 - K: doc #c dock swampdoctor
   D: |
     if (H.name eq 'D') {
        sayre"AVOIDING DOC SELF" for 1..3;
        return "";
     }
     my $m = ['doc'];
     my $meta = H.G w mJ[$m];
     
     my $or = {%$ar};
     or.G = $G->pi;
     or.R = (delete or.R)->pi;
     my $en = wdump($or);
     $en =~ s/^\s+//sgm;
     
     $m = {};
     m.Fscrape = Rw oc/Fscrape;
     my $f = $F[0];
     m.ar = join',',sort keys %{f.ar};
     m.en = $en;
     H.G w emana[$meta,$m];
     
     # J up zee, store in G.swamp here
     # spurt swamp zip & cargo
     # someone asks this Hid (sleep mode)
     # availing benignities before and after the fact)
 - K: oc/Fscrape #c to drag tthrough pipe
   D: |
     my @fs;
     my @iF = @F;
     shift @iF for 1..2;
     for my $F (@iF) {
         my $f;
         f.K = F.K;
         f.point = F.point;
         if (!@fs) {
             G.doc.Fknow->{F.id} = $F;
         }
         f.id = F.id if G.doc.Fknow->{F.id};
         f.id ||= '?'; # tracable from near id
         f.intr = {map{$_=>gp(F.intr->{$_})}keys %{F.intr}} if F.intr;
         
         push @fs, $f;
     }
     \@fs
 - K: oc/exit #c listen to swamp
   D: |
     my $y = 'doc';
     my $l = sub {
         sayyl "DOC         slwing $y =>  :::: $_[0]";
         my $m = shift;
         Rw oc/exity $J $m;
     };
     $G->ily($y, $l);
       
 - K: oc/exity #c have exit
   D: |
     sayyl "DOC GOT $m";
     my $ci = djson $m;
     my $cc = $G->tri("ci.y/ci.id\.c");
     $H->fixutf8($cc);
     my $cd = djson $cc;
     
     J.ocexitv ||= -0.1;
     J.ocexitv += 0.2;
     J.ocexitv = 0.1 if J.ocexitv > 1;
     my $at = J.ocexitv;
     
     
     Rw oc/one $J $cd $at;
     
     my $Ft = cd.Fscrape;
     my $path = join "/", map {_.point} grep{_.K =~ /^D/} reverse @$Ft;
     sayyl wdump 5, $cd;
     #Rw ii/pi $x $r $M:oM;
     my $s = "A trace... $path";
     Rw wtf + tthin $at $s;
     
     w mux(u=>$J);
       
 - K: oc/one #c
   D: |
     my $x;
     x.in = $at;
     x.out = $at + 0.18;
     Rw ix/suro + $x;

