
R_surs:
    keys: | #c
      my $k = e.k;
      my $R = w are;
      
        sayyl join"  ", ($k) x 13 for 1..2;

        my $key = "$k";
        $key = "S$key" if e.S;
        # some instyle hooks letters to apply
        my $cuz = R.way->find("key")||die;
        # 3
        my $do = $cuz->{$key};
        # 4
        $do ||= do {
            my $or = "number" if $key =~ /[0-9]/;
            $cuz->{$or} if $or;
        };
        # 5
        # 5.9
        $do ||= "wtf";
        #w unchanged[$R] if $do eq "wtf";
        sayyl join"  ", ($do) x 13 for 1..2;
        # 6
        ar.k = $k;
        w $R $do(%$ar);
    E: | #c event
      #ay wdump(2, $ar);
      
      my $id = e.id;
      sayyl "ID: $id";
      my $pi = R.a.pis->{$id};
      my ($gpl) = grep {R.a.bb->{$_} eq $pi} keys %{R.a.bb};
      my $k = $1 if $gpl =~ /^(\d+)/;
      if (!defined $k) {
          sayre "nothing to";
          return unless $pi;
          ar.i = $pi;
          w are;
          w $R Sud/in;
          return;
      }
      w are;
      w $R Num/in[$k, $S];
      
      
      
    setup: | #c
        w $R goto/H if !S.J;
        R.S.e = 0.6;
        
        R.S.ss_Ds = Load(<<'');
                  n: |
                     n.HASH = {};
                  Ai: |
                     Ai.A = {};
                  Gi: |
                     my $likes = {map{$_=>1}qw{G ways}};
                     Gi.HASH = {
                      it => sub {
                        my $h = shift;
                        my @r = map { { K=>$_, k=>"{".$_, v=>$h->{$_} } } sort keys %$h
                      },
                     };
        
        if (my $ssDs = delete R.S.ss_Ds) {
            for my $k (sort keys %$ssDs) { # or K array who knows
                my $u = R.S.ss->{$k} = w $R dus;
                my $D = $ssDs->{$k};
                $G->D({bab=>$D, ar=>{$k=>$u}});
            }
        }
        
        say "Made ".$R->pi;
        #w R.S.w $_/in({}) for keys %{R.S.w};
    
    shj: | #c
      my $j;
      j.r = $r;
      j.s = $d->{$r};
      (j.t, j.cv) = j.r =~ /^(.+)\t(.+?)$/ ? ($1, $2) : split /\s+/, j.r, 2;
      (j.cv, my @e) = split /\s+/, j.cv;
      j.ev = \@e if @e;
      $j
    
    
    as: | #c
        my $j = {};
        my $ord = ar.ord;
        my $do;
        $do = sub {
            my $j = {%$j};
            my $ad = [@_];
            my %j = %$j;
            while (@$ad) {
                my ($k, $v) = (shift @$ad, shift @$ad);
                
                my $comp = $k =~ /^(%|\+)/;
                my $j = {%j} if $comp;
                if ($comp) {
                    $k =~ s/^\+// if $comp;
                    j.t .= $k if $comp;
                }
                else {
                    (j.t, j.cv) = split /\s+/, $k, 2;
                    %j = %$j;
                }
                j.cv || die;
                j.r = "j.t j.cv";
                j.s = $v;
                $bb->{j.r} = j.s;
                push @$ord, $j if $ord;
            }
            sub{$do->(%$j, @_)}
        };
        $do
    gpfro: | #c
      my ($aser, $l, $u, $cv, @etc) = @$a;
      
      my $gp = {u=>$u, cv=>$cv};
      if (ref gp.cv) {
          my $mcv = delete gp.cv;
          %$gp = (%$gp, %$mcv);
      }
      my $v = w $R gp(a => $gp);
            
      $aser->($l => $v,
          '%gp' => $gp,
          @etc,
      );
    
    phat: | #c
        a.bb = {};
        a.ord = [];
        a.bz = w $R as(bb=>a.bb, ord=>a.ord);
        a.fro = sub {
            my $fro = [a.bz, @_];
            w $R gpfro(a=>$fro);
        };
    cgp: | #c data guess chart
        my $c = {};
        if (!defined $u){
            c.undef = 1;
        } else {
            if (my $ref = ref $u) {
                c.ARRAY = 1 if $ref eq "ARRAY";
                c.HASH = 1 if $ref eq "HASH";
                c.CODE = 1 if $ref eq "CODE";
                c.canpi = 1 if !%$c && $u->can('pi');
                for (qw'A C G T     R   J') {
                      $c->{$_} = 1 if $ref eq $_;
                }
                c.ref = $ref;
            }
            else {
                if (ref \$u eq 'SCALAR') {
                    c.text = 1;
                    c.len = length($u);
                    c.lin = scalar split /\n/, $u;
                    c.b = scalar split /\n\n/, $u;
                    c.number = $u =~ /^(?:\d+\.)?\d+$/;
                    c.wordy = $u =~ /\w+/;
                }
                else { die "wtf is $u" };
            }
        }
        $c
    gp: | #c R_sur gp
        G.gp_inarow++;
        my $a = ar.a || {};
        a.cv = ar.cv if ar.cv;
        a.u = ar.u if ar.u;
        a.cv = 0.1 if a.cv < 0.1;
        a.isJid = a.replaceJid || $H->mkuid;
        undef a.isJid if G.gp_inarow > 1;
        my $u = a.u;
        
        # 3
        $R->phat($a);
        my $c = $R->cgp($u);
        
        my $arr = {
            a => $a, # @_
            u => $u,
        };
        
        # 4
        my $wa;
        if ($wa = a.wa) {
            # yep
        }
        else {
            ($wa) = grep { $c->{$_} } qw'canpi ARRAY HASH ref undef text';
            $wa = ref $u if $wa eq 'canpi';
            $wa ||= 'wtf';
        }
        
        if (c.canpi) { # supply $self
            my $ref = ref $u;
            $arr->{$ref} = $u if $ref ne 'G' && $ref ne 'R';
        }
        R.way->find("pi/$wa") || die "not $wa equip";
        my $ping = 1;
        
        # 5

        # 6
        w $R pi/$wa(%$arr) if $ping;
        
        # 7
        my $html = w $R makaout(%$arr);
        
        # 8
        
        # 9
        G.gp_inarow--;
        my $ind = join "", ("  ") x scalar @F;
        #sayyl "$ind Done gp for $u ".F_delta;
        $html
        
    wind: | #c
      my $s = 9;
      return 1..$s if $si <= $s;
      my $wind = $si - 9;
      my $from = 6;
      my $for = 3;
    
      my @i;
    
            my $la = $wind / $for;
            my $za = int $la;
            
            my $y;
            my @wind = 1..$wind;
            my @ys = $from..$from+$for-1;
            my $yi = 0;
            while (@wind) {
                my $win = shift @wind;
                
                my $at = $ys[$yi];
                $y->{$at}++;
                
                $yi++;
                $yi = 0 if !exists $ys[$yi];
            }
            
            for my $wi (1..$s) {
                
                if (my $la = $y->{$wi}) {
                    my @la = 1..$la+1;
                    for my $pl (@la) {
                        push @i, "$wi$pl";
                    }
                }
                else {
                    push @i, $wi;
                }
            }
            
            @i
            
  
    dus: | #c
        my $h = {
          ARRAY => {
            it => sub {
              my $h = shift;
              my $i = 0;
              map { { k => "[".$i++, v => $_ } } @$h
            },
            oh => 0,
          },
          HASH => {
            it => sub {
              my $h = shift;
              map { { K=>$_, k=>"{".$_, v=>$h->{$_} } } sort keys %$h
            },
          },
        };
        my $an = sub {
            my $k = shift;
            my $i = $h->{$k} ||= {it => h.HASH.it};
            %$i = (%$i, @_);
        };
        # make so 1.2 means if e>=0.5 traverse with e-=0.2
        # drops 1 every traversal too...
        # cept for sometimes when there's a deeper number in e
        # saying from above via style schema how to curle around
        # the 1-9, wherever
        # then anomalies are mapped with names & meaning in stylegrab 78
        
        $an->(qw'A oh 0.2');
        $an->(qw'C oh 0.2');
        $an->(qw'G oh 0.2');
        $an->(qw'T oh 0.2');
        $an->(qw'R oh 0.2');

        $an->(qw'W oh 0.2 mustb','id,hash,file,G');
        $h
    du: | #c style grab
      $a || die;
      my $R = a.R;
      defined a.i || die;
      # how to get around the Objs' data
      my $s = a.s ||= w $R dus;
      my $i = a.i;
      my $n = a.n;
      a.e = 2 if !defined a.e;
      
      my $c = {};
      a.as ||= [];
      push @{a.as}, $a;
      a.ds = [@{a.ds||[]}, $a];
      
      return {} if @{a.ds} > 12 || 2 < grep {ref _.i && _.i eq $i} @{a.as};
      
      my $ref = ref $i || 'SCALAR';
      my $is = $s->{$ref} || $s->{default};
      $is ||= $s->{HASH} if "$i" =~ /^\w+=HASH\(/;
      $is ||= $s->{default} || return {};
      
      for my $j (is.it->($i)) {
          my $k = delete j.k;
          my $K = delete j.K;
          my $v = delete j.v;
          
          $j = {%$is, %$j};
          
          my $ohms = defined j.oh ? j.oh
              : defined is.oh ? is.oh
            : 1;
          
          my $an = {%$a, i => $v};
          an.e -= $ohms;
          
          my $rk = join "\t", $k, an.e;
          
          $c->{$rk} = $v;
          
          a.tr.rows++;
          last if a.tr.rowlimit && a.tr.rows >= a.tr.rowlimit;
          
          if (an.e >= 1 && ref an.i) {
              my $cu = w $R du(a=>$an);
              while (my ($ku, $vu) = each %$cu) {
                  my $nk = $k.$ku;
                  next if grep { $_->($_, $an, $cu) } @{s.notZ||[]};
                  $c->{$nk} = $vu;
              }
          }
      }
      
      # this is about a 4 - material for links
      $c
      
    S: | #c void R_surcess R::S heist
        # 0.1
        saygr "for ".$S->pi;
        my $a = R.a = ar.a ||= {};
        a.R = $R;
        w $R phat;
        
        # 9.9
        saygr " S --- ".F_delta;
        $html
    makaout: | #c
        my $cv = ar.cv;
        $cv = a.cv if !defined $cv;
        
        if (my $id = a.isJid || a.replaceJid) {
            a.bz->('/%id 0.1', $id);
        }
        # 4
        my @r = w stylekeysort(d=>a.bb);
        
        # 4.1
        a.o = {}; # by voltage, peel
        for my $r (@r) {
                my ($l, $vo, $or) = split /\s+/, $r; # split style, vectory
                
                saygr "igggy $l $vo > a.cv" && next if $cv && $vo > $cv;
                
                $or = $vo if !defined $or;
                
                my $o = a.o->{$or} ||= []; 
                push @$o, $r;
        }
        
        # 4.2
            
            #thingness <-> appearance
            my $th = {};
            my $ap = {};
            my @int;
            for my $ov (sort keys %{a.o}) {
                 my $o = a.o->{$ov};
                 
                 for my $r (@$o) {
                     my $j = $R->shj($r, a.bb);
                     (j.l, my $style) = split '%', j.t;
                     
                     $style ? do {
                         j.style = $style;
                         push @{$ap->{j.l} ||= []}, $j;
                     } : do {
                          warn "replacemont j.l " if exists $th->{j.l};
                         $th->{j.l} = $j;
                         push @int, j.l;
                     }
                }
            }
            
        # 7
        my $apl = sub {
            my ($l, $s) = @_;
            
                my $o = delete $ap->{$l};
                
                
                die "reffy $s in $l" if ref $s;
                sayyl "for the $l\t\t$s" if ar.db;
                
                my $ishtml = $l eq '/';
                my $gp;
                my $at = {};
                my $tag = "aÃ±";
                my $css = [];
                for my $oj (@$o) {
                    saybl "        sdtyle! oj.style oj.s" if ar.db; 
                    
                    if (oj.style eq "css") {
                        push @$css, oj.s;
                    }
                    elsif (oj.style eq "gp") {
                        # has a way to $a the gp action within...
                        $gp = oj.s;
                        $ishtml = 1;
                    }
                    elsif (oj.style eq 'id') {
                        at.id = oj.s;
                    }
                    elsif (oj.style eq "sf") {
                        push @$css, map { $R::f->{$_} || 
                        die "no style $_"} split '_', oj.s;
                    }
                    elsif (oj.style eq 'tag') {
                        $tag = oj.s;
                    }
                    else {
                        die "style oj.style = oj.s \t for $l";
                    }
                }
                
                at.style = join ';', @$css;
                ##G.shtuuyle->{at.style}++;
                # 7.6
                # 7.7
                #at.title = $l;
                $at = join " ", map { $_.'="'.$at->{$_}.'"' }
                    grep { $at->{$_} } sort keys %$at;
                if (!$ishtml) {
                    $s = encode_entities($s);
                    $s =~ s/\\n/\n/g;
                    die if $s =~ /\\n/;
                }
                $s = "<$tag $at>$s</$tag>" if defined $s;
                $s
        };
        my @s;
            for my $thl (@int) {
                my $j = $th->{$thl} || next;
                #say "$thl ".wdump($o) if !G.gp_inarow;
                my $l = j.l;
                my $s = j.s;
                die "$l  -- $thl" if $thl ne $l;
                
                # top volt for thing selection: # whattage
                if ($l eq 'K' && a.bb->{"name 0.1"} =~ $s
                 || $l eq 'name' && a.bb->{"K 0.2"} =~ $s
                 && $s ne a.bb->{"K 0.2"}) {
                    delete $ap->{$l};
                    next;
                }
                    
                push @s, $apl->($l, $s);
            }
            
            @s = "no?" if !@s;
            my $html = $apl->('/', join '', @s);
            
            
            if (%$ap) {
                sayre "Extr a appearance: ".wdump($ap);
            }
            
            #die "nose? $u" if !@s;
            #sayyl join "  ", map { _.G.name .": _.point _.id" } grep {_.name eq 'D'} reverse @F;
            $html;
            
            

