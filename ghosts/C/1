
R_surs:
    keys: | #c
      my $k = e.k;
      my $R = w are;
      
      sayyl join"  ", ($k) x 13 for 1..2;

      my $key = "$k";
      $key = "S$key" if e.S;
      # some instyle hooks letters to apply
      my $cuz = R.way->find("key")||die;
      
      my $do = $cuz->{$key};
      
      $do ||= do {
          my $or = "number" if $key =~ /[0-9]/;
          $cuz->{$or} if $or;
      };
      
      $do ||= "wtf";
      sayyl join"  ", ($do) x 13 for 1..2;
      
      ar.k = $k;
      w $R $do(%$ar);
    setup: | #c
        S.S.e = 0.6;
        # 3
        # 4
        # 5
        say "Made ".$R->pi;
        #w R.S.w $_/in({}) for keys %{R.S.w};
    
    gpfro: | #c
      my ($aser, $l, $u, $cv, @etc) = @$a;
      
      my $gp = {u=>$u, cv=>$cv};
      if (ref gp.cv) {
          my $mcv = delete gp.cv;
          %$gp = (%$gp, %$mcv);
      }
      my $v = w $R gp(a => $gp);
            
      $aser->($l => $v,
          '%gp' => $gp,
          @etc,
      );
    
    gp: | #c R_sur gp
        G.gp_inarow++;
        my $a = ar.a || {};
        a.cv = ar.cv if ar.cv;
        a.u = ar.u if ar.u;
        # usuall comes in on a:
        %$a = (%$a, %{delete a.cv}) if ref a.cv; # sneak params in
        a.cv = 0.1 if a.cv < 0.1;
        
        my $u = a.u;
        my $arr = {a => $a, u => $u};
        
        
        # 3
        $R->phat($a);
        
        a.isJid = a.replaceJid || $H->mkuid;
        undef a.isJid if G.gp_inarow > 1;
        
        my $c = $R->cgp($u);
        
        # 4
        my $wa = a.wa || do {
            my ($wa) = grep { $c->{$_} } qw'canpi ARRAY HASH ref undef text';
            $wa = ref $u if $wa eq 'canpi';
            $wa ||= 'wtf';
            $wa
        };
        R.way->find("pi/$wa") || die "not $wa equip";
        
        # 5

        # 6
        #saybl wdump(2, $arr);
        w $R pi/$wa[$a,$u];
        
        # 7
        my $html = w $R maka[$a,$u];
        # don't need to close it up right now...
        # top down injection gos
        
        
        # 8
        
        # 9
        G.gp_inarow--;
        my $ind = join "", ("  ") x scalar @F;
        #sayyl "$ind Done gp for $u ".F_delta;
        $html
        
    dus: | #c
        my $h = {
          ARRAY => {
            it => sub {
              my $h = shift;
              my $i = 0;
              map { { k => "[".$i++, v => $_ } } @$h
            },
            oh => 0,
          },
          HASH => {
            it => sub {
              my $h = shift;
              map { { K=>$_, k=>"{".$_, v=>$h->{$_} } } sort keys %$h
            },
          },
        };
        my $an = sub {
            my $k = shift;
            my $i = $h->{$k} ||= {it => h.HASH.it};
            %$i = (%$i, @_);
        };
        # make so 1.2 means if e>=0.5 traverse with e-=0.2
        # drops 1 every traversal too...
        # cept for sometimes when there's a deeper number in e
        # saying from above via style schema how to curle around
        # the 1-9, wherever
        # then anomalies are mapped with names & meaning in stylegrab 78
        
        $an->(qw'A oh 0.2');
        $an->(qw'C oh 0.2');
        $an->(qw'G oh 0.2');
        $an->(qw'T oh 0.2');
        $an->(qw'R oh 0.2');

        $an->(qw'W oh 0.2 mustb','id,hash,file,G');
        $h
    du: | #c style grab # goner
      $a || die;
      my $R = a.R;
      defined a.i || die;
      # how to get around the Objs' data
      my $s = a.s ||= w $R dus;
      my $i = a.i;
      my $n = a.n;
      a.e = 2 if !defined a.e;
      
      my $c = {};
      a.as ||= [];
      push @{a.as}, $a;
      a.ds = [@{a.ds||[]}, $a];
      
      return {} if @{a.ds} > 12 || 2 < grep {ref _.i && _.i eq $i} @{a.as};
      
      my $ref = ref $i || 'SCALAR';
      my $is = $s->{$ref} || $s->{default};
      $is ||= $s->{HASH} if "$i" =~ /^\w+=HASH\(/;
      $is ||= $s->{default} || return {};
      
      for my $j (is.it->($i)) {
          my $k = delete j.k;
          my $K = delete j.K;
          my $v = delete j.v;
          
          $j = {%$is, %$j};
          
          my $ohms = defined j.oh ? j.oh
              : defined is.oh ? is.oh
            : 1;
          
          my $an = {%$a, i => $v};
          an.e -= $ohms;
          
          my $rk = join "\t", $k, an.e;
          
          $c->{$rk} = $v;
          
          a.tr.rows++;
          last if a.tr.rowlimit && a.tr.rows >= a.tr.rowlimit;
          
          if (an.e >= 1 && ref an.i) {
              my $cu = w $R du(a=>$an);
              while (my ($ku, $vu) = each %$cu) {
                  my $nk = $k.$ku;
                  next if grep { $_->($_, $an, $cu) } @{s.notZ||[]};
                  $c->{$nk} = $vu;
              }
          }
      }
      
      # this is about a 4 - material for links
      $c
      
    S: | #c void R_surcess R::S heist
        # 0.1
        saygr "for ".$S->pi;
        my $a = S.a = ar.a ||= {};
        $R->phat($a);
        
        # 3
        Sguts: {
        
        # 6
        }
        
        # 9.9
        saygr " S --- ".F_delta;
        $html

