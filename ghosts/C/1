R_Jz:
 - K: ou/dire #c
   D: |
     my $we = $u;
     ref $u && die "ref $u";
     -d $we || die "not found: $we pwd=".`pwd`;
     
     my $j = x.j;
     Rw cruxal $x lala wagga;
     
     for (glob("$we/*")) {
         $H->fixutf8($_);
         my $r;
         die "un: $_" unless $_;
         r.r = $_;
         r.r =~ s/^$we\///;
         r.s = r.r;
         r.c.path = "/r.r";
         r.c.pi = 'dire';
         r.c.file = $_;
         push @{o.r}, $x;
         saygr wdump ($r);
     }
 - K: cruxal #c
   D: |
     my $j = x.j;
     my $J = j.b.b.j;
     my ($k,$v) = @$m;
     J.bz->("j.l%".$k." j.cv", $v);
 - K: oundo #c hound god from a crux of inness $x
   D: |
     my $o = {r=>[]};
     # fills up @r to $thi
     # also $plucky to select hash key order
     # a space for tiny-part-of-huge-set access
     
     my $u = x.j.s;
     my $sc = x.sc;
     
     # $plucky could rate the things it gets passed
     # and the $thi yins up out here
     if (sc.ou) {
         # further dimensional sc if {} or something?
         # so the spec can curve data all the way
         Rw ou/sc.ou $u $o $x $sc;
     }
     elsif (!ref $u) {
         o.type = 'text';
         push @{o.r}, { r=>"text", s=>$u, cv=>0.4 };
     }
     elsif (ref $u eq 'ARRAY') {
         o.type = 'ARRAY';
         o.total = @$u;
         my $i = 0;
         until (@{o.r} >= $thi) {
             if (!exists $u->[$i]) {
                 last;
             }
             
             my $v = $u->[$i];
             # $plucky
             push @{o.r}, { r=>$i, path=>"[".$i, s=>$v };
             
             if (@{o.r} >= $thi) {
                 o.more = @$u - @{o.r};
                 delete o.more if !o.more;
                 last;
             }
             $i++;
         }
     }
     elsif (ref $u eq 'CODE') {
          die;
          o.type = 'CODE';
          push @{o.r}, { r=>"CODE", clues=>{stuff=>"fromDm?"} }
     }
     else {
         my @ks = sort keys %$u;
         o.total = @ks;
         until (@{o.r} >= $thi) {
             if (!@ks) {
                 last;
             }
             
             my $k = shift @ks;
             my $v = $u->{$k};
             # $plucky # could be R coded small lmaz
             # can meet slightly more and select best
             # nothing is too worthy
             push @{o.r}, { r=>$k, path=>"{".$k, s=>$v };
             
             if (@{o.r} >= $thi) {
                 o.more = @ks if @ks;
                 last;
             }
         }
         # bunch of keys... ^ interpret, compress knowledge
         # TODO ^make itv like two indexes, polars
         # any sorta layout knowhow...
     }
     o.thi = @{o.r};
     $o
 - K: pi/dire #c
   D: |
     my $emb = 'ğ˜' if -d 

