R_Jz:
 - K: cruxal #c
   D: |
     my $j = x.j;
     my $J = j.b.b.j;
     my ($k,$v) = @$m;
     J.bz->("j.l%".$k." j.cv", $v);
 - K: ii/labegy #c suitcase handle # elemental locus of travel/path fields
   D: |
     my $d = {%{ar.d||{}}};
     d.t = 'lab';
     say "lab r.r  also: ".ki $r;
     d.c.s = r.r;
     d.c.pi = 'lab';
     d.c.fsx = "25";
     # selection piways
     d.sc.ws = 'p';
     d.sc.ab = 'right:0.5em';
     Rw iiJM + $d;
 - K: pi/lab #c round corner, where one bit/type/hum of noise splits others
   D: |
     #J.d.sc.bo = '3px solid white';
     my $s = $u;
     my $ex;
     if (J.d.g.r.c.file) {
         $s =~ s/\.(\w+)$//;
         $ex = $1;
     }
     if (defined $s) {
         my $c = {s=>$s};
         my $sc ={zi=>15, sha=>'2 3 6 ccf',
            fw=>6, co=>'3f4'};
         Rw wtf $J lab $c $sc;
     }
     if (defined $ex) {# TODO this huge beingness faster
         my $sc = {co=>'000',sha=>'2 3 4 ccf', 
             ab=>1,right=>'0.4em',top=>'0.5em',
            fs=>8,zi=>'3'};
         Rw wtf $J ex $s:ex $sc;
     }
     
 - K: pi/labback #c round corner, where one bit/type/hum of noise splits others
   D: |
     #J.d.sc.bo = '3px solid white';
     my $s = $u;
     my $sc = {};
     sc.rad = $RADIAN * 2;
     sc.fw = 3;
     sc.fs = 12;
     sc.ab = 1;
     sc.right = '1.4em';
     sc.sha = '3 3 5 12f';
     Rw wtf $J lab 3 $s $sc;
     
 - K: pi/lablfa # round corner + backflip...
   D: |
     my $s = $u;
     my $sc = {};
     sc.rad = $RADIAN * 2;
     sc.fw = 4;
     sc.fs = 12;
     sc.ab = 1;
     sc.left = '1.4em';
     sc.sha = '3 3 5 12f';
     Rw wtf $J lab 3 $s $sc;
 - K: oundo #c hound god from a crux of inness $x
   D: |
     my $o = {r=>[]};
     # fills up @r to $thi
     # also $plucky to select hash key order
     # a space for tiny-part-of-huge-set access
     
     my $u = x.j.s;
     my $sc = x.sc;
     
     # $plucky could rate the things it gets passed
     # and the $thi yins up out here
     
     sc.ou ||= 'text' if !ref $u;
     sc.ou ||= 'array' if ref $u eq 'ARRAY';
     sc.ou ||= 'code' if ref $u eq 'CODE';
     sc.ou ||= 'hash';
     
     # further dimensional sc if {} or something?
     # so the spec can curve data all the way
     Rw ou/sc.ou + $u $o $x $sc;
     
     sc.grp ||= 'ref';
     Rw og/sc.grp + $u $o $x $sc;
     
     # $r rows over the contents
     # r.c probably for pi, other stuff may pick stuff up...
     
     o.thi = @{o.r};
     $o
 - K: og/ref #c mix up @{o.r}
   D: |
     my $ac = {};
     for my $r (@{o.r}) {
         my $s = ref r.s;
         acum $ac, $s, $r;
     }
     my @r;
     for my $s (sort keys %$ac) {
         my $v = $ac->{$s};
         push @r, @$v;
     }
     o.r = \@r;
 - K: ou/text #c
   D: |
     o.type = 'text';
     push @{o.r}, { r=>"text", s=>$u, cv=>0.4 };
 - K: ou/hash #c
   D: |
      
      my @ks = sort keys %$u;
      o.total = @ks;
      until (@{o.r} >= $thi) {
          last if !@ks;
          my $k = shift @ks;
          my $v = $u->{$k};
          # $plucky # could be R coded small lmaz
          # can meet slightly more and select best
          # nothing is too worthy
          push @{o.r}, { r=>$k, path=>"{".$k, s=>$v };

          if (@{o.r} >= $thi) {
              o.more = @ks if @ks;
              last;
          }
      }
      # bunch of keys... ^ interpret, compress knowledge
      # TODO ^make itv like two indexes, polars
      # any sorta layout knowhow...
 - K: ou/array #c
   D: |
         o.type = 'ARRAY';
         o.total = @$u;
         my $i = 0;
         until (@{o.r} >= $thi) {
             if (!exists $u->[$i]) {
                 last;
             }
             
             my $v = $u->[$i];
             # $plucky
             push @{o.r}, { r=>$i, path=>"[".$i, s=>$v };
             
             if (@{o.r} >= $thi) {
                 o.more = @$u - @{o.r};
                 delete o.more if !o.more;
                 last;
             }
             $i++;
         }
 - K: ou/code #c
   D: |
          die;
          o.type = 'CODE';
          push @{o.r}, { r=>"CODE", clues=>{stuff=>"fromDm?"} }
 - K: ii/more #c round corner
   D: |
     my $d;
     d.t = 'more';
     d.sc.ab = 'right:-1em';
     d.c.pi = 'more';
     d.c.gp.cv = 0.5;
     d.c.s = $o;
     Rw iiJM + $d;
 - K: pi/more #c round corner
   D: |
     #J.d.sc.bo = '3px solid white';
     Rw MyN $J $N:_ for
     [
     [more => 1, {s=>'@'},{fs=>19,co=>'31f'}],
     [more => 2, {s=>u.more}],
     [more => 3, {s=>'more'},{co=>'000',sha=>'3 5 2 531'}]
     ];
     

