hooks:
  R_zs: #c
    - K: maka_styley #c
      babz:
        'makaout 0.31': |
            for my $k (%{a.bb}) {
                if ($k =~ /^(\S*(?:oB|Bo|Bi))\s+(.+)$/) {
                    a.bb->{"$1\%css $2"} = "color:black";
                }
                if ($k =~ /^thi\s+(.+)$/) {
                    a.bb->{"thi\%css $1"} = "text-decoration:underline";
                }
                if ($k =~ /^name\s+(.+)$/) {
                    a.bb->{"name\%css $1"} = "color:#f93";
                }
            }
    - K: forkpi #c
      spesh: 1
      babz:
        'gp 5': |
            my $p = 1;# fork();
            if (a.cv > 0.1) {
                my $lyt = a.R.layert ||= [];
                push @$lyt, $a;
            }
            a.cv = 0.1 if $p;
            #exit if !$p;
        'gp 8': |
          if (!$p) {
              sayre "Theng: for $u ".length $html;
              #exit;
          }
          else {
              #saygr "This: for $u ".length $html;
          }
    - K: prot_fits #c
      babz:
        'S#proto_fits 8': |
          # proto fits: shrink this webbing into a space in our webbing
          my @sty;

          my $o = 12;
          my $lines = split /\n/, $html;
          if ($lines > $o) {
              my $fs = 100 * $o / $lines;
              $fs *= -1 if $fs < 0;
              push @sty, "font-size:$fs%";
          }
          push @sty, "background:rgba(80,50,22,0.3)"; 
          push @sty, "white-space:pre";
          push @sty, "font-family:mono";
          push @sty, "display:block";
          push @sty, "overflow-wrap:break-word";
          my $sty = join ";", @sty; 
          $html = qq{<span style="$sty"><span>$html<span></span>};
      
    - K: Aun #c
      babz:
        'S#unifromA 1.16': |
          my $unifro = {
              i => R.J.from || die,
              t => R.J.trav || "",
          };
          R.a.i ||= w R_sur/uni(%$unifro);
    - K: Q #c
      key:
        SW: way
        SR: Redisy
      n_D:
            way: |
              R.J = {
                  from => [$G->findway('R_sur'), $G->findway('R_n')],
              };
            Redisy: |
              R.J = {
                from => [sort H.r->keys("*")],
              }
    - K: Vit #c
      key: {E: up, R: down}
      n_D:
            up: |
                R.S.e += 0.1;
            down: |
                R.S.e -= 0.1;
    - K: Gho #c # to ghost from here
      key: {G: G}
      n_D:
            G: |
              my $R = w R_sur/are;
              my $a = {i=>$R};
              w R_n/Sud/in[$R, $a];
    - K: Fau #c # F junket
      key: {F: F}
      n_D:
            F: |
              saygr "Trying!!!!" for 1..5;
              my @lot = w trythis;
              my $f = $F[0];
              my $R = w R_sur/are;
              my $a = {i=>$f};
              w R_n/Sud/in[$R, $a];
              sayyl "Trithings: $_ " for @lot;
    - K: Dawn #c
      key: {D: D}
      n_D:
            D: |
                sayre "Yeahp";
                my $P = Load(<<'');
                 - GAK: deadC C

                H.G w percs[$P];
    - K: Swim #c
      key: {S: S}
      n_D:
            S: |
                my $a;
                my $R = w R_sur/are;
                my ($GG) = grep { $_ ne $G && _.name eq "C" } @{H.G.GGs};
                a.i = $GG w R_sur/are;
                w R_n/Sud/in[$R, $a];
    - K: Num #c
      key: {0: out, number: in}
      n_D:
            out: |
              return R.ksuc = "" if R.ksuc && $k eq "0";
              return $R->popJtrav
            in: |
              R.ksuc .= $k;
              my $j = R.a.ro->{R.ksuc};
              
              if (!$j) {
                  w unchanged[$R];
                  return sayre "no j ye for R.ksuc";
              }
              sayyl "got $j j.t j.cv for R.ksuc";

              R.ksuc = "";

              my ($hop) = split /(?=\{|\[)/, j.t;
              R.J.trav .= $hop; 
    - K: Sud #c
      n_D:
            in: |    # ebrace flying embryo J
                R.J = { from => a.i };
                R.J.trav = a.t if a.t;
    
