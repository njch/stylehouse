R_Jz:

 - K: pi/direlab #c round corner, where one bit/type/hum of noise splits others
   D: |
     my $s = $u;
     my $r = J.d.g.r;
     
     my $fi = {pi=>'fileinfo', s=>r.s, label=>$u, gp=>{cv=>0.1}};
     Jn(fileinfo => 0.3, $fi,
            '{hs:6.7.2.9,ab:1,top:1em,right:1em}');
     
     Jn('label', '', fi.label,
         "{zi:15,sha:2 3 6 ccf,fw:6,co:3f4}");
     
 - K: og/ref #c mix up @{o.r}
   D: |
     my $ac = {};
     for my $r (@{o.r}) {
         my $u = r.s;
         my $s = "AREF";
         $s = 'text' if !ref $u;
         $s = 'array' if ref $u eq 'ARRAY';
         $s = 'code' if ref $u eq 'CODE';
         $s = 'hash' if ref $u eq 'HASH';
         acum $ac, $s, $r;
     }
     my @r;
     for my $s (sort keys %$ac) {
         my $v = $ac->{$s};
         o.g.ref->{$s} = $v;
         push @r, @$v;
     }
     _.sc.mw = '22em' for @r;
     _.sc.over = 'hidden' for @r;
     o.r = \@r;

       if (o.g.ref) {
           for my $r (@{o.g.ref.AREF||[]}) {
               r.sc.fs = 15;
           }
           my @coag = @{o.g.ref.code||[]};
           if (@coag) {
               my ($f,@r) = @coag;
               my $co = {map {_.r => _.s}@coag};
               f.s = $co;
               f.c.pi = "codes";
               f.t = "codes";
               _.skip = 1 for @r;
           }
       }
       
     # want a default mode that shrinks away as other innesses come up
     # & reappropriates pi rhythms
     # where pi/stuff uses wtfs
     # chunks of the branching meaning can be patched upwards
     my $bigys = {map{$_=>1}qw{B S Z o phl phy}};
     @{o.t} = grep {!(
         sc.ou eq 'hash' && (
             $bigys->{_.t} && !%{_.s}
            || _.t eq 'Gw' && _.s eq '1'
         )
     )} @{o.r};
       
 - K: pi/codes #c bo
   D: |
     # cranking
     for my $k (sort keys %$u) {
         my $s = " $k";
         my $sc = {co=>'34f'};
         Rw wtf + dhei$k $s $sc;
         my $v = $u->{$k};
         die unless ref $v eq 'CODE';
     }
 - K: ou/text #c
   D: |
     o.type = 'text';
     push @{o.r}, { t=>"text", s=>$u, cv=>0.4 };
 - K: ou/hash #c
   D: |
      my @ks = sort keys %$u;
      o.total = @ks;
      until (@{o.r} >= $thi) {
          last if !@ks;
          my $k = shift @ks;
          my $v = $u->{$k};
          # $plucky # could be R coded small lmaz
          # can meet slightly more and select best
          # nothing is too worthy
          push @{o.r}, { t=>$k, path=>"{".$k, s=>$v };

          if (@{o.r} >= $thi) {
              o.more = @ks if @ks;
              last;
          }
      }
      # bunch of keys... ^ interpret, compress knowledge
      # TODO ^make itv like two indexes, polars
      # any sorta layout knowhow...
 - K: ou/array #c
   D: |
         o.type = 'ARRAY';
         o.total = @$u;
         my $i = 0;
         until (@{o.r} >= $thi) {
             if (!exists $u->[$i]) {
                 last;
             }
             
             my $v = $u->[$i];
             # $plucky
             push @{o.r}, { t=>$i, path=>"[".$i, s=>$v };
             
             if (@{o.r} >= $thi) {
                 o.more = @$u - @{o.r};
                 delete o.more if !o.more;
                 last;
             }
             $i++;
         }
 - K: ou/code #c
   D: |
          die;
          o.type = 'CODE';
          push @{o.r}, { t=>"CODE", clues=>{stuff=>"fromDm?"} }
 - K: ii/more #c round corner
   D: |
     my $d;
     d.t = 'more';
     d.sc.ab = 'right:-1em';
     d.c.pi = 'more';
     d.c.gp.cv = 0.5;
     d.c.s = $o;
     Rw iiJM + $d;
 - K: pi/more #c round corner
   D: |
     #J.d.sc.bo = '3px solid white';
     Rw MyN $J $N:_ for
     [
     [more => 1, {s=>'@'},{fs=>19,co=>'31f'}],
     [more => 2, {s=>u.more}],
     [more => 3, {s=>'more'},{co=>'000',sha=>'3 5 2 531'}]
     ];
     
 - K: pi #c
   n_D:
      wtf: | #c
        J.bz->('know 0.1', "$u");
      ARRAY: | #c
            my $cv = J.cv ||= 0.3;
            
            my $si = @$u;
            J.bz->('si 0.1' => $si, '%css' => "color:#fff;font-size:50%");
            J.bz->('Bo 0.11' => '[');
            J.bz->('oB 0.89' => ']');
            
            return if $cv < 0.2;
            
            
            my @cvs = Rw cv/oe $v:si;
            my $i = 0;
            while (exists $u->[$i]) {
                my $uu = $u->[$i];
                my $vc = shift @cvs;
                if ($i > 0) {
                    J bz [${i}/Bs 0.2${vc}1 ','
                }
                
                my $vcv = J.cv - 0.2; # dus bend for $k
                $vcv = 0.1 if $vcv < 0.1;
                 
                Jn("[${i}", "0.2${vc}4", {pi=>'',s=>$uu,gp=>{cv=>$vcv}}, {fs=>7});
                
                $i++;
                if ($i >= 5) {
                    J bz more 0.88 "@", '%sf' => "blue"
                    last;
                }
            }
      HASH: | #c
            my $cv = J.cv ||= 0.3;
            
            my $si = keys %$u;
            J.bz->('si 0.1' => $si, 'si%css 0.1' => "color:#fff;font-size:50%");
            
            Jn(Bo => 0.11, {s=>'{'});
            Jn(oB => 0.89, {s=>'}'});
            
            return if $cv < 0.2;
            
            # 3
            my $r = {map{$_=>1} sort keys %$u};
            my @r = grep { delete $r->{$_} } qw'K name';
            push @r, sort keys %$r;
            
            my @cvs = Rw cv/oe $v:si;
            my $i = 0;
            for my $k (@r) {
                my $v = $u->{$k};
                my $vc = shift @cvs;
                if ($i > 0) {
                    #J bz {$k/Bs 0.2${vc}1 ','
                }
                
                my $fs = 16; # is 100%?
                my $ksi = length($k);
                $fs -= ($ksi - 2) * 0.4 if $ksi > 8;
                $fs = int($fs);
                $fs = 4 if $fs < 4;
                
                Jn("{$k/k", "0.2${vc}", $k, "{co:acf,fs:$fs}");
                
                my $vcv = J.cv - 0.2; # dus bend for $k
                if ($vcv >= 0.2) {
                    #J bz {$k/Bi 0.2${vc}3 ':', '%css' => "font-size:40%"
                    # TODO fsxing, cv, geom peeps
                    my $fs = 11;
                    $fs -= length($v) - 2 * 0.4 if 8 < length $v;
                    $fs = int($fs);
                    
                    Jn("{$k/v", "0.2${vc}4", {pi=>'',s=>$v,gp=>{cv=>$vcv}}, {fs=>$fs});
                }
                
                $i++;
                if ($i >= 5) {
                    J.bz->("more 0.2 0.886" => "@",
                    
                        '%sf' => "blue");
                    last;
                }
            }
      ref: | #c weird ref
        J.bz->('knowref 0.1', "$u", '%css'=>'color:#945;font-size:70%');
      code: | #c
        J.bz->('know 0.1', "CODE");
      undef: | #c
        J.bz->('know 0.1', '~');
      text: | #c
            my $text = $u;
            
            my @s;
            my $adhow = $text =~ s/\n/↯/g;
            
            my $tev = int(J.cv * 200); # 0.4 = 100
            
            my $si = length($text);
            if (!$si) {
                J.bz->('length 0.1', "''", '%sf', 'blue');
            }
            if ($si > $tev) {
                $text = ($text=~/^(.{$tev})/s)[0];
            }
            else {
                undef $si;
            }
            
            J.bz->('line 0.1' => $text,
                '%css' => "background:rgba(200,30,80,0.3);color:#3f3;"
                    ."font-size:70%");
            
            if ($si) {
                J.bz->("more 0.89" => "@",'%sf' => "blue");
            }
            
            return if J.cv < 0.2;
            
            my $ni = J.c.lin if J.c.lin > 1;
            my $bi = J.c.b if J.c.b > 1;
            
                J.bz->("si/l 0.2" => "$si",
                    '%css' => "color:#b89;font-size:50%;position:absolute") if $si;
                J.bz->('si/n 0.2' => "$ni",
                    '%css' =>
                        "color:#fff;font-size:50%;"
                        ."position:absolute;margin-top:1.4em;") if $ni;
                J.bz->('si/b 0.2' => "b$bi",
                    '%css' =>
                        "color:#f89;font-size:50%;"
                        ."float:left;left:-1em") if $bi;
                   
            if (J.cv < 0.7 && $text =~ /^(# \d.+?)↯/) {
                J.bz->('line 0.1' => $1,
                '%css' => "background:rgba(200,30,80,0.3);color:#3f3;"
                    ."font-size:70%");
            }
            return if J.cv < 0.7;
            
            # 7
            my @tex = split /\n/, $u;
            #my $s = $G->vimcolor($u);
            #$s =~ s/^(<span) (class="synComment">.+?)(<\/span>)/$1 style="font-size:170%;" $2$com$3/;
            
            #$tex[0] .= " #J.cv";
            
            my $surge = int(100 * (J.cv - 0.7));
            # add interesting o to tex 0.7ishs as surge goes
            (my $one, my @o) = @tex if J.cv < 0.8;
            @tex = $one if @o;
            my $urge = $surge / 2;
            $urge = 0; # TODO colours and
            for (@o) {
                last if @tex >= $urge;
                push @tex, $_ if /^#/
                    || /R\./
                    || /\-\>/
                    || /w\ /;
            }
            
            
            my $lim = ";height:19em;overflow-y:scroll" if @tex > 19;
            $lim .= ";background:rgba(70,40,0,1);" if J.cv >= 0.8;
            
            my $fs = int(50 + $surge * 7);
            $fs = "font-size:$fs%;";
            
            my $s = join"\n", @tex;
            J.bz->("line 0.1" => $s, '%tag'=>'pre','%gp'=>{vimcolor=>1},
                '%css' => "margin:0.2em;background:rgba(30,30,60,1);$fs-webkit-filter:hue-rotate(80deg);$lim");
      A: | #c
        my $cv = J.cv ||= 0.3;
        
        J bz thi 0.01     ref $u
        return if $cv < 0.1;
        J bz name 0.1     u.name
        return if $cv < 0.2;
        J bz K 0.2        u.K
        #die wdump 2, J.d.g.x.sc;
        # THIS v kinda as the whole thing is water phased cleverness (a defer)
        if (J.d.g.x.sc.ori ne u.i) {
            Jn('i', 0.2, {pi=>'',s=>u.i,gp=>{cv=>0.2}});
        }
        else {
            J bz i 0.2 'this'
        }
        return if $cv < 0.3;
        
        my $un;
        my $wy = {};
        for my $nuk (keys %$u) {
            next if $nuk !~ /^(u|n)(.*)$/;
            my $k = $1;
            my $kn = $2;
            my $v = $u->{$nuk};
            acum $wy, $k, [$nuk,$k,$kn,$v];
        }
        for my $k (reverse sort keys %$wy) {
            my $v = $wy->{$k};
            my $sc = {hs=>'2.3.5.6'};
            Rw wtf + was $s:k $sc;
            for my $n (@$v) {
                my ($nuk,$k,$kn,$v) = @$n;
                Rw wtf + wur $s:kn;
                my $c;
                c.s = $v;
                c.pi = '';
                c.gp.cv = 0.2;
                Rw wtf + wurp $c;
            }
        }
        
      G: | #c
        my $cv = J.cv ||= 0.3;
        J.bb->{"thi 0.01"} = ref $u;
        return if $cv < 0.1;
        J.bb->{"K 0.11"} = u.K;
        J.bb->{"name 0.12"} = u.name;
        return if $cv < 0.2;
        
      T: | #c dodge
        J.bz->('pi 0.1', $u->pi);
      J: | #c dodge
        my $cv = J.cv ||= 0.3;
        J.bb->{"thi 0.01"} = ref $u;
        return if $cv < 0.1;
        J.bb->{"name 0.1"} = $H->ejson(u.B) if u.B;
        return if $cv < 0.2;
        Jn(i => 0.2, {pi=>'',s=>$u,gp=>{cv=>0.1}});
        return if $cv < 0.3;
        # 3
      up: | #c WWAHAT
            my $r = {map{$_=>1} sort keys %$u};
            die "UP IN PI";
            
            my $ordy = {
                A => 1,
                id => 11,
                K => 12,
                name => 13,
                G => 14,
                R => 14,
                W => 2,
            };
            my $ydro = {};
            push @{$ydro->{$_}||=[]}, $_ for keys %$ordy;
            my @order = map { @{$ydro->{$_}} } sort keys %$ydro;
            
            my @r = grep { delete $r->{$_} } @order;
            push @r, sort keys %$r;
            
            my $ki = 0;
            my $i = 0;
            for my $k (@r) {
                my $v = $u->{$k};
                
                my $ord = $ordy->{$k} || 4;
                J.bb->{"$k\t".'0.'.$ord} = ''.$v;
                
                $i++;
            }
      H: | #c
        J.bz->('thi 0.01' => 'H');
        J.bz->("name 0.06" => u.style);
        J.bz->("K 0.1" => u.name);
        
      R: | #c
        my $cv = J.cv ||= 0.3;
        J.bb->{"thi 0.01"} = ref $u;
        return if $cv < 0.1;
        J.bb->{"K 0.11"} = u.K;
        J.bb->{"name 0.12"} = u.name;
        return if $cv < 0.2;
        return if $cv < 0.3;
        Jn(G => 0.3, {pi=>'',s=>u.G,gp=>{cv=>0.2}}, {fs=>7}); # TODO relative down
        return if $cv < 0.4;
      C: | #c
        my $cv = J.cv ||= 0.3;
        J.bb->{"thi 0.01"} = ref $u;
        J.bb->{"thi%tt 0.01"} = u.id;
        return if $cv < 0.1;
        
        J.bb->{"K 0.11"} = u.K;
        J.bb->{"name 0.12"} = u.name;
        
        return if $cv < 0.2;
        
        u.B && ref u.B eq 'HASH' && do {
            u.B.name &&
            Rw wtf + B_name 0.23 $s:u.B.name;
        };
        
        u.bb && ref u.bb eq 'HASH' && do {
            my $s = keys %{u.bb};
            my $sc = {co=>'be0',fs=>7};
            Rw wtf + bbmag 0.4 $s $sc;
        };
        
        if (J.fop->()) {
            my @ts = Rw tvy $J;
            my $s = @ts;
            my $sc = {co=>'be0',fs=>9};
            Rw wtf + bbthings 0.41 $s $sc;
            my $bs = 'l';
            my $bsc = {co=>'97e5',fs=>9};
            Rw wtf + bbthind 0.401 $s:bs $sc:bsc;
            # lev this ^ and get them all to drop at ...
            # calc width thi of things up to there
        }
        
        
        # maybe S, Z
        
        
        return if $cv < 0.3;
        
        if (0 && u.G && (defined u.print || u.Gw)) {
            my $p = u.G->w('print' => {}, $u, {nodie=>1});
            J.bb->{"print 0.3"} = $p if defined $p;
        }
        
        # dusseldorf
        my %s = map { $_=>1 } grep { /^[a-z]/ } keys %$u;
        delete $s{id};
        my @or = qw'name point timer', keys %s; 
        
        my $c; 
        my $b; 
        for my $k (@or) {
            next if !defined $k;
            next if !exists $u->{$k};
            my $t = $u->{$k};
            next if !defined $t;
            next if ref $t;
            next if $t =~ /\n/; 
            next if $k eq 'name';
            my $slim = slim(20,20,$t);
            
            J.bb->{"$k 0.4"} = $slim if $cv >= 0.4; # also a dus fuzz away
        }
        

