
R_surz: #c
    - K: maka_styley #c
      babz:
        'makaout 0.31': |
            for my $k (%{a.bb}) {
                if ($k =~ /^(\S*(?:oB|Bo|Bi|Bs))\s+(.+)$/) {
                    a.bb->{"$1\%css $2"} = "color:black";
                }
                if ($k =~ /^thi\s+(.+)$/) {
                    a.bb->{"thi\%css $1"} = "text-decoration:underline";
                }
                if ($k =~ /^name\s+(.+)$/) {
                    a.bb->{"name\%css $1"} = "color:#f93";
                }
            }
    - K: forkpi #c
      spesh: 0
      babz:
        'gp#fork_layert 5.6': | 
            if (a.cv > 0.2 && !a.replaceJid && !a.q) {
                my $la = {%$a};
                la.origin_inarow = G.gp_inarow;
                a.isJid = la.replaceJid = $H->mkuid;
                my $lyt = R.layert ||= [];
                push @$lyt, $la;
                a.forking = $la;
                a.cv = 0.1;
                $ping = 1;
            }
        'S#waylayert_pias 8.8': |
            if (my $pias = delete R.layert) {
                # my $it = natatime 5, @$pias;
                # TODO they come back out of order of attachment 
                # fork only the top level pi, not pi within pi?
                # promise pi, makaout executes?
                $G->timer(0, sub {
                    w $R forkpi/pias[$pias];
                });
            }
        'gp 6.2': |
            R.a.pis->{a.isJid} = $a;
        'gp 7.1': |
            a.forking.wash = $H->dig($html) if a.forking;
        'S#tidy 0.113': |
            if (my $tokill = delete R.S_forkpi_tokill) {
                kill 'KILL', $_ for @$tokill;
            }
      n_D:
        pias: |
            if (my $pid = fork()) {
                my $Sftk = R.S_forkpi_tokill ||= [];
                push @$Sftk, $pid;
                return
            }
            H.db = H.pg->db;
            # child must exit, after reporting error
            # so nothing else can happen. listening db handle gone anyway?
            my $bail = sub{ exit };
            $G->accum($G0, _aft_err_do => $bail);
            $G->accum($F[0], _aft_etc_do => $bail);
            
            sayyl "pier Forked... ";
            
            my @js;
            my $group = 2;
            for my $a (@$pias) {
                my $html = w $R gp[$a];
                next if a.wash eq $H->dig($html);
                my $set = $H->ejson($html);
                my $id = a.replaceJid || die;
                my $js = qq{ \$('#$id').replaceWith($set);};
                push @js, $js;
                if (@js >= $group) {
                    $H->send(join('', @js));
                    @js = ();
                }
            }
            $H->send(join '', @js) if @js;
            saygr "pier done ".F_delta;
            
    - K: prot_fits #c
      babz:
        'S#proto_fits 8.7': |
          # proto fits: shrink this webbing into a space in our webbing
          my @sty;

          my $o = 12;
          my $lines = split /\n/, $html;
          if ($lines > $o) {
              $lines = 17 if $lines > 17;
              my $fs = 100 * $o / $lines;
              $fs *= -1 if $fs < 0;
              push @sty, "font-size:$fs%";
          }
          push @sty, "background:rgba(80,50,22,0.3)"; 
          push @sty, "white-space:pre";
          push @sty, "font-family:mono";
          push @sty, "display:block";
          push @sty, "overflow-wrap:break-word";
          my $sty = join ";", @sty; 
          $html = qq{<span style="$sty"><span>$html<span></span>};
      
    - K: keyba #c
      spesh: 1
      babz:
        'keys 3': |
          saygr "doings of $do";
          R.thedoings = $do;
        'S#keybas 3.32': |
          a.bz->('keybas 3.32', "Yogo R.thedoings!");
      
    - K: Num #c
      key: {0: out, number: in}
      n_D:
            out: |
              return R.ksuc = "" if R.ksuc && $k eq "0";
              my @trav = $G->chuntr(S.J.trav);
              pop @trav;
              S.J.trav = join '', @trav;
            in: |
              R.ksuc .= $k;
              my $j = R.a.ro->{R.ksuc};
              
              if (!$j) {
                  w unchanged[$S];
                  sayre "no j ye for R.ksuc" for 1..5;
                  return;
              }
              sayyl "got $j j.t j.cv for R.ksuc";


              R.ksuc = "";
              if (R.a.travly) {
                  S.J.trav =~ s/\^.+?$// || die;
              }

              my ($hop) = j.t;
              S.J.trav .= $hop; 
    - K: Sud #c
      n_D:
            in: |    # ebrace flying embryo J
                S.J = { from => ar.i };
                S.J.trav = ar.t if ar.t;
    
    - K: stringlook #c
      babz:
        'S#string 3.14': | #c
          S.mod.humm = 'adu';
          if (!%$d) {
            if (!ref a.i) {
              sayre "SDoing something else";
              S.mod.humm = 'stringlook';
              my $sd = {};
              $G->D_to_style({K=>"s",D=>a.i}, $sd);
              my @ksd = sort keys %$sd;
              my $on;
              my @j = map { G.R->shj($_, $sd) } @ksd;
              ($on) = map { _.cv } grep { _.cv eq R.a.travly } @j;
              saygr "Was R.a.travly";
              for my $j (@j) {
                  my $k = j.t;
                  my $v = j.cv;
                  my $s = j.s;
                  my $sec = 0;
                  
                  my $vo = 0.7;
                  
                  if ($on && $on eq j.cv || @j == 1) {
                      $vo = 0.8;
                      sayyl "\t\t$on  j.cv";
                  }
                  elsif ($on && 0) {
                      my $dist = $on - j.cv;
                      $dist *= -1 if $dist < 0;
                      $sec = $dist;
                      $sec =
                      $sec < 1 ? 3
                      :
                      $sec < 2 ? 2
                      :
                      $sec < 3 ? 1
                      :
                      0;
                      
                          $sec = $sec*0.01;
                          $vo = 0.7 + $sec;
                      
                      #sayyl " j.cv \t $sec\t\t$vo";
                  }
                  say "^j.cv\t$vo";
                  $d->{"^j.cv\t$vo"} = $s;
              }
            }
          }
        'pi/text 7': | #c
            my $s = $u;
            my $s = $G->vimcolor($s);
            
            my @old = split /\n/, $s;
            my @new = @old;
            my $com;
            if (a.cv >= 0.7 && a.cv < 0.8) {
                my $sens = (a.cv - 0.7) * 10;
                my $cu = int($sens * 10 * 3);
                say "sendse $sens  $cu";
                my $i = 1;
                @new = ();
                push @new, shift @old;
                for (@old) {
                    
                    push @new, $_ if @new < $cu && (/^#/ || /R\./ || /\-\>/ || /w\ /);
                    $i++;
                }
                my $more = $i - @new;
                $com = $more ? "$more@" : "";
            }
            #$col = join "\n", ()[0], '' if a.cv < 0.8;
            $s = join "\n", @new;
            $com = "  $com";
            $s =~ s/^(<span) (class="synComment">.+?)(<\/span>)/$1 style="font-size:170%;" $2$com$3/;
            
            
            saygr "aw a.cv";
            my $lim = ";height:19em;overflow-y:scroll" if @new > 19;
            $lim .= ";background:rgba(70,40,0,1);" if a.cv >= 0.8;
            
            a.bz->("line 0.1" => $s, '%tag'=>'pre','%gp'=>{vimcolor=>1},
                '%css' => "margin:0.2em;background:rgba(30,30,60,1);font-size:50%;-webkit-filter:hue-rotate(80deg);$lim");
      n_D:
        humms: | #c
          my @r = w stylekeysort[$d]; 
          my $si = @r;
          my @i = w $R wind[$si];
          my $ro = R.a.ro = {}; # wind round
          my $i = 0;
          for my $r (@r) {
              my $j = $R->shj($r, $d);
              
              my $li = j.li = shift @i || die;
              $ro->{$li} = $j;
              #my $z = a.bz->("$li 
              a.fro->("${li}_s 0.3 0.3${li}4", j.s, j.cv,
                  '%sf', 'white_fs120');
              
              a.bz->("${li}_z 0.3 0.3${li}5", "\n") if j.cv < 0.7;
              $i++; 
          }
          #a.bz->("/%css 0.1", 'background:rgba(10,10,0,1)');
              
          
    - K: goto #c
      key:
        J: J
        M: RwS
        SM: SM
        SN: SN
        F: F
        H: H
        W: W
        G: G
        S: S
      n_D:
        S: |
          my ($GG) = grep { $_ ne $G && _.name =~ /^C(?!\/)/} @{H.G.GGs};
          die "No other G named 'C'" unless $GG;
          my $otheR = $GG w are;
          ar.i = $otheR;
          w $R Sud/in;

        H: |
          ar.i = H.G.GGs;
          w $R Sud/in;
        RwS: |
          S.J = {from=>$R,trav=>'{way{hooks'};
        SM: |
          S.J = {from=>$R,trav=>'{way{hooks{goto'};
        SN: |
          S.J = {from=>R.a.i,trav=>'{ways[0{hooks'};
        J: |
          my $J = a.i = R.A->spawn('J');
          J.W = G.GG.U.W;
          J.hol = "H.style/H.name/H.id";
          J.tiNZ = J.W.at.styles =~ /\bNZ\b/;
          J.hitime = $H->hitime;
          # throw J into Pg
              #G0.Wh->{$ww} = $W;
          ar.i = $J;
          w $R Sud/in;
        W: |
          my $n = int rand 30000;
          S.J = { from => [$n,unico($n,1)]};
        F: |
              saygr "Trying!!!!" for 1..5;
              my @lot = w trythis;
              my $f = $F[0];
              ar.i = $f;
              w $R Sud/in;
              sayyl "Trithings: $_ " for @lot;
    - K: Q #c
      key:
        SR: Redisy
        D: D
        SD: SD
        Q: Q
        C: C
        K: K
        N: N
        T: T
      n_D:
        N: |
          S.mod.double = !S.mod.double;
        K: |
          my $P = 0->anyway('P_sud');
          my $GG = $G;
          H.G w percs[$P, $GG];
        C: |
          H.G w reexec;
        T: |
          my $ia = R.a.i.A || die "no idea about A?";
          my $ab = [$ia];
          push @$ab, $ia while $ia = ia.u;
          ar.i = $ab;
          w $R Sud/in;
        Q: |
          my $g = G:C/ool;
          ar.i = $g;
          w $R Sud/in;
        Redisy: |
              S.J = {
                from => [reverse sort H.r->keys("*")],
              };
        D: |
            my $u = w makeD;
            return;
        SD: |
            my $way = "C C/nv";
            my $K = "C".H.nn++;
            my $P = [{GAK => "$K $way"}];
            my $g = H.G w percs[$P];
            #my $g = G:$K;
            $g w ave(i=>$R);
            return;
            # make C elsewhere...
            sayre "Yeahp";
            my $with = "C/nv";
            $H->pub("S/hut/C", "percC $with");
    - K: chr0 #c
      spesh: 1
      babz:
         'S 4.01': |
           for my $i (1..10) {
               my $c;
               for my $ii (1..25) {
                   $c = 250 + ($i * 100) + $ii;
                   my $ch = unico($c);
                   a.bz->("ch_$c 3.011" , $ch);
               }
               a.bz->("ch_${c}_nl 3.011" => "\n");
           }
    - K: Vit #c
      key: {E: up, R: down}
      n_D:
            up: |
                R.S.e += 0.1;
            down: |
                R.S.e -= 0.1;

