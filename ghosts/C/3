
R_surz: #c


    - K: Jtwo #c
      babz:
        'S#unifromA 2.3': |
            R.lastS = $S;
            S.K eq "D" || die || "D?";
            sayyl "Doing S.K S.name hmmmmmmmm S.J.from S.J.trav"; 
            my $i = S.J.from || die;
            my $t = S.J.trav || '';
            ($t, S.a.travly) = split /\^/, $t, 2;
            
            S.a.i = $R->suets($i, $t);
            
            a.s = S.S.s || w $R dus;
            a.s.HASH.oh = 0.2;
            a.tr.rowlimit = S.S.rowlimit || 9*4;
            a.e ||= S.S.e;
            defined a.i || die;
            my $d = {};
            
            
        'S 2.4': |
          
          a.fro->('Rl 0.01' => [$H,R.G,$R,$S], {cv=>0.2});
          
          a.fro->('S_J_from 0.12' => S.J.from, 0.2, '%css' => 'border:2px solid pink;');

          a.bz->('S_J_trav 0.13' => S.J.trav, '%sf' => 'black_fs120'); 

          a.bz->('S_S_e 0.2' => S.S.e, '%sf' => 'white');

          a.fro->('S_a_i 0.21' => S.a.i, 0.2);

          a.bz->('Js 0.29' => "\n");
    - K: Jbuild #c
      babz:
        'S#moo 3.1': | 
          S.mod = {%{S.mood||{}}};
          if (my $onetime = delete S.monod) {
              S.mod = {%{S.mod}, %$onetime};
          }
        'S#du 3.3': |
          $d = w $R du;
        'S#hum 4': |
          my $humm = S.mod.humm || 'adu';
          w $R $humm/humms[$S, $a, $d];
          
          

    - K: playn #c
      babz:
        'S 3.214': |
          if (S.J.trav eq  '{way{hooks') {
              a.e += 2;
              S.mod.hooklook = 1;
          }
          if (S.mod.double) { # 
              my $an = {u=>a.i, cv=>0.8, q=>1};
              w $R gp(a=>$an);
              
              my $anH = {u=>a.i, cv=>0.8, q=>1, wa=>'HASH2'};
              w $R gp(a=>$anH);
              
              my $something = {
                  #%{an.bb},
                  %{anH.bb},
              };
              
              w Dave(K=>"Cm1",way=>"C/nv",Dname=>"hd",i=>$something);
          }
    - K: stringlook #c
      babz:
        'S 3.424': |
          S.mod.humm = 'adu';
          if (!%$d) {
            if (!ref a.i) {
              sayre "SDoing something else";
              S.mod.humm = 'simphumm';
              my $sd = {};
              $G->D_to_style({K=>"s",D=>a.i}, $sd);
              my @ksd = sort keys %$sd;
              
              # how near or how far
              my $on;
              my @j = map { G.R->shj($_, $sd) } @ksd;
              ($on) = map { _.cv } grep { _.cv eq S.a.travly } @j;
              
              saygr "Was S.a.travly";
              for my $j (@j) {
                  my $k = j.t;
                  my $v = j.cv;
                  my $s = j.s;
                  my $sec = 0;
                  
                  my $vo = 0.7;
                  
                  if ($on && $on eq j.cv || @j == 1) {
                      $vo = 0.8;
                      sayyl "\t\t$on  j.cv";
                  }
                  elsif ($on) {
                      my $dist = $on - j.cv;
                      $dist *= -1 if $dist < 0;
                      if ($dist > 5) {
                          $sec = 0;
                      }
                      else {
                          $sec = -$dist + 5;
                      }
                      
                          $sec = $sec*0.01;
                          $vo = 0.7 + $sec;
                      
                      sayyl " j.cv \t $sec\t\t$vo";
                  }
                  say "^j.cv\t$vo";
                  $d->{"^j.cv\t$vo"} = $s;
              }
            }
          }
    - K: stylook #c compress style slightly
      babz:
        'S 3.4145': |
          if (3 == grep { $_ =~ /^.+ .+\d\t.+$/ } (shuffle keys %$d)[0,1,2]) {
              my $l;
              for my $k (keys %$d) {
                  my $j = $R->shj($k, $d);
                  #sayre j.t;
                  my $t = j.t;
                  my $st = $1 if $t =~ s/(%\S+)//;
                  $st ||= 'Å¾';
                  my $lt = "$t\t"."0.4";
                  exists $l->{$lt}->{$st} && die "$t    $st";
                  $l->{$lt}->{$st} = j.s;
              }
              $d = $l;
          }
    - K: hookok #c
      babz:
        'S 3.4146': |
          if (S.mod.hooklook) {
              for my $k (keys %$d) {
                  my $v = delete $d->{$k};
                  next if ref $v;
                  $k =~ s/(?<=\t)(.+?)$/0.4/;
                  $d->{$k} = $v;
              }
          }

          
    - K: chr0 #c
      spesh: 1
      babz:
         'S 4.01': |
           for my $i (1..10) {
               my $c;
               for my $ii (1..25) {
                   $c = 250 + ($i * 100) + $ii;
                   my $ch = unico($c);
                   a.bz->("ch_$c 3.011" , $ch);
               }
               a.bz->("ch_${c}_nl 3.011" => "\n");
           }

    - K: adu #c
      n_D:
        humms: |
          my @r = w stylekeysort[$d];
          my $si = @r;
          my @i = w $R wind[$si];
          my $ro = S.a.ro = {}; # wind round
          my $i = 0;
          for my $r (@r) {
              #  sayyl " - $r";
              my $j = $R->shj($r, $d);
              #sayre wdump($j);
              
              my $li = j.li = shift @i || die;
              $ro->{$li} = $j;
              
              
              a.bz->("${li}_Bs 0.3 0.3${li}0" => "\n") if $i > 0;
                   
              a.bz->("${li}_li 0.3 0.3${li}1", j.li,
                  '%sf', 'blue_fs120');

              my $t = j.t;
              $t .= join("", (" ") x (6 - length($t))) if length($t) < 6;
              a.bz->("${li}_k 0.3 0.3${li}2", $t,
                  '%sf', 'black');

              my $cv = j.cv;
              $cv =~ s/^0//;
              a.bz->("${li}_cv 0.3 0.3${li}22", $cv,
                  '%sf', 'red_fs80');


              a.fro->("${li}_s 0.3 0.3${li}4", j.s, j.cv,
                  '%sf', 'white_fs120');
              $i++;
          }
    - K: simphumm #c
      n_D:
        humms: |
          my @r = w stylekeysort[$d]; 
          my $si = @r;
          my @i = w $R wind[$si];
          my $ro = S.a.ro = {}; # wind round
          my $i = 0;
          for my $r (@r) {
              my $j = $R->shj($r, $d);
              
              my $li = j.li = shift @i || die;
              $ro->{$li} = $j;
              #my $z = a.bz->("$li 
              a.fro->("${li}_s 0.3 0.3${li}4", j.s, j.cv,
                  '%sf', 'white_fs120');
              
              a.bz->("${li}_z 0.3 0.3${li}5", "\n") if j.cv < 0.7;
              $i++; 
          }
          #a.bz->("/%css 0.1", 'background:rgba(10,10,0,1)');
              
          

    - K: self_Jness #c
      spesh: 1
      babz:
         'S 4.1': |
            a.fro->('H 0.01' => $H, 0.2);
            a.fro->('G 0.02' => $G, 0.2);
            a.fro->('R 0.11' => $R, 0.2);
         'S 4.2': |
            # spesh
            
    - K: wind #c
      D: |
        my $s = 9;
        return 1..$s if $si <= $s;
        my $wind = $si - 9;
        my $from = 6;
        my $for = 3;

        my @i;
    
            my $la = $wind / $for;
            my $za = int $la;
            
            my $y;
            my @wind = 1..$wind;
            my @ys = $from..$from+$for-1;
            my $yi = 0;
            while (@wind) {
                my $win = shift @wind;
                
                my $at = $ys[$yi];
                $y->{$at}++;
                
                $yi++;
                $yi = 0 if !exists $ys[$yi];
            }
            
            for my $wi (1..$s) {
                
                if (my $la = $y->{$wi}) {
                    my @la = 1..$la+1;
                    for my $pl (@la) {
                        push @i, "$wi$pl";
                    }
                }
                else {
                    push @i, $wi;
                }
            }
            
            @i
            
  
