R_Jz:
 - K: cruxal #c
   D: |
     my $j = x.j;
     my $J = j.b.b.j;
     my ($k,$v) = @$m;
     J.bz->("j.l%".$k." j.cv", $v);
 - K: oundo #c hound god from a crux of inness $x
   D: |
     my $o = {r=>[]};
     # fills up @r to $thi
     # also $plucky to select hash key order
     # a space for tiny-part-of-huge-set access
     
     my $u = x.j.s;
     my $sc = x.sc;
     
     # $plucky could rate the things it gets passed
     # and the $thi yins up out here
     
     sc.ou ||= 'text' if !ref $u;
     sc.ou ||= 'array' if ref $u eq 'ARRAY';
     sc.ou ||= 'code' if ref $u eq 'CODE';
     sc.ou ||= 'hash';
     
     # further dimensional sc if {} or something?
     # so the spec can curve data all the way
     Rw ou/sc.ou + $u $o $x $sc;
     
     # $r rows over the contents
     # r.c probably for pi, other stuff may pick stuff up...
     
     o.thi = @{o.r};
     $o
 - K: ou/text #c
   D: |
     o.type = 'text';
     push @{o.r}, { r=>"text", s=>$u, cv=>0.4 };
 - K: ou/hash #c
   D: |
      
      my @ks = sort keys %$u;
      o.total = @ks;
      until (@{o.r} >= $thi) {
          last if !@ks;
          my $k = shift @ks;
          my $v = $u->{$k};
          # $plucky # could be R coded small lmaz
          # can meet slightly more and select best
          # nothing is too worthy
          push @{o.r}, { r=>$k, path=>"{".$k, s=>$v };

          if (@{o.r} >= $thi) {
              o.more = @ks if @ks;
              last;
          }
      }
      # bunch of keys... ^ interpret, compress knowledge
      # TODO ^make itv like two indexes, polars
      # any sorta layout knowhow...
 - K: ou/array #c
   D: |
         o.type = 'ARRAY';
         o.total = @$u;
         my $i = 0;
         until (@{o.r} >= $thi) {
             if (!exists $u->[$i]) {
                 last;
             }
             
             my $v = $u->[$i];
             # $plucky
             push @{o.r}, { r=>$i, path=>"[".$i, s=>$v };
             
             if (@{o.r} >= $thi) {
                 o.more = @$u - @{o.r};
                 delete o.more if !o.more;
                 last;
             }
             $i++;
         }
 - K: ou/code #c
   D: |
          die;
          o.type = 'CODE';
          push @{o.r}, { r=>"CODE", clues=>{stuff=>"fromDm?"} }
 - K: ii/more #c round corner
   D: |
     my $d;
     d.t = 'more';
     d.sc.ab = 'right:-1em';
     d.c.pi = 'more';
     d.c.gp.cv = 0.5;
     d.c.s = $o;
     Rw iiJM + $d;
 - K: pi/more #c round corner
   D: |
     #J.d.sc.bo = '3px solid white';
     Rw MyN $J $N:_ for
     [
     [more => 1, {s=>'@'},{fs=>19,co=>'31f'}],
     [more => 2, {s=>u.more}],
     [more => 3, {s=>'more'},{co=>'000',sha=>'3 5 2 531'}]
     ];
     

