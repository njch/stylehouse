R_Jz:
 - K: cruxal #c on inness style adju
   D: |
     my $j = x.j;
     my $J = j.b.b.j;
     my ($k,$v) = @$m;
     J.bz->("j.l%".$k." j.cv", $v);

 - K: oundo #c hound god from a crux of inness $x
   D: |
     my $o = {r=>[]};
     # fills up @r to $thi
     # also $plucky to select hash key order
     # a space for tiny-part-of-huge-set access
     
     my $u = x.j.s;
     my $sc = x.sc;
     
     # $plucky could rate the things it gets passed
     # and the $thi yins up out here
     
     sc.ou ||= 'text' if !ref $u;
     sc.ou ||= 'array' if ref $u eq 'ARRAY';
     sc.ou ||= 'code' if ref $u eq 'CODE';
     sc.ou ||= 'hash';
     
     # further dimensional sc if {} or something?
     # so the spec can curve data all the way
     Rw ou/sc.ou + $u $o $x $sc;
     
     sc.grp &&
     Rw og/sc.grp + $u $o $x $sc;
     
     # $r rows over the contents
     # r.c probably for pi, other stuff may pick stuff up...
     
     o.thi = @{o.r};
     $o
 - K: og/ref #c mix up @{o.r}
   D: |
     my $ac = {};
     for my $r (@{o.r}) {
         my $u = r.s;
         my $s = "AREF";
         $s = 'text' if !ref $u;
         $s = 'array' if ref $u eq 'ARRAY';
         $s = 'code' if ref $u eq 'CODE';
         $s = 'hash' if ref $u eq 'HASH';
         #say "of $s : ".slim 30, gp $u;
         acum $ac, $s, $r;
     }
     my @r;
     for my $s (sort keys %$ac) {
         my $v = $ac->{$s};
         o.g.ref->{$s} = $v;
         push @r, @$v;
     }
     _.sc.mw = '22em' for @r;
     _.sc.over = 'hidden' for @r;
     o.r = \@r;

       if (o.g.ref) {
           for my $r (@{o.g.ref.AREF||[]}) {
               r.sc.fs = 15;
           }
           my @coag = @{o.g.ref.code||[]};
           if (@coag) {
               my ($f,@r) = @coag;
               my $co = {map {_.r => _.s}@coag};
               f.s = $co;
               f.c.pi = "codes";
               f.r = "codes";
               _.skip = 1 for @r;
           }
       }
       
     # want a default mode that shrinks away as other innesses come up
     # & reappropriates pi rhythms
     # where pi/stuff uses wtfs
     # chunks of the branching meaning can be patched upwards
     my $bigys = {map{$_=>1}qw{B S Z o phl phy}};
     @{o.r} = grep {!(
         sc.ou eq 'hash' && (
             $bigys->{_.r} && !%{_.s}
            || _.r eq 'Gw' && _.s eq '1'
         )
     )} @{o.r};
       
 - K: pi/codes #c bo
   D: |
     # cranking
     for my $k (sort keys %$u) {
         my $s = " $k";
         my $sc = {co=>'34f'};
         Rw wtf + dhei$k $s $sc;
         my $v = $u->{$k};
         die unless ref $v eq 'CODE';
     }
 - K: ou/text #c
   D: |
     o.type = 'text';
     push @{o.r}, { r=>"text", s=>$u, cv=>0.4 };
 - K: ou/hash #c
   D: |
      
      my @ks = sort keys %$u;
      o.total = @ks;
      until (@{o.r} >= $thi) {
          last if !@ks;
          my $k = shift @ks;
          my $v = $u->{$k};
          # $plucky # could be R coded small lmaz
          # can meet slightly more and select best
          # nothing is too worthy
          push @{o.r}, { r=>$k, path=>"{".$k, s=>$v };

          if (@{o.r} >= $thi) {
              o.more = @ks if @ks;
              last;
          }
      }
      # bunch of keys... ^ interpret, compress knowledge
      # TODO ^make itv like two indexes, polars
      # any sorta layout knowhow...
 - K: ou/array #c
   D: |
         o.type = 'ARRAY';
         o.total = @$u;
         my $i = 0;
         until (@{o.r} >= $thi) {
             if (!exists $u->[$i]) {
                 last;
             }
             
             my $v = $u->[$i];
             # $plucky
             push @{o.r}, { r=>$i, path=>"[".$i, s=>$v };
             
             if (@{o.r} >= $thi) {
                 o.more = @$u - @{o.r};
                 delete o.more if !o.more;
                 last;
             }
             $i++;
         }
 - K: ou/code #c
   D: |
          die;
          o.type = 'CODE';
          push @{o.r}, { r=>"CODE", clues=>{stuff=>"fromDm?"} }
 - K: ii/more #c round corner
   D: |
     my $d;
     d.t = 'more';
     d.sc.ab = 'right:-1em';
     d.c.pi = 'more';
     d.c.gp.cv = 0.5;
     d.c.s = $o;
     Rw iiJM + $d;
 - K: pi/more #c round corner
   D: |
     #J.d.sc.bo = '3px solid white';
     Rw MyN $J $N:_ for
     [
     [more => 1, {s=>'@'},{fs=>19,co=>'31f'}],
     [more => 2, {s=>u.more}],
     [more => 3, {s=>'more'},{co=>'000',sha=>'3 5 2 531'}]
     ];
     

