R_Jz:
 - K: ii/bod #c boodle am $rr into $M: lab,pi, lab,pi ...
   D: |
       my $in = x.in; # TODO whereto?
       my $out = x.out;
       my $phi = ($out - $in) * x.thi; # normal lines per 0.1
       my $thi = $phi * 2; # oundo big window, bod small
       
       say "bod $in <--> $out  $thi     x.j.r"; # TODO say big
       
       my $o = Rw oundo $thi $x;
       say "Oundo: ". join ', ', map{"$_"} @{o.r};
       warn "More o.more" if o.more;
       my $M = [];
       for my $r (@{o.r}) {
           r.r || die"nor".ki$r;
           my $oM = [];
           # SZOOOOOOOOOOOM
           Rw ii/labegy $x $r $M:oM;
           Rw ii/pi $x $r $M:oM;
           # ^ pass $thi, pool resources
           
           my $c = {%{r.c||{}}};
           sayyl "iibod: ". ki $r;
           
           
           Rw om/lev + $oM $M $t:r.r $c;
       }
       Rw iM + $oM:M;
 - K: ii/labegy #c suitcase handle
   D: |
     my $d;
     d.t = 'lab';
     d.c.s = r.r;
     d.sc.ws = 'p';
     d.sc.ab = 'right:0.5em';
     d.c.fsx = "25";
     Rw iiJM + $d;
 - K: ii/pi #c THE WHOLE GHUTS
   D: |
     my $d;
     d.t = 'pi';
     my $o = {};
     o.u = r.s;
     o.cv = 0.6;
     my $pi = [r.s, 0.6];
     push @$pi, r.c.pi if r.c.pi;
     d.c.fo = $pi;
     d.c.path = r.path;
     d.c.L = $r;
     d.c.X = $x;
       
     d.sc.ws = 'n';
     d.sc.ab = 'left:1em';
     d.sc.mw = '14em';
     d.sc.over = 'hidden';
     say wdump [$d, from => $r] if r.s =~ /pidgeon/;
     Rw iiJM + $d;

