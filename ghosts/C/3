
R_surz: #c
    - K: maka_styley #c
      babz:
        'makaout 0.31': |
            for my $k (%{a.bb}) {
                if ($k =~ /^(\S*(?:oB|Bo|Bi|Bs))\s+(.+)$/) {
                    a.bb->{"$1\%css $2"} = "color:black";
                }
                if ($k =~ /^thi\s+(.+)$/) {
                    a.bb->{"thi\%css $1"} = "text-decoration:underline";
                }
                if ($k =~ /^name\s+(.+)$/) {
                    a.bb->{"name\%css $1"} = "color:#f93";
                }
            }
    - K: forkpi #c
      spesh: 0
      babz:
        'gp#fork_layert 5.6': | 
            if (a.cv > 0.2 && !a.replaceJid) {
                my $la = {%$a};
                la.origin_inarow = G.gp_inarow;
                a.isJid = la.replaceJid = $H->mkuid;
                my $lyt = a.R.layert ||= [];
                push @$lyt, $la;
                a.forking = $la;
                a.cv = 0.1;
                $ping = 1;
            }
        'S#waylayert_pias 8.8': |
            if (my $pias = delete R.layert) {
                # my $it = natatime 5, @$pias;
                # TODO they come back out of order of attachment 
                # fork only the top level pi, not pi within pi?
                # promise pi, makaout executes?
                $G->timer(0, sub {
                    w $R forkpi/pias[$pias];
                });
            }
        'gp 6.2': |
            R.a.pis->{a.isJid} = $a;
        'gp 7.1': |
            a.forking.wash = $H->dig($html) if a.forking;
        'S#tidy 0.113': |
            if (my $tokill = delete R.S_forkpi_tokill) {
                kill 'KILL', $_ for @$tokill;
            }
      n_D:
        pias: |
            if (my $pid = fork()) {
                my $Sftk = R.S_forkpi_tokill ||= [];
                push @$Sftk, $pid;
                return
            }
            H.db = H.pg->db;
            # child must exit, after reporting error
            # so nothing else can happen. listening db handle gone anyway?
            my $bail = sub{ exit };
            $G->accum($G0, _aft_err_do => $bail);
            $G->accum($F[0], _aft_etc_do => $bail);
            
            sayyl "pier Forked... ";
            
            my @js;
            my $group = 2;
            for my $a (@$pias) {
                my $html = w $R gp[$a];
                next if a.wash eq $H->dig($html);
                my $set = $H->ejson($html);
                my $id = a.replaceJid || die;
                my $js = qq{ \$('#$id').replaceWith($set);};
                push @js, $js;
                if (@js >= $group) {
                    $H->send(join '', @js);
                    @js = ();
                }
            }
            $H->send(join '', @js) if @js;
            saygr "pier done ".F_delta;
            
    - K: prot_fits #c
      babz:
        'S#proto_fits 8.7': |
          # proto fits: shrink this webbing into a space in our webbing
          my @sty;

          my $o = 12;
          my $lines = split /\n/, $html;
          if ($lines > $o) {
              $lines = 17 if $lines > 17;
              my $fs = 100 * $o / $lines;
              $fs *= -1 if $fs < 0;
              push @sty, "font-size:$fs%";
          }
          push @sty, "background:rgba(80,50,22,0.3)"; 
          push @sty, "white-space:pre";
          push @sty, "font-family:mono";
          push @sty, "display:block";
          push @sty, "overflow-wrap:break-word";
          my $sty = join ";", @sty; 
          $html = qq{<span style="$sty"><span>$html<span></span>};
      
    - K: keyba #c
      spesh: 1
      babz:
        'keys 3': |
          saygr "doings of $do";
          R.thedoings = $do;
        'S#keybas 3.32': |
          a.bz->('keybas 3.32', "Yogo R.thedoings!");
      

    - K: Num #c
      key: {0: out, number: in}
      n_D:
            out: |
              return R.ksuc = "" if R.ksuc && $k eq "0";
              my @trav = $G->chuntr(R.J.trav);
              pop @trav;
              R.J.trav = join '', @trav;
            in: |
              R.ksuc .= $k;
              my $j = R.a.ro->{R.ksuc};
              
              if (!$j) {
                  w unchanged[$R];
                  sayre "no j ye for R.ksuc" for 1..5;
                  return;
              }
              sayyl "got $j j.t j.cv for R.ksuc";


              R.ksuc = "";
              if (R.a.travly) {
                  R.J.trav =~ s/\^.+?$// || die;
              }

              my ($hop) = $G->chuntr(j.t);
              R.J.trav .= $hop; 
    - K: Jtwo #c
      babz:
        'S#unifromA 1.0134': |
            w $R Jtwo/uni;
      n_D:
        uni: |
            my $i = R.J.from || die;
            my $t = R.J.trav || '';
            my @tr = $G->chuntr($t);

            for (@tr) {
                /^(.)(.+)$/;
                say "Sapped ".slim($i)."       $1 $2";
                last if $1 eq " ";
                $i = $i->{$2} if $1 eq "{";
                $i = $i->[$2] if $1 eq "[" && (ref $i eq 'ARRAY' || die "NOT!");
                if ($1 eq '^') {
                    R.a.travly = $2;
                    last;
                }
            }
            if ($t =~ m/^.+? (.+)$/) {
                say "Had some more: $1";
            }
            R.a.i = $i;
    - K: Sud #c
      n_D:
            in: |    # ebrace flying embryo J
                R.J = { from => ar.i };
                R.J.trav = ar.t if ar.t;
    
    - K: dusmatic #c
      babz:
        'S 2.1004': |
          a.s = R.S.s || w $R dus;
          a.s.HASH.oh = 0.2;
          a.tr.rowlimit = R.S.rowlimit || 9*4;
    - K: stringlook #c
      babz:
        'S#string 3.14': |
          if (!%$d) {
            if (!ref a.i) {
              sayre "SDoing something else";
              my $sd = {};
              $G->D_to_style({K=>"s",D=>a.i}, $sd);
              my @ksd = keys %$sd;
              for my $k (@ksd) {
                my $s = $sd->{$k};
                my ($ind) = $k =~ /^s\t(.+)$/;
                my $v = $ind eq R.a.travly ? 0.8 : do {
                    #$s = join "\n", (split /\n/, $s)[0];
                    @ksd < 9 ? 0.7 : R.a.e;
                };
                $d->{"^$ind\t$v"} = $s;
              }
            }
          }
        'pi/text 7': |
            my $col = $G->vimcolor($u);
            
            my $lim = ";height:5em;overflow-y:scroll" if a.c.lin > 8;
            $lim .= ";background:rgba(30,30,60,0.9)" if a.cv > 0.7;
            
            a.bz->("line 0.1" => $col, '%gp'=>{vimcolor=>1},
                '%css' => "margin:0em;background:rgba(0,0,50,0.9);font-size:82%;-webkit-filter:hue-rotate(200deg) brightness(3) contrast(0.8);$lim");
    - K: adu #c
      babz:
        'S#du 3.1': | 
          a.e ||= R.S.e || die;
          defined a.i || die;
          #a.e = a.e + 2;
          
          my $d;
          my $an = {u=>a.i, cv=>0.4};
          w $R gp(a=>$an);
          a.i = an.bb if R.double;
          $d = w $R du;
          # 3.14
          
        'S#aduhummings 4.01': |
          w $R adu/humms[$a, $d];
          a.bz->('sheer 0.7565' => "travly:".R.a.travly);
      n_D:
        humms: |
          my @r = w stylekeysort[$d]; 
          my $si = @r;
          my @i = w wind[$si];
          my $ro = R.a.ro = {}; # wind round
          my $i = 0;
          for my $r (@r) {
              my $j = w $R shj[$r, $d];
              
              my $li = j.li = shift @i || die;
              $ro->{$li} = $j;
              #my $z = a.bz->("$li 
              
              a.bz->("${li}_Bs 0.3 0.3${li}0" => "\n") if $i > 0;
                   
              a.bz->("${li}_li 0.3 0.3${li}1", j.li,
                  '%sf', 'blue_fs120');

              my $t = j.t;
              $t .= join("", (" ") x (6 - length($t))) if length($t) < 6;
              a.bz->("${li}_k 0.3 0.3${li}2", $t,
                  '%sf', 'black');

              my $cv = j.cv;
              $cv =~ s/^0//;
              a.bz->("${li}_cv 0.3 0.3${li}22", $cv,
                  '%sf', 'red_fs80');

              a.fro->("${li}_s 0.3 0.3${li}4", j.s, j.cv,
                  '%sf', 'white_fs120');
                  
              
              
              #a.fro->("${li}_si 0.3 0.3${li}8", j.s.A.n_pyramid, 0.2, '%sf', 'white_fs120');
                  
              
              

              #sayyl " S_4[$i => $li   ".$G->F_delta;
              $i++; 

          }
    - K: self_Jness #c
      babz:
         'S 4.1': |
            a.fro->('H 0.01' => $H, 0.2);

            a.fro->('G 0.02' => $G, 0.2);

            a.fro->('R 0.11' => $R, 0.2);
         'S 4.2': |
            a.fro->('R_J_from 0.12' => R.J.from, 0.2);

            a.fro->('R_J_trav 0.13' => R.J.trav, 0.2, '%sf' => 'black_fs120'); 

            a.bz->('R_S_e 0.2' => R.S.e, '%sf' => 'white');

            a.fro->('R_a_i 0.21' => R.a.i, 0.2);

            a.bz->('Js 0.29' => "\n");
            
    - K: goto #c
      key:
        J: J
        M: RwS
        SM: SM
        F: F
        H: H
        W: W
        G: G
        S: S
      n_D:
        S: |
          my ($GG) = grep { $_ ne $G && _.name =~ /^C(?!\/)/} @{H.G.GGs};
          die "No other G named 'C'" unless $GG;
          my $otheR = $GG w are;
          w $R Sud/in(i=>$otheR);

        H: |
          w $R Sud/in(i=>H.G.GGs);
        RwS: |
          R.J = {from=>$R,trav=>'{way{hooks{S'};
        SM: |
          R.J = {from=>$R,trav=>'{way{hooks{goto'};
        J: |
          my $J = a.i = R.A->spawn('J');
          J.W = G.GG.U.W;
          J.hol = "H.style/H.name/H.id";
          J.tiNZ = J.W.at.styles =~ /\bNZ\b/;
          J.hitime = $H->hitime;
          # throw J into Pg
              #G0.Wh->{$ww} = $W;
          w $R Sud/in(i=>$J);
        W: |
          my $n = int rand 30000;
          R.J = { from => [$n,unico($n,1)]};
        F: |
              saygr "Trying!!!!" for 1..5;
              my @lot = w trythis;
              my $f = $F[0];
              w $R Sud/in(i=>$f);
              sayyl "Trithings: $_ " for @lot;
    - K: Q #c
      key:
        SR: Redisy
        D: D
        Q: Q
        C: C
        K: K
        N: N
      n_D:
        N: |
          R.double = !R.double;
        K: |
          my $P = 0->anyway('P_sud');
          my $GG = $G;
          H.G w percs[$P, $GG];
        C: |
          H.G w reexec;
        Q: |
          my $g = G:C/ool;
          w $R Sud/in(i=>$g);
        Redisy: |
              R.J = {
                from => [reverse sort H.r->keys("*")],
              };
        D: |
            my $way = "C C/nv";
            my $K = "C".H.nn++;
            my $P = [{GAK => "$K $way"}];
            my $g = H.G w percs[$P];
            #my $g = G:$K;
            $g w ave(i=>$R);
            return;
            # make C elsewhere...
                sayre "Yeahp";
                my $with = "C/nv";
                $H->pub("S/hut/C", "percC $with");
    - K: chr0 #c
      spesh: 1
      babz:
         'S 4.01': |
           for my $i (1..10) {
               my $c;
               for my $ii (1..25) {
                   $c = 250 + ($i * 100) + $ii;
                   my $ch = unico($c);
                   a.bz->("ch_$c 3.011" , $ch);
               }
               a.bz->("ch_${c}_nl 3.011" => "\n");
           }

    - K: Vit #c
      key: {E: up, R: down}
      n_D:
            up: |
                R.S.e += 0.1;
            down: |
                R.S.e -= 0.1;

