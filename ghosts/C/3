
R_surz: #c
    - K: maka_styley #c
      babz:
        'makaout 0.31': |
            for my $k (%{a.bb}) {
                if ($k =~ /^(\S*(?:oB|Bo|Bi|Bs))\s+(.+)$/) {
                    a.bb->{"$1\%css $2"} = "color:black";
                }
                if ($k =~ /^thi\s+(.+)$/) {
                    a.bb->{"thi\%css $1"} = "text-decoration:underline";
                }
                if ($k =~ /^name\s+(.+)$/) {
                    a.bb->{"name\%css $1"} = "color:#f93";
                }
            }
    - K: forkpi #c
      spesh: 0
      babz:
        'gp#fork_layert 5.6': | 
            if (a.cv > 0.2 && !a.replaceJid) {
                my $la = {%$a};
                la.origin_inarow = G.gp_inarow;
                a.isJid = la.replaceJid = $H->mkuid;
                my $lyt = a.R.layert ||= [];
                push @$lyt, $la;
                a.forking = $la;
                a.cv = 0.1;
            }
        'S#waylayert_pias 8.8': |
            if (my $pias = delete R.layert) {
                # my $it = natatime 5, @$pias;
                # TODO they come back out of order of attachment 
                # fork only the top level pi, not pi within pi?
                # promise pi, makaout executes?
                $G->timer(0, sub {
                    w $R forkpi/pias[$pias];
                });
            }
        'gp 8.3': |
            if (my $Jid = a.isJid || a.replaceJid) {
                $html = qq{<nnn id="$Jid">$html</nnn>};
                a.forking.wash = $H->dig($html) if a.forking;
            }
        'S#tidy 0.113': |
            if (my $tokill = delete R.S_forkpi_tokill) {
                kill 'KILL', $_ for @$tokill;
            }
      n_D:
        pias: |
            if (my $pid = fork()) {
                my $Sftk = R.S_forkpi_tokill ||= [];
                push @$Sftk, $pid;
                return
            }
            H.db = H.pg->db;
            # child must exit, after reporting error
            # so nothing else can happen. listening db handle gone anyway?
            my $bail = sub{ exit };
            $G->accum($G0, _aft_err_do => $bail);
            $G->accum($F[0], _aft_etc_do => $bail);
            
            sayyl "pier Forked... ";
            
            my @js;
            my $group = 2;
            for my $a (@$pias) {
                my $html = w $R gp[$a];
                next if a.wash eq $H->dig($html);
                my $id = a.replaceJid || die;
                my $js = qq{ \$('#$id').replaceWith('$html');};
                push @js, $js;
                if (@js >= $group) {
                    $H->send(join '', @js);
                    @js = ();
                }
            }
            $H->send(join '', @js) if @js;
            saygr "pier done ".F_delta;
            
    - K: prot_fits #c
      babz:
        'S#proto_fits 8.7': |
          # proto fits: shrink this webbing into a space in our webbing
          my @sty;

          my $o = 12;
          my $lines = split /\n/, $html;
          if ($lines > $o) {
              my $fs = 100 * $o / $lines;
              $fs *= -1 if $fs < 0;
              push @sty, "font-size:$fs%";
          }
          push @sty, "background:rgba(80,50,22,0.3)"; 
          push @sty, "white-space:pre";
          push @sty, "font-family:mono";
          push @sty, "display:block";
          push @sty, "overflow-wrap:break-word";
          my $sty = join ";", @sty; 
          $html = qq{<span style="$sty"><span>$html<span></span>};
      
    - K: keyba #c
      spesh: 1
      babz:
        'keys 3': |
          saygr "doings of $do";
          R.thedoings = $do;
        'S#keybas 3.32': |
          a.bz->('keybas 3.32', "Yogo R.thedoings!");
      


    - K: Jto #c
      babz:
        'S#unifromA 1.0134': |
          my $unifro = {
              i => R.J.from || die,
              t => R.J.trav || "",
          };
          R.a.i ||= w $R uni(%$unifro);
    - K: dusmatic #c
      babz:
        'S 2.1004': |
          a.s = R.S.s || w $R dus;
          a.s.HASH.oh = 0.2;
          a.tr.rowlimit = R.S.rowlimit || 9*2;
    - K: adu #c
      babz:
        'S 3.1': | 
          #a.i = [a.i->anyway('hooks')];
          a.e ||= R.S.e || die;
          
          my $d = w $R du;
          if (!%$d) {
            if (!ref a.i) {
              my $sd = {};
              $G->D_to_style({K=>"s",D=>a.i}, $sd);
              for my $k (keys %$sd) {
                my $v = $sd->{$k};
                my ($ind) = $k =~ /^s (.+)$/;
                $d->{"^$ind 0.2"} = $v;
              }
              my $inter = 4.01;
              $d->{"^$inter 0.7"} = delete $d->{"^$inter 0.2"};
            }
          }
        'S#aduhummings 4.01': |
          w $R adu/humms[$a, $d];
      n_D:
        humms: |
          my @r = w stylekeysort[$d]; 
          my $si = @r;
          my @i = w wind[$si];
          my $ro = R.a.ro = {}; # wind round
          my $i = 0;
          for my $r (@r) {
              my $j = w $R shj[$r, $d];
              
              my $li = j.li = shift @i || die;
              $ro->{$li} = $j;
              #my $z = a.bz->("$li 
              
              a.bz->("${li}_Bs 0.3 0.3${li}0" => "\n") if $i > 0;
                   
              a.bz->("${li}_li 0.3 0.3${li}1", j.li,
                  '%sf', 'blue_fs120');

              my $t = j.t;
              $t .= join("", (" ") x (6 - length($t))) if length($t) < 6;
              a.bz->("${li}_k 0.3 0.3${li}2", $t,
                  '%sf', 'black');

              my $cv = j.cv;
              $cv =~ s/^0//;
              a.bz->("${li}_cv 0.3 0.3${li}22", $cv,
                  '%sf', 'red_fs80');

              a.fro->("${li}_s 0.3 0.3${li}4", j.s, j.cv,
                  '%sf', 'white_fs120');

              #sayyl " S_4[$i => $li   ".$G->F_delta;
              $i++; 

          }
    - K: self_Jness #c
      babz:
         'S 4.1': |
            a.fro->('H 0.01' => $H, 0.2);

            a.fro->('G 0.02' => $G, 0.2);

            a.fro->('R 0.11' => $R, 0.2);
         'S 4.2': |
            a.fro->('R_J_from 0.12' => R.J.from, 0.2);

            a.fro->('R_J_trav 0.13' => R.J.trav, 0.2, '%sf' => 'black_fs120'); 

            a.bz->('R_S_e 0.2' => R.S.e, '%sf' => 'white');

            a.fro->('R_a_i 0.21' => R.a.i, 0.2);

            a.bz->('Js 0.29' => "\n");
            
    - K: Q #c
      key:
        SR: Redisy
        W: W
        G: G
        F: F
        D: D
        S: S
        Q: Q
        C: C
        H: H
        J: J
      n_D:
        J: |
          my $i = [map{_.i} G:0 ->scGre({})];
          w $R Sud/in[$i];
        H: |
          w $R Sud/in(i=>H.G.GGs);
        C: |
          H.G w reexec;
        Q: |
          my $g = G:C/ool;
          w $R Sud/in(i=>$g);
        G: |
          w $R Sud/in(i=>$R,t=>'{way{hooks{S');
        Redisy: |
              R.J = {
                from => [reverse sort H.r->keys("*")],
              };
        W: |
          my $n = int rand 30000;
          R.J = { from => [$n,unico($n,1)]};
        F: |
              saygr "Trying!!!!" for 1..5;
              my @lot = w trythis;
              my $f = $F[0];
              w $R Sud/in(i=>$f);
              sayyl "Trithings: $_ " for @lot;

        D: |
                sayre "Yeahp";
                my $with = "C/nv";
                $H->pub("S/hut/Z", "percC $with");
        S: |
                my ($GG) = grep { $_ ne $G && _.name =~ /^C(?!\/)/} @{H.G.GGs};
                die "No other G named 'C'" unless $GG;
                my $otheR = $GG w are;
                w $R Sud/in(i=>$otheR);
    - K: chr0 #c
      spesh: 1
      babz:
         'S 4.01': |
           for my $i (1..10) {
               my $c;
               for my $ii (1..25) {
                   $c = 250 + ($i * 100) + $ii;
                   my $ch = unico($c);
                   a.bz->("ch_$c 3.011" , $ch);
               }
               a.bz->("ch_${c}_nl 3.011" => "\n");
           }
    - K: Vit #c
      key: {E: up, R: down}
      n_D:
            up: |
                R.S.e += 0.1;
            down: |
                R.S.e -= 0.1;
    - K: Num #c
      key: {0: out, number: in}
      n_D:
            out: |
              return R.ksuc = "" if R.ksuc && $k eq "0";
              return $R->popJtrav
            in: |
              R.ksuc .= $k;
              my $j = R.a.ro->{R.ksuc};
              
              if (!$j) {
                  w unchanged[$R];
                  sayre "no j ye for R.ksuc" for 1..5;
                  return;
              }
              sayyl "got $j j.t j.cv for R.ksuc";

              R.ksuc = "";

              my ($hop) = split /(?=\{|\[)/, j.t;
              R.J.trav .= $hop; 
    - K: Sud #c
      n_D:
            in: |    # ebrace flying embryo J
                my $a = $ar;
                R.J = { from => a.i };
                R.J.trav = a.t if a.t;
    

