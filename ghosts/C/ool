name: psych synth

GG:
 - K: xI
   way: T/ux
   W_Ss: [X]
   M_Ss: [ooo, tr]
   M_Z: {font-size: 500%}
   
 - K: gI
   way: T/ux
   W_Ss: [X]
   W_Z: {width: 5em, background: blue, z-index: 5, width: 5em}
   M_Ss: [g]
   M_Z: {font-size: 80%}
C:
 - K: Ims #c
   flows_D: |
      my @finds = grep { !/MANY/ && !/gif$/ } map { 0->fs_find($_) } $dir;
      for my $file (@finds[0..3]) {
          0->TafuBl(Im => { file => $file });
      }
      
 - K: Im #c
   V: oom
   print: $file
   flows_D: |
     (B.href) = $file =~ /(i\/.+$)/;
     w se/sa[$S];
     0->TafuBl(Lingos => {l => '☯', hmm => rand(1)});
   Anim:
     opacity: 10
     padding: 10 # * 100ms = 1s
   S:
     style_D: |
       { 'background-image',"url('$href')",
         %{S.Z||{}} }
   styles: Im -te
   tag: Im
   ux:
     spawn: []
 
 - K: Lingos #c
   V: oom
   styles: Lingos -te
   S:
     content_D: $l
     style_D: |
       { %{S.Z||{}} }
     ishtml: 1
   ux:
     spawn: []
 
   
 
 - K: Ra #c
   flows_D: |
     S.timezs = sub { my ($time) = shift;
                       join "x", map { $time->{$_} } sort keys %$time; };
     Sw lat;
     Sw riv;
   e: 8/9
   riv: | #c riv
     now.1++;
     if (now.1 == time.1) {
         now.1 = 0;
         now.0++;
        if (now.0 == time.0) {
             now.0 = 0;
        }
     }
     my $at = S.timezs->($now);
     for my $ma (grep {
         my $u = $_; $u =~ s/_/./g; $at =~ /^$u$/
            }
            sort keys %{S.Dz}) {
         Sw Dz/$ma[$at];
     }
   lat: |
     S.dead && return;
     if (G.maxloadav && (`uptime` =~ /load average: (\S+),/)[0] > G.maxloadav) {
         sayre "load average is $1, sleep for 5...";
         sleep 5;
     }
     $G->timer(Sw e, sub { Sw lat; Sw riv; });
S:
 - K: ooo #c
   Ss:
    - K: te
      css: 
        - border-bottom:1px solid black
        - float:left
        - position:relative
        - width:100%
        - background:rgba(150,100,50,0.7)
    - K: yi
      css: [font-size:77%]
    - K: yo
      css: [font-size:40%]
    - K: yt
      css: [color:#873, font-size:80%, padding:1em]
    - K: yw
      css: [font-size:60%]
    - K: resize
      css:
       - overflow:hidden
       - -moz-resize:both
       - resize:both
        
    - K: Im #c
      css:
       - border:0.03em solid black
       - width:49%
       - padding:2em
       - background-size:100%
     
    - K: Lingos
      css:
       - font-size:222%
       - z-index:50000
     
    - K: Ims
    - K: Ooogida
      css:
       - width:100%
       
    - K: reson
      css:
       - background:rgba(255,23,55,0.3)
       - border:0.03em solid rgba(140,120,50,0.8)
       - padding:0.1em
       
    - K: underline
      css: [text-decoration:line-through]
       
    - K: blue
      css:
       - background:rgba(23,23,125,0.1)
       - padding:1em
    
    - K: blur2
      css: 
       - -webkit-animation:blur 3s infinite
    - K: blur
      keif:
       - K: 0%, 100%
         css:
          - -webkit-filter:blur(0px)
       - K: 50%
         css:
          - -webkit-filter:blur(10px)
          
 - K: g #c sidecar
   Ss:
    - K: te
      css: 
        - border-bottom:1px solid black
        - float:left
        - position:relative
        - width:100%
        - background:rgba(150,100,50,0.7)
        
 - K: tr #c y-toro
   Ss:
    - K: satn
      spawns: |
        map { $S->spawn->from({
            K=>"sat$_",
            css=>["-webkit-filter:saturate($_)"],
        }) } 1..9
    - K: brin
      spawns: |
        map { $S->spawn->from({
            K=>"bri$_",
            css=>["-webkit-filter:brightness($_)"],
        }) } 1..9
    - K: conn
      spawns: |
        map { $S->spawn->from({
            K=>"con$_",
            css=>["-webkit-filter:contrast(".($_*2).")"],
        }) } 1..9
    - K: invn
      spawns: |
        map { $S->spawn->from({
            K=>"inv$_",
            css=>["-webkit-filter:invert(0.$_)"],
        }) } 1..9
    - K: huen
      spawns: |
        map { $S->spawn->from({
            K=>"hue$_",
            css=>["-webkit-filter:hue-rotate(".int((360/9)*$_)."deg)"],
        }) } 1..9
    - K: blrn
      spawns: |
        map { $S->spawn->from({
            K=>"blr$_",
            css=>["-webkit-filter:blur(".($_*2)."px)"],
        }) } 1..9
    - K: gran
      spawns: |
        map { $S->spawn->from({
            K=>"gra$_",
            css=>["-webkit-filter:grayscale(0.$_)"],
        }) } 1..9
    - K: dead
      css:
        - background:#0d0e4d
    - K: ref
      css:
        - '-webkit-box-reflect: below -5px -webkit-gradient(linear, left top, left bottom, from(transparent), to(rgba(255, 255, 255, 0.3)))'
    - K: sativo
      css:
       - -webkit-filter:brightness(1.5) saturate(2)
perc_BS:
  - K: Ims
    B:
      dir: /s/public/i/
      
  - K: Ra
    e: |
     25/2
    B:
      name: Wa
      time: {0: 4, 1: 4}
      now: {0: 0, 1: 0}
    Dz:
     0x2: |
       w f/te;#textual
     1x2: |
       w f/ph;#ase
     2x2: |
       w f/at;#titude
     _x3: |
       w uxds;
     _x1: |
       w uxds;
  
  - K: Ra
    e: 14/2
    B:
      name: Ba
      time: {0: 2, 1: 3}
      now: {0: 0, 1: 0}
    Dz:
     0x2: |
       w f/te;#textual
       w f/rotation;
     1x1: |
       w f/at;#titude
       w f/rotation;
hooks:
  any_init: |
    $G->timer(22, sub { Say "turning on maxloadav"; G.maxloadav = 2.4; });
  percolate: |
    my $BS = $G->anyway('perc_BS'); # G0
    return unless $BS;
    for my $uS (@$BS) {
        next if uS.K eq "Ra";
        my $u = 0->sway({K=>uS.K}, $uS);
        0->Tafu($u);
    }
    # alright so... see styles run around
    # mod styles to mod waves of stuff
    # start full of shit:
     w f/drumroll;
     
    G.GG.gI->w('ux', {Ls => [0->scGre({K=>"Ims"})]});
    
  keys:
    t: |
      w f/at;
    i: |
      #w f/rose;
    y: |
      w f/aty;
    e: |
      w f/rotation;
    E: |
      w f/tallpaddy;
    u: |
        for my $S (w W/reitropy(K=>"Im")) {
            if (S.resty) {
                S.styles =~ s/$_// for split ' ', S.resty;
                delete S.resty;
            }
        }
        my $res = w restyfor(S=>{});
        for my $S (w W/reitropy(K=>"Im")) {
            next if rand(1) < 6/9;
            S.resty = $res;
            S.styles .= " $res";
        }
    p: |
      w f/ph;
      
  se: # mod
    opa: S.Z.opacity = "0.".int(rand(9));
    pad: S.Z.padding = int(rand 9).'em';
    sat: w crank(+ s=>'sat');
    bri: w crank(+ s=>'bri');
    con: w crank(+ s=>'con');
    hue: w crank(+ s=>'hue');
  crank: |
    S.styles =~ s/$s(-?\d+)//;
    my $d = $1+1;
    $d += ar.di - 1 if ar.di;
    $d -= 9 until $d <= 9;
    say "$s $d";
    S.styles .= " $s$d";
  
  f: # flux
    rose: |
       my @rose = read_file("trampled_rose_lyrics");
       my @randoms = shuffle( grep { /\w/ } @rose );
       
        for (1..2) {
            my $S = 0->TafuB(Lingos => { l => shift @randoms});
            say "S.B.l";
            S.Z = {%{S.Z||{}},
                'font-size' => int(rand(5)+1).'00%',
                position => "fixed",
            };
        }
    tallpaddy: |
      for my $S (w W/reitropy(K=>"Im")) {
          if (S.Z.padding > 7) {
              w se/pa[$S]; 
          }
      }
    rotation: |
      my ($unI) = w W/reitropy(K=>"Im");
      for my $ux ($unI->LioO('ux')) {
          my $uxid = ux.at.id;
          $H->JS("var p = \$('#$uxid').parent(); \$('#$uxid').detach().appendTo(p);");
      }
    drumroll: |
      w f/at(di => 420);
      w f/at(di => 420);
      w f/ph;
      w f/ph;
      w f/lingpa;
    lingpa: |
      for my $S ((w W/reitropy(K=>"Lingos"))[1..3]) {
            S.Z.padding = int(rand 24).'em';
      }
    at: |                                            # at x2 #c
        say "@";
        my $di = ar.di || 2;
        for my $S ((w W/reitropy(K=>"Im"))[1..$di]) {
            next unless $S;
            w se/pad[$S];
            next if rand(1) < 5/9;
            w se/opa[$S];
            next if rand(1) < 2/9;
            S.Z.padding = int(rand 20).'em';
        }
        if (rand(1) < 2/9) {
            w f/ph;
            w f/rotation;
        }
        if (rand(1) < 1/9) {
            w f/tallpaddy;
            w f/ph;
        }
    te: | # at x1, x3
      say 'te';
      for my $S ((w W/reitropy(K=>"Lingos"))[1..4]) {
          my $o = shuffle qw'☯ ☯ ☯ ☯ ᣜ ☭ Ϡ ᣝ ⍲ ⍲ ⍲ ⍲', " s҉", "ෙ";
          S.B.l = $o;
      }
    ph: |                                            # at 0x0
        for my $S ((w W/reitropy(K=>"Im"))[1..3]) {
            if (S.resty) {
                S.styles =~ s/$_// for split ' ', S.resty;
            }
            (S.resty) = grep { !S.resty || $_ ne S.resty } w restyfor[$S];
            S.styles .= " S.resty";
        }
  restyfor: |
    my @bang = ("sat6 opa2 con2 blr2 inv9", "ref sat9 bri4", 'ref sat9', 'ref blr8 con9 hue3',
        'inv9 sat9 blr2 hue8', 'inv4 bri7 blr5 con5', 'inv3 blr2 con1 hue6', 
        'blr2 bri3 con5 gra8 hue8 inv8 sat5'
        );
    my @colar = ("sat9 blr2 inv4 con8", "sat3 blr5 inv9 con9", 'ref sat6 bri3 inv2');
    push @bang, @colar;
    @bang = @colar if S.B.file =~ /art/;
    return shuffle(@bang);
  uxds: |
    0->sing("G.name uxd", sub { w uxd; });
    say `uptime`;
  W:
    reitropy: |
      shuffle(0->rei({K=>$K}));
  index_clickspace: |
    my $Mid = G.T.W.uuid;
    my ($x, $y) = (e.x, e.y);
    my $what = ar.what || "ux.Im" || "ux";
    $H->JS(" var hit = [];
    \$('#$Mid > $what').filter(function() {
        return \$(this).offset().left < $x
            && \$(this).offset().left + \$(this).width() > $x
            && \$(this).offset().top < $y
            && \$(this).offset().top + \$(this).height() > $y
    }).each(function() {
        hit."."push(this."."id())
    });
    ws."."send({i=>hit});"); # TODO makes the server hang or something?
  event: |
    sayyl "Event relating to ".pint(L.i);
    0->visTp({L=>$L},'Fun');
    #sw ($ar);
    # try and hit E/elabourateness and then blunten until whatever
    if (e.S) {
        w $u zoum;
    }
    else {
        w $u E/_D;
    }
    waylay uxd;
    
  recoded_init: |
    for my $i (map {_.i} 0->scGre()) {
        my $up = 0->CsK({K=>i.K});
        $i->from($up);
    }
  uxd: |
    my @Im = 0->scGre({V=>"oom"});
    G.GG.xI->w('ux', {Ls => [@Im]});
  

