name: psych synth

GG:
 - K: xI
   way: T/ux
   W_Ss: [X]
   W_Z: {left: 5em, width: calc(100% - 5em)}
   M_Ss: [ooo, tr]
   M_Z: {font-size: 500%}
   
 - K: gI
   way: T/ux
   W_Ss: [X]
   W_Z: {width: 5em, background: black}
   M_Ss: [g]
   M_Z: {font-size: 80%}
C:
 - K: Ims #c
   flows_D: |
      my @finds = grep { !/MANY/ && !/gif$/ } map { 0->fs_find($_) } $dir;
      for my $file (@finds) {
          0->TafuBl(Im => { file => $file });
      }
   print: $dir
   styles: Ims
   tag: Ims
   ux:
     spawn:
      - K: i
      - K: t
      
 - K: Im #c
   V: oom
   print: $file
   flows_D: |
     (B.href) = $file =~ /(i\/.+$)/;
     w se/sa[$S];
     0->TafuBl(Lingos => {l => '☯', hmm => rand(1)});
   Anim:
     opacity: 10
     padding: 10 # * 100ms = 1s
   S:
     style_D: |
       { 'background-image',"url('$href')",
         %{S.Z||{}} }
   styles: Im -te
   tag: Im
   ux:
     spawn: []
 
 - K: Lingos
   V: oom
   styles: Lingos -te
   S:
     content_D: $l
     style_D: |
       { %{S.Z||{}} }
     ishtml: 1
   ux:
     spawn: []
 
   
 
 - K: Ra #c
   flows_D: |
     S.timezs = sub { my ($time) = shift;
                       join "x", map { $time->{$_} } sort keys %$time; };
     Sw lat;
     Sw riv;
   e: 8/9
   riv: | #c riv
     now.1++;
     if (now.1 == time.1) {
         now.1 = 0;
         now.0++;
        if (now.0 == time.0) {
             now.0 = 0;
        }
     }
     my $at = S.timezs->($now);
     say "S.id @".$at;
     for my $ma (grep {
         my $u = $_; $u =~ s/_/./g; $at =~ /^$u$/
            }
            sort keys %{S.Dz}) {
         Sw Dz/$ma[$at];
     }
   lat: |
     S.dead && return;
     $G->timer(Sw e, sub { Sw lat; Sw riv; });
S:
 - K: ooo #c
   Ss:
    - K: te
      css: 
        - border-bottom:1px solid black
        - float:left
        - position:relative
        - width:100%
        - background:rgba(150,100,50,0.7)
    - K: yi
      css: [font-size:77%]
    - K: yo
      css: [font-size:40%]
    - K: yt
      css: [color:#873, font-size:80%, padding:1em]
    - K: yw
      css: [font-size:60%]
    - K: resize
      css:
       - overflow:hidden
       - -moz-resize:both
       - resize:both
        
    - K: Im #c
      css:
       - border:0.03em solid black
       - width:49%
       - padding:2em
       - background-size:100%
     
    - K: Lingos
      css:
       - font-size:600%
       - z-index:500
     
    - K: Ims
    - K: Ooogida
      css:
       - width:100%
       
    - K: reson
      css:
       - background:rgba(255,23,55,0.3)
       - border:0.03em solid rgba(140,120,50,0.8)
       - padding:0.1em
       
    - K: underline
      css: [text-decoration:line-through]
       
    - K: blue
      css:
       - background:rgba(23,23,125,0.1)
       - padding:1em
    
    - K: blur2
      css: 
       - -webkit-animation:blur 3s infinite
    - K: blur
      keif:
       - K: 0%, 100%
         css:
          - -webkit-filter:blur(0px)
       - K: 50%
         css:
          - -webkit-filter:blur(10px)
          
 - K: g #c sidey thing
   Ss:
    - K: te
      css: 
        - border-bottom:1px solid black
        - float:left
        - position:relative
        - width:100%
        - background:rgba(150,100,50,0.7)
        
 - K: tr #c y-toro
   Ss:
    - K: satn
      spawns: |
        map { $S->spawn->from({
            K=>"sat$_",
            css=>["-webkit-filter:saturate($_)"],
        }) } -6, -3, 0, 3, 6, 9
    - K: dakn
      spawns: |
        map { $S->spawn->from({
            K=>"dak$_",
            css=>["-webkit-filter:brightness($_)"],
        }) } -6, -3, 0, 3, 6, 9
    - K: conn
      spawns: |
        map { $S->spawn->from({
            K=>"con$_",
            css=>["-webkit-filter:contrast(".($_*2).")"],
        }) } -6, -3, 0, 3, 6, 9
    - K: invn
      spawns: |
        map { $S->spawn->from({
            K=>"inv$_",
            css=>["-webkit-filter:invert(".((1/9)*$_).")"],
        }) } 1..9
    - K: huen
      spawns: |
        map { $S->spawn->from({
            K=>"hue$_",
            css=>["-webkit-filter:invert(".int((360/9)*$_)."deg)"],
        }) } 1..9
    - K: sativo
      css:
       - -webkit-filter:brightness(1.5) saturate(2)
perc_BS:
  - K: Ims
    B:
      dir: /s/public/i/
      
  - K: Ra
    e: |
     25/9
    B:
      name: Wa
      time: {0: 4, 1: 4}
      now: {0: 0, 1: 0}
    Dz:
     _x3: |
       w f/te;#textual
       w f/ph;#ase
     0x0: |
       w f/at;#titude
    humms_D: |
      
    
        
hooks:
  percolate: |
    my $BS = $G->anyway('perc_BS'); # G0
    return unless $BS;
    for my $uS (@$BS) {
        my $u = 0->sway({K=>uS.K}, $uS);
        0->Tafu($u);
    }
    # alright so... see styles run around
    # mod styles to mod waves of stuff
    # start full of shit:
     w f/drumroll;
    
  keys:
    t: |
      w f/at;
    y: |
      w f/aty;
    u: |
      w f/
      
  se: # mod
    opa: |
      S.Z.opacity = "0.".int(rand(9));
    pad: |
      S.Z.padding = int(rand 14).'em';
    sat: |
      w crank(+ s=>'sat');
    dak: |
      w crank(+ s=>'dak');
    con: |
      w crank(+ s=>'con');
  crank: |
    S.styles =~ s/$s(-?\d+)//;
    my $d = $1+3;
    $d -= 15 until $d <= 9;
    say "$s $d";
    S.styles .= " $s$d";
  
  f: # flux
    drumroll: |
        my $j;
        for my $S (w W/reitropy(K=>"Im")) {
            my $j++;
            next if rand(1) < 2/9;
            w se/pad[$S];
            next if rand(1) < 6/9;
            w se/opa[$S];
        }
        say "Drumyol".join"",('l')x$j;
    aty: |
      for my $S ((w W/reitropy(K=>"Lingos"))[1..4]) {
              say S.K;
            _.Z->{'font-size'} = int(rand(5)+1).'00%'
      }
      w f/te;
        w uxds;
    ro: | # order
      my @eis = 0->rei({K=>'Im'});
      push @eis, shift @eis;
      0->reeni({K=>'Im'}, [@eis]);
    at: |                                            # at x2
        ar.di ||= 2;
        for my $S ((w W/reitropy(K=>"Im"))[1..ar.di]) {
            w se/pad[$S];
            next if rand(1) < 5/9;
            w se/opa[$S];
        }
        w uxds;
    te: | # at x1, x3
      for my $S ((w W/reitropy(K=>"Lingos"))[1..4]) {
          for (S.B.l) {
              s/☭/☯/ || s/☯/☭/;
          }
          #S.Z->{'font-size'} = int(rand(5)+1).'00%';
      }
      w uxds;
    ph: |                                            # at 0x0 #c
        sayyl "non ph";
        return; # http://css3clickchart.com/#resize
        my @eis = w W/rand;
        for my $S (@eis) {
            next unless S.phow;
            
        }
        for my $S (@eis[1..1]) {
            w se/con[$S];
            w se/sat[$S];
            next if rand(1) < 4/9;
            w se/dak[$S];
            next if rand(1) < 7/9;

        }
        w uxds;
  uxds: |
    0->sing("G.name uxd", sub { w uxd; });
  W:
    reitropy: |
      shuffle(0->rei({K=>$K}));
  index_clickspace: |
    my $Mid = G.T.W.uuid;
    my ($x, $y) = (e.x, e.y);
    my $what = ar.what || "ux.Im" || "ux";
    $H->JS(" var hit = [];
    \$('#$Mid > $what').filter(function() {
        return \$(this).offset().left < $x
            && \$(this).offset().left + \$(this).width() > $x
            && \$(this).offset().top < $y
            && \$(this).offset().top + \$(this).height() > $y
    }).each(function() {
        hit."."push(this."."id())
    });
    ws."."send({i=>hit});"); # TODO makes the server hang or something?
  event: |
    sayyl "Event relating to ".pint(L.i);
    0->visTp({L=>$L},'Fun');
    #sw ($ar);
    # try and hit E/elabourateness and then blunten until whatever
    if (e.S) {
        w $u zoum;
    }
    else {
        w $u E/_D;
    }
    waylay uxd;
    
  recoded_init: |
    for my $i (map {_.i} 0->scGre()) {
        my $up = 0->CsK({K=>i.K});
        $i->from($up);
    }
  uxd: |
    my @Im = 0->scGre({V=>"oom"});
    G.GG.xI->w('ux', {Ls => [@Im]});
  

