name: psych synth

GG:
 - K: xI
   way: T/ux
   In:
     C:
       W:
         S:
           styles: poi ab
         Z:
           border: 5px solid white
           background: url(i/greencush.jpg)
           margin: 8em
           height: calc(100% - 16em)
           width: calc(100% - 16em)
       M:
         Ss: [ooo, tr]
         Z:
           font-size: 500%
   
 - K: gI
   way: T/ux
   In:
     C:
       W:
         Ss: [X]
         Z:
           width: 5em
           background: blue
           z-index: 5
       M:
         Ss: [g]
         Z:
           font-size: 80%
W:
  - K: mooj
    B: {href: http://24.media.tumblr.com/tumblr_lzsfutEA3G1rop013o1_1280.jpg}
C:
 - K: Ims #c
   V: gI
   flows_D: |
      my @finds = grep { !/MANY/ && !/gif$/ } map { 0->fs_find($_) } $dir;
      for my $file (@finds[0..9]) {
          #0->TafuBl(Im => { file => $file });
          0->TafuBl(mooj => { file => $file }) if rand(1) < 4/9;
      }
      
 - K: mooj #c
   V: xI
   flows_D: |
     (B.href) = $file =~ /(i\/.+$)/;
   ux: {spawn: []}
   S:
     content_D: |
       "Y". S.B.href
     styles: -te mooj
     style_D: |
       { 'background-image',"url('$href')",
         %{S.Z||{}} }
      
 - K: Im #c
   V: xI
   print: $file
   flows_D: |
     (B.href) = $file =~ /(i\/.+$)/;
     0->TafuBl(Lingos => {l => '☯', hmm => rand(1)});
   Anim:
     opacity: 10
     padding: 10 # * 100ms = 1s
   S:
     style_D: |
       { 'background-image',"url('$href')",
         %{S.Z||{}} }
   styles: Im -te
   tag: Im
   ux:
     spawn: []
 
 - K: Lingos #c
   V: xI
   styles: Lingos -te
   S:
     content_D: $l
     style_D: |
       { %{S.Z||{}} }
     ishtml: 1
   ux:
     spawn: []
 - K: YouTube #c
   S:
     content_D: |
       my $vid = ar.vid || "PSNPpssruFY"; # Fats Waller - Aint Misbehavin
       qq {<iframe class="youtube-player" type="text/html" width="640" height="385"}
       .qq { src="http://www.youtube.com/embed/$vid" allowfullscreen frameborder="0"></iframe>};

 
 - K: Ra #c
   e: 8/9
   flows_D: |
     S.timezs = sub { my ($time) = shift;
                       join "x", map { $time->{$_} } sort keys %$time; };
     Sw lat;
     Sw riv;
   riv: |
     now.1++;
     if (now.1 == time.1) {
         now.1 = 0;
         now.0++;
        if (now.0 == time.0) {
             now.0 = 0;
        }
     }
     my $at = S.timezs->($now);
     for my $ma (grep { my $u = $_; $u =~ s/_/./g; $at =~ /^$u$/ } sort keys %{S.Dz}) {
         Sw Dz/$ma[$at];
     }
   lat: |
     S.dead && return;
     if (G.maxloadav && $H->la > G.maxloadav) {
         sayre "load average is $1, sleep for 5...";
         sleep 5;
     }
     $G->timer(Sw e, sub { Sw lat; Sw riv; });
S:
 - K: ooo
   Ss:
    - K: Im
      css:
       - border:0.03em solid black
       - width:49%
       - padding:2em
       - background-size:100%
       
    - K: mooj
      css:
       - text-shadow:2px 2px 4px rgb(0,0,255)
       - background-size:100%
     
    - K: Lingos
      css:
       - font-size:222%
       - z-index:50000
     
    - K: Ims
    
    - K: Ooogida
      css:
       - width:100%
    
    - K: blur2
      css: 
       - -webkit-animation:blur 3s infinite
    - K: blur
      keif:
       - K: 0%, 100%
         css:
          - -webkit-filter:blur(0px)
       - K: 50%
         css:
          - -webkit-filter:blur(10px)
          
 - K: g #c sidecar
   Ss:
    - K: te
      css: 
        - border-bottom:1px solid black
        - float:left
        - position:relative
        - width:100%
        - background:rgba(150,100,50,0.7)
        
 - K: tr #c y-toro
   Ss:
    - K: sat_n
      D: |
        u.Z->{flit}->{saturate} = $n;
    - K: bri_n
      D: |
        u.Z->{flit}->{brightness} = $n;
    - K: con_n
      D: |
        u.Z->{flit}->{contrast} = $n*2;
    - K: inv_n
      D: |
        u.Z->{flit}->{invert} = "0.$n";
    - K: hue_n
      D: |
        u.Z->{flit}->{'hue-rotate'} = int((360/9)*$n)."deg";
    - K: blr_n
      D: |
        u.Z->{flit}->{'blur'} = ($n*2)."px";
        }) } 1..9
    - K: gra_n
      D: |
        u.Z->{flit}->{'grayscale'} = "0.$n";
    - K: dead
      css:
        - background:#0d0e4d
    - K: ref
      css:
        - '-webkit-box-reflect: below -5px -webkit-gradient(linear, left top, left bottom, from(transparent), to(rgba(255, 255, 255, 0.3)))'
perc_BS:
  - K: Ims
    B:
      dir: /s/public/i/
      
  - K: Ra
    e: |
     25/2
    B:
      name: Wa
      time: {0: 4, 1: 4}
      now: {0: 0, 1: 0}
    Dz:
     0x2: |
       w f/te;#textual
     1x2: |
       w f/ph;#ase
     2x2: |
       w f/at;#titude
     _x3: |
       w uxds;
     _x1: |
       w uxds;
  
  - K: Ra
    e: 14/2
    B:
      name: Ba
      time: {0: 2, 1: 3}
      now: {0: 0, 1: 0}
    Dz:
     0x2: |
       w f/te;#textual
       w f/rotation;
     1x1: |
       w f/at;#titude
       w f/rotation;
hooks:
  any_init: |
    $G->timer(22, sub { Say "turning on maxloadav"; G.maxloadav = 2.4; });
  percolate: |
    my $BS = $G->anyway('perc_BS'); # G0
    return unless $BS;
    for my $uS (@$BS) {
        my $u = 0->sway({K=>uS.K}, $uS);
        $u = 0->Tafu($u);
        
    }
    # alright so... see styles run around
    # mod styles to mod waves of stuff
    # start full of shit:
     w f/drumroll;
     
    G.GG.gI->w('ux', {Ls => [0->scGre({V=>"gI"})]});
    w uxd;
    
  keys:
    t: w f/at;
    i: #w f/rose;
    y: w f/aty;
    e: w f/rotation;
    E: w f/tallpaddy;
    u: w f/restysets;
    p: w f/ph;
      
  se: # mod
    opa: S.Z.opacity = "0.".int(rand(9));
    pad: S.Z.padding = int(rand 9).'em';
    sat: w crank(+ s=>'sat');
    bri: w crank(+ s=>'bri');
    con: w crank(+ s=>'con');
    hue: w crank(+ s=>'hue');
  crank: |
    S.styles =~ s/$s(-?\d+)//;
    my $d = $1+1;
    $d += ar.di - 1 if ar.di;
    $d -= 9 until $d <= 9;
    say "$s $d";
    S.styles .= " $s$d";
  
  f: # flux
    restysets: |
        for my $S (w W/r(qw'K Im')) {
            if (S.resty) {
                S.styles =~ s/$_// for split ' ', S.resty;
                delete S.resty;
            }
        }
        my $res = w restyfor(S=>{});
        for my $S (w W/r(qw'K Im')) {
            next if rand(1) < 6/9;
            S.resty = $res;
            S.styles .= " $res";
        }
    rose: |
       my @rose = read_file("trampled_rose_lyrics");
       my @randoms = shuffle( grep { /\w/ } @rose );
       
        for (1..2) {
            my $S = 0->TafuB(Lingos => { l => shift @randoms});
            say "S.B.l";
            S.Z = {%{S.Z||{}},
                'font-size' => int(rand(5)+1).'00%',
                position => "fixed",
            };
        }
    tallpaddy: |
      for my $S (w W/r(qw'K Im')) {
          _.Z.padding > 7 || next;
          w se/pa[$S];
      }
    rotation: |
      for my $Im (w W/r(qw'K Im for 1')) {
          for my $ux ($Im->LioO('ux')) {
              my $uxid = ux.at.id;
              $H->JS("var p = \$('#$uxid').parent(); \$('#$uxid').detach().appendTo(p);");
          }
      }
    drumroll: |
      w f/at(di => 420);
      w f/at(di => 420);
      w f/ph;
      w f/ph;
      w f/lingpa;
    lingpa: |
      for my $S (w W/r(qw'K Lingos for 1..3')) {
            S.Z.padding = int(rand 24).'em';
      }
    at: |                                            # at x2
        say "@";
        my $di = ar.di || 2;
        for my $S (w W/r(qw'K Im for', "1..$di")) {
            next unless $S;
            w se/pad[$S];
            w se/opa[$S] if rand(1) < 5/9;
            S.Z.padding = int(rand 20).'em' if rand(1) < 2/9;
        }
        if (rand(1) < 2/9) {
            w f/ph;
            w f/rotation;
        }
        if (rand(1) < 1/9) {
            w f/tallpaddy;
            w f/ph;
        }
    te: | # at x1, x3
      say 'te';
      for my $S (w W/r(qw'K Lingos for 1..4')) {
          my $o = shuffle qw'☯ ☯ ☯ ☯ ᣜ ☭ Ϡ ᣝ ⍲ ⍲ ⍲ ⍲', " s҉", "ෙ";
          my $in = S.B;
          say "in.l => $o";
          in.l = $o;
      }
    ph: |                                            # at 0x0
        for my $S (w W/r(qw'K Im for 1..3')) {
            if (S.resty) {
                S.styles =~ s/$_// for split ' ', S.resty;
            }
            (S.resty) = grep { !S.resty || $_ ne S.resty } w restyfor[$S];
            S.styles .= " S.resty";
        }
  restyfor: |
    my @bang = ("sat6 opa2 con2 blr2 inv9", "ref sat9 bri4", 'ref sat9', 'ref blr8 con9 hue3',
        'inv9 sat9 blr2 hue8', 'inv4 bri7 blr5 con5', 'inv3 blr2 con1 hue6', 
        'blr2 bri3 con5 gra8 hue8 inv8 sat5'
        );
    my @colar = ("sat9 blr2 inv4 con8", "sat3 blr5 inv9 con9", 'ref sat6 bri3 inv2');
    push @bang, @colar;
    @bang = @colar if S.B.file =~ /art/;
    return shuffle(@bang);
  uxds: |
    0->sing("G.name uxd", sub { w uxd; });
  uxd: |
    my @Im = 0->scGre({V=>"xI"});
    G.GG.xI->w('ux', {Ls => [@Im]});
  W:
    r: |
      my @a=shuffle(0->rei({K=>$K}));
      if (ar.for && ar.for =~ /^(?:(\d+)\.\.(\d+)|(\d+))$/) {
          my $from = $1 || 0;
          my $to = $2 || $3-1;
          @a = grep {defined} @a[$from..$to];
      }
      @a
      
  index_clickspace: |
    my $Mid = G.T.W.uuid;
    my ($x, $y) = (e.x, e.y);
    my $what = ar.what || "ux.Im" || "ux";
    $H->JS(" var hit = [];
    \$('#$Mid > $what').filter(function() {
        return \$(this).offset().left < $x
            && \$(this).offset().left + \$(this).width() > $x
            && \$(this).offset().top < $y
            && \$(this).offset().top + \$(this).height() > $y
    }).each(function() {
        hit."."push(this."."id())
    });
    ws."."send({i=>hit});"); # TODO makes the server hang or something?
  event: |
    Say "Event relating to ".pint(L.i);
    0->visTp({L=>$L},'Fun');
    #sw ($ar);
    # try and hit E/elabourateness and then blunten until whatever
    if (e.S) {
        w $u zoum;
    }
    else {
        w $u E/_D;
    }
    waylay uxd;
    
recoded_Cways: 1

