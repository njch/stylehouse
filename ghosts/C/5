hooks:

R_surz:
    - K: phi #c
      D: |
          my $n = ar.n || 9;
          my $width = 100;
          my $height = 100;
          my $cx = $width / 2;
          my $cy = $height / 2;
          my $lg_diam = $width * 0.85;
          my $lg_rad = $lg_diam / 2; 
          my $outer_rad = $width*0.45;
          my $angle_incr = ar.ai || 9 / $n;
          
          my $xy = [];
          for my $i (1..$n) {
              my $ratio = $i/$n;
              my $spiral_rad = $ratio * $outer_rad;
              my $angle = 1+$i*$angle_incr;
              my $x = $cx + cos($angle) * $spiral_rad;
              my $y = $cy + sin($angle) * $spiral_rad;
              push @$xy, {
                  angle => sprintf('%.3f', $angle),
                  x => sprintf('%.3f', $x),
                  y => sprintf('%.3f', $y),
              };
          }
          $xy
    - K: phits #c
      key:
        P: P
      n_D:
        P: |
          my @Dos = w G.R fi(f=>{K=>'Do'});
          gut: {
          if (!@Dos) {
             w $R Q/K;
             last gut;
          }
            
          
          my $n = @Dos;
          G.which ||= 2;
          my $ai = G.which / $n;
          G.which += 0.3;
          
          my $xy = w $R phi[$n, $ai];
          
          saybl "G.which ".F_delta;
          
          for my $u (@Dos) {
              my $co = shift @$xy;
              
              co.x += 90;
              co.y += 50;
              
              u.S.Z.position = 'absolute';
              u.S.Z.top = co.x.'%';
              u.S.Z.left = co.y.'%';
              u.S.Z->{'font-size'} = '60%';
              u.B.name =~ s/(,.+)?$/,co.angle/;
              
              my $v = 5; # U level to rezfoom from # <<< TODO
              w mux[$u, $v];
          }
          
          ar.not = !ar.not;
          } # gut;
          sayre "out of huts";
          $G->timer(0.4, sub {
              0->sing(phi=>sub{ w $R phits/P(%$ar); }, begin => 12);
          });
        J: |
          die "here";
    - K: B #c
      key:
        O: O
      n_D:
        O: |
          w unmux(u=>$S); # TODO could 8 a message about this?
          sayyl "CSSS ".$S->pi;
          $H->pub('S/hut/O', 'retile');
    - K: Q #c
      key:
        SR: Redisy
        D: D
        SD: SD
        Q: Q
        C: C
        K: K
        N: N
        T: T
        U: U
        V: V
      n_D:
        V: |
          my $ou = H.G K G:sul;
          $ou w add;
        N: |
          S.monod.double = 1;!S.mood.double;
        K: |
          my $P = 0->anyway('P_sud');
          my $GG = $G;
          H.G w percs[$P, $GG];
        C: |
          H.G w reexec;
        T: |
          my $ia = R.a.i.A || die "no idea about A?";
          my $ab = [$ia];
          push @$ab, $ia while $ia = ia.u;
          ar.i = $ab;
          w $R Sud/in;
        Q: |
          my $g = G:C/ool;
          ar.i = $g;
          w $R Sud/in; 
        Redisy: |
          S.J = {
              from => { map { $_ => H.r->get($_) } reverse sort H.r->keys("*") },
          };
        D: |
            my $u = w makeD;
            return;
        SD: |
            my $way = "C C/J";
            my $K = "C".H.nn++;
            my $P = [{GAK => "$K $way"}];
            my $g = H.G w percs[$P];
            #my $g = G:$K;
            $g w ave(i=>$R);
            return;
            # make C elsewhere...
            sayre "Yeahp";
            my $with = "C/J";
            $H->pub("S/hut/C", "percC $with");
     
    - K: Got #c
      key:
        G: G
        P: P
      n_D:
        G: |
          return if fork(); # TODO forking pyramid isolator with error report
          `ssh v 'export DISPLAY=":0"; ssh s "cd styleshed; git gui"'`;
          exit;
        P: |
          w $R phi/P;
      
    - K: goto #c
      key:
        M: RwS
        SM: SM
        SN: SN
        F: F
        H: H
        W: W
        S: S
      n_D:
        H: |
          my @go = H.G K Gs:*; 
          ar.i = \@go;
          w $R Sud/in;
        RwS: |
          S.J = {from=>$R,trav=>'{way{hooks{S'};
        SM: |
          S.J = {from=>$R,trav=>'{way{hooks{goto'};
        SN: |
          S.J = {from=>S.a.i,trav=>'{ways[0{hooks'};
        W: |
          my $n = int rand 30000;
          S.J = { from => [$n,unico($n,1)]};
        F: |
              saygr "Trying!!!!" for 1..5;
              my @lot = w trythis;
              my $f = $F[0];
              ar.i = $f;
              w $R Sud/in;
              sayyl "Trithings: $_ " for @lot;
    - K: bg #c
      key:
        ' ': space
      n_D:
        space: |
          $H->pub('S/hut/S', 'reexec');
      
    
    - K: occie #c style komerp # occasional (page) global aggregate
      key: 
        Y: komp
      babz:
        'maka 6.56': |
                    G.shtuuyle->{at.style}++;
                    if (my $class = G.shtdc->{at.style}) {
                        delete at.style;
                        $tag = $class;
                    }
      n_D:
        komp: |
            my $dc = G.shtuuyle;
            my $sd;
            my @all;
            while (my ($sty,$uses) = each %$dc) {
                push @all, {sty=>$sty,uses=>$uses};
            }
            @all = sort { _.uses <=> _.uses } @all;
            my $limit = 50;
            for my $a (@all) {
                last if $limit-- <= 1;
                my $sty = join '', map{"$_;"} grep{defined} split ';', a.sty;
                next unless $sty;
                my ($heex) = $H->dig($sty) =~ /^(...)/;
                # TODO pack hex into unibabl
                $sd->{"a".$heex} = $sty;
            }
            G.shtdc = {reverse %$sd};

            # ^ to maka
            # v to elvis

            my $as = {K=>'style', B=>{am=>'styleyo'}};
            my $st = w G.R fuu(u=>$as);
            st.sheet = join "\n", map { "$_ { $sd->{$_} }" } sort keys %$sd;
            # TODO style order massively important
            # for regrouping s;t;y;l;e into sma;ll;er st;yles
            # need well oiled J to do it right
            # also may compress sheet updates with text append...
            # and many sheets at levels of holiness
            w mux(u=>$st);

      

