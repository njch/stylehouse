hooks:

R_surz:
    - K: phi #c
      D: |
          my $n = ar.n || 9;
          my $width = 100;
          my $height = 100;
          my $cx = $width / 2;
          my $cy = $height / 2;
          my $lg_diam = $width * 0.85;
          my $lg_rad = $lg_diam / 2; 
          my $outer_rad = $width*0.45;
          my $angle_incr = ar.ai || 9 / $n;
          
          my $xy = [];
          for my $i (1..$n) {
              my $ratio = $i/$n;
              my $spiral_rad = $ratio * $outer_rad;
              my $angle = 1+$i*$angle_incr;
              my $x = $cx + cos($angle) * $spiral_rad;
              my $y = $cy + sin($angle) * $spiral_rad;
              push @$xy, {
                  angle => sprintf('%.3f', $angle),
                  x => sprintf('%.3f', $x),
                  y => sprintf('%.3f', $y),
              };
          }
          $xy
    - K: phits #c
      key:
        P: P
      n_D:
        P: |
          my @Dos = w G.R fi(f=>{K=>'Do'});
          gut: {
          if (!@Dos) {
             w $R Q/K;
             sayyl "lasting gut...";
             last gut;
          }
          saybl "UINTO the guts";
            
          
          my $n = @Dos;
          G.which ||= 2;
          my $ai = G.which / $n;
          G.which += 0.3;
          
          my $xy = w $R phi[$n, $ai];
          
          saybl "G.which ".F_delta;
          
          for my $u (@Dos) {
              my $co = shift @$xy;
              
              co.x += 90;
              co.y += 50;
              
              u.S.Z.position = 'absolute';
              u.S.Z.top = co.x.'%';
              u.S.Z.left = co.y.'%';
              u.S.Z->{'font-size'} = '60%';
              u.B.name =~ s/(,.+)?$/,co.angle/;
              
              my $v = 5; # U level to rezoom from
              w chang[$u, $v];
          }
          
          ar.not = !ar.not;
          } # gut;
          sayre "out of huts";
          $G->timer(0.4, sub {
              0->sing(phi=>sub{ w $R phits/P(%$ar); }, begin => 12);
          });
        J: |
          die "here";
    - K: Q #c
      key:
        SR: Redisy
        D: D
        SD: SD
        Q: Q
        C: C
        K: K
        N: N
        T: T
        U: U
      n_D:
        U: |
          return w uxd(full=>1);
          ar.i = H.G.A.n_G;
          ar.i = [G:Cm1];
          w $R Sud/in;
        N: |
          S.monod.double = 1;!S.mood.double;
        K: |
          my $P = 0->anyway('P_sud');
          my $GG = $G;
          H.G w percs[$P, $GG];
        C: |
          H.G w reexec;
        T: |
          my $ia = R.a.i.A || die "no idea about A?";
          my $ab = [$ia];
          push @$ab, $ia while $ia = ia.u;
          ar.i = $ab;
          w $R Sud/in;
        Q: |
          my $g = G:C/ool;
          ar.i = $g;
          w $R Sud/in;
        Redisy: |
              S.J = {
                from => [reverse sort H.r->keys("*")],
              };
        D: |
            my $u = w makeD;
            return;
        SD: |
            my $way = "C C/nv";
            my $K = "C".H.nn++;
            my $P = [{GAK => "$K $way"}];
            my $g = H.G w percs[$P];
            #my $g = G:$K;
            $g w ave(i=>$R);
            return;
            # make C elsewhere...
            sayre "Yeahp";
            my $with = "C/nv";
            $H->pub("S/hut/C", "percC $with");
     
    - K: goto #c
      key:
        J: J
        M: RwS
        SM: SM
        SN: SN
        F: F
        H: H
        W: W
        G: G
        S: S
        ' ': space
      n_D:
        P: |
          w $R phi/P;
        space: |
          $H->pub('S/hut/S', 'reexec');
        G: |
          `ssh v 'export DISPLAY=":0"; ssh s "cd styleshed; git gui"'`;
        S: |
          my ($GG) = grep { $_ ne $G && _.name =~ /^C(?!\/)/} @{H.G.GGs};
          die "No other G named 'C'" unless $GG;
          my $otheR = $GG w are;
          ar.i = $otheR;
          w $R Sud/in;

        H: | 
          ar.i = H.G.GGs;
          w $R Sud/in;
        RwS: |
          S.J = {from=>$R,trav=>'{way{hooks{S'};
        SM: |
          S.J = {from=>$R,trav=>'{way{hooks{goto'};
        SN: |
          S.J = {from=>S.a.i,trav=>'{ways[0{hooks'};
        J: |
          my $J = a.i = R.A->spawn('J');
          J.W = G.GG.U.W;
          J.hol = "H.style/H.name/H.id";
          J.tiNZ = J.W.at.styles =~ /\bNZ\b/;
          J.hitime = $H->hitime;
          # throw J into Pg
              #G0.Wh->{$ww} = $W;
          ar.i = $J;
          w $R Sud/in;
        W: |
          my $n = int rand 30000;
          S.J = { from => [$n,unico($n,1)]};
        F: |
              saygr "Trying!!!!" for 1..5;
              my @lot = w trythis;
              my $f = $F[0];
              ar.i = $f;
              w $R Sud/in;
              sayyl "Trithings: $_ " for @lot;
    - K: Vit #c
      key: {E: up, R: down}
      n_D:
            up: |
                S.S.e += 0.1;
            down: |
                S.S.e -= 0.1;

