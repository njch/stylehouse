    G.Es = []; # elvi beam
    G.am = $G->findway("node/H.name")
    my $P = ar.P || G.am;
    my $GG = ar.GG || $G;
    @$P = sort { defined a.GAK <=> defined b.GAK } @$P;
            $GG->D({bab => p.D});
            $lg = w pur_GAK[$p, $GG];
            my ($k, @w) = split ' ', p.GAK;
            @w = $k if !@w;
            my $g = $GG->K(G=>$k);
                $g = GG.A->spawn(G=>@w);
                g.K = $k;
            my $oGG = $GG;
            $GG = $oGG K G:$k;
            my $P = [];
            my @onG = flatline $GG->anyway('P');
            if (my $d = p.InC) {
                $GG->InjC($GG => {C => $d});
        if (keys %$p == 1 && (keys %$p)[0] =~ /^(\w+) (.+)$/) {
            my $c = $GG->CsK({K=>$1});
            my @parc = ($2, values %$p);
            $p = {};
            p.K = $1;
            p.B->{$_} = shift @parc for split ' ', c.BcS;
            w GG.R fuu(u => $p);
            die " wtf=>".ki($p)
      ar.r ||= {};
      ar.r.q = ar.q if ar.q;
      my $r = ar.r;
      my $uu = $G->sway({K=>u.K}, $u);
      uu.S = dclone(uu.S) if uu.S;
      $u = $uu;
      inter({uu => $u->pi});
      $u = w $R Tafu[$u, $r];
      sayyl $uu->pi ."     => ". $u->pi unless r.q;
      my $uu = Rw fu $u;
          ar.r.new = 1;
          $uu = Rw T $u;
      $u = $uu;
      ar.f ||= {};
        my $fo = R.ca.K->{"u.K/u.name"}->{B_ki}->{ki(u.B||{})};
            $fo = undef;
        my @all = Rw fi;
            my $yup = $i eq $u
                && 0->B_same($u => $i);
      my $S = $u;
      R.ca.K->{"u.K/u.name"}->{B_ki}->{ki(u.B||{})} = $u;
        u.dead = 1;
            my $uk = $Ak;
            $uk =~ s/^u/n/;
            my $it = u.A->{$Ak};
            $it = [$it] unless ref $it eq 'ARRAY';
                w $R del(u => $n);
