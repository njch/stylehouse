

C:
  - K: Sources
    Gw: 1
    ux:
      spawn: []
      
  - K: Nonpm
    styles: brick8
    Gw: 1
    
  - K: Stat
    Gw: 1
    
  - K: Do
    BcS: name D
    styles: brick8
    ux:
      spawn: []
    print: |
       $name
    S:
      Z: {background: 'rgba(0,80,80,0.4)', font-size: '309%'}
      content_D: |
        $name
    E:
      _D: |
        Sw B/D;
P:
 - GAK: U
   InC:
           W:
             Ss: [u, x, X]
             S:
               styles: OxO z NZ
             Z:
               font-size: 50%
               background: rgba(100,66,33,0.2)
           ux:
             spawn:
               - K: i
               
 - Do code: waylay code;
 - Do uxd: w uxd;
 - Do Ü¤: $H->pub('S/hut/o', 'reextet');
 - Do tidy: $H->pub('S/hut/o', 'Hiwtidy');
 - Do Otile:  $H->pub('S/shed/O', 'retile');
 - Do Zr: $H->pub('S/hut/Z', 'reexec');
 - Do Or: $H->pub('S/shed/O', 'reexec');
 - Do Cr: $H->pub('S/hut/C', 'reexec');
 - Do Sr: $H->pub('S/hut/S', 'reexec');
hooks:
  fresh_init: |
    push @{G0.recoded_cbs}, sub {
        my $Gd = shift;
        w coins[$Gd]; 
    };
  any_init: |
      waylay code;   
      sayyl " - c - o - d - e - " for 1..3;
  percolate: |
    w uxd;
  uxd: |
    my @o = grep { "Nonpm" ne _.i.K } 0->scGre({});
    return saygr "Zero uxd" if !@o;
    G.GG.U->w('ux', {Ls=>\@o});
  event: |
    sayyl "Event relating to ".$u->pi;
    0->visTp({L=>$L},'Fun');
    for (1) {
        G.envsub && do { say "envsub"; delete(G.envsub)->($u); next };
        e.S && do { w $u zoum; next };
        w $u E/_D;
        #waylay uxd;
    }
    sw (ar.u) if e.S;
  Nonpm:
    flows_D: |
      S.A->spawn('T');
    is_changed: | # TODO T and if {B{sum changes
      B.sum_old = B.sum;
      B.sum = `md5sum $file`;
      S.changed || B.sum_old ne B.sum;
    reload: |
        S.way =  $S->s;
        S.way->load($file);
        #Sw codif/diff;
        #S.T->commit('reload');
    codif:
      diff: |
        my $Dh = S.Dh = {};
        for my $Ds (@{S.way->find("Ds")}) {
            $Dh->{Ds.K} = $H->dig(Ds.D);
        }
        S.Dd = {};
        if (@{S.T.L} > 1) {
        my $lim = '{Dh';
            my $d = S.T->diff('{Dh');
            
            for my $h (values %$d) {
                for my $k (keys %$h) {
                    my $hk = $k;
                    $k =~ s/^\Q$lim\E(\S)/$1/;
                    die "$k not from $hk" unless $k;
                    $h->{$k} = delete $h->{$hk};
                }
            }

            my $new = d.new;
            for my $k (keys %$new) {
                my $v = $new->{$k};
                $k =~ /^\{(\S+)/;
                S.Dd->{$1} = 1;
            }
        }
        sayyl "Redoming: ".wdump(S.Dd) if %{S.Dd};
    codif: |
        S.Dc = [];
        while (my ($k, $v) = each %{S.Dd}) {
            my $km = $k.'_'.$H->dig($v);
            $v =~ s/^sub $k \{/sub $km \{/ || next;
            
            my $code = '*'.S.nb.'::'.$k.' = sub { '.$km.'(@_) };'
            ."\n$v\n";
            push @{S.Dc}, $code;
        }
        return S.codif = '' if !@{S.Dc};
        S.codif = join "\n", "package S.nb;\n", @{S.Dc};

    print: |
      "for $file";
  Sources:
    S:
      Z:
        font-size: 125%
      ishtml: 1
      sendo_init_D: |
        # wants to flash on update... 
        # " \$('#u.at.id').delay(300).fadeOut().fadeIn();";
      content_D: |
        '<pre>'
        .join("\n",
        '<span style="color:black">'.B.coded.'</span>',
        (B.ghod ? '<span style="color:black">'.B.ghod.'</span>' : ""),
        '<span style="color:black">'.B.end.'</span>',
        '<span style="color:#0aa">'.join("\n",@{B.dup||[]}).'</span>',
        '<span style="color:#500;background:rgba(244,230,200);">'.B.compile.'</span>',
        '<span style="color:#0a3">'.(length(B.diff) > 900 ? "HUGE DIFF": B.diff).'</span>')
        .'</pre>';
  codedis: | 
    my $s = 0->TafuB(Sources => {});
    my $f = {};
    my @cl = split "\n", say.compile;
    my @nl;
    for my $l (@cl)  {
        #
        my ($li) = $l =~ m/^E  (.+)/;
        my ($ug, $file, $line, $near) = 
            $li =~ /^(\S.+) at ((?:\w+\/)*[\w\.]+) line (\d+)(.*)$/;
        my ($space) =
            $li =~ /^(\s+.+)$/;
        undef $near if $near eq ".";
        
        $file = "il/$file"; # TODO suitcase
        
        if ($file && $line) {
            my $perl = $f->{$file} ||= [ split "\n", $H->slurp($file) ];
            my $lii = $line - 1;
            my $lie = $perl->[$lii];
            
            # seek backwards for sub $K {
            my $sub;
            my $wai = $lii;
            my $spot; # in the chunk from sub
            while (!$sub && $wai > 0) {
                if ($perl->[$wai] =~ /^sub (\w+) \{/) {
                    $sub = $1;
                    $spot = $lii - $wai;  
                }
                $wai--;
            }
            $sub ||= $perl->[$wai];
            
            # width for syntaxey
            my @code;
            my ($fore, $aft) = (1, 2); # 4 lines
            ($fore, $aft) = (0, 0) if $perl->[$lii] =~ /use \S+;/;
            my $i = $lii - $fore;
            $i = 0 if $i < 0;
            while ($i <= $lii + $aft) {
                last if !exists $perl->[$i];
                push @code, $perl->[$i];
                $i++;
            }
            
            $R::f->{fs40} = "font-size:40%;";
            $R::f->{liblue} = "color:#88f;";
            
            if ($lie =~ /^\s*\}\s*$/) {
                @code = "$lie".G.R->f(liblue_fs80 => " ! end of block");
            }
            
            push @nl, G.R->f(fs120_liblue => "D: $sub  line $spot");
            for (@code) {
                my $sty = $_ eq $lie ? "red" : "white";
                push @nl, G.R->f($sty => "C $_");
            }
            push @nl, "\t$ug   ".G.R->f(fs60 => "$file:$line");
            push @nl, $near if $near;
        }
        else {
            push @nl, $l;
        }
    }
    say.compile = join "\n", @nl;
    
    s.B = $say;
  try: |
    saygr 'Restarting S' for 1..3;
    my $pm = ".pm";
    `touch l/S$pm`; 
  coins: |
    # etc
    for my $gf (keys %$Gd) {
        if ($gf =~ /ghosts\/(R|G)/) {
            my $fu = {K=>'Nonpm',B=>{file =>"ghosts/0/$1"}};
            for my $c (0->fu($fu)) {
                $c || next;
                sayyl "domey reticulation unto $gf  ($1)  ".$c->pi;
                c.changed = 1;
            }
        }
    }
    w code[$Gd];
  codifs: |
    my @cdifs = grep { _.codif } @$chpms;
    if (@cdifs) {
        my @codifs = map { _.codif } @cdifs;
        my $upnb = join "_", map {_.nb} @cdifs;
        my $update = join "\n", @codifs, "1";
        my $hash = $H->dig($update);
        my $name = join "__", $upnb, $hash;

        $H->spurt("zl/$name", H::encode_utf8($update));
        $H->pub("S", "zl $name");
        # TODO more id? change may be R/G0 way braiding, fed domey
        my @zeal = glob "zl/*";
        H.G->timer(222, sub { `rm @zeal` });
    }
  code: |
    waylay uxd;
    my $say = {};
    my @nonpms = map { 0->TafuB(Nonpm => {file => $_}) }
        grep{!/\d$/} glob "ghosts/0/*";
    my @chpms = grep { ar.full || w $_ is_changed; } @nonpms;
    
    
    sayyl "Coding: ".join"   ,   ", map { _.B.file } @chpms;
    if (!@chpms) {
        say.coded = sayre "Nothing change 0/0";
        waylay codedis[$say];
        return;
    }
    
    say.coded = sayyl "coding?? ".(0+@chpms)." of ".(0+@nonpms);
    say.ghod = sayre "   g0ings: ".join ", ", sort keys %{ar.Gd} if ar.Gd;
    
    
    for my $c (@chpms) { 
        delete c.way;
        w $c reload;
        my $way = c.way;
        way.name ||= (way._wayfile =~ /ghosts\/(.+)/)[0] || way._wayfile;
        
        w coden[$c, $way];
        sayyl "compile way.name    ".$G->F_delta(); 
        
        #w $c codif;
        
        0->accum($say, dup => saygr "c.B.file ");
    }
    
    #w codifs(chpms => \@chpms);
    
    
    my $bug;
    for my $file (qw"H* S*") {
        my $check = "cd il/; perl -I ../lib -c l/$file";

        ($bug, my @out) = capture_err $check;
        my $talk = join "", @out;
        my $st = ($bug ? "FAILELDIDL!!!" : "compiled")
            ." $file == $bug\n".ind("E  ", $talk); 
        
        my $sh = slim(600,600,$st);
        $bug ? sayre $sh : sayyl $sh;
        say.compile .= $st;
    }
    
    sayyl "compile".$G->F_delta();
    
    run "cp il/l/* sal/";
    my $dif = capture("cd sal; git diff");
    say.diff = $dif;
    my $dhf = slim(600,600,$dif);
    saybl $dhf;
    my $ch;
    if ($bug) {
        $ch = "buggered";
    }
    else {
        $ch = "updated safe" if $dif;
        if ($ch && 1) {
            run("cd sal; git add *; git commit -m 'somewhere...'");
            run("cd l; git pull");
        } 
        $ch ||= "no changes";
        
    }
    
    say.end = sayg "compiled, $ch ".$G->F_delta();
    
    waylay codedis[$say];
    
    return if $ch eq "no changes";
    
    waylay try;
  coden: |
        use lib 'sal';
        use G;
        my $eg = bless {}, "G"; # safe lib updates on compiles
        # TODO so 0 doesn't have to restart on babble changes?
        # make a script that just loads G and pipes babble in out?
        # do it twice if babble changes so final code has new parsed babble
        my @name = split '/', way.name;
        shift @name if $name[0] eq '0';
        my $nb = join "::", @name;
        c.nb = $nb;

        my $co = $way->find("Ds");
        $co ||do{ warn "No Domes si ".$way->pi; next };
    
        my @code = (
            join "\n",
            "package $nb;", 
            "our \$H;",
            map { "use $_;" }
                "strict", "warnings", "utf8", "lib 'lib'", "feature 'say'"
        );
        my $btw = {};
        for my $ch (@$co) {
            say "skipping a blank K in $nb" && next if !ch.K;
            
            my $D = ch.D || ch.SD;
            $D = $eg->parse_babble($D) unless ch.style =~ /nonbabble/;
            
            if (ch.K eq "head" || ch.K eq "everything") {
                if (ch.K eq "everything") {
                    @code = ();
                }
                ch.style .= "bare";
                if (my $lg = ch.libglob) {
                    my ($ldir) = $lg =~ /^(.+)\/.+?$/;
                    my @l = map { /\/(.+?)\.pm$/ } glob $lg;
                    push @code, "use lib '$ldir';";
                    push @code, "use $_;" for grep {$_ ne $nb && $_ !~ /s/i} @l;
                    btw.s.___LIBGLOBETC = join "\n",
                    map { "\$${_}::H = \$H;" } grep {$_ !~ /s/i} @l;
                }
            }
            
            if (ch.style !~ /bare/) {
                $D =~ s/$_/btw.s->{$_}/seg for keys %{btw.s};
                
                # setup self
                $D = "my \$$nb = shift;\n$D" if ch.style !~ /func/;
                
                # return self
                $D = "$D\n\$$nb"             if ch.K eq "new" || ch.SD;
                
                $D = ind('    ', $D);
                $D =~  s/^    $//sgm;
                $D = "sub ch.K {\n$D\n}\n";
            }
            if (c.Dd->{ch.K}) {
                c.Dd->{ch.K} = $D;
            }
            push @code, $D;
        }
        push @code, ($co->[0]->{K} ne "everything" ? "9" : ''); ##
        my $file = "il/l/${nb}.pm"; # TODO ::->/
        $H->spurt($file, H::encode_utf8(join("\n", @code)));
        
            
    

