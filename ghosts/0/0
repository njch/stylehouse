

C:
  - K: Sources
    Gw: 1
      
  - K: Nonpm
    Gw: 1
    
  - K: Stat
    Gw: 1
    
  - K: Do
    BcS: name D
    S:
      styles: -te
      Z: {background: '#044', font-size: '309%'}
      content_D: |
        $name
    event_D: |
      Sw B/D;
P:
 - Do '#': waylay code(full=>e.S);
 - Do uxd: w uxd;
 - Do Ü¤: $H->pub('S/hut/o', 'reextet');
 - Do tid: $H->pub('S/hut/o', 'Hiwtidy');
 - Do til:  $H->pub('S/hut/O', 'retile');
 - Do Zr: $H->pub('S/hut/Z', 'reexec');
 - Do Or: $H->pub('S/hut/O', 'reexec');
 - Do Cr: $H->pub('S/hut/C', 'reexec');
 - Do C2r: $H->pub('S/hut/C2', 'reexec');
 - Do Sr: $H->pub('S/hut/S', 'reexec');
hooks:
  fresh_init: |
    push @{G0.recoded_cbs}, sub {
        my $Gd = shift;
        w coins[$Gd]; 
    };
    w timerestart;
  any_init: |
    # get origiun, freshly planted C and :
    my ($M) = 0->CsK({K=>'W'});
    M.S.styles = 'OxO';
    M.S.Z = Load(<<'');
                   font-size: 50%
                   width: 1em
                   right: 3em
                   bottom: 0em
                   position: fixed
                   min-height: 3em
                   z-index: 50
                   background: rgba(100,66,33,0.2)
    
    sayyl "Emm  ".$M->pi;
  humms_D: |
    if (u.A.u_Rnon_C->[0] eq $G) {
        waylay mux(u=>$u);
    } # else G hum avoid cos it must be deep in RNA somewhere
  timerestart: |
    my $now = $H->hitime;
    my $sinze = $now - G.lastupdate if G.lastupdate;
    if ($sinze > 9*60) {
        H.G w reexec;
    }
    
    sayre "restart later - changed ".int($sinze)."s ago";
    $G->sing(timerestart => sub {
        w timerestart;
    }, begin => 6*30);
  recoded_init: | 
    waylay code(full=>1);
    waylay uxd;
    sayyl " - c - o - d - e - " for 1..3; 
  percolate: |
    waylay code(full=>1);
  uxd: |
    my @u;
    push @u, K Do;
    push @u, K Sources;
    for my $u (@u) {
        w mux[$u];
    }
    sayre "uxd from ".$F[2]->pi;
  Nonpm:
    is_changed: | # TODO T and if {B{sum changes
      B.sum_old = B.sum;
      B.sum = `md5sum $file`;
      S.changed || B.sum_old ne B.sum;
    reload: |
        S.way =  $S->s;
        S.way->load($file);
        #Sw codif/diff;
        #S.T->commit('reload');
    codif:
      diff: |
        my $Dh = S.Dh = {};
        for my $Ds (@{S.way->find("Ds")}) {
            $Dh->{Ds.K} = $H->dig(Ds.D);
        }
        S.Dd = {};
        if (@{S.T.L} > 1) {
        my $lim = '{Dh';
            my $d = S.T->diff('{Dh');
            
            for my $h (values %$d) {
                for my $k (keys %$h) {
                    my $hk = $k;
                    $k =~ s/^\Q$lim\E(\S)/$1/;
                    die "$k not from $hk" unless $k;
                    $h->{$k} = delete $h->{$hk};
                }
            }

            my $new = d.new;
            for my $k (keys %$new) {
                my $v = $new->{$k};
                $k =~ /^\{(\S+)/;
                S.Dd->{$1} = 1;
            }
        }
        sayyl "Redoming: ".wdump(S.Dd) if %{S.Dd};
    codif: |
        S.Dc = [];
        while (my ($k, $v) = each %{S.Dd}) {
            my $km = $k.'_'.$H->dig($v);
            $v =~ s/^sub $k \{/sub $km \{/ || next;
            
            my $code = '*'.S.nb.'::'.$k.' = sub { '.$km.'(@_) };'
            ."\n$v\n";
            push @{S.Dc}, $code;
        }
        return S.codif = '' if !@{S.Dc};
        S.codif = join "\n", "package S.nb;\n", @{S.Dc};

    print: |
      "for $file";
  Sources:
    S:
      Z:
        font-size: 125%
        position: fixed
        bottom: 0em
        right: 0em
        width: 20em
        height: 20em
      ishtml: 1
        # TODO R/C and " \$('#u.at.id').delay(300).fadeOut().fadeIn();";
      content_D: |
        '<pre>'
        .join("\n",
        '<span style="color:black">'.B.coded.'</span>',
        (B.ghod ? '<span style="color:black">'.B.ghod.'</span>' : ""),
        '<span style="color:black">'.B.end.'</span>',
        '<span style="color:#0aa">'.join("\n",@{B.dup||[]}).'</span>',
        '<span style="color:#500;background:rgba(244,230,200);">'.B.compile.'</span>',
        '<span style="color:#0a3">'.(length(B.diff) > 900 ? "HUGE DIFF": B.diff).'</span>')
        .'</pre>';
  codedis: | 
    my $Sou = {K => 'Sources'};
    my $s = w G.R fuu(u=>$Sou);
    my $f = {};
    my @cl = split "\n", say.compile;
    my @nl;
    for my $l (@cl)  {
        #
        my ($li) = $l =~ m/^E  (.+)/;
        my ($ug, $file, $line, $near) = 
            $li =~ /^(\S.+) at ((?:\w+\/)*[\w\.]+) line (\d+)(.*)$/;
        my ($space) =
            $li =~ /^(\s+.+)$/;
        undef $near if $near eq ".";
        
        $file = "il/$file"; # TODO suitcase
        
        if ($file && $line) {
            my $perl = $f->{$file} ||= [ split "\n", $H->slurp($file) ];
            my $lii = $line - 1;
            my $lie = $perl->[$lii];
            
            # seek backwards for sub $K {
            my $sub;
            my $wai = $lii;
            my $spot; # in the chunk from sub
            while (!$sub && $wai > 0) {
                if ($perl->[$wai] =~ /^sub (\w+) \{/) {
                    $sub = $1;
                    $spot = $lii - $wai;  
                }
                $wai--;
            }
            $sub ||= $perl->[$wai];
            
            # width for syntaxey
            my @code;
            my ($fore, $aft) = (1, 2); # 4 lines
            ($fore, $aft) = (0, 0) if $perl->[$lii] =~ /use \S+;/;
            my $i = $lii - $fore;
            $i = 0 if $i < 0;
            while ($i <= $lii + $aft) {
                last if !exists $perl->[$i];
                push @code, $perl->[$i];
                $i++;
            }
            
            $R::f->{fs40} = "font-size:40%;";
            $R::f->{liblue} = "color:#88f;";
            
            if ($lie =~ /^\s*\}\s*$/) {
                @code = "$lie".G.R->f(liblue_fs80 => " ! end of block");
            }
            
            push @nl, G.R->f(fs120_liblue => "D: $sub  line $spot");
            for (@code) {
                my $sty = $_ eq $lie ? "red" : "white";
                push @nl, G.R->f($sty => "C $_");
            }
            push @nl, "\t$ug   ".G.R->f(fs60 => "$file:$line");
            push @nl, $near if $near;
        }
        else {
            push @nl, $l;
        }
    }
    say.compile = join "\n", @nl;
    
    s.B = $say;
  try: |
    saygr 'Restarting S' for 1..3;
    my $pm = ".pm";
    `touch l/S$pm`; 
  coins: | # non 0/* (self) things to code
    # etc
    my $ya = 0;
    for my $gf (keys %$Gd) {
        if ($gf =~ /ghosts\/(R|G)/) {
            $ya = 1;
            my $f = {K=>'Nonpm',B=>{file =>"ghosts/0/$1"}};
            my @p = w G.R fi[$f];
            for my $c (@p) {
                $c || next;
                sayyl "domey reticulation unto $gf  ($1)  ".$c->pi;
                c.changed = 1;
            }
        }
    }
    w code[$Gd] if $ya;
  codifs: |
    my @cdifs = grep { _.codif } @$chpms;
    if (@cdifs) {
        my @codifs = map { _.codif } @cdifs;
        my $upnb = join "_", map {_.nb} @cdifs;
        my $update = join "\n", @codifs, "1";
        my $hash = $H->dig($update);
        my $name = join "__", $upnb, $hash;

        $H->spurt("zl/$name", H::encode_utf8($update));
        $H->pub("S", "zl $name");
        # TODO more id? change may be R/G0 way braiding, fed domey
        my @zeal = glob "zl/*";
        H.G->timer(222, sub { `rm @zeal` });
    }
  code: |
    #ar.full = 1;
    say "full: ar.full";
    waylay uxd;
    my $say = {};
    my @nonpms = map {
        my $u = {K => 'Nonpm', B => {file => $_}};
        w G.R fuu[$u];
        }
        grep {!/\d$/} glob "ghosts/0/*";
    my @chpms = grep { ar.full || w $_ is_changed; } @nonpms;
    
    
    sayyl "Coding: ".join"   ,   ", map { _.B.file } @chpms;
    if (!@chpms) {
        say.coded = sayre "Nothing change 0/0";
        waylay codedis[$say];
        return;
    }
    
    say.coded = sayyl "coding?? ".(0+@chpms)." of ".(0+@nonpms);
    say.ghod = sayre "   g0ings: ".join ", ", sort keys %{ar.Gd} if ar.Gd;
    
    
    for my $c (@chpms) { 
        delete c.way;
        w $c reload;
        my $way = c.way;
        way.name ||= (way._wayfile =~ /ghosts\/(.+)/)[0] || way._wayfile;
        
        w coden[$c, $way];
        sayyl "compile way.name    ".$G->F_delta(); 
        
        #w $c codif;
        
        0->accum($say, dup => saygr "c.B.file ");
    }
    
    #w codifs(chpms => \@chpms);
    
    
    my $bug;
    for my $file (qw"S*") {
        my $check = "cd il/; perl -I ../lib -c l/$file";

        ($bug, my @out) = capture_err $check;
        my $talk = join "", @out;
        my $st = ($bug ? "FAILELDIDL!!!" : "compiled")
            ." $file == $bug\n".ind("E  ", $talk); 
        
        my $sh = slim(600,600,$st);
        $bug ? sayre $sh : sayyl $sh;
        say.compile .= $st;
    }
    
    sayyl "compile".$G->F_delta();
    
    run "cp il/l/* sal/";
    my $dif = capture("cd sal; git diff");
    say.diff = $dif;
    my $dhf = slim(600,600,$dif);
    saybl $dhf;
    my $ch;
    if ($bug) {
        $ch = "buggered";
    }
    else {
        $ch = "updated safe" if $dif;
        G.lastupdate = $H->hitime;
        if ($ch && 1) {
            run("cd sal; git add *; git commit -m 'somewhere...'");
            run("cd l; git pull");
        } 
        $ch ||= "no changes";
        
    }
    
    say.end = sayg "compiled, $ch ".$G->F_delta();
    
    waylay codedis[$say];
    
    return if $ch eq "no changes";
    
    waylay try;
  coden: |
        use lib 'sal';
        use G;
        my $eg = bless {}, "G"; # safe lib updates on compiles
        # TODO so 0 doesn't have to restart on babble changes?
        # make a script that just loads G and pipes babble in out?
        # do it twice if babble changes so final code has new parsed babble
        my @name = split '/', way.name;
        shift @name if $name[0] eq '0';
        my $nb = join "::", @name;
        c.nb = $nb;

        my $co = $way->find("Ds");
        $co ||do{ warn "No Domes si ".$way->pi; next };
    
        my @code = (
            join "\n",
            "package $nb;", 
            "our \$H;",
            map { "use $_;" }
                "strict", "warnings", "utf8", "lib 'lib'", "feature 'say'"
        );
        my $btw = {};
        for my $ch (@$co) {
            say "skipping a blank Kin $nb" && next if !ch.K;
            
            my $D = ch.D || ch.SD;
            $D = $eg->parse_babble($D) unless ch.style =~ /nonbabble/;
            
            if (ch.K eq "head" || ch.K eq "everything") {
                if (ch.K eq "everything") {
                    @code = ();
                }
                ch.style .= "bare";
                if (my $lg = ch.libglob) {
                    my ($ldir) = $lg =~ /^(.+)\/.+?$/;
                    my @l = map { /\/(.+?)\.pm$/ } glob $lg;
                    push @code, "use lib '$ldir';";
                    push @code, "use $_;" for grep {$_ ne $nb && $_ !~ /s/i} @l;
                    btw.s.___LIBGLOBETC = join "\n",
                    map { "\$${_}::H = \$H;" } grep {$_ !~ /s/i} @l;
                }
            }
            
            if (ch.style !~ /bare/) {
                $D =~ s/$_/btw.s->{$_}/seg for keys %{btw.s};
                
                # setup self
                $D = "my \$$nb = shift;\n$D" if ch.style !~ /func/;
                
                # return self
                $D = "$D\n\$$nb"             if ch.K eq "new" || ch.SD;
                
                $D = ind('    ', $D);
                $D =~  s/^    $//sgm;
                $D = "sub ch.K {\n$D\n}\n";
            }
            if (c.Dd->{ch.K}) {
                c.Dd->{ch.K} = $D;
            }
            push @code, $D;
        }
        push @code, ($co->[0]->{K} ne "everything" ? "9;\n\n" : ''); ##
        my $file = "il/l/${nb}.pm"; # TODO ::->/
        $H->spurt($file, H::encode_utf8(join("\n", @code)));
        
            
    

