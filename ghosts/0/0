
name: other stuff...
C:
  - K: Sources
    Gw: 1
    ux:
      spawn: []
  - K: Nonpm
    styles: brick4
    Gw: 1
  - K: Stat
    Gw: 1
    
  - K: Do
    BcS: name D
    styles: brick4
    ux:
      spawn: []
    print: |
       $name
    S:
      Z: {background: '#044'}
      content_D: |
        "Ze: $name ()";
    E:
      _D: |
        $D->();
hooks:
  fresh_init: |
    push @{G0.recoded_cbs}, sub {
        my $S = shift;
        w coins[$S]; 
    };

    0->GAK(U => G!U);
    0->InjC(G.GG.U => Load(<<''));
         C:
           W:
             Ss: [u, x, X]
             S:
               styles: OxO z NZ
             Z:
               font-size: 42%
               background: rgba(100,66,33,0.6)
           ux:
             spawn:
               - K: i
  percolate: |
    # HI for 1..2
    $G->TafuB(Do => {D => sub{waylay code;}, name=>"code"});
    w uxd;
  uxd: |
    my @o = 0->scGre({});
    saygr "Zero uxd";
    return sayyl "No ux at all!" if !G.GG.U;
    return if !@o;
    G.GG.U->w('ux', {Ls=>\@o});
  event: |
    sayyl "Event relating to ".$u->pi;
    0->visTp({L=>$L},'Fun');
    for (1) {
        G.envsub && do { say "envsub"; delete(G.envsub)->($u); next };
        e.S && do { w $u zoum; next };
        w $u E/_D;
        #waylay uxd;
    }
    sw (ar.u) if e.S;
  Nonpm:
    is_changed: | # TODO T and if {B{sum changes
      my $old = B.sum;
      B.sum = `md5sum $file`;
      $old ne B.sum;
    reload: |
      c.way =  #
       #c my $way = $wfh->{c.B.file} || die "not loaded c.B.file";
    print: |
      "for $file";
  Sources:
    S:
      Z:
        font-size: 125%
      ishtml: 1
      sendo_init_D: |
        # wants to flash on update... 
        # " \$('#u.at.id').delay(300).fadeOut().fadeIn();";
      content_D: |
        '<pre>'
        .join("\n",
        '<span style="color:black">'.join("\n",B.coded, B.end).'</span>',
        '<span style="color:#0aa">'.join("\n",@{B.dup||[]}).'</span>',
        '<span style="color:#03a">'.join("\n",B.compile).'</span>',
        '<span style="color:#0a3">'.join("\n",B.diff).'</span>')
        .'</pre>';
  codedis: | 
    my $s = 0->TafuB(Sources => {});
    s.B = $say;
  try: |
    saygr 'Restarting S' for 1..3;
    my $pm = ".pm";
    `touch l/S$pm`; 
  coins: |
    # etc
    return saygr "igginit S.name" if S.name =~ /C\/|Ï /;
    saygr "Got reinitn on S.name";
    return if $S eq $G;
    #w try;
  any_init: |
      waylay code;   
      say "COCOCOO" for 1..8;
  code: |
    waylay uxd;
    my $say = {};
    
    my @nonpms = grep{!/\d$/} glob "ghosts/0/*";
    # TODO data load separately?
    # the coins hook should still let us know when sources
    # re-create
    @nonpms = map { 0->TafuB(Nonpm => {file => $_}) } @nonpms;
    # re-sonate
    my @chpms = grep { ar.full || w $_ is_changed; } @nonpms;
    w $_ reload for @chpms;
    # and link further, 
    # the 4 ^ createds the 5 v
    say.coded = sayyl "some code? ".(0+@nonpms)." some code ".(0+@chpms);
    my $wfh = {map{_._wayfile=>$_}@{G.ways}}; # must be loaded in here
    for my $c (@chpms) {
        my $way = c.way;
        my @name = split '/', way.name;
        shift @name if $name[0] eq '0';
        my $nb = join "::", @name;
        my $co = $way->find("0/$nb");
        0->accum($say, dup => saygr "Way : @name  $nb $co");
        w coden[$nb, $co];
    }
    
    my $bug;
    for my $file (qw"H* S*") {
        my $check = "cd il/; perl -I ../lib -c l/$file";

        ($bug, my @out) = capture_err $check;
        my $st = ($bug ? "FAILELDIDL!!!" : "compiled")
            ." $file == $bug\n".join("",map {"  $_"}@out);
        $bug ? sayre $st
        : sayyl $st;
        say.compile = $st;
    }
    
    
    
    run "cp il/l/* sal/";
    my $dif = capture("cd sal; git diff");
    say.diff = saybl $dif if $dif;
    my $ch;
    if ($bug) {
        $ch = "buggered";
    }
    else {
        $ch = "updated safe" if $dif;
        if ($ch && 1) {
            run("cd sal; git add *; git commit -m 'somewhere...'");
            run("cd l; git pull");
        } 
        $ch ||= "no changes";
    }
    
    say.end = sayg "compiled, $ch ".$G->F_delta();
    waylay codedis[$say];
    return if $ch eq "no changes";
    waylay try;
  coden: |
    use lib 'sal'; # safe lib updates on compiles
    # TODO so 0 doesn't have to restart on babble changes?
    # make a script that just loads G and pipes babble in out?
    # do it twice if babble changes so final code has new parsed babble
    use G;
    my $eg = bless {}, "G";
    
    for my $w ($G->anyway('0')) {
        my ($nb, $co) = %$w;
        
        #die sw['etc',$co, $nb] unless ref $co eq "ARRAY";
        
        next unless $co;
        my @code = (
            join "\n",
            "package $nb;", 
            "our \$H;",
            map { "use $_;" }
                "strict", "warnings", "utf8", "lib 'lib'", "feature 'say'"
        );
        my $btw = {};
        for my $ch (@$co) {
            say "skipping a blank K in $nb" && next if !ch.K;
            
            my $D = ch.D || ch.SD;
            $D = $eg->parse_babble($D) unless ch.style =~ /nonbabble/;
            
            if (ch.K eq "head" || ch.K eq "everything") {
                if (ch.K eq "everything") {
                    @code = ();
                }
                ch.style .= "bare";
                if (my $lg = ch.libglob) {
                    my @l = map { /\/(.+?)\.pm$/ } glob $lg;
                    my ($l) = $lg =~ /^(.+)\/.+?$/;
                    push @code, "use lib '$l';";
                    push @code, "use $_;" for grep {$_ ne 'S'} @l;
                    btw.s.___LIBGLOBETC = join "\n",
                        map { "\$${_}::H = \$H;" } @l;
                }
            }
            
            if (ch.style !~ /bare/) {
                $D =~ s/$_/btw.s->{$_}/seg for keys %{btw.s};
                
                # setup self
                $D = "my \$$nb = shift;\n$D" if ch.style !~ /func/;
                
                # return self
                $D = "$D\n\$$nb"             if ch.K eq "new" || ch.SD;
                
                $D = ind('    ', $D);
                $D =~  s/^    $//sgm;
                $D = "sub ch.K {\n$D\n}\n";
            }
            push @code, $D;
        }
        push @code, ($co->[0]->{K} ne "everything" ? "'stylehouse'" : ''); ##
        my $file = "il/l/${nb}.pm";
        $H->spurt($file, H::encode_utf8(join("\n", @code)));
    }
    

