
name: other stuff...
H:
  - K: head
    libglob: 'l/?.pm'
    D: |
        use UUID;
        sub wdump{Ghost::wdump(@_)}
    
  - K: new
    D: |
      $H = $H->spawn0('H');
      ___LIBGLOBETC
      
      $H->spawn0('A')->new($H); 
      
      H.G = H.A->spawn(G => 'H');
      
  - K: spawn
    D: |
      my $a = shift;
      my $u = $H->spawn0(@{a.r});
      
      say "H spawning $u";
      if (ref $u eq 'A') {
          return $u->new(a.i);
      }
      else {
          $H->spawn({i=>$u, r=>['A']});
          a.uA->An($u);
          u.A->Au(a.uA);
      }
      shift @{a.r};
      $u->new(@{a.r});
      
      
  - K: spawn0
    D: |
      my $nb = shift;
      my $u = bless {}, $nb;
      $nb::H = $H;
      u.id = mkuid();
      $u
      
  #Hmisc #c
  - K: mkuid # H wide unique id
    style: func
    D: |
        (mkuuid() =~ /^(\w+)-.+$/)[0];
        
  - K: mkuuid # make a number bigger than the universe
    style: func
    D: |
      UUID::generate(my $i);
      UUID::unparse($i, my $s);
      $s
A:
  - K: new # link the thing A in
    D: |
      my $i = shift;
      A.i = $i;
      i.A = $A;
      
  - K: spawn # make down
    D: |
      $H->spawn({uA => $A, r=>[@_]});
      
  - K: An # link down
    D: |
      my $n = shift;
      push @{A.n}, $n;
      
  - K: Au # link up
    D: |
      my $u = shift;
      die if A.u;
      A.u = $u;
      
  - K: path
    D: |
      my $up;$up = sub {
          my $u = shift;
          return $u, $up->(u.A.u) if u.A && u.A.u && $u ne u.A.u;
      };
      my @path = reverse $up->(A.u);
      return join "/", map { ref $_ } @path;
      
      
    
C:
  - K: head
    D: |
      use base 'Way';
  - K: new
    D: |
      C.G = C.A.u.i;
G:
  - K: head
    D: |
      use base 'Ghost';
      sub wdump { Ghost::wdump(@_) };
      sub sw { Ghost::sw(@_) };
      use YAML::Syck;
      
  - K: new
    D: |
      my (@ways) = @_;
      G.name = join "+", @ways;
      
      G.W ||= G.A->spawn('W');
      
      $G->load_ways(@ways);

  - K: nw
    D: |
      my $C = G.A->spawn('C');
      $C->from({@_}) if @_;
      $C
      
  - K: load_ways
    D: |
        my @ways = @_;
        G.ways ||= [];
        G.wayfiles ||= [];
        G.load_ways_count++;

        my $ldw = [];
        while (defined( my $name = shift @ways )) {
            my @files;

            my $base = "ghosts/$name";
            push @files, $base if -f $base;
            push @files, grep { /\/\d+$/ } glob("$base/*");

            for my $file (@files) {
                # TODO pass an If object selector to 0->deaccum
                @{G.ways} = grep { _._wayfile ne $file } @{G.ways};
                @{G.wayfiles} = grep { $_ ne $file } @{G.wayfiles};

                my $nw = $G->nw(name=>$name);
                $nw->load($file);

                if (my $inc = nw.include) {
                    for my $name (split ' ', $inc) {
                        next if grep { _.name eq $name } @{G.ways};
                        push @ways, $name;
                    }
                }

                say "G G.name w+ nw.name";
                push @{G.wayfiles}, $file;
                push @{G.ways}, $nw;
            }
            
            die "no wayfiles from $name" unless @files;
        }

        $G->_0('_load_ways_post', {w=>G.ways});
  - K: du #c the style grab
    style: func
    D: |
      my $a = shift;
      # how to get around the Objs' data
      my $s = a.s ||= dus();
      my $i = a.i;
      my $n = a.n;
      a.e ||= 2;
      
      my $c = {};
      push @{a.as||=[]}, $a;
      return {} if @{a.as} > 9 || 1 < grep {ref _.i && _.i eq $i} @{a.as};
      
      my $ref = ref $i;
      my $is = $s->{$ref} || $s->{default};
      $is ||= $s->{HASH} if "$i" =~ /^\w+=HASH\(/;
      $is ||= $s->{default} || return {};
      
      for my $j (is.it->($i)) {
            die if !$j;
          my $k = delete j.k;
          my $v = delete j.v;
          
          $c->{$k} = $v;
          
          $j = {%$is, %$j};
          my $an = {%$a, i => $v};
          
          an.e -= j.oh || 0.5; # ohms
          say "$k j oh\tj.oh\t-> an.e" if j.oh;
          
          
          if (an.e >= 1) {
              my $cu = du($an);
              # may someday zip into dus again for fractions
              # to display only 2
              while (my ($ku, $vu) = each %$cu) {
                  $c->{$k.$ku} = $vu;
              }
          }
      }
      
      
      $c
      
  - K: dus #c the style schema
    style: func
    D: |
        my $h = {
          ARRAY => {
            it => sub {
              my $h = shift;
              my $i = 0;
              map { { k => "[".$i++, v => $_ } } @$h
            },
          },
          HASH => {
            it => sub {
              my $h = shift;
              map { { k => "{".$_, v => $h->{$_} } } sort keys %$h
            },
          },
        };
        h.A = {
          it => h.HASH.it,
          oh => 2.8,
        };
        $h
      
T:
  - K: new
    D: |
      T.i = T.A.u.i;
      T.i.T = $T;
      $T->name(shift);
      $T->commit(shift);
      
  - K: name
    D: |
      T.name = shift || Ghost::gpty(T.A.u.i);
  
  - K: commit
    D: |
      my $mes = shift;
      T.L ||= [];
      $mes ||= "init" if !@{T.L};
      $mes ||= "?";
      my $L = {
          B => G::du({ O=>$T, i=>T.A.u.i }),
          mes => $mes,
      };
      push @{T.L||=[]}, $L;
      T.HEAD = T.L->[-1];
      
      
W:
  - K: head
    D: |
      use base 'Wormhole';
  - K: new
    D: |
      W.name = "W.A.u.i.name";
      W.G = W.A.u.i;
      W.n = 0;
      $W->wormfile_load(shift);
hooks:
  try: |
    use lib 'l';
    use H;
    my $oh = $H;
    
    my $nH = H->new();
    my $g = nH.G;
    my $nG = g.A->spawn( G => 'E/h' );
    
    $H = $oh;
    my $E = nH.G->w(En => {M=>H.who.B.M});
    my $t = nG.A->spawn('T');
    die sw(t.HEAD.B);
  any_init: |
      $G->timer(0.2,sub{waylay code;});
  code: |
    my $w = G.ways->[0];
    for my $nb (grep { /^[A-Z]$/ } keys %$w) {
        my $co = $G->anyway($nb);
        next unless $co;
        my @code = (
            join "\n",
            "package $nb;",
            "our \$H;",
            map { "use $_;" }
                "strict", "warnings", "utf8", "lib 'lib'", "feature 'say'"
        );
        my $btw = {};
        for my $ch (@$co) {
            my $D = $G->parse_babble(ch.D || ch.SD);
            
            if (ch.K eq "head") {
                ch.style .= "bare";
                if (my $lg = ch.libglob) {
                    my @l = map { /\/(.+?)\.pm$/ } glob $lg;
                    my ($l) = $lg =~ /^(.+)\/.+?$/;
                    push @code, "use lib '$l';";
                    push @code, "use $_;" for @l;
                    btw.s.___LIBGLOBETC = join "\n",
                        map { "\$${_}::H = \$H;" } @l;
                }
            }
            
            if (ch.style !~ /bare/) {
                $D =~ s/$_/btw.s->{$_}/seg for keys %{btw.s};
                
                # setup self
                $D = "my \$$nb = shift;\n$D" if ch.style !~ /func/;
                
                # return self
                $D = "$D\n\$$nb"             if ch.K eq "new" || ch.SD;
                
                $D = ind('    ', $D);
                $D =~  s/^    $//sgm;
                $D = "sub ch.K {\n$D\n}\n";
            }
            push @code, $D;
        }
        push @code, "'stylehouse'";
        my $file = "l/${nb}.pm";
        write_file($file, join("\n", @code));
        
        run "perl -c $file";
        
    }
    
    waylay try;

  

