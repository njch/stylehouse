
Oi:
  includome: G/way G/cis
Ds:
  - K: head #c
    style: nonbabble
    D: |
      use YAML::Syck;
      use Mojo::Pg;
      use List::MoreUtils 'natatime';
      use File::Slurp;
      use JSON::XS;
      use YAML::Syck;
      use Scriptalicious;
      use HTML::Entities;
      use List::Util qw(first max maxstr min minstr reduce shuffle sum);
      use List::MoreUtils qw(natatime uniq);
      use Unicode::UCD 'charinfo';
      # use Mojo::IOLoop::ForkCall; # see para
      our $swdepth = 5;
      our $T; # allele tower... not like so, again R above
      our @F; # is Ring re subs from below 
      our $G0;
      our $db = 0;
      our $MAX_FCURSION = 140;
      our $NUM = qr/(?:(\d+(?:\.\d+)?) )/;
      our $HASHC = "#"."c";
      our $gp_inarow = 0;
      my %D_cache;

      # ^ curves should optimise away, accordion
      
      #c to dry up
        
        sub ddump { H::ddump(@_) }
        sub wdump { H::wdump(@_) }
        
        # to go
        sub findO { my ($k, $o) = @_; grep { $_->{O} eq $k } @$o }
        
        sub slim {
            my ($f,$t,$c) = @_;
            ($f,$t,$c) = (40,40,$f) if !$t && !$c;
            $c = ($c=~/^(.{$t})/s)[0]."..." if length($c) > $f;
            $c
        }
        sub shtocss { 
            my $s = shift;
            return join "", map { "$_:$s->{$_};" } sort keys %$s if ref $s eq "HASH";
            return join ";", @$s if ref $s eq "ARRAY";
            return $s
        }
        sub ind { "$_[0]".join "\n$_[0]", split "\n", $_[1] }
        use Carp 'confess';
        use Term::ANSIColor; 
        use File::Find;

        our $Ly;
        our $_ob = undef;
  - K: new #c
    D: |
      my (@ways) = @_;
      G.way = join "+", @ways;
      G.name = G.way;
      
      G.GGs = [];
      my $ui = G.A.u.i;
      wish(G => $ui) || $ui eq $H || die "not G above? G.name ".$ui->pi;
      G.O = $ui;
      G.A->umv('', 'G');
      G.A->umk(H.G, 'Gs') if H.G;
      push @{ui.GGs}, $G; # OGG
      push @{H.G.GGs}, $G unless $ui eq H.G; # OGG
      
      
      $G->load_ways(@ways);
      
  - K: gp #c 
    style: func
    D: |
      my $u = shift;
      return $u->pi if ref $u && ref $u ne 'HASH' && ref $u ne 'CODE'
          && ref $u ne 'ARRAY' && $u->can('pi');
      gpty($u);
      
  - K: sw #c
    style: func
    D: |
      my $stuff = wdump($G::swdepth, @_>1?\@_:@_);
      return say "too early rto publich" if ! H.r;
      H.r->publish('sw', $stuff);
      say "published wdump to sw from   $G::swdepth x ".length($stuff);
  
  - K: pi #c
    D: |
      "G ".G.name;
  
  - K: deeby #c TODO... more pi about thing printing, how much interest (db)
    D: |
        G.db + $db > 0
        
  - K: throwlog
    styles: func
    D: |
        my $what = shift;
        H.G->w(throwlog => {what => $what, thing => [@_]});
        
  - K: susgdb
    D: |
        my $t = $db;
        push @{$F[0]->{_after_do}}, sub { $db = $t };
        $db = -2;
        
  - K: gname # goner? 
    D: |
        my $g = shift;
        my $si = shift || 0;
        my $ush = "$g";
        my $may = $g->{name} || $g->{K} || $g->{id} if ref $g && $ush =~ /HASH/;
        $may ||= (0+keys %$g)."{" if ref $g eq "HASH";
        $may ||= "$g";
        $may =~ s/^(\w+)=HASH.*$/$1\{/;
        $may;
   
  - K: pint
    style: func
    D: |
        my $w = shift; 
        $w && ref $w eq "Way" ? $w->pint : "ww:".join"",map { s/\s//sg; $_ } wdump(2,$w)
   
  - K: mess
    D: |
        H.G->w(mess => {what => shift, thing => shift}); # TODO say*
   
  - K: ghostlyprinty
    style: func
    D: |
        $gp_inarow++;
        my $witcolour = sub { '<t style="color:#'.($_[1] || '8f9').';">'.shift.'</t>' };
        my $nohtml;
        if ($_[0] && $_[0] eq "NOHTML") {
            shift;
            $nohtml = 1;
            $witcolour = sub { shift };
        }
        
        my @t = @_;
        my @s;
        for my $t (@t) {
            if ($t && ref $t eq "ARRAY") {
                if ($gp_inarow > 5) {
                    push @s, "ghostlyprinty recursion!";
                    next;
                }
                push @s, map { "[".ghostlyprinty(($nohtml?("NOHTML", $_):($_))) } @$t;
            }
            elsif (ref $t) {
                push @s, $witcolour->(ref($t), "333;font-size:50%");
                my $name = gname($t);
                push @s, $witcolour->($name);
            }
            else {
                push @s, (defined $t ? $t : "~")
            }
        }
        $gp_inarow--;
        join "  ", @s
        
  - K: pty
    style: func
    D: |
        my $t = shift;
        ref $t eq "Way" ? pint($t) : gpty($t)
        
  - K: gpty
    style: func
    D: |
        ghostlyprinty('NOHTML',@_)
  

  - K: R #c needle extRange
    D: |
      G.A->spawn(R => @_);
  
  - K: TRub #c top level inGector
    D: |
      my $a = {};
      my $R = G.R ||= G.A->spawn("R");
      # like du, vectors space out after $k
      #   for increment spacing over the braid
      
      # nah just chuck stuff in $a
      # everything should have more meaning than that
      my @a = @_;
      while (@a) {
          my ($k, $v) = (shift(@a), shift(@a));
          $R->loadup($a, $k, $v);
      }
      
      # 1
      
      # find u from K and B?
      my $u = 0->CsK({K=>a.i.K});
      die "Not leading anywhere: ". wdump($a) unless $u;
      $u->from(a.i);
      
      # etc
      0->T({i => $u});
  - K: ob #c make lookee
    D: |
      my $ob = G._ob || $_ob || return;
      
      my $s = $G->pyramid(@_);
      
      my $te = $@; $@ = "";
      my $to = $_ob; $_ob = undef;

      $ob->w(ob=>{s=>$s});

      $_ob = $to;
      $@ = $te;
  - K: Gf #c
    D: |
        my $way = shift;
        # TODO $G or $S etc A 
        my @GGs =
          #sort { length($a->{way}) <=> length($b->{way}) } # cerated
          grep { $_->{way} =~ /$way/ } @{ $G->{GGs} };
        
        wantarray ? @GGs : shift @GGs;
  - K: HGf #c
    style: func
    D: |
      H.G->Gf(@_)
  - K: W #c
    D: |
      die "Hi";
      G.W
  - K: parse_babble #c
    style: nonbabble
    D: |
      
            my $eval = shift;
            
            my $AR = qr/(?:\[(.+?)\]|(?:\((.+?)\)))/;
            my $G_name = qr/[\/\w]+/;
            my $Gnv = qr/\$?$G_name/;
            
            # 5/9
            
            $eval =~ s/(Sw|ws) (?=\w+)/w \$S /sg;
            
            $eval =~ s/(Say|Info|Err) (([^;](?! if ))+)/\$H->$1($2)/sg;
            $eval =~ s/T (?=->)/->T() /sg;
            
             
            # 6/9 - motionless subway
            
            $eval =~ s/timer $NUM? \{(.+?)\}/\$G->timer($1, sub { $3 })/sg;
            $eval =~ s/waylay $NUM?(\w.+?);/\$G->timer("$1",sub { w $2; },"waylay $2");/sg;
            
            my $point = qr/[\w\$\/\->\{\}]*[\w\$\/\->\.\}]+/;
            
            my $alive = qr/\$[\w]*[\w\->\{\}]+/;
            
            my $dotha = qr/[A-Za-z_]\w{0,3}(?:\.[\w-]*\w+)+/;
            my $poing = qr/$alive|G:$point|$dotha/;
            
            my $sqar = qr/\[.+?\]|\(.+?\)/; 
            
            my $sur = qr/ if| unless| for/;
            my $surn = qr/(?>! if)|(?>! unless)|(?>! for)/;
            my $suro = qr/(?:$sur|(?>!$sur))/;
            
            while ($eval =~
            /\${0}($poing )?((?<![\$\w])w(?: ($poing))? ($point)( ?$sqar| ?$point|))($sur)?/sg) {
                my ($g, $old, $u, $p, $a, $un) = ($1, $2, $3, $4, $5, $6);
                
                if (!$g) {
                    $g = '$G';
                }
                else {
                    $g = ""
                }

                my @n;
                my $ne = ""; # hidden reverse
                ($ne, $a) = ($a, "") if $a =~ /^$sur$/;
                # ^ caught a bit of conditional syntax after w expr


                push @n, '%$ar' if $a =~ s/^[\(\[]\+ ?// || !$a;
                
                push @n, $a     if $a =~ s/^\(|\)$//sg;
                
                push @n, 
                    map { my($l)=/\$(\w+)/;"$l => $_" } split /, */, $a

                                if $a =~ s/^\[|\]$//sg;
                

                my @e;
                push @e, qq["$p"];
                push @e, "{".join(", ",@n)."}";
                push @e, $u if $u;
                my $en = join ", ", @e;
                
                my $wa = $g."->w(".$en.")".$ne;
                
                
                #saygr " $old \t=>\t$wa \t\t\tg$g \tu$u \tp$p \ta$a \tun$un";
                
                $eval =~ s/\Q$old\E/$wa/          || die "Ca't replace $1\n\n in\n\n$eval";
            }
            
            # 8/9

            $eval =~ s/G!($Gnv)/G\.A->spawn(G => "$1")/sg;
            $eval =~ s/G-($Gnv)/\$G->Gf("$1")/sg;
            $eval =~ s/G:($Gnv)/HGf("$1")/sg;

            $eval =~ s/(?<!G)0->(\w+)\(/\$G->$1(/sg; 

            $eval =~ s/(?:(?<=\W)|^)([A-Za-z_]\w{0,3})((?:\.[\w-]*\w+)+)/"\$$1".join"",map {"->{$_}"} grep {length} split '\.', $2;/seg;


            $eval;
  - K: du #c G style grab
    D: |
      my $a = shift;
      # how to get around the Objs' data
      my $s = a.s ||= $G->dus();
      my $i = a.i;
      my $n = a.n;
      a.e = 2 if !defined a.e;
      
      my $c = {};
      a.as ||= [];
      die sw($a) if !defined a.i;
      push @{a.as}, $a;
      a.ds = [@{a.ds||[]}, $a];
      
      return {} if @{a.ds} > 12 || 2 < grep {ref _.i && _.i eq $i} @{a.as};
      
      my $ref = ref $i;
      my $is = $s->{$ref} || $s->{default};
      $is ||= $s->{HASH} if "$i" =~ /^\w+=HASH\(/;
      $is ||= $s->{default} || return {};
      
      # $mustb
      # does HASH key importance if 0>e<1
      # travels every thing      if e>=1
      #                also      if 0.5<e<1
      # since it must want to know links by then
      # overthinking must be reached somehow
      # going over a line
      # at 5
      # how much is happened
      # sw is a channel
      # the way in the splat...
      
      # there's some more flipping around: TODO
      # an e mod possibly coming from mustb (missing part)
      # so some mustb key can e above 0.5 and see travel
      
      # could return somehow weighted graph, hmm
      # oldworld really doesn't like that idea
      # maybe if du was grabbed as more abstract chunks with A action
      # driving the new codons basically...
      
      # snapping branches off the concept of ^ for now
      
      # we sculpt data as fractions of energy that enlightens the 1-9 meanings
      # fuck binary
      
      # an.s, etc can be modded as meaning builds down
      # but only for 
      # (separado until much future brings everything together)
      
      my $mustb = { map { $_ => 1 } split ',', is.mustb } if is.mustb;
      
      for my $j (is.it->($i)) {
          my $k = delete j.k;
          my $K = delete j.K;
          my $v = delete j.v;
          
          $j = {%$is, %$j};
          my $an = {%$a, i => $v};
          
          my $ohms = defined j.oh ? j.oh : 1;
          
          an.e -= $ohms;
          
          my $rk = "$k an.e";
          $c->{$rk} = $v;
          
          say join("", ("  ") x scalar(@{a.ds}))
              ." a.e - $ohms  $k\t an.e \t\t ".gpty($v);
                    
          if (an.e >= 1 && ref an.i) {
              my $cu = $G->du($an);
              while (my ($ku, $vu) = each %$cu) {
                  my $nk = $k.$ku;
                  next if grep { $_->($_, $an, $cu) } @{s.notZ||[]};
                  $c->{$nk} = $vu;
              }
          }
          elsif (an.e > 0 && an.e < 1 && $mustb && !$mustb->{$K}) {
              delete $c->{$rk};
          }
      }
      
      
      $c
      
  - K: dus #c G style schema
    D: |
        my $h = {
          ARRAY => {
            it => sub {
              my $h = shift;
              my $i = 0;
              map { { k => "[".$i++, v => $_ } } @$h
            },
            oh => 0,
          },
          HASH => {
            it => sub {
              my $h = shift;
              map { { K=>$_, k=>"{".$_, v=>$h->{$_} } } sort keys %$h
            },
          },
        };
        my $an = sub {
            my $k = shift;
            my $i = $h->{$k} ||= {it => h.HASH.it};
            %$i = (%$i, @_);
        };
        $an->(qw'A oh 0.2');
        $an->(qw'Ghost oh 0.8');
        $an->(qw'G oh 0.8');
        $an->(qw'W oh 0.8 mustb','id,hash,file,G');
        $h
  - K: F_delta #c
    style: func
    D: |
            my $now = $H->hitime();
            my $then = $F[0]->{hitime};
            my $d = sprintf("%.3f",$now-$then);
            $d = $d<1 ? ($d*1000).'ms' : $d.'s';
  - K: inter #c
    style: func
    D: |
            
            my $thing = shift;
            my $ki = ki($thing);
            $ki =~ s/^\s+//;
            $F[1]->{inter} ||= ".";
            $F[1]->{inter} .= "\n -{".$ki."}\n";
  - K: crankFun #c
    D: |
            my $un = $G->crank(@_);
            # so a synapse would snake through something...
            # directly looking at a concept and exuding its energy pathway
            push @{ $F[0]->{_after_do} }, $un;
            return
  - K: crank #c
    D: |
            my ($dial,$v) = @_;
            my $original = $G->{$dial};
            $G->{$dial} = $v;
            
            sub { $G->{$dial} = $original };
  - K: ki #c
    style: func
    D: |
      my $ar = shift;
      my $s = "";
      if (!ref $ar || "$ar" !~ /HASH/) {
          confess "NOT HASH: $ar";
      }
      for my $k (sort keys %$ar) {
          my $v = $ar->{$k};
          $v = "~" unless defined $v;
          #$v = "( ".gname($v)." )" if ref $v;
          $s .= "   $k=$v";
      }
      $s
      
  - K: unico #c
    style: func
    D: |
      my ($int, $wantinfo) = @_;
      my $h = sprintf("%x", $int);
      my @s = eval '"\\x{'.$h.'}"';
      push @s, charinfo($int) if $wantinfo;
      wantarray ? @s : shift @s
      
      
      
  - K: flatline #c
    style: func
    D: |
      map { ref $_ eq "ARRAY" ? flatline(@$_) : $_ } @_
    
  - K: recur #c
    D: |
        Mojo::IOLoop->recurring(@_);
  - K: wish #c
    style: func
    D: |
      my $w = shift;
      my $i = shift;
      $w eq "W" ? ref $i eq "Wormhole" || ref $i eq "W" :
      $w eq "w" || $w eq "C" ? ref $i eq "Way" || ref $i eq "C" :
      $w eq "G" ? ref $i eq "Ghost" || ref $i eq "G" : die "wish $w $i";
  - K: saycol #c sayyl sayre sayg saygr saybl
    style: func
    D: |
        my $colour = shift;
        print colored(join("\n", @_,""), $colour);
        wantarray ? @_ : shift @_
  - K: sayyl
    style: func
    D: |
        saycol(bright_yellow => @_)

  - K: sayre
    style: func
    D: |
        saycol(red => @_)

  - K: sayg
    style: func
    D: |
        saycol(bright_green => @_)

  - K: saygr
    style: func
    D: |
        saycol(green => @_)

  - K: saybl
    style: func
    D: |
        saycol(bright_blue => @_) 
    
  - K: uiuS #c U ventrickles
    D: |
        my ($u, $b) = @_;
        my $a = "S";
        my $ui = u.i if u.i;
        
        for my $w ($ui, $u) {
            next if !$w;
            
            my $Gw = w.G->findway(w.K) if w.Gw;
            
            for my $ww ($Gw, $w) {
                next if !$ww;
                next if !$ww->{$a};
                if ($ww->{$a}->{"${b}_D"}) {
                    $G->Flab("got a $a $b _D  ", $u);
                    my $some = w.G->w("$a/${b}_D", {u=>$u}, $w);
                    return $some if $some;
                }
                my $some = $ww->{$a}->{$b};
                return $some if $some;
            }
        }
  - K: GAK #c
    D: |
        my ($K, $g) = @_;
        g.K = $K;
        G.GG->{g.K} = $g;
  - K: sing #c sing ing ingo
    D: |
        my $p;
        p.name = G.id."/".shift;
        p.code = shift;
        $p = {%$p, @_};
        my $name = p.name;
        my $code = p.code;
        
        my $si = H.G.singing ||= {};
        return if $si->{$name} && $si->{$name}++;
        $si->{$name} = 1;
        
        my $after = p.block || p.again || 0.2;
        my $init = p.begin || 0.001;
        
        $G->timer($init, sub {
        
            $G->timer($after, sub {
                my $splatter = delete $si->{$name};
                if ($splatter > 1 && p.again) {
                    $G->Flab("Sig reps $splatter... again!  $name");
                    $G->sing($name, $code, %$p);
                }
            }, "sing-block        $name");
            
            $si->{$name} = 1;
            $code->();
        }, "pre-sing     $name");
  - K: ing #c puts teeth along the wave that ingo unifies into doing, batching...
    D: |
        my ($time, $ing, $w) = @_;
        $time && $ing || die " time&ing";
        
        my $name = $ing;
        $name .= $w->pint if $w;
        my $ingw = $G->nw(
            K=>"ing",
            name => $name,
            ing => $ing,
            time => $time,
        );
        say "create ingw.G.name ingw.name $time";
        ingw.w = $w if $w;
        my $inga = G.ing->{$name} ||= {};
        _.dead = 1 for values %$inga;
        $inga->{ingw.id} = $ingw;
        0->ingo($ingw);
    
  - K: ingo #c
    D: |
        my ($ingw) = @_;
        return say "ing ingw.name ingw.id deduped" if ingw.dead;
        return say "ing ingw.name ingw.id ui dead" if ingw.w && ingw.w.dead;
        
        $G->w(ingw.ing, {}, ingw.w);
        
        my $time = ingw.w.e if ingw.w && ingw.w.e;
        $time ||= ingw.time;
        say "time ingw.G.name ingw.name $time";
        $G->timer($time, sub {
            0->ingo($ingw);
        }, "ing ingw.name ingw.id");


  - K: ip #c TODO Tish/R maths logics, heat mapping, see also CsK vortex reading
    D: |
        my ($ip, $i) = @_;
        my $pass = 1;
        for my $I (keys %$ip) {
            $pass-- if $ip->{$I} ne $i->{$I};
        }
        $pass == 1
  - K: fs_glob #c
    D: |
        my (@globs) = @_;
        my @list;
        for my $glob (@globs) {
            push @list, grep { defined }
                grep { $H->fixutf8($_) || 1 }
                grep { -f $_ } glob $glob;
        }
        return @list;
  - K: fs_find #c
    D: |
        my (@dirs) = @_;
        my @list;
        File::Find::find(sub {
            my $na = $File::Find::name;
            $H->fixutf8($na);
            return unless -f $na;

            push @list, $na;
        }, @dirs);
        return @list;
  - K: jsq #c
    D: |
        my @a = @_;
        for (@a) {
            s/\\/\\\\/g;
            s/'/\\'/g;
            s/\n/\\n/g;
        }
        wantarray ? @a : shift @a;
  - K: jssq #c
    D: |
        my @a = @_;
        for (@a) {
            s/\\/\\\\/g;
            s/"/\\"/g;
            s/\\\\n/\\n/g;
            #s/\n/\\n/g;
        }
        wantarray ? @a : shift @a;
  - K: Stytog #c
    D: |
        my ($u, $s) = @_;
        my @styles = split /\s+/, u.styles;
        if (grep { $_ eq $s } @styles) {
            @styles = grep { $_ ne $s } @styles
        }
        else {
            push @styles, $s;
        }
        u.styles = join ' ', @styles;
        $G->w('v/ch', {u=>$u});

  - K: su #c
    D: |
        my ($a) = @_;
        if (@_ > 1) {
            $a = {top => shift};
            a.cb = pop;
            a.div = shift || 7;
        }
        a.top && a.cb || die "wtf";
        my $D = a.cb;
        
        H.G->w(subsc => $a); 

