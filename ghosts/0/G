
name: other stuff...
hooks:
  try: |
    Say 'Restarting S';
    `touch ghosts/0/S`;
    
  any_init: |
      $G->timer(0.2,sub{waylay code;}); 
  fresh_init: |
    push @{G0.recoded_cbs}, sub { w try; };
  code: |
    my $w = G.ways->[0];
    for my $nb (grep { /^[A-Z]$/ } keys %$w) {
        my $co = $G->anyway($nb);
        next unless $co;
        my @code = (
            join "\n",
            "package $nb;",
            "our \$H;",
            map { "use $_;" }
                "strict", "warnings", "utf8", "lib 'lib'", "feature 'say'"
        );
        my $btw = {};
        for my $ch (@$co) {
            say "skipping a blank K in $nb" && next if !ch.K;
            
            my $D = $G->parse_babble(ch.D || ch.SD);
            
            if (ch.K eq "head") {
                ch.style .= "bare";
                if (my $lg = ch.libglob) {
                    my @l = map { /\/(.+?)\.pm$/ } glob $lg;
                    my ($l) = $lg =~ /^(.+)\/.+?$/;
                    push @code, "use lib '$l';";
                    push @code, "use $_;" for @l;
                    btw.s.___LIBGLOBETC = join "\n",
                        map { "\$${_}::H = \$H;" } @l;
                }
            }
            
            if (ch.style !~ /bare/) {
                $D =~ s/$_/btw.s->{$_}/seg for keys %{btw.s};
                
                # setup self
                $D = "my \$$nb = shift;\n$D" if ch.style !~ /func/;
                
                # return self
                $D = "$D\n\$$nb"             if ch.K eq "new" || ch.SD;
                
                $D = ind('    ', $D);
                $D =~  s/^    $//sgm;
                $D = "sub ch.K {\n$D\n}\n";
            }
            push @code, $D;
        }
        push @code, "'stylehouse'";
        my $file = "l/${nb}.pm";
        write_file($file, join("\n", @code));
        
        
    }
    run "perl -c l/H*";
    
    waylay try;

  
H:
  - K: head
    libglob: 'l/?.pm'
    D: |
        use UUID;
        use Redis;
        use File::Slurp;
        use Time::HiRes 'gettimeofday', 'usleep';
        use YAML::Syck;
        use Data::Dumper;
        use Term::ANSIColor;
        

        sub wdump{Ghost::wdump(@_)}
    
  - K: new
    D: |
      my $p = shift;
      
      $DB::single = 1;
      $H = $H->spawn0('H', $p);
      ___LIBGLOBETC
       
      use lib 'lib'; 
      use Hostinfo;
      Hostinfo::lib_perc_H($H);
      
      $H->spawn0('A')->new($H);
      H.G = H.A->spawn(G => 'H');
      
      H.G->w('fresh_init'); # art
      H.G->w('any_init'); # art
      
      # is either G->subs or vortexed way, not a "root ghost" anymore but...
      $Ghost::G0 = H.A->spawn(G => 'G');
      $Ghost::G0->w('fresh_init');
      $Ghost::G0->w('any_init');

  - K: pi
    D: |
      "H ! ";
      
  - K: spawn
    D: |
      my $a = shift;
      my $u = $H->spawn0(@{a.r});
      
      if (ref $u eq 'A') {
          $u = $u->new(a.i);
      }
      else {
          $H->spawn({i=>$u, r=>['A']});
          a.uA->An($u);
          u.A->Au(a.uA);
          shift @{a.r};
          $u = $u->new(@{a.r});
      }
      say "H spawning ".$u->pi unless ref $u eq 'A' || ref $u eq 'C';
      $u
      
  - K: spawn0
    D: |
      my $nb = shift;
      my $p = shift || {};
      my $u = bless {%$p}, $nb;
      $nb::H = $H;
      u.id = mkuid();
      $u
  #c bits and stuff
  - K: snooze
    D: |
          return Time::HiRes::usleep(shift || 5000);
  - K: Say #c
    D: |
       $H->throwlog("Say", @_);

  - K: Err
    D: |
       $H->throwlog("Err", @_);
  - K: error
    D: |
       $H->throwlog("Err", @_);

  - K: Info
    D: |
       $H->throwlog("Info", @_);
  - K: info
    D: |
       $H->throwlog("Info", @_);

  - K: throwlog
    D: |
      my $what = shift;

      if ($H->{_future}) {
          my $te = $@;
          $@ = "";
          my $r = eval { $H->{G}->mess($what, [@_]) };
          if ($@) {
              eval { $H->{G}->timer(0.1, sub {
                  $H->error("G mess error while throwing a $what: $@");
               }) };
              $@ = '';
          }
          $@ = $te;
          if ($r && $r eq "yep") {
              return;
          }
      }

      my @E;
      for my $b (@_) {
          if (ref $b eq "Way") {
              push @E, "Way: $b->{name}";
              push @E, ( map { " ` ".Ghost::ghostlyprinty("NOHTML", $_) } @{$b->{thing}});
              push @E, $b->{Error} if $b->{Error};
          }
          else {
              push @E, Ghost::ghostlyprinty("NOHTML", $b)
          }
      }
      my $error =
          [ hitime(), $H->stack(2), [@E] ];

      my @context = (
          grep { !/Ghost Ghost::__ANON__ |Ghost \(eval\)/ } @{$error->[1]},
      );
      @context = () if $what eq "Say" || $what eq "Info";
      my @f = @Ghost::F;
      for my $c (@context) {
          my $f = shift @f;
          say "$c ======== ". Ghost::gpty($f->{thing});
      }
      my $string = join("\n",
          @context,
          @{$error->[2]},
      );
      $string = "\n$string\n";
      print colored(ind("$what  ", $string)."\n", $what eq "Error"?'red':'green');

    
  - K: ind #c
    D: |
      my ($in, $thing) = @_;
      $thing = "" unless defined $thing;
      join "\n", map { "$in$_" } split "\n", $thing

  - K:ddump
    D: |
      my $thing = shift;
      my $ind;
      return
          join "\n",
          grep {
              1 || !( do { /^(\s*)hostinfo:/ && do { $ind = $1; 1 } }
              ...
              do { /^$ind\S/ } )
          }
          "",
          grep !/^       /,
          split "\n", Dump($thing);

  - K: wdump
    D: |
      my $thing = shift;
      my $maxdepth = 3;
      if (@_ && $thing =~ /^\d+$/) {
          $maxdepth = $thing;
          $thing = shift;
      }
      $Data::Dumper::Maxdepth = $maxdepth;
      return join "\n", map { s/      /  /g; $_ } split /\n/, Dumper($thing);

  - K: send
    D: |
      my $m = shift;
      die "Message contains \\n:\n$m\n\n" if $m =~ /\n/;
      H.G->w(send_Elvis => {m => $m});
    
  - K:
    D: |
      
  - K:
    D: |
      
  - K:
    D: |
      
  - K:
    D: |
      
  - K:
    D: |
      
  - K:
    D: |
      
    
      
  - K: hitime
    D: |
      return join ".", time, (gettimeofday())[1];
  - K: stack #c
    D: |
      my $b = shift;
      $b = 1 unless defined $b;
      my @from;
      while (my $f = join " ", (caller($b))[0,3,2]) {
          last unless defined $f;
          my $surface = $f =~ s/(Mojo)::Server::(Sand)Box::\w{24}/$1$2/g
              || $f =~ m/^Mojo::IOLoop/
              || $f =~ m/^Mojolicious::Controller/;
          $f =~ s/(MojoSand\w+) (MojoSand\w+)::/$2::/;
          push @from, $f;
          last if $surface; 
          $b++;
      }
      return [@from];
      
  - K: slurp
    D: |
      scalar read_file(shift);
      
  - K: spurt
    D: |
      write_file(shift, shift);
      
  #Hmisc #c
  - K: mkuid # H wide unique id
    style: func
    D: |
        (mkuuid() =~ /^(\w+)-.+$/)[0];
        
  - K: mkuuid # make a number bigger than the universe
    style: func
    D: |
      UUID::generate(my $i);
      UUID::unparse($i, my $s);
      $s
A:
  - K: new # link the thing A in
    D: |
      my $i = shift;
      A.i = $i;
      i.A = $A;
      
  - K: pi
    D: |
      "A A.id ".A.i->pi();
      
  - K: spawn # make down
    D: |
      $H->spawn({uA => $A, r=>[@_]});
      
  - K: An # link down
    D: |
      my $n = shift;
      push @{A.n}, $n;
      
  - K: Au # link up
    D: |
      my $u = shift;
      die if A.u;
      A.u = $u;
      
  - K: path
    D: |
      my $up;$up = sub {
          my $u = shift;
          return $u, $up->(u.A.u) if u.A && u.A.u && $u ne u.A.u;
      };
      my @path = reverse $up->(A.u);
      return join "/", map { ref $_ } @path;
      
      
    
C:
  - K: head
    D: |
      use base 'Way';
  - K: new
    D: |
      C.G = C.A.u.i;
      
  - K: pi
    D: |
      my $some = "C ".$C->pint();
      unless (length($some) > 5) {
          $some .= " ".Ghost::ki($C);
      }
      $some
G:
  - K: head
    D: |
      use base 'Ghost';
      sub wdump { Ghost::wdump(@_) };
      sub gpty { Ghost::wdump(@_) };
      sub sw { Ghost::sw(@_) };
      use YAML::Syck;
      
  - K: new
    D: |
      my (@ways) = @_;
      G.name = join "+", @ways;
      
      G.GGs = [];
      push @{H.GGs}, $G;
      
      G.W ||= G.A->spawn('W');
      
      
      $G->load_ways(@ways);

  - K: sw
    D: |
      my $thing = @_==1 ? shift : [@_];
      my $stuff = wdump($thing);
      H.r->publish('sw', $stuff);
      "published wdump to sw";

      
  - K: pi
    D: |
      "G ".G.name;
  - K: nw #c G ways
    D: |
      my $C = G.A->spawn('C');
      $C->from({@_}) if @_;
      $C
      
  - K: load_ways
    D: |
        my @ways = @_;
        G.ways ||= [];
        G.wayfiles ||= [];
        G.load_ways_count++;

        my $ldw = [];
        while (defined( my $name = shift @ways )) {
            my @files;

            my $base = "ghosts/$name";
            push @files, $base if -f $base;
            push @files, grep { /\/\d+$/ } glob("$base/*");

            for my $file (@files) {
                # TODO pass an If object selector to 0->deaccum
                @{G.ways} = grep { _._wayfile ne $file } @{G.ways};
                @{G.wayfiles} = grep { $_ ne $file } @{G.wayfiles};

                my $nw = $G->nw(name=>$name);
                $nw->load($file);

                if (my $inc = nw.include) {
                    for my $name (split ' ', $inc) {
                        next if grep { _.name eq $name } @{G.ways};
                        push @ways, $name;
                    }
                }

                say "G G.name w+ nw.name";
                push @{G.wayfiles}, $file;
                push @{G.ways}, $nw;
            }
            
            die "no wayfiles from $name" unless @files;
        }

        $G->_0('_load_ways_post', {w=>G.ways});
  - K: du #c G style grab
    style: func
    D: |
      my $a = shift;
      # how to get around the Objs' data
      my $s = a.s ||= dus();
      my $i = a.i;
      my $n = a.n;
      a.e = 2 if !defined a.e;
      
      my $c = {};
      a.as ||= [];
      die sw($a) if !defined a.i;
      push @{a.as}, $a;
      a.ds = [@{a.ds||[]}, $a];
      
      return {} if @{a.ds} > 12 || 2 < grep {ref _.i && _.i eq $i} @{a.as};
      
      my $ref = ref $i;
      my $is = $s->{$ref} || $s->{default};
      $is ||= $s->{HASH} if "$i" =~ /^\w+=HASH\(/;
      $is ||= $s->{default} || return {};
      
      # $mustb
      # does HASH key importance if 0>e<1
      # travels every thing      if e>=1
      #                also      if 0.5<e<1
      # since it must want to know links by then
      
      # there's some more flipping around: TODO
      # an e mod possibly coming from mustb (missing part)
      # so some mustb key can e above 0.5 and see travel
      
      # could return somehow weighted graph, hmm
      # oldworld really doesn't like that idea
      # maybe if du was grabbed as more abstract chunks with A action
      # driving the new codons basically...
      
      # snapping branches off the concept of ^ for now
      
      # we sculpt data as fractions of energy that enlightens the 1-9 meanings
      # fuck binary
      
      # an.s, etc can be modded as meaning builds down
      # but only for 
      # (separado until much future brings everything together)
      
      my $mustb = { map { $_ => 1 } split ',', is.mustb } if is.mustb;
      
      for my $j (is.it->($i)) {
          my $k = delete j.k;
          my $K = delete j.K;
          my $v = delete j.v;
          
          $j = {%$is, %$j};
          my $an = {%$a, i => $v};
          
          my $ohms = defined j.oh ? j.oh : 1;
          
          an.e -= $ohms;
          
          my $rk = $k;
          $rk .= "$k -$ohms = an.e";
          $c->{$rk} = $v;
          
          say join("", ("  ") x scalar(@{a.ds}))
              ." a.e - $ohms  $k\t an.e \t\t ".Ghost::gpty($v);
                    
          if (an.e >= 1 && ref an.i) {
              my $cu = du($an);
              while (my ($ku, $vu) = each %$cu) {
                  $c->{$k.$ku} = $vu;
              }
          }
          elsif (an.e > 0 && an.e < 1 && $mustb && !$mustb->{$K}) {
              delete $c->{$rk};
          }
      }
      
      
      $c
      
  - K: dus #c G style schema
    style: func
    D: |
        my $h = {
          ARRAY => {
            it => sub {
              my $h = shift;
              my $i = 0;
              map { { k => "[".$i++, v => $_ } } @$h
            },
            oh => 0,
          },
          HASH => {
            it => sub {
              my $h = shift;
              map { { K=>$_, k=>"{".$_, v=>$h->{$_} } } sort keys %$h
            },
          },
        };
        my $an = sub {
            my $k = shift;
            my $i = $h->{$k} ||= {it => h.HASH.it};
            %$i = (%$i, @_);
        };
        $an->(qw'A oh 0.8');
        $an->(qw'Ghost oh 0.8');
        $an->(qw'G oh 0.8');
        $an->(qw'W oh 0.8 mustb','id,hash,file,G');
        $h
      
T:
  - K: new
    D: |
      T.i = T.A.u.i; # MAINT
      T.i.T = $T;
      T.name = shift;
      $T->commit(shift);
      
  - K: pi
    D: |
      "T T.name x".scalar(@{T.L})." ".T.i->pi(); 
  
  - K: commit
    D: |
      my $mes = shift;
      T.L ||= [];
      $mes ||= "init" if !@{T.L};
      $mes ||= "?";
      my $L = {
          B => G::du({ O=>$T, i=>T.i }),
          mes => $mes,
      };
      push @{T.L||=[]}, $L;
      T.HEAD = T.L->[-1];
      
      
W:
  - K: head
    D: |
      use base 'Wormhole';
  - K: new
    D: |
      W.G = W.A.u.i;
      W.name = "W.G.name";
      W.n = 0;
      $W->wormfile_load(shift);

  - K: pi
    D: |
      "W W.name";

