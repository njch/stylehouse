
0:
 G:
  - K: head #c
    D: |
      use base 'Ghost';
      sub wdump { H::wdump(@_) };
      sub gpty { Ghost::wdump(@_) };
      use YAML::Syck;
      our $swdepth = 5;
      our $T; # allele tower... not like so, again R above
      our @F; # is Ring re subs from below
      # ^ curves should optimise away, accordion
      
  - K: new #c
    D: |
      my (@ways) = @_;
      G.way = join "+", @ways;
      G.name = G.way;
      
      G.GGs = [];
      push @{H.G.GGs}, $G;
      
      $G->timer(1, sub {sw(G.A.u.u.i)}) if G.way =~ /ux/;
      
      G.W ||= G.A->spawn('W');
      
      
      $G->load_ways(@ways);
  - K: sw #c
    style: func
    D: |
      my $stuff = wdump($G::swdepth, @_>1?\@_:@_);
      H.r->publish('sw', $stuff);
      "published wdump to sw    $G::swdepth x ".length($stuff);
  - K: pi #c
    D: |
      "G ".G.name;
  - K: nw #c G ways
    D: |
      my $C = G.A->spawn('C');
      $C->from({@_}) if @_;
      $C
      
  - K: load_ways #c
    D: |
        my @ways = @_;
        G.ways ||= [];
        G.wayfiles ||= [];
        G.load_ways_count++;

        my $ldw = [];
        while (defined( my $name = shift @ways )) {
            my @files;

            my $base = "ghosts/$name";
            push @files, $base if -f $base;
            push @files, grep { /\/\d+$/ } glob("$base/*");

            for my $file (@files) {
                # TODO pass an If object selector to 0->deaccum
                @{G.ways} = grep { _._wayfile ne $file } @{G.ways};
                @{G.wayfiles} = grep { $_ ne $file } @{G.wayfiles};

                my $nw = $G->nw(name=>$name);
                $nw->load($file);

                if (my $inc = nw.include) {
                    for my $name (split ' ', $inc) {
                        next if grep { _.name eq $name } @{G.ways};
                        push @ways, $name;
                    }
                }

                say "G G.name w+ nw.name";
                push @{G.wayfiles}, $file;
                push @{G.ways}, $nw;
            }
            
            die "no wayfiles from $name" unless @files;
        }

        $G->_0('_load_ways_post', {w=>G.ways});
  - K: babblethehut #c
    D: |
      my $eval = shift;

      my $G_name = qr/[\/\w]+/;
      my $Gnv = qr/\$?$G_name/;

      $eval =~ s/G!($Gnv)/G\.A->spawn(G => "$1")/sg;
      $eval =~ s/G-($Gnv)/\$G->Gf("$1")/sg;
      $eval =~ s/G:($Gnv)/HGf("$1")/sg;
      
      $eval =~ s/U->(\w+)\(/\$G->U("$1", /sg;
      $eval =~ s/(?<!G)(0->\w+)\(/\$G->_0("$1", /sg;
      $eval =~ s/(0S->\w+)\(/\$G->_0("$1", \$S, /sg;

      $eval =~ s/(?:(?<=\W)|^)([A-Za-z_]\w{0,3})((?:\.[\w-]*\w+)+)/"\$$1".join"",map {"->{$_}"} grep {length} split '\.', $2;/seg;

      $eval
  - K: du #c G style grab
    style: func
    D: |
      my $a = shift;
      # how to get around the Objs' data
      my $s = a.s ||= dus();
      my $i = a.i;
      my $n = a.n;
      a.e = 2 if !defined a.e;
      
      my $c = {};
      a.as ||= [];
      die sw($a) if !defined a.i;
      push @{a.as}, $a;
      a.ds = [@{a.ds||[]}, $a];
      
      return {} if @{a.ds} > 12 || 2 < grep {ref _.i && _.i eq $i} @{a.as};
      
      my $ref = ref $i;
      my $is = $s->{$ref} || $s->{default};
      $is ||= $s->{HASH} if "$i" =~ /^\w+=HASH\(/;
      $is ||= $s->{default} || return {};
      
      # $mustb
      # does HASH key importance if 0>e<1
      # travels every thing      if e>=1
      #                also      if 0.5<e<1
      # since it must want to know links by then
      # overthinking must be reached somehow
      # going over a line
      # at 5
      # how much is happened
      # sw is a channel
      # the way in the splat...
      
      # there's some more flipping around: TODO
      # an e mod possibly coming from mustb (missing part)
      # so some mustb key can e above 0.5 and see travel
      
      # could return somehow weighted graph, hmm
      # oldworld really doesn't like that idea
      # maybe if du was grabbed as more abstract chunks with A action
      # driving the new codons basically...
      
      # snapping branches off the concept of ^ for now
      
      # we sculpt data as fractions of energy that enlightens the 1-9 meanings
      # fuck binary
      
      # an.s, etc can be modded as meaning builds down
      # but only for 
      # (separado until much future brings everything together)
      
      my $mustb = { map { $_ => 1 } split ',', is.mustb } if is.mustb;
      
      for my $j (is.it->($i)) {
          my $k = delete j.k;
          my $K = delete j.K;
          my $v = delete j.v;
          
          $j = {%$is, %$j};
          my $an = {%$a, i => $v};
          
          my $ohms = defined j.oh ? j.oh : 1;
          
          an.e -= $ohms;
          
          my $rk = $k;
          $rk .= "$k -$ohms = an.e";
          $c->{$rk} = $v;
          
          say join("", ("  ") x scalar(@{a.ds}))
              ." a.e - $ohms  $k\t an.e \t\t ".Ghost::gpty($v);
                    
          if (an.e >= 1 && ref an.i) {
              my $cu = du($an);
              while (my ($ku, $vu) = each %$cu) {
                  $c->{$k.$ku} = $vu;
              }
          }
          elsif (an.e > 0 && an.e < 1 && $mustb && !$mustb->{$K}) {
              delete $c->{$rk};
          }
      }
      
      
      $c
      
  - K: dus #c G style schema
    style: func
    D: |
        my $h = {
          ARRAY => {
            it => sub {
              my $h = shift;
              my $i = 0;
              map { { k => "[".$i++, v => $_ } } @$h
            },
            oh => 0,
          },
          HASH => {
            it => sub {
              my $h = shift;
              map { { K=>$_, k=>"{".$_, v=>$h->{$_} } } sort keys %$h
            },
          },
        };
        my $an = sub {
            my $k = shift;
            my $i = $h->{$k} ||= {it => h.HASH.it};
            %$i = (%$i, @_);
        };
        $an->(qw'A oh 0.8');
        $an->(qw'Ghost oh 0.8');
        $an->(qw'G oh 0.8');
        $an->(qw'W oh 0.8 mustb','id,hash,file,G');
        $h
  - K: InjC #c
    D: |
        my ($S, $g, $In) = @_;
        while (my ($s, $etc) = each %$In) {
            while (my ($K, $win) = each %$etc) {
                my $C = G.U.CsK->($g, {K=>$K, s=>$s});
                $C->from($win);
            }
        }
  - K: GAK #c
    D: |
        my ($S, $K, $g) = @_;
        g.K = $K;
        S.GG->{g.K} = $g;
  - K: ing #c
    D: |
        my ($S, $time, $ing, $w) = @_;
        $time && $ing || die " time&ing";
        
        my $name = $ing;
        $name .= $w->pint if $w;
        my $ingw = $S->nw(
            K=>"ing",
            name => $name,
            ing => $ing,
            time => $time,
        );
        say "create ingw.G.name ingw.name $time";
        ingw.w = $w if $w;
        my $inga = S.ing->{$name} ||= {};
        _.dead = 1 for values %$inga;
        $inga->{ingw.id} = $ingw;
        0S->ingo($ingw);
    
  - K: ingo #c
    D: |
        my ($S, $ingw) = @_;
        return say "ing ingw.name ingw.id deduped" if ingw.dead;
        return say "ing ingw.name ingw.id ui dead" if ingw.w && ingw.w.dead;
        
        $S->w(ingw.ing, {}, ingw.w);
        
        my $time = ingw.w.e if ingw.w && ingw.w.e;
        $time ||= ingw.time;
        say "time ingw.G.name ingw.name $time";
        $S->timer($time, sub {
            0S->ingo($ingw);
        }, "ing ingw.name ingw.id");
  - K: scGre #c
    D: |
        my ($S, $ip) = @_;
        # or something was somehow, tractioning v
        my @a = grep { G.U.ip->($S, $ip, _.i) } @{ S.W.script };
        @a
  - K: ip #c
    D: |
        my ($S, $ip, $i) = @_;
        (!exists ip.K || i.K eq ip.K) &&
        (!exists ip.V || i.V eq ip.V)
  - K: rei #c
    D: |
        my ($S, $ip) = @_;
        map {_.i} 0S->scGre($ip);
  - K: reeni #c
    D: |
        my ($S, $ip, @is) = @_;
        my @sel;
        my @new = grep {defined} map {
            if (0S->ip($ip, _.i)) {;
                push @sel, $_;
                undef;
            }
            else {         $_           }
        } @{S.W.script};
        # etc
  - K: sing #c
    D: |
        my $S = shift;
        my $p;
        p.name = shift;
        p.code = shift;
        $p = {%$p, @_};
        p.again = 0.5 if !defined p.again;
        p.begin = 0.2 if !defined p.begin;
        w sing(%$p);
  - K: loquate #c
    D: |
        my ($S, $source, $path, $def) = @_;
        my @moves = split '/', $path;
        my $s = $source;
        until (@moves == 1) {
            my $m = shift @moves;
            $s = $s->{$m};
        }
        my $m = shift @moves;
        my $thing = $s->{$m} ||= $def;
        !ref $thing && die "Oh no! $path led to non-ref $thing from $source";
        return $thing;
  - K: accum #c
    D: | 
        # TODO path loquation doesn't stretch far re policy, no prob for now.
        my ($S, $src, $ac, $t) = @_;
                
        if ($ac eq "Lo" || $ac eq "Li") {
            $src->{$ac} = $t;
            return;
        }
        
        my $a = 0S->loquate($src, $ac, []);
        
        return if $ac eq 'o' && src.i && src.i eq $t;

        if (!grep { $_ eq $t } @$a) {
            push @$a, $t
        }
  - K: deaccum #c
    D: |
        my ($S, $source, $ac, $t) = @_;
        my $a = $source->{$ac} ||= [];
        my $i = 0;
        for (@$a) {
            return splice(@$a, $i, 1) if $_ eq $t;
            $i++;
        }
  - K: wdif #c
    D: |
        my ($S, $h, $w) = @_;
        if ($w->{$h}) {
            $S->w($h, {}, $w);
            delete $w->{$h};
        }
  - K: u #c
    D: |
        my ($S, $K, $s) = @_;
        0S->sway({K=>$K}, $s);
  - K: sway #c
    D: |
        # sucks way matching $p # only supports matching K for now
        my ($S, $p, $s, $P) = @_;
        p.s ||= 'chains C';
        my ($from) = p.from || 0S->CsK($p);
        
        $from || defined P.e || die "no findo way called p.K (S.name)".wdump([$p,$s]);
        
        my $w = $S->nw();
        $w->from($from) if $from;
        $w->from($p) unless $from;
        $w->from($s) if $s && %$s; # merges in B :D
        
        return $w
  - K: Bu #c
    D: |
        my($S,$K,$B)=@_;
        my $u = 0S->sway({K=>$K},{B=>$B});
        my $a = {};
        $S w $u Bu_D[$a] if u.Gw || u.Bu_D;#opopopopop
        $u;
  - K: CsK #c
    D: |
        my ($S, $p, $GG) = @_;
        $GG ||= $S;
        p.s ||= 'C';
        # p.CsK locates the Cs, is a qw of paths for anyway
        my @Cs = map { flatline($_) } map { $GG->anyway($_) }  split ' ', delete p.s;
        # another ghost lurks
        if (p.K) {
            @Cs = grep { _.K eq p.K } @Cs;
        }
        return wantarray ? @Cs : shift @Cs;
  - K: Tind #c
    D: |
        my ($S, $space) = @_;
        $space = "    " if !defined $space;
        my $mes = T.r.is if T.r;
        $mes ||= [];
        my $ind = "";
        $ind .= "    " for 0..@$mes; # +1
        return $ind;
  - K: Egypto #c
    D: |
        my ($S, $Egyptian_Fraction) = @_;
        my $val = 0;
        for (split / ?\+ ?/, $Egyptian_Fraction) {
            /^(\d+)\/(\d+)$/ || die "Egypmal";
            $val += $1 / $2;
        }
        $val;
  - K: EgyB #c
    D: |
        my ($S, $B) = @_;
        return { map { 0->Egypto($_) => $_ } keys %$B };
  - K: TafuBl #c
    D: |
        #STICKSSTICKSSTICKSSTICKSSTICKSSTICKSSTICKSSTICKSSTICKSSTICKS
        my$S=shift;
        0S->l( 0S->TafuB(@_) );
  - K: TafuB #c
    D: |
        my($S,$K,$B)=@_;
        my $ca = $S->W->{ca}->{K}->{$K}->{B_ki}->{ki($B)};
        if ($ca && !ca.dead) {
            return $ca;
        }
        0S->Tafu(0S->Bu($K, $B))
  - K: TB #c
    D: |
        my ($S, $K, $B) = @_;
        my $u = 0S->Bu($K, $B);
        0S->T({i=>$u});
  - K: Tafu #c
    D: |
        my($S,$uu)=@_;
        0S->fu($uu) || 0S->T({i => $uu});
  - K: Taful #c
    D: |
        my($S,$uu)=@_;
        0S->l( 0S->Tafu($uu) );
  - K: visTp_TafuBlA #c
    D: |
        my ($S, $Tp, $Bup, $A) = @_;
        my $old = 0S->visTp($Tp); # could be Fun, wire into end
        my $uu = 0S->Bu(@$Bup); 
        my $u = 0S->fu($uu);
        
        A.old ||= [] if $A;
        A.new ||= [] if $A;
        if ($u) {
            push @{A.old}, $u if $A;
        }
        else {
            push @{A.new}, $u if $A;
            $u = 0S->T({i => $uu});
        }
        
        0S->l($u);
        $T= $old;
        $u;
  - K: visTp_l_u #c
    D: |
        my ($S, $Tp, $u) = @_; #c get in to a T place and make links
        my $old = 0S->visTp($Tp);
        0S->l($u);
        $T= $old;
        $u;
  - K: l # draw arcs #c
    D: |
        my ($S, $u) = @_;
        0S->accum($u, 'Lo', T.L);
        0S->accum($T, 'o', $u);
        $u;
  - K: visTp_TafuBl # get in Tp,  #c
    D: |
        my ($S, $Tp, $Bp) = @_;
        my $old = 0S->visTp($Tp);
        my $u = 0S->TafuBl(@$Bp);
        $T= $old;
        $u;
  - K: T #c
    D: |
        my ($S, $p) = @_;
        
        # 1/9
        
        my $giu = T.i;
        my $old = 0S->visTp($p); # 1
        die "no old!".wdump($T) if !$old;
        T.i || die " no way in! ".wdump($p);
        
        0S->fu_cache(T.i);
        
        # set up this dimension - allele tower
        # maths stapler - clown shoes - RNA
        
        my $beg = T.i;
        my $sge = sub {
            die "Lost i somewhere before ".shift."... "
            .wdump(2, [$beg, T.i]) unless T.i eq $beg;
        };
        
        # 2/9
        
        say "HAUNT HAUNT HAUNT ".pint(T.i) if $S->deeby;
        #$G0->{travels_of}->{$S->{name}} ++;
        $S->ob("haunt");
        # so crawl is like an expanding awareness thing
        # see the whole structure
        
        # 3/9
         $S->w("T/flows");
           $S->w('flows_D', {}, T.i);
        $G->Flab("flows ", $T);
          $sge->("flows");
        # 4/9
        T.L = $S->W->continues($S); # %
          $sge->("humms W being"); # eg travelling sw eval
         $S->w("T/humms");
           $S->w('humms_D', {}, T.i);
        $G->Flab("humms", $T);
          $sge->("humms");
        # 5/9
        T.L.i eq T.i || die "tli not ni!?!?!";
        0S->accum(T.L.i, 'Li', T.L); # just right
        
         $S->w("T/links", {u=>T.i});
           $S->w('links_D', {}, T.i);
        $G->Flab("links", $T);
          $sge->("links");
        # rounds_D? replayable when recoded?
        # assume 6/7 will continue the process...
        # 6/9
         $S->w("T/travels");
           $S->w('travels_D', {}, T.i);
        $G->Flab("travels", $T);
          $sge->("travels");
        die "Lost i somewhere before 7... "
        .wdump(2, [$beg, T.i])unless T.i eq $beg;
        
        # 7/9
        
        $S->w("T/traction", {u=>T.i});
        $S->w('traction_D', {}, T.i);
        $G->Flab("travels", $T);
          $sge->("travels");
        
        # 8/9
        
        #Info "HAUNTED ".sw($T) if $S->{name} =~ /braid|ux|odon/;
        
        # 9/9
        
        die "Lost i somewhere before 9... "
        .wdump(2, [$beg, T.i])unless T.i eq $beg;
        
        my $L = T.L;
        $T = $old;
        die "dumb".wdump([$T, $old, $giu]) unless T.i eq $giu;
        return L.i;
  - K: visTp #c
    D: |
        my ($S, $p, $fun) = @_;
        
        my $tish = $T && (ref $T eq 'Way' || ref $T eq 'C');
        my $old = $T;
        if (!$tish) {
            $T = $S->nw();
        }
        elsif (T.G ne $S) {
            # loses hair? we never care?
            $T = $S->nw();
        }
        else {
            $T = $T->spawn;
        }
        
        $p = {i=>$p} if ref $p =~ /^(Way|C)$/;
        my $moved = p.i || p.L;
        if ($moved) {
            delete $T->{$_} for qw'i L t o';
        }
        
        $T->from($p);
        
        T.i ||= T.L.i;
        T.L ||= T.i.Li;
        T.t ||= T.L.t;
        T.o ||= T.L.o;
        T.o ||= [];
        
        if ($old) {
            T._T = $old;
            #push @{old.T_||=[]}, $T;
        }
        if (my $r = T.r) {
            if ($moved && r.ih->{T.i.id} && r.noo) {
                # recursion q factor # can rebraid things to go on forever etc.
                die "not allowed circular travel, "
                    .sw({here_before => $T});
            }
            $r = T.r = {%$r};
            r.ih = {%{r.ih||{}}};
            r.is = [@{r.is||[]}, T.i];
            r.ih->{T.i.id} = $T;
        }
        
        if (ref $fun eq "CODE") {
            return $fun->();
            $T = $old;
        }
        elsif ($fun eq "Fun") {
            push @{ $F[0]->{_after_do} }, sub { $T = $old }
        }
        return $old;
  - K: fu #c
    D: |
        my $S = shift;
        my $u = shift;
        
        my $fo = $S->W->{ca}->{K}->{u.K}->{B_ki}->{ki(u.B)};
        if ($fo && fo.dead) {
            say "u.K found but dead";
            $fo = undef;
        }
        return $fo if $fo;
        
        for my $LL (@{$S->W->{script}}) {
            my $i = LL.i;
            my $yup = $i eq $u
                || (!exists u.K || i.K eq u.K)
                && 0S->B_same($u => $i);
            if ($yup) {
               say "found i.K in script";
                return $i;
            }
        }
        return undef;
  - K: fu_cache #c
    D: |
        my $S = shift;
        my $u = shift;
        u.B ||= {};
        $S->W->{ca}->{K}->{u.K}->{B_ki}->{ki(u.B)} = $u;
  - K: fs_glob #c
    D: |
        my ($S, @globs) = @_;
        my @list;
        for my $glob (@globs) {
            push @list, grep { defined }
                grep { Hostinfo::fixutf8($_) || 1 }
                grep { -f $_ } glob $glob;
        }
        return @list;
  - K: fs_find #c
    D: |
        my ($S, @dirs) = @_;
        my @list;
        File::Find::find(sub {
            my $na = $File::Find::name;
            Hostinfo::fixutf8($na);
            next unless -f $na;

            push @list, $na;
        }, @dirs);
        return @list;
  - K: jsq #c
    D: |
        my $S = shift;
        my @a = @_;
        for (@a) {
            s/\\/\\\\/g;
            s/'/\\'/g;
            s/\n/\\n/g;
        }
        wantarray ? @a : shift @a;
  - K: B_same #c
    D: |
        my ($S, $u, $i) = @_;
        
        return 1 if exists u.B._ && exists i.B._ && u.B._ eq i.B._;
        
        my @ks = keys %{u.B};
        for my $k (@ks) {
            u.B->{$k} eq i.B->{$k} || return 0;
            next if $k eq "Codon";
        }
        unless (keys %{u.B}) {
            Say " u has no B, mind  you...".ki($u);
        }
        return 1;
  - K: Ato #c
    D: |
        my ($S, $w, $to) = @_;
        grep { _.K =~ /^$to$/ } @{w.Li.o}
  - K: Stytog #c
    D: |
        my ($S, $u, $s) = @_;
        my @styles = split /\s+/, u.styles;
        if (grep { $_ eq $s } @styles) {
            @styles = grep { $_ ne $s } @styles
        }
        else {
            push @styles, $s;
        }
        u.styles = join ' ', @styles;
        $S->w('v/ch', {u=>$u});
  - K: wayray #c
    D: |
        my ($S, $SS, $GG) = @_;
        $GG ||= $S;
        die sw(\@_) if ref ${GG} !~ /^G/;
        my $i = 0;
        for my $wS (@$SS) {
            $SS->[$i] = $GG->nw(%$wS) unless ref $wS =~ /^(Way|C)$/;
            $i++;
        }
  - K: RW #c
    D: |
        my ($S, $GG) = @_;
        say "RW RW RW RW RW GG.name\t\t GG.K";
        _.dead = $F[0] for G.U.rei->($GG, {});
        my $W = GG.W;
        delete GG.Vu; # vortex will start over
        my $deadscript = W.script;
        W.script = [];
        W.n = 0;
        delete W.ca;
        $deadscript;
  - K: delfrom #c
    D: |
        my ($S, $u) = @_;
        for my $uu (0S->Io($u)) {
            0S->del($uu);
        }
  - K: del #c
    D: |
        my ($S, $u) = @_;
        my $L = u.Li || die "wasnt";
        Say "deleting ".$u->pint;
        $S->w('v/ch'=>{u=>$u});

        0S->deaccum(u.Lo, 'o', $u);
        0S->deaccum(u.Li.W, 'script', $L);
        u.dead = 1;

        0S->del($_) for @{u.Li.o};
    
  - K: Io #c
    D: |
        my ($S, $u) = @_;
        grep { _.G eq $S } @{u.Li.o};
  - K: su #c
    D: |
        my ($S, $a) = @_;
        my $D = a.cb; 
        a.cb = sub { $G->Flab("a su top=a.top", $a); $D->(@_); };
        
        H.G->w(suRedis => $a);

