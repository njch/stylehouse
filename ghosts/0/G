
name: other stuff...
H:
  - K: head
    libglob: 'l/?.pm'
    D: |
        use UUID;
        sub wdump{Ghost::wdump(@_)}
    
  - K: new
    D: |
      $H = $H->spawn0('H');
      ___LIBGLOBETC
      
      $H->spawn0('A')->new($H); 
      
      H.G = H.A->spawn(G => 'H');
      
  - K: spawn
    D: |
      my $a = shift;
      my $u = $H->spawn0(@{a.r});
      
      say "H spawning $u";
      if (ref $u eq 'A') {
          return $u->new(a.i);
      }
      else {
          $H->spawn({i=>$u, r=>['A']});
          a.uA->An($u);
          u.A->Au(a.uA);
      }
      shift @{a.r};
      $u->new(@{a.r});
      
      
  - K: spawn0
    D: |
      my $nb = shift;
      die Ghost::sw($nb) if ref $nb;
      my $u = bless {}, $nb;
      $nb::H = $H;
      u.id = mkuid();
      $u
      
  #Hmisc #c
  - K: mkuid # H wide unique id
    style: func
    D: |
        (mkuuid() =~ /^(\w+)-.+$/)[0];
        
  - K: mkuuid # make a number bigger than the universe
    style: func
    D: |
      UUID::generate(my $i);
      UUID::unparse($i, my $s);
      $s
A:
  - K: new # link the thing A in
    D: |
      my $i = shift;
      A.i = $i;
      i.A = $A;
      
  - K: spawn # make down
    D: |
      $H->spawn({uA => $A, r=>[@_]});
      
  - K: An # link down
    D: |
      my $n = shift;
      push @{A.n}, $n;
      
  - K: Au # link up
    D: |
      my $u = shift;
      die if A.u;
      A.u = $u;
      
  - K: path
    D: |
      my $up;$up = sub {
          my $u = shift;
          return $u, $up->(u.A.u) if u.A && u.A.u && $u ne u.A.u;
      };
      my @path = reverse $up->(A.u);
      return join "/", map { ref $_ } @path;
      
      
    
C:
  - K: head
    D: |
      use base 'Way';
  - K: new
G:
  - K: head
    D: |
      use base 'Ghost';
      
  - K: new
    D: |
      my (@ways) = @_;
      G.name = join "+", @ways;
      
      G.W ||= G.A->spawn('W');
      
      $G->load_ways(@ways);
      
  - K: load_ways
    D: |
        my @ways = @_;
        G.ways ||= [];
        G.wayfiles ||= [];
        G.load_ways_count++;

        my $ldw = [];
        while (defined( my $name = shift @ways )) {
            my @files;

            my $base = "ghosts/$name";
            push @files, glob($base),
                grep { /\/\d+$/ } glob("$base/*");
            die "$base -> ".join", ", @files;

            for my $file (@files) {
                # TODO pass an If object to 0->accum
                @{G.ways} = grep { _._wayfile ne $file } @{G.ways};
                @{G.wayfiles} = grep { $_ ne $file } @{G.wayfiles};

                my $nw = $G->nw(name=>$name);
                $nw->load($file);

                if (my $inc = nw.include) {
                    for my $name (split ' ', $inc) {
                        next if grep { _.name eq $name } @{G.ways};
                        push @ways, $name;
                    }
                }

                say "G G.name w+ nw.name";
                push @{G.wayfiles}, $file;
                push @{G.ways}, $nw;
            }

            if (@files) {
                $H->watch_ghost_way($G, $name, \@files);
            }
            else {
                $H->error("No way! $name");
            }
        }

        $G->_0('_load_ways_post', {w=>G.ways});
W:
  - K: new
    D: |
      W.name = "W.A.u.i.name"; # TODO A tract mixinout naming
hooks:

  try: |
    use lib 'l';
    use H;
    my $oh = $H;
    
    my $nH = H->new();
    my $nG = $nH->spawn0( G => 'E/h' );
    
    $H = $oh;
    die sw($nH);
  any_init: |
      $G->timer(0.2,sub{waylay code;});
  code: |
    my $w = G.ways->[0];
    for my $nb (grep { /^[A-Z]$/ } keys %$w) {
        my $co = $G->anyway($nb);
        next unless $co;
        my @code = (
            join "\n",
            "package $nb;",
            "our \$H;",
            map { "use $_;" }
                "strict", "warnings", "utf8", "lib 'lib'", "feature 'say'"
        );
        my $btw = {};
        for my $ch (@$co) {
            my $D = $G->parse_babble(ch.D || ch.SD);
            
            if (ch.K eq "head") {
                ch.styles .= "bare";
                if (my $lg = ch.libglob) {
                    my @l = map { /\/(.+?)\.pm$/ } glob $lg;
                    my ($l) = $lg =~ /^(.+)\/.+?$/;
                    push @code, "use lib '$l';";
                    push @code, "use $_;" for @l;
                    btw.s.___LIBGLOBETC = join "\n",
                        map { "\$${_}::H = \$H;" } @l;
                }
            }
            
            if (ch.styles !~ /bare/) {
                $D =~ s/$_/btw.s->{$_}/seg for keys %{btw.s};
                
                # setup self
                $D = "my \$$nb = shift;\n$D" if ch.styles !~ /func/;
                
                # return self
                $D = "$D\n\$$nb"             if ch.K eq "new" || ch.SD;
                
                $D = ind('    ', $D);
                $D = "sub ch.K {\n$D\n}\n";
            }
            push @code, $D;
        }
        push @code, "'stylehouse'";
        my $file = "l/${nb}.pm";
        write_file($file, join("\n", @code));
        
        run "perl -c $file";
        
    }
    
    waylay try;

  

