
Oi:
  includome: G/way G/cis G/on
Ds:
  - K: head #c
    style: nonbabble
    D: |
      # two annoying dependencies 
      use Mojo::IOLoop::Stream;
      use Mojo::IOLoop;
      use Mojo::UserAgent;
      #use Mojo::SMTP::Client;
      use File::Path qw(make_path remove_tree);
      use Scriptalicious;  
      use File::Slurp;
      use JSON::XS;
      our $JSON = JSON::XS->new->allow_nonref;
      use YAML::Syck;
      use Data::Dumper; 
      use Storable 'dclone';
      use Carp;
      use UUID;
      
      use Time::HiRes 'gettimeofday', 'usleep';
      use List::Util qw(first max maxstr min minstr reduce shuffle sum);
      use List::MoreUtils qw(natatime uniq);
      use POSIX qw'ceil floor';
      use Math::Trig 'pi2';
      
      use HTML::Entities;
      use Unicode::UCD 'charinfo';
      use Encode qw(encode_utf8 decode_utf8 is_utf8);
      use Term::ANSIColor; 
      use File::Find;
      use feature 'switch';
      our @F; # is Ring re subs from below 
      
      our $MAX_FCURSION = 240;
      our $RADIAN = 1.57079633;
      our $NUM = qr/-?\d+(?:\.\d+)?/;
      
      # going...
      our $db = 0;
      our $gp_inarow = 0;
      our $swdepth = 5;
      our $G0;
      our $Ly;
      our $_ob = undef;
      
      
      # ^ curves should optimise away, accord ion
      
      # to dry up
        
        
  - K: ddump #c
    style: func
    D: |
      my $thing = shift;
      my $ind;
      return
          join "\n",
          grep {
              1 || !( do { /^(\s*)hostinfo:/ && do { $ind = $1; 1 } }
              ...
              do { /^$ind\S/ } )
          }
          "",
          grep !/^       /,
          split "\n", Dump($thing);
  - K: wdump #c
    style: func
    D: |
      my $thing = shift;
      my $maxdepth = 3;
      if (@_ && $thing =~ /^\d+$/) {
          $maxdepth = $thing;
          $thing = shift;
      }
      $Data::Dumper::Maxdepth = $maxdepth;
      my $s = join "\n", map { s/      /  /g; $_ } split /\n/, Dumper($thing);
      $s =~ s/^\$VAR1 = //;
      $s =~ s/^    //gm;
      $s;
  - K: new #c
    D: |
      my (@ways) = @_;
      G.way = join "+", @ways;
      G.name = G.way;
      
      my $ui = G.A.u.i;
      wish(G => $ui) || $ui eq $H || die "not G above? G.name ".$ui->pi;
      G.A->umv('', 'G');
      my $h = H.G;
      $h ||= $G if G.name eq 'H'; # TODO G.K
      $h || die "nogh";
      G.A->umk($h, 'Gs');
      
      
      $G->load_ways();
      
  - K: gp #c 
    style: func
    D: |
      my $u = shift;
      return $u->pi if ref $u && ref $u ne 'HASH' && ref $u ne 'CODE'
          && ref $u ne 'ARRAY' && $u->can('pi');
      gpty($u);
      
  - K: sw #c
    style: func
    D: |
      return warn "BEFORE SWA" if !H.swa;
      return H.swa->(@_);
 
  - K: saycol #c sayyl sayre sayg saygr saybl TODO TODO
    style: func
    D: |
        my $colour = shift;
        if ($colour eq "bright_yellow" && $db) {
            my $D = $F[0];
            my $ind = join"", ("  ")x@F;
            say "$ind D.G.name:D.G.K D.id:D.K   D.point";
        }
        print colored(join("\n", @_,""), $colour);
        wantarray ? @_ : shift @_
  - K: sayyl
    style: func
    D: |
        saycol(bright_yellow => @_)

  - K: sayre
    style: func
    D: |
        saycol(red => @_)

  - K: sayg
    style: func
    D: |
        saycol(bright_green => @_)

  - K: saygr
    style: func
    D: |
        saycol(green => @_)

  - K: saybl
    style: func
    D: |
        saycol(bright_blue => @_) 
    
  - K: pi #c
    D: |
      join ' ', grep{defined} "G", G.K, G.name
  
  - K: pint #c
    style: func
    D: |
        my $w = shift; 
        $w && ref $w eq "Way" ? $w->pint : "ww:".join"",map { s/\s//sg; $_ } wdump(2,$w)
   
  - K: ghostlyprinty #c gone ish
    style: func
    D: |
        $gp_inarow++;
        my $witcolour = sub { '<t style="color:#'.($_[1] || '8f9').';">'.shift.'</t>' };
        my $nohtml;
        if ($_[0] && $_[0] eq "NOHTML") {
            shift;
            $nohtml = 1;
            $witcolour = sub { shift };
        }
        
        my @t = @_;
        my @s;
        for my $t (@t) {
            if ($t && ref $t eq "ARRAY") {
                if ($gp_inarow > 5) {
                    push @s, "ghostlyprinty recursion!";
                    next;
                }
                push @s, map { "[".ghostlyprinty(($nohtml?("NOHTML", $_):($_))) } @$t;
            }
            elsif (ref $t eq 'HASH') {
                push @s, '%{';
                if (3 == grep { $_ =~ /^(.+)\t(.+?)$/ } 
                    (shuffle keys %$t)[0,1,2]) {
                    push @s, "st%le";
                }
                if (t.name) {
                    push @s, "name=t.name";
                }
                if (t.r) {
                    push @s, "r=t.r";
                }
                if (t.bb) {
                    push @s, "* ".scalar(keys %$t);
                }
                if (@s == 1) {
                    push @s, slim(200, ki($t));
                }
                push @s, '}%';
            }
            elsif (ref $t) {
                push @s, $witcolour->(ref($t), "333;font-size:50%");
                my $name = gname($t);
                push @s, $witcolour->($name);
            }
            else {
                push @s, (defined $t ? $t : "~")
            }
        }
        $gp_inarow--;
        join "  ", @s
        
  - K: pty #c
    style: func
    D: |
        my $t = shift;
        ref $t eq "Way" ? pint($t) : gpty($t)
        
  - K: gpty #c
    style: func
    D: |
        ghostlyprinty('NOHTML',@_)
  
  - K: gname #c goner? 
    D: |
        my $g = shift;
        my $si = shift || 0;
        my $ush = "$g";
        my $may = $g->{name} || $g->{K} || $g->{id} if ref $g && $ush =~ /HASH/;
        $may ||= (0+keys %$g)."{" if ref $g eq "HASH";
        $may ||= "$g";
        $may =~ s/^(\w+)=HASH.*$/$1\{/;
        $may;
   
  - K: cgp #c heartache
    D: |
      my $u = shift;
        my $c = {};
        if (!defined $u){
            c.undef = 1;
        } else {
            if (my $ref = ref $u) {
                c.ARRAY = 1 if $ref eq "ARRAY";
                c.HASH = 1 if $ref eq "HASH";
                c.CODE = 1 if $ref eq "CODE";
                c.canpi = 1 if !%$c && $u->can('pi');
                for (qw'A C G T     R   J') {
                      $c->{$_} = 1 if $ref eq $_;
                }
                c.ref = $ref;
            }
            else {
                if (ref \$u eq 'SCALAR') {
                    c.text = 1;
                    c.len = length($u);
                    c.lin = scalar split /\n/, $u;
                    c.b = scalar split /\n\n/, $u;
                    c.number = $u =~ /^(?:\d+\.)?\d+$/;
                    c.wordy = $u =~ /\w+/;
                }
                else { die "wtf is $u" };
            }
        }
        $c
  - K: ob #c make lookee
    D: |
      my $ob = G._ob || $_ob || return;
      
      my $s = $G->pyramid(@_);
      
      my $te = $@; $@ = "";
      my $to = $_ob; $_ob = undef;

      $ob->w(ob=>{s=>$s});

      $_ob = $to;
      $@ = $te;
  - K: Gf #c
    D: |
        my $way = shift;
        my $Gs = [map{_.i}@{H.G.A.n_Gs}];
        
        my @GGs = grep { _.K eq $way } @$Gs;
        if (!@GGs) {
            # never did much of this but from before was like
            @GGs = grep { _.way =~ /$way/ } @$Gs;
              # which complicates as vague:
            #sort { length($a->{way}) <=> length($b->{way}) } # cerated
        }
        
        wantarray ? @GGs : shift @GGs;
  - K: HGf #c
    style: func
    D: |
      H.G->Gf(@_)


  - K: ki #c
    style: func
    D: |
      my $ar = shift;
      my $re = $ar if $ar =~ /^\d+$/;
      $ar = shift if defined $re;
      my $d = 1 + shift;
      if (!ref $ar || "$ar" !~ /(ARRAY|HASH)/) {
          return "!%:$ar";
      }
      my $lim = 150 - (150 * ($d / 3));
      join ' ', map {
          my $v = $ar->{$_};
          $v = "~" unless defined $v;
          ref $v eq 'HASH'
              ? "$_=".($re ?  "{ ".slim($lim,ki($re-1, $v,$d))." }" : gp($v))
          ref $v eq 'ARRAY'
              ? "$_=@x".@$v
              : "$_=".slim(150,"$v")
      } sort keys %$ar;
  - K: k2 #c
    style: func
    D: |
      ki 1, shift;
  - K: unico #c
    style: func
    D: |
      my ($int, $wantinfo) = @_;
      my $h = sprintf("%x", $int);
      my @s = eval '"\\x{'.$h.'}"';
      push @s, charinfo($int) if $wantinfo;
      wantarray ? @s : shift @s
      
  - K: hexend #c
    style: func
    D: |
      $_[0] =~ /([0-f])?([0-f])?([0-f])?$/;
      map { hex($_) } $1, $2, $3;
  - K: hexbe #c not g
    style: func
    D: |
      my@h = map { sprintf('%x', int($_)) } @_;
      wantarray ? @h : join'',@h;
       
  - K: hitime #c
    style: func
    D: |
      return join ".", gettimeofday();
      
  - K: flatline #c
    style: func
    D: |
      map { ref $_ eq "ARRAY" ? flatline(@$_) : $_ } @_
    
  - K: recur #c
    D: |
        Mojo::IOLoop->recurring(@_);
  - K: wish #c
    style: func
    D: |
      my $w = shift;
      my $i = shift;
      $w eq "W" ? ref $i eq "Wormhole" || ref $i eq "W" :
      $w eq "w" || $w eq "C" ? ref $i eq "Way" || ref $i eq "C" :
      $w eq "G" ? ref $i eq "Ghost" || ref $i eq "G" : die "wish $w $i";

  - K: sing #c sing ing ingo
    D: |
        my $p;
        p.name = G.id."/".shift;
        p.code = shift;
        $p = {%$p, @_};
        my $name = p.name;
        my $code = p.code;
        
        my $si = H.G.singing ||= {};
        return if $si->{$name} && $si->{$name}++;
        $si->{$name} = 1;
        
        my $after = p.block || p.again || 0.2;
        my $init = p.begin || 0.001;
        
        $G->timer($init, sub {
        
            $G->timer($after, sub {
                my $splatter = delete $si->{$name};
                if ($splatter > 1 && p.again) {
                    sayre "Gsing $splatter again! $name";
                    $G->sing($name, $code, %$p);
                }
            }, "sing-block        $name");
            
            $si->{$name} = 1;
            $code->();
        }, "pre-sing     $name");
  - K: ing #c puts teeth along the wave that ingo unifies into doing, batching...
    D: |
        my ($time, $ing, $w) = @_;
        $time && $ing || die " time&ing";
        
        my $name = $ing;
        $name .= $w->pint if $w;
        my $ingw = $G->nw(
            K=>"ing",
            name => $name,
            ing => $ing,
            time => $time,
        );
        say "create ingw.G.name ingw.name $time";
        ingw.w = $w if $w;
        my $inga = G.ing->{$name} ||= {};
        _.dead = 1 for values %$inga;
        $inga->{ingw.id} = $ingw;
        0->ingo($ingw);
    
  - K: ingo #c
    D: |
        my ($ingw) = @_;
        return say "ing ingw.name ingw.id deduped" if ingw.dead;
        return say "ing ingw.name ingw.id ui dead" if ingw.w && ingw.w.dead;
        
        $G->w(ingw.ing, {}, ingw.w);
        
        my $time = ingw.w.e if ingw.w && ingw.w.e;
        $time ||= ingw.time;
        say "time ingw.G.name ingw.name $time";
        $G->timer($time, sub {
            0->ingo($ingw);
        }, "ing ingw.name ingw.id");
  - K: ip #c TODO Tish/R maths logics, heat mapping, see also CsK vortex reading
    D: |
        my ($ip, $i) = @_;
        my $pass = 1;
        for my $I (keys %$ip) {
            !ref $ip->{$I} && $ip->{$I} ne $i->{$I} && $pass--;
            ref $ip->{$I} eq 'HASH' && do {
                if (my $not = $ip->{$I}->{not}) {
                    $not eq 'def' && do {
                        defined $i->{$I} && $pass--;
                    } 
                    || $not eq $i->{$I} && $pass--;
                }
                else {
                    $ip->{$I}->{$i->{$I}} eq '1' || $pass--;
                }
            };
            
        }
        $pass == 1
  - K: fs_glob #c
    D: |
        my (@globs) = @_;
        my @list;
        for my $glob (@globs) {
            push @list, grep { defined }
                grep { $H->fixutf8($_) || 1 }
                grep { -f $_ } glob $glob;
        }
        return @list;
  - K: fs_find #c
    D: |
        my (@dirs) = @_;
        my @list;
        File::Find::find(sub {
            my $na = $File::Find::name;
            $H->fixutf8($na);
            return unless -f $na;

            push @list, $na;
        }, @dirs);
        return @list;
  - K: mkuid #c H wide unique id
    style: func
    D: |
        (mkuuid() =~ /^(\w+)-.+$/)[0]
        .H.sdghih++
        
  - K: mkuuid # make a number bigger than the universe
    style: func
    D: |
      UUID::generate(my $i);
      UUID::unparse($i, my $s);
      $s
    

