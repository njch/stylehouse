
name: other stuff...
A:
  - K: new
  
C:
  - K: new
G:
  - K: head
    D: |
      use base 'Ghost';
      use feature 'say';
      
  - K: new
    D: |
      my ($name, $O, @ways) = @_;
      
      G.GGs = [];
      G.O = $O; # TODO A
      
      G.W ||= $G->A('W') || die "no Wormhole?";

      my $way = join ", ", @ways;
      G.name = "$name`($way)";
      G.way = $way;
      say "Ghost named G.name";
      
      $G->load_ways(@ways);

      push @{G.O.GGs}, $G if ref G.O =~ /^G/;
  
  - K: A
    de: |
      tractory, making perl objects from Ghost
      H pretends to be A singularity to boot
    D: |
      my $nb = shift;
      my $u = bless {}, $nb;
      $nb::H = $H;
      G.A->t($u) if G.A; # installs u.A
      $H->intro->($u); # which replaces that
      delete u.hostinfo;
      $u->new(@_);
W:
  - K: head
    D: |
      use Set::Object 'set';
  - K: new
    D: |
      W.name = W.A.O.name;
      W.s = set();
hooks:
  any_init: |
    my $w = G.ways->[0];
    for my $nb (grep { /^[A-Z]$/ } keys %$w) {
        my $co = $G->anyway($nb);
        next unless $co;
        my @code = (
            join "\n",
            "package $nb;",
            "our \$H;",
            map { "use $_;" }
                "strict", "warnings", "utf8", "lib 'lib'"
        );
        for my $ch (@$co) {
            my $D = $G->parse_babble(ch.D);
            ch.styles .= "bare" if ch.K eq "head";
            unless (ch.styles =~ /bare/) {
                $D = "my \$$nb = shift;\n$D" unless ch.styles =~ /func/;
                $D = "$D\n\$$nb"              if ch.K eq "new";
                $D = ind('    ', $D);
                $D = "sub ch.K {\n$D\n}\n";
            }
            push @code, $D;
        }
        push @code, "'stylehouse'";
        my $file = "l/${nb}.pm";
        write_file($file, join("\n", @code));
        
        run "perl -c $file";
        
    }

