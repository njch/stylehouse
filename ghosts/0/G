
Ds:
  - K: head #c
    style: nonbabble
    D: |
      sub wdump { H::wdump(@_) };
      use YAML::Syck;
      use Scriptalicious;
      our $swdepth = 5;
      our $T; # allele tower... not like so, again R above
      our @F; # is Ring re subs from below 
      our $G0;
      # ^ curves should optimise away, accordion
      
      #c to dry up
        use File::Slurp;
        use JSON::XS;
        use YAML::Syck;
        use HTML::Entities;
        use List::Util qw(first max maxstr min minstr reduce shuffle sum);
        use List::MoreUtils 'uniq';
        sub ddump { Hostinfo::ddump(@_) }
        sub wdump { Hostinfo::wdump(@_) }
        sub htmlesc { encode_entities(shift) }
        sub findO { my ($k, $o) = @_; grep { $_->{O} eq $k } @$o }
        sub slim { my ($f,$t,$c) = @_; $c = ($c=~/^(.{$t})/s)[0]."..." if length($c) > $f; $c }
        sub enc { encode_entities(shift) }
        sub ind { "$_[0]".join "\n$_[0]", split "\n", $_[1] }
        sub shtocss { 
            my $s = shift;
            return join "", map { "$_:$s->{$_};" } sort keys %$s if ref $s eq "HASH";
            return join ";", @$s if ref $s eq "ARRAY";
            return $s
        };
        use Carp 'confess';
        use Term::ANSIColor; 
        use File::Find;

        our @Flab;
        our $Ly;
        our $db = 0;
        our $_ob = undef;
        our $MAX_FCURSION = 140;
        our $NUM = qr/(?:(\d+(?:\.\d+)?) )/;
        our $HASHC = "#"."c";
        
        sub Flab { #c to dry
            my $G = shift;
            wish(G=>$G) || die "send G";
            say join("", "$G->{db} + $db", ("_") x scalar(@F))."$G->{name}  $_[0]"
                if $G->deeby && $_[0] !~ /^\w Error/;
            $G->ob(@_);
            my $s = $G->pyramid(@_);
            unshift @Flab, $s;
            $s->{Flab} = [@Flab];
            $s;
        }
        sub fla {
            $F[0]->{G}->Flab(@_);
        }
        sub deeby {
            shift->{db} + $db > 0
        }

        sub gname {
            my $g = shift;
            my $si = shift || 0;
            my $ush = "$g";
            my $may = $g->{name} || $g->{K} || $g->{id} if ref $g && $ush =~ /HASH/;
            $may ||= (0+keys %$g)."{" if ref $g eq "HASH";
            $may ||= "$g";
            $may =~ s/^(\w+)=HASH.*$/$1\{/;
            $may;
        }
        sub pint { 
            my $w = shift; 
            $w && ref $w eq "Way" ? $w->pint : "ww:".join"",map { s/\s//sg; $_ } wdump(2,$w)
        }
        sub mess {
            my $G = shift;
            $H->{G}->w(mess => {what => shift, thing => shift});
        }
        our $gp_inarow = 0;
        sub ghostlyprinty {
            $gp_inarow++;
            my $witcolour = sub { '<t style="color:#'.($_[1] || '8f9').';">'.shift.'</t>' };
            my $nohtml;
            if ($_[0] && $_[0] eq "NOHTML") {
                shift;
                $nohtml = 1;
                $witcolour = sub { shift };
            }
            
            my @t = @_;
            my @s;
            for my $t (@t) {
                if ($t && ref $t eq "ARRAY") {
                    if ($gp_inarow > 5) {
                        push @s, "ghostlyprinty recursion!";
                        next;
                    }
                    push @s, map { "[".ghostlyprinty(($nohtml?("NOHTML", $_):($_))) } @$t;
                }
                elsif (ref $t) {
                    push @s, $witcolour->(ref($t), "333;font-size:50%");
                    my $name = gname($t);
                    push @s, $witcolour->($name);
                }
                else {
                    push @s, (defined $t ? $t : "~")
                }
            }
            $gp_inarow--;
            join "  ", @s
        }
        sub pty { my $t = shift; ref $t eq "Way" ? pint($t) : gpty($t) }
        sub gpty { ghostlyprinty('NOHTML',@_) };
        sub timur { #c
            if ($G0) {
                $G0->timer(@_);
            }
            else {
                $H->timer(@_);
            }
        }
        sub timer {
            my $G = shift;
            my $time = shift || 0.001;
            my $doing = shift;
            my $st = " ".$_[0] if $_[0] && !ref $_[0];
            $st ||= "";
            my $last = $G->Flab("G Timer$st", @_);
            
            my $doings;
            $doings = sub { $G->comeback($last, $doings, $doing, @_); };
            Mojo::IOLoop->timer( $time, $doings );
            return $last
        }
        sub comeback {
            my $G = shift;
            my $last = shift;
            my $doings = shift;
            my $doing = shift;
            my @saying = @{ $last->{thing} };
            $saying[0] =~ s/G Timer/G remiT/ || unshift @saying, "G remiT";
            my ($u, $s) = $G->waystacken(@saying, @_);
            $s->{doings} = $doings;
            $s->{timer_from} = $last;
            $last->{timer_back} = $s;
            eval { $doing->(); };
            # start serving code and stuff through H/0!
            $u->();
            if ($@) {
                $@ =~ s/^(!   )+Z\n//sgm;
                sayre(ind("Error ", $@));
            }
        }
        sub F_delta {
            my $G = shift;
            my $now = $H->hitime();
            my $then = $F[0]->{hitime};
            #$H->error("F_delta shows $now < $then;", $F[0]) if $now < $then;
            my $d = sprintf("%.3f",$now-$then);
            $d = $d<1 ? ($d*1000).'ms' : $d.'s';
        }
        sub inter {
            my $thing = shift;
            my $ki = ki($thing);
            $ki =~ s/^\s+//;
            $F[1]->{inter} ||= ".";
            $F[1]->{inter} .= "\n -{".$ki."}\n";
        }
        sub crankFun {
            my ($G,$dial) = @_;
            my $origin = $G->{$dial};
            # so a synapse would snake through something...
            # directly looking at a concept and exuding its energy pathway
            
            $G->Flab("crankFun", ($G->{$dial} = shift), $origin);
            
            push @{ $F[0]->{_after_do} }, sub { $G->{$dial} = $origin };
            return
        }
        sub crank {
            my ($self,$dial) = @_;
            my $original = $self->{$dial};
            my $uncrank = sub { $self->{$dial} = $original };
            $self->{$dial} = shift;
            return $uncrank;
        }
        sub way_was {
            my $G = shift;
            my $what = shift;
            my $lt = $F[0]->{thing};
            $lt->[0] eq "D" && $lt->[1] eq $what
        }
        sub haunt { # arrives through here #c
            my $G = shift;
            my $unT = shift;
            my $p = {
              depth => shift,
              t => shift,
              i => shift,
            };
            return $G->_0("0->T", $p);
        }
        sub chains {
            my $G = shift;
            return @{$G->{chains}} if $G->{chains};
            grep { !$_->{_disabled} }
            map { @{$_->{chains}||[]} } $G->ways
        }
        sub allchains {
            my $self = shift;
            map { @{$_->{chains}||[]} } $self->ways
        }
        sub unrush {
            my $self = shift;
            my $point = shift;
            unless ($self->{_unrush}->{$point}) {
                $self->timer(0.2, sub {
                    $self->{_unrush}->{$point} = 2;
                    $self->w($point);
                }, "unrush $point");
                $self->{_unrush}->{$point} = 1
            }
            $self->{_unrush}->{$point} == 2
            
            && delete $self->{_unrush}->{$point}
        }

        sub ways {
            my $self = shift;
            
            grep { !$_->{_disabled} } @{$self->{ways}}
        }
        sub styles {
            my ($G, $styles) = @_;
            
            my @styles;
            for my $style (split ' ', $styles) {
                push @styles,
                    join "", map { /;$/ ? $_ : "$_;" } $G->w("styles/$style");
            }
            join ' ', @styles;
        }
        sub findway {
            my $G = shift;
            my $point = shift;
            my @w = grep { defined $_ } map { $_->find($point) } $G->ways;
            wantarray ? @w : shift @w;
        }
        sub anyway {
            my $G = shift;
            my $point = shift;
            my @a = grep { defined $_ } map { $_->find($point, 1) } $G->ways;
            wantarray ? @a : shift @a
        }
        sub throwlog {
            my $what = shift;
            $H->{G}->w(throwlog => {what => $what, thing => [@_]});
        }
        sub susgdb {
            my $G = shift;
            my $t = $db;
            push @{$F[0]->{_after_do}}, sub { $db = $t };
            $db = -2;
        }

        my %D_cache;
        sub dooftip {<<""; #c
             .-'''-.     
           '   _    \   
         /   /` '.   \  
        .   |     \  '  
        |   '      |  ' 
        \    \     / /  
         `.   ` ..' /   
            '-...-'`    

        }
        sub grep_chains {
            my $self = shift;
            my %s = @_;
            my @go;
            for my $c ($self->chains) {
                while (my ($k, $v) = each %s) {
                    if ((!$k || exists $c->{$k}) && (!$v || $c->{$k} =~ $v)) {
                        push @go, $c;
                    }
                }
            }
            return @go;
        }
  - K: new #c
    D: |
      my (@ways) = @_;
      G.way = join "+", @ways;
      G.name = G.way;
      
      G.GGs = [];
      my $ui = G.A.u.i;
      wish(G => $ui) || $ui eq $H || die "not G above? G.name ".$ui->pi;
      G.O = $ui;
      push @{ui.GGs}, $G;
      push @{H.G.GGs}, $G unless $ui eq H.G;
      
      
      #$G->timer(1, sub {sw(G.A.u.u.i)}) if G.way =~ /ux/;
      
      G.W ||= G.A->spawn('W');
      
      
      $G->load_ways(@ways);
  - K: gp #c
    style: func
    D: |
      my $u = shift;
      return $u->pi if ref $u && ref $u ne 'HASH' && ref $u ne 'CODE'
          && ref $u ne 'ARRAY' && $u->can('pi');
      gpty($u);
  - K: sw #c
    style: func
    D: |
      my $stuff = wdump($G::swdepth, @_>1?\@_:@_);
      return say "too early rto publich" if ! H.r;
      H.r->publish('sw', $stuff);
      say "published wdump to sw from   $G::swdepth x ".length($stuff);
  
  - K: pi #c
    D: |
      "G ".G.name;
  
  - K: di #c
    style: func
    D: |
      # line the F that is blowing up with intel
      # then die to throw back to $G->D
      # which always stack traces with sig die handler
      # and starts sucking error styles, die-ing all the way up the F train
      # anything else we should want to die with gets added here
      # @_ is:
      #   bunch of numbers can show patterns to escape style like
      #   everything else passed into F.di.tip[
      my @vec;
      push @vec, shift while $_[0] =~ /^[\.\d]+$/;
      my $a = $F[0]->{di} = {};
      (a.mag, a.dir, a.etc) = @vec;
      a.tip = [@_];
      die @_;
      
      
      
  - K: w #c
    style: nonbabble
    D: |
      my $point = shift; 
      my $ar = shift;
      my $Sway = shift;
      my @ways;

      die "What do you MEAN $G->{name} $point $ar $Sway !?  ".wdump($ar) if defined $ar && ref $ar ne "HASH";
      my $talk = "w $point";
      my $watch;

      if ($Sway) {
          $talk .= " S";
          if (ref $Sway eq 'Ghost' || ref $Sway eq "G") {
              @ways = $Sway->ways;
              $talk .= " G";
          }
          elsif (ref $Sway eq 'Way' || ref $Sway eq "C") {
              if ($Sway->{ofways}) {
                  @ways = @{$Sway->{ofways}};
              }
              elsif ($Sway->{Gw}) {
                  my $SG = $Sway->{G} || die "no Sway G!?";
                  my $CodeK = $Sway->{Gw};
                  $CodeK = $Sway->{K} if $CodeK eq "1";
                  $point = "$CodeK/$point" unless $point =~ /^$CodeK/;
                  if ($G eq $SG) {
                      @ways = $G->ways; # ------------------
                  }
                  else {
                      return $SG->w($point, $ar, $Sway); # G pass
                  }
              }
              else {
                  @ways = $Sway; #---------------------
              }
          }
          elsif (ref $Sway eq 'ARRAY') {
              die "NO MORE ARRAY WAYS --- $point ".slim(100,80,ki($ar))."\n"."$Sway - ".ki($Sway);
          }
          my $b = {};
          %$b = (%{$Sway->{B}}, B => $Sway->{B}) if $Sway->{B};
          $ar = {%$ar, %$b, S => $Sway};
          $ar->{S} = $G->{S} if $G->{S};
      }
      else {
          @ways = $G->ways;
      }

      my @returns;
      for my $w (@ways) {
      
          my $h = $w->find($point) || next;
          
          my $u = $G->waystacken(Z => "$talk", $G, $w, $Sway, bless {h=>$h}, 'h');
          my ($Z) = @F;
          my $r;

          eval { $r = [ $G->D($h, $ar, $point, $Sway, $w, $Z) ] };

          push @returns, $r;
          my $ZZ = $u->();
          die "MISM" unless $Z eq $ZZ;
          $Z->{Returns} = $r;

          if ($@) {
              my $ne = "Z";
              $ne .= $Z->{inter} if $Z->{inter};
              $ne .= "\n";
              $ne .= "S: ".ki($Sway)."\n" if $Sway;
              $ne .= "$@";
              $@ = $ne;
              $G->Flab("Z Error $@");
              die $@;
          }
      }
      unless (@returns) {
          $G->Flab("way miss $talk", \@ways, $Sway) if $G->deeby > 3;
      }
      return warn "Multiple returns from ".($point||'some?where')
                              if @returns > 1;    
      return
                              if @returns < 1;
      my @return = @{$returns[0]};
      if (wantarray) {
          return @return
      }
      else {
          my $one = shift @return;
          return $one;
      }
      
      
  - K: D #c
    style: nonbabble
    D: |
           
            my $babble = shift;
            my $ar = shift || {};
            my $point = shift;
            my $Sway = shift;
            my $w = shift;
            my $Z = shift;
            die "RECURSION ".@F if @F > $MAX_FCURSION;
            
            my $ksmush = join",",sort keys %$ar;
            
            
            if (ref $babble eq "C") {
                my $b = $babble;
                die unless $b->{K} eq "Disc";
                my $d = $b->{Dish};
                return $d->{G}->w('D', $ar, $d);
            }
            
            my $br = $babble;
            $br =~ s/\n//sg;
            my $uuname = "$G->{id} ".$H->dig($br)
                ." ".($point||"")." arar=".$ksmush;
                
            my $ha = $H->dig($uuname);
            die unless length($ha) == 40;
            
            $G->Flab(join("   ", '☺', ($point ? "w $point" : "⊖ $babble"), "$ksmush"));
            
            my $Ds = $D_cache{$ha};
            unless ($Ds) {
                my $eval = $G->parse_babble($babble, $point);
                my $download = $ar?join("", map { 'my$'.$_.'=$ar->{'.$_."}; " } keys %$ar):"";
                $download .= 'my $thing = $T->{t}; ' unless !exists($T->{t}) || $ar->{thing};
                $download .= 'my $O = $G->{O}; ' unless $ar->{O};
                my $upload = $ar?join("", map { '$ar->{'.$_.'}=$'.$_."; "    } keys %$ar):"";
                
                my @warnings = ("no warnings 'experimental';");
            
                my $sub = "bollox";
                
                my $evs = '$sub = sub { my $ar = shift; '.
                                        "@warnings $download\n".
                                        
                    "my \@doo_return = (sub { \n\n$eval\n })->();\n"
                    
                                        ."$upload"
                .'return @doo_return };';
                
                eval $evs;
                
                $Ds = [ $evs, $sub ];
                if (!$@ && ref $sub eq "CODE") {
                    $D_cache{$ha} = $Ds;
                }
            };
            my ($evs, $sub) = @$Ds;
                
            my $back = $G->waystacken(D => $point, $G, $ar, $Sway, $w);
            
            my $komptalk = $@ ? "nicht kompilieren! nicht kompilieren!\n" : "";
            
            $H->{sigstackend} ||= sub {
                local $@;
                eval { confess( '' ) };
                my @stack = split m/\n/, $@;
                shift @stack for 1..3; # hide above this sub, G eval & '  at G...';
                my @stackend;
                push @stackend, shift @stack until $stack[0] =~ /G::D/ || !@stack && die;
                s/\t//g for @stackend;
                
                push @{$F[0]->{SigDieStack}||=[]}, \@stackend;
            };
            
            my @return;
            if (ref $sub eq "CODE" && !$@) {
                local $SIG{__DIE__} = $H->{sigstackend};
                eval { @return = $sub->($ar) }
            }
            
            my $D = $back->();
            $D->{Returns} = [@return];
            
            if ($@) { #     DOO DOO #c
                my ($x) = $@ =~ /line (\d+)/;
                $x = $1 if $@ =~ /syntax error .+ line (\d+), near/;
                my $file = $1 if $@ =~ /at (\S+) line/;
                undef $file if $file && $file =~ /\(eval \d+\)/;
                undef $file if $file && !-f $file;
                my $perl = $H->slurp($file) if $file;
                $perl ||= $evs;
                
                my $eval = "";
                $eval .= "$file\n" if $file;
                my @eval = split "\n", $perl;
                my $xx = 0;
                $x -= 3 if $x;
                shift @eval for 1..3;
                pop @eval for 1..3;
                my $whole = @eval < 20;
                for (@eval) {
                    $xx++;
                    
                        if (!defined $x) {
                            $eval .= ind("⊘  ", $_)."\n"
                        }
                        elsif ($xx == $x) {
                            $eval .= ind("⊘  ", $_)."\n";
                            my $bab = (split"\n",$babble)[$x -1];
                            if ($bab ne $_) {
                                $eval .= ind("⊖r ", $bab)."\n";
                            }
                        }
                        elsif (!$whole && $xx > $x-5 && $xx < $x+5) {
                            $eval .= ind("|  ", $_)."\n"
                        }
                        elsif ($whole) {
                            $eval .= ind("|  ", $_)."\n"
                        }
                }
                my $DOOF; 
                my $first = 1 unless $@ =~ /DOOF/;
                
                $DOOF .= "DOOF ".sprintf("%-24s", $G->{name}." ".($ar->{S} ? "S=".gpty($ar->{S}) :""));
                $DOOF .= " w $point  ".join(", ", keys %$ar)."\n";;
                if ($first) {
                    if (exists $D->{SigDieStack}) {
                        warn "MALTY SIGGI" if @{$D->{SigDieStack}} > 1;
                        $DOOF .= "\n";
                        my $i = "  ";
                        for my $s ( reverse flatline($D->{SigDieStack}) ) {
                            $DOOF .= "$i- $s\n";
                            $i .= "  ";
                        }
                    }        
                    $DOOF .= "\n$eval\n";
                }
                $DOOF .= ind("E    ", "\n$komptalk$@\n\n")."\n\n"     if $first;
                $DOOF .= ind("!   ", "$@")."\n"             if !$first;
                $DOOF .= ind("ar  ",wdump(1,$ar))             if $first;
                #$DOOF .= dooftip()                         if $first;
                
                my $OOF = $G->Flab("D Error $@", $DOOF, $D);
                if ($first) {
                    #$H->error($OOF);
                }
                $D->{Error} = $DOOF;
                $@ = $DOOF;
                die "$@";
            }
            
            return wantarray ? @return : shift @return

  - K: nw #c G ways
    D: |
      my $C = G.A->spawn('C');  
      
      $C->from({@_}) if @_;
      # etc
      $C 
      
  - K: load_ways #c
    D: |
        my @ways = @_;
        G.ways ||= [];
        G.wayfiles ||= [];
        G.load_ways_count++;

        my $ldw = [];
        while (defined( my $name = shift @ways )) {
            my @files;

            my $base = "ghosts/$name";
            push @files, $base if -f $base;
            push @files, grep { /\/\d+$/ }
                map { Hostinfo::fixutf8($_) } glob("$base/*");

            for my $file (@files) {
                # TODO pass an If object selector to 0->deaccum
                @{G.ways} = grep { _._wayfile ne $file } @{G.ways};
                @{G.wayfiles} = grep { $_ ne $file } @{G.wayfiles};

                my ($wn) = $file =~ /ghosts\/(.+)$/;
                $wn ||= $file;
                my $nw = $G->nw(name=>$wn);
                $nw->load($file);

                if (my $inc = nw.include) {
                    for my $name (split ' ', $inc) {
                        next if grep { _.name eq $name } @{G.ways};
                        push @ways, $name;
                    }
                } 

                say "G G.name w+ nw.name";
                push @{G.wayfiles}, $file;
                push @{G.ways}, $nw;
            }
            
            G.name =~ s/\+$name// && warn "no wayfiles from $name" || die
            unless @files; # ^ dies if was first way name
        }

        $G->_0('_load_ways_post', {w=>G.ways});
  - K: wayb #c # TODO way smushing
    D: |
      my ($GG, $atu) = @_;
      my $suway = join "", map {"{$_"} split /\//, atu.way;
      G.R->loadup($atu, "{hooks$suway", $atu);
      
      
      push @{GG.ways}, $atu; # A etc
      
  - K: ob #c make lookee
    D: |
      my $ob = G._ob}||$_ob||return;
      
      my $s = $G->pyramid(@_);
      
      my $te = $@; $@ = "";
      my $to = $_ob; $_ob = undef;

      $ob->w(ob=>{s=>$s});

      $_ob = $to;
      $@ = $te;
  - K: Gf #c
    D: |
        my $way = shift;
        # TODO $G or $S etc A 
        my @GGs =
          #sort { length($a->{way}) <=> length($b->{way}) } # cerated
          grep { $_->{way} =~ /$way/ } @{ $G->{GGs} };
        
        wantarray ? @GGs : shift @GGs;
  - K: HGf #c
    D: |
      H.G->Gf(@_)
  - K: W #c
    D: |
      G.W
  - K: pyramid #c
    D: |
      my $thing = [@_];
      
      my $u;
      my ($last) = @F;
      $u = last.A->spawn('C') if $last;
      $u ||= G.A->spawn('C');
      # TODO ^ set A u words to 'pyramid'
      
      my $stack = $H->stack(2,12);# short
      
      my $from; # FUZZ!
      if ($stack->[0] =~ /G::timer/) {
          $from = "time"
      }
      elsif ($stack->[1] =~ /G.+eval.+/
          && $stack->[2] =~ /G::doo/) {
          $from = "some doing..."
      }
      else {
          ($from) = $stack->[0] =~ / (\S+::\S+) /;
          $from =~ s/.*G::(Fl|wa).*/$1/ && do {
              $from =~ s/^wa$/_ᣝ/ ||
              $from =~ s/^Fl$/ᣜ_/
          }
          || $from =~ s/G::/G\:/;
      }
      my $dir = ($last ? "last.id>" : "").u.id;
      #say "pyra $dir $from  $thing->[0]";
      $from ||= "stackw\ $stack->[0]";
      shift @$stack;

      $u->from({
          K => "$from",
          G => $G,
          hitime => $H->hitime(),
          stack => $stack,
          Flab => [@Flab],
          F => [@F],
          depth => 0+@F,
          thing => $thing,
          print => 'S.name;',
      });
      $u->from({Error=>$@}) if $@;
      u.name = join " ", grep {defined $_} u.G.way, u.K, gpty(@{u.thing});
      $u
  - K: waystacken #c
    style: nonbabble
    D: |
            my $s = $G->pyramid(@_);
            push @{ $F[0]->{undies} ||= [] }, $s if @F;
            unshift @F, $s;
            $s->{F} = [@F],
            $G->ob("\\", $s);
            my $unway = sub {
                my @FF;
                if ($F[0] ne $s) {
                    my $E = "BATS ";
                    if (!grep {$_ eq $s} @F) {
                        $E .= "self nowhere in \@F"
                    }
                    else {
                        unshift @FF, shift @F until $FF[0] && $FF[0] eq $s || !@F;
                        $E .= " - from $_->{name}\n" for shift @FF;
                    }
                    $H->error(BATS => $G->Flab($E, $s, [[@FF], [@F]]));
                }
                else {
                    shift @F;
                }
                
                if ($@) {
                    #$G->Flab("Stack Return Error", $s, $@);
                    $s->{Error} = $@;
                }
                $s->{Flab} = [@Flab];
                
                if ($s->{_after_do}) {
                    $_->() for @{$s->{_after_do}};
                }
                
                my $te = $@; $@ = "";
                $G->ob("/", $s);
                $@ = $te;
                @Flab = ();
                $s
            };
            wantarray ? ($unway, $s) : $unway;
  - K: parse_babble #c
    style: nonbabble
    D: |
      
            my $eval = shift;
            
            my $AR = qr/(?:\[(.+?)\]|(?:\((.+?)\)))/;
            my $G_name = qr/[\/\w]+/;
            my $Gnv = qr/\$?$G_name/;
            
            # 5/9
            
            $eval =~ s/(Sw|ws) (?=\w+)/w \$S /sg;
            
            $eval =~ s/(Say|Info|Err) (([^;](?! if ))+)/\$H->$1($2)/sg;
            $eval =~ s/T (?=->)/->T() /sg;
            
             
            # 6/9 - motionless subway
            
            $eval =~ s/timer $NUM? \{(.+?)\}/\$G->timer($1, sub { $3 })/sg;
            $eval =~ s/waylay $NUM?(\w.+?);/\$G->timer("$1",sub { w $2; },"waylay $2");/sg;
            
            my $point = qr/[\w\$\/\->\{\}]*[\w\$\/\->\.\}]+/;
            
            my $alive = qr/\$[\w]*[\w\->\{\}]+/;
            
            my $dotha = qr/[A-Za-z_]\w{0,3}(?:\.[\w-]*\w+)+/;
            my $poing = qr/$alive|G:$point|$dotha/;
            
            my $sqar = qr/\[.+?\]|\(.+?\)/; 
            
            my $sur = qr/ if| unless| for/;
            my $surn = qr/(?>! if)|(?>! unless)|(?>! for)/;
            my $suro = qr/(?:$sur|(?>!$sur))/;
            
            while ($eval =~
            /\${0}($poing )?((?<![\$\w])w(?: ($poing))? ($point)( ?$sqar| ?$point|))($sur)?/sg) {
                my ($g, $old, $u, $p, $a, $un) = ($1, $2, $3, $4, $5, $6);
                
                if (!$g) {
                    $g = '$G';
                }
                else {
                    $g = ""
                }

                my @n;
                my $ne = ""; # hidden reverse
                ($ne, $a) = ($a, "") if $a =~ /^$sur$/;
                # ^ caught a bit of conditional syntax after w expr


                push @n, '%$ar' if $a =~ s/^[\(\[]\+ ?// || !$a;
                
                push @n, $a     if $a =~ s/^\(|\)$//sg;
                
                push @n, 
                    map { my($l)=/\$(\w+)/;"$l => $_" } split /, */, $a

                                if $a =~ s/^\[|\]$//sg;
                

                my @e;
                push @e, qq["$p"];
                push @e, "{".join(", ",@n)."}";
                push @e, $u if $u;
                my $en = join ", ", @e;
                
                my $wa = $g."->w(".$en.")".$ne;
                
                
                #saygr " $old \t=>\t$wa \t\t\tg$g \tu$u \tp$p \ta$a \tun$un";
                
                $eval =~ s/\Q$old\E/$wa/          || die "Ca't replace $1\n\n in\n\n$eval";
            }
            
            # 8/9

            $eval =~ s/G!($Gnv)/G\.A->spawn(G => "$1")/sg;
            $eval =~ s/G-($Gnv)/\$G->Gf("$1")/sg;
            $eval =~ s/G:($Gnv)/HGf("$1")/sg;

            $eval =~ s/(?<!G)(0->\w+)\(/\$G->_0("$1", /sg;
            $eval =~ s/(0S->\w+)\(/\$G->_0("$1", /sg;

            $eval =~ s/(?:(?<=\W)|^)([A-Za-z_]\w{0,3})((?:\.[\w-]*\w+)+)/"\$$1".join"",map {"->{$_}"} grep {length} split '\.', $2;/seg;


            $eval;
  - K: _0 #c
    D: |
      my ($point, @etc) = @_;
      if (!$G0 || !wish(G=>$G0)) {
          if ($point eq "_load_ways_post") {
              return $G->w("load_ways_post");
          }
          die "CABNNOOT call G0, doesn't exist. "
              ." $point, @etc\n\n".wdump($G0);
      }
      if ($point =~ /^0S?->(.+)$/) {
          my $Usub = $1;
          $G->can($Usub) || die "no 0U $Usub\n".wdump(2,$G0);
          $G->$Usub(@etc);
      }
      else {
          my $ar = shift @etc;
          $ar->{S} = $G;
          $G0->w($point, $ar);
      }
  - K: du #c G style grab
    D: |
      my $a = shift;
      # how to get around the Objs' data
      my $s = a.s ||= $G->dus();
      my $i = a.i;
      my $n = a.n;
      a.e = 2 if !defined a.e;
      
      my $c = {};
      a.as ||= [];
      die sw($a) if !defined a.i;
      push @{a.as}, $a;
      a.ds = [@{a.ds||[]}, $a];
      
      return {} if @{a.ds} > 12 || 2 < grep {ref _.i && _.i eq $i} @{a.as};
      
      my $ref = ref $i;
      my $is = $s->{$ref} || $s->{default};
      $is ||= $s->{HASH} if "$i" =~ /^\w+=HASH\(/;
      $is ||= $s->{default} || return {};
      
      # $mustb
      # does HASH key importance if 0>e<1
      # travels every thing      if e>=1
      #                also      if 0.5<e<1
      # since it must want to know links by then
      # overthinking must be reached somehow
      # going over a line
      # at 5
      # how much is happened
      # sw is a channel
      # the way in the splat...
      
      # there's some more flipping around: TODO
      # an e mod possibly coming from mustb (missing part)
      # so some mustb key can e above 0.5 and see travel
      
      # could return somehow weighted graph, hmm
      # oldworld really doesn't like that idea
      # maybe if du was grabbed as more abstract chunks with A action
      # driving the new codons basically...
      
      # snapping branches off the concept of ^ for now
      
      # we sculpt data as fractions of energy that enlightens the 1-9 meanings
      # fuck binary
      
      # an.s, etc can be modded as meaning builds down
      # but only for 
      # (separado until much future brings everything together)
      
      my $mustb = { map { $_ => 1 } split ',', is.mustb } if is.mustb;
      
      for my $j (is.it->($i)) {
          my $k = delete j.k;
          my $K = delete j.K;
          my $v = delete j.v;
          
          $j = {%$is, %$j};
          my $an = {%$a, i => $v};
          
          my $ohms = defined j.oh ? j.oh : 1;
          
          an.e -= $ohms;
          
          my $rk = "$k an.e";
          $c->{$rk} = $v;
          
          say join("", ("  ") x scalar(@{a.ds}))
              ." a.e - $ohms  $k\t an.e \t\t ".gpty($v);
                    
          if (an.e >= 1 && ref an.i) {
              my $cu = $G->du($an);
              while (my ($ku, $vu) = each %$cu) {
                  my $nk = $k.$ku;
                  next if grep { $_->($_, $an, $cu) } @{s.notZ||[]};
                  $c->{$nk} = $vu;
              }
          }
          elsif (an.e > 0 && an.e < 1 && $mustb && !$mustb->{$K}) {
              delete $c->{$rk};
          }
      }
      
      
      $c
      
  - K: dus #c G style schema
    D: |
        my $h = {
          ARRAY => {
            it => sub {
              my $h = shift;
              my $i = 0;
              map { { k => "[".$i++, v => $_ } } @$h
            },
            oh => 0,
          },
          HASH => {
            it => sub {
              my $h = shift;
              map { { K=>$_, k=>"{".$_, v=>$h->{$_} } } sort keys %$h
            },
          },
        };
        my $an = sub {
            my $k = shift;
            my $i = $h->{$k} ||= {it => h.HASH.it};
            %$i = (%$i, @_);
        };
        $an->(qw'A oh 0.2');
        $an->(qw'Ghost oh 0.8');
        $an->(qw'G oh 0.8');
        $an->(qw'W oh 0.8 mustb','id,hash,file,G');
        $h

  - K: ki #c
    style: func
    D: |
      my $ar = shift;
      my $s = "";
      if (!ref $ar || "$ar" !~ /HASH/) {
          confess "NOT HASH: $ar";
      }
      for my $k (sort keys %$ar) {
          my $v = $ar->{$k};
          $v = "~" unless defined $v;
          #$v = "( ".gname($v)." )" if ref $v;
          $s .= "   $k=$v";
      }
      $s
      
  - K: flatline #c
    style: func
    D: |
      map { ref $_ eq "ARRAY" ? flatline(@$_) : $_ } @_
    
  - K: wish #c
    style: func
    D: |
      my $w = shift;
      my $i = shift;
      $w eq "W" ? ref $i eq "Wormhole" || ref $i eq "W" :
      $w eq "w" ? ref $i eq "Way" || ref $i eq "C" :
      $w eq "G" ? ref $i eq "Ghost" || ref $i eq "G" : die "wish $w $i";




  - K: saycol #c sayyl sayre sayg saygr saybl
    style: func
    D: |
        my $colour = shift;
        print colored(join("\n", @_,""), $colour);
        wantarray ? @_ : shift @_
  - K: sayyl
    style: func
    D: |
        saycol(bright_yellow => @_)

  - K: sayre
    style: func
    D: |
        saycol(red => @_)

  - K: sayg
    style: func
    D: |
        saycol(bright_green => @_)

  - K: saygr
    style: func
    D: |
        saycol(green => @_)

  - K: saybl
    style: func
    D: |
        saycol(bright_blue => @_) 


  - K:
    D: |
    
  - K: uiuS
    D: |
        my ($u, $b) = @_;
        my $a = "S";
        my $ui = u.B.Lu.i if u.B.Lu; # even if below thingy?
        
        for my $w ($ui, $u) {
            next if !$w;
            
            my $Gw = w.G->findway(w.K) if w.Gw;
            
            for my $ww ($Gw, $w) {
                next if !$ww;
                next if !$ww->{$a};
                if ($ww->{$a}->{"${b}_D"}) {
                    $G->Flab("got a $a $b _D  ", $u);
                    my $some = w.G->w("$a/${b}_D", {u=>$u}, $w);
                    return $some if $some;
                }
                my $some = $ww->{$a}->{$b};
                return $some if $some;
            }
        }
  - K: InjC #c
    D: |
        my ($g, $In) = @_;
        while (my ($s, $etc) = each %$In) {
            while (my ($K, $win) = each %$etc) {
                my $C = $g->CsK({K=>$K, s=>$s});
                $C->from($win);
            }
        }
  - K: GAK #c
    D: |
        my ($K, $g) = @_;
        g.K = $K;
        G.GG->{g.K} = $g;
  - K: sing #c sing ing ingo
    D: |
        my $p;
        p.name = shift;
        p.code = shift;
        $p = {%$p, @_};
        p.again = 0.5 if !defined p.again;
        p.begin = 0.2 if !defined p.begin;
        H.G->w(sing => $p);
  - K: ing
    D: |
        my ($time, $ing, $w) = @_;
        $time && $ing || die " time&ing";
        
        my $name = $ing;
        $name .= $w->pint if $w;
        my $ingw = $G->nw(
            K=>"ing",
            name => $name,
            ing => $ing,
            time => $time,
        );
        say "create ingw.G.name ingw.name $time";
        ingw.w = $w if $w;
        my $inga = G.ing->{$name} ||= {};
        _.dead = 1 for values %$inga;
        $inga->{ingw.id} = $ingw;
        0S->ingo($ingw);
    
  - K: ingo
    D: |
        my ($ingw) = @_;
        return say "ing ingw.name ingw.id deduped" if ingw.dead;
        return say "ing ingw.name ingw.id ui dead" if ingw.w && ingw.w.dead;
        
        $G->w(ingw.ing, {}, ingw.w);
        
        my $time = ingw.w.e if ingw.w && ingw.w.e;
        $time ||= ingw.time;
        say "time ingw.G.name ingw.name $time";
        $G->timer($time, sub {
            0S->ingo($ingw);
        }, "ing ingw.name ingw.id");
  - K: accum #c TODO C vortex i/o
    D: | 
        # TODO path loquation doesn't stretch far re policy, no prob for now.
        my ($src, $ac, $t) = @_;
                
        if ($ac eq "Lo" || $ac eq "Li") {
            $src->{$ac} = $t;
            return;
        }
        
        my $a = 0S->loquate($src, $ac, []);
        
        return if $ac eq 'o' && src.i && src.i eq $t;

        if (!grep { $_ eq $t } @$a) {
            push @$a, $t
        }
  - K: deaccum
    D: |
        my ($source, $ac, $t) = @_; # takes ip ish $t maybe
        my $a = $source->{$ac} ||= [];
        my $i = 0;
        for (@$a) {
            return splice(@$a, $i, 1) if $_ eq $t;
            $i++;
        }
  - K: ip #c TODO Tish/R maths logics, heat mapping, see also CsK vortex reading
    D: |
        my ($ip, $i) = @_;
        my $pass = 1;
        for my $I (keys %$ip) {
            $pass-- if $ip->{$I} ne $i->{$I};
        }
        $pass == 1
  - K: scGre #c TODO A sess # scGre, rei, ei
    D: |
        my ($ip) = @_;
        # or something was somehow, tractioning v
        my @a = grep { 0->ip($ip, _.i) } @{ G.W.script };
        @a
  - K: rei
    D: |
        my ($ip) = @_;
        map {_.i} 0S->scGre($ip);
  - K: ei
    D: |
        my $ip = {};
        ip.K = shift; # lookup BcS for more, we could want to create
        map {_.i} 0S->scGre($ip);
  - K: loquate #c TODO A sess with vectory text
    D: |
        my ($source, $path, $def) = @_;
        my @moves = split '/', $path;
        my $s = $source;
        until (@moves == 1) {
            my $m = shift @moves;
            $s = $s->{$m};
        }
        my $m = shift @moves;
        my $thing = $s->{$m} ||= $def;
        !ref $thing && die "Oh no! $path led to non-ref $thing from $source";
        return $thing;
  - K: fu #c TODO A sess
    D: |
        my $u = shift;
        
        my $fo = $G->W->{ca}->{K}->{u.K}->{B_ki}->{ki(u.B)};
        if ($fo && fo.dead) {
            say "u.K found but dead";
            $fo = undef;
        }
        return $fo if $fo;
        
        for my $LL (@{$G->W->{script}}) {
            my $i = LL.i;
            my $yup = $i eq $u
                || (!exists u.K || i.K eq u.K)
                && 0S->B_same($u => $i);
            if ($yup) {
               say "found i.K in script";
                return $i;
            }
        }
        return undef;
  - K: fu_cache
    D: |
        my $u = shift;
        u.B ||= {};
        $G->W->{ca}->{K}->{u.K}->{B_ki}->{ki(u.B)} = $u;

  - K: R #c needle extRange
    D: |
      G.A->spawn(R => @_);
  
  - K: TRub #c top level inGector
    D: |
      my $a = {};
      my $R = G.R ||= G.A->spawn("R");
      # like du, vectors space out after $k
      #   for increment spacing over the braid
      
      # nah just chuck stuff in $a
      # everything should have more meaning than that
      my @a = @_;
      while (@a) {
          my ($k, $v) = (shift(@a), shift(@a));
          $R->loadup($a, $k, $v);
      }
      
      # 1
      
      # find u from K and B?
      my $u = 0->CsK({K=>a.i.K});
      die "Not leading anywhere: ". wdump($a) unless $u;
      $u->from(a.i);
      
      
      
      # etc
      0S->T({i => $u});
      
      
  - K: u #c u, sway, Bu # 
    D: |
        my ($K, $s) = @_;
        0S->sway({K=>$K}, $s);
  - K: sway
    D: |
        # sucks way matching $p # only supports matching K for now
        my ($p, $s, $P) = @_;
        my ($from) = p.from || 0S->CsK($p);
        
        $from || defined P.e || die "no C: p.K (G.name)".wdump([$p,$s]);
        
        my $w = $G->nw();
        $w->from($from) if $from;
        $w->from($p) unless $from;
        $w->from($s) if $s && %$s; # merges in B :D
        
        return $w
  - K: Bu
    D: |
        my($K,$B)=@_;
        my $u = 0S->sway({K=>$K},{B=>$B});
        my $a = {};
        $G w $u Bu_D[$a] if u.Gw || u.Bu_D;#opopopopop
        $u
  - K: CsK #c TODO C vortex reading # TODO
    D: |
        my ($p, $GG) = @_;
        $GG ||= $G;
        p.s ||= 'Cs C';
        my @topK = split ' ', delete p.s;
        my @Cs = map { flatline($_) } map { $GG->anyway($_) } @topK;
        @Cs = grep { 0->ip($p, $_) } @Cs if %$p;
        return wantarray ? @Cs : shift @Cs;
  - K: TafuBl #c TafuBl, TafuB, TB, Tafu, Taful
    D: |
        #STICKSSTICKSSTICKSSTICKSSTICKSSTICKSSTICKSSTICKSSTICKSSTICKS
        0S->l( 0S->TafuB(@_) );
  - K: TafuB
    D: |
        my($K,$B)=@_;
        my $ca = $G->W->{ca}->{K}->{$K}->{B_ki}->{ki($B)};
        if ($ca && !ca.dead) {
            return $ca;
        }
        0S->Tafu(0S->Bu($K, $B))
  - K: TB
    D: |
        my ($K, $B) = @_;
        my $u = 0S->Bu($K, $B);
        0S->T({i=>$u});
  - K: Tafu
    D: |
        my($uu)=@_;
        0S->fu($uu) || 0S->T({i => $uu});
  - K: Taful
    D: |
        my($uu)=@_;
        0S->l( 0S->Tafu($uu) );
  - K: visTp_TafuBlA #c
    D: |
        my ($Tp, $Bup, $A) = @_;
        my $old = 0S->visTp($Tp); # could be Fun, wire into end
        my $uu = 0S->Bu(@$Bup); 
        my $u = 0S->fu($uu);
        
        A.old ||= [] if $A;
        A.new ||= [] if $A;
        if ($u) {
            push @{A.old}, $u if $A;
        }
        else {
            push @{A.new}, $u if $A;
            $u = 0S->T({i => $uu});
        }
        
        0->l($u);
        $T= $old;
        $u;
  - K: visTp_l_u #c
    D: |
        my ($Tp, $u) = @_; # get in to a T place and make links
        my $old = 0S->visTp($Tp);
        0->l($u);
        $T= $old;
        $u;
  - K: visTp_TafuBl # get in Tp,  #c
    D: |
        my ($Tp, $Bp) = @_;
        my $old = 0S->visTp($Tp);
        my $u = 0S->TafuBl(@$Bp);
        $T= $old;
        $u;
  - K: visTp #c
    D: |
        my ($p, $fun) = @_;
        
        # are in Ghost right now?
        my $tish = $T && (ref $T eq 'Way' || ref $T eq 'C');
        my $old = $T;
        if (!$tish) {
            $T = $G->nw();
        }
        elsif (T.G ne $G) {
            # loses hair? we never care?
            $T = $G->nw();
        }
        else {
            $T = $T->spawn;
        }
        
        $p = {i=>$p} if ref $p =~ /^(Way|C)$/;
        my $moved = p.i || p.L;
        if ($moved) {
            delete $T->{$_} for qw'i L t o';
        }
        
        $T->from($p);
        
        T.i ||= T.L.i;
        T.L ||= T.i.Li;
        T.t ||= T.L.t;
        T.o ||= T.L.o;
        T.o ||= [];
        
        if ($old) {
            T._T = $old;
            #push @{old.T_||=[]}, $T;
        }
        if (my $r = T.r) {
            if ($moved && r.ih->{T.i.id} && r.noo) {
                # recursion q factor # can rebraid things to go on forever etc.
                die "not allowed circular travel, "
                    .sw({here_before => $T});
            }
            $r = T.r = {%$r};
            r.ih = {%{r.ih||{}}};
            r.is = [@{r.is||[]}, T.i];
            r.ih->{T.i.id} = $T;
        }
        
        if (ref $fun eq "CODE") {
            return $fun->();
            $T = $old;
        }
        elsif ($fun eq "Fun") {
            push @{ $F[0]->{_after_do} }, sub {
                $T = $old;
            }
        }
        return $old;
  - K: l # draw arcs #c
    D: |
        my ($n) = @_;
        my $u = T.i; # up;
        $G->L($n, $u);
        0->accum($n, 'Lo', T.L);
        0->accum($T, 'o', $n);
        $n;
  - K: L #c
    D: |
      my ($n, $u) = @_;
      u.A->An($n);
      n.A->Au($u);
      
  - K: T #c
    D: |
        my ($p) = @_;
        
        # 1/9
        
        my $giu = T.i;
        my $old = 0S->visTp($p); # 1
        die "no old!".wdump($T) if !$old;
        T.i || die " no way in! ".wdump($p);
        
        0S->fu_cache(T.i);
        
        # set up this dimension - allele tower
        # maths stapler - clown shoes - RNA
        
        my $beg = T.i;
        my $sge = sub {
            die "Lost i somewhere before ".shift."... "
            .wdump(2, [$beg, T.i]) unless T.i eq $beg;
        };
        
        # 2/9
        
        say "HAUNT HAUNT HAUNT ".T.i->pi if $G->deeby;
        #$G0->{travels_of}->{$G->{name}} ++;
        $G->ob("haunt");
        # so crawl is like an expanding awareness thing
        # see the whole structure
        
        # 3/9
         $G->w("T/flows");
           $G->w('flows_D', {}, T.i);
        #$G->Flab("flows ", $T);
          $sge->("flows");
          
        # 4/9
        T.L = $G->W->continues($G); # %
          $sge->("humms W being"); # eg travelling sw eval
         $G->w("T/humms");
           $G->w('humms_D', {}, T.i);
        #$G->Flab("humms", $T);
          $sge->("humms");
          
        # 5/9
        T.L.i eq T.i || die "5 eye swamp gone wrong".sw($T);
        0S->accum(T.L.i, 'Li', T.L); # just right
        
         $G->w("T/links", {u=>T.i});
           $G->w('links_D', {}, T.i);
        #$G->Flab("links", $T);
          $sge->("links");
        # rounds_D? replayable when recoded?
        # assume 6/7 will continue the process...
        # 6/9
         $G->w("T/travels");
           $G->w('travels_D', {}, T.i);
        #$G->Flab("travels", $T);
          $sge->("travels");
        die "Lost i somewhere before 7... "
        .wdump(2, [$beg, T.i])unless T.i eq $beg;
        
        # 7/9
        
        $G->w("T/traction", {u=>T.i});
        $G->w('traction_D', {}, T.i);
        #$G->Flab("travels", $T);
          $sge->("travels");
        
        # 8/9
        
        #Info "HAUNTED ".sw($T) if $G->{name} =~ /braid|ux|odon/;
        
        # 9/9
        
        die "Lost i somewhere before 9... "
        .wdump(2, [$beg, T.i])unless T.i eq $beg;
        
        my $L = T.L;
        $T = $old;
        die "dumb".wdump([$T, $old, $giu]) unless T.i eq $giu;
        return L.i;
  - K: fs_glob #c
    D: |
        my (@globs) = @_;
        my @list;
        for my $glob (@globs) {
            push @list, grep { defined }
                grep { Hostinfo::fixutf8($_) || 1 }
                grep { -f $_ } glob $glob;
        }
        return @list;
  - K: fs_find #c
    D: |
        my (@dirs) = @_;
        my @list;
        File::Find::find(sub {
            my $na = $File::Find::name;
            Hostinfo::fixutf8($na);
            return unless -f $na;

            push @list, $na;
        }, @dirs);
        return @list;
  - K: jsq #c
    D: |
        my @a = @_;
        for (@a) {
            s/\\/\\\\/g;
            s/'/\\'/g;
            s/\n/\\n/g;
        }
        wantarray ? @a : shift @a;
  - K: jssq #c
    D: |
        my @a = @_;
        for (@a) {
            s/\\/\\\\/g;
            s/"/\\"/g;
            s/\\\\n/\\n/g;
            #s/\n/\\n/g;
        }
        wantarray ? @a : shift @a;
  - K: B_same #c
    D: |
        my ($u, $i) = @_;
        
        return 1 if exists u.B._ && exists i.B._ && u.B._ eq i.B._;
        
        my @ks = keys %{u.B};
        for my $k (@ks) {
            u.B->{$k} eq i.B->{$k} || return 0;
            next if $k eq "Codon";
        }
        unless (keys %{u.B}) {
            Say " u has no B, mind  you...".ki($u);
        }
        return 1;
  - K: Ato #c
    D: |
        my ($w, $to) = @_;
        grep { _.K =~ /^$to$/ } @{w.Li.o}
  - K: Stytog #c
    D: |
        my ($u, $s) = @_;
        my @styles = split /\s+/, u.styles;
        if (grep { $_ eq $s } @styles) {
            @styles = grep { $_ ne $s } @styles
        }
        else {
            push @styles, $s;
        }
        u.styles = join ' ', @styles;
        $G->w('v/ch', {u=>$u});
  - K: wayray #c
    D: |
        my ($SS, $GG) = @_;
        $GG ||= $G;
        die sw(\@_) if ref ${GG} !~ /^G/;
        my $i = 0;
        for my $wS (@$SS) {
            $SS->[$i] = $GG->nw(%$wS) unless ref $wS =~ /^(Way|C)$/;
            $i++;
        }
  - K: RW #c
    D: |
        my ($GG) = @_;
        say "RW RW RW RW RW GG.name\t\t GG.K";
        _.dead = $F[0] for 0->rei($GG, {});
        my $W = GG.W;
        delete GG.Vu; # vortex will start over
        my $deadscript = W.script;
        W.script = [];
        W.n = 0;
        delete W.ca;
        $deadscript;
  - K: delfrom #c
    D: |
        my ($u) = @_;
        for my $uu (0S->Io($u)) {
            0S->del($uu);
        }
  - K: del #c
    D: |
        my ($u) = @_;
        my $L = u.Li || die "wasnt";
        #say "deleting ".$u->pint;
        $G->w('v/ch'=>{u=>$u});

        0S->deaccum(u.Lo, 'o', $u);
        0S->deaccum(u.Li.W, 'script', $L);
        u.dead = 1;

        0S->del($_) for @{u.Li.o};
    
  - K: Io #c
    D: |
        my ($u) = @_;
        grep { _.G eq $G } @{u.Li.o};
  - K: su #c
    D: |
        my ($a) = @_;
        if (@_ > 1) {
            $a = {top => shift};
            a.cb = pop;
            a.div = shift || 7;
        }
        a.top && a.cb || die "wtf";
        my $D = a.cb;
        a.cb = sub {
            my $d = {};
            (d.m, d.top, d.sutop) = map { $H->fixutf8($_) } @_;
            $G->timer(0.1, sub {
                $D->($d);
            });
        };
        
        H.G->w(suRedis => $a);

