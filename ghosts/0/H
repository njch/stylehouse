  
0:
 H:
  - K: head
    libglob: 'l/?.pm'
    D: |
        use UUID;
        use Redis;
        use File::Slurp;
        use Time::HiRes 'gettimeofday', 'usleep';
        use YAML::Syck;
        use Data::Dumper;
        use Term::ANSIColor;
    
  - K: new
    D: |
      my $p = shift;
      $H = $H->spawn0('H');
      $H->{$_} = $p->{$_} for keys %$p;
      
      ___LIBGLOBETC
       
      use lib 'lib'; 
      use Hostinfo;
      Hostinfo::lib_perc_H($H);
      
      $H->spawn0('A')->new($H);
      H.G = H.A->spawn(G => 'H');
      
      H.G->w('fresh_init'); # art
      H.G->w('any_init'); # art
      
      # is either G->subs or vortexed way, not a "root ghost" anymore but...
      $Ghost::G0 = H.A->spawn(G => 'G');
      $Ghost::G0->w('fresh_init');
      $Ghost::G0->w('any_init');

  - K: pi
    D: |
      "H ! ";
      
  - K: spawn
    D: |
      my $a = shift;
      my $u = $H->spawn0(@{a.r});
      
      if (ref $u eq 'A') {
          $u = $u->new(a.i);
      }
      else {
          $H->spawn({i=>$u, r=>['A']});
          a.uA->An($u);
          u.A->Au(a.uA);
          shift @{a.r};
          $u = $u->new(@{a.r});
      }
      say "H spawning ".$u->pi unless ref $u eq 'A' || ref $u eq 'C';
      $u
      
  - K: spawn0
    D: |
      my $nb = shift;
      my $u = bless {}, $nb;
      $nb::H = $H;
      u.id = mkuid();
      $u



  - K: throwlog #c
    D: |
      my $what = shift;

      if ($H->{_future}) {
          my $te = $@;
          $@ = "";
          my $r = eval { $H->{G}->mess($what, [@_]) };
          if ($@) {
              eval { $H->{G}->timer(0.1, sub {
                  $H->error("G mess error while throwing a $what: $@");
               }) };
              $@ = '';
          }
          $@ = $te;
          if ($r && $r eq "yep") {
              return;
          }
      }

      my @E;
      for my $b (@_) {
          if (ref $b eq "Way") {
              push @E, "Way: $b->{name}";
              push @E, ( map { " ` ".Ghost::ghostlyprinty("NOHTML", $_) } @{$b->{thing}});
              push @E, $b->{Error} if $b->{Error};
          }
          else {
              push @E, Ghost::ghostlyprinty("NOHTML", $b)
          }
      }
      my $error =
          [ hitime(), $H->stack(2), [@E] ];

      my @context = (
          grep { !/Ghost Ghost::__ANON__ |Ghost \(eval\)/ } @{$error->[1]},
      );
      @context = () if $what eq "Say" || $what eq "Info";
      my @f = @Ghost::F;
      for my $c (@context) {
          my $f = shift @f;
          say "$c ======== ". Ghost::gpty($f->{thing});
      }
      my $string = join("\n",
          @context,
          @{$error->[2]},
      );
      $string = "\n$string\n";
      print colored(ind("$what  ", $string)."\n", $what eq "Error"?'red':'green');

  - K: Say
    D: |
       $H->throwlog("Say", @_);

  - K: Err
    D: |
       $H->throwlog("Err", @_);
  - K: error
    D: |
       $H->throwlog("Err", @_);

  - K: Info
    D: |
       $H->throwlog("Info", @_);
  - K: info
    D: |
       $H->throwlog("Info", @_);
  - K: snooze #c
    D: |
          return Time::HiRes::usleep(shift || 5000);

  - K: ind #c
    D: |
      my ($in, $thing) = @_;
      $thing = "" unless defined $thing;
      join "\n", map { "$in$_" } split "\n", $thing

  - K:ddump
    D: |
      my $thing = shift;
      my $ind;
      return
          join "\n",
          grep {
              1 || !( do { /^(\s*)hostinfo:/ && do { $ind = $1; 1 } }
              ...
              do { /^$ind\S/ } )
          }
          "",
          grep !/^       /,
          split "\n", Dump($thing);

  - K: wdump
    D: |
      my $thing = shift;
      my $maxdepth = 3;
      if (@_ && $thing =~ /^\d+$/) {
          $maxdepth = $thing;
          $thing = shift;
      }
      $Data::Dumper::Maxdepth = $maxdepth;
      return join "\n", map { s/      /  /g; $_ } split /\n/, Dumper($thing);

  - K: send
    D: |
      my $m = shift;
      die "Message contains \\n:\n$m\n\n" if $m =~ /\n/;
      H.G->w(send_Elvis => {m => $m});
    
  - K:
    D: |
      
  - K:
    D: |
      
  - K:
    D: |
      
  - K:
    D: |
      
  - K:
    D: |
      
  - K:
    D: |
      
    
      
  - K: hitime
    D: |
      return join ".", time, (gettimeofday())[1];
  - K: stack #c
    D: |
      my $b = shift;
      $b = 1 unless defined $b;
      my @from;
      while (my $f = join " ", (caller($b))[0,3,2]) {
          last unless defined $f;
          my $surface = $f =~ s/(Mojo)::Server::(Sand)Box::\w{24}/$1$2/g
              || $f =~ m/^Mojo::IOLoop/
              || $f =~ m/^Mojolicious::Controller/;
          $f =~ s/(MojoSand\w+) (MojoSand\w+)::/$2::/;
          push @from, $f;
          last if $surface; 
          $b++;
      }
      return [@from];
      
  - K: slurp
    D: |
      scalar read_file(shift);
      
  - K: spurt
    D: |
      write_file(shift, shift);
      

  - K: mkuid # H wide unique id
    style: func
    D: |
        (mkuuid() =~ /^(\w+)-.+$/)[0];
        
  - K: mkuuid # make a number bigger than the universe
    style: func
    D: |
      UUID::generate(my $i);
      UUID::unparse($i, my $s);
      $s
    
  - K: dig #c make a unique art exubertique (same exube for same art) (hash function)
    style: func
    D: |
      UUID::generate(my $i);
      UUID::unparse($i, my $s);
      $s
      sub sha1_hex { Digest::SHA::sha1_hex(encode_utf8(shift)) }
      sub enhash { sha1_hex(shift) }
      sub dig { enhash(shift) }

