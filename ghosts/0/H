  
Ds:
  - K: head #c
    libglob: 'l/?.pm'
    D: |
        use UUID;
        use Redis;
        use File::Slurp;
        use Time::HiRes 'gettimeofday', 'usleep';
        use YAML::Syck;
        use JSON::XS;
        use Data::Dumper;
        use Term::ANSIColor;
        use Encode qw(encode_utf8 decode_utf8 is_utf8);
        use Carp 'confess';
    
  - K: new #c
    D: |
      my $p = shift;
      $SIG{__WARN__} = sub {
          my $ing = shift;
          warn$ing unless $ing =~ /^Use of uninitialized/;
      };
      $H = $H->spawn0('H');
      H.h = 1;
      H.dark = 1;
      $H->{$_} = $p->{$_} for keys %$p;
      
      ___LIBGLOBETC
      
      
      $G::T = {};
      $H->spawn0('A')->new($H);
      H.G = H.A->spawn(G => 'H', 'S', "S/p.style", "S/p.style/p.name");
      
      # is either G->subs or vortexed way, not a "root ghost" anymore but...
      $G::G0 = H.G;
      
      delete H.dark;
      
      H.G->w('fresh_init'); # art
      H.G->w('any_init'); # art
  - K: enwebsocket #c
    D: |
      my $mojo = shift;
      eval { 
        H.G->w(websocket => { M => $mojo });
      };
          say "Eerror\n\n$@" if $@;
      $@ = "";
  - K: pi #c
    D: |
      "H ! ";
      
  - K: spawn #c
    D: |
      my $a = shift;
      my $u = $H->spawn0(@{a.r});
      say "H spa u.id ". ref $u unless ref $u eq 'A' || ref $u eq 'C';
      
      if (ref $u eq 'A') {
          $u = $u->new(a.i);
      }
      else {
          $H->spawn({i=>$u, r=>['A']});
          a.uA->An($u);
          u.A->Au(a.uA);
          shift @{a.r};
          $u = $u->new(@{a.r});
      }
      
      $u
      
  - K: spawn0 #c
    D: |
      my $nb = shift;
      my $u = bless {}, $nb;
      #$nb::H = $H;#TODO
      u.id = $H->mkuid();
      $u
  - K: send #c
    D: |
      my ($m, $cb) = @_;
      my $a = {m => $m};
      a.cb = $cb if $cb;
      H.G->w(send_Elvis => $a);
  - K: JS
    D: |
      my $js = shift;
      die "jno more ref to view" if ref $js;
      $js =~ s/\n/ /sg;
      $H->send($js);
  - K: pub #c
    D: |
       my ($S, $m, $ig) = @_;
       G::sayyl "H pub $S < ".G::slim(50,50,$m) if !$ig;
       H.db->notify($S,$m);
  - K: djson #c
    D: |
      my $m = shift;
      my $j;
      H.json = JSON::XS->new->allow_nonref;

      eval { $j = H.json->decode(H::encode_utf8($m)) };
      die "JSON DECODE FUCKUP: $@\n\nfor $m\n\n\n\n" if $@;
      die "$m\n\nJSON decoded to ~undef~" unless defined $j;
      $j
  - K: fixutf8 #c
    D: |
      for (@_) {
        if (!is_utf8($_)) {
          $_ = decode_utf8($_); 
        }
      }
      return shift if @_ == 1
  - K: throwlog #c
    D: |
      my $what = shift;

      if (!H.mezthrowing) {
          my $te = $@;
          $@ = "";
          H.mezthrowing = 1;
          my $r = eval { H.G->mess($what, [@_]) };
          undef H.mezthrowing;
          if ($@) {
              my $s = "G mess error while throwing a $what: $@";
              eval { H.G->timer(0.1, sub { $H->error($s); }) };
              $@ = '';
          }
          $@ = $te;
          return if $r && $r eq "yep";
      }

      my @E;
      for my $b (@_) {
          if (ref $b eq "Way") {
              push @E, "Way: $b->{name}";
              push @E, ( map { " ` ".G::ghostlyprinty("NOHTML", $_) } @{$b->{thing}});
              push @E, $b->{Error} if $b->{Error};
          }
          else {
              push @E, G::ghostlyprinty("NOHTML", $b)
          }
      }
      my $error =
          [ hitime(), $H->stack(2), [@E] ];

      my @context = (
          grep { !/G G::__ANON__ |G \(eval\)/ } @{$error->[1]},
      );
      @context = () if $what eq "Say" || $what eq "Info";
      
      my $string = join("\n",
          @context,
          @E,
      );
      $string = "\n$string\n";
      $string = $H->ind("$what  ", $string)."\n";
      my $color = $what eq "Error"?'red':'green';
      print colored($string, $color);
  - K: Say #c TODO babble to $G->mess(...) sa*
    D: |
       $H->throwlog("Say", @_);

  - K: Err
    D: |
       $H->throwlog("Err", @_);
  - K: error
    D: |
       $H->throwlog("Err", @_);

  - K: Info
    D: |
       $H->throwlog("Info", @_);
  - K: info
    D: |
       $H->throwlog("Info", @_);
  - K: snooze #c                   \/\/\////\/\\\/\/\//\/\\\\\/\/////\/\///\\\
    D: |
          return Time::HiRes::usleep(shift || 5000);
  - K: ind #c
    D: |
      my $in = shift;
      my $s = shift;
      join "\n",
           map { "$in$_" } split "\n", $s;
  - K: ddump #c
    style: func
    D: |
      my $thing = shift;
      my $ind;
      return
          join "\n",
          grep {
              1 || !( do { /^(\s*)hostinfo:/ && do { $ind = $1; 1 } }
              ...
              do { /^$ind\S/ } )
          }
          "",
          grep !/^       /,
          split "\n", Dump($thing);
  - K: wdump #c
    style: func
    D: |
      my $thing = shift;
      my $maxdepth = 3;
      if (@_ && $thing =~ /^\d+$/) {
          $maxdepth = $thing;
          $thing = shift;
      }
      $Data::Dumper::Maxdepth = $maxdepth;
      return join "\n", map { s/      /  /g; $_ } split /\n/, Dumper($thing);

  - K: la
    D: |
      (`uptime` =~ /load average: (\S+),/)[0]
  - K:
    D: |
      
  - K:
    D: |
      
  - K:
    D: |
      
  - K:
    D: |
      
  - K: hitime #c
    D: |
      return join ".", time, (gettimeofday())[1];
      
  - K: stack #c
    D: |
      my $b = shift;
      my $for = shift || 1024;
      $b = 1 unless defined $b;
      my @from;
      while (my $f = join " ", (caller($b))[0,3,2]) {
          last unless defined $f;
          my $surface = $f =~ s/(Mojo)::Server::(Sand)Box::\w{24}/$1$2/g
              || $f =~ m/^Mojo::IOLoop/
              || $f =~ m/^Mojolicious::Controller/;
          $f =~ s/(MojoSand\w+) (MojoSand\w+)::/$2::/;
          push @from, $f;
          last if $surface;
          last if !--$for;
          $b++;
      }
      return [@from];
      
  - K: slurp #c
    D: |
      scalar read_file(shift);
      
  - K: spurt #c
    D: |
      write_file(shift, shift);
      
  - K: mkuid #c H wide unique id
    D: |
        (mkuuid() =~ /^(\w+)-.+$/)[0];
        
  - K: mkuuid #c make a number bigger than the universe
    D: |
      UUID::generate(my $i);
      UUID::unparse($i, my $s);
      $s
    
  - K: dig # make a unique art exubertique
      # same exube for same art) (string hash function
    D: |
      my $msg = shift;
      Digest::SHA::sha1_hex(encode_utf8($msg))

