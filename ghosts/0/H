  
Ds:
  - K: head #c
    libglob: 'l/?.pm'
    D: |
        use UUID;
        use Redis;
        use File::Slurp;
        use Time::HiRes 'gettimeofday', 'usleep';
        use YAML::Syck;
        use JSON::XS;
        use Data::Dumper;
        use Term::ANSIColor;
        use Encode qw(encode_utf8 decode_utf8 is_utf8);
        use Carp 'confess';
        sub ddump { H::ddump(@_) }
        sub wdump { H::wdump(@_) }


    
  - K: new #c
    D: |
      my $p = shift;
      $SIG{__WARN__} = sub {
          my $ing = shift;
          warn$ing unless $ing =~ /^Use of uninitialized/;
      };
      $H = $H->spawn0('H');
      H.h = 1;
      H.dark = 1;
      $H->{$_} = $p->{$_} for keys %$p;
      
      ___LIBGLOBETC
      
      $H->spawn0('A')->new($H);
      H.G = H.A->spawn(G => 'H');
      
      # is either G->subs or vortexed way, not a "root ghost" anymore but...
      $G::G0 = H.G;
      
      delete H.dark;
      
      H.G w _load_ways_post(S=>H.G);
  - K: enwebsocket #c
    D: |
      my $mojo = shift;
      eval { 
        H.G->w(websocket => { M => $mojo });
      };
          say "Eerror\n\n$@" if $@;
      $@ = "";
  - K: pi #c
    D: |
      "H ! ";
      
  - K: spawn #c
    D: |
      my $a = shift;
      my $u = $H->spawn0(@{a.r});
      say "H spa u.id ". ref $u unless ref $u eq 'A' || ref $u eq 'C';
      
      if (ref $u eq 'A') {
          $u = $u->new(a.i);
      }
      else {
          $H->spawn({i=>$u, r=>['A']});
          a.uA->An($u);
          u.A->Au(a.uA);
          shift @{a.r};
          $u = $u->new(@{a.r});
      }
      
      $u
      
  - K: spawn0 #c
    D: |
      my $nb = shift;
      my $u = bless {}, $nb;
      #$nb::H = $H;#TODO
      u.id = $H->mkuid();
      $u
  - K: send #c
    D: |
      my ($m, $cb) = @_;
      my $a = {m => $m};
      a.cb = $cb if $cb;
      H.G->w(send_Elvis => $a);
  - K: JS #c
    D: |
      my $js = shift;
      die "jno more ref to view" if ref $js;
      $js =~ s/\n/ /sg;
      $H->send($js);
  - K: pub #c
    D: |
       my ($S, $m, $ig) = @_;
       G::sayyl "H pub $S < ".G::slim(50,50,$m) if !$ig;
       H.db->notify($S,$m);
  - K: djson #c
    D: |
      my $m = shift;
      my $j;

      eval { $j = $H->json->decode(H::encode_utf8($m)) };
      die "JSON DECODE FUCKUP: $@\n\nfor $m\n\n\n\n" if $@;
      die "$m\n\nJSON decoded to ~undef~" unless defined $j;
      $j
  - K: ejson #c
    D: |
      my $m = shift;
      $H->json->encode($m);
  - K: json #c
    D: |
      H.json ||= JSON::XS->new->allow_nonref;
  - K: fixutf8 #c
    D: |
      for (@_) {
        if (!is_utf8($_)) {
          $_ = decode_utf8($_); 
        }
      }
      return shift if @_ == 1

  - K: snooze #c                   \/\/\////\/\\\/\/\//\/\\\\\/\/////\/\///\\\
    D: |
          return Time::HiRes::usleep(shift || 5000);
  - K: ind #c
    D: |
      my $in = shift;
      my $s = shift;
      join "\n",
           map { "$in$_" } split "\n", $s;

  - K: la #c
    D: |
      (`uptime` =~ /load average: (\S+),/)[0]
  - K: hitime #c
    D: |
      return join ".", gettimeofday();
      
  - K: stack #c
    D: |
      my $b = shift;
      my $for = shift || 1024;
      $b = 1 unless defined $b;
      my @from;
      while (my $f = join " ", (caller($b))[0,3,2]) {
          last unless defined $f;
          my $surface = $f =~ s/(Mojo)::Server::(Sand)Box::\w{24}/$1$2/g
              || $f =~ m/^Mojo::IOLoop/
              || $f =~ m/^Mojolicious::Controller/;
          $f =~ s/(MojoSand\w+) (MojoSand\w+)::/$2::/;
          push @from, $f;
          last if $surface;
          last if !--$for;
          $b++;
      }
      return [@from];
      
  - K: slurp #c
    D: |
      scalar read_file(shift);
      
  - K: spurt #c
    D: |
      write_file(shift, shift);
      
  - K: mkuid #c H wide unique id
    style: func
    D: |
        (mkuuid() =~ /^(\w+)-.+$/)[0]
        .H.sdghih++
        
  - K: mkuuid #c make a number bigger than the universe
    style: func
    D: |
      UUID::generate(my $i);
      UUID::unparse($i, my $s);
      $s
    
  - K: dig #c make a unique art exubertique
      # same exube for same art) (string hash function
    D: |
      Digest::SHA::sha1_hex(encode_utf8(shift))

