      
Ds:
  - K: new #c
    D: |
      T.i = T.A.u.i; # MAINT
      T.i.T = $T;
      T.R = T.A->fiu('G')->{R};
      T.name = shift;
      $T->commit(shift);
      
  - K: pi
    D: |
      "T T.name x".scalar(@{T.L})." ".T.i->pi(); 
  
  - K: b
    D: |
        die "HELLO!!";
        T.R->du({ O=>$T, i=>T.i })
  
  - K: commit
    D: |
      my $mes = shift;
      T.L ||= []; 
      $mes ||= "init" if !@{T.L}; 
      $mes ||= "?";
      my $L = {
          B => $T->b,  
          mes => $mes,  
      };
      push @{T.L||=[]}, $L;
      T.HEAD = T.L->[-1]; 
      # reduce middle L # TODO J geology

  - K: diflim
    D: |
        my $lim = shift;
        my $d = $T->diff($lim);

            
            for my $h (values %$d) {
                for my $k (keys %$h) {
                    my $hk = $k;
                    $k =~ s/^\Q$lim\E(\S)/$1/;
                    die "$k not from $hk" unless $k;
                    $h->{$k} = delete $h->{$hk};
                }
            }

            $d
  - K: diff
    D: |
        my $lim = shift;
        my $N = $T->b;
        my $Z = {%{T.HEAD.B}};
        my $d = {};
        while (my ($k, $Nv) = each %$N) {
            my $not = !exists $Z->{$k};
            my $Zv = delete $Z->{$k};  
            
            next unless $k =~ /^\Q$lim\E\S/;

            if ($not) {
                d.create->{$k} = $Nv;
            }
            elsif ($Zv ne $Nv) {
                d.dif->{$k} = $Nv;
            }
        }
        d.left = $Z;
        d.new = {%{d.create||{}},%{d.dif||{}}};
        $d;
      
      

