 
0:
 W:
  - K: head #c
    D: |
      use base 'Wormhole';
  - K: new #c
    D: |
      W.G = W.A.u.i;
      W.name = "W.G.name";
      W.n = 0;
      $W->wormfile_load(shift);
      
  - K: continues #c
    D: |
      my $G = shift; # %

      my ($namg) = $W->{G}->{name} =~ /\(\S+[^\)]*\)$/;
      $namg = "$W->{G}->{name} ".
          join("",("  ")x($Ghost::T->{depth}||1))."l-$W->{n} ";
      my $L = {
          uuid => (ref $H eq "H" ? $H->mkuid : $H->make_uuid),
          name => $namg,
          n => $W->{n}++,

          t => $G::T->{t},

          i => $G::T->{i},
          o => $G::T->{o},
          T => $G::T, # LIES?
          G => $G,
          W => $W,

          depth => $G::T->{depth},
      };

      if ($G->deeby) {
          say "Enters the $namg\t\ti:".L.i->pi;
          say "W: \t\tB{ ".Ghost::ki($L->{i}->{B});
          say "   \tt = ".Ghost::gpty($L->{t});
      }

      push @{$W->{script}}, $L;
      $G->ob("continues...", $L);

      return $L;
  - K: uhigh #c
    D: |
      my $n = $W->{n};
      return "!!" if ref W.script ne "ARRAY";
      my $u = scalar(@{W.script});
      ($u ne $n ? $n : '')."x$u"; # acquire north, get high
      
  - K: pi #c
    D: |
      "W W.name ".$W->uhigh;

