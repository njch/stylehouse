 
Ds:
  - K: head #c
    D: |
      # nothing!
  - K: new #c
    D: |
      W.G = W.A.u.i;
      W.name = "W.G.name";
      W.n = 0;
      $W->wormfile_load(shift); 
      
  - K: continues #c
    D: |
      my $G = shift; # %

      my ($namg) = W.G.name =~ /\(\S+[^\)]*\)$/;
      $namg = "W.G.name ".
          join("",("  ")x($G::T->{depth}||1))."l-$W->{n} ";
      my $L = {
          uuid => $H->mkuid,
          name => $namg,
          n => $W->{n}++,

          t => $G::T->{t},

          i => $G::T->{i},
          o => $G::T->{o},
          T => $G::T, # LIES?
          G => $G,
          W => $W,

          depth => $G::T->{depth},
      };

      if ($G->deeby) {
          Say "Enters the $namg\t\ti:".L.i->pi;
      }

      push @{W.script}, $L;
      $G->ob("continues...", $L);

      return $L;
  - K: uhigh #c
    D: |
      my $n = $W->{n};
      return "!!" if ref W.script ne "ARRAY";
      my $u = scalar(@{W.script});
      ($u ne $n ? $n : '')."x$u"; # acquire north, get high
      
  - K: pi #c
    D: |
      "W W.name ".$W->uhigh;
  - K: ob #c
    D: |
        W.G->ob(@_);
  - K: CS #c
    D: |
        [@{W.script}]
  - K: wormfile_load #c
    D: |
        W.file = shift;
        if (W.file && -e W.file) {
            my $s = W.script = Load($H->slurp(W.file));
            die " script (loaded from W.file) ne ARRAYref: ".($s||"~undef~")
                unless ref $s && $s eq "ARRAY";
            say "W W.file loaded";
        }
        else {
            W.script = [];
        }
  - K: wormfile_check #c
    D: |
        my $file = W.file;
        unless (-e $file) {
            say "no $file";
            my ($wom) = $file =~ qr{(wormholes/.+)/};
            unless (-e $wom) {
                mkdir $wom;
            }
            `touch $file`;
        }
  - K: findL
    D: |
          my $id = shift || return;
          my ($L) = grep { _.uuid eq $id } @{W.script||[]};
          $L;

