
Oi:
  includome: R/sur R/ivm
Ds:
  - K: head #c
    D: |
      our $f = {};
      fstyles();

 
  - K: new #c
    D: |
      R.name = shift;
      R.G = R.A->fiu('G');
      (R.startF) = @G::F;
      my $Ru = R.G->CsK({s=>'R',K=>R.name});
      # ^ really a space of way from K to reag
      $R->from($Ru) if $Ru;
      $R->instyle(@_);
      
  - K: from #c
    D: |
      my $s = shift;
      my $a = shift;
      my $u = $R;
      $u = $u->{$_} if $_=a.trav; # like du
      $R->dfrom({u=>$R, s=>$s});
      return $R;
  - K: dfrom #c
    D: |
        my $a = shift;
        my $u = a.u;
        my $s = a.s;

        my $sk = {map{$_=>1}qw"uuid id G A T"};
        my $axi = ref $u ne "HASH"; # on ACGTR or so

        for my $k (keys %$s) {
            next if $axi && $sk->{$k};
            # Li or Lo? TODO gonerism and schemas dusly
            my $t = $u->{$k};
            my $f = $s->{$k};
            
            if ($k =~ /^(.+)!(.+)$/) {
                $k = $1;
                my $uu = R.A->spawn($2);
                $uu->from($f);
                $f = $uu;
            }
            elsif ($f && $k =~ /^(B|S)$/) {
                $t ||= {};
                ref $t eq "HASH" || die;
                $R->dfrom({u=>$t, s=>$f});
                $f = $t;
            }

            $u->{$k} = $f;
        }
        return $u;
  - K: instyle #c  
    D: |
      return unless @_;
      # inject from @_ and make     braids
      # probably a named bunch of stuff to do like
      # to mix up
      # and mix something else down...
      
      # first simply switch tiny codes on and off
      
      if (@_ == 1) {
        my $a = shift;
        if (ref $a) {
          if (a.timer) {
              R.timer = Mojo::IOLoop->recurring(a.timer => sub { $R->wtf });
          }
          else {
              die "R in...".$R->pi."  \n\n". wdump($a);
          }
        }
        else {
            warn "got $a";
        }
      }
        
    
 
  - K: pi #c 
    D: |
      "R R.name"  
   
  - K: du #c style grab
    D: |
      my $a = shift || R.a;
      $a || die;
      defined a.i || die;
      # how to get around the Objs' data
      my $s = a.s ||= $R->dus();
      my $i = a.i;
      my $n = a.n;
      a.e = 2 if !defined a.e;
      
      my $c = {};
      a.as ||= [];
      push @{a.as}, $a;
      a.ds = [@{a.ds||[]}, $a];
      
      return {} if @{a.ds} > 12 || 2 < grep {ref _.i && _.i eq $i} @{a.as};
      
      my $ref = ref $i;
      my $is = $s->{$ref} || $s->{default};
      $is ||= $s->{HASH} if "$i" =~ /^\w+=HASH\(/;
      $is ||= $s->{default} || return {};
      
      # sw is a channel
      # the way in the splat...
      
      # snapping branches off the concept of ^ for now
      
      # we sculpt data as fractions of energy that enlightens the 1-9 meanings
      
      # an.s, etc can be modded as meaning builds down
      # but only for 
      # (separado until much future brings everything together)
      
      my $mustb = { map { $_ => 1 } split ',', is.mustb } if is.mustb;
      
      for my $j (is.it->($i)) {
          my $k = delete j.k;
          my $K = delete j.K;
          my $v = delete j.v;
          
          $j = {%$is, %$j};
          my $an = {%$a, i => $v};
          
          my $ohms = defined j.oh ? j.oh : 1;
          
          an.e -= $ohms;
          
          my $rk = "$k \t an.e";
          $c->{$rk} = $v;
          a.tr.rows++;
          last if a.tr.rowlimit && a.tr.rows >= a.tr.rowlimit;
          
          if (an.e >= 1 && ref an.i) {
              my $cu = $R->du($an);
              while (my ($ku, $vu) = each %$cu) {
                  my $nk = $k.$ku;
                  next if grep { $_->($_, $an, $cu) } @{s.notZ||[]};
                  $c->{$nk} = $vu;
              }
          }
          elsif (an.e > 0 && an.e < 1 && $mustb && !$mustb->{$K}) {
              delete $c->{$rk};
          }
      }
      
      if (R.a == $a) {
          R.a.d = $c;
      }
      
      # this is about a 4 - material for links
      $c
      
  - K: dus #c G style schema
    D: |
        my $h = {
          ARRAY => {
            it => sub {
              my $h = shift;
              my $i = 0;
              map { { k => "[".$i++, v => $_ } } @$h
            },
            oh => 0,
          },
          HASH => {
            it => sub {
              my $h = shift;
              map { { K=>$_, k=>"{".$_, v=>$h->{$_} } } sort keys %$h
            },
          },
        };
        my $an = sub {
            my $k = shift;
            my $i = $h->{$k} ||= {it => h.HASH.it};
            %$i = (%$i, @_);
        };
        # make so 1.2 means if e>=0.5 traverse with e-=0.2
        # drops 1 every traversal too...
        # cept for sometimes when there's a deeper number in e
        # saying from above via style schema how to curle around
        # the 1-9, wherever
        # then anomalies are mapped with names & meaning in stylegrab 78
        
        $an->(qw'A oh 0.2');
        $an->(qw'C oh 0.2');
        $an->(qw'G oh 0.2');
        $an->(qw'T oh 0.2');
        $an->(qw'R oh 0.2');

        $an->(qw'W oh 0.2 mustb','id,hash,file,G');
        $h
  - K: loadup #c du in reverse
    D: |
      my ($a, $k, $v) = @_;
      my $s = $R->snapple($k); # chunks {G{GG{etc 3
      s.e = $v;
      my $i = $R->suets($a, $s);
      
  
  - K: suets
    D: |
      my ($i, $s) = @_;
      my @s = @{s.s};
      my $end = pop @s if exists s.e;
      my $last;
      while (1) {
            my $ac = shift @s || do {exists s.e || last; $last=1; $end};
          $ac =~ /^(\W)(\w+)$/ || die;
          if (!$last) { # TODO know about insto hash or array...
              $i = $i->{$2} ||= {} if $1 eq "{";
              $i = $i->[$2] ||= {} if $1 eq "[";
          }
          else {
              $i->{$2} = s.e if $1 eq "{";
              $i->[$2] = s.e if $1 eq "[";
              last;
          }
      }
  - K: snapple
    D: |
      my $k = shift;
      ($k, my $v) = $k =~ /^(\S+)(?: (.+))?$/;
      my $a = {k => $k, v => $v};
      my @s;
      while ($k =~ m/(\W\w+)/sg) {
            push @s, $1;
      }
      a.s = \@s;
      $a
      

