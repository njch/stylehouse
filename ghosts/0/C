
Ds:
  - K: head #c
    D: |
       use YAML::Syck;
       $YAML::Syck::ImplicitUnicode = 1;
  - K: new #c
    D: |
      C.G = C.A->fiu('G');
      die "waying non G : C.A.u.i", $C, C.A unless C.G && ref C.G eq "G";
      
  - K: pi #c
    D: |
      my $some = "C ".$C->pint();
      if (length($some) < 6) {
          my $ki = G::ki($C);
          my ($wf) = $ki =~ s/(_wayfile\S+\s*)//;
          $ki = "$wf$ki" if $wf;
          $some .= " $ki";
      }
      $some
  - K: pint #c
    D: |
            my $K = C.K;
            
            my $p;
            $p = eval { C.G->w(print => {}, $C); }
                if (defined C.print || C.Gw) && G::wish(G=>C.G);
            $@ = "" if $@;
            
            $p = C.B.name if C.B.name;
            
            if (C.name eq 'D') {
                $p = C.G->pi." C.point % ".join' ', sort keys %{C.ar};
            }
            
            my $B;
            if (C.B && !$p) {
                if (join(",", sort keys %{C.B}) eq "Lu,ui") {
                    $B = "ui=(".C.B.ui->pint();
                }
                $B ||= G::slim(50,30,G::ki(C.B))        
            } 
            my $s = "$K↯$p".($B?"↯$B":"");
            return $s;
  - K: send #c
    D: |
            my ($m, $cb) = @_;
            my $Elvis = $C;
            H.G w send_Elvis[$m, $cb, $Elvis];
  - K: s #c
    D: |
      my $s = C.A->spawn("C");
      $s->from({@_}) if @_;
      $s
  - K: spawn #c
    D: |
      my $from = shift || $C;
      my $u = C.G->nw();
      $u->from($from);
      $u;
  - K: name
    D: |
            C.name = shift;
            $C;
  - K: init_way #c
    D: |
            my $d = shift;

            # merge the ways into us
            for my $i (keys %$d) {
            
                $C->{$i} = $d->{$i};
            }
            # TODO should be in G or so as we thrust down many ways to here
            # leveridge A into way
            if (my $i = C.Oi) {
                i.includome || die"?";
                for my $Dome (split ' ', i.includome) {
                    my $CDs = $C->s->load("ghosts/$Dome")->{Ds} || die "no domes in $Dome";
                    push @{C.Ds}, @$CDs;
                }
            }
            for my $d ("dials") {
                next unless $C->{$d};
                while (my ($k, $v) = each %{$C->{$d}}) {
                    C.G->{$k} = $v;
                }
            }
  - K: from #c
    D: |
      my $s = shift;
      
      $C->dfrom({u=>$C, s=>$s});
      return $C;
  - K: dfrom #c
    D: |
        my $a = shift;
        my $u = a.u;
        my $s = a.s;

        my $sk = {map{$_=>1}qw"uuid id G A T"};
        my $axi = ref $u ne "HASH"; # on ACGTR or so

        for my $k (keys %$s) {
            next if $axi && $sk->{$k};
            # Li or Lo? TODO gonerism and schemas dusly
            my $t = $u->{$k};
            my $f = $s->{$k};

            $f = { %$t, %$f } if $t && $f && $k =~ /^(B|S)$/;

            $u->{$k} = $f;
        }
        return $u;
  - K: load #c
    D: |
            C._wayfile = shift if @_;
            C._wayfile || die;
            $C->load_file(C._wayfile);
            my $data = delete C._wayfiledata; # could hang, could come back
            C.name ||= (C._wayfile =~ /ghosts\/(.+)/)[0] || C._wayfile;
            $C->init_way($data);
            $C
  - K: load_file #c
    D: |
            my $yamlfile = shift;
            die "no C._wayfile " unless $yamlfile;
            my $yaml = $H->slurp($yamlfile);
            my $w = eval { Load($yaml) };
            if ($@ || !$w || ref $w ne 'HASH' || $@) {
                say $@;
                my ($x, $y) = $@ =~
                      /parser \(line (\d+), column -?(\d+)\)/;
                      
                my @file = split "\n",  $yaml;
                my $xx = 1;
                my $vision = SYCK();
                for (@file) {
                  if ($x - 8 < $xx && $xx < $x + 5) {
                    if ($xx == $x) {
                      $vision .= "HERE > $_\n";
                      $vision .= "HERE > ".join("", (" ")x$y)."^\n";
                    }
                    else {
                      $vision .= "       $_\n";
                    }
                  }
                  $xx++;
                }
                die "! YAML load $yamlfile failed: "
                .($@ ? $@ : "got: ".($w || "~"))
                ."\n\n".$vision;
            }
            C._wayfiledata = $w;
  - K: SYCK #c
    style: nonbabble
    D: |
        <<'';
                                     _..._                   
                                  .-'_..._''.                
                                .' .'      '.\    .          
               .-.          .- / .'             .'|          
                \ \        / /. '             .'  |          
                 \ \      / / | |            <    |          
               _  \ \    / /  | |             |   | ____     
             .' |  \ \  / /   . '             |   | \ .'     
            .   | / \ `  /     \ '.          .|   |/  .       
          .'.'| |//  \  /       '. `._____.-'/|    /\  \     
        .'.'.-'  /   / /          `-.______ / |   |  \  \    
        .'   \_.'|`-' /                    `  '    \  \  \   
                  '..'                       '------'  '---' 
                  
        
        # etc
  - K: find #c
    D: |
            my $point = shift;
            my @path = split /\/|\./, $point;
            my $h = C.hooks || $C;
            $h = $C if @_; # as
            for my $p (@path) {
                $h = $h->{$p};
                unless ($h) {
                    undef $h;
                    last;
                }
            }
            return $h if defined $h;
            
            return undef unless $point =~ /\*/;
            die "sat rs findy $point";

