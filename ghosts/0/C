
0:
 C:
  - K: head
    D: |
      use base 'Way';
       use YAML::Syck;
  - K: new
    D: |
      C.G = C.A->fiu('G');
      die G::sw(["non G : C.A.u.i", $C, C.A]) unless C.G && ref C.G eq "G";
      
  - K: pi
    D: |
      my $some = "C ".$C->pint();
      unless (length($some) > 5) {
          $some .= " ".G::ki($C);
      }
      $some
  - K: s
    D: |
      my $s = C.A->spawn("C");
      $s->from({@_}) if @_;
      $s

  - K: spawn
    D: |
      my $from = shift || $C;
      my $u = C.G->nw();
      $u->from($from);
      $u;
  - K: name
    D: |
            C.name = shift;
            $C;
  - K: from
    D: |
            my $s = shift;
            for my $k (keys %$s) {
                next if $k eq "id" || $k eq "G";
                my $t = $w->{$k};
                my $f = $s->{$k};
                
                 # # SCHEMAS # MERGINESS
                $f = { %$t, %$f } if $t && $k =~ /^(B|S)$/;
                
                $w->{$k} = $f;
            }
            return $w;
  - K: load
    D: |
            C._wayfile = shift if @_;
            C._wayfile || die;
            $C->load_file;
            my $data = delete C._wayfiledata # could hang, could come back
            $C->init_way($data);
            
        }
  - K: load_file
    D: |
            my $yamlfile = shift; 
            my $yaml = $H->slurp($yamlfile);
            my $w = eval { Load($yaml) };
            if ($@ || !$w || ref $w ne 'HASH' || $@) {
                say $@;
                my ($x, $y) = $@ =~
                      /parser \(line (\d+), column -?(\d+)\)/;
                      
                my @file = split "\n",  $yaml;
                my $xx = 1;
                my $vision = SYCK();
                for (@file) {
                  if ($x - 8 < $xx && $xx < $x + 5) {
                    if ($xx == $x) {
                      $vision .= "HERE > $_\n";
                      $vision .= "HERE > ".join("", (" ")x$y)."^\n";
                    }
                    else {
                      $vision .= "       $_\n";
                    }
                  }
                  $xx++;
                }
                die "! YAML load $yamlfile failed: "
                .($@ ? $@ : "got: ".($w || "~"))
                ."\n\n".$vision;
            }
            $w
  - K: SYCK #c
    D: |

        <<'';
                                     _..._                   
                                  .-'_..._''.                
                                .' .'      '.\    .          
               .-.          .- / .'             .'|          
                \ \        / /. '             .'  |          
                 \ \      / / | |            <    |          
               _  \ \    / /  | |             |   | ____     
             .' |  \ \  / /   . '             |   | \ .'     
            .   | / \ `  /     \ '.          .|   |/  .      
          .'.'| |//  \  /       '. `._____.-'/|    /\  \     
        .'.'.-'  /   / /          `-.______ / |   |  \  \    
        .'   \_.'|`-' /                    `  '    \  \  \   
                  '..'                       '------'  '---' 

  - K: init_way #c
    D: |
            my $data = shift;

            # merge the ways into $self
            for my $i (keys %$w) {
                $self->{$i} = $w->{$i};
            }
            for my $a ("chains", "tractors") { # TODO leveridge A into way
                next unless $w->{$a};
                my $as = [];
                for my $c (@{$self->{$a}}) {
                    $c = $self->spawn($c);
                    push @$as, $c;
                }
                $self->{$a} = $as;
            }
            for my $d ("dials") {
                next unless $self->{$d};
                while (my ($k, $v) = each %{$self->{$d}}) {
                    $self->{G}->{$k} = $v;
                }
            }
        }
  - K: pint
    D: |

            my $w = shift;
            
            my $K = $w->{K}        if defined $w->{K} && !defined $w->{k};
            my $p = eval { $w->{G}->w('print',{},$w) }
                if (defined $w->{print} || $w->{Gw}) && G::wish(G=>$w->{G});
            $@ = "" if $@;
            my $B;
            if ($w->{B} && !$p) {
                if (join(",", sort keys %{$w->{B}}) eq "Lu,ui") {
                    $B = "Lui*=(".$w->{B}->{ui}->pint();
                }
                $B ||= G::slim(50,30,G::ki($w->{B}))        
            }
            my $s = "$K↯$p".($B?"↯$B":"");
            return $s;
        }
  - K: send
    D: |

            my ($m, $cb) = @_;
            my $Elvis = $C;
            $m =~ /\n/ && say "Message contains \\n:\n$m\n\n";
            H.G w send_Elvis[$m, $cb, $C];
        }
  - K: find
    D: |
            my $point = shift;
            my @path = split /\/|\./, $point;
            my $h = C.hooks || $C;
            $h = $C if @_; # as
            for my $p (@path) {
                $h = $h->{$p};
                unless ($h) {
                    return undef;
                }
            }
            return $h
  - K: LioO # wants to be goner $c
    D: |
            my $w=shift;
            my $O = shift;
            die "w.K has no Li!" unless $w->{Li};
            my @a = G::findO($O => $w->{Li}->{o});
            wantarray ? @a : shift @a;
        }

  - K: dryup
    D: |
  - K: dryup
    D: |
  - K: dryup
    D: |
  - K: dryup
    D: |
  - K: dryup
    D: |
  - K: dryup
    D: |
  - K: dryup
    D: |
  - K: dryup
    D: |

