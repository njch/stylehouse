
Ds:
  - K: head #c
    D: |
       use YAML::Syck;
       $YAML::Syck::ImplicitUnicode = 1;
  - K: new
    D: |
      C.G = C.A->fiu('G');
      die "waying non G : C.A.u.i", $C, C.A unless C.G && ref C.G eq "G";
      
  - K: pi #c
    D: |
      my $some = "C ".$C->pint();
      unless (length($some) > 5) {
          $some .= " ".G::ki($C);
      }
      $some
  - K: pint #c
    D: |
            my $K = C.K        if defined C.K && !defined C.k;
            my $p = eval { C.G->w(print => {}, $C); }
            
                if (defined C.print || C.Gw) && G::wish(G=>C.G);
            $@ = "" if $@;
            my $B;
            if (C.B && !$p) {
                if (join(",", sort keys %{C.B}) eq "Lu,ui") {
                    $B = "ui=(".C.B.ui->pint();
                }
                $B ||= G::slim(50,30,G::ki(C.B))        
            } 
            my $s = "$K↯$p".($B?"↯$B":"");
            return $s;
  - K: send #c
    D: |
            my ($m, $cb) = @_;
            my $Elvis = $C;
            $m =~ /\n/ && say "Message contains \\n:\n$m\n\n";
            H.G w send_Elvis[$m, $cb, $Elvis];
  - K: s #c
    D: |
      my $s = C.A->spawn("C");
      $s->from({@_}) if @_;
      $s
  - K: spawn #c
    D: |
      my $from = shift || $C;
      my $u = C.G->nw();
      $u->from($from);
      $u;
  - K: name
    D: |
            C.name = shift;
            $C;
  - K: init_way #c
    D: |
            my $d = shift;

            # merge the ways into us
            for my $i (keys %$d) {
                $C->{$i} = $d->{$i};
            }
            # TODO should be in G or so as we thrust down many ways to here
            # leveridge A into way
            
            for my $d ("dials") {
                next unless $C->{$d};
                while (my ($k, $v) = each %{$C->{$d}}) {
                    C.G->{$k} = $v;
                }
            }
  - K: from #c
    D: |
      my $s = shift;
      for my $k (keys %$s) {
      #               unless modulating v 
          next if $k eq "uuid" || $k eq "id" || $k eq "G"; # or Li or Lo or who knows what # SCHEMAS # MERGINESS
          my $t = $C->{$k};
          my $f = $s->{$k};

          $f = { %$t, %$f } if $t && $f && $k =~ /^(B|S)$/;

          $C->{$k} = $f;
      }
      return $C;
  - K: load #c
    D: |
            C._wayfile = shift if @_;
            C._wayfile || die;
            $C->load_file(C._wayfile);
            my $data = delete C._wayfiledata; # could hang, could come back
            C.name ||= (C._wayfile =~ /ghosts\/(.+)/)[0] || C._wayfile;
            $C->init_way($data);
  - K: load_file #c
    D: |
            my $yamlfile = shift;
            die "no C._wayfile " unless $yamlfile;
            my $yaml = $H->slurp($yamlfile);
            my $w = eval { Load($yaml) };
            if ($@ || !$w || ref $w ne 'HASH' || $@) {
                say $@;
                my ($x, $y) = $@ =~
                      /parser \(line (\d+), column -?(\d+)\)/;
                      
                my @file = split "\n",  $yaml;
                my $xx = 1;
                my $vision = SYCK();
                for (@file) {
                  if ($x - 8 < $xx && $xx < $x + 5) {
                    if ($xx == $x) {
                      $vision .= "HERE > $_\n";
                      $vision .= "HERE > ".join("", (" ")x$y)."^\n";
                    }
                    else {
                      $vision .= "       $_\n";
                    }
                  }
                  $xx++;
                }
                die "! YAML load $yamlfile failed: "
                .($@ ? $@ : "got: ".($w || "~"))
                ."\n\n".$vision;
            }
            C._wayfiledata = $w;
  - K: SYCK #c
    style: nonbabble
    D: |
        <<'';
                                     _..._                   
                                  .-'_..._''.                
                                .' .'      '.\    .          
               .-.          .- / .'             .'|          
                \ \        / /. '             .'  |          
                 \ \      / / | |            <    |          
               _  \ \    / /  | |             |   | ____     
             .' |  \ \  / /   . '             |   | \ .'     
            .   | / \ `  /     \ '.          .|   |/  .       
          .'.'| |//  \  /       '. `._____.-'/|    /\  \     
        .'.'.-'  /   / /          `-.______ / |   |  \  \    
        .'   \_.'|`-' /                    `  '    \  \  \   
                  '..'                       '------'  '---' 
                  
        
        # etc
  - K: find #c
    D: |
            my $point = shift;
            my @path = split /\/|\./, $point;
            my $h = C.hooks || $C;
            $h = $C if @_; # as
            for my $p (@path) {
                $h = $h->{$p};
                unless ($h) {
                    return undef;
                }
            }
            return $h
  - K: LioO #c wants to be goner $c
    D: |
            my $O = shift;
            die "C.K has no Li!" unless C.Li;
            my @a = G::findO($O => C.Li.o);
            wantarray ? @a : shift @a;

