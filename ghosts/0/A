
Ds:
  - K: new # link the thing A in
    D: |
      my $i = shift;
      A.i = $i;
      i.A = $A;
      
      # return if dark
      # links() injects, via accum, itself
      
      
  - K: pi
    D: |
      "A A.id >".A.i->pi();
      
  - K: spawn # make down
    D: |
      $H->spawn({uA => $A, r=>[@_]});
      
  - K: An # link down
    D: |
      my $n = $A->fiA(shift);
      my $l = $A->mklt(n => @_);
      $A->accum($A, $l, $n);
      
  - K: Au # link up
    D: |
      my $u = $A->fiA(shift);
      my $l = $A->mklt(u => @_);
      return A.u = $u if $l eq "u";
      $A->accum($A, $l, $u);
      
  - K: mklt # link line thinger
    D: |
      return join "_", grep /./, @_;
      
  - K: umv
    D: |
      my ($f, $t) = @_;
      my ($nf, $nt) = map { $A->mklt(n=>$_) } @_;
      my ($uf, $ut) = map { $A->mklt(u=>$_) } @_;
      my $Au = A.u;
      $Au->deaccum($Au, $nf, $A);
      $Au->An($A, $t);
      #$Au->accum($Au, $nt, $A);
      # u constant
      $A->Au($Au, $t);
      #say "gonna move $nf  $nt   $uf to $ut   -- ".$A->pi;
      
  - K: accum
    D: |
        my ($s, $ac, $t) = @_;
        
        my $a = $s->{$ac} ||= [];
        die "ac looks $ac, got  $a " unless ref $a eq "ARRAY";
        return if grep { $_ eq $t } @$a;
        push @$a, $t;
        
  - K: deaccum
    D: |
        my ($s, $ac, $t) = @_;
        my $a = $s->{$ac} ||= [];
        my $i = 0;
        for (@$a) {
            return splice(@$a, $i, 1) if $_ eq $t;
            $i++;
        }

  - K: p
    D: |
      A.i.K || A.i.name
      
  - K: sag
    D: |
      say $A->p ." ".shift(@_)." ".join"   > ",map {$_->p} @_;
      
  - K: fiA
    D: |
      my $u = shift;
      $u = u.A if ref $u ne 'A';
      die "no A finding" if ref $u ne 'A';
      $u
      
  - K: fiu
    D: |
      my $sh = shift;
      my $a = $A;
      until (ref a.i eq $sh) {
          die "no finding $sh" unless a.u && a.u ne $a;
          $a = a.u;
          ref $a eq "A" || die "atrain malt";
      }
      a.i
      
  - K: to # move
    D: |
      my $to = shift;
      grep { _.K =~ /^$to$/ } @{A.n}

  - K: path
    D: |
      my $up;$up = sub {
          my $a = shift;
          return $a, $up->(a.u) if a.u && a.u ne $a;
      };
      my @path = reverse $up->($A);
      #return join "/", map { ref $_ } @path;

