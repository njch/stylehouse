
Ds:
  - K: new #c link the thing A in
    D: |
      my $i = shift;
      A.i = $i;
      i.A = $A;
      
      # return if dark
      # links() injects, via accum, itself
      
      
  - K: pi #c
    D: |
      "A A.id >".A.i->pi();
      
  - K: spawn #c make down
    D: |
      $H->spawn({uA => $A, r=>[@_]});
      
  - K: An #c link down
    D: |
      my $n = $A->fiA(shift);
      my $l = $A->mklt(n => @_);
      $A->accum($A, $l, $n);
      
  - K: Au #c link up
    D: |
      my $u = $A->fiA(shift);
      my $l = $A->mklt(u => @_);
      return A.u = $u if $l eq "u";
      $A->accum($A, $l, $u);
            
  - K: rAn #c unlink down
    D: |
      my $n = $A->fiA(shift);
      my $l = $A->mklt(n => @_);
      $A->deaccum($A, $l, $n);
  - K: rAu #c unlink up
    D: |
      my $u = $A->fiA(shift);
      my $l = $A->mklt(u => @_);
      return A.u = $u if $l eq "u";
      $A->deaccum($A, $l, $u);
      
  - K: mklt #c link line thinger
    D: |
      return join "_", grep /./, @_;
      
  - K: umv #c rewire from origin (n|u) to (n|u)_name
    D: |
      # say if we don't want to clutter the G this spawned from
      # as a tidy up
      # and things that don't get tidied up
      # must want more attention
      my ($f, $t) = @_;
      my $Au = A.u;
      $Au->rAn($A, $f);
      $Au->An($A, $t);
      $A->rAu($Au, $f);
      $A->Au($Au, $t);
      
  - K: umk #c
    D: |
      my ($u, $t) = @_;
      my $Au = $A->fiA($u);
      $Au->An($A, $t);
      $A->Au($Au, $t);
      
  - K: accum #c
    D: |
        my ($s, $ac, $t) = @_;
        
        my $a = $s->{$ac} ||= [];
        die "ac looks $ac, got  $a " unless ref $a eq "ARRAY";
        return if grep { $_ eq $t } @$a;
        push @$a, $t;
        
  - K: deaccum #c
    D: |
        my ($s, $ac, $t) = @_;
        my $a = $s->{$ac} ||= [];
        my $i = 0;
        for (@$a) {
            return splice(@$a, $i, 1) if $_ eq $t;
            $i++;
        }
  - K: p #c
    D: |
      A.i.K || A.i.name
      
  - K: sag #c
    D: |
      say $A->p ." ".shift(@_)." ".join"   > ",map {$_->p} @_;
      
  - K: fiA #c
    D: |
      my $u = shift;
      $u = u.A if ref $u ne 'A';
      die "no A finding" if ref $u ne 'A';
      $u
      
  - K: fiu #c
    D: |
      my $sh = shift;
      my $a = $A;
      until (ref a.i eq $sh) {
          die "no finding $sh" unless a.u && a.u ne $a;
          $a = a.u;
          ref $a eq "A" || die "atrain malt";
      }
      a.i
      
  - K: to # move
    D: |
      my $to = shift;
      grep { _.K =~ /^$to$/ } @{A.n}
  - K: path #c
    D: |
      my $up;$up = sub {
          my $a = shift;
          return $a, $up->(a.u) if a.u && a.u ne $a;
      };
      my @path = reverse $up->($A);
      #return join "/", map { ref $_ } @path;

