
0:
 A:
  - K: new # link the thing A in
    D: |
      my $i = shift;
      A.i = $i;
      i.A = $A;
      
      # return if dark
      # links() injects, via accum, itself
      
      
  - K: pi
    D: |
      "A A.id >".A.i->pi();
      
  - K: spawn # make down
    D: |
      $H->spawn({uA => $A, r=>[@_]});
      
  - K: An # link down
    D: |
      my $n = $A->fiA(shift);
      push @{A.n}, $n unless grep { $_ eq $n } @{A.n};
      
  - K: Au # link up
    D: |
      my $u = $A->fiA(shift);
      my $t = shift;
      #$A->sag("Au changes from ", A.u, $u) if A.u;
      A.u_t->{$t} = $u;
      A.u = $u;

  - K: p
    D: |
      A.i.K || A.i.name
      
  - K: sag
    D: |
      say $A->p ." ".shift(@_)." ".join"   > ",map {$_->p} @_;
      
  - K: fiA
    D: |
      my $u = shift;
      $u = u.A if ref $u ne 'A';
      die "no A finding" if ref $u ne 'A';
      $u
      
  - K: fiu
    D: |
      my $sh = shift;
      my $a = $A;
      until (ref a.i eq $sh) {
          die "no finding $sh" unless a.u && a.u ne $a;
          $a = a.u;
          ref $a eq "A" || die "atrain malt";
      }
      a.i
      
  - K: to # move
    D: |
      my $to = shift;
      grep { _.K =~ /^$to$/ } @{A.n}

  - K: path
    D: |
      my $up;$up = sub {
          my $a = shift;
          return $a, $up->(a.u) if a.u && a.u ne $a;
      };
      my @path = reverse $up->($A);
      #return join "/", map { ref $_ } @path;

