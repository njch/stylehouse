
Ds:
 - K: wtf #c
   D: |
    my $a = shift;
    # fractionating importantness into spacetime
    if (a.way && a.div) { # spawn
        a.now ||= 0;
        R.wtf->{a.way} = $a;
        return;
    }
    # inf
    my $riv = R.wtf ||= {};
    while (my ($way,$r) = each %$riv) {
        r.now++;
        if (r.now >= r.div) {
            r.now = 0;
            R.G->timer(0.0000001, sub {
                r.last_hit = $H->hitime;
                return r.D->() if r.D;
                R.G->w("$way");
            });
        }
    }
 - K: cgp #c
   D: |
      my $u = shift;
        my $c = {};
        if (!defined $u){
            c.undef = 1;
        } else {
            if (my $ref = ref $u) {
                c.ARRAY = 1 if $ref eq "ARRAY";
                c.HASH = 1 if $ref eq "HASH";
                c.CODE = 1 if $ref eq "CODE";
                c.canpi = 1 if !%$c && $u->can('pi');
                for (qw'A C G T     R   J') {
                      $c->{$_} = 1 if $ref eq $_;
                }
                c.ref = $ref;
            }
            else {
                if (ref \$u eq 'SCALAR') {
                    c.text = 1;
                    c.len = length($u);
                    c.lin = scalar split /\n/, $u;
                    c.b = scalar split /\n\n/, $u;
                    c.number = $u =~ /^(?:\d+\.)?\d+$/;
                    c.wordy = $u =~ /\w+/;
                }
                else { die "wtf is $u" };
            }
        }
        $c
 - K: phat #c
   D: |
       my $a = shift;
        a.bb = {};
        a.ord = [];
        a.bz = R.G w $R as(bb=>a.bb, ord=>a.ord);
        a.fro = sub {
            my $fro = [$R, a.bz, @_];
            R.G w $R gpfro(a=>$fro);
        };
 - K: shj #c
   D: |
      my ($r, $d) = @_;
      my $j;
      j.r = $r;
      j.s = $d->{$r};
      (j.t, j.cv) = j.r =~ /^(.+)\t(.+?)$/ ? ($1, $2) : split /\s+/, j.r, 2;
      (j.cv, my @e) = split /\s+/, j.cv;
      j.ev = \@e if @e;
      $j

