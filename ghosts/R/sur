
Ds:
  - K: key #c
    D: |
        my $k = shift;
        my $e = shift;
        
        if (R.keysuc) {
            if ($k eq "\r") {
                $R->keysucd;
            }
            else {
                push @{R.keysuc}, $k; 
            }
        }
        else {
            $R->popJtrav        if $k eq '-' && !e.S; # look R.A.upwards... 
            $R->adef             if $k eq '1' && e.S;
            $R->afrom             if $k eq '-' && e.S;
            $R->intJtrav($k)    if $k =~ /[0-9]/ && !e.S;
            R.keysuc = []     if $k eq 'Ã€'; # tilde key

        }
        say "Key sucked! $k";
  - K: keysucd #c
    D: |
      my $s = join"",@{delete R.keysuc};
      my ($w) = $s =~ /^(.+)$/;
      say "KEYS SUCKED: $w";
      return $R->intJtrav($1) if $w =~ /^(\d+)$/;
      die "sucked in whatnow? '$s'";
      
  
  - K: uni #c
    D: |
      my $J = R.J || die;
      my $i = J.from || die;
      my $t = J.trav || "";
      #  from => $H,
      #  trav => "{G{GGs",
      while ($t =~ m/(\W)(\w+)/sg) {
          say "Snapped $i       $1 $2";
          last if $1 eq " ";
          $i = $i->{$2} if $1 eq "{";
          $i = $i->[$2] if $1 eq "[" && (ref $i eq 'ARRAY' || die "NOT!");
      }
      if ($t =~ m/^.+? (.+)$/) {
          say "Had some more: $1";
      }
      $i
  - K: afrom #c
    D: |
      R.J.from = R.a.i;
      R.J.trav = "";
  - K: adef #c
    D: |
      R.J.from = H.G.GGs;
      R.J.trav = "";
  - K: popJtrav #c
    D: |
      R.J.trav =~ s/\W\w+$//;
  - K: intJtrav #c
    D: |
      my $k = shift;
      return $R->popJtrav if $k == 0;
      my $i = $k - 1;
      die "no $i" unless exists R.a.r->[$i];
      my $r = R.a.r->[$i];
      my ($hop) = $r->[0] =~ /^(\W\w+)/;
      R.J.trav .= $hop;

      
  - K: durows #c 4 
    D: |
      my $d = R.a.d;
      my @r = %$d;
      R.a.r = [map {[ $_, $d->{$_} ]} sort keys %$d];
  - K: dustill #c 5 stylayer
    D: |
      my $r = R.a.r;
      $_->[2] = G::slim(96,80,G::gp($_->[1])) for @$r;
      @$r;
      
  - K: S #c style splat
    D: |
      R.a = my $a = shift || {};
      # 2
      a.e ||= R.S.e || die;
      a.i ||= $R->uni;
      a.tr.rowlimit = 9*3;
      # 3
      $R->du;
      die "nod" unless a.d; 
      # 4
      $R->durows;
      # 5
      $R->dustill;
      # 6 ?
      # fork sends travel back later with more depth to $R w S,7
      # 7
      # reflect style injection round corner
      # throw style into ux recipe
      my $i = 1;
      my @rows = map {
          join "  ",
          $R->f(blue_fs60 => $i++),
          $R->f(black => $_->[0]),
          $R->f(white_fs120 => $_->[2]),
      } @{R.a.r};
      
      my $title = "= ".$R->f(white_fs150 => G::gp(a.i));
      my $Jpi = "J ".$R->f(white => G::gp(R.J.from))
          ."  ".$R->f(black => R.J.trav);
      
      join "\n", $Jpi, $title, @rows;
  - K: dust #c style text
    D: |
      my $a = {i=>shift, e=>3};
      
      my $d = $R->du($a);
      
      my @or = sort keys %$d;
      @or = map {[ $_, $d->{$_} ]} @or;
      $_->[2] = G::slim(96,80,G::gp($_->[1])) for @or;
      my @rows = map { join "  ", $_->[0], $_->[2] } @or;
      
      return join "\n", @rows;

