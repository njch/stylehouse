
Ds:
  - K: f #c
    D: |
      my @styles = split "_", shift;
      my $t = shift;
      @styles = map { $f->{$_} || die "no style $_" } @styles;
      qq{<span style="@styles">$t</span>};
  - K: fstyles #c
    D: |
      f.fs150 = "font-size:150%;";
      f.fs120 = "font-size:120%;";
      f.fs80 = "font-size:80%;";
      f.fs60 = "font-size:60%;";
      f.white = "color:white;";
      f.blue = "color:blue;";
      f.red = "color:#fca;";
      f.lightblue = "color:#44f;";
      f.black = "color:black;";
  - K: key #c
    D: |
        my $k = shift;
        my $e = shift;
        
        if (R.keysuc) {
            if ($k eq "\r") {
                $R->keysucd;
            }
            else {
                push @{R.keysuc}, $k; 
            }
        }
        else {
            if (!e.S) {
                $R->intJtrav($k)  if $k =~ /[0-9]/; # 0 = popJtrav
                R.keysuc = []     if $k eq 'Ã€'; # tilde key
            }
            else {
            }

        }
        say "Key sucked! $k";
  - K: keysucd #c
    D: |
      my $s = join"",@{delete R.keysuc};
      my ($w) = $s =~ /^(.+)$/;
      say "KEYS SUCKED: $w";
      return $R->intJtrav($1) if $w =~ /^(\d+)$/;
      die "sucked in whatnow? '$s'";
      
  
  - K: popJtrav #c
    D: |
      R.J.trav =~ s/\W\w+$//;
  - K: intJtrav #c
    D: |
      my $k = shift;
      return $R->popJtrav if $k == 0;
      my $i = $k - 1;
      die "no $i" unless exists R.a.r->[$i];
      my $r = R.a.r->[$i];
      my ($hop) = $r->[0] =~ /^(\W\w+)/;
      R.J.trav .= $hop;

      
  - K: uni #c
    D: |
      my $J = R.J || die;
      my $i = J.from || die;
      my $t = J.trav || "";
      #  from => $H,
      #  trav => "{G{GGs",
      while ($t =~ m/(\W)(\w+)/sg) {
          #say "Snapped $i       $1 $2";
          last if $1 eq " ";
          $i = $i->{$2} if $1 eq "{";
          $i = $i->[$2] if $1 eq "[" && (ref $i eq 'ARRAY' || die "NOT!");
      }
      if ($t =~ m/^.+? (.+)$/) {
          say "Had some more: $1";
      }
      $i
  - K: durows #c 4 
    D: |
      my $d = R.a.d;
      my @r = %$d;
      R.a.r = [map {[ $_, $d->{$_} ]} sort keys %$d];
  - K: dustill #c 5 stylayer
    D: |
      my $r = R.a.r;
      $_->[2] = G::slim(96,80,G::gp($_->[1])) for @$r;
      @$r;
      
  - K: S #c style splat
    D: |
      R.a = my $a = shift || {};
      # 2
      a.e ||= R.S.e || die;
      a.i ||= $R->uni;
      a.tr.rowlimit = R.S.rowlimit || 9*3;
      # 3
      $R->du;
      die "nod" unless a.d; 
      # 4
      $R->durows;
      # the buzziness comes off
      return;
      # 5
      $R->dustill;
      # 6 ?
      # fork sends travel back later with more depth to $R w S,7
      # 7
      # reflect style injection round corner
      # throw style into ux recipe
      my $i = 1;
      my @rows = map {
          my ($ac, $li, $pi) = @$_;
          $ac =~ s/\s+/ /g;
          join "  ", map { $R->f(@$_) }
            [ black => $ac ],
            [ blue_fs80 => $i++ ],
            [ white_fs120 => $pi ],
      } @{R.a.r};
      
      my $title = "= ".$R->f(white_fs150 => G::gp(a.i));
      my $Jpi = "@!@".$R->f(white => G::gp(R.J.from))
          ."  ".$R->f(black => R.J.trav);
      
      join "\n", $Jpi, $title, @rows;
  - K: gp #c pi bender
    D: |
      my $u = shift;
      my $v = shift; 
      my $piok = ref $u && ref $u ne 'HASH' && ref $u ne 'CODE'
          && ref $u ne 'ARRAY' && $u->can('pi');
          
      return $u->pi if $piok;
      
      ghostlyprinty('NOHTML',@_);
      
  - K: dust #c style text
    D: |
      my $a = {i=>shift, e=>3};
      
      my $d = $R->du($a);
      
      my @or = sort keys %$d;
      @or = map {[ $_, $d->{$_} ]} @or;
      $_->[2] = G::slim(96,80,G::gp($_->[1])) for @or;
      my @rows = map { join "  ", $_->[0], $_->[2] } @or;
      
      return join "\n", @rows;

