
Ds:
  - K: key #c
    D: |
        my $k = shift;
        
        if (R.keysuc) {
            if ($k eq "\r") {
                $R->keysucd;
            }
            else {
                push @{R.keysuc}, $k; 
            }
        }
        else {
            $R->popJtrav        if $k eq '-'; # look R.A.upwards...
            $R->intJtrav($k)    if $k =~ /[0-9]/;
            R.keysuc = []     if $k eq 'Ã€'; # tilde key

        }
        say "Key sucked! $k";
  - K: keysucd #c
    D: |
      my $s = join"",@{delete R.keysuc};
      my ($w) = $s =~ /^(.+)$/;
      say "KEYS SUCKED: $w";
      return $R->intJtrav($1) if $w =~ /^(\d+)$/;
      die "sucked in whatnow? '$s'";
      
  
  - K: uni #c
    D: |
      my $J = R.J || die;
      my $i = J.from || die;
      my $t = J.trav || "";
      #  from => $H,
      #  trav => "{G{GGs",
      while ($t =~ m/(\W)(\w+)/sg) {
          say "Snapped $i       $1 $2";
          last if $1 eq " ";
          $i = $i->{$2} if $1 eq "{";
          $i = $i->[$2] if $1 eq "[" && (ref $i eq 'ARRAY' || die "NOT!");
      }
      if ($t =~ m/^.+? (.+)$/) {
          say "Had some more: $1";
      }
      $i
      
  - K: popJtrav #c
    D: |
      R.J.trav =~ s/\W\w+$//;
  - K: intJtrav #c
    D: |
      my $k = shift;
      return $R->popJtrav if $k == 0;
      my $i = $k - 1;
      die "no $i" unless exists R.J.at->[$i];
      my $r = R.J.at->[$i];
      my ($hop) = $r->[0] =~ /^(\W\w+)/;
      R.J.trav .= $hop;


  - K: durows
    D: |
      my @or = sort keys %$d;
      @or = map {[ $_, $d->{$_} ]} @or;

  - K: durows
    D: |
      my $d = shift;
      map {[ $_, $d->{$_} ]} sort keys %$d;
  - K: dustill
    D: |
      
  - K: durows
    D: |
      my $d = shift;
      map {[ $_, $d->{$_} ]} sort keys %$d;
  - K: dustill
    D: |
      my @or = @_;
      $_->[2] = G::slim(96,80,G::gp($_->[1])) for @or;
      # could fork after glimpse ^ and do more style, sends parent S,7 new @or
      @or;
      
  - K: S #c style splat
    D: |
      R.a = my $a = shift;
      a.e ||= R.S.e || die;
      a.i ||= $R->uni;
      a.tr.rowlimit = 9*3;
      
      # 3
      my $d = $R->du($a);
      # 4
      my @or = $R->durows($d);
      # 5
      my @or = $R->dustill(@or);
      # 6
      R.J.at = \@or;
      
      my $i = 1;
      my @rows = map {
          join "  ",
          $R->f(blue_fs60 => $i++),
          $R->f(black => $_->[0]),
          $R->f(white_fs120 => $_->[2]),
      } @or;
      
      my $title = "= ".$R->f(white_fs150 => G::gp(a.i));
      my $Jpi = "J ".$R->f(white => G::gp(R.J.from))
          ."  ".$R->f(black => R.J.trav);
      
      join "\n", $Jpi, $title, @rows;
  - K: dust #c style text
    D: |
      my $a = {i=>shift, e=>3};
      
      my $d = $R->du($a);
      
      my @or = sort keys %$d;
      @or = map {[ $_, $d->{$_} ]} @or;
      $_->[2] = G::slim(96,80,G::gp($_->[1])) for @or;
      my @rows = map { join "  ", $_->[0], $_->[2] } @or;
      
      return join "\n", @rows;

