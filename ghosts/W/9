R_Jz:
 - K: cl #c
   n_D:
     reC: |
       # MZ sc={co:b238}
       Rw rez;
     tidy: |
       # MZ sc={co:34b3}
       $G->pub('S/hut/o', 'Hiwtidy');
     reextet: |
       # MZ sc={co:b227}
       $G->tas("S/hut/o" => "reextet");
 - K: ps #c fo9od
   n_D:
     yJ: |
       qw'ps oci ';
     curves: |
       y 0  0.9
       x 0  0.12
       spun 0  0.75
       curve 0.1 -0.024
       zoom 0 0.3
       #["curve 0.4" => 0.3],
     up: | #c
       Rw ii/Jhead $J $cv=0.2;
       Rw ii/psfaus;
 - K: ii/psfaus #c ii = indigo, pi = carving, wt = maneuvrable type 
   D: |
       my @l = `ps faux`;
       my $wtf = [];
       for my $l (@l) {
           chomp $l;
           next if $l !~ /perl/;
           next if $l =~ /sshfs/;
           my @r = split /\s+/, $l, 11;
           my $cs = [@r[0..3,9,10]];
           my $o = Rw pul $cs user pid cpu mem time cmd;
           
           push @$wtf, $o;
       }
       say "PSFAUX: ". wdump $wtf;
       my $M = [];
       for my $f (@$wtf) {
           my $c;
           c.pi = 'psfacts';
           c.gp.cv = 0.8;
           c.s = $f;
           c.i = 1; # numbers
           my $sc;
           sc.co = '4fc';
           sc.zi = 10;
           sc.ws = 'p';
           push @$M, ['SOI', '', $c, $sc];
       }
       my $in = 0.1;
       my $out = 0.9;
       my $k = 'psfaus';
       
       my $oM = [];
       Rw MyN $M:oM $N:M pwth;
       Rw om/bal $J $oM $in $out $k;
 - K: ii/psfaux #c ii = indigo, pi = carving, wt = maneuvrable type 
   D: |
       my @l = `ps faux`;
       my $wtf = [];
       for my $l (@l) {
           chomp $l;
           next if $l !~ /perl|sshfs|tail/;
           my @r = split /\s+/, $l, 11;
           my $cs = [@r[0..3,9,10]];
           my $o = Rw pul $cs user pid cpu mem time cmd;
           push @$wtf, $o;
       }
       say "PSFAUX: ". wdump $wtf;
       my $M = [];
       for my $f (@$wtf) {
           my $c;
           c.pi = 'psfacts';
           c.gp.cv = 0.8;
           c.s = $f;
           c.i = 1; # numbers
           my $sc;
           sc.co = '4fc';
           sc.zi = 10;
           sc.ws = 'p';
           push @$M, ['SOI', '', $c, $sc];
       }
       my $in = 0.1;
       my $out = 0.9;
       my $k = 'psfaus';
       
       my $oM = [];
       Rw MyN $M:oM $N:M pwth;
       Rw om/bal $J $oM $in $out $k;
 - K: pi/psfacts #c
   D: |
        $_ =  u.cmd;
        my ($style,$name) =
            /l\/S\.pm (.+)$/ ? ('hut', $1)
            :
            /stylehouse\.pl$/ ? ('h00s', $_)
            :
            /\.\/ps/ ? ('ps', $_)
            :
            ("weird", $_);
        
        if ($style ne 'hut') {
            $name =~ s/^[| ]+//;
        }
        if ($style eq 'ps') {
            $name =~ s/\/usr\/bin\/perl //;
        }
        
        my $M = []; # HMMMMM may wannsa J?
        
        Rw wt/stylename $M $style $name; 
        
        Rw wt/cpu $M $cpu:u.cpu;
        Rw wt/mem $M $mem:u.mem;
        
        warn "heaps of mem on $style $name  (u.mem)" if u.mem > 20;
        my $V = 1;
        
        #say "psfact -: ".ki 2, $_ for @$M; 
        #die wdump [$d, $ar];
        Rw iM $J $M;
        
 - K: wt/stylename #c  TODO return _M_ brigy dep text jostle
   D: |
       my $sc = {}; # carbon flux $style
       my $nsc = {}; # carbon flux $name
       
       if ($style eq 'hut') {
           sc.co = 'fc7';
           sc.fs = 14;
       }
       if ($style eq 'h00s') {
           sc.co = '007';
           sc.sha = '3 1 2 cff6';
       }
       if ($style eq 'ps') {
           sc.co = '804';
           sc.sha = '3 1 2 fc77';
       }
       # ^ sheety
       
       nsc.co ||= '4fc';
       if ($style eq 'hut') {
           nsc.co = 'ff0';
           nsc.fs = 29;
       }
       if ($name eq '\_ perl stylehouse.pl') {
           $name = 'stylehouse.pl';
           nsc.fs = 8;
       }
       sc.sha = '1 2 6 000';
       nsc.sha = '1 2 6 000';
       my $nc;
       nc.weigh = 'activity';
       
       Rw wtf $M style 1 $s:style $sc;
       Rw wtf $M name 2 $s:name $c:nc $sc:nsc;
 - K: wt/cpu #c  # TODO make fs smooth, atomical curve compu
   D: |
       my $sc;
       sc.co = 'eb0';
       sc.fs = $cpu<0.5?4:$cpu<2?7:$cpu<4?10:14;
       sc.sha = '1 2 6 000';
       my $c;
       c.weighed = 'activity';
       Rw wtf $M cpu 3 $s:cpu $c $sc;
 - K: wt/mem #c
   D: |
       my $sc;
       sc.co = '8e0';
       sc.co = 'f30' if $mem > 20;
       sc.fs = $mem<2?4:$mem<5?7:$mem<12?14:28;
       my $c;
       c.weighed = 'activity';
       Rw wtf $M mem 4 $s:mem $c $sc;
 - K: samv #c
   D: |
    G.samv ||= [
        ["w", 7*86400], ["d", 86400, " "], ["h", 3600, ":"],
        ["m", 60, ":" ], ["s", 1, 0],
        [ "ms", 0.001 ], [ "us", 1e-6 ], ["ns", 1e-9],
    ];  

    my $scalar = $d;
    my $neg = $scalar < 0;
    if ($neg) {
        $scalar = -$scalar;
    }
    my $d = (shift) || 4;
    if ($scalar == 0) {
        return "0s";
    }
    my $quanta = exp(log($scalar)-2.3025851*$d);
    my $rem = $scalar+0;
    my $rv = "";
    for my $i (0..@{G.samv}) {
           my $unit = G.samv->[$i];
        if ($rv or $unit->[1] <= $rem ) {
           my $x = int($rem/$unit->[1]);
           my $new_rem = ($x ? $rem - ($x*$unit->[1]) : $rem);
           my $last = (G.samv->[$i+1][1]<$quanta);
           if ($last and $new_rem >= $unit->[1]/2) {
               $x++;
           }
           if (!$last and $unit->[2]) {
               $rv .= $x.$unit->[0].$unit->[2];
           }
           elsif (defined $unit->[2] and !$unit->[2]) {
               # stop at seconds
               my $prec = ceil(-log($quanta)/log(10)-1.01);
               if ( $prec >= 1 ) {
                       $rv .= sprintf("%.${prec}f", $rem).$unit->[0];
               }
               else {
                       $rv .= sprintf("%d", $rem).$unit->[0];
               }
               last;
           }
           else {
               $rv .= $x.$unit->[0];
           }
           last if $last;
           $rem = $new_rem;
        }
    }
    ($neg?"-":"").$rv;
 - K: mugwu #c
   D: |
    my %prefixes=(18=>"E",15=>"P",12=>"T",9=>"G",6=>"M",3=>"k",
    0=>"",
              -3=>"m",-6=>"u",-9=>"n",-12=>"p",-15=>"f",-18=>"a");

    my $scalar = $d;
    my $neg = $scalar < 0 ? "-" : "";
    if ($neg) {
        $scalar = -$scalar;
    }
    my $unit = (shift) || "";
    my $d = (shift) || 4;
    my $e = 0;
    #scale value
    while ( abs($scalar) > 1000 ) { $scalar /= 1000; $e += 3; }
    while ( $scalar and abs($scalar) < 1 ) {$scalar*=1000;$e-=3}

    # round the number to the right number of digits with sprintf
    if (exists $prefixes{$e}) {
        $d -= ceil(log($scalar)/log(10));
        $d = 0 if $d < 0;
        my $a = sprintf("%s%.${d}f", $neg, $scalar);
        return $a.$prefixes{$e}.$unit;
    } else {
        return sprintf("%s%${d}e", $neg, $scalar).$unit;
    }

