R_Jz:



 - K: mash #c CURVEd FOOD
   n_D:
     yJ: |
       'mash bluerug eyenest'
     curves: |
          zoom 0 0.570
          y 0 0
          x 0 0.5
          #x 0.1 0.46
          curve 0.3 -0.041
     up: | #
       my $he = 0.05;
       Rw ii/Jhead + 0.03 $out=0.05;
       
       J.cv = 16;

       my $onl = Rw very + $J:J.on $in=0.2 $out=0.9 $tot:J.cv;

       for my $x (@$onl) {
           Rw ix/suro + $x;
       }
       sayre "==\nASH delt ASH ".F_delta."\n==";
 - K: eyenest #c
   n_D:
     ines: | # inness vines
       my $J = J.on;
       if (my $r = ar.r) {
           Rw inesto $J $r;
       }
       my $tl = Rw tlv $J:J.on;
       for my $l (@$tl) {
           sayyl "l.j.r     ";
           sayre ki l.sc;
           if (l.j.l eq 'u') {
               Rw delbbl $J $l=u;
           }
       }
       3
 - K: Wdo #c
   D: |
       my $tl = Rw tlv $J:J.oJ.on;
       
       my $M = [];
       for my $l (@$tl) {
           my $d;
           d.t = l.j.l;
           d.y = '';
           d.c = l.j.s;
           d.sc = l.sc;
           
           sayyl "d.t         d.c           ".ki d.sc;
           
           for my $n (sort keys %$d) {
               my $s = $d->{$n};
               if (ref $s eq 'HASH') {
                   my @h;
                   for my $k (sort keys %$s) {
                       my $v = $s->{$k};
                       if (ref $v || $v =~ /[,\n:}]/) {
                           sayre "cannot down d.t  d_${n}_$k = $v";
                       }
                       else {
                           push @h, $k.':'.$v;
                       }
                   }
                   $d->{$n} = '{'.join(',',@h).'}';
               }
               elsif (ref $s) {
                   sayre "cannot down d.t  d_$n = $s";
                   $d->{$n} = '';
               }
               else {
               }
           }
           push @$M, [d.t, d.y, d.c, d.sc];
       }
       my $n = 'wormhole/the'.J.nam;
       $n .= '-'.ar.m->[0] if ar.m && @{ar.m};
       my $s = ejson $M;
       fspu $n, $s;
       sayyl "Made $n ::: ".@$M." lines ::: ".slim 64, $s;
       
       
 - K: oats #c CURVE curver
   n_D:
     yJ: |
       'oats fiz_ave oci eyenest'
     curves: |
         zoom 0   0.8
         spun 0   2
         y 0 0.05
         x 0 0.05
         curve 0.1 -0.111
     up: |
       Rw ii/Jhead + 0.03 $out=0.05;
       
       
       my $onl = Rw very + $J:J.on $in=0.2 $out=0.9 $tot=14;

       for my $x (@$onl) {
           Rw ix/suro + $x;
       }
       sayre "==\nASH delt ASH ".F_delta."\n==";
       
       Rwyl 1 oats/in;
     in: |
       
 - K: intoo #c
   D: |
     #die J2.most.J->pi ."          ".wdump ;
     my $x = J2.d.c.s;
     my $on = x.j.b.b.j;
 - K: inesto #c in J.on, throwing $r down
   D: |
     my $d;
     d.s = r.i;
     d.sc = r.sc;
     
     sayyl sort keys %{J.bb};
     
     die "inesto ref in: ".gp d.s if ref d.s;
     
     if (d.sc.ou eq 'image') {
         if (d.s =~ /^(.+)\/([^\/]+)\/([^\/]+)(?:\.([^\/\.]+))?$/) {
             d.t = "$2/$3";
         }
     }
     d.t ||= d.s if !ref d.s;
     # TODO make safe IDish munge of the d.t
     d.t ||= 'u';
     # Jn(d.t, '', d.s, d.sc); # TODO that easy
     sayyl "inesto ".gp($J)."       ".gp(d.t)."      d.s  ".ki r.sc;
     
      J bz d.t 0.1 d.s
      
      for (sort keys %{r.sc||{}}) {
           sayre "d.t      = = the $_    is r.sc->{$_}";
           J bz d.t%$_ 0.1 r.sc->{$_}
      }
      
     #J.on bz u 0.1 $i
     # J.on bz u%ori 0.1 J.onei.i
     # J.on bz u%travely 0.1 J.onei.t
 - K: occie #c style komerp # occasional (page) global aggregate
   babz:
     'maka 6.1': |
       if (1) {
           my (@css, @class);
           my $fat = sum map { length $_ } @$css;
           for my $cs (@$css) {
               G.jumb.occie->{$cs}++; #<in
               if (my $out = G.yomp.occie->{$cs}) {
                      push @class, $out;
               }
               else {
                   push @css, $cs;
               }
           }
           my $csin = sum map { length $_ } @css;
           my $clin = sum map { length $_ } @class;
           #sayyl "Komp: $fat -> $csin      $clin"  if 4.97 < rand 5;
           at.class = join' ',@class if @class;
           # and redo:
           at.style = join '', map{"$_;"}
           grep{defined} map { split ';' } @css;
       }
   n_D:
     yJ: |
       'occie'
     around: |
       # really whenever bored, busied, and in the 7 of anything big/strange/initial
       G.oin.bz->("J.name%wantime\t0.3" => 40);
       Rw up;
     up: |
       my $sty_y = sub {
           my $sty = shift;
           my ($heex) = $H->dig($sty) =~ /^(........)/;
           $heex =~ tr/0123456789/ghijklmnop/; # no numbers
           my @s;
           push @s, $1 while $heex =~ s/^(..)//;
           @s = map {
               my ($o,$t) = /^(.)(.)$/;
               $t = chr ord($t) + 10 if $o =~ /[g-p]/;
               $t;
           } @s;
           join'',@s
       };
     
       my $t = 'occie';
       my $pool = G.jumb->{$t} || return;
      
       my @pool = map { { of => $_, sc => $pool->{$_} } } sort keys %$pool;
      
      
       my @order = reverse sort { a.sc <=> b.sc } @pool;
      
       my $Y = {};
       
       my $limit = 100;
       my $aimit = @order / 1.2;
       for my $o (@order) {
           last if o.sc < 5;
           next if o.of eq '';
           # pha oras ratio ^ rolling
           
           last if $limit-- < 1;
           last if $aimit-- < 1;
           
           my $sty = join('', map{"$_;"} grep{defined} split ';', o.of)
           || die "of tiny: ".wdump($o);
           
           my $y = $sty_y->($sty);
           $Y->{$y} = $sty;
       }
       
       my $oY = {reverse %{G.yomp->{$t}}};
       if (keys %$oY < 500) { # roll time, may appends...
           $Y->{$_} = $oY->{$_} for keys %$oY;
       }
       if (!keys %$Y) {
           return sayre "NOTHING TO COMPRESS";
       }
       
       G.yomp->{$t} = {reverse %$Y};
       
       my $oJ = Rw oJ sts;
       Rw sts/tY $J:oJ $t $Y;
       sayyl "occie - ".F_delta;
 - K: sts #c
   n_D:
     yJ: |
       'sts mayo';
     up: |
       my $tw = Rw huck */stylesheet;
       while (my($t,$w) = each %$tw) {
           my ($Y) = @$w;
           Rw sts/tY $J $t $Y;
       }
     tY: | # eat
       my $was = J.bb->{"$t\t0.3"};
       
       my $is = join "\n", map {
          (/ /?'':'.')."$_ { $Y->{$_} }"
       } sort keys %$Y;
       $is .= "\n";
       
       if ($was ne $is) {
           Jn($t => 0.3 => $is, {st=>1});
           Rw out $J;
       }
     stylesheet: | #
       my $Y = Load(<<'');
        - K: nopoi # outer
          css: [pointer-events:none]
        - K: poi
          css: [pointer-events:all]
        - K: OxO
          styles: ab
          css: [height:100%, width:100%]
        - K: ab
          css: [position:absolute]
        - K: rel
          css: 
            - position:relative
        - K: X
          css:
            - position:relative
            - width:100%
            - height:100%
        - K: NZ
          css: []
          classy: hidden until its brought into the web
        - K: z
          css: []
          classy: to bring into the web
        - K: ux *
          css: [pointer-events:all, z-index:100]


       $Y = {map {
           _.K => join '', map { "$_;" } @{_.css}
       } @$Y};
       
       $Y
          
 - K: dolphy #c
   D: |
     my $tvs = w $R ytv[$J];
     
     my $phi_n = 1;
     map { $phi_n++ } map { @$_ } values %$tvs;
     my $phia = {n=>$phi_n};
     phia.ai = 0.06;
     phia.modi = { map { $_ => 0.5 } 18..$phi_n };
     my $where = w $R phi(%$phia);
     
       #sayyl "!\n";
       
     for my $jkv (sort keys %$tvs) { 
         #sayyl "at $jkv";
         for my $j (@{$tvs->{$jkv}}) {
             #sayyl "    It's j.t !";
             my $whe = shift @$where;
             $whe || die "out of spiral!";
             
             J.bz->(j.t."%css#phi"."\t".j.cv =>
               'position:absolute;'
               .'top:'.whe.x.'%;'
               .'left:'.whe.y.'%;'
               .'-webkit-transform:rotate('.whe.radial.'rad);'
               .'transform-origin:-10% -10%;' # animate that bit
             ); 
             J.bz->(j.t."%tt#phiro"."\t".j.cv => "^".whe.angle);
             # + font-size fit + whe.angle
         }
     }
       #sayyl "!\n";
 
 - K: phi #c re/progressive proJammable petalis
   D: |
     my $n = ar.n || 9;
          my $width = 100;
          my $height = 100;
          my $cx = $width / 2;
          my $cy = $height / 2;
          my $lg_diam = $width * 0.85;
          my $lg_rad = $lg_diam / 2; 
          my $outer_rad = $width*0.45;
          my $angle_incr = ar.ai || 9 / $n;
          
          my $xy = [];
          for my $i (1..$n) {
              my $ratio = $i/$n;
              my $spiral_rad = ($ratio *1.3) * $outer_rad;
              my $angi = $angle_incr + 0.15;
              $angi *= ar.modi->{$i} if ar.modi->{$i};
              my $angle = 1.2+$i*$angi;
              my $x = $cx + cos($angle) * $spiral_rad;
              my $y = $cy + sin($angle) * $spiral_rad;
              push @$xy, {
                  radial => sprintf('%.2f', atan2($x - $cx, $y - $cy)),
                  angle => sprintf('%.3f', $angle),
                  x => sprintf('%.2f', $x),
                  y => sprintf('%.2f', $y),
              };
          }
          $xy

