R_Jz:
 - K: mash #c CURVEd FOOD
   n_D:
     yJup: |
       'mash oci bluerug'
     curves: |
          zoom 0 0.570
          y 0 0
          x 0 0.5
          #x 0.1 0.46
          curve 0.3 -0.041
     mods:
        - 
          - sq
          - 10
          - s: 22
            fs: 7_3
            cow: rg 34f
          - blr: 3
            ml: 1em
     up: | #c
       my $he = 0.05;
       Rw ii/Jhead + 0.03 $out=0.05;
       #Rw ii/ornate + $in:he;
       
       Jn(eW => 0.1112, {s=>'eW',pwth=>'mash/down'}, {fs=>'25'});

       my $onl = Rw very + $J:J.on $in=0.2 $out=0.9 $tot=16;

       for my $x (@$onl) {
           Rw ix/suro + $x;
       }
       sayre "==\nASH delt ASH ".F_delta."\n==";
     down: | #c
       w demux[$J];
       my $tl = Rw tlv $J:J.on;
       
       
       my $m = [];
       for my $l (@$tl) {
           say wdump [l.j.l, '', l.j.s, l.sc];
       }
       $m = ejson $m;
       
       
     ines: | #c inness vines
       my $J = J.on;
       if (my $r = ar.r) {
           Rw inesto $J $r;
       }
       my $tl = Rw tlv $J:J.on;
       for my $l (@$tl) {
           sayyl "l.j.r     ";
           sayre ki l.sc;
           if (l.j.l eq 'u') {
               delete J.bb->{_.r} for l.j, values %{l.sj}
           }
       }
       3
 - K: intoo #c
   D: |
     #die J2.Jmost->pi ."          ".wdump ;
     my $x = J2.d.c.s;
     my $on = x.j.b.b.j;
     die wdump 2, $x;
 - K: inesto #c in J.on, throwing $r down
   D: |
     my $d;
     d.s = r.i;
     d.sc = r.sc;
     
     sayyl sort keys %{J.bb};
     
     warn "inesto ref in: ".gp d.s if ref d.s;
     
     if (d.sc.ou eq 'image') {
         if (d.s =~ /^(.+)\/([^\/]+)\/([^\/]+)(?:\.([^\/\.]+))?$/) {
             d.t = "$2/$3";
         }
         d.t ||= d.s if !ref d.s;
     }
     # TODO make safe IDish munge of the d.t
     d.t ||= 'u';
     # Jn(d.t, '', d.s, d.sc); # TODO that easy
     sayyl "inesto ".gp($J)."       ".gp(d.t)."      d.s  ".ki r.sc;
     
      J bz d.t 0.1 d.s
      
      for (sort keys %{r.sc||{}}) {
           sayre "d.t      = = the $_    is r.sc->{$_}";
           J bz d.t%$_ 0.1 r.sc->{$_}
      }
      
     #J.on bz u 0.1 $i
     # J.on bz u%ori 0.1 J.onei.i
     # J.on bz u%travely 0.1 J.onei.t
 - K: stylesheets #c
   n_D:
     any_init: |
       Rwyl stylesheets/of;
     of: |
       my $tw = Rw huck */stylesheet;

       while (my($t,$w) = each %$tw) {
           my $as = {K=>'style', B=>{am=>$t}};
          my $u = w G.R fuu(u=>$as);
          my $was = u.sheet;   
          u.sheet = join "\n",@$w;
          
          die $u if !$u;

          w mux[$u] if u.sheet ne $was;
       }
     stylesheet: | #c
       my $Y = Load(<<'');
        - K: te # yer standard thing
          css: 
            - border-bottom:1px solid black
            - padding-left:2em
            - float:left
            - position:relative
            - width:calc(100% - 2em)
            - background:rgba(150,100,50,0.1)
        - K: tu # without indentation, more normal
          css: 
            - border-bottom:1px solid black
            - float:left
            - position:relative
            - width:100%
            - background:rgba(150,100,50,0.1)
        - K: nopoi # outer
          css: [pointer-events:none]
        - K: poi
          css: [pointer-events:all]
        - K: OxO
          styles: ab
          css: [height:100%, width:100%]
        - K: ab
          css: [position:absolute]
        - K: rel
          css: 
            - position:relative
        - K: X
          css:
            - position:relative
            - width:100%
            - height:100%
        - K: NZ
          css: []
          classy: hidden until its brought into the web
        - K: z
          css: []
          classy: to bring into the web


       $Y = {map {
           _.K => join '', map { "$_;" } @{_.css}
       } @$Y};
       
       my $stuff = Rw sheep $Y;
       $stuff.
       'ux * {pointer-events: all;z-index:100}';
          
 - K: occie #c style komerp # occasional (page) global aggregate
   spesh: 0
   babz:
     'maka 6.1': |
       if (1) {
           my (@css, @class);
           my $fat = sum map { length $_ } @$css;
           for my $cs (@$css) {
               G.jumb.occie->{$cs}++; #<in
               if (my $out = G.yomp.occie->{$cs}) {
                      push @class, $out;
               }
               else {
                   push @css, $cs;
               }
           }
           my $csin = sum map { length $_ } @css;
           my $clin = sum map { length $_ } @class;
           #sayyl "Komp: $fat -> $csin      $clin"  if 4.97 < rand 5;
           at.class = join' ',@class if @class;
           # and redo:
           at.style = join '', map{"$_;"}
           grep{defined} map { split ';' } @css;
       }
   n_D:
     fresh_init: |
       # really whenever bored
       timer 7 { w $R occie/komp; };
       recur 40 { w $R occie/komp; };
     styleshout: |
       # entropia & komp
     komp: |
       return unless G.jumb.occie;
       my $u = Rw hamz style occie;
       Rw toof + $u occie;
 - K: toof #c html styleshootout
   D: |
      my $c = shift @$m;
      $u || die "look for u>?"; 
      
      my $pool = G.jumb->{$c};
      
      my @pool = map { { of => $_, sc => $pool->{$_} } } sort keys %$pool;
      
      
      my @order = reverse sort { a.sc <=> b.sc } @pool;
      
      my $komp = u.komp ||= {}; # back/forward
      
      my $limit = 100;
      my $aimit = @order / 1.2;
      for my $o (@order) {
          last if o.sc < 5;
          next if o.of eq '';
          # pha oras ratio ^ rolling
          
          last if $limit-- < 1;
          last if $aimit-- < 1;
          
          my $sty = join('', map{"$_;"} grep{defined} split ';', o.of)
          || die "of tiny: ".wdump($o);
          
          my ($heex) = $H->dig($sty) =~ /^(...)/;
          $heex =~ tr/0123456789/ghijklmnop/; # no numbers
          # TODO name it
          my $y = "s".$heex;
          $komp->{$y} = $sty;
      }
      
      my $wi = keys %$komp;
      $wi || return sayre "NOTHING TO COMPRESS";
      #sayyl "toof $c compressed ".@pool." to $wi";

      # komp carbonises, makes up style
      G.yomp->{$c} = {reverse %$komp};

      # ^ to maka, draws in
      # v to elvis, draws out
      
      
      my $was = u.sheet;
      u.sheet = Rw sheep $Y:komp;

      w mux[$u] if u.sheet ne $was;
 - K: sheep #c html stylesheet Y
   D: |
     join "\n", map { ".$_ { $Y->{$_} }" } sort keys %$Y;
 - K: dolphy #c
   D: |
     my $tvs = w $R ytv[$J];
     
     my $phi_n = 1;
     map { $phi_n++ } map { @$_ } values %$tvs;
     my $phia = {n=>$phi_n};
     phia.ai = 0.06;
     phia.modi = { map { $_ => 0.5 } 18..$phi_n };
     my $where = w $R phi(%$phia);
     
       #sayyl "!\n";
       
     for my $jkv (sort keys %$tvs) { 
         #sayyl "at $jkv";
         for my $j (@{$tvs->{$jkv}}) {
             #sayyl "    It's j.t !";
             my $whe = shift @$where;
             $whe || die "out of spiral!";
             
             J.bz->(j.t."%css#phi"."\t".j.cv =>
               'position:absolute;'
               .'top:'.whe.x.'%;'
               .'left:'.whe.y.'%;'
               .'-webkit-transform:rotate('.whe.radial.'rad);'
               .'transform-origin:-10% -10%;' # animate that bit
             ); 
             J.bz->(j.t."%tt#phiro"."\t".j.cv => "^".whe.angle);
             # + font-size fit + whe.angle
         }
     }
       #sayyl "!\n";
 
 - K: phi #c re/progressive proJammable petalis
   D: |
     my $n = ar.n || 9;
          my $width = 100;
          my $height = 100;
          my $cx = $width / 2;
          my $cy = $height / 2;
          my $lg_diam = $width * 0.85;
          my $lg_rad = $lg_diam / 2; 
          my $outer_rad = $width*0.45;
          my $angle_incr = ar.ai || 9 / $n;
          
          my $xy = [];
          for my $i (1..$n) {
              my $ratio = $i/$n;
              my $spiral_rad = ($ratio *1.3) * $outer_rad;
              my $angi = $angle_incr + 0.15;
              $angi *= ar.modi->{$i} if ar.modi->{$i};
              my $angle = 1.2+$i*$angi;
              my $x = $cx + cos($angle) * $spiral_rad;
              my $y = $cy + sin($angle) * $spiral_rad;
              push @$xy, {
                  radial => sprintf('%.2f', atan2($x - $cx, $y - $cy)),
                  angle => sprintf('%.3f', $angle),
                  x => sprintf('%.2f', $x),
                  y => sprintf('%.2f', $y),
              };
          }
          $xy

