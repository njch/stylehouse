
R_Jz:
 - K: empc #c
   D: |
     $v .= 'em' if $v !~ /(%|em|px)/;
     
esc c:
 - K: sha #c it
   esc 3: |
     my @m = split m/\s/, $v;
     $m[-1] = X.cole->($m[-1]);
     sprintf 'text-shadow:%dpx %dpx %dpx %s', @m;
 - K: cole #c it
   esc 3: |
        my $h;
        (h.r, h.g, h.b, h.a) = ($1, $2, $3, $4)
                  if $v =~ /^(\w)(\w)(\w)(\w)?$/ || die "not cole: $v";
        
        if (defined h.a) {
           # do an rgba(255,255,255,1)
           for my $k (qw'r g b a') {
               my $e = $h->{$k};
               $e = "$e$e" if length $e == 1; # out of 255
               $h->{$k} = hex $e;
           }
           h.la = sprintf '%.2f', h.la / 255; # out of 1
           return "rgba(h.r,h.g,h.b,h.a)";
        }
        else {
           return sprintf "#%s%s%s", h.r, h.g, h.b;
        }
 - K: hsle #c ray lih, unhassley
   esc 3: |
        my $h;
        if ($v =~ /^(\S+) (\S+) (\S+)(?: (\S+))?$/) {
            (h.h, h.s, h.l, h.a) = ($1, $2, $3, $4);
        }
        elsif ($v =~ /^(\d+)\.(\d+)\.(\d+)(?:\.(\d+))?$/) {
            (h.h, h.s, h.l, h.a) = ('0.'.$1, '0.'.$2, '0.'.$3, '0.'.$4);
        }
        else {
            die "not hsle : $v";
        }
        h.h = h.h * 360 if h.h < 1;
        $h->{$_} = ($h->{$_}*100).'%' for 's','l';
        
        my $al = ", h.a" if defined h.a;
        "hsl".($al?'a':'')."(h.h, h.s, h.l$al)";
        # 1423
     
 - K: zi #c ground
   esc 3: |
     "z-index:".$v
 - K: zip #c it alley, primary
   esc 3: |
     "z-index:".(10+$v)
 - K: zis #c suuuuuu
   esc 3: |
     "z-index:".(20+$v)
 - K: co #c it
   esc 3: |
     "color:".X.cole->($v);
 - K: hs #c it
   esc 3: |
     "color:".X.hsle->($v);
 - K: fs #c it
   esc 3: |
     $v *= 9;
     'font-size:'.int($v).'%';
 - K: ws #c it
   esc 3: |
     my @wtf;
     push @wtf, 'white-space:pre' if $v =~ /p/;
     push @wtf, 'white-space:nowrap' if $v =~ /n/;
     die "many :  @wtf       from $v" if @wtf > 1;
     join ';', @wtf;
 - K: blr #c it
   esc 3: |
     '-webkit-filter:blur('.$v.'px)'
 - K: ml #c it
   esc 3: |
     $v = Rw empc $v;
     "margin-left:$v"
 - K: mr #c it
   esc 3: |
     $v = Rw empc $v;
     "margin-right:$v"
 - K: mt #c it
   esc 3: |
     $v = Rw empc $v;
     "margin-top:$v"
 - K: mb #c it
   esc 3: |
     $v = Rw empc $v;
     "margin-bottom:$v"
 - K: ab #c solute
   esc 3.3: |
     if ($v =~ /^(\S+:\S+)( \S+:\S+)*$/) {
         my @se = split ' ', $v;
         for (@se) {
             /^(\S+):(\S+)$/;
             $tks->{$1}->{abc} = $2;
         }
         $v = 1;
     }
     elsif ($v ne '1') {
         die "whatab:$v";
     }
     $v = "absolute" if $v eq '1';
     "position:$v";
 - K: right #c yep
   esc 3.4: |
     "right:$v";
 - K: left #c yep
   esc 3.4: |
     "left:$v"
 - K: top #c yep
   esc 3.4: |
     "top:$v"
 - K: bottom #c yep
   esc 3.4: |
     "bottom:$v"
 - K: mw #c y
   esc 3.4: |
     "max-width:$v"
 - K: miw #c y
   esc 3.4: |
     "min-width:$v"
 - K: width #c y
   esc 3.4: |
     "width:$v"
 - K: over #c y 
   esc 3.4: |
     "overflow:$v"

