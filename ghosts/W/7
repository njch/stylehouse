
R_Jz:
 - K: empc #c
   D: |
     $v .= 'em' if $v !~ /(%|em|px)/;
     $v;
 - K: esc #c espouse ton carbon product
   n_D:
     el:
       CARBON: | #c
         {droplist => 'O', subhash => 'X'} # qmco:sutff
         # different rhythms to qw == hallucinogenic yaml
     dosc: | #c
       delete G.drop.esc;
       Rw Con esc;
     u: | #c around
       # so '.this > .that' can move to '.another > .that' bunch of styles
       # lending to high dynamic, low cost of tape
       
       my $seg = ar.m->[0] if ar.m;
       my @css;
       die "nonrefsc u asc esc usc". wdump(ar.m) if !ref $sc; # parse strings too
       # invent the stevecraig format, playing music
       # YIN
       
       # ^ list esc.O
       my $tks; # expand (k:)?lma:v to lma:k:v
       for my $k (sort keys %$sc) {
           my $v = $sc->{$k};
           my $com = ref $v eq 'HASH' ? $k : '';
           my $t = ref $v eq 'HASH' ? $v : {$k=>$v};
           
           for my $tk (sort keys %$t) {
               $tks->{$tk}->{$com} = $t->{$tk};
           }
       }
       
       my $unseen = {map{$_=>1}keys%$tks};
       my $tw; # bang
       for my $tk (@{G.drop.esc.O}) {
           my $oms = $tks->{$tk};
           delete $unseen->{$tk};
           next if !$oms;
           for my $com (sort keys %$oms) {
               my $v = $oms->{$com};
               
               my @s = $X->{$tk}->($v, $tks, $X); # < $mish carbon adapt
               # could be a big...
               # tks for X to inject this stream: lma:k:v style (com is k)
               # make better looking pyramids
               
               unshift @s, '%css' if @s == 1;
               while (@s) {
                   my $sty = shift @s;
                   my $s = shift @s;
                   die "$com $sty all3    @s"
                       if defined $tw->{$com}->{$tk}->{$sty};
                       
                   $tw->{$com}->{$tk}->{$sty} = $s;
               }
           }
       }
       die "invent ".join' & ', keys %$unseen if keys %$unseen;
       
       for my $com (sort keys %$tw) {
           my $tks = $tw->{$com};
           for my $tk (sort keys %$tks) {
               my $stys = $tks->{$tk};
               for my $sty (sort keys %$stys) {
                   my $s = $stys->{$sty};
                   #say " ghave $com $sty => $s";
                   $sty .= "#".join('-', grep{$_} $seg, $com, $tk)
                       unless $sty =~ /#/;
                   push @css, $sty => $s;
               }
           }
       }
       #sayre "CSS  @css";
       @css;
       

esc c:
 - K: mktk #c language expansion
   esc 3: |
     my ($tks, $name, $s) = @_;
     my $name = ar.m && ar.m->[0] || "langsp";
     my @t = split ',', $s;
     my $t = {};
     for (@t) {
         my ($k, $v) = split ':', $_;
         $tks->{$k}->{$name} = $v;
         # or rejoint another trip to $k if passed...
         #sayyl "mktk $name $k : $v";
     }
     return;
 - K: ab #c absolute # ORDER uglies
   esc 3.3: |
     if ($v =~ /^.+:.+/) {
         X.mktk->($tks, abc => $v);
         $v = 1;
     }
     elsif ($v ne '1') {
         die "whatab:$v";
     }
     $v = "absolute" if $v eq '1';
     "position:$v";
 - K: at #c
   esc 3: |
     my @ats;
     while (my ($k,$v) = each %$v) {
         push @ats, '%at:'.$k, $v;
     }
     @ats
 - K: tag #c
   esc 3: |
     '%tag' => $v
 - K: sha #c it
   esc 3: |
     my @m = split m/\s/, $v;
     $m[-1] = X.cole->($m[-1]);
     sprintf 'text-shadow:%dpx %dpx %dpx %s', @m;
 - K: cole #c it
   esc 3: |
        my $h;
        (h.r, h.g, h.b, h.a) = ($1, $2, $3, $4)
                  if $v =~ /^(\w)(\w)(\w)(\w)?$/ || die "not cole: $v";
        
        if (defined h.a) {
           # do an rgba(255,255,255,1)
           for my $k (qw'r g b a') {
               my $e = $h->{$k};
               $e = "$e$e" if length $e == 1; # out of 255
               $h->{$k} = hex $e;
           }
           h.la = sprintf '%.2f', h.la / 255; # out of 1
           return "rgba(h.r,h.g,h.b,h.a)";
        }
        else {
           return sprintf "#%s%s%s", h.r, h.g, h.b;
        }
 - K: hsle #c ray lih, unhassley
   esc 3: |
        my $h;
        if ($v =~ /^(\S+) (\S+) (\S+)(?: (\S+))?$/) {
            (h.h, h.s, h.l, h.a) = ($1, $2, $3, $4);
        }
        elsif ($v =~ /^(\d+)\.(\d+)\.(\d+)(?:\.(\d+))?$/) {
            (h.h, h.s, h.l, h.a) = ('0.'.$1, '0.'.$2, '0.'.$3, '0.'.$4);
        }
        else {
            die "not hsle : $v";
        }
        h.h = h.h * 360 if h.h < 1;
        $h->{$_} = ($h->{$_}*100).'%' for 's','l';
        
        my $al = ", h.a" if defined h.a;
        "hsl".($al?'a':'')."(h.h, h.s, h.l$al)";
        # 1423
     
 - K: zi #c ground
   esc 3: |
     "z-index:".$v
 - K: zip #c it alley, primary
   esc 3: |
     "z-index:".(10+$v)
 - K: zis #c suuuuuu
   esc 3: |
     "z-index:".(20+$v)
 - K: co #c it
   esc 3: |
     "color:".X.cole->($v);
 - K: hs #c color: hsla
   esc 3: |
     "color:".X.hsle->($v);
 - K: bgi #c background image
   esc 3.2: |
     "background-image:url('$v')";
 - K: fs #c it
   esc 3: |
     $v *= 9;
     'font-size:'.int($v).'%';
 - K: fw #c it
   esc 3.5: |
     'font-weight:'.int($v*100);
 - K: ws #c it
   esc 3: |
     my @wtf;
     push @wtf, 'white-space:pre' if $v =~ /p/;
     push @wtf, 'white-space:nowrap' if $v =~ /n/;
     die "many :  @wtf       from $v" if @wtf > 1;
     join ';', @wtf;
 - K: opa #c seetrhu
   esc 3: |
     "opacity:$v"
 - K: tr #c filterszzzz weird style using com to agg.
   esc 3.7: |
     return '' if tks.tr.comp;
     my @f;
     for (qw(rotate )) {
         my $v = tks.tr->{$_};
         defined $v || next;
         push @f, "$_($v)";
     }
     tks.tr.comp = '-webkit-transform:'.join' ', @f
 - K: rad #c radial tr
   esc 3.6: |
     tks.tr.rotate = $v.'rad'
 - K: fl #c filterszzzz weird style using com to agg.
   esc 3.7: |
     return '' if tks.fl.comp;
     my @f;
     for (qw(blur saturate contrast brightness hue-rotate sepia invert grayscale )) {
         my $v = tks.fl->{$_};
         defined $v || next;
         push @f, "$_($v)";
     }
     tks.fl.comp = '-webkit-filter:'.join' ', @f
 - K: blr #c it
   esc 3.6: |
     tks.fl.blur = $v.'px'
 - K: sat #c it saturation
   esc 3.6: |
     tks.fl.saturate = $v
 - K: con #c it contrast
   esc 3.6: |
     tks.fl.contrast = $v
 - K: bri #c it bright
   esc 3.6: |
     tks.fl.brightness = $v
 - K: hue #c it bright
   esc 3.6: |
     tks.fl->{'hue-rotate'} = $v.'deg';
 - K: sep #c it old
   esc 3.6: |
     tks.fl.sepia = $v
 - K: inv #c it old
   esc 3.6: |
     tks.fl.invert = $v
 - K: gray #c it old
   esc 3.6: |
     tks.fl.grayscale = $v
 - K: ml #c it
   esc 3: |
     $v = Rw empc $v;
     "margin-left:$v"
 - K: mr #c it
   esc 3: |
     $v = Rw empc $v;
     "margin-right:$v"
 - K: mt #c it
   esc 3: |
     $v = Rw empc $v;
     "margin-top:$v";
 - K: mb #c it
   esc 3: |
     $v = Rw empc $v;
     "margin-bottom:$v"
 - K: right #c yep
   esc 3.4: |
     "right:$v";
 - K: left #c yep
   esc 3.4: |
     "left:$v"
 - K: top #c yep
   esc 3.4: |
     "top:$v"
 - K: bottom #c yep
   esc 3.4: |
     "bottom:$v"
 - K: mw #c y
   esc 3.4: |
     "max-width:$v"
 - K: miw #c y
   esc 3.4: |
     "min-width:$v"
 - K: width #c y
   esc 3.4: |
     "width:$v"
 - K: height #c y
   esc 3.4: |
     "height:$v"
 - K: over #c y 
   esc 3.4: |
     "overflow:$v"
 - K: float #c y 
   esc 3.4: |
     "float:$v"
 - K: bo #c border
   esc 3.4: |
     "border:$v"

