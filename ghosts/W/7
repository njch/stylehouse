
R_Jz:
 - K: empc #c
   D: |
     $v .= 'em' if $v !~ /(%|em|px)/;
     $v;

 - K: C_esc #c espouse ton carbon product - hanging around the mods too...
   n_D:
     el:
       CARBON: | #
         {droplist => 'O', subhash => 'X'} # qmco:sutff
         # different rhythms to qw == hallucinogenic yaml
     u: | # around
       # so '.this > .that' can move to '.another > .that' bunch of styles
       # lending to high dynamic, low cost of tape
       # invent the stevecraig format, playing music
       # this chunk could embed, gravuity
       # a meeting of spaceships of an astral body
       # G net tks
       my $seg = ar.m->[0] if ar.m;
       
       die "nonrefsc" if !ref $sc; # parse strings too
       
       # YIN
       
       my $tks = Rw sctks $sc;
       my $styles = G.drop.esc.O;
       my $it = Rw scitl $X $tks $styles;
       
       my $tw; # bang
       while (1) {
           my ($tk, $com, $v, $tks) = $it->();
           $tk || last;
           
           my @s = $X->{$tk}->($v, $tks, $X);
           
           @s = ('%css' => @s) if @s == 1;
           while (@s) {
               my $sty = shift @s;
               my $s = shift @s;
               die $sty if $sty !~ /^%/;
               #
               warn "$com $sty ----> $s  all3    @s"
                   if defined $tw->{$com}->{$tk}->{$sty};
               $tw->{$com}->{$tk}->{$sty} = $s;
           }
           
       }
       
       my @css;
       for my $com (sort keys %$tw) {
           my $tks = $tw->{$com};
           for my $tk (sort keys %$tks) {
               my $stys = $tks->{$tk};
               for my $sty (sort keys %$stys) {
                   my $s = $stys->{$sty};
                   #say " ghave $com $sty => $s";
                   $sty .= "#".join('-', grep{$_} $seg, $com, $tk)
                       unless $sty =~ /#/;
                   push @css, $sty => $s;
               }
           }
       }
       #sayre "CSS  @css";
       @css;
       
C esc:
 - #c STASHINGS
  - jsc # some compression
  - 3
  - |
     '%jsc'=>$v
 -
  - argzs # some compression pattern
  - 3
  - |
     '%argzs'=>$v

 -
  - FLYING #
  - 3
  - |
    #warn "all these were flying: ".wdump $v;
    my @style;
    for my $lma (sort keys %$v) {
        my $lm = $v->{$lma};
        for my $com (sort keys %$lm) {
            my $y = join '#', grep {length} $lma, $com;
            #sayre "making %"."$y => $lm->{$com}";
            push @style, '%'.$y => $lm->{$com};
        }
    }
    @style;
 -
  - mktk # language expansion
  - 3
  - |
     my ($tiks, $name, $s) = @_;
     #my $name = ar.m && ar.m->[0] || "langsp";
     my @t = split ',', $s;
     my $t = {};
     for (@t) {
         my ($k, $v) = split ':', $_;
         $tiks->{$k}->{$name} = $v;
         # or rejoint another trip to $k if passed...
         #sayyl "mktk $name $k : $v";
     }
     return;
 -
  - ab # absolute # ORDER uglies
  - 3.3
  - |
     $v = 'width:100%,height:100%' if $v eq '100';
     if ($v =~ /^.+:.+/) {
         X.mktk->($tks, abc => $v);
         $v = 1;
     }
     elsif ($v ne '1') {
         die "whatab:$v";
     }
     $v = "absolute" if $v eq '1';
     "position:$v";
 -
  - deco # splurge many, get this pipe sorted...
  - 3.2
  - |
     "text-decoration:underline";
 -
  - poi # pointer-events
  - 3.2
  - |
     "pointer-events:".($v =~ /^(1|a)$/ ? 'all' : 'none');
 -
  - at #
  - 3
  - |
     my @ats;
     while (my ($k,$v) = each %$v) {
         push @ats, '%at:'.$k, $v;
     }
     @ats
 -
  - tag #
  - 3
  - |
     '%tag' => $v
 -
  - sha # it
  - 3
  - |
     my @m = split m/\s/, $v;
     $m[-1] = X.cole->($m[-1]);
     sprintf 'text-shadow:%dpx %dpx %dpx %s', @m;
 -
  - cole # it
  - 3
  - |
        my $h;
        (h.r, h.g, h.b, h.a) = ($1, $2, $3, $4)
                  if $v =~ /^(\w)(\w)(\w)(\w)?$/ || die "not cole: $v";
        
        if (defined h.a) {
           # do an rgba(255,255,255,1)
           for my $k (qw'r g b a') {
               my $e = $h->{$k};
               $e = "$e$e" if length $e == 1; # out of 255
               $h->{$k} = hex $e;
           }
           h.la = sprintf '%.2f', h.la / 255; # out of 1
           return "rgba(h.r,h.g,h.b,h.a)";
        }
        else {
           return sprintf "#%s%s%s", h.r, h.g, h.b;
        }
 -
  - hsle # ray lih, unhassley
  - 3
  - |
        my $h;
        if ($v =~ /^(\S+) (\S+) (\S+)(?: (\S+))?$/) {
            (h.h, h.s, h.l, h.a) = ($1, $2, $3, $4);
        }
        elsif ($v =~ /^(\d+)\.(\d+)\.(\d+)(?:\.(\d+))?$/) {
            (h.h, h.s, h.l, h.a) = ('0.'.$1, '0.'.$2, '0.'.$3, '0.'.$4);
        }
        else {
            die "not hsle : $v";
        }
        h.h = h.h * 360 if h.h < 1;
        $h->{$_} = ($h->{$_}*100).'%' for 's','l';
        
        my $al = ", h.a" if defined h.a;
        "hsl".($al?'a':'')."(h.h, h.s, h.l$al)";
        # 1423
     
 -
  - co # it
  - 3
  - |
     "color:".X.cole->($v)
 -
  - hs # color: hsla
  - 3
  - |
     "color:".X.hsle->($v)
 -
  - zi #c ground etc
  - 3
  - |
     "z-index:".$v
 -
  - zig # it alley, primary, ground
  - 3
  - |
     "z-index:".($v-20)
 -
  - zie # suuuuuu, ether
  - 3
  - |
     "z-index:".($v-10)
 -
  - bgi # background image
  - 3.2
  - |
     "background-image:url('$v')"
 -
  - bg # background something
  - 3.2
  - |
     "background:$v"
 -
  - bgh # background hsla
  - 3.2
  - |
     "background-color:".X.hsle->($v)
 -
  - fs # it
  - 3
  - |
     $v *= 9;
     'font-size:'.int($v).'%';
 -
  - fw # it
  - 3.5
  - |
     'font-weight:'.int($v*100);
 -
  - ws # it
  - 3
  - |
     my @wtf;
     push @wtf, 'white-space:pre' if $v =~ /p/;
     push @wtf, 'white-space:nowrap' if $v =~ /n/;
     die "many :  @wtf       from $v" if @wtf > 1;
     join ';', @wtf;
 -
  - opa # seetrhu
  - 3
  - |
     "opacity:$v"
 -
  - tr # filterszzzz weird style using com to agg.
  - 3.7
  - |
    '-webkit-transform:'.join' ', map {"$_($v->{$_})"} keys %$v;
 -
  - rad # radial tr
  - 3.6
  - |
     tks.tr.of.rotate = $v.'rad'
 - #c filterszzzz weird style using com to agg.
  - fl
  - 3.7
  - |
    '-webkit-filter:'.join' ', map {"$_($v->{$_})"} keys %$v;
 -
  - blr # it
  - 3.6
  - |
     tks.fl.of.blur = $v.'px'
 -
  - sat # it saturation
  - 3.6
  - |
     tks.fl.of.saturate = $v
 -
  - con # it contrast
  - 3.6
  - |
     tks.fl.of.contrast = $v
 -
  - bri # it bright
  - 3.6
  - |
     tks.fl.of.brightness = $v
 -
  - hue # it bright
  - 3.6
  - |
     tks.fl.of->{'hue-rotate'} = $v.'deg';
 -
  - sep # it old
  - 3.6
  - |
     tks.fl.of.sepia = $v
 -
  - inv # it old
  - 3.6
  - |
     tks.fl.of.invert = $v
 -
  - gray # it old
  - 3.6
  - |
     tks.fl.of.grayscale = $v
 - #c limbic space
  - empc # decide space unit TODO init soon
  - 3
  - |
     $v .= 'em' if $v !~ /(%|em|px)/;
     $v =~ s/^-?0em$/0%/;
     $v;
 -
  - ml # it
  - 3
  - |
     $v = Rw empc $v;
     "margin-left:".X.empc->($v);
 -
  - mr # it
  - 3
  - |
     $v = Rw empc $v;
     "margin-right:".X.empc->($v);
 -
  - mt # it
  - 3
  - |
     "margin-top:".X.empc->($v);
 -
  - mb # it
  - 3
  - |
     $v = Rw empc $v;
     "margin-bottom:".X.empc->($v);
 -
  - m # margrin
  - 3
  - |
     "margin:$v";
 -
  - right # yep
  - 3.4
  - |
     "right:$v";
 -
  - left # yep
  - 3.4
  - |
     "left:$v"
 -
  - top # yep
  - 3.4
  - |
     "top:$v"
 -
  - bottom # yep
  - 3.4
  - |
     "bottom:$v"
 -
  - mw # y
  - 3.4
  - |
     "max-width:$v"
 -
  - miw # y
  - 3.4
  - |
     "min-width:$v"
 -
  - width # y
  - 3.4
  - |
     "width:$v"
 -
  - height # y
  - 3.4
  - |
     "height:$v"
 -
  - over # y 
  - 3.4
  - |
     "overflow:$v"
 -
  - float # y 
  - 3.4
  - |
     "float:$v"
 -
  - bo # border
  - 3.4
  - |
     "border:$v"

