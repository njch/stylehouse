
R_Jz:
 - K: empc #c
   D: |
     $v .= 'em' if $v !~ /(%|em|px)/;
     $v;
 - K: sctks #c # expand (k:)?lma:v to lma:k:v
   D: |
     my $tks = {};
     for my $k (sort keys %$sc) {
         my $v = $sc->{$k};
         # possible extra {} level couples into com '' behind $k
         # com is for many of same styles
         my $com = ref $v eq 'HASH' ? $k : '';
         my $t = ref $v eq 'HASH' ? $v : {$k=>$v};

         for my $tk (sort keys %$t) {
             $tks->{$tk}->{$com} = $t->{$tk};
         }
     }
     $tks
     
 - K: scitl #c iterate iterations
   D: |
     my ($n,$h) = @$m;
     
     my @dl = @{G.drop->{$n}->{$h}};
     warn "nodl" if !@dl;
     my $pr = {%$tks};
     
     my $unseen = {map{$_=>1}keys%$tks};
     
     my $i = 0;
     my @om;
     sub {
         if (@om) {
             my $o = shift @om;
             return @$o;
         }
         while (1) {
             my $tk = $dl[$i];
             my $oms = delete $tks->{$tk};
             # delete so if tks come back, we repeat
             for my $com (sort keys %$oms) {
                 my $v = $oms->{$com};
                 push @om, [$tk, $com, $v, $tks];
             }
         }
     }
   
 - K: C_esc #c espouse ton carbon product
   n_D:
     el:
       CARBON: | #
         {droplist => 'O', subhash => 'X'} # qmco:sutff
         # different rhythms to qw == hallucinogenic yaml
     u: | # around
       # so '.this > .that' can move to '.another > .that' bunch of styles
       # lending to high dynamic, low cost of tape
       
       my $seg = ar.m->[0] if ar.m;
       my @css;
       die "nonrefsc u asc esc usc". wdump(ar.m) if !ref $sc; # parse strings too
       # invent the stevecraig format, playing music
       # YIN
       
       # ^ list esc.O
       # this chunk could embed, gravuity
       # a meeting of spaceships of an astral body
       my $tks = Rw sctks $sc;
       
       # G net tks
       my $it = Rw scitl $tks esc O;
       
       while (0) {
           my $it = sub{};
           my ($tk, $com, $v, $tks) = $it->();
           say " $tk, $com, $v, $tks";
           last if !$tk;
           
           my @s;#$X->{$tk}->($v, $tks, $X);
           
           @s = ('%css' => @s) if @s == 1;
           while (@s) {
               my $sty = shift @s;
               my $s = shift @s;
               #
               die "$com $sty all3    @s"
               #if defined $tw->{$com}->{$tk}->{$sty};
               #$tw->{$com}->{$tk}->{$sty} = $s;
           }
           
       }
       my $unseen = {map{$_=>1}keys%$tks};
       my $tw; # bang
       for my $tk (@{G.drop.esc.O}) {
           my $oms = $tks->{$tk};
           delete $unseen->{$tk};
           next if !$oms;
           for my $com (sort keys %$oms) {
               my $v = $oms->{$com};
               
               my @s = $X->{$tk}->($v, $tks, $X); # < $mish carbon adapt
               # could be a big...
               # tks for X to inject this stream: lma:k:v style (com is k)
               # make better looking pyramids
               
               unshift @s, '%css' if @s == 1;
               while (@s) {
                   my $sty = shift @s;
                   my $s = shift @s;
                   die "$com $sty all3    @s"
                       if defined $tw->{$com}->{$tk}->{$sty};
                       
                   $tw->{$com}->{$tk}->{$sty} = $s;
               }
           }
       }
       die "nothing esc O".wdump(2, G.drop) if !@{G.drop.esc.O};
       die "invent ".join' & ', keys %$unseen if keys %$unseen;
       
       for my $com (sort keys %$tw) {
           my $tks = $tw->{$com};
           for my $tk (sort keys %$tks) {
               my $stys = $tks->{$tk};
               for my $sty (sort keys %$stys) {
                   my $s = $stys->{$sty};
                   #say " ghave $com $sty => $s";
                   $sty .= "#".join('-', grep{$_} $seg, $com, $tk)
                       unless $sty =~ /#/;
                   push @css, $sty => $s;
               }
           }
       }
       #sayre "CSS  @css";
       @css;
       
C esc:
 -
  - jsc # some compression
  - 3
  - |
     '%jsc'=>$v
     
 -
  - mktk # language expansion
  - 3
  - |
     my ($tiks, $name, $s) = @_;
     #my $name = ar.m && ar.m->[0] || "langsp";
     my @t = split ',', $s;
     my $t = {};
     for (@t) {
         my ($k, $v) = split ':', $_;
         $tiks->{$k}->{$name} = $v;
         # or rejoint another trip to $k if passed...
         #sayyl "mktk $name $k : $v";
     }
     return;
 -
  - ab # absolute # ORDER uglies
  - 3.3
  - |
     if ($v =~ /^.+:.+/) {
         X.mktk->($tks, abc => $v);
         $v = 1;
     }
     elsif ($v ne '1') {
         die "whatab:$v";
     }
     $v = "absolute" if $v eq '1';
     "position:$v";
 -
  - deco # splurge many, get this pipe sorted...
  - 3.2
  - |
     "text-decoration:underline";
 -
  - poi # pointer-events
  - 3.2
  - |
     "pointer-events:".($v =~ /^(1|a)$/ ? 'all' : 'none');
 -
  - at #
  - 3
  - |
     my @ats;
     while (my ($k,$v) = each %$v) {
         push @ats, '%at:'.$k, $v;
     }
     @ats
 -
  - tag #
  - 3
  - |
     '%tag' => $v
 -
  - sha # it
  - 3
  - |
     my @m = split m/\s/, $v;
     $m[-1] = X.cole->($m[-1]);
     sprintf 'text-shadow:%dpx %dpx %dpx %s', @m;
 -
  - cole # it
  - 3
  - |
        my $h;
        (h.r, h.g, h.b, h.a) = ($1, $2, $3, $4)
                  if $v =~ /^(\w)(\w)(\w)(\w)?$/ || die "not cole: $v";
        
        if (defined h.a) {
           # do an rgba(255,255,255,1)
           for my $k (qw'r g b a') {
               my $e = $h->{$k};
               $e = "$e$e" if length $e == 1; # out of 255
               $h->{$k} = hex $e;
           }
           h.la = sprintf '%.2f', h.la / 255; # out of 1
           return "rgba(h.r,h.g,h.b,h.a)";
        }
        else {
           return sprintf "#%s%s%s", h.r, h.g, h.b;
        }
 -
  - hsle # ray lih, unhassley
  - 3
  - |
        my $h;
        if ($v =~ /^(\S+) (\S+) (\S+)(?: (\S+))?$/) {
            (h.h, h.s, h.l, h.a) = ($1, $2, $3, $4);
        }
        elsif ($v =~ /^(\d+)\.(\d+)\.(\d+)(?:\.(\d+))?$/) {
            (h.h, h.s, h.l, h.a) = ('0.'.$1, '0.'.$2, '0.'.$3, '0.'.$4);
        }
        else {
            die "not hsle : $v";
        }
        h.h = h.h * 360 if h.h < 1;
        $h->{$_} = ($h->{$_}*100).'%' for 's','l';
        
        my $al = ", h.a" if defined h.a;
        "hsl".($al?'a':'')."(h.h, h.s, h.l$al)";
        # 1423
     
 -
  - zi # ground
  - 3
  - |
     "z-index:".$v
 -
  - zip # it alley, primary
  - 3
  - |
     "z-index:".(10+$v)
 -
  - zis # suuuuuu
  - 3
  - |
     "z-index:".(20+$v)
 -
  - co # it
  - 3
  - |
     "color:".X.cole->($v)
 -
  - hs # color: hsla
  - 3
  - |
     "color:".X.hsle->($v)
 -
  - bgi # background image
  - 3.2
  - |
     "background-image:url('$v')"
 -
  - bg # background something
  - 3.2
  - |
     "background:$v"
 -
  - bgh # background hsla
  - 3.2
  - |
     "background-color:".X.hsle->($v)
 -
  - fs # it
  - 3
  - |
     $v *= 9;
     'font-size:'.int($v).'%';
 -
  - fw # it
  - 3.5
  - |
     'font-weight:'.int($v*100);
 -
  - ws # it
  - 3
  - |
     my @wtf;
     push @wtf, 'white-space:pre' if $v =~ /p/;
     push @wtf, 'white-space:nowrap' if $v =~ /n/;
     die "many :  @wtf       from $v" if @wtf > 1;
     join ';', @wtf;
 -
  - opa # seetrhu
  - 3
  - |
     "opacity:$v"
 -
  - tr # filterszzzz weird style using com to agg.
  - 3.7
  - |
     return '' if tks.tr.comp;
     my @f;
     for (qw(rotate )) {
         my $v = tks.tr->{$_};
         defined $v || next;
         push @f, "$_($v)";
     }
     tks.tr.comp = '-webkit-transform:'.join' ', @f
 -
  - rad # radial tr
  - 3.6
  - |
     tks.tr.rotate = $v.'rad'
 -
  - fl #c filterszzzz weird style using com to agg.
  - 3.7
  - |
     return '' if tks.fl.comp;
     my @f;
     for (qw(blur saturate contrast brightness hue-rotate sepia invert grayscale )) {
         my $v = tks.fl->{$_};
         defined $v || next;
         push @f, "$_($v)";
     }
     tks.fl.comp = '-webkit-filter:'.join' ', @f
 -
  - blr # it
  - 3.6
  - |
     tks.fl.blur = $v.'px'
 -
  - sat # it saturation
  - 3.6
  - |
     tks.fl.saturate = $v
 -
  - con # it contrast
  - 3.6
  - |
     tks.fl.contrast = $v
 -
  - bri # it bright
  - 3.6
  - |
     tks.fl.brightness = $v
 -
  - hue # it bright
  - 3.6
  - |
     tks.fl->{'hue-rotate'} = $v.'deg';
 -
  - sep # it old
  - 3.6
  - |
     tks.fl.sepia = $v
 -
  - inv # it old
  - 3.6
  - |
     tks.fl.invert = $v
 -
  - gray # it old
  - 3.6
  - |
     tks.fl.grayscale = $v
 -
  - ml # it
  - 3
  - |
     $v = Rw empc $v;
     "margin-left:$v"
 -
  - mr # it
  - 3
  - |
     $v = Rw empc $v;
     "margin-right:$v"
 -
  - mt # it
  - 3
  - |
     $v = Rw empc $v;
     "margin-top:$v";
 -
  - mb # it
  - 3
  - |
     $v = Rw empc $v;
     "margin-bottom:$v"
 -
  - m # margrin
  - 3
  - |
     "margin:$v";
 -
  - right # yep
  - 3.4
  - |
     "right:$v";
 -
  - left # yep
  - 3.4
  - |
     "left:$v"
 -
  - top # yep
  - 3.4
  - |
     "top:$v"
 -
  - bottom # yep
  - 3.4
  - |
     "bottom:$v"
 -
  - mw # y
  - 3.4
  - |
     "max-width:$v"
 -
  - miw # y
  - 3.4
  - |
     "min-width:$v"
 -
  - width # y
  - 3.4
  - |
     "width:$v"
 -
  - height # y
  - 3.4
  - |
     "height:$v"
 -
  - over # y 
  - 3.4
  - |
     "overflow:$v"
 -
  - float # y 
  - 3.4
  - |
     "float:$v"
 -
  - bo # border
  - 3.4
  - |
     "border:$v"

