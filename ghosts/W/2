R_Jz:
 - K: oot #c fo9od
   n_D:
     yJup: |
       qw'
       oot food
       ghostch timeloop
       oci afghanrug flax'
     etc:
       - spun 0 0.51
     curves: |
       ["spun 0" => 0.51],
       ["y 0" => 1],
       ["x 0" => 0.061],
       ["zoom 0.1" => 0.8],
       ["curve 0.1" => 0.3],

       ['y 0.5' => 0.6],
       ['x 0.5' => 0.721],
       ["spun 0.5" => 0.11],
 - K: duck #c food expansion
   n_D:
     yJup: |
       J.q = 1;
       'duck', 'sur', 'faot'
     curves: |
       ["spun 0" => 0.9],
       ["y 0" => 0.5],
       ["x 0" => 0.5],
       ["zoom 0" => 0.3],
       ["curve 0.1" => 0.024],
 - K: timeloop #c
   n_D:
     fresh_init: | #c
       my $to = sub {
         Rw timeloop/ocur;
       };
       recur 24 { $to->() }
     ocur: | #c
       sayre "OC!" if !H.busy;
       # H.G w cyc; 
 - K: ghostch #c watching food
   n_D:
     recoded_init: | #c
       Rw ghostch/ofghost;  
     ofghost: | #c
       my $Gd = H.G.lastGd;
       my $n = Rw Jung;
       
       
       n.oot && n.oot.hox || return sayre "No oot/hox, no ghostfood";
       my $J = n.oot.hox;
       
       
       say "gulped git changes ".join"  ", map {
           J bz $_ 0.1 "yep"
           $_
       } keys %$Gd;
 - K: thrash #c CURVEd FOOD
   n_D:
     yJup: |
       J.yy.round.id = 3;
       qw'thrash ash sur oci'
     curves: |
         ["zoom 0" => 0.10],
         ["y 0" => 0],
         ["x 0" => 0.4],
         ["x 0.1" => 0.46],
         ["curve 0.3" => -0.041],
         
     mods:
        - 
          - sq
          - 10
          - s: ~
            fs: 7_3
          - co: 8ff
            blr: 3
            ml: 3em
       
        
        
        
        

 - K: food #c FOOD #cc
   n_D:

     entropia: | # con shadowing in a word
       my $n = Rw Jung;
       my @yt = Rw tvo $J:n.ollox;
       sayyl "ollox has: ". @yt;
       return 'drone';  
     conty: | #
       for ($y) {
           when ('ash') {
               die;
           }
       }
       
 
     up: | #c
       # or functions sucking more stuff... suck chain shunting 
       Rw food/traction;
       Rw food/file;
     traction: | #c
       my $sc;
       sc.co = 'a3a'; 
       sc.fw = 6;
       
       my $M = [];
       Rw the + tractor $M;
       saybl ki $ar;
       Rw om/bal + $oM:M tractorfood 0.1-0.3 $sc;
     tractor: #c or ii/some further
      - MZ: pwth
      - [h!o!x  food/hoxdrop]
      - [hox    food/hoxy]
      - [file    food/file {} {hs:3.9.8.5}]
      - [byle    food/byle {} {hs:3.9.8.5}]
      - [BÆ¾B    jin:ash]
      - [hull   jin:hull]
      - [ps     jin:ps]
      - [sur    jin:ollox  {} {fs:14,co:a3a}]
      - [occie  occie/komp {} {fs:12,co:ff6}]
     fiele: | #c gor
       write_file('blag',{append=>1},"Several\nThingsies\n");
     file: | #c or
       open my $ha, '-|','tail','-F','-n9999999999','blag' or die $!;
       my $s = Mojo::IOLoop::Stream->new($ha);
       $s->on(read => sub {
          my ($s,$b) = @_;
          say "FILE:". wdump $b;
          return 0;
       });
       $s->on(close => sub {
       my $s = shift;
        die "closed!?";
       $s->start;
       });
       $s->timeout(0);
       $s->on(error => sub {
          my ($stream, $err) = @_;
          die $err
        });
        sub log2 {
           log(shift) / log(2);
        }
       #say "Yep: ".($_ * log2($_)) for 1..42;
       
       
       $s->start;
       $s->reactor->start unless $s->reactor->is_running;
       say wdump 2,$s;
       
       G.saaaa = $s;
     byle: | #c 
       my $ha = G.theha;
       say <$ha>;
     hoxy: | #c 
       my $ox = J.hox ||= {};
       ox.bb ||
           Rw suJ $J:ox;
       
       my $curves = Rw wuck $J */curves;
       my @wt;
       
           for my $k (sort keys %$curves) {
               my $d = $curves->{$k};
               my $coi = Rw pha $J:ox $k;
                
               # only when immutable: isn't tucking in some flux
               if (!J.yy.voltuck->{$k}) {
                   my $able = 
                   Rw ph_defaff $J $x:coi $d;
                   say "able to defaf" if $able;
                   next if $able;
               }
               
               @{$d=[]} = w $R $k;
               
               ox.bz->(@$_) for @$d;

               my $y = coi.end->();
               my $ex = Rw ph_exactl $J $y;
               push @wt, {ex=>$ex, y=>$y};
               sayre "\n\n############## $k and ".ki $ex;
           }
           
       my $wtf = \@wt;
       
       Rw pha $J:ox outs;
       
       Rw food/ducking + $ox;
       Rw food/wtfing + $wtf;

     hoxdrop: |
       delete J.hox
     wtfing: | #c
       my $wtf = ar.wtf;
       $wtf ||= Rw wuck $J */curves;
       
       my $wd = wdump(2,$wtf);
       sayyl "wad: $wd";
       my @l = split /\n/, $wd;
       my $M = [map{
           ["SO", '', {s=>$_,i=>1}, {co=>'4fc',ws=>'p'}],
       }@l];
       my $in = 0.5;
       my $out = 0.9;
       Rw mo/pwth $J $M $in $out;
       
     ducking: | #c 
       my $tw;
       
       my @oxn = Rw tvo $J:ox;
       my $i = 0; 
       for my $j (@oxn) {
           my $intents = Rw from_phys $J:ox $r:j.r;
           $tw->{$i++ ."_".j.r} =
             "j.s  ".join",", sort keys %$intents;
       }
       
       Rw jin duck $in:tw;
 - K: foody #c
   n_D:
     nothing: |
       
       J.lum.lev->("knobs\t0.08" => sub {
           my $J2 = shift; 
           
           J2 bz lable 0.1 "knobs "
           
           J2.lev->("knobs\t0.2" => sub {
             my $J3 = shift;
             J3 bz slide 0.2 "<input type=range min=1 value=$cra max=9 step=0.25>", "%ishtml"=>1, "%idly" => 'slide', '%css'=>'font-size:50%'
           });
       }); 
     stylesheet: |
       <<"";
            input[type=range] {
                -webkit-appearance: none;
                background: black;
                height: 2px;
            }
            input[type=range]::-webkit-slider-thumb {
              -webkit-appearance: none;
              background: url(i/copper_anodes.jpg);
              height: 12px;
              width: 12px;
              border-radius: 6px;
              cursor: crosshair;
              box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d;
            }
       
       # y

