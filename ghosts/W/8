
R_Jz:
 - K: spinash #c J chund/wandry   3erator
   D: |
     my $j;
     j.Jiter = $J; # erse rev
     j.Jmost = J.Jmost;
     # ^ outside v self
     Rw suJ $J:j;
     $j
     
 - K: mkJid #c
   D: |
     J.isJid = J.replaceJid || $H->mkuid; # convert
     undef J.isJid if G.jumb.gp_inarow > 1; # to
     J.idyl->($J, J.isJid) if J.isJid; # /%id stuff
 - K: pipathg #c
   D: |
     my $u = J.u;
     die if J.wa;
     my $wa = J.y || do {
         J.c = $R->cgp($u);
         # ^
         
         # v
         my ($wa) = grep { J.c->{$_} } qw'canpi ARRAY HASH ref undef text';
         $wa = ref $u if $wa eq 'canpi';
         $wa ||= 'wtf';
         $wa;
     };
     # can stick $wa on J.wa for thrashing maths
     # funcy fuzz fields
     # mutating spiral code
     my $way;
     for my $try ("pi/$wa", "$wa/pi") {
         my $m = [$try];
         $way = $try if Rw wuck $m;
     }
     
     $way || die "not $wa equip anywhere"; # more
     $way
     
 - K: oldschool #c
   D: |
     # next floatation device...
         for my $k (%{J.bb}) {
             if ($k =~ /^(\S*(?:oB|Bo|Bi|Bs))\s+(.+)$/) {
                 J.bb->{"$1\%css#maka25\t$2"} = "color:black";
             }
             if ($k =~ /^thi\s+(.+)$/) {
                 J.bb->{"thi\%css#maka25\t$1"} = "text-decoration:underline";
             }
             if ($k =~ /^name\s+(.+)$/) {
                 J.bb->{"name\%css#maka25\t$1"} = "color:#f93;";
             }
             if ($k =~ /^K\s+(.+)$/) {
                 J.bb->{"K%css#maka25\t$1"} = "color:#3f3";
             }
         }
 - K: fom #c fo arg unpack $o
   D: |
     my $cs = ar.cs || ar.m;
     my $o = Rw pul $cs u cv{+} y;
     if (my $J = ar.J) {
         %$o = (%$J, %$o);
     }
     $o;
     
 - K: fo #c gp in 3d    # there's the J.fo for DC or J.f 'fo', $o for AC
   babz:
     'suJ 3.5': |
       J.fo = sub {
           my $m = [@_];
           my $j = Rw spinash $J;
           Rw fo $J:j $m;
       };
       J.f = sub {
           my $t = shift;
           my $o = shift;
           my $j = Rw spinash $J;
           Rw $t $J:j $o;
       };
   D: |
     %$J = (%$J, %$o);
     # cv 
     die "could be anything" if ref J.cv;
     J.cv = 0.1 if J.cv < 0.1;
     
     # give it %id, flux in cache of Jmost
     J bz / 0.9 "y"
     
     # 2
     Rw mkJid;
     # 3
     my $pia = Rw pipathg $J;
     
     # 5 forking swivel injecty redis, etc etc
     # set up more consciously the stylepliers of 5
     
     # 6
     my $u = J.u;
     Rw $pia $J $u;
     
     Rw oldschool $J;
     
     # 7 TRACTOR BLEED
     J.s = Rw maka $J $u;
     # can pin/ping light source of con
     
     # 8
     
     # 9
     $J
     
 - K: ii/pi #c THE WHOLE GHUTS, X & L line the squiggles of inness $x and oundo $r
   D: |
     my $d;
     d.t = 'pi';
     # structureal elements jump into the pipe lining
     d.g = $g;
     
     d.c.pi = r.c.pi || "";
     d.c.s = r.s;
     d.c.gp.cv = 0.6;
     d.c.path = r.path;
       
     d.sc.ws = 'n';
     d.sc.ab = 'left:1em';
     d.sc.mw = '14em';
     d.sc.over = 'hidden';
     
     Rw iiJM + $d;
mod c:
 - K: pi #c modulapi
   mod 3.3: |
     my $o = $cs;
     o.r = d.r;
     o.d = $d;
     my $f = J.f->('pii', $o);
     d.cs.pi.f = $f;
   mod 3.7: |
     d.s = d.cs.pi.f.s;
     die wdump d.cs;
   #mod 3.8: | # fork
     
 - K: fo #c MOD fo as sc sc makes a little J/a big j
   mod 3.6: |
     my $o = {};
     if (ref $cs eq 'ARRAY') {
         my $zero = 0;
         $o = Rw fom $cs $J:zero;
     }
     else {
         %$o = %$cs;
     }
     # do the args out here so add J.r
     o.r = d.r;
     
     o.mod = $d;
     
     my $f = J.f->(fo=>$o); # magnetic fishingrods
     
     d.cs.fo.fo = $f;
     d.s = f.s; # later
     n.ogl = 1; # mark override
     # make like to hook %gp towards set f.r to the line this fo is on
 - K: pwth #c -> !some/path exp.
   mod 3.1: |
     my $path = $cs;
     $path = "!$path" unless $path =~ /^\W/;
     c.path && die;
     c.path = $path;
 - K: path #c install cs path
   mod 3.2: |
     d.cs.pwth.path = $cs;
     d.cs.pwth.idly = 1 unless c.fo; # will prov
     # later style %idly when %path but no /%id
esc c:
 - K: path #c
   esc 3: |
     '%path'=>$v
 - K: idly #c
   esc 3: |
     '%idly'=>$v
 - K: fo #c ag
   esc 3.5: |
     die if !v.r;
     '%gp' => $v 
 - K: pi #c ag
   esc 3.5: |
     die if !v.r;
     '%gp' => $v 

