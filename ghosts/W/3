R_Jz:

 - K: hull #c whole screen iraga
   n_D:
     conty: | # tyhe other
       sayyl "HULL";
       w mux(u=>$J);
     yJup: |
       qw| hull ocean |
       # geophat
       
     curves: |
         ["spun 0" => 0],
         ["y 0" => 0],
         ["x 0" => 0],
         ["zoom 0" => 0.5],
         ["curve 0.1" => -0.4],
         
         ["zoom 0.4" => -0.12],
         ["curve 0.4" => -0.7],
         
         ["curve 0.8" => -1.4],
     stylesheet: | #c
       my $Y = Load(<<'');
        - K: te # yer standard thing
          css: 
            - border-bottom:1px solid black
            - padding-left:2em
            - float:left
            - position:relative
            - width:calc(100% - 2em)
            - background:rgba(150,100,50,0.1)
        - K: tu # without indentation, more normal
          css: 
            - border-bottom:1px solid black
            - float:left
            - position:relative
            - width:100%
            - background:rgba(150,100,50,0.1)
        - K: nopoi # outer
          css: [pointer-events:none]
        - K: poi
          css: [pointer-events:all]
        - K: OxO
          styles: ab
          css: [height:100%, width:100%]
        - K: ab
          css: [position:absolute]
        - K: rel
          css: 
            - position:relative
        - K: X
          css:
            - position:relative
            - width:100%
            - height:100%
        - K: NZ
          css: []
          classy: hidden until its brought into the web
        - K: z
          css: []
          classy: to bring into the web


       $Y = {map {
           _.K => join '', map { "$_;" } @{_.css}
       } @$Y};
       
       my $stuff = Rw sheep $Y;
       $stuff.
       'ux * {pointer-events: all;}';
          
     hijack: | #c
       # the biggest con!
       Rw hull/mkboot;
     mksur: | #c ins frond
       # bg arg to hiJ if about id magnetism/cell division
       my $J = Rw jin ollox thesurf;
       Rw hul $J;
       $J
     mkboot: | #c
       my $J = Rw jin oot foot;
       Rw hul $J;
       $J
     mkash: | #c
       my $J = Rw jin thrash;
       Rw hul $J;
       $J
 - K: hul #c
   D: |
     # ^ sing
     my $J2 = $J;
     $J = Rw Jun hull;
     Rw Jolt $J $J2;
     Rw Joltebug $J;
     
 - K: Jolt #c JjJj how to J -> j, sproutlinger
   D: |
     my $n = ar.n || shift @{ar.m||[]} || J.jon++;
     
     $n += 0;
     
     # balance follicles
     sayyl "Jont ".$J->pi."  %Joints @ J.jon   ".gp($J2);
     
     J bz J2.name 0.$n    '>:D', '%Joint' => $J2
     
     # J hull knows about %Joints

     J2.jointed = $J;
     $J2;
 - K: Joltebug #c like push onto the %Joints centipede, which cons # mmm
   D: |
     my $cv = 0.7;
     # wants to be the optimo
     # sets up a projection on J.oj
     # will inform conroll, use entropia to de
     # bolts on to any humming, suction zone
     # so there is time...
     # 
     say "Joltebug Joltebug Joltebug " for 1..2;
     Rw jitterbug $J $cv;
     Rw Joints $J;
 - K: Joints #c
   D: |
     my @path = Rw ship $J Joints;
     
     my @things = Rw tvy $J;
     saybl " JOINTSJOINTSJOINTSJOINTSJOINTSJOINTSJOINTSJOINTSJOINTSJOINTSJOINTSJOINTS";
     for my $ths (@things) {
         my ($th, @sjs) = @$ths;
         say "y hello ".wdump(1,$ths) if th.l ne th.t;
         
         if (my ($Joi) = grep{_.style eq 'Joint'} @sjs) {
             my @jcss = grep{_.style eq 'css' && _.com =~ /^pha/} @sjs;
             my $J2 = $Joi->{s};
             
             Rw oven $J $J2;
             # J2 now disposed to a part of J, all within L
             
             
             my ($Z, $N);
             for my $N (map { _.s } @jcss) {
                 $Z->{$_} = $N->{$_} for keys %$N;
             }
             sayyl " hoping ".$J2->pi." istyle:".wdump($Z);
             
             if ($Z->{'-webkit-transform'} =~ /rotate\((.+?)rad\)/) {
                 $Z->{'-webkit-transform'} = 'rotate('.($1 + 0).'rad)',
             }
             
             
             my $beef = J2.S.Z;
             my $off = 77;
             Z.width = $off.'%';
             Z.height = $off.'%';
             #Z.border = '2px solid rgba(0,0,0,0.3)';
             J2.S.Z = $Z;
             #say "YESSSSS". wdump 2,[tj.r, $beef, map { "   _.r" } @jcss];
         }
     }
     saybl "joints..." for 1..3;
 - K: JL #c make L bracket # rename Joint
   D: |
      my $u = {K=>'L',%{ar.r || {}}}; 
      u.name ||= "L:J.name:".G.jumb.Lnumb++; # additively
      my $q = 1;
      my $L = w G.R fuu[$u, $q];
      sayyl "made ++ ".$L->pi;
      $L
 - K: oven #c
   D: |
     J.L ||= Rw JL $J;
     
     J2.A->umk(J.L => 'S'); # put in
     
     w mux(u=>$J2);
     w mux(u=>J.L);
     sayyl "OVENATING ".$J->pi."  put in  ".$J2->pi;
     
     

