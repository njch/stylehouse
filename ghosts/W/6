

R_Jz:
 - K: globdir #c
   D: |
     my @ma = map{$H->fixutf8($_);chomp;$_}`ls -1 '$dir'`;
     my @r;
     for my $f (@ma) {
         my $r;
         r.full = "$dir/$f";
         r.r = $f;
         push @r, $r;
     }
     @r;
 - K: zash #c CURVEd FOOD
   n_D:
     yJup: |
       'mash bluerug eyenest'
     curves: |
          zoom 0 0.570
          y 0 0
          x 0 0.5
          #x 0.1 0.46
          curve 0.3 -0.041
     up: | #
       my $he = 0.05;
       Rw ii/Jhead + 0.03 $out=0.05;
       #Rw ii/ornate + $in:he;
       
       Rw ii/Wdo $J $oJ:J.on;
       
       J.cv = 16;

       my $onl = Rw very + $J:J.on $in=0.2 $out=0.9 $tot:J.cv;

       for my $x (@$onl) {
           Rw ix/suro + $x;
       }
       sayre "==\nASH delt ASH ".F_delta."\n==";
 - K: ou/dire #c 
   D: |
     # LOOK FOR KNOWNS, scoped in wormhole
     die 'ref' if ref $u;
     -d $u || die "not found: $u pwd=".`pwd`;
     my @r = Rw globdir $dir:u;
     for my $n (@r) {
         my $r;
         r.r = n.r;
         r.s = n.full;
         # $x power percolates
         # track J.most.J etcs...
         # shway by Jhead the ou/dire culture suggestions
         # to be chucked on and off, little nonmuxing pi swimming events
         r.c.path = "!pat/dire";
         r.c.pi = 'dire';
         r.lab_c.pi = 'direlab';
         push @{o.r}, $r;
         if (@{o.r} >= $thi) {
             o.more = @r - @{o.r};
             last;
         }
     }
 - K: pat/dire #c pat a physical, in a directory
   D: |
     # this row...
     my $i = J2.most.r.s;
     if (-d $i) {
         #J2.d.g.x.j.s = $ul;
         Rw ein/dire $J $i;
     }
     elsif (-f $i) {
         w demux[$J];
         my $J = Rw Jon $name=mash;
         # & over there
         Rw ein/image $J $i;
     }
     else{ die "no see $i" }
 - K: pi/dire #c
   D: |
     my $x = J.most.x;
     my $dir = -d $u;
     my $file = -f $u;
     if ($dir) {
         if (J.fop->()) {
             Rw pi/direst $J $dir:u;
         }
     }
     elsif ($file) {
         
         return if J.cv < 0.2;
         
         if (J.cv >= 0.3) {
             my $sp = x.imspin++;
             x.imspin = 0 if $sp > 3;
             my $left = (($sp * 3)).'em';
             $left = "0.1em";
             J.no->($J, thumb => 0.3,
                 {pi=>'thumbnail',s=>$u,gp=>{cv=>J.cv}},
                "{opa:0.8,left:$left,top:0em,ab:1,rad:0.1,sat:4}");
         }
     }
     else {
         Rw wtf wtf 1 $J;
     }
 - K: pi/emb #c right
   D: |
     Jn(J.r, 0.2, "$u", '{fs:15}');
 - K: pi/fileinfo #c 0.3ish under dirlab
   D: |
     J.d.sc.sha = '-2 1 5 ff7a';
     if (-d $u) {
         Jn(isdir => 0.1,
            {pi=>'emb', s=>'ð“'},
            '{hs:3.7.5.9}');
     }
     if (-f $u) {
         Jn(isfile => 0.1,
         {pi=>'emb', s=>'f'},
            '{hs:6.7.2.9}');
         
         if (!defined J.d.c.fileext) {
             J.d.c.fileext = $1
                 if J.d.c.label =~ s/\.([^\.]+)$//;
         }
         if (defined J.d.c.fileext) {
             Jn(ext => 0.1, J.d.c.fileext, 
                 '{co:fff,sha:2 3 4 ccf,fs:8,zi:3,deco:1}');
         }
     }
     
     return unless J.cv >= 0.3 && J.fop->();
     
     if (-f $u) {
         Jn(filesiz => 0.3,
             {pi=>'filesiz', s=>$u}, # full
                '{hs:6.7.2.9}');
     }
     
 - K: pi/filesiz #c the vague know something about files disjoint
   D: |
     my $s = (stat $u)[7];
     say "$u is $s";
     my @t = qw'b kB MB GB';
     while ($s > 666) {
         shift @t || last;
         $s /= 1024;
     }
     $s = sprintf '%.1f', $s;
     my ($co) = @t;
     J.d.sc.fs = 7;
     Jn(size => 0.2, $s, '{hs:8.3.1.8}');
     Jn(co => 0.3, $co);
     
     
     #e
 - K: ou/image #c
   D: |
     -f $u || die 'not file';
     
     
     my $j = x.j;
     #Rw cruxal $x lala wagga;
     my $r;
     r.r = x.j.l; # abrevid
     r.s = $u;
     r.c.path = "!nowhere";
     r.c.pi = 'image';
     r.c.file = $u;
     push @{o.r}, $r;
 - K: pi/image #c
   D: |
     -f $u || die;
     my $sc;
     my $thi = J.d.g.x.phi || 1;
     sc.height = (64 * $thi)."em";
     say "Image thickness:   sc.height     for $u";
     sc.hue = -20 + int(rand 56);
     sc.con = sprintf '%.1f', 0.7 + rand 2;
     sc.left = "0em";
     J.d.sc.mw = "20em";
     Rw pi/thumbnail $u $J $sc;
 - K: pi/thumbnail #c image/video
   D: |
     my $size = -s $u;
     return "nontypeimage: $u" unless $u =~ /(png|gif|jpe?g)$/i;
     my $mou = "public/";
     #return if $size > 3_000_000;
     my ($first) = split '/', $u;
     die "$first not $mou?" unless -e "$mou$first";
     
     my $thl = "th/$u";
     my $th = "$mou$thl";
     
     # TODO mod slowness
     # make this thumbnail J even more forky than usual
     # TODO wander 90deg radial over phatness...
     # tape twist effect coming from somewhere
     
     if (!-f $th && J.fop->()) {
         sayyl " thumbnail++$u";
         my $thd = $1 if $th =~ /^(.+)\/(.+)$/ || die $th;
         if (!-d $thd) {
             run 'mkdir', '-p', $thd;
         }
         if ($u =~ /(mov|avi|mp4)$/i) {
             run 'ffmpegthumbnailer -s 420 -t 20% -i '.$u.' -o '.$th
         }
         else {
             run 'convert', $u, '-thumbnail','500x500', $th
         }
     }
     if (-f $th) {
         my $sc = {
             tag => 'img',
             zom=>{at => {src => $thl}},
             height=>'17em',
             ab=>1,
             zi=>2,
             %{ar.sc||{}}
         };
         my $s = "";
         Rw wtf $J yowl 3 $s $sc;
     }
     delete J.mod.sc.over;
     #J.mod.sc.bgi = $thl;
 - K: pi/direst #c shadowing fs
   D: |
     my @r = Rw globdir $dir;
     my @d = grep { -d _.full } @r;
     for my $r (@d) {
         Jn(r.r, '',
             {s=>$r,pi=>'dierfi'},
             '{co:33f,sha:3 3 5 fff,ml:0.1em}');
     }
     my $ts;
     ts.d = @d;
     ts.files = @r - @d;
     Rw Mn + $n:_ for
         ['more', 0.88, {s=>$ts,pi=>'n_tal'}, {fs=>13,co=>'e9a7'}];
 - K: pi/dierfi #c
   D: |
     Rw Mn + $n:_ for
     ['name', '', {s=> u.r }, {ml=>'0.1em'}];
     
     if (-d u.full) {
         Rw Mn + $n:_ for
         ['symbol', '', {s=>'/'}, {sha=>'3 3 4 af8',co=>'afa'}];
     }
     
 - K: pi/n_tal #c
   D: |
     my $i = 0;
     for my $k (sort keys %$u) {
         J.no->($J, count => '', "$u->{$k}", '{fs:9,co:39a7}');
         
         J.no->($J, k => '', "$k", '{fs:7,co:e9a7}');
         J.no->($J, Bs => '', ',', {}) if $i++ > 0;
     }

mod c: # pile of stuff on the ceiling # pull out the culture protocol re MZ meanings
 - K: unico #c
   mod 3.3: |
      my $c = ref $cs ? $cs : {};
      my $ent = d.s =~ /^(d+)$/ ? $1 : J.ent.2;
      my @s;
      for my $i (1..(c.thi||24)) {
          my $entoi = $1 if ($ent * $i) =~ /(\d)$/;

          my ($b, $dd) = unico(n.um+$i* 100 * $entoi, 1);
          my $pa = $entoi > 7 ? "  " : $entoi > 3 ? " " : "";
          push @s, $pa.$b;
      }
      d.s = join '', @s;
 - K: zim #c seem z swim
   mod 3.3: |
     my $osc = n.zim->{$cs} ||= do {
         $cs =~ /^($NUM)\^v($NUM)(?:\*($NUM))?$/ || die "no zim osc $cs";
         {ce => $1, ext => $2, mul => ($3||1)}
     };
     osc.pi ||= 1;
     osc.v = osc.ext if !defined osc.v;
     osc.pi = -1 if osc.pi > 0 && osc.v >= osc.ext;
     osc.pi = 1 if osc.pi < 0 && osc.v <= -osc.ext;
     
     osc.v += osc.pi;
     
     d.cs.zim.zi = osc.ce + (osc.v*osc.mul);
        
 - K: cow #c hs mods be more fun
   mod 3.4: |
     # TODO hex round sweepage
     my @col = hexend($cs);
     my @wo = grep{/^[1-9]$/} split '', d.pcv;
     
     my $wi = sub { $_[0] += $_[1]; $_[0] -= 15 if 15 < $_[0]; };
     my $win = {};
     my $wc = {qw{r 0 g 1 b 2}};
     for (0,1,2) {
          my $wa = $wc->{$_};
          $win->{$_} = $cs =~ /w$wa-(\d)/ ? $1 : $_;
     }
     my $fore = join ' ', @col;
     unless ($cs =~ /no/) {
         my $norgb = $cs !~ /r|g|b/;
         for my $k (keys %$wc) {
             my $n = $wc->{$k};
             my $ad = $wo[$win->{$n}];
             # patch bay ^
             my $mult = 9;
             $mult = $1 if $cs =~ /$k(\d+)/;
             $ad *= ($mult / 9);
             $wi->($col[$n], $ad) if $norgb || $cs =~ /$k/;
         }
     }
     #saybl "cow mod $fore  ->  ".join ' ', @col;
     my $col = hexbe(@col);
     # hexify? dark is nice
       # art this shit proply ^
     d.cs.olo.co = $col;
 - K: mixco #c mix into olo.co
   mod 3.5: |
     $cs =~ /^($NUM )?(...)$/;
     my $mix = $1;
     my @col = hexend($2);
     my @fro = hexend(d.cs.olo.co);
     for (0,1,2) {
         my $yu = $fro[$_] - $col[$_];
         #$yu *= -1;
         $yu = $yu * $mix;
         #say " $yu          from $col[$_]-$fro[$_] * $mix       ";
         $fro[$_] -= $yu;
     }
     #say hexbe(@fro);
     #d.cs.olo.co;
     d.cs.olo.co = hexbe(@fro);
     
     
     #
 - K: fs #c MOD MOD MOD 1=stable 2=sweep # & SWIM
   mod 3.3: |
     my ($n1,$n2) = $cs =~ /^($NUM)(?:_($NUM))?/;
     # n1 already 0.4 if it wants to be tiny
     my $siz = 100 * (12 / $n1);
     $siz -= n.um / $n2 if $n2;
     d.cs.fsgy.fs = int $siz;
 - K: fsx #c text fit
   mod 3.4: |
        my $si = length(d.c.s);
        my $curve = {qw{
        40 6
        30 7
        20 9
        }};
        for (sort keys %$curve) {
            d.cs.fsx.fs = $curve->{$_} if $si > $_
        }
 - K: sh #c
   mod 3: |
     d.cs.sh.sha = '2 2 7 ffc';
 - K: i #c  $i is the osc, attach on $v to $n
   mod 3.1: |
     d.t = d.t."-".n.iii->{$cs}++; 
     d.r = join "\t", d.t, d.cv;
 - K: carbcap #c jel like language # n.gl gravity, implosi # agg from chaos
   MZ: {}
   mod 3.9: |
     # roll ^ dough, the gel that gl may be
     # now snaps off a branch
     # continuous notation we still pick up as chunks of lingo geom
     # ^ es also like looking for most magnity n.thee value heading for $s
     # carbdome...

