

R_Jz:
 - K: zash #c CURVEd FOOD
   n_D:
     yJup: |
       'mash bluerug eyenest'
     curves: |
          zoom 0 0.570
          y 0 0
          x 0 0.5
          #x 0.1 0.46
          curve 0.3 -0.041
     up: | #
       my $he = 0.05;
       Rw ii/Jhead + 0.03 $out=0.05;
       #Rw ii/ornate + $in:he;
       
       Rw ii/Wdo $J $oJ:J.on;
       
       J.cv = 16;

       my $onl = Rw very + $J:J.on $in=0.2 $out=0.9 $tot:J.cv;

       for my $x (@$onl) {
           Rw ix/suro + $x;
       }
       sayre "==\nASH delt ASH ".F_delta."\n==";
mod c: # pile of stuff on the ceiling # pull out the culture protocol re MZ meanings
 - K: unico #c
   mod 3.3: |
      my $c = ref $cs ? $cs : {};
      my $ent = d.s =~ /^(d+)$/ ? $1 : J.ent.2;
      my @s;
      for my $i (1..(c.thi||24)) {
          my $entoi = $1 if ($ent * $i) =~ /(\d)$/;

          my ($b, $dd) = unico(n.um+$i* 100 * $entoi, 1);
          my $pa = $entoi > 7 ? "  " : $entoi > 3 ? " " : "";
          push @s, $pa.$b;
      }
      d.s = join '', @s;
 - K: zim #c seem z swim
   mod 3.3: |
     my $osc = n.zim->{$cs} ||= do {
         $cs =~ /^($NUM)\^v($NUM)(?:\*($NUM))?$/ || die "no zim osc $cs";
         {ce => $1, ext => $2, mul => ($3||1)}
     };
     osc.pi ||= 1;
     osc.v = osc.ext if !defined osc.v;
     osc.pi = -1 if osc.pi > 0 && osc.v >= osc.ext;
     osc.pi = 1 if osc.pi < 0 && osc.v <= -osc.ext;
     
     osc.v += osc.pi;
     
     d.cs.zim.zi = osc.ce + (osc.v*osc.mul);
        
 - K: cow #c hs mods be more fun
   mod 3.4: |
     # TODO hex round sweepage
     my @col = hexend($cs);
     my @wo = grep{/^[1-9]$/} split '', d.pcv;
     
     my $wi = sub { $_[0] += $_[1]; $_[0] -= 15 if 15 < $_[0]; };
     my $win = {};
     my $wc = {qw{r 0 g 1 b 2}};
     for (0,1,2) {
          my $wa = $wc->{$_};
          $win->{$_} = $cs =~ /w$wa-(\d)/ ? $1 : $_;
     }
     my $fore = join ' ', @col;
     unless ($cs =~ /no/) {
         my $norgb = $cs !~ /r|g|b/;
         for my $k (keys %$wc) {
             my $n = $wc->{$k};
             my $ad = $wo[$win->{$n}];
             # patch bay ^
             my $mult = 9;
             $mult = $1 if $cs =~ /$k(\d+)/;
             $ad *= ($mult / 9);
             $wi->($col[$n], $ad) if $norgb || $cs =~ /$k/;
         }
     }
     #saybl "cow mod $fore  ->  ".join ' ', @col;
     my $col = hexbe(@col);
     # hexify? dark is nice
       # art this shit proply ^
     d.cs.olo.co = $col;
 - K: mixco #c mix into olo.co
   mod 3.5: |
     $cs =~ /^($NUM )?(...)$/;
     my $mix = $1;
     my @col = hexend($2);
     my @fro = hexend(d.cs.olo.co);
     for (0,1,2) {
         my $yu = $fro[$_] - $col[$_];
         #$yu *= -1;
         $yu = $yu * $mix;
         #say " $yu          from $col[$_]-$fro[$_] * $mix       ";
         $fro[$_] -= $yu;
     }
     #say hexbe(@fro);
     #d.cs.olo.co;
     d.cs.olo.co = hexbe(@fro);
     
     
     #
 - K: fs #c MOD MOD MOD 1=stable 2=sweep # & SWIM
   mod 3.3: |
     my ($n1,$n2) = $cs =~ /^($NUM)(?:_($NUM))?/;
     # n1 already 0.4 if it wants to be tiny
     my $siz = 100 * (12 / $n1);
     $siz -= n.um / $n2 if $n2;
     d.cs.fsgy.fs = int $siz;
 - K: fsx #c text fit
   mod 3.4: |
        my $si = length(d.c.s);
        my $curve = {qw{
        40 6
        30 7
        20 9
        }};
        for (sort keys %$curve) {
            d.cs.fsx.fs = $curve->{$_} if $si > $_
        }
 - K: sh #c
   mod 3: |
     d.cs.sh.sha = '2 2 7 ffc';
 - K: i #c  $i is the osc, attach on $v to $n
   mod 3.1: |
     d.t = d.t."-".n.iii->{$cs}++; 
     d.r = join "\t", d.t, d.cv;
 - K: carbcap #c jel like language # n.gl gravity, implosi # agg from chaos
   MZ: {}
   mod 3.9: |
     # roll ^ dough, the gel that gl may be
     # now snaps off a branch
     # continuous notation we still pick up as chunks of lingo geom
     # ^ es also like looking for most magnity n.thee value heading for $s
     # carbdome...

