
mod c: # pile of stuff on the ceiling # pull out the culture protocol re MZ meanings

 - K: unico #c
   mod 3.3: |
      my $c = ref $cs ? $cs : {};
      my $ent = d.s =~ /^(d+)$/ ? $1 : J.ent.2;
      for my $i (1..(c.thi||24)) {
          my $entoi = $1 if ($ent * $i) =~ /(\d)$/;

          my ($b, $dd) = unico(n.um+$i* 100 * $entoi, 1);
          my $pa = $entoi > 7 ? "  " : $entoi > 3 ? " " : "";
          push @{n.gl||=[]}, $pa.$b;
      }
 - K: cow #c
   mod 3.4: |
     # TODO hex round sweepage
     my @col = hexend($cs);
     my @wo = grep{/^[1-9]$/} split '', d.pcv;
     my $wi = sub { $_[0] += $_[1]; $_[0] -= 15 if 15 < $_[0]; };
     my $win = {};
     for (0,1,2) {
          $win->{$_} = $cs =~ /w$_-(\d)/ ? $1 : $_;
     }
     $wi->($col[0], $wo[$win->{0}]);
     $wi->($col[1], $wo[$win->{1}]);
     $wi->($col[2], $wo[$win->{2}]);
     my $col = sprintf '%03d', map {int($_)} @col;
     # hexify? dark is nice
       # art this shit proply ^
     d.cs.olo.co = $col;
 - K: mixco #c mix into olo.co
   mod 3.5: |
     $cs =~ /^($NUM )?(...)$/;
     my $mix = $1;
     my @col = hexend($2);
     my @fro = hexend(d.cs.olo.co);
     $mix = 0.6;
     #$mix = ($mix||1) / 1;
     for (0,1,2) {
         my $yu = $col[0] - $fro[$_];
         $yu = $yu * $mix;
         #say " $yu          from $col[0]    $fro[$_]       ";
         $col[0] -= $yu;
     }
     #say "@col -> ". hexbe(@col);
     d.cs.olo.co = hexbe(@col);
     
     
     #
 - K: fs #c MOD MOD MOD 1=stable 2=sweep # & SWIM
   mod 3.3: |
     my ($n1,$n2) = $cs =~ /^($NUM)(?:_($NUM))?/;
     # n1 already 0.4 if it wants to be tiny
     my $siz = 100 * (12 / $n1);
     $siz -= n.um / $n2 if $n2;
     d.cs.fsgy.fs = $siz;
 - K: sh #c
   mod 3: |
     d.cs.sh.sha = '2 2 7 ffc';
 - K: jamit #c
   mod 3: |
     d.cs.awl = "JAMTHATFUELTANK";

R_Jz:
 - K: oundo #c hound god
   D: |
     my $o = {r=>[]};
     # fills up @r to $thi
     # also $plucky to select hash key order
     # a space for tiny-part-of-huge-set access
     
     # $plucky could rate the things it gets passed
     # and the $thi yins up out here
     
     if (!ref $u) {
         o.type = 'text';
         push @{o.r}, { r=>"text", s=>$u, cv=>0.4 };
     }
     elsif (ref $u eq 'ARRAY') {
         o.type = 'ARRAY';
         o.total = @$u;
         my $i = 0;
         until (@{o.r} >= $thi) {
             if (!exists $u->[$i]) {
                 last;
             }
             
             my $v = $u->[$i];
             # $plucky
             push @{o.r}, { r=>$i, path=>"[".$i, s=>$v };
             
             if (@{o.r} >= $thi) {
                 o.more = @$u - @{o.r};
                 delete o.more if !o.more;
                 last;
             }
             $i++;
         }
     }
     elsif (ref $u eq 'CODE') {
          die;
          o.type = 'CODE';
          push @{o.r}, { r=>"CODE", clues=>{stuff=>"fromDm?"} }
     }
     else {
         my @ks = sort keys %$u;
         o.total = @ks;
         until (@{o.r} >= $thi) {
             if (!@ks) {
                 last;
             }
             
             my $k = shift @ks;
             my $v = $u->{$k};
             # $plucky # could be R coded small lmaz
             # can meet slightly more and select best
             # nothing is too worthy
             push @{o.r}, { r=>$k, path=>"{".$k, s=>$v };
             
             if (@{o.r} >= $thi) {
                 o.more = @ks if @ks;
                 last;
             }
         }
         # bunch of keys... ^ interpret, compress knowledge
         # TODO ^make itv like two indexes, polars
         # any sorta layout knowhow...
     }
     o.thi = @{o.r};
     $o


 - K: wtf #c pi friendly mod stackening, thingy endian # YIN accumuspinny $M parti
   D: |
     my @m = @{ar.m||[]};
     my $l = ar.l || shift @m;
     die"nolly" if !$l;
     my $s = ar.s || shift @m;
     my $c = ar.c || {};
     c.s = $s;
     
     my $ss = ar.sc || [@m];
     my $sc;
     if (ref $ss eq 'ARRAY') {
         for (@$ss) {
             /^(\S+):(\S+)$/ || die $_;
             $sc->{$1} = $2;
         }
     }
     else {
         $sc = $ss;
     }
     
     my $mo = [$l,'',$c,$sc];
     if (my $M = ar.M) {
         push @$M, $mo;
     }
     $mo
     
 - K: pi #c
   n_D:
      wtf: | #c
        J.bz->('know 0.1', "$u");
      ARRAY: | #c
            my $cv = J.cv ||= 0.3;
            
            my $si = @$u;
            J.bz->('si 0.1' => $si, '%css' => "color:#fff;font-size:50%");
            J.bz->('Bo 0.11' => '[');
            J.bz->('oB 0.89' => ']');
            
            return if $cv < 0.2;
            
            
            my @cvs = Rw cv/oe $v:si;
            my $i = 0;
            while (exists $u->[$i]) {
                my $uu = $u->[$i];
                my $vc = shift @cvs;
                if ($i > 0) {
                    J bz [${i}/Bs 0.2${vc}1 ','
                }
                
                my $vcv = J.cv - 0.2; # dus bend for $k
                $vcv = 0.1 if $vcv < 0.1;
                
                J fro [${i} 0.2${vc}4 $uu, $vcv, "%css" => "font-size:75%"
                
                $i++;
                if ($i >= 5) {
                    J bz more 0.88 "@", '%sf' => "blue"
                    last;
                }
            }
      HASH: | #c
            my $cv = J.cv ||= 0.3;
            
            my $si = keys %$u;
            J.bz->('si 0.1' => $si, 'si%css 0.1' => "color:#fff;font-size:50%");
            
            J bz Bo 0.11 '{'
            J bz oB 0.89 '}'
            
            return if $cv < 0.2;
            
            # 3
            my $r = {map{$_=>1} sort keys %$u};
            my @r = grep { delete $r->{$_} } qw'K name';
            push @r, sort keys %$r;
            
            my @cvs = Rw cv/oe $v:si;
            my $i = 0;
            for my $k (@r) {
                my $v = $u->{$k};
                my $vc = shift @cvs;
                if ($i > 0) {
                    J bz {$k/Bs 0.2${vc}1 ','
                }
                
                my $fs = 75;
                my $ksi = length($k);
                $fs -= ($ksi - 8) * 8 if $ksi > 8;
                $fs = int($fs);
                $fs = 25 if $fs < 25;
                    

                J bz {$k/k 0.2${vc}2 $k, "%css" => "color:#acf;font-size:$fs%"
                
                my $vcv = J.cv - 0.2; # dus bend for $k
                if ($vcv >= 0.2) {
                
                    J bz {$k/Bi 0.2${vc}3 ':', '%css' => "font-size:40%"
                    
                    my $fs = 75;
                    $fs -= length($v) - 8 * 4 if 8 < length $v;
                    $fs = int($fs);
                    
                    J fro {$k/v 0.2${vc}4 $v, $vcv, '%css' => "font-size:$fs%"

                }
                
                $i++;
                if ($i >= 5) {
                    J.bz->("more 0.2 0.886" => "@",
                    
                        '%sf' => "blue");
                    last;
                }
            }
      HASH2: | #c
            my $cv = J.cv ||= 0.3;
            
            my $si = keys %$u;
            J.bz->('si 0.1' => $si, 'si%css 0.1' => "color:#fff;font-size:50%");
            
            J.bz->("B:Bo 0.1 0.1" => '{');
            J.bz->('B:oB 0.1 0.89' => '}');
            
            return if $cv < 0.2;
            
            # 3
            my $r = {map{$_=>1} keys %$u};
            my @r = grep { delete $r->{$_} } qw'K name';
            push @r, sort keys %$r;
            
            my $ki = 0;
            my $i = 0;
            J.bz->('B:Bs 0.2', ',');
            J.bz->('B:Bi 0.3', ':');
            
            for my $k (@r) {
                my $v = $u->{$k};
                $i++;
                if ($cv < 0.8 && $i >= 5) { # braids at 0.8
                    J.bz->("more 0.2 0.886" => "@", '%sf' => "blue");
                    last;
                }
                
                my $ii = sprintf('%04d', $i);
                
                J.bz->('B/'.$ii.'/k 0.2', $k,
                
                    '%css' => 'color:#acf;font-size:80%');
                
                
                my $vcv = J.cv - 0.2; # dus bend for $k
                if ($vcv >= 0.2) {
                    J.fro->('B/'.$ii.'/v 0.3', $v, $vcv,

                        '%css' => 'font-size:75%');
                }
            }
      ref: | #c weird ref
        J.bz->('knowref 0.1', "$u", '%css'=>'color:#945;font-size:70%');
      code: | #c
        J.bz->('know 0.1', "CODE");
      undef: | #c
        J.bz->('know 0.1', '~');
      text: | #c
            my $text = $u;
            
            my @s;
            my $adhow = $text =~ s/\n/↯/g;
            
            my $tev = int(J.cv * 200); # 0.4 = 100
            
            my $si = length($text);
            if (!$si) {
                J.bz->('length 0.1', "''", '%sf', 'blue');
            }
            if ($si > $tev) {
                $text = ($text=~/^(.{$tev})/s)[0];
            }
            else {
                undef $si;
            }
            
            J.bz->('line 0.1' => $text,
                '%css' => "background:rgba(200,30,80,0.3);color:#3f3;"
                    ."font-size:70%");
            
            if ($si) {
                J.bz->("more 0.89" => "@",'%sf' => "blue");
            }
            
            return if J.cv < 0.2;
            
            my $ni = J.c.lin if J.c.lin > 1;
            my $bi = J.c.b if J.c.b > 1;
            
                J.bz->("si/l 0.2" => "$si",
                    '%css' => "color:#b89;font-size:50%;position:absolute") if $si;
                J.bz->('si/n 0.2' => "$ni",
                    '%css' =>
                        "color:#fff;font-size:50%;"
                        ."position:absolute;margin-top:1.4em;") if $ni;
                J.bz->('si/b 0.2' => "b$bi",
                    '%css' =>
                        "color:#f89;font-size:50%;"
                        ."float:left;left:-1em") if $bi;
                   
            if (J.cv < 0.7 && $text =~ /^(# \d.+?)↯/) {
                J.bz->('line 0.1' => $1,
                '%css' => "background:rgba(200,30,80,0.3);color:#3f3;"
                    ."font-size:70%");
            }
            return if J.cv < 0.7;
            
            # 7
            my @tex = split /\n/, $u;
            #my $s = $G->vimcolor($u);
            #$s =~ s/^(<span) (class="synComment">.+?)(<\/span>)/$1 style="font-size:170%;" $2$com$3/;
            
            #$tex[0] .= " #J.cv";
            
            my $surge = int(100 * (J.cv - 0.7));
            # add interesting o to tex 0.7ishs as surge goes
            (my $one, my @o) = @tex if J.cv < 0.8;
            @tex = $one if @o;
            my $urge = $surge / 2;
            $urge = 0; # TODO colours and
            for (@o) {
                last if @tex >= $urge;
                push @tex, $_ if /^#/
                    || /R\./
                    || /\-\>/
                    || /w\ /;
            }
            
            
            my $lim = ";height:19em;overflow-y:scroll" if @tex > 19;
            $lim .= ";background:rgba(70,40,0,1);" if J.cv >= 0.8;
            
            my $fs = int(50 + $surge * 7);
            $fs = "font-size:$fs%;";
            
            my $s = join"\n", @tex;
            J.bz->("line 0.1" => $s, '%tag'=>'pre','%gp'=>{vimcolor=>1},
                '%css' => "margin:0.2em;background:rgba(30,30,60,1);$fs-webkit-filter:hue-rotate(80deg);$lim");
      A: | #c
        my $cv = J.cv ||= 0.3;
        
        J bz thi 0.01     ref $u
        return if $cv < 0.1;
        J bz name 0.1     u.name
        return if $cv < 0.2;
        J bz K 0.2        u.K
        
        J fro i 0.2 u.i, 0.2
        
        return if $cv < 0.3;
        
        my $un;
        for my $nuk (keys %$u) {
            next if $nuk !~ /^(u|n)/;
            my $v = $u->{$nuk};
            my $tot = ref $v eq "ARRAY" ? @$v : $v;
            $un->{$1}->{$nuk} = $tot;
            my $lv = $1 eq "u" ? 1 : 2;
            
            J.bz->("un/$1/${nuk}_nuk 0.3$lv", "$nuk:",
                    
                    "\%css" => "color:#acf;font-size:80%");
            
            J.fro->("un/$1/${nuk}_t 0.3$lv", $tot, 0.2,
                    
                    "\%css" => "color:#fca;font-size:80%");
        }
        
      G: | #c
        my $cv = J.cv ||= 0.3;
        J.bb->{"thi 0.01"} = ref $u;
        return if $cv < 0.1;
        J.bb->{"K 0.11"} = u.K;
        J.bb->{"name 0.12"} = u.name;
        return if $cv < 0.2;
        
      T: | #c dodge
        J.bz->('pi 0.1', $u->pi);
      J: | #c dodge
        my $cv = J.cv ||= 0.3;
        J.bb->{"thi 0.01"} = ref $u;
        return if $cv < 0.1;
        J.bb->{"name 0.1"} = $H->ejson(u.B) if u.B;
        return if $cv < 0.2;
        J.fro->('i 0.2', $u, 0.1);
        return if $cv < 0.3;
        # 3
          my $bits = do {
              my $a = {u=>$u, wa=>'up'};
              w $R gp[$u, $a];
              J.bb
          };
          J.bb->{'bit/'.$_} = $bits->{$_} for keys %$bits;
        
      up: | #c
            my $r = {map{$_=>1} sort keys %$u};
            
            my $ordy = {
                A => 1,
                id => 11,
                K => 12,
                name => 13,
                G => 14,
                R => 14,
                W => 2,
            };
            my $ydro = {};
            push @{$ydro->{$_}||=[]}, $_ for keys %$ordy;
            my @order = map { @{$ydro->{$_}} } sort keys %$ydro;
            
            my @r = grep { delete $r->{$_} } @order;
            push @r, sort keys %$r;
            
            my $ki = 0;
            my $i = 0;
            for my $k (@r) {
                my $v = $u->{$k};
                
                my $ord = $ordy->{$k} || 4;
                J.bb->{"$k\t".'0.'.$ord} = ''.$v;
                
                $i++;
            }
      H: | #c
        J.bz->('thi 0.01' => 'H');
        J.bz->("name 0.06" => u.style);
        J.bz->("K 0.1" => u.name);
        
      R: | #c
        my $cv = J.cv ||= 0.3;
        J.bb->{"thi 0.01"} = ref $u;
        return if $cv < 0.1;
        J.bb->{"K 0.11"} = u.K;
        J.bb->{"name 0.12"} = u.name;
        return if $cv < 0.2;
        return if $cv < 0.3;
        J.fro->('G 0.3', u.G, 0.2, '%css'=>"font-size:80%"); # TODO relative down
        return if $cv < 0.4;
      C: | #c
        my $cv = J.cv ||= 0.3;
        J.bb->{"thi 0.01"} = ref $u;
        J.bb->{"thi%tt 0.01"} = u.id;
        return if $cv < 0.1;
        
        J.bb->{"K 0.11"} = u.K;
        J.bb->{"name 0.12"} = u.name;
        
        return if $cv < 0.2;
        
        
        my $B = u.B if u.B && ref u.B eq 'HASH';
        if (B.name) { # B aetc
            J.bz->("B_name 0.23", u.B.name); 
        }
        
        my $S = u.S if u.S && ref u.S eq 'HASH';
        if ($S && %$S) {
            J.fro->('S 0.4', $S, 0.4);
            J.fro->('SZ 0.5', S.Z, 0.4) if u.S.Z;
            J.bz->('SZ 0.5', "$S S.Z u.S.Z.left S.Z.top", '%css','font-size:50%') if S.Z;
        }
        
        my $Z = u.Z if u.Z && ref u.Z eq 'HASH';
        if ($Z && %$Z) {
            J.fro->('Z 0.5', u.Z, 0.4);
        }

        
        
        return if $cv < 0.3;
        
        if (u.G && (defined u.print || u.Gw)) {
            my $p = u.G->w('print' => {}, $u, {nodie=>1});
            J.bb->{"print 0.3"} = $p if defined $p;
        }
        
        
        # dusseldorf
        my %s = map { $_=>1 } grep { /^[a-z]/ } keys %$u;
        delete $s{id};
        my @or = qw'name point timer', keys %s; 
        
        my $c; 
        my $b; 
        for my $k (@or) {
            next if !defined $k;
            next if !exists $u->{$k};
            my $t = $u->{$k};
            next if !defined $t;
            next if ref $t;
            next if $t =~ /\n/; 
            next if $k eq 'name';
            my $slim = slim(20,20,$t);
            
            J.bb->{"$k 0.4"} = $slim if $cv >= 0.4; # also a dus fuzz away
        }
        

