

mod c: # pile of stuff on the ceiling # pull out the culture protocol re MZ meanings
 - K: unico #c
   mod 3.3: |
      my $c = ref $cs ? $cs : {};
      my $ent = d.s =~ /^(d+)$/ ? $1 : J.ent.2;
      for my $i (1..(c.thi||24)) {
          my $entoi = $1 if ($ent * $i) =~ /(\d)$/;

          my ($b, $dd) = unico(n.um+$i* 100 * $entoi, 1);
          my $pa = $entoi > 7 ? "  " : $entoi > 3 ? " " : "";
          push @{n.gl||=[]}, $pa.$b;
      }
 - K: zim #c seem z swim
   mod 3.3: |
     my $osc = n.zim->{$cs} ||= do {
         $cs =~ /^($NUM)\^v($NUM)(?:\*($NUM))?$/ || die "no zim osc $cs";
         {ce => $1, ext => $2, mul => ($3||1)}
     };
     osc.pi ||= 1;
     osc.v = osc.ext if !defined osc.v;
     osc.pi = -1 if osc.pi > 0 && osc.v >= osc.ext;
     osc.pi = 1 if osc.pi < 0 && osc.v <= -osc.ext;
     
     osc.v += osc.pi;
     
     d.cs.zim.zi = osc.ce + (osc.v*osc.mul);
        
 - K: cow #c hs mods be more fun
   mod 3.4: |
     # TODO hex round sweepage
     my @col = hexend($cs);
     my @wo = grep{/^[1-9]$/} split '', d.pcv;
     
     my $wi = sub { $_[0] += $_[1]; $_[0] -= 15 if 15 < $_[0]; };
     my $win = {};
     my $wc = {qw{r 0 g 1 b 2}};
     for (0,1,2) {
          my $wa = $wc->{$_};
          $win->{$_} = $cs =~ /w$wa-(\d)/ ? $1 : $_;
     }
     my $fore = join ' ', @col;
     unless ($cs =~ /no/) {
         my $norgb = $cs !~ /r|g|b/;
         for my $k (keys %$wc) {
             my $n = $wc->{$k};
             my $ad = $wo[$win->{$n}];
             # patch bay ^
             my $mult = 9;
             $mult = $1 if $cs =~ /$k(\d+)/;
             $ad *= ($mult / 9);
             $wi->($col[$n], $ad) if $norgb || $cs =~ /$k/;
         }
     }
     #saybl "cow mod $fore  ->  ".join ' ', @col;
     my $col = hexbe(@col);
     # hexify? dark is nice
       # art this shit proply ^
     d.cs.olo.co = $col;
 - K: mixco #c mix into olo.co
   mod 3.5: |
     $cs =~ /^($NUM )?(...)$/;
     my $mix = $1;
     my @col = hexend($2);
     my @fro = hexend(d.cs.olo.co);
     for (0,1,2) {
         my $yu = $fro[$_] - $col[$_];
         #$yu *= -1;
         $yu = $yu * $mix;
         #say " $yu          from $col[$_]-$fro[$_] * $mix       ";
         $fro[$_] -= $yu;
     }
     #say hexbe(@fro);
     #d.cs.olo.co;
     d.cs.olo.co = hexbe(@fro);
     
     
     #
 - K: fs #c MOD MOD MOD 1=stable 2=sweep # & SWIM
   mod 3.3: |
     my ($n1,$n2) = $cs =~ /^($NUM)(?:_($NUM))?/;
     # n1 already 0.4 if it wants to be tiny
     my $siz = 100 * (12 / $n1);
     $siz -= n.um / $n2 if $n2;
     d.cs.fsgy.fs = int $siz;
 - K: fsx #c text fit
   mod 3.4: |
        my $si = length(d.c.s);
        my $curve = {qw{
        40 6
        30 7
        20 9
        }};
        for (sort keys %$curve) {
            d.cs.fsx.fs = $curve->{$_} if $si > $_
        }
 - K: sh #c
   mod 3: |
     d.cs.sh.sha = '2 2 7 ffc';
 - K: jamit #c
   mod 3: |
     d.cs.awl = "JAMTHATFUELTANK";
 - K: s #c yes
   mod 3.1: |
     acum $n, gl => $cs; # some funky magnation
 - K: i #c  $i is the osc, attach on $v to $n
   mod 3.1: |
     d.t = d.t."-".n.iii->{$cs}++; 
     d.r = join "\t", d.t, d.cv;
 - K: carbcap #c jel like language # n.gl gravity, implosi # agg from chaos
   MZ: {}
   mod 3.9: |
     if (n.gl && @{n.gl} && !n.ogl) {
         my $was = d.s;
         d.s = join'',@{n.gl};
         #saybl "carb capin (was '$was') --> d.s" if ar.V;
         delete n.gl;
         # roll ^ dough, the gel that gl may be
         # now snaps off a branch
         # continuous notation we still pick up as chunks of lingo geom
     }
     # ^ es also like looking for most magnity n.thee value heading for $s
     # carbdome...
R_Jz:


 - K: pi #c
   n_D:
      wtf: | #c
        J.bz->('know 0.1', "$u");
      ARRAY: | #c
            my $cv = J.cv ||= 0.3;
            
            my $si = @$u;
            J.bz->('si 0.1' => $si, '%css' => "color:#fff;font-size:50%");
            J.bz->('Bo 0.11' => '[');
            J.bz->('oB 0.89' => ']');
            
            return if $cv < 0.2;
            
            
            my @cvs = Rw cv/oe $v:si;
            my $i = 0;
            while (exists $u->[$i]) {
                my $uu = $u->[$i];
                my $vc = shift @cvs;
                if ($i > 0) {
                    J bz [${i}/Bs 0.2${vc}1 ','
                }
                
                my $vcv = J.cv - 0.2; # dus bend for $k
                $vcv = 0.1 if $vcv < 0.1;
                
                J fro [${i} 0.2${vc}4 $uu, $vcv, "%css" => "font-size:75%"
                
                $i++;
                if ($i >= 5) {
                    J bz more 0.88 "@", '%sf' => "blue"
                    last;
                }
            }
      HASH: | #c
            my $cv = J.cv ||= 0.3;
            
            my $si = keys %$u;
            J.bz->('si 0.1' => $si, 'si%css 0.1' => "color:#fff;font-size:50%");
            
            J bz Bo 0.11 '{'
            J bz oB 0.89 '}'
            
            return if $cv < 0.2;
            
            # 3
            my $r = {map{$_=>1} sort keys %$u};
            my @r = grep { delete $r->{$_} } qw'K name';
            push @r, sort keys %$r;
            
            my @cvs = Rw cv/oe $v:si;
            my $i = 0;
            for my $k (@r) {
                my $v = $u->{$k};
                my $vc = shift @cvs;
                if ($i > 0) {
                    J bz {$k/Bs 0.2${vc}1 ','
                }
                
                my $fs = 75;
                my $ksi = length($k);
                $fs -= ($ksi - 8) * 8 if $ksi > 8;
                $fs = int($fs);
                $fs = 25 if $fs < 25;
                    

                J bz {$k/k 0.2${vc}2 $k, "%css" => "color:#acf;font-size:$fs%"
                
                my $vcv = J.cv - 0.2; # dus bend for $k
                if ($vcv >= 0.2) {
                
                    J bz {$k/Bi 0.2${vc}3 ':', '%css' => "font-size:40%"
                    
                    my $fs = 75;
                    $fs -= length($v) - 8 * 4 if 8 < length $v;
                    $fs = int($fs);
                    
                    J fro {$k/v 0.2${vc}4 $v, $vcv, '%css' => "font-size:$fs%"

                }
                
                $i++;
                if ($i >= 5) {
                    J.bz->("more 0.2 0.886" => "@",
                    
                        '%sf' => "blue");
                    last;
                }
            }
      HASH2: | #c
            my $cv = J.cv ||= 0.3;
            
            my $si = keys %$u;
            J.bz->('si 0.1' => $si, 'si%css 0.1' => "color:#fff;font-size:50%");
            
            J.bz->("B:Bo 0.1 0.1" => '{');
            J.bz->('B:oB 0.1 0.89' => '}');
            
            return if $cv < 0.2;
            
            # 3
            my $r = {map{$_=>1} keys %$u};
            my @r = grep { delete $r->{$_} } qw'K name';
            push @r, sort keys %$r;
            
            my $ki = 0;
            my $i = 0;
            J.bz->('B:Bs 0.2', ',');
            J.bz->('B:Bi 0.3', ':');
            
            for my $k (@r) {
                my $v = $u->{$k};
                $i++;
                if ($cv < 0.8 && $i >= 5) { # braids at 0.8
                    J.bz->("more 0.2 0.886" => "@", '%sf' => "blue");
                    last;
                }
                
                my $ii = sprintf('%04d', $i);
                
                J.bz->('B/'.$ii.'/k 0.2', $k,
                
                    '%css' => 'color:#acf;font-size:80%');
                
                
                my $vcv = J.cv - 0.2; # dus bend for $k
                if ($vcv >= 0.2) {
                    J.fro->('B/'.$ii.'/v 0.3', $v, $vcv,

                        '%css' => 'font-size:75%');
                }
            }
      ref: | #c weird ref
        J.bz->('knowref 0.1', "$u", '%css'=>'color:#945;font-size:70%');
      code: | #c
        J.bz->('know 0.1', "CODE");
      undef: | #c
        J.bz->('know 0.1', '~');
      text: | #c
            my $text = $u;
            
            my @s;
            my $adhow = $text =~ s/\n/↯/g;
            
            my $tev = int(J.cv * 200); # 0.4 = 100
            
            my $si = length($text);
            if (!$si) {
                J.bz->('length 0.1', "''", '%sf', 'blue');
            }
            if ($si > $tev) {
                $text = ($text=~/^(.{$tev})/s)[0];
            }
            else {
                undef $si;
            }
            
            J.bz->('line 0.1' => $text,
                '%css' => "background:rgba(200,30,80,0.3);color:#3f3;"
                    ."font-size:70%");
            
            if ($si) {
                J.bz->("more 0.89" => "@",'%sf' => "blue");
            }
            
            return if J.cv < 0.2;
            
            my $ni = J.c.lin if J.c.lin > 1;
            my $bi = J.c.b if J.c.b > 1;
            
                J.bz->("si/l 0.2" => "$si",
                    '%css' => "color:#b89;font-size:50%;position:absolute") if $si;
                J.bz->('si/n 0.2' => "$ni",
                    '%css' =>
                        "color:#fff;font-size:50%;"
                        ."position:absolute;margin-top:1.4em;") if $ni;
                J.bz->('si/b 0.2' => "b$bi",
                    '%css' =>
                        "color:#f89;font-size:50%;"
                        ."float:left;left:-1em") if $bi;
                   
            if (J.cv < 0.7 && $text =~ /^(# \d.+?)↯/) {
                J.bz->('line 0.1' => $1,
                '%css' => "background:rgba(200,30,80,0.3);color:#3f3;"
                    ."font-size:70%");
            }
            return if J.cv < 0.7;
            
            # 7
            my @tex = split /\n/, $u;
            #my $s = $G->vimcolor($u);
            #$s =~ s/^(<span) (class="synComment">.+?)(<\/span>)/$1 style="font-size:170%;" $2$com$3/;
            
            #$tex[0] .= " #J.cv";
            
            my $surge = int(100 * (J.cv - 0.7));
            # add interesting o to tex 0.7ishs as surge goes
            (my $one, my @o) = @tex if J.cv < 0.8;
            @tex = $one if @o;
            my $urge = $surge / 2;
            $urge = 0; # TODO colours and
            for (@o) {
                last if @tex >= $urge;
                push @tex, $_ if /^#/
                    || /R\./
                    || /\-\>/
                    || /w\ /;
            }
            
            
            my $lim = ";height:19em;overflow-y:scroll" if @tex > 19;
            $lim .= ";background:rgba(70,40,0,1);" if J.cv >= 0.8;
            
            my $fs = int(50 + $surge * 7);
            $fs = "font-size:$fs%;";
            
            my $s = join"\n", @tex;
            J.bz->("line 0.1" => $s, '%tag'=>'pre','%gp'=>{vimcolor=>1},
                '%css' => "margin:0.2em;background:rgba(30,30,60,1);$fs-webkit-filter:hue-rotate(80deg);$lim");
      A: | #c
        my $cv = J.cv ||= 0.3;
        
        J bz thi 0.01     ref $u
        return if $cv < 0.1;
        J bz name 0.1     u.name
        return if $cv < 0.2;
        J bz K 0.2        u.K
        
        J fro i 0.2 u.i, 0.2
        
        return if $cv < 0.3;
        
        my $un;
        for my $nuk (keys %$u) {
            next if $nuk !~ /^(u|n)/;
            my $v = $u->{$nuk};
            my $tot = ref $v eq "ARRAY" ? @$v : $v;
            $un->{$1}->{$nuk} = $tot;
            my $lv = $1 eq "u" ? 1 : 2;
            
            J.bz->("un/$1/${nuk}_nuk 0.3$lv", "$nuk:",
                    
                    "\%css" => "color:#acf;font-size:80%");
            
            J.fro->("un/$1/${nuk}_t 0.3$lv", $tot, 0.2,
                    
                    "\%css" => "color:#fca;font-size:80%");
        }
        
      G: | #c
        my $cv = J.cv ||= 0.3;
        J.bb->{"thi 0.01"} = ref $u;
        return if $cv < 0.1;
        J.bb->{"K 0.11"} = u.K;
        J.bb->{"name 0.12"} = u.name;
        return if $cv < 0.2;
        
      T: | #c dodge
        J.bz->('pi 0.1', $u->pi);
      J: | #c dodge
        my $cv = J.cv ||= 0.3;
        J.bb->{"thi 0.01"} = ref $u;
        return if $cv < 0.1;
        J.bb->{"name 0.1"} = $H->ejson(u.B) if u.B;
        return if $cv < 0.2;
        J.fro->('i 0.2', $u, 0.1);
        return if $cv < 0.3;
        # 3
          my $bits = do {
              my $a = {u=>$u, wa=>'up'};
              w $R gp[$u, $a];
              J.bb
          };
          J.bb->{'bit/'.$_} = $bits->{$_} for keys %$bits;
        
      up: | #c
            my $r = {map{$_=>1} sort keys %$u};
            
            my $ordy = {
                A => 1,
                id => 11,
                K => 12,
                name => 13,
                G => 14,
                R => 14,
                W => 2,
            };
            my $ydro = {};
            push @{$ydro->{$_}||=[]}, $_ for keys %$ordy;
            my @order = map { @{$ydro->{$_}} } sort keys %$ydro;
            
            my @r = grep { delete $r->{$_} } @order;
            push @r, sort keys %$r;
            
            my $ki = 0;
            my $i = 0;
            for my $k (@r) {
                my $v = $u->{$k};
                
                my $ord = $ordy->{$k} || 4;
                J.bb->{"$k\t".'0.'.$ord} = ''.$v;
                
                $i++;
            }
      H: | #c
        J.bz->('thi 0.01' => 'H');
        J.bz->("name 0.06" => u.style);
        J.bz->("K 0.1" => u.name);
        
      R: | #c
        my $cv = J.cv ||= 0.3;
        J.bb->{"thi 0.01"} = ref $u;
        return if $cv < 0.1;
        J.bb->{"K 0.11"} = u.K;
        J.bb->{"name 0.12"} = u.name;
        return if $cv < 0.2;
        return if $cv < 0.3;
        J.fro->('G 0.3', u.G, 0.2, '%css'=>"font-size:80%"); # TODO relative down
        return if $cv < 0.4;
      C: | #c
        my $cv = J.cv ||= 0.3;
        J.bb->{"thi 0.01"} = ref $u;
        J.bb->{"thi%tt 0.01"} = u.id;
        return if $cv < 0.1;
        
        J.bb->{"K 0.11"} = u.K;
        J.bb->{"name 0.12"} = u.name;
        
        return if $cv < 0.2;
        
        
        my $B = u.B if u.B && ref u.B eq 'HASH';
        if (B.name) { # B aetc
            J.bz->("B_name 0.23", u.B.name); 
        }
        
        my $S = u.S if u.S && ref u.S eq 'HASH';
        if ($S && %$S) {
            J.fro->('S 0.4', $S, 0.4);
            J.fro->('SZ 0.5', S.Z, 0.4) if u.S.Z;
            J.bz->('SZ 0.5', "$S S.Z u.S.Z.left S.Z.top", '%css','font-size:50%') if S.Z;
        }
        
        my $Z = u.Z if u.Z && ref u.Z eq 'HASH';
        if ($Z && %$Z) {
            J.fro->('Z 0.5', u.Z, 0.4);
        }

        
        
        return if $cv < 0.3;
        
        if (0 && u.G && (defined u.print || u.Gw)) {
            my $p = u.G->w('print' => {}, $u, {nodie=>1});
            J.bb->{"print 0.3"} = $p if defined $p;
        }
        
        
        # dusseldorf
        my %s = map { $_=>1 } grep { /^[a-z]/ } keys %$u;
        delete $s{id};
        my @or = qw'name point timer', keys %s; 
        
        my $c; 
        my $b; 
        for my $k (@or) {
            next if !defined $k;
            next if !exists $u->{$k};
            my $t = $u->{$k};
            next if !defined $t;
            next if ref $t;
            next if $t =~ /\n/; 
            next if $k eq 'name';
            my $slim = slim(20,20,$t);
            
            J.bb->{"$k 0.4"} = $slim if $cv >= 0.4; # also a dus fuzz away
        }
        

