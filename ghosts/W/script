name: wormhole splatter
tractors:
  - K: 'W/script'
    arr_if: |
      $W && ref $W eq "Wormhole";
    B_: |
      1
    print: |
      $S->{K} .": ". $S->{B}->{_}
    first_time: |
      $S->{lines} = $G->Gc("W/line");
      
    tolines: |
      my $l = $S->{lines};
      $l->RW; # or...
      for my $line (@{$W->{script}}) {
            $l->T($line);
      }
hooks:
  arr: |
    my $W = $thing;
    my $S = Arr[$W];
    w $S tolines;
    
  go: |
    Info "\n splat go:   ".join "  ", %$ar;
    exists $ar->{line}
      ? $G->w('into_the_way_out', $ar)
      : $O->w('somewhere', $ar);
    
  into_the_way_out: |
    my $CG = $O->Gf("crawl") || die "no O G crawl";
    
    my $NS = $CG->w('revisit', { line => $line, push_depth => 1 });
    $NS || die "NO!";
    
    my $wormhole = { script => $NS };
    
    my $A = Afind[$splatname];
    unless ($A) {
        #die "no such splatname: $splatname";
        w go(thing => {antf=>[@F], undef_by => $splatname, z => $G->W->CS} );
        return;
    }
    w script_out[$A, $wormhole, $splatname, $append];
  lcodon: |
    my @files;
    my $t = $line->{t};
    if (ref $t eq "Ghost") {
        @files = @{ $t->{wayfiles} };
    }
    else { die "get codes from $t"; }
    
    for my $file (@files) {
        my $c = Codon->new($H->intro,
            { codo => $H->getapp("Codo"),
            filename => $file }
        );
        $c->{show} = $S->{view}->spawn_floozy($G, "codon-del-$line->{uuid}",  "width:89%; background:#80182; color:#afc; height:23em;", after => $A->{C}->{Line}->{S}->{id});
        $c->display();
    }
  


  script_out: |
    my $lines = [];
    my $i = 0;
    for my $line (@{$wormhole->{script}}) {
        if($i++ > 400) {
            push @$lines, "more...";
            last;
            
            
        }
        my ($R, $B) = ([], {});
        push @$lines, w make_line[$splatname, $i, $R, $B, $line];
    }
    my $th = {
        nospace => 1,
        class => 'menu',
        tuxtstyle => 'width: 100%;',
    };
    $th->{append} = $ar->{append} if $ar->{append};
    
    my $t = $A->{view}->newtext($lines, $th);
    return $t;
  
  make_line: |
    ref $line eq "HASH" || die  "FUKN ".wdump($line);
    
    w line/value; # R <-> B to be tractored

    return { _spawn => [ $R, {
        nospace => 1,
        B => $B,
        tuxtstyle => 'opacity:1; height:120%;position: relative; float: left;',
        tuxts_to_htmls => sub {
            my $texty = shift;
            my $tx = $texty->{tuxts};
            
            w tuxtsB(B => $B, tx => $tx);
            w line/style;
        },
    }]}

