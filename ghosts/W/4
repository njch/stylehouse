R_Jz:
 - K: styles #c
   n_D:
     any_init: |
       Rw styles/z;
     z: |
       # quick rezip 
       # vamp compressioms
       # that is things before even J personality mods
       # same Jway, phases etc.
     
 - K: ash #c woosh
   n_D:
     life: |
       die;
       sayre "GOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO" for 1..12;
       J.yy.jiter = 'borg';
 - K: afghanrug #c
   n_D:
     mods:
        - 
          - sqww
          - 18
          - s: ஓ୶
            fs: 7.9
            cow: 315
          - blr: 5
 - K: ocean #c
   n_D:
     mods:
       -
         - sqw
         - 16 # rivm add space every 1/3 so these go @ ~ ~ @ ~ ~ or so
         - s: '~'
         - fs: 73
       -
         - sq
         - 8
         - cow: 123
           s: '@'
         - fs: 73
 - K: faut #c
   n_D:
     mods:
        - 
          - sqww
          - 10
          - s: ஓ୶
            fs: 7_3
          - co: 3f0
            blr: 3
            ml: 3em
mod c: # pile of stuff on the ceiling
 - K: s #c yes
   mod 3.1: |
     acum $n, gl => $cs; # some funky magnation
 - K: rug #c make carpety
   MZ: {}
   mod 3.2: |
     d.cs.rug.zi = -2;
 - K: unico #c
   mod 3.3: |
      my $c = ref $cs ? $cs : {};
      my $ent = d.s =~ /^(d+)$/ ? $1 : J.ent.2;
      for my $i (1..(c.thi||24)) {
          my $entoi = $1 if ($ent * $i) =~ /(\d)$/;

          my ($b, $dd) = unico(n.um+$i* 100 * $entoi, 1);
          my $pa = $entoi > 7 ? "  " : $entoi > 3 ? " " : "";
          push @{n.gl||=[]}, $pa.$b;
      } 1..34;
 - K: cow #c
   mod 3.4: |
     $i =~ /(\d)?(\d)?(\d)?$/;
     my $col = join'',
       map { /^.*(\d+).*$/; $1 }
       map { J.ent.3 > 6 && $_ > 5 && -4 + J.ent.3 || $_ }
       map{ J.ent.1 > 6 ? $1 * (J.ent.3 / 4) :$_}
       $1,$2,$3;
       # art this shit proply ^
     d.cs.olo.co = $col;
     d.cs.olo.ws = 'p';
 - K: fs #c MOD MOD MOD 1=stable 2=sweep # & SWIM
   mod 3.3: |
     my ($n1,$n2) = $cs =~ /^($NUM)(?:_($NUM))?/;
     # n1 already 0.4 if it wants to be tiny
     my $siz = $n1 * 24;
     $siz -= n.um / $n2 if $n2;
     d.cs.fsgy.fs = $siz;
 - K: sh #c
   MZ: {}
   mod 3: |
     d.cs.awl.sha = '2 2 7 0fc';
 - K: jamit #c
   mod 3: |
     d.cs.awl = "JAMTHATFUELTANK";
 - K: carbcap #c jel like language
   MZ: {}
   mod 3.9: |
     if (n.gl && @{n.gl}) {
         d.s = join'',@{n.gl};
         delete n.gl;
         # roll ^ dough, the gel that gl may be
         # continuous notation we still pick up as chunks of lingo geom
     }
     # ^ es also like looking for most magnity n.thee value heading for $s
     # carbdome...

 - K: yinvis #c what it means to be here
   mod 1: |
     # an extremity at one point
     # two places at once to pack d.in, overallness of loop
     my $v = $i / (999 - d.in);
     n.um = sprintf '%.3d', ($i * $v + 5);
     # hex round sweepage
 - K: yangco #c background language expansion
   mod 2: |
     # yang may pass arounJ komp struc intact for a while
     
 - K: dsc #c cs on d, outside mod twistor pipe
   mod 7: |
     # sc.$sc -> (stable compressions), specd by the */mods vac
     # also any $sc maybe be like {$k => $sc, $k2 => $sc2}
     # for comments like v  # so comp is the very last hash, the rest is where etc.
     #push @{d.css}, '%css#'.$_ => d.cs->{$_}
     #    for sort keys %{d.cs};
     if (d.sc && %{d.sc}) {
         push @{d.css}, Rw escn $sc:d.sc sc;
     }
 - K: dcs #c cs in da pipe, modulating or so
   mod 7: |
     # cs.$k.$sc -> squiggly first style compressions
     # the wilder pole, coming from mods
     # there's stuff across the whole line too
     # and what's between...
     # exp to css for now...
     if (d.cs && %{d.cs}) {
         push @{d.css}, Rw escn $sc:d.cs;
     }
esc c:
 - K: sha #c it
   D: |
     my @m = split m/\s/, $v;
     $m[-1] = X.cole->($m[-1]);
     sprintf 'text-shadow:%dpx %dpx %dpx %s', @m;
 - K: cole #c it
   D: |
        my $h;
        (h.r, h.g, h.b, h.la) = ($1, $2, $3, $4)
                  if $v =~ /^(\w)(\w)(\w)(\w)?$/ || die;
        
        if (defined h.la) {
           # do an rgba(255,255,255,1)
           for my $k (qw'r g b la') {
               my $e = $h->{$k};
               $e = "$e$e" if length $e == 1; # out of 255
               $h->{$k} = hex $e;
           }
           h.la = sprintf '%.2f', h.la / 255; # out of 1
           return "rgba(h.r,h.g,h.b,h.la)";
        }
        else {
           return sprintf "#%s%s%s", h.r, h.g, h.b;
        }
 - K: zi #c it
   D: |
     "z-index:$v"
 - K: co #c it
   D: |
     "color:".X.cole->($v);
 - K: fs #c it
   D: |
     $v *= 9;
     'font-size:'.int($v).'%';
 - K: ws #c it
   D: |
     my @wtf;
     push @wtf, 'white-space:pre' if $v =~ /p/;
     join ';', @wtf;
 - K: blr #c it
   D: |
     '-webkit-filter:blur('.$v.'px)'
 - K: ml #c it
   D: |
     $v .= 'em' if $v !~ /(%|em|px)/;
     "margin-left:$v"

