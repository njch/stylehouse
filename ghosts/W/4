R_Jz:
 - K: styles #c
   n_D:
     any_init: |
       Rw styles/z;
     z: |
       # quick rezip 
       # vamp compressioms
       # that is things before even J personality mods
       # same Jway, phases etc.
     
 - K: ash #c woosh
   n_D:
     life: |
       die;
       sayre "GOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO" for 1..12;
       J.yy.jiter = 'borg';
 - K: afghanrug #c
   n_D:
     mods:
        - 
          - sqww
          - 12
          - s: ஓ୶
            fs: 7.9
            cow: 315
          - blr: 8
            zi: 1
 - K: flax #c
   n_D:
     mods:
        - 
          - sqwo
          - 7
          - s: ஓ୶
            fs: 3.9 
            cow: 86f
          - blr: 5
            zi: 2
 - K: ocean #c
   n_D:
     mods:
       -
         - sqw
         - 16 # rivm add space every 1/3 so these go @ ~ ~ @ ~ ~ or so
         - s: '~'
         - fs: 24
           zi: 3
       -
         - sq
         - 8
         - cow: f33
           unico: 4
           s: '@'
         - fs: 73
           zi: 2
 - K: oci #c
   n_D:
     mods:
       -
         - ociw
         - 16 # rivm add space every 1/3 so these go @ ~ ~ @ ~ ~ or so
         - s: '|'
         - fs: 22
           zi: 4
 - K: faut #c
   n_D:
     mods:
        - 
          - sqww
          - 10
          - s: ஓ୶
            fs: 8_3
          - co: 140
            blr: 3
            ml: 1em
mod c: # pile of stuff on the ceiling # pull out the culture protocol re MZ meanings
 - K: s #c yes
   mod 3.1: |
     acum $n, gl => $cs; # some funky magnation
 - K: unico #c
   mod 3.3: |
      my $c = ref $cs ? $cs : {};
      my $ent = d.s =~ /^(d+)$/ ? $1 : J.ent.2;
      for my $i (1..(c.thi||24)) {
          my $entoi = $1 if ($ent * $i) =~ /(\d)$/;

          my ($b, $dd) = unico(n.um+$i* 100 * $entoi, 1);
          my $pa = $entoi > 7 ? "  " : $entoi > 3 ? " " : "";
          push @{n.gl||=[]}, $pa.$b;
      } 1..34;
 - K: cow #c
   mod 3.4: |
     # TODO hex round sweepage
     n.um =~ /(\d)?(\d)?(\d)?$/;
     my $col = join'',
       map { /^.*(\d+).*$/; $1 }
       map { J.ent.3 > 6 && $_ > 5 && -4 + J.ent.3 || $_ }
       map{ J.ent.1 > 6 ? $1 * (J.ent.3 / 4) :$_}
       $1,$2,$3;
       # art this shit proply ^
     d.cs.olo.co = $col;
     d.cs.olo.ws = 'p';
 - K: fs #c MOD MOD MOD 1=stable 2=sweep # & SWIM
   mod 3.3: |
     my ($n1,$n2) = $cs =~ /^($NUM)(?:_($NUM))?/;
     # n1 already 0.4 if it wants to be tiny
     my $siz = $n1 * 24;
     $siz -= n.um / $n2 if $n2;
     d.cs.fsgy.fs = $siz;
 - K: sh #c
   MZ: {}
   mod 3: |
     d.cs.sh.sha = '2 2 7 0fc';
 - K: jamit #c
   mod 3: |
     d.cs.awl = "JAMTHATFUELTANK";
 - K: carbcap #c jel like language # n.gl gravity, implosi # agg from chaos
   MZ: {}
   mod 3.9: |
     if (n.gl && @{n.gl}) {
         saybl "carb capin (was d.s) to:\n\n@{n.gl}" if ar.V;
         d.s = join'',@{n.gl};
         delete n.gl;
         # roll ^ dough, the gel that gl may be
         # now snaps off a branch
         # continuous notation we still pick up as chunks of lingo geom
     }
     # ^ es also like looking for most magnity n.thee value heading for $s
     # carbdome...
esc c:
 - K: sha #c it
   esc 3: |
     my @m = split m/\s/, $v;
     $m[-1] = X.cole->($m[-1]);
     sprintf 'text-shadow:%dpx %dpx %dpx %s', @m;
 - K: cole #c it
   esc 3: |
        my $h;
        (h.r, h.g, h.b, h.la) = ($1, $2, $3, $4)
                  if $v =~ /^(\w)(\w)(\w)(\w)?$/ || die;
        
        if (defined h.la) {
           # do an rgba(255,255,255,1)
           for my $k (qw'r g b la') {
               my $e = $h->{$k};
               $e = "$e$e" if length $e == 1; # out of 255
               $h->{$k} = hex $e;
           }
           h.la = sprintf '%.2f', h.la / 255; # out of 1
           return "rgba(h.r,h.g,h.b,h.la)";
        }
        else {
           return sprintf "#%s%s%s", h.r, h.g, h.b;
        }
 - K: zi #c it
   esc 3: |
     "z-index:$v"
 - K: co #c it
   esc 3: |
     "color:".X.cole->($v);
 - K: fs #c it
   esc 3: |
     $v *= 9;
     'font-size:'.int($v).'%';
 - K: ws #c it
   esc 3: |
     my @wtf;
     push @wtf, 'white-space:pre' if $v =~ /p/;
     join ';', @wtf;
 - K: blr #c it
   esc 3: |
     '-webkit-filter:blur('.$v.'px)'
 - K: ml #c it
   esc 3: |
     $v .= 'em' if $v !~ /(%|em|px)/;
     "margin-left:$v"

