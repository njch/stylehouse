
mod c:
 - K: fo #c yes
   mod 3.6: |
     my $f = J.fo->(@$cs); # magnetic fishingrods
     d.cs.fo.fo = $f;
     d.s = f.s;
     n.gl = [];
     say "was fo d.s";
     # make like to hook %gp towards set f.r to the line this fo is on
 - K: pwth #c -> !some/path exp.
   mod 3.1: |
     my $path = $cs;
     $path = "!$path" unless $path =~ /^ /;
     c.path && die;
     c.path = $path;
 - K: path #c install cs path
   mod 3.2: |
     d.cs.pwth.path = $cs;
     d.cs.pwth.idly = 1 unless c.fo; # will prov
     # later style %idly when %path but no /%id
esc c:
 - K: path #c
   esc 3: |
     '%path'=>$v
 - K: idly #c
   esc 3: |
     '%idly'=>$v
 - K: fo #c ag
   esc 3: |
     v.r = d.r; 
     '%gp' => $v 
R_Jz:
 - K: nnn #c twining
   D: |
       # the class etc bits of $e might clue in what to do
       # maybe can mousedown just x y?
       # J is the 1circle, J2 the 2circle (bw)
       # path must be somewhere around here...
       # on the gp's / which is inside yet outsideness, or the lev... whatev. turnstyle
       
       # there's a bunch of paths, there interesting
 - K: thesurf #c CURVE curver
   n_D:
     yJup: |
       J.yy.round.id = 3;
       qw'thesurf sur faut oci'
     curves: |
         #["spun 0" => 0.025],
         ["curve 1" => -0.211],
         ["zoom 0" => 0.15],
         ["zoom 0.21" => -0.05],
         ["y 0" => 0],
         ["x 0" => 0], 
         ["x 0.1" => 0.06],
         ["curve 0.3" => -0.111],
         #["zoom 0.5" => -0.03],
         
     mods:
        - 
          - sq
          - 10
          - s: ~
            fs: 7_3
          - co: 8ff
            blr: 3
       
 - K: thrash #c CURVEd curver
   n_D:
     yJup: |
       J.yy.round.id = 3;
       'thrash', 'ash', 'sur'
     curves: |
         ["zoom 0" => 0.10],
         ["y 0" => 0],
         ["x 0" => 0.4],
         ["x 0.1" => 0.46],
         ["curve 0.3" => -0.041],
         
     mods:
        - 
          - sq
          - 10
          - s: ~
            fs: 7_3
          - co: 8ff
            blr: 3
            ml: 3em
       
 - K: theself #c CURVE domer
   n_D:
     yJup: |
       J.yy.round.id = 3;
       'theself', 'sur'
     curves: |
         ["spun 0" => 0.025], 
         ["curve 1" => 0.211],
         ["zoom 0" => 0.15],
         ["zoom 0.21" => -0.05],
         ["y 0" => 0],
         ["x 0" => 0.8],
         ["x 0.1" => 0.7],
         ["curve 0.3" => -0.111],
         #["zoom 0.5" => -0.03],
         
     mods: |
       [sq   => 10,  '~'],
       #[sqat   => 20,  '^', {}, 'color:blue', in => 10, ],
       #[sqat   => 20,  'v', {}, 'color:blue', out => 10, ],
 - K: duck #c fo9od's
   n_D:
     yJup: |
       'duck', 'sur', 'faot'
     curves: |
       ["spun 0" => 0.9],
       ["y 0" => 0.7],
       ["x 0" => 0.6],
       ["zoom 0" => 0.06],
       ["curve 0.1" => -0.024],
 - K: pw #c mo mod
   
 - K: sur #c SURish rondo: on -> square ->
   n_D:
     X: | #c close
      w G.R del(u=>$J);
     to: | #c into
       my $to = shift @$m;
       my $r;
       for ($to) {
           r.t = [] when '/';
           r.i = $G when 'G';
           die         when 'feed'; # look at cont moves?
           r.i = Rw Jung
                       when 'Jung';
           r.i = Rw onJ o2x theself
                       when 'self';
           
           default {
               die "no yyyyyyyyyyyy to $to   on ".$J->pi;
           }
       }
       Rw inness $J $r;
     conty: | #css # eats event + HASH preparation $pa
       my $r = {}; # sproutya
       # ^ outer $y compressions understood 
        #  by 2ale of inness J.onei, compiled...
       # will lovely to maintain in spiral
       saybl "pat: $y   mmmm @$m";
       #/  ^ m
          # language inthemiddle
       #\  v m
       if (e.type eq 'click') {
           for ($y) {
               when (/^(\{|\[)/) {
                   r.t = $y;
                   Rw sur/folw $r $J;
               }
               default {
                   die "dunno $y"
               }
           }
       }
       elsif (e.type eq 'keydown') {
               say "is key e.k";
               for (e.k) {
                   when ('0') {
                       my $t = J.onei.t;
                       my @t = @{$t||die};
                       pop @t;
                       my $r = {t=>\@t};
                       Rw inness $J $r;
                   }
               }
       }
       else {
             say "Sur". wdump($e);
       }
     heading: |
       
     heading: | #c
       J3.lev->("J\t0.01", sub {
           my $J2 = shift;
           my $M = [
               ['J', 'sur/self', {fo=>[$J,0.1]}],
               ['Æ¾', 'hull/mkboot', {}, {co=>'8ff'}],
               ['G', 'sur/to:G'],
               ['x', 'sur/X', {}, {co=>'f34',fs=>3}],
               ['Jung', 'sur/to:Jung', {}, {co=>'68d', fs=>5}],
           ];
           Rw mo/pwth $J:J2 $M 0.1-0.3;
       }, '%css'=>'font-size:200%');
     oning: | #c
       J3.lev->("onei\t0.06" => sub {
           my $J2 = shift;
           my $on = J.onei;
           my $M = [
               ['=','', {}, {fs=>12,co=>'000'}],
               ['i', 'sur/to:/', {fo=>[on.i,0.1]}]
           ];
           
           push @$M,
              ['travels', '', {s=>join("  ",@{on.t||[]}), wsp=>1}],
              ['fou', '', {fo=>[$u, 0.2]}],
                  if $u ne on.i;
                  
           Rw mo/pwth $J:J2 $M 0.1-0.3;
       });
       
     up: | #c upper level gplumb
       Rw inness;
       # move impression of ^ to v, then round
       J.lum = Rw tent lum;
       # TODO replace last
       
       # sucks each u
       # but also the
       
       Rw sur/heading + $J3:J.lum;
       
       my @ju = Rw tvo $J:J.on;
       
       my $u = J.on.bb->{"u\t".0.1};
       Rw sur/oning + $u $J3:J.lum;
       # ^ singulsr, really a gel cap we may have many of
       # ventricles of its stature too
       # eg the many %travels colates..
       # give best view to the freshest activated sense
       
       # join gel cap knowledge halfway
       my $y = w $R down; # 2ish aggd knowledge, instructions?
       
       my @things = Rw tvy $J:J.on;
       while (@things) {
           my $thing = shift @things;
           my ($j, @sjs) = @$thing;
       
           say "U: ".$J->pi."   ".gp(j.s);
           say "   * _.r          => ".gp(_.s) for @sjs;
           sayre " _____________________ " for 1..5;
       }
       
       my $spcv = 0.2; # so has gap in 1 unless id, etc
       
       
       my @r;
       if (!ref $u) {
           push @r, { r=>"text", s=>$u, cv=>0.4 };
       }
       elsif (ref $u eq 'ARRAY') {
           my $i = 0;
           my $warp = @$u; # TODO or less?
           my @warp = Rw cv/oe off1 $v:warp;
           for my $ui (@$u) {
               my $cv = "0.". shift @warp;
               push @r, { r=>$i, path=>"[".$i++, s=>$ui, cv=>$cv};
           }
       }
       else {
           my $r = {map{$_=>1} keys %$u};
           
           $spcv = 0.3 if u.id;

           # bunch of keys... ^ interpret, compress knowledge
           # TODO ^make itv like two indexes, polars
           # any sorta layout knowhow...
       
           my @or = grep { delete $r->{$_} } @{y.order};
           if (ref $u eq 'A') {
               push @or, sort grep { /^u_/ && delete $r->{$_} } keys %$r;
           }
           push @or, sort keys %$r;
           
           for (@or) {
               my $v = y.ordy->{$_};
               # this is totally 5 in inness doing this 
               my $cv = "0.$v" if $v;
               $cv ||= $spcv;
               push @r, { r=>$_, path=>"{$_", s=>$u->{$_}, cv=>$cv };
           }
       }
       
       for my $r (@r) { # %{ r, path, v, cv #c
           
           J.lum.lev->("r.r/\t".r.cv => sub {
               my $J2 = shift;
               
               my $si = length(r.r);
               my $fs = $si > 40 ? 60 : $si > 30 ? 70 : $si > 20 ? 80 : 100;
               
               my $guec = $2 if r.cv =~ /^(0\.)?(\d)/;
               my $col = G.jumb.cos->{$guec} || warn "was r.cv so $guec";
               
               # TODO curve ^ # make sf of a Q factor that can see $v somehow
               J2.bz->(
                    "lable 0.1" => r.r,
                    #'%sf#la' => "ab;pr.5;fs$fs;c0", C that < v
                    "%css#laob" => 'position:absolute;right:0.5em;white-space:pre;',
                    "%css#lableg" => "font-size:$fs%",
                    "%css#labcoat" => "color:$col", # TODO unwind cv into colour
                    "%tt#\cv" => r.cv,
               );
               if (r.r eq 'id') {
                   my $axio = ref $u;
                   J2.bz->(
                        "axio 0.1" => $axio,
                        "%css#laob" => 'position:absolute;right:3em;font-size:300%',
                   );  
                   if (r.r eq 'K') {
                       my $axio = u.K;
                       J2.bz->(
                            "axe 0.1" => $axio,
                            "%css#laob" => 'position:absolute;right:2.5em;font-size:300%;color:#f93',
                       );  
                   }
               }
               
               # GP ness ^ v leaky
               my $bcv = 0.4;
               $bcv = 0.1 if r.cv < 0.2;
                  
               J2.fro->("gp\t"."0.6" => r.s,
                 {cv=>$bcv, makaz=>{ # hooky
                    "/%css#jit 0.9" => 'position:absolute;left:1em;max-width:14em;overflow:hidden;white-space:nowrap',
                 }}, # ^ v in out sameish
               );
           },
                 (r.path ? ('%path' => r.path) : ()),
           );
            #J.bz->("$r\t"."0.$cv" => ''.$v, '%css'=>'white-space:pre');
             # has l cursor stashed as a 1shj
             # TODO 5er grab l cursor and style
             # ad what kind of cursor, fro delays/syncs
             # start culture
             # the middle
             # start cuddle
       }
       
       Rw round $J2:J.lum $J;
       
       my @oooo = Rw tvo $J;
       for my $j (@oooo) {
           #say j.r;
       }
       
     entropia: | #c kind of same as running intents on u/ etc from inness
       wdump(2,J.onei);
     folw: | #c expand path, may spew arm
       my $J3 = Rw sur/spawnge $J;

       if ($J ne $J3) { # copy HEAD before pat(c)h
           Rw inness $J:J3 $r:J.onei;
       }
       Rw inness $J:J3 $r;
     spawnge: | #c spew arm when getting full
       # intermediates inness unfoldment to cellular structure
       # like if e.S we want shift in it, sprouting
       $J; # or return the arm instead

