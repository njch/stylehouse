
R_Jz:
 - K: ollox #c CURVE curver
   n_D:
     yJup: |
       J.yy.round.id = 3;
       qw'ollox sur fiz_ave oci'
     curves: |
         #["spun 0" => 0.025],
         ["curve 1" => -0.211],
         #["zoom 0" => 0.8],
         ["zoom 0.21" => 0.6],
         ["y 0" => 0],
         ["x 0" => 0], 
         ["x 0.1" => 0.06],
         ["curve 0.3" => -0.111],
         #["zoom 0.5" => -0.03],
         
     mods:
        - 
          - sq
          - 10
          - s: ~
            fs: 7_3
          - co: 8ff
            blr: 3
       
 - K: nnn #c twining
   D: |
       # the class etc bits of $e might clue in what to do
       # maybe can mousedown just x y?
       # J is the 1circle, J2 the 2circle (bw)
       # path must be somewhere around here...
       # on the gp's / which is inside yet outsideness, or the lev... whatev. turnstyle
       # rotate around same
       # there's a bunch of paths, there interesting
 - K: down #c TODO to have maintained down by what comes up from 7 via 8 in motion, tune in values
   D: |
       my $ordy = Load(<<'');
       {A: 13, id: 11, K: 17, name: 185,
       G: 14, R: 15, B: 23, more: 543,
       surf: 8,
       theJ: 23, theM: 28
       }
       
       my $ydro = {};
       push @{$ydro->{$_}||=[]}, $_ for keys %$ordy;
       my @order = map { @{$ydro->{$_}} } sort keys %$ydro;
       
       { order => \@order,
            ordy => $ordy,
       }

 - K: sur #c SURish rondo: on -> square ->
   n_D:
     to: | #c into, goes with inness and communes Js
       my $to = shift @$m;
       my $r;
       for ($to) {
           r.t = [] when '/';
           r.i = $G when 'G';
           die         when 'feed'; # look at cont moves?
           r.i = Rw Jung
                       when 'Jung';
                       # TODO ash
           r.i = Rw onJ o2x theself
                       when 'self';
           
           default {
               die "no yyyyyyyyyyyy to $to   on ".$J->pi;
           }
       }
       Rw inness $J $r;
     conty: | #css # eats event + HASH preparation $pa
       my $r = {}; # sproutya
       # ^ outer $y compressions understood 
        #  by 2ale of inness J.onei, compiled...
       # will lovely to maintain in spiral
       saybl "pat: $y   mmmm @$m";
       #/  ^ m
          # language inthemiddle
       #\  v m
       if (e.type eq 'click') {
           for ($y) {
               when (/^(\{|\[)/) {
                   r.t = $y;
                   Rw sur/folw $r $J;
               }
               default {
                   die "dunno $y"
               }
           }
       }
       elsif (e.type eq 'keydown') {
               say "is key e.k";
               for (e.k) {
                   when ('0') {
                       my $t = J.onei.t;
                       my @t = @{$t||die};
                       pop @t;
                       my $r = {t=>\@t};
                       Rw inness $J $r;
                   }
               }
       }
       else {
             say "Sur". wdump($e);
       }

     oning: | #c
       J3.lev->("onei\t0.06" => sub {
           my $J2 = shift;
           my $on = J.onei;
           my $M = [
               ['=','', {}, {fs=>12,co=>'000'}],
               ['i', 'sur/to:/', {fo=>[on.i,0.1]}]
           ];
           
           push @$M,
              ['travels', '', {s=>join("  ",@{on.t||[]}), wsp=>1}],
              ['fou', '', {fo=>[$u, 0.2]}],
                  if $u ne on.i;
                  
           Rw mo/pwth $J:J2 $M 0.1-0.3;
       });
     gelcaps: | #c egroup
       my $ordy = {qw'
         id 11  A 13  K 17  name 18
         G  14  R 15

         B  21  style 22
         theJ 23  theM 28
       '};
       
     up: | #c upper level gplumb
       Rw inness;

       # shadow just right so round
       # sucks each u
       # bzphaz
       # but also the
       
       
       
       my @things = Rw tvy $J:J.on;
       my $tot = 32;
       my $in = 0.1;
       my $out = 0.9;
       
       
       my $phi = $out - $in; # <-0.8->
       my $tin = $in;
       my $thi = $phi / @things; # or indi
       my @re;
       for (@things) {
           my ($j, @sjs) = @$_;
           say "U: ".$J->pi."   ".gp(j.s); 
           say "   * _.r          => ".gp(_.s) for @sjs;
           my $outt = $tin + $thi; # r indi, of sjs
           my $rr = {
               in => $tin,
               out => $outt,
               thi => $tot/$phi, # space volve, indi...
               sjs => \@sjs,
               j => $j,
           };
           say "rr.j.r    = rr.in    -> rr.out";
           push @re, $rr;
           $tin = $outt;
       }
       # each branching yet here...
       # it's a collection of (pi|wt)/(cap|bod|arch|etc)
       
       my $he = $in - 0.05;
       # header fin at in - cell wall division, things squished up to
       
       Rw ii/Jhead + $out:he;
       
       Rw ii/ornate + $in:he;
       
       # here looking at cones of junk
       # collections of junk
       for my $rr (@re) {
           my $M = [
               Rw ii/cap $rr,
               Rw ii/bod $rr,
           ];
           my $in = rr.in;
           my $out = rr.out;
           Rw mo/pwth $J $M $in $out;
       }
       sayre "==\n== delt ".F_delta."\n==";
     pi: | #c THE WHOLE GHUTS
       my ($c,$sc);
       
       c.fo = [r.s, 0.6];
       
       sc.ws = 'n';
       sc.ab = 'left:1em';
       sc.mw = '14em';
       sc.over = 'hidden';
       
       return ['pi', r.path, $c, $sc];
     labegy: | #c
        # TODO add a style that colours it after round
        # TODO curve
        # TODO shared labels
        # TODO culture
        # TODO unwind cv into colours variously
        # TODO make a tiny maka thing for $k decor, tiny styled tags
        my ($c,$sc);
        
        c.s = r.r;
        
        sc.ws = 'p';
        sc.ab = 'right:0.5em';
        
        my $si = length(r.r);
        my $curve = {qw{
        40 60
        30 70
        20 80
        }};
        for (sort keys %$curve) {
            sc.fs = $curve->{$_} if $si > $_
        }
        return ['lab', '', $c, $sc];
     entropia: | #c kind of same as running intents on u/ etc from inness
       wdump(2,J.onei);
     folw: | #c expand path, may spew arm
       my $J3 = Rw sur/spawnge $J;

       if ($J ne $J3) { # copy HEAD before pat(c)h
           Rw inness $J:J3 $r:J.onei;
       }
       Rw inness $J:J3 $r;
     spawnge: | #c spew arm when getting full
       # intermediates inness unfoldment to cellular structure
       # like if e.S we want shift in it, sprouting
       $J; # or return the arm instead

