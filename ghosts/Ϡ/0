name: Ï 
etc: intoraction... magnetic fishing rod, guy playing guitar cave art


C:
  - K: GG
  - K: nothing
hooks:
  Arr: |
    my ($what) = keys %$ar;
    my $u = 0->TafuB($what => $ar);
    G.GG.Be->w(ion => {u=>$u});
  fresh_init: |
    G.Es = [];
    # w scribe_js; # TODO add to wtf scenario
    
      # H w/conz reconzoiters existing conz with H w z/conz
      # looks up stuff
      w transam;
    
    $G->timer(1,sub{ w push_conin if !H.singul });
  recoded_init: |
    w retile;
    w reperc;

  transam: |
    G.am = $G->findway("H.style/S/H.name")
        || die "what am? H.style/H.name";

    waylay percs;
  percs: |
    my $P = ar.P || G.am;
    my $GG = ar.GG || $G; # starting from magnetic fishing rod
    saygr "to perc ".$GG->pi."   ".wdump($P);
    @$P = sort { !defined _.GAK } @$P;
    for my $p (@$P) {
        if (defined p.GAK) {
            my ($k, @w) = split ' ', p.GAK;
            my $w = join ' ', @w;
            $w ||= $k;
            
            if (!GG.GG->{$k}) {
                $GG->GAK($k, GG.A->spawn(G=>$w));
                sayyl "Put ".GG.GG->{$k}->pi." down";
            }
            
            my $GG = GG.GG->{$k} || die;
            my $P = [];
            push @$P, $_ for @{ p.P || [] };
            push @$P, $_ for @{ $GG->anyway('P') || [] };
            
            if (my $d = p.InC) {
                $GG->InjC($GG => {C => $d});
            }
            
            w percs[$GG, $P];
            sayyl "back from ".$GG->pi;
        }
        else {
            if (keys %$p == 1 && (keys %$p)[0] =~ /^(\w+) (.+)$/) {
                my $c = $GG->CsK({K=>$1});
                die "no BcS for $1" unless c.BcS;
                my @parc = ($2, values %$p);
                $p = {};
                p.K = $1;
                p.B->{$_} = shift @parc for split ' ', c.BcS;
            }
            if (p.K) { # perc u
                my $u = $GG->sway({K=>p.K}, $p);
                saybl "Making ".$u->pi;
                $u = $GG->Tafu($u);
            }
            else {die " wtf=>".ki($p)};
        }
    }
    $GG w percolate unless $GG eq $G;
  reperc: |
    # coded way diff/inject/retravel above percolations
  ux: |
    my @GGs = ar.GG || grep { _.K !~ /L|ux/ } @{G.GGs};
    Say "ux! ".gpty(@GGs);
    for my $GG (@GGs) { 
        sayre "RWRWRWRW GG.K\t GG.name";
        
        my $U = GG.GG.U;
        delete H.G.A.W->{U.uW.at.id};
        for my $E (@{G.Es}) {
            H.G w z/conz[$E];
        }
        
        0->RW($U);
        
        0->RW($GG);
        
        w percs[$GG];
    }
    w wux;
    saybl "ux ".$G->F_delta();
  pull_conin: | # head receives the headless
    saygr "H.style/H.name        pulls conin     $m";
    my ($style, $name, $id, $conin) = split ' ', $m;
    die "mal cone push: '$m'" if !$conin;
    H.G w z/coninto[$conin];
    
  push_conin: | # the headless seeks heads
    saygr "H.style/H.name        pushes conin";
    H.r->publish("S", "push_conin H.style H.name H.id H.listen_ws");
  elvis_enters: |
    saygr "jump on the j train ".$E->pi;
    0->accum($G, 'Es', $E);
    
    if (H.singul) {
        H.r->publish("S", "please_push_conin");
    }
    
    my @GGs = ar.GG || @{G.GGs};
    for my $g (@GGs) {
        $g w elvibe;
    }
    
    for my $j (@{G.Js}) {
        w sEnj[$E, $j];
    }
  elvis_leaves: |
    0->deaccum($G => Es => $E);
  aj: |
    if (j._) {
        saygr "j.G.name unified field! see for ".@{j.s};
        H.G.A.W->{j._.at.id} = j.G.W;
    }
    
    0->accum($G, Js => $j);
    
    my @Es = w Es;
    for my $E (@Es) {
        w sEnj[$E, $j];
    }
    sayg "j to the ".@Es;
  Es: |
    uniq @{G.Es};
  sEnj: |
    my @lot = reverse @{j.s};
    push @lot, reverse @{j.c};
    saygr (0+@lot)." ->->->-> ".$E->pi;
    
    for my $l (@lot) {
        ref $l && die "reff $l";
        $l = " $l" if H.h;
        $E->send(" ".$l);
    }
    
    if (j._) {
        saygr "j.G.name unified field hits tiles!";
        0->sing(retile => sub { w retile[$E]; }, begin => 0.8);
    }
    # after U - direct to tape instead of catching JS in H
    
  scribe_js: |
    my $new = G.js || [];
    return unless @$new;
    G.js = [];
    
    my $now = $H->hitime();
    G.jslast ||= $now;
    my $d = sprintf("%.3f",$now - G.jslast);
    G.jslast = $now;
    
    my $script = join"","[$d,function(){", @$new, "}],\n";
    write_file("o/o", {append=>1}, H::encode_utf8($script));
  retile: | # TODO client side js data inter
    my $js = 
    " var e = []; \$('#ux > ww[class*=".'"z"'
    ."]').each(function(){"
        ."e\.push(\$(this).attr('id'));" # could take more clues
    ."});"
    ."return e\.join(' + ');";
    my @Es = w Es;
    @Es = ar.E if ar.E;
    for my $E (@Es) {
        my $cb = sub { my $m = shift; w divide[$m]; };
        H.G w jaw[$js, $cb];
    }
  divide: |
    my @m = sort split / \+ /, $m;
    
    my $div = Load(<<''); # hmm
        - width:left 1
        - height:top 2
    
    my $grid = {};
    for my $p (@$div) {
        my ($iv, $parts) = split ' ', $p;
        my ($mags, $ax) = split ':', $iv;
        # magnitudes of width
        # axed from unified by left, etc.
        my $in = sprintf("%.3f", 1 / $parts);
        
        my @ground = map { [$_ => $grid->{$_} ] } sort keys %$grid;
        @ground = [] if !@ground;
        my $pole = [];
        $grid = {};
        
        my $here = 0; # in accum
        for my $i (1..$parts) {
            my $ox = {};
            ox.part = $i;
            $ox->{$ax} = $here;
            $here += $in;
            $ox->{$mags} = $in;
            push @$pole, $ox;
        }
        
        for my $g (@ground) {
            my ($k, $v) = @$g;
            $v ||= {};
            for my $ox (@$pole) {
                my $K = (defined $k?"$k ":"") . ox.part;
                my $x = $grid->{$K} = {%$v, %$ox};
                delete x.part;
            }
        }
    }
    
    my @holes = sort keys %$grid;
    say "Got ".@m." pegs for ".@holes." holes";
    for my $n (@m) {
        my $h = shift @holes;
        my $o = $grid->{$h};
        my $cssset = ".animate({".join(",", map {
            "'$_':'".($o->{$_} * 100)."%'"
            } sort keys %$o)."}, 0)";
        my $E = H.who;
        $E->send(" \$('#$n')$cssset".";");
        $G->timer(0.4, sub { $E->send(" \$('#$n').removeClass('NZ');"); });
    }
  
  wux: |
    for my $GG (@{G.GGs}) { # could ar into GG=$K orso
        $GG->w('uxd');
    }
    

