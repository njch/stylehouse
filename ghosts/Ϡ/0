name: Ï 
etc: intoraction... magnetic fishing rod, guy playing guitar cave art


C:
  - K: GG
  - K: nothing
hooks:
  Arr: |
    my ($what) = keys %$ar;
    my $u = 0->TafuB($what => $ar);
    G.GG.Be->w(ion => {u=>$u});
  fresh_init: |
    w scribe_js;
    
    $G->w("busk/H.style");
  recoded_init: |
    w reperc;
  any_init: |
    $H->send("whatever"); 
  z:
    uxsky: |
      $H->JS("\$('#sky').css('overflow', 'hidden');");
      my $style = join ";", qw{  
          position:absolute color:#3bc
          width:100% height:100% font-size:10pt pointer-events:none
      };
      $H->JS(qq{\$('#sky').append('<div id="ux" style="$style"></div>');});
      
  busk:
    styleshed: |
      Say "SttyleSHEDing        H.name";
      
      w z/uxsky;
      
      0->GAK(L =>     G!L/0); # lyrico
      
      0->GAK(0 =>     G!0); # compiler
      
      0->GAK(ool => G!C/ool); # pretty
      
      #0->GAK(Eh => G!E/h); # brick wall
      
      0->su(sw => sub { G:L/0 ->w(sw => $_[0]); });
      0->su(elvac => sub { w elvac(%{$_[0]}); });
      
      waylay percolations;
      
    stylehut: |
      # H w/conz reconzoiters existing conz with H w z/conz
      # looks up stuff
      my $s = $G->findway("am/H.style/H.name");
      w stylo[$s];
      w envac; # chase down elvis
      waylay perco[$s];
  stylo: |
    wish(C=>$s) || die "what $s?";
    for my $g (@{ s.GG||[] }) {
        
        0->GAK(g.K => G!g.way);
    
    }
  perco: |
    for my $g (@{ s.GG||[] }) {
    
    }
  am: #c
    stylehut:
      S: #c stylehut
        GG:
          - K: background
            way: C/ool
      O: #c stylehut
        GG:
          - K: ood
            way: C/odon
            perc:
            - K: IF
              B:
                href: http://s:2001
              S:
                Z:
                  height: 20%
                  width: 40%
                  left: 10%
                  bottom: 20%
                  position: absolute
  elvac: |
    saygr "H.style`elvac $top $m";
    my ($style, $name, $id, $ws) = split ' ', $m;
    say " $m means conin $ws";
    $H->send(" a\.con({conin: '$ws'});");
    
  envac: |
    H.r->publish("elvac", "H.style H.name H.id H.listen_ws");
  elvis_enters: |
    saygr "jump on the j train ".$E->pi;
    for my $j (@{G.J}) {
        w sEnj[$E, $j];
    }
  aj: |
    if (j._) {
        saygr "j.G.name unified field! see for ".@{j.s};
        H.G.A.W->{j._.at.id} = j.G.W
    }
    
    0->accum($G, J => $j);
    
    my @Es = H.G->w("Elvi");
    for my $E (@Es) {
        w sEnj[$E, $j];
    }
    sayg "j to the ".@Es;
  sEnj: |
    for my $l (reverse @{j.s}, reverse @{j.c}) {
        ref $l && die "reff $l";
        $l = " $l" if H.h;
        $E->send(" ".$l);
    }
    # after U - direct to tape instead of catching JS in H
    
  scribe_js: |
    $G->timer(0.3, sub { w scribe_js; });
    
    my $new = G.js || [];
    return unless @$new;
    G.js = [];
    
    my $now = $H->hitime();
    G.jslast ||= $now;
    my $d = sprintf("%.3f",$now - G.jslast);
    G.jslast = $now;
    
    my $script = join"","[$d,function(){", @$new, "}],\n";
    write_file("o/o", {append=>1}, Hostinfo::encode_utf8($script));
    
  ux: |
    for my $GG (@{G.GGs}) { # could ar into GG=$K orso
        next if GG.K =~ /L|ux/;
        
        sayre "RWRWRWRW GG.name";
        for my $ux ($GG->Gf("T/ux")) {
            0->RW($ux);
        }
        0->RW($GG);
        $GG->w('percolate');
    }
    w wux;
    saybl "ux ".$G->F_delta();
  percolations: |
    for my $GG (@{G.GGs}) { # could ar into GG=$K orso
        saygr "to perc GG.name";
        $GG->w('percolate');
        
    }
  wux: |
    for my $GG (@{G.GGs}) { # could ar into GG=$K orso
        $GG->w('uxd');
    }
    

