name: Ϡ
etc: intoraction... magnetic fishing rod, guy playing guitar cave art
GG:
 - K: ux
   way: T/ux
   In:
     C:
       W:
         Ss: [X]
nonGG:
 - K: ood
   way: C/odon
# - K: Eh
#   way: E/h
C:
  - K: GG
  - K: nothing
hooks:
  V:
    ux:
      styles: cardboard ux
  styles:
    cardboard: |
      qw'position:absolute color:#3bc', 'border:2px solid #003'
      
    ux: |
      qw'width:100% height:100% font-size:10pt pointer-events:none'
  Arr: |
    my ($what) = keys %$ar;
    my $u = 0->TafuB($what => $ar);
    G.GG.Be->w(ion => {u=>$u});
  keys:
    n: |
      G:Ϡ ->_0('V/blur');
    N: |
      Say "TOGIN";
      G:Ϡ ->_0('V/toginvis');
  fresh_init: |
    $H->JS("\$('#ground').remove();");
    $H->JS("\$('#sky').css('overflow', 'hidden');");
    w scribe_js;
    
    G.GI = sub {
        my ($K, $gg) = @_;
        my $g = G!$gg;
        g.K = $K;
        G.GG->{g.K} = $g;
    };
    Say "Busking H.style";
    $G->w("busk/H.style");
    
    waylay percolations;
  busk:
    styleshed: |
      G.GI->(ool => 'C/ool');
      G.GI->(L => 'L/0');
      G.GI->(0 => '0');
  aj: |
    Say "Gota a j! for j.G.name ".ki($j);
    Say "was ".scalar(@{j.s})." long";
    $_->() for reverse @{j.s};
    
  scribe_js: |
    $G->timer(0.3, sub { w scribe_js; });
    
    my $new = G.js || [];
    return unless @$new;
    G.js = [];
    
    my $now = $H->hitime();
    G.jslast ||= $now;
    my $d = sprintf("%.3f",$now - G.jslast);
    G.jslast = $now;
    
    my $script = join"","[$d,function(){", @$new, "}],\n";
    write_file("o/o", {append=>1}, Hostinfo::encode_utf8($script));
    
  uW: |
    Say "from u.G.name is u.K for ".ki(u.B);
    u.K eq 'W' || die "NOW";
    
    if (u.G eq G.GG.ux) {
        sayyl "Ϡ takeover";
        G.V.ux->takeover(u.html);
    }
    else {
        sayyl "Ϡ <into< G.GG.ux.name"; # slip somewhere
        G.GG.ux->w(ux => {Ls => [u.Li]});
    }
  ux: |
    for my $GG (@{G.GGs}) { # could ar into GG=$K orso
        next if GG.K =~ /L|ux|ool/;
        
        sayre "RWRWRWRW GG.name";
        for my $ux ($GG->Gf("T/ux")) {
            0->RW($ux);
        }
        0->RW($GG);
        $GG->w('percolate');
    }
    w wux;
    saybl "ux ".$G->F_delta();
  percolations: |
    for my $GG (@{G.GGs}) { # could ar into GG=$K orso
        Say "to perc GG.name";
        $GG->w('percolate');
    }
  wux: |
    for my $GG (@{G.GGs}) { # could ar into GG=$K orso
        $GG->w('uxd');
    }
    

