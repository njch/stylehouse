name: Ï 
etc: intoraction... magnetic fishing rod, guy playing guitar cave art


C:
  - K: GG
  - K: nothing
hooks:
  Arr: |
    my ($what) = keys %$ar;
    my $u = 0->TafuB($what => $ar);
    G.GG.Be->w(ion => {u=>$u});
  fresh_init: |
    G.Es = [];
    w scribe_js;
    
    $G->w("busk/H.style");
    
    $G->timer(1,sub{ w push_conin if !H.singul });
  recoded_init: |
    w reperc;
  z:
    uxsky: |
      $H->JS("\$('#sky').css('overflow', 'hidden');");
      my $style = join ";", qw{  
          position:absolute color:#3bc
          width:100% height:100% font-size:10pt pointer-events:none
      };
      $H->JS(qq{\$('#sky').append('<div id="ux" style="$style"></div>');});
    coninto: |
      Say "CONING IN $conin";
      $H->send(" a\.con({conin: '$conin'});");
  busk:
    styleshed: |
      Say "SttyleSHEDing        H.name";
      
      w z/uxsky; # make a thing (huts have #ux in page);
      
      w transam;
      
      0->su(sw => sub { G.GG.L->w(sw => $_[0]); }); # suck splats
    stylehut: |
      # H w/conz reconzoiters existing conz with H w z/conz
      # looks up stuff
      w transam;
  transam: |
    G.am = $G->findway("am/H.style/H.name")
        || die "what am? H.style/H.name";
    w stylo;
    waylay percs;
  stylo: |
    while (my ($k, $v) = each %{G.am}) {
        next if $k =~ /s$/;
        saygr "to make $k";
        $v = {way => $v} if !ref $v;
        my $w = v.way || $k;
        my $ug = 0->GAK($k => G!$w);
        die "ug nok ug.name" if !defined ug.K;
    }
  percs: |
    my @GGs = ar.GG || @{G.GGs};
    for my $g (@GGs) {
        my $K = g.K;
        defined $K || die "no K? g.name".sw($G);
        my $BS = G.am->{"${K}s"} || do {
            sayre "no percos a g.K\s in G.name G.am";
            [];
        };
        saygr "to perc ".gpty($g)."   ".gpty($BS);
        
        $g w percolate[$BS];
    }
  reperc: |
    # coded way diff/inject/retravel above percolations
  ux: |
    my @GGs = ar.GG || grep { _.K !~ /L|ux/ } @{G.GGs};
    Say "ux! ".gpty(@GGs);
    for my $GG (@GGs) { 
        sayre "RWRWRWRW GG.K\t GG.name";
        
        my $U = GG.GG.U;
        delete H.G.A.W->{U.uW.at.id};
        for my $E (@{G.Es}) {
            H.G w z/conz[$E];
        }
        
        0->RW($U);
        
        0->RW($GG);
        
        w percs[$GG];
    }
    w wux;
    saybl "ux ".$G->F_delta();
  am:
    styleshed:
      SHED:
        L: {}
        0: {}

    stylehut:
      S:
        bacg: C/ool
        bacgs: 
          - K: Ims
            flo: 2
            B:
              dir: /s/public/i
          - GG: U
            InC:
                 W:
                   Z:
                     z-index: -1
                     background: url(i/greencush.jpg)
          
      J:
        bacg: E/h
        
      Z:
        bacg: C/ool
        bacgs: 
          - K: Ims
            B:
              dir: /s/public/i/fug
          - GG: U
            InC:
                 W:
                   Z:
                     z-index: 5
                     background: blue
                     left: 50%
                     height: 200%
                     transform: rotate(7deg);
      O:
        ood: C
        0: {}
      ZZZ:
        bacg: C/ool
        bacgs: 
          - K: Ims
            B:
              dir: /s/public/i/fug
          - GG: U
            InC:
                 W:
                   Z:
                     z-index: 5
                     background: \#8bf
                     left: 65%
                     height: 20%
                     width: 10%
                     top: 40%
                     transform: rotate(7deg);

  pull_conin: | # head receives the headless
    saygr "H.style/H.name        pulls conin     $m";
    my ($style, $name, $id, $conin) = split ' ', $m;
    die "mal cone push: '$m'" if !$conin;
    w z/coninto[$conin];
    
  push_conin: | # the headless seeks heads
    saygr "H.style/H.name        pushes conin";
    H.r->publish("S", "push_conin H.style H.name H.id H.listen_ws");
  elvis_enters: |
    saygr "jump on the j train ".$E->pi;
    if (H.singul) {
        H.r->publish("S", "please_push_conin");
    }
    push @{G.Es}, $E;
    for my $j (@{G.Js}) {
        w sEnj[$E, $j];
    }
  aj: |
    if (j._) {
        saygr "j.G.name unified field! see for ".@{j.s};
        H.G.A.W->{j._.at.id} = j.G.W
    }
    
    0->accum($G, Js => $j);
    
    my @Es = @{G.Es};
    for my $E (@Es) {
        w sEnj[$E, $j];
    }
    sayg "j to the ".@Es;
  sEnj: |
    my @lot = reverse @{j.s};
    push @lot, reverse @{j.c};
    saygr (0+@lot)." ->->->-> ".$E->pi;
    
    for my $l (@lot) {
        ref $l && die "reff $l";
        $l = " $l" if H.h;
        $E->send(" ".$l);
    }
    # after U - direct to tape instead of catching JS in H
    
  scribe_js: |
    $G->timer(0.3, sub { w scribe_js; });
    
    my $new = G.js || [];
    return unless @$new;
    G.js = [];
    
    my $now = $H->hitime();
    G.jslast ||= $now;
    my $d = sprintf("%.3f",$now - G.jslast);
    G.jslast = $now;
    
    my $script = join"","[$d,function(){", @$new, "}],\n";
    write_file("o/o", {append=>1}, Hostinfo::encode_utf8($script));
    
  wux: |
    for my $GG (@{G.GGs}) { # could ar into GG=$K orso
        $GG->w('uxd');
    }
    

