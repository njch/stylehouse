name: wormhole splatter

C:
  - K: splatting
    flows_D: |
      G.V->{$name} = S.view = H.sky->spawn_floozy($G, $name, $G->styles("spl $name"));
hooks:
  styles:
    spl: |
      qw{ position:absolute overflow:hidden pointer-events:none }
    path: |
      qw{ top:0px left:10em width:11em z-index:20 },
      q { border:1px solid green },
    func: |
      qw{ bottom:0px left:-5em width:11em z-index:30 },
      q { border:1px solid green },
      q { -webkit-filter: brightness(0.6) contrast(1) drop-shadow(17px 17px 20px black) grayscale(0.1) hue-rotate(150deg) invert(0.3) saturate(5.8) },
      
    somewhere: |
      qw{ bottom:5px left:10em width:80% },
      q { -webkit-filter: brightness(1.2) saturate(3) drop-shadow(10px 0px 30px black) },
      
    swamp: |
      qw{ top:70% left:10em }
      
    land: |
      qw { bottom:0px right:0px width:9em z-index:20 },
      q{ border:1px solid green },
      
    splatW: |
      qw { background:#5a8 bottom:0px right:30% width:28em z-index:20 },
      q { border:1px solid green },
      
    worm: |
      qw{ bottom:0em left:10em min-width:17em max-width:60% z-index:20 pointer-events:initial },
      q { border:1em solid rgba(120, 120, 255, 0.5); background: rgba(22,22,22,0.4); max-height: 40%; overflow: scroll }
  load_ways_post: |
    #grab A/WS,L,t,
    # nest, styles tied to atom thing
    # everything will have its own texty things going on
    # the gname
    # junction
    # so it's just over yonder in the chain
  recoded_init: |
    $O->w('f/⥁');
  go: |
    $G->timer(0.1, sub {
    exists $ar->{append}
      ? $G->w('open_line', $ar)
      : $O->w('somewhere', $ar)
    }, "splatgo");
  
  open_line: |
    my $CG = $O->Gf("crawl") || die "no O G crawl";
    
    my $NS = $CG->w('revisit', { line => $line, push_depth => 1 });
    $NS || die "NO!";
    
    my $wormhole = { script => $NS };
    
    my $A = 0->TafuB(splatting => {name => $splatname});
    unless ($A) {
        #die "no such splatname: $splatname";
        my $wayout = $G->stackway("No mo $splatname!?", $G->W->CS );
        w go(thing => $wayout);
        return;
    }
    w script_out[$A, $wormhole, $splatname, $append];
  Splat: |
    my ($splatname, $wormhole) = %$ar;
    $wormhole = w aWstract[$wormhole];
    
    my $A = w Arr[$splatname, $wormhole];
    my $A = 0->TafuB(splatting => {name => $splatname});
    A.B.W = $wormhole;
    
    w script_out[$A, $splatname, $wormhole];
    $H->{G}->w('sky/doof') if $splatname =~ /some|no/;
    
    $H->Say("Splat '$splatname' ".$wormhole->pi."  ".show_delta(), $A)
                               unless $splatname =~ /^worm$|Ϡ|land|func|path/;
  get: |
    my $S = w Afu[$splatname];
    $S || return $H->error("NO findo $splatname", $G->W);
    $S
  aWstract: |
    return { script => [@$wormhole] } if ref $wormhole eq "ARRAY";
    $wormhole ne $G->W
        ? $wormhole
        : { script => [@{$wormhole->{script}}] }
  script_out: |
    my $lines = [];
    my $i = 0;
    my @script = @{$wormhole->{script}};
    @script = reverse @script if $splatname eq "path";
    if (@script > 160) {
        push @$lines, "!style='font-size:50pt;color:white;' ".(@script-100)." more above ...";
        @script = @script[-160..-1];
        die unless @script == 160;
    }
    for my $line (@script) {
        next if $i == 0 && !defined $line;
        my ($R, $B) = ([], {});
        push @$lines, w make_line[$splatname, $i, $R, $B, $line];
    }
    my $th = {
        nospace => 1,
        class => 'menu',
        tuxtstyle => 'width: 100%; pointer-events:none;',
    };
    $th->{append} = $ar->{append} if $ar->{append};
    die "no A" if !$A;
    
    my $t = $A->{view}->newtext($lines, $th);
    $A->{view}->rmcl('invis');
    
    
    return $t;
  
  make_line: |
    ref $line eq "HASH"
    || return $H->error("$G->{name} making notline: $splatname i=$i ".wdump($line));
    
    w line/value; # R <-> B to be tractored

    return { _spawn => [ $R, {
        B => $B,
        nospace => 1,
        tuxtstyle => 'pointer-events:initial; height:120%;position: relative; float: left;',
        tuxts_to_htmls => sub {
            my $texty = shift;
            my $tx = $texty->{tuxts};
            
            w tuxtsB(B => $B, tx => $tx);
            w line/style;
        },
    }]}
  tuxtsB: |
      for (@$tx) {
          next unless $_->{bb};
          $B->{$_->{bb}}->{s} = $_;
      }
  line:
    value: |
      my @atom = qw[d i t o m]; # TODO combine d+i = a
      if ($splatname =~ /^(path|land|func|worm)$/) {
            $line = {%$line};
          line.t = delete line.i;   # do this as a t # alludes to allele layer
          @atom = qw[t];
      }
      for my $bb (@atom) {
          my $b = $B->{$bb} = {line => $line, bb => $bb};
          my $v = $G->w("line/$bb/v", {%$ar, b=>$b});
          $v = "!bb=$bb $v" unless ref $v;
          push @$R, $v;
      }
    style: |
        while (my ($bb, $b) = each %$B) {
            $G->w("line/$bb/s",{%$ar,
            b => $b, s => $b->{s}, line => $b->{line}});
        }
    event: |
        my $append = $s->{id};
        
        my $t = $line->{t};
        if ($splatname eq 'trev') {
            return sub {
                w go[$splatname, $line, $append];
            }
        }
        else {
            return sub {
                w go(thing => $t);
            }
        }
    m: #c
      v: |
        my $t = $line->{t};
        my $menu = [];
        
        my $ineach = line.i.each;
        my $inineach = line.i.Lo.i.each;
        return if $inineach && $inineach eq "stack";
        
        
        push @$menu, 'ᣋ' => sub {
            my $tar = {splatname => $splatname, line => $line, append =>  "$_[1]->{id}"};
            $G->timer(0.1, sub { $G->w(go => $tar) }, "pendline" );
        };
            
        push @$menu, 'Ϡ' => sub { w go( nothing => $t ) };
        push @$menu, 'Ώ' => sub { w go( wormhole => $t ) }
           if ref $t eq "W" || ref $t eq "Wormhole";
            # WTF DOESNT WORK if ref $t =~ /^(W|Wormhole)$/;

        push @$menu, 'Ώ' => sub { w go( wormhole => $t) }
        if $ineach && $ineach eq 'crawl_W_S';
            
        push @$menu, 'Ώ' => sub { w go( wormhole => t.W ) }
            if ref $t eq "G" || ref $t eq "Ghost";
        #push @$menu, '⊟' => sub { w lcodon[$line] } if ref $t =~ /^[CG]/;
        push @$menu, '⊟' => sub { my $res = [$t->()]; w go(thing => $res) }
            if ref $t eq "CODE";
        
        {
        contyt => { bb => $b->{bb} },
        _spawn => [ [], {
        nospace => 1,
        event => { menu => $menu },
        class => "menu insplatm",
        }]
        }
      s: |
        $s->{style} .= "font-size:35pt;";
    t: #c thing background=#fca
      v: |
        my $t = $line->{t};
        if ($t && ref $t eq "HASH") {
            # way in like: Hostinfo ->{ file_stream >@ this HASH
            #
            # means we want bring $t->{filename} to the surface and show here
            # organicness just around the corner.....
        }
        "$t"; # done over once style
      s: |
        my $t = $line->{t};
        die $s->{value} if ref $s->{value};
        my $inc = sub { $s->{html}=1;'<t style="color:'.shift.';">'.shift.'</t>' }; 
        my $emb = sub { 
            my $e = shift;
            $inc->(
                sprintf('rgba(%s,0.4);font-size:33pt;'
                    .'position:absolute;left:-1em;top:-7px;',
                    ($e =~ /^[A-Z]$/ ? '255,200,200' : '100, 80, 230'),
                ),
                encode_entities($e)
            );
        };
        my $contrail = sub {
            my $curve = shift;
            my $S = shift;
            $s->{html}=1;'<t style="color:'.shift.';">'.shift.'</t>'
        };
        my $leftsub = sub {
            $inc->("rgba(255,255,255,0.8);font-size:10pt;position:absolute;left:1em;bottom:3px;", shift)
        };
        my $color;
        my $name = "$t";
        my $fs;
        my $font;
        if (my $ref = ref $t) {
            if ($name =~ /HASH/) { #c t s
                $color = "f66";
                $name = "{";
                if ($ref eq "HASH") {
                    my $k = ki($t);
                    $name .= "$k";
                    if (exists $t->{t} && $t->{i} && $t->{o}) {
                        $name = "Line: $t->{name}\n"
                            .pint($t->{i})."\n".@{$t->{o}}." out"
                    }
                    $fs = 10;
                }
                else {
                    $fs = 22;
                    $name = $ref.$name;
                    if ($ref eq "View") {
                        $name .= "#".$t->{divid};
                    }
                }
                if (200 < length $name) {
                    $name = join ", ", keys %$t;
                }
                if ($t->{name}) {
                    $name .= " ".$t->{name};
                }
                $s->{style}.="border-left:40px groove #$1;"
                    if $t->{id} && $t->{id} =~ m/^\w+-\w{5}(\w{3})/;
            }
            if ($ref eq "ARRAY") { #c t s
                $color = "090";
                $name = 0+@$t.$inc->('black',"[");
                my @a = @$t;
                my @snip = splice @a, 36 if @a > 42;
                push @a, "..".scalar(@snip)." more" if @snip;
                $name .=
                    $inc->('#fca; font-size:10pt;line-height:8pt;',
                    
                        join $inc->('black',"["),     @a
                    )
                        
                        unless @{$line->{o}};
                        
                $name =~ s/^((?:.+?\n){4}).+$/$1/s;
                $s->{style}.="overflow:hidden";
            }
            if ($ref eq "Way" || $ref eq 'C') {  #c t s
                $name = $t->pint;
                $fs = 12 if $t->{K} =~ /^m/;
                $fs = 14 if length($name) > 20;
                $color = "fc0";
                unless (defined $name) {
                    $name = "{".join(" ", sort keys %$t);
                }
                $name = substr($name, 0, 400)."..." if length($name) > 420;
                if (my $wf = $t->{_wayfile}) {
                    my ($n) = $wf =~ /^ghosts\/(.+)$/;
                    $name = $inc->("#030" => $n)." ".$name;
                }
                $name =~ s/(rgba?\([\d, .]+\))/<t style="background:$1;">$1<\/t>/;
                $name = $emb->($ref eq 'C' ? 'ල' : 'ϖ').$name;
            }
            if ($ref eq "T") {  #c t s
                $name = "T for ".gpty(t.i);
                my $size = scalar @{t.B||[]};
                $name = $leftsub->($size).$emb->('ඈ').$name;
            }
            if ($ref =~ /^(Travel|G|W)/ && $ref ne "Way") { #c t s
                my $ty = $1;
                my ($nb, $nl);
                my $W;
                if ($ty eq "T") {
                    $name = "$t->{G}->{way}";
                    $color = "8c6";
                    $W = $t->{W};
                }
                if ($ty eq "W") {
                    $name = $t->{G}->{name};
                    $color = "4c6";
                    $W = $t;
                }
                if ($ty eq "G") {
                    $name = $t->{name};
                    $color = "4c6";
                    $W = $t->{T}->{W};
                }
                ($nb,$nl) = $name =~ /^(.+)\(([^\)]+)\)$/;
                $nl ||= $name;
                $s->{style}.="border-left:40px groove #$1;"
                    if $nb =~ m/^\w+-\w{5}(\w{3})/;
                $s->{html} = 2;
                'this   the stylebush,          
                                            the data is walking around';
                $nb = join "ᣪ", map {
                    length($_) < 3
                    ? $inc->('#CCFF33;font-size:23pt', $_)
                    
                    : /^\((.+)\)$/ # O G way
                    ? $inc->('#f93;font-size:14pt', $1)
                    
                    : /^(#.+)$/ #divid
                    ? $inc->('#af1;font-size:14pt', $1)
                    : $inc->('#111;font-size:10pt', $_) } split '`s ', $nb;
                    
                if ($W && ref W.script eq "ARRAY") {
                    # totals
                    $W = $inc->("rgba(255,255,255,0.8);font-size:10pt;"
                        ."position:absolute;left:-3em;"
                        ."bottom:3px;",
                          $W->uhigh,
                    );
                }
                else {
                    $W = "";
                }
                $ty = 'Ѿ' if $ref eq 'W';
                $ty = 'Ꮹ' if $ref eq 'G';
                $ty = 'ᎍ' if $ref eq 'T';
                $name = $W.$emb->($ty).$inc->('#111;font-size:8pt', $nb).$nl;
            }
            
            $s->{style} .= "text-shadow:2px 3px 3px "
                .(@{$line->{o}} ?"#89F":"rgba(255,244,100,0.4)")  .";";
            $s->{style} .= "font-weight: 900;";
        }
        else { #c t string string string
            
            if ($t =~ m/^\w+-\w{5}(\w{3})/) {
                $s->{style}.="border-left:18px groove #$1;";
            }
            $color = "999";
            $s->{style} .= "font-weight: 500;";
            my $v = $t;
            $color = "47B247";
            if (!defined $t) {
                $v = "~undef!";
                $color = '000';
            }
            if (length($v) > 2700) {
                 $v = substr($t, 0, 2680)."...";
            }
            $fs = 9;
            $fs = 15 if length($v) < 90;
            $fs = 20 if length($v) < 40;
            $fs = 25 if length($v) < 12;
            $name = $v;
            
            $font = "font-family:mono; line-height: 1em;";
            
        }
        $s->{value} = $name; #c t ETC         ETC         ETC
        my $l = length($name);
        $fs ||= 17 if $l > 10;
        $fs ||= 10 if $l > 20;
        $fs ||= 25;
        $fs = int($fs *1.4) if $splatname eq "wing";
        $s->{style} .= "font-size:${fs}pt;";
        
        $s->{style}.="max-width: 45em;";
        $s->{style}.="word-wrap:break-word; max-height:50em; min-width: 10em;";
        $s->{style}.="color:#$color;";
        $s->{style}.="background: #330; ";
        
        $font ||= "font-family:serif;";
        $s->{style} .= $font if !ref $t;
        $s->{_event} = w line/event;
        $s->{class}.= " splatt ";
    d:
      v: |
        $line->{depth}
      s: |
        $s->{style} .="color: #3D52A8; font-size:20pt; position: absolute; background:none; top:-0.25em;";
        $s->{_event} = sub {
            my ($e, $s, $t) = @_;
            $H->JS("\$('.$t->{id}').slideUp();");
        };
    i:  #c i o
      v: |
        $b->{c} = $line->{i};
        my $v = w desc/chain(+ c => $b->{c});
        $v;
      s: |
        $s->{class} .= " splat-w ";
        $s->{style}.="margin-top:1px;background:rgba(130,108,33,0.5);text-align:right;"
            ."width: "
        .(($line->{depth}) * 5 + 3)."em;"
            if $line->{depth} > 0;
        
        if (s.value =~ /\{\{/) {
            my $width = 0;
            while (s.value =~ /\{/g) { $width++ };
            s.style .= "text-align:left;padding-left:".$width."0em; width:14em;";
        }
        my $K = $b->{c}->{K};
        
        my $ilt = $line->{i}->{B}->{Lo}->{t};
        if ($ilt && ref $ilt
            && "$ilt" =~ "HASH"
            && $ilt->{id}
            && $ilt->{id} =~ /^\w+-\w{5}(\w{3})/) {
                $s->{style}.="border-right:1px solid #$1;";
        }
        
        my $color = $line->{i}->{K} && $line->{i}->{K} eq 'ARRAY' ?
                      "0F2E1F" : 'bbb';
        $s->{style}.="color: #$_;" for $color;
        s.style .= "font-size:140%;" if s.value !~ /\n/;
            
        $s->{_event} = sub { w go(thing => $line->{i}) }
    o:
      v: |
        $b->{c} = $line->{o};
        w desc/chain(+ c => $b->{c});
      s: |
        $s->{class} .= " splat-w ";
        $s->{style} .= "font-size:7pt;" if length($s->{value}) > 8;
        $s->{style} .= "max-width:15em; background:rgba(130,108,33,0.5);";
        $s->{style} .= "color: #f82;" unless $s->{value} eq "none";
        $s->{_event} = sub { w go(thing => $line->{o}) }
  
  desc:
    chain: |
      return "?" unless $c;
      
      if (ref $c eq "ARRAY") {
          my @cl;
          
          for my $cc (@$c) {
              push @cl,
            scalar w desc/chain(+ c => $cc)
          }
          return "[]" unless @cl;
          
          
          my @names = @cl;
          return scalar(@cl)." @names";
      }
      my $l = $c->pint if $c && ref $c eq "Way";# =~ /^(Way|C)$/; # fucks it?
      unless (defined $l) {
          $l = 
          join ", ",
              map { "$_: $c->{$_}" }
              sort keys %$c;
      }
     
      if (0 && $c->{as_from}) {
          $l .= "<".w desc/chain(+ c => $c->{as_from});
      }
      return $l
    
  wdump: |
    use Data::Dumper;
    $Data::Dumper::Maxdepth = 2;
    return Dumper($in);

  colorf: |
    my $fing = $in;
    my ($l,$r,$b) = @_;
    my ($color) = ($in || "0") =~ /\(0x....(...)/;
    $color ||= $fing if $in && ref \$in eq "SCALAR" && $in =~ /^(\x{3}|\x{6})$/;
    $color ||= "663300";
    $l ||= 0;
    $r ||= 0;
    $b ||= 3;
    return "text-shadow: ${l}px ${r}px ${b}px #$color;";

  random_shadow: |
    my ($rgb) = join", ", map int rand 255, 1 .. 3;
    return "text-shadow: 0px 0px 4px rgb($rgb);";
  random_colour: |
    my ($rgb) = join", ", map int rand 255, 1 .. 3;
    return "rgb($rgb);";
  random_colour_background: |
    my ($rgb) = join", ", map int rand 255, 1 .. 3;
    return "rgb($rgb);";

