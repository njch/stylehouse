C may#styley:
 - #
  - cm
  - 5.8
  - |
    my $wt = ejson {id=>at.id, value=>at.s};
    at.id || die;
    at.dig = cs.dig || die "no diggy";
    acum $at, Esc => " a\.cod($wt);";
    at.s = '';
 - #
  - pi
  - 5
  - |
     at.ishtml = 1;
 - #
  - lp
  - 5
  - |
     at.ishtml = 1;
 - #
  - gp
  - 5
  - |
     at.ishtml = 1;

 - #
  - ishtml
  - 5
  - |
     at.ishtml = 1;

 -
  - sf # has a way to $a the gp action within...
  - 5
  - |
    push @{at.css}, map { $R::f->{$_} || die "no style $_"} split '_', $v;
 -
  - css
  - 5
  - |
    $v = join ';', map{"$_:$v->{$_}"} sort keys %$v if ref $v;
    push @{at.css}, $v;
 -
  - id
  - 5
  - |
    at.id = $v;
 -
  - tt
  - 5
  - |
    at.title = $v;
 -
  - canvas
  - 5
  - |
    at.canvas = $v;
 -
  - nt
  - 5
  - |
    at.title = undef;
 -
  - type
  - 5.1
  - |
    at.type = $v;
    at.ishtml = 1;
    at.title = undef;
 -
  - tag
  - 5
  - |
    at.tag = $v;
 -
  - at
  - 5
  - |
    $v =~ /^(?:(\S+):)?(\S+)$/;
    $at->{$1} = $2;
 - #
  - atrp
  - 5
  - |
     at.rp = $v;
 -
  - path
  - 5
  - |
    # TODO compile J.ys
    # should get %idly if not lev/gp too
 -
  - origin
  - 5
  - |
    #
 -
  - waves
  - 5
  - |
    #
 -
  - pwar
  - 5
  - |
    #
 -
  - Joint
  - 5
  - |
    #
 -
  - idly
  - 5
  - |
    my $id = mkuid();
    at.id && die "arl";
    at.id = $id;
    J.idyl->($J, $id, $j);
    #
R_Jz:

 - K: A #c light cone trig, soul of may, makes W meta bracket
   n_D:
     yJ: |
       'A'
     around: |
       ar.X ?
           Rw A/X
       :1;
     up: |
       my $aj = {Wid=>J.Jo.id,J=>J.Jo,id=>mkuid,c=>[],sc=>[]};
       acum $J, W => $aj;
       $aj;
     X: |
       my $aj = Rw up;
       acum $aj, 'c', " \$('#X.id').fadeOut(1000, function() { \$(this).remove(); });";
       Rw Em $aj;
 - K: jamsc #c sc->j.bb
   D: |
     return if !$sc;
     for my $k (sort keys %$sc) {
         my $v = $sc->{$k};
         J.bz->("j.l%$k\t".j.cv => $v);
     }
     
 - K: sctks #c # expand (k:)?lma:v to lma:k:v
   D: |
     my $tks = {};
     for my $k (sort keys %$sc) {
         my $v = $sc->{$k};
         # possible extra {} level couples into com '' behind $k
         # com is for many of same styles
         my $com = ref $v eq 'HASH' ? $k : ''; # $k can be ''
         my $t = ref $v eq 'HASH' ? $v : {$k=>$v};

         for my $tk (sort keys %$t) {
             $tks->{$tk}->{$com} = $t->{$tk};
         }
     }
     $tks
     
 - K: ordlv #c
   D: |
       my @first;
       my @tops;
       @$vs = grep{defined} map { # COMPRESSION v
           my $v;
           if (#J.oy.ordlv.slashtopi && 
           _.j.l =~ /\/$/) { # make envelope aft
               push @tops, $_;
           }
           elsif (0 || _.j.l eq 'K' && J.bb->{"name 0.1"} eq _.j.s
               && _.j.s ne J.bb->{"K 0.2"}) {
           }
           elsif (J.oy.ordlv.ninefirst && _.j.cv =~ /9/) {
               push @first, $_;
           }
           else {
               $v = $_;
           }
           $v
       } @$vs;
       unshift @$vs, @first;
       push @$vs,
         reverse
         sort { a.j.cv <=> b.j.cv }
         sort{ a.j.r cmp b.j.r } @tops;
       $vs
     
 - K: scitl #c iterate iterations
   D: |
     my @dl = @$styles;
     warn "nodl" if !@dl;
     
     my $i = 0;
     my @om;
     my $flying = 0;
     sub {
         if (@om) {
             my $o = shift @om;
             $flying = 0;
             return @$o;
         }
         while (1) {
             return if !keys %$tks;
             if (!exists $dl[$i]) {
                 $i = 0;
                 if ($flying++ > 2) {
                     my $cs = {};
                     $cs->{$_} = delete $tks->{$_} for keys %$tks;
                     $flying = 0;
                     if (ar.X.FLYING) {
                         return 'FLYING', '', $cs, $tks;
                     }
                     else {
                         sayre $F[2]->pi,
                         $F[0]->pi,
                         "    unnibblable (make FLYING to catch): ".ki 2, $cs;
                         return;
                     }
                 }
                 next;
             }
             my $tk = $dl[$i];
             if (!exists $tks->{$tk}) {
                 $i++;
                 next;
             }
             my $oms = delete $tks->{$tk};
             # delete so if tks come back, we repeat
             for my $com (sort keys %$oms) {
                 my $v = $oms->{$com};
                 push @om, [$tk, $com, $v, $tks];
             }
             $i++;
             if (@om) {
                 my $o = shift @om;
                 $flying = 0;
                 return @$o;
             }
         }
     }
   

   
 - K: kyv #c go tyv -> com style $cs
   D: |
     my $ts = {};
     for my $k (sort keys %$sc) {
         my $cs = $sc->{$k};
         my ($style,$com) = split '#', $k;
         die if $style =~ /\W/;
         $ts->{$com}->{$style} = $cs;
     }
     $sc = $ts;
 - K: tks_cs #c tks -> style=>v
   D: |
     my $cs = {};
     for my $k (sort keys %$tks) {
         my $w = $tks->{$k};
         my @wks = sort keys %$w;
         my ($el) = @wks;
         my $v = $w->{$el};
         if (@wks > 1 && 0) {
             warn "ar.r   style $k collaprse ::: ".ki($w)."\n"
             ." went with $el: $v";
         }
         $cs->{$k} = $v;
     }
     $cs
           
 - K: sit #c style hummer
   D: |
     my $o = Rw pul + path o x;
     my $X = (ar.wJ||$G)->{drop}->{o.path}->{o.x};
     my $styles = (ar.wJ||$G)->{drop}->{o.path}->{o.o};
     #die wdump [ $o, ar.oJ.drop ] if ar.oJ;
     my $sc = ar.sc || ar.lv.sc;
     # keyscrunch
     # the law is to make it not to crazy
     # style#Com / v (sctks should eat this, esc chang)
     $sc = Rw kyv $sc;
     # com / style / v
     my $tks = Rw sctks $sc;
     # style / com / v
     my $cs = Rw tks_cs $tks;
     # style / v
     my $it = Rw scitl $X $tks $styles;
     
     return $tks, $cs, $it;
 - K: C_may #c
   n_D:
     el:
       STYLE: | #
         {droplist => 'O',
          subhash => 'X',
          subhash_X_arp => '$com,$cs,$at,$lv,$J,$j',
         }
     Conned: |
       sayre "conned may";
     u: |
       # YIN
       #sayyl "Maky on J.name: R.way.hooks.may_X";
       # v should be somehow, not necessarily # sorta J/1 in gpasm
       
       say "         MAY J.name        J.name MAY";
       
       G.oin.idJy->{J.id} ||= $J;
       
       # 0.1        think these want to be injected crazily
       if (!J.yy.may.noroot) {
           exists J.bb->{"/\t0.9"} ||
           J.bz->("/\t0.9", "y", "%tag","ux","%tt"=>J.name);
           exists J.bb->{"/%id\t0.9"} ||
           J.bz->("/%id\t0.9", J.id);
       }
       
       my $oJ = Rw oJ $J A;
       #  ^ v MMMMMMMMMM aj ejector
       my $aj = Rw up $J:oJ;
       
       my $vs = Rw tyv $J;
       # puts /s backwards and last:
       my $gs = Rw ordlv $J $vs $slashtopi=1;
       
       my @s; # heading
       
       # this should be all the current lvs
       my %now = map{_.j.r => 1} @$gs;
       for (keys %{oJ.bb}) {
           /^(.+)%.+?\t(\S+)$/||die$_;
           if (!$now{"$1\t$2"}) {
               delete oJ.bb->{$_};
           }
       }
       
       for my $lv (@$gs) {
           push @s, $lv;
           my $j = lv.j;
           die "reffy j.s in j.l ON J.name".wdump 3, [ar.ip, $j] if ref j.s;
           
           my $k = "may j.r";
           my $coi = Rw pha $J:oJ $k;
           coi.qui = 1;
           my $xat = do {
               Rw lv_same $lv $x:coi $J:oJ;
           } if oJ.bb->{"j.l%at\t".j.cv} && j.l !~ /\//;
           
           
           my $at;
           my $pat;
           my $plv;
           if (!$xat) {
               $at = {css=>[]};
               at.s = j.s;
               # may be creating, overhead thought
               at.__ajid1 = aj.id;
               
               my ($tks, $cs, $it) = Rw sit may O X $lv;
               
               #c >< up from...
               if (j.l =~ /^(.*)\/$/) { # carbon hapsso env
                   # grep tw for $1/things
                   my $p = $1;
                   $p .= '/' if length $p;
                   #sayre "looking for '$p' directed";
                   my $olvr = "j.l%lv\t".j.cv;
                   # assume this/ is for this/*, / is for *
                   my @lvs =
                       sort { a.j.cv <=> b.j.cv }
                       sort{ a.j.r cmp b.j.r }
                       grep {_.j.l ne j.l}
                       grep {!_.at._jointed || grep {$_ eq $olvr} @{_.at._jointed}}
                       # $lv ^
                       map {oJ.bb->{$_}}
                       grep {/^$p/}
                       grep {/%lv\s+\S+$/}
                       keys %{oJ.bb};
                       
                   # j sc may have a motice to grab something
                   acum $at, _joins => "_.j.l%lv\t"._.j.cv for @lvs;
                   
                   _.at || die "no at _.j.r (we j.r)".wdump($_) for @lvs;
                   acum _.at, __jointed => $olvr for @lvs;
                   
                   # really like n.sc.z = [...]
                   at.ishtml = 1;
                   at.s = '';
                   @s = ();
               }
               
               while (1) { #c sciterate
                   my ($tk, $com, $v, $tks) = $it->();
                   last if !$tk;
                   #say " $tk, $com, $v, $tks";

                   my @s = $X->{$tk}->($v, $tks, $X, $com, $cs, $at, $lv, $J, $j);
                   #say "May X $tk returned: ". wdump [@s] if @s;
               }
               
               # Some 7 while symmetrical... some 7 of extrude
               @{at.css} = map { join '', map{"$_;"} 
               grep{defined} split ';', $_ } @{at.css};
               # at beam
               $pat =
               oJ.bb->{"j.l%at\t".j.cv};
               $plv =
               oJ.bb->{"j.l%lv\t".j.cv};
               oJ.bb->{"j.l%lv\t".j.cv} = $lv;
               oJ.bb->{"j.l%at\t".j.cv} = $at;
               
               my $y = coi.end->();
               my $ex = Rw ph_exactl $J:oJ $y;
           }
           else {
               $pat = oJ.bb->{"j.l%at\t".j.cv};
               $plv = oJ.bb->{"j.l%lv\t".j.cv};
               oJ.bb->{"j.l%lv\t".j.cv} = $lv;
               $at = $pat;
           }
           
           # gets self aware in waves
           # above can now trust lvs to have iter-sane E{s,}c[] impulses / same s
           at.__ajid2 = aj.id;
           lv.at = $at;
           
           my $inv = sub {
              my $wa = shift;
              my $ig = shift;
              return ejson $wa if ref $wa eq 'ARRAY';
              join"            ", map{"$_:".ejson($wa->{$_})}
              sort grep {!$ig||$_ !~ /^($ig)$/} grep{!/^__/} keys %$wa;
           };
           my $tryig = sub {
              my $ig = shift;
              $inv->($pat, $ig) eq $inv->($at, $ig)
           };
           my $kinv = sub {
              my $k = shift;
              $inv->($at->{$k}) ne $inv->($pat->{$k})
           };
           
           # eats #c
           if (at._joins) {
               my @lvs = map { oJ.bb->{$_} } @{at._joins};
               
               say "j.r eats    ".join',   ', map{_.j.r} @lvs;
               # or compressions in c, sc
               # make them tubes real nice
               my @live = grep {_.at.__ajid2 eq aj.id} @lvs;
               my @skip = grep {_.at.__ajid2 ne aj.id} @lvs;
               # can trust lvs c/sc from this aj (pipe/time)
               # circumference
               # future should be all self...
               # el:
               # C[/:ux, 0.3, {id:$id,cl:$class,etc:whatsit}, [
               #   C[Jhead, 0.1, ["yt",:h3YO-zOl82g}, [
               
               
               # hoist at.Cs into our at.C t y c sc ssc
               #
               # assume @live phased will sane s/c/sc
               map { acum $lv, 'Esc', $_ for @{_.Ec} } @live;
               map { acum $lv, 'Esc', $_ for @{_.Esc} } @live;
               
               # these are flying blind chunks of html in s
               # few replace selves, say lv.scon = 1;
               # make at.s [ [_.j.r => _.s] ... ] and shake down...
               # filter out who is scon'ing for themselves
               # they want to Jtube through us
               at.s = join '', map { _.s } @lvs;
               # these are curving down into things
           }
           
           my $sat = $inv->($at);
           my $spat = $inv->($pat) if $pat;
           my $ateq = $sat eq $spat;
           if (at.c) { #cleaves away c/sc lines
           # which are really just patterns to keep embedding higher and hire
               if ($ateq && !at.pur) {
                   #acum $lv, 'Ec', " a\.m('nothing');";
                   next;
               }
               # args for y
               # some day G.w(y, @args);
               my $js = ref at.s eq 'ARRAY' ?
                   join(',',map{ ejson($_) }@{at.s})
                   : ejson(at.s);
               acum $lv, 'Ec', ' a.'.at.c.'('.$js.');';
               # eventual lv.C = [ [...]... ] and then aj.C = [lvs{}C];
               # yet vectory again
               # bucket fountain, musical atitude
               # where mess goes into black hole, proofs strung up
               next;
           }
           if (at.Esc) {
               acum $lv, 'Esc', $_ for @{at.Esc};
           }
           
           #c at out scribe, #c slump to end ## switch up pool of lang > styles
           if ($spat && !$ateq) { # S-C
               # maybe .html if $tryig->('s')
               # or replaceWith if spat.id or we can find ourselves
               # for aj.C streams it shall easy...
           }
           
           at.style = join '', map{"$_;"} 
           grep{defined} map { split ';' } @{at.css};
           delete at.style if !length at.style;
           # <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
           #Rw attitle $at $j;
           
           my $of = {map{$_=>1}qw's ishtml css tag rp'};
           my $s = at.s;
           my $ishtml = at.ishtml;
           $s = encode_entities($s) if !$ishtml;
           
           
           my $tag = at.tag;
           my $ts = j.l;
           $ts =~ s/[^\w]/ñ/sg;
           $tag ||= "$ts";
           $tag = "Z$tag" if $tag !~ /^[a-z]/i;
           my $arp = at.rp if exists at.rp;
           my $mat = join " ", $tag,
               map { $_ }
               map { $_.'="'.$at->{$_}.'"' } # attra
               grep { $at->{$_} } sort grep {!/^_/ && !$of->{$_} } keys %$at;
           
           $mat .= ' '.$arp if defined $arp;
           
                   # whole replace
           lv.s = "<$mat>$s</$tag>";
           lv.scon = 1 if lv.s eq plv.s;
           
           if (pat.id) { # S-C
               lv.scon = 1 if lv.s eq plv.s;
               # need to relax the _jointed, cannot find?
               #say "j.r      pat __jointed: ". wdump 2, plv.__jointed;
               # acum $lv, 'Ec', jsq ' $(%s).replaceWith(%s);', '#'.pat.id, at.s;
           }
           #saybl "left j.r   ".lv.s;
           # here hangs loose, we would want to conduct at.c/sc business cleanly
           
       }
       # check lv up cover
       if (J.yy.may.noroot) {
           die 'noroot ag has s'.wdump($_) for grep {_.s} @s;
           aj.c = [map{@{_.Ec||[]}}@s];
           aj.sc = [map{@{_.Esc||[]}}@s];
       }
       else {
           my $lv = oJ.bb->{"/%lv\t0.9"};
           aj.s = lv.s;
           delete aj.s if lv.scon; # no repeat emit
           aj.c = lv.Ec || [];
           aj.sc = lv.Esc || [];
       }
       if (!ar.catj) {
           Rw Em $aj;
       }
       
       $aj
       
 - K: attitle #c no
   D: |
     if (!exists at.title || defined at.title) {
         at.title = "j.cv j.l".(defined at.title && " * at.title")
         if at.title !~ /^j.cv j.l/;
     }

