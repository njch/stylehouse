R_Jz:
 - K: clw #c
   n_D:
     curves: |
       zoom 0  0.6 
       y    0  0
       x    0  0
       curve 0 -0.1
     
 - K: Em #c send love
   D: |
     # aj.id is the J zipped .c to E in one, stream?
     
     aj.J.yt.zipline &&
         Rw zipline
     && return;
     
     aj.Wid || die "not Wid?";
     aj.hol = "H.style/H.name/H.id";
     aj.hitime = hitime;
     aj.name ||= aj.J.name;
     
     # also some J.headlev readings for .i
     aj.sent = 1;
     
     # route aj.W from ...
     G.Wh->{aj.Wid} ||= do {
         my $ij = {}; map {
         $ij->{$_} = $aj->{$_} if !/^[sc]+/; } keys %$aj;
         ij.id = delete ij.Wid;
         ij.y = 'W';
         
         sayyl "Life! of ij.y ij.id";
         0->tai("ij.y/ij.id\.i", $ij);
         0->tac("V/H.style/H.name/H.id\.s", ztm($ij));
         aj.J;
     };

     Rw J5 wu $aj;
     
     aj.y ||= 'J';
     aj.yy = 'W';
     Rw aji $aj;
     Rw blabaj $aj;
 - K: aji #c 
   D: |
     my $z = ztm($aj);
     if (aj.yy) {
         0->tac("aj.yy/".$aj->{aj.yy.'id'}.'.s', $z);
     }
     my @m;
     for my $s (sort grep{/^[sc]+$/} keys %$aj) {
         my $v = $aj->{$s};
         if ($s eq 's') {
             die "s is $v" if $v;
             next;
         }
         ref $v || die "$s is $v";     
         push @m, @$v;
     }
     my $m = join "\n", @m;
     0->tai("aj.y/aj.id\.c", $m);
     0->tac("aj.y\.s", $z);
     
 - K: blabaj #c
   D: |
     return if aj.J.yt.quiet;
     saybl "E    aj.name    aj.yy/".$aj->{aj.yy.'id'}."   (  aj.id      aj.oudelta";
     for my $k (sort grep{/^[sc]+/} keys %$aj) {
         my $v = $aj->{$k};
         if (ref $v eq 'ARRAY') {
             my $i = 1; 
             my $lim = $k eq 'c' ? 70 : 90;
             saybl "$k ".$i++."=".slim $lim, $_ for @$v 
         }
         else {
             saybl "$k    => ".slim 80, $v;
         }
     }
 - K: wu #c cattach anything under ww, trainyard, patch bay, hash out space <body>
   n_D:
     yJ: |
       'wu quiet'
     around: | 
       J.stup ||= Rw wu/wup;
       ar.aj ?
          Rw wu/ajwu
       :
       ar.X ?
          Rw wu/unwu
       :();
     wup: | # non self id wirdness
       J.stup = 1; # as we Em->wu
       Jn('/', 0.9, {}, "{id:J.id,tt:H.ol,tag:ww,poi:0,ab:100,bgh:33.5.3.1}");
       G.Wid = J.id;
       my $ip = {l=>'l'};
       my $aj = Rw may $J $catj=1 $ip;
       if (my $s = delete aj.s) { # OUR ww/ a W multiplex of W uxy
           unshift @{aj.c}, jsq " \$('#ux').append(%s);", $s;
       }
       Rw Em $aj;
       $aj;
     ajwu: |
       # transact aj into W...
       # a.wu is blob kinda a.o
       #Jn(aj.Wid, 0.2, {tsup=>'1'});
       #Jn(aj.Wid.'/'.aj.id, 0.3,
       # ux 7 APADO
       if (my $s = delete aj.s) { # first timey, otherwise C knows all
           unshift @{aj.c}, jsq
               " a\.wu(%s, %s, %s);",
               J.id, aj.Wid, $s;
           
       }
       $aj;
     unwu: |
       if (my $J = X.oJ.A) {
           Rw around $J $X;
       }
       else {
           die "kill no oJ: X.name X.id";
       }
       
 - K: on #c
   n_D:
     yJ: |
       J.yl.nojb = 1;
       'on';
     up: | # tak tlv J.on into iterations of upgoing clever
       Rw thy $oJ:J $J:J.Jo defon;
       
       my $vs = Rw tyv $J $ip:ar.ip;
       
       sayyl "ON J.Jo.name";
       my $nc = -1;
       for my $lv (@$vs) {
           $nc = 0 if $nc == -1;
           my $j = lv.j;
           my $coi = Rw pha $J $k=j.r;
           coi.off=100;
           my $lnc = Rw lv_same $lv $j $x:coi $J;
           $nc = 0 if !$lnc;
           if ($lnc) {
               sayyl "LINEHUM SAME";
               #next;
           }
           
           my $sc = {};
           if (!lv.sc) {
               say "INIT STYLO ". lv.j.r ."     ".ki lv.sc;
               if (j.s =~ /^[A-Z0]\/./) {
                   sc.ou = 'file';
                   sc.dir = 'ghosts/';
               }
               # upgrade strings to thoughts
               # drag in
               Rw jamsc $J $j $sc;
           }
           
           coi.end->();
       }
       $nc;
       
       
 - K: oundo #c hound god from a crux of inness $x
   D: |
     my $o = {r=>[]};
     # fills up @r to $thi
     # also $plucky to select hash key order
     # a space for tiny-part-of-huge-set access
     
     my $u = x.j.s;
     my $sc = x.sc;
     
     # $plucky could rate the things it gets passed
     # and the $thi yins up out here
     
     sc.ou ||= 'text' if !ref $u;
     sc.ou ||= 'array' if ref $u eq 'ARRAY';
     sc.ou ||= 'code' if ref $u eq 'CODE';
     sc.ou ||= 'hash';
     
     # further dimensional sc if {} or something?
     # so the spec can curve data all the way
     my $thi = x.thi || die;
     Rw ou/sc.ou + $u $o $x $sc $thi;
     
     sc.grp &&
     Rw og/sc.grp + $u $o $x $sc;
     
     # $r rows over the contents
     # r.c probably for pi, other stuff may pick stuff up...
     
     o.thi = @{o.r};
     $o
 - K: pi/infrom #c
   D: |
     my $x = $u;
     
     Jn('onl', 0.1, "x.j.l", '{co:38f,fs:12}');
     
     Jn('is',0.102,{s=>':',pwth=>'whack'},'{fs:20,co:eee}');
     
     Jn('s', 0.11, {pi=>'',s=>x.j.s},'{fs:15}');
     
     
     
     my $in = {%{x.sc||{}}};
     Jn('sc',0.3, {pi=>'scbund',s=>x.sc},
         {fs=>23 ,co=>'314',sha=>'1 1 3 fff'});
     
     if (my $time = x.sc.ts) { # can't be zero, so relative
         Rw ii/time + $time;
     }

