
R_Jz:


 - K: osca #c unsolved c hold
   D: |
     my $als = {};
     $als->{_.style}->{_.com||''} = _.s for values %{lv.sj};
     my $sc = {};
     
       for my $k (keys %$als) {
           my $ck = $als.>$k;
           my @ks = sort keys %$ck;
           
           my $one = shift @ks; # probly ''
           my $v = $ck.>$one;
           ($sc.>$k) = $v;
           
           for my $com (@ks) {
               next if $ck.>$com eq $v;
               #die wdump [@ks];
               die "multiple @ks".wdump[$als,$sc];
           }
       }
     $sc
 - K: chuv/flows/chov #c
   D: |
     #MZ pa:geomo
     flow 1
     nesting 4
     V 5
     wonga 5
     outs 7
     Wout 8
 - K: chov/flow #c
   D: |
     # 1
     G.oin.idJy->{J.id} ||= $J;
     
     # 3 spewing two-step
     my $vs = Rw tyv $J;
     my @s;
     
     
     # 3.9
     for my $lv (@$vs) {
         push @s, $lv;
         my $j = lv.j;
         #die "reffy j.s in j.l ON J.name".wdump 3, [ar.ip, $j] if ref j.s;
         
         # 4 figure floor
         my $coi = Rw pha $J:aJ $k:j.r;
         coi.qui = 1;
         
         my $xat; # 1 to ignore
         
         my $hav = lv.sc.enid && lv.sc.J && lv.sc.J.oJ.A;
         if ($hav) {
              my $aj = hav.W->[-1];
              $xat = 0 if !aj.sent;
              say "Exat in J.r J.d.t " if J.name ne 'shv';
         }
         
         $xat = do {
             Rw lv_same $lv $x:coi $J:aJ;
         } if !defined $xat && aJ.bb->{"j.l%at\t".j.cv} && j.l !~ /\//;
         
         
         my $at;
         my $pat;
         my $plv;
         if (!$xat) {
             $at = {};
             at.s = j.s;
             # may be creating, overhead thought
             at.__ajid1 = aj.id;
             # 5
             
             # 5.9
         }
         # gets self aware in waves: 5 busi, 6 traj, 7 scoops
         # above can now trust lvs to have iter-sane E{s,}c[] impulses / same s
         $pat = aJ.bb->{"j.l%at\t".j.cv};
         $plv = aJ.bb->{"j.l%lv\t".j.cv};
         if (!$xat) {
             aJ.bb->{"j.l%lv\t".j.cv} = $lv;
             aJ.bb->{"j.l%at\t".j.cv} = $at;
             
             coi.exactl->();
         }
         else {
             aJ.bb->{"j.l%lv\t".j.cv} = $lv;
             $at = $pat;
         }
         at.__ajid2 = aj.id;
         lv.at = $at;
         # 6
         
         # 7.9 # T ^``
     }
     # 8 check lv up cover
     if (J.yy.may.noroot) {
         die 'noroot ag has s'.wdump($_) for grep {_.s} @s;
         aj.c = [map{@{_.Ec||[]}}@s];
         aj.sc = [map{@{_.Esc||[]}}@s];
     }
     else {
         my $lv = aJ.bb->{"/%lv\t0.9"};
         aj.s = lv.s;
         delete aj.s if lv.scon; # no repeat emit
         aj.c = lv.Ec || [];
         aj.sc = lv.Esc || [];
     }
     # 8.8
     aj.oudelta = F_delta;
     if (!ar.catj) {
         Rw Em $aj;
     }
     # 9
     $aj
     
 - K: geomo/nesting #c
   D:
     -
      - backl
      - 1
      - |
       if (!J.yy.may.noroot) {
           J.bz->("/\t0.9", "y", "%tag"=>J.name) if !exists J.bb->{"/\t0.9"};
           J.bz->("/%id\t0.9", J.id) if !exists J.bb->{"/%id\t0.9"};
       }
     -
      - A
      - 2
      - |
       my $aJ = Rw oJ $J A;
       #  ^ v MMMMMMMMMM aj ejector
       my $aj = Rw up $J:aJ;
     
     -
      - knowone
      - 3.7
      - |
       # know what we are ignoring and destroying
       # bi-pha
       # pingy statechange graphicly allele towers
       # $vs should stretch over aJ as far as any $ip is
       #
       my $now = {map{_.j.r => 1} @$vs};
       my @gone;
       for (keys %{aJ.bb}) {
           /^(.+)%.+?\t(\S+)$/||die$_;
           if (!$now->{"$1\t$2"}) {
               push @gone, $_;
               delete aJ.bb->{$_};
           }
       }
       if (@gone) {
           @gone = uniq map{s/%\S+//;$_} @gone;
           sayre "Gone: ".join', ',sort @gone;
       }
     -
      - vsord
      - 3.2189
      - |
        # puts /s backwards and last:
        $vs = Rw ordlv $J $vs $slashtopi=1;
     -
      - nesto
      - 4.189
      - |
        # >< up from... # carbon hapsso env 
        if (j.l =~ /^(.*)\/$/) {
            die "Upwards: 'j.l'" if j.l ne '/';
            X.nestw->($1,$j,$at,$aJ,$lv);
            @s = ();
        }
     -
      - nests
      - 6.189
      - | 
        # eats hoist
        X.nestz->($j,$at,$aJ,$aj,$lv) if at._joins;
        
     - MZ: dorp:X
     -
      - nestw
      - 3
      - |
        my ($p,$j,$at,$aJ,$lv) = @_;
            # grep tw for $1/things
            $p .= '/' if length $p;
            #sayre "looking for '$p' directed";
            my $olvr = "j.l%lv\t".j.cv;
            # assume this/ is for this/*, / is for *
            my @lvs =
                sort { a.j.cv <=> b.j.cv }
                sort{ a.j.r cmp b.j.r }
                grep {_.j.l ne j.l}
                grep {!_.at._jointed || grep {$_ eq $olvr} @{_.at._jointed}}
                # $lv ^
                map {aJ.bb->{$_}}
                grep {/^$p/}
                grep {/%lv\s+\S+$/}
                keys %{aJ.bb};
                
            # j sc may have a motice to grab something
            acum $at, _joins => "_.j.l%lv\t"._.j.cv for @lvs;
            
            _.at || die "no at _.j.r (we j.r)".wdump($_) for @lvs;
            acum _.at, __jointed => $olvr for @lvs;
            
            # really like n.sc.M = [...]
            at.ishtml = 1;
            at.s = '';
     - 
      - nestz
      - 3
      - |
        my ($j,$at,$aJ,$aj,$lv) = @_;
            my @lvs = map { aJ.bb->{$_} } @{at._joins};
            
            say "j.r eats    ".join',   ', map{_.j.r} @lvs if J.V;
            # or compressions in c, sc
            # make them tubes real nice
            my @live = grep {_.at.__ajid2 eq aj.id} @lvs;
            my @skip = grep {_.at.__ajid1 ne aj.id} @lvs;
            if (0) {
                say "j.r ignoresz    ".join',   ', map{_.j.r} @skip if @skip;
                say "j.r has    ".join',   ', map{_.j.r} @live if @live;
            }
            # hoist at.Cs into our at.C t y c sc ssc
            #
            # assume @live phased will sane s/c/sc
            map { acum $at, 'Esc', $_ for @{_.Ec} } @live;
            map { acum $at, 'Esc', $_ for @{_.Esc} } @live;
            
            # these are flying blind chunks of html in s
            # few replace selves, say lv.scon = 1;
            # make at.s [ [_.j.r => _.s] ... ] and shake down...
            # filter out who is scon'ing for themselves
            # they want to Jtube through us
            at.s = join '', map { _.s } @lvs;
            sayre "Got some lv s should Esc: ".slim 80, at.s if at.s;
            # these are curving down into things
        
               
               
 - K: chov/Wout #c
   D:
    -
     - begin
     - 8.5
     - |
       if (J.yt.uppy) {
           my $c = aj.c;
           die 'scs' if @{aj.sc};
           die 's' if aj.s;
           my $M = ['','',{W=>G.Wid},{z=>$c}];
           #sayyl wdump 15, $M;
           aj.c = [" a\.om({},".sjson($M).",a,{});"];
       }
 - K: chov/V #c 5 cs oscacts rejoin the pipelining - form style trance
   D:
    -
     - STYCKS #
     - 5.3
     - |
       #J.V=1;
       if (J.V && !aj.geko++) {
           sayre "am ".gp($J).": ".join ' ', sort keys %{J.yt};
           sayyl "has V: ".join' ',map{_.t}@{wJ.cts.V};
       }
       sayyl "STICKS :   j.r    ".join' ', sort keys %{lv.sc} if J.V;
       my $sc = Rw osca $J $lv;
       
       my $stc = {};
       my $st = sub {
           my $k = shift;
           exists $sc->{$k} || return ();
           $stc->{$k}++;
           return $sc->{$k}
       };
       
       my $g = wJ.ctx.V;
       for my $ct (@{wJ.cts.V}) {
           my @v = st&ct.t;
           @v || next;
           for my $v (@v) {
               saygr "V j.r ct.t ".gp $v if J.V;
               my $A = {J=>$J,j=>$j};
               my $C = {s=>j.s,c=>$v,sc=>$sc}; # bendy stick throw
               my $T = $at;
               wJ.ctx.V->{ct.x}->($A,$C,$g,$T,$J,$j,$v,$at);
               
               die "j.r ct.t $v  make css" if ref at.css eq 'ARRAY';
           }
       }
       my $mys = {};
       for my $k (keys %$sc) {
           next if $k =~ /^_/;
           next if $stc->{$k};
           $mys->{$k} = $at->{$k};
       }
       #sayre "! j.r $_ $sc->{$_}" for #grep { $_ !~ /^(t|y|c|sc)$/ }
       #keys %$mys;
 - K: chov/wonga #c
   D:
   - EZ: chov/Go
   - EZ: chov/spa
   - EZ: chov/sharp
   - EZ: chov/sharpish
 - K: chov/Go #c
   D:
   - MZ: sticks:xV
   -
    - w # do wandering to point
    - 5
    - |
      my $A = {};
      my $C = r.C || {};
      my $T = {};
      C.c = r.s if exists r.s;
      C.sc = r.sc if exists r.sc;
      my $z = $g.>$way;
      #sayyl "gwa $way";
      $z || warn "no $way ".gp($g);
      $z && $z ->($A,$C,$g,$T);
      return $T;
    - args: way,r,g
      way: 1
   - 
    - mksc # 
    - 5
    - |
      my $t = g.w->(mos=>{s=>C.c},$g);
      while(my($k,$v) = each %$t) {
          C.sc.>$k = $v;
      }
      return;
    - args: A,C,g,T
   -
    - mos # language expansion
    - 3
    - |
      my @t = split ',', C.c;
      for (@t) {
          my ($k, $v) = split ':', $_;
          $T.>$k = $v;
      }
    - args: A,C,g,T
 - K: chov/spa #c
   D:
   - MZ: sticks:xV
   -
    - meat
    - 5
    - |
      my $f = $v;
      my $mv = C.sc->{$k};
      $f = g.mean&$f,$mv;
      C.sc->{$k} = $f;
    - args: A,C,g,T,k,v
   -
    - mean
    - 5
    - |
      $mix ||= 0.5;
      my $yu = $fro - $to;
      $yu = $yu * $mix;
      $fro -= $yu;
      $fro
    - args: to,fro,mix
   -
    - cole # it
    - 5
    - |
      my $h;
      (h.r, h.g, h.b, h.a) = ($1, $2, $3, $4)
          if $v =~ /^(\w)(\w)(\w)(\w)?$/ || die "not cole: $v";

          if (defined h.a) {
             # do an rgba(255,255,255,1)
             for my $k (qw'r g b a') {
                 my $e = $h->{$k};
                 $e = "$e$e" if length $e == 1; # out of 255
                 $h->{$k} = hex $e;
             }
             h.la = sprintf '%.2f', h.la / 255; # out of 1
             return "rgba(h.r,h.g,h.b,h.a)";
          }
          else {
             return sprintf "#%s%s%s", h.r, h.g, h.b;
          }
    - args: v
   -
    - hsle # ray lih, unhassley
    - 5
    - |
      my @m;
      for ($v) {
          @m = split ' ', $_;
          last if @m == 3 || @m == 4;
          @m = split /\./, $_;
          last if @m == 3 || @m == 4;
          @m = split '', $_;
          last if @m == 3 || @m == 4;
          @m = ();
      }
      @m || die "not hsle: $v";
      my $h;
      (h.h, h.s, h.l, h.a) = map{0+("0.".$_)}@m;
      
      h.h = h.h * 360 if h.h < 1;
      
      $h->{$_} = ($h->{$_}*100).'%' for 's','l';

      my $al = ", h.a" if defined h.a;
      "hsl".($al?'a':'')."(h.h, h.s, h.l$al)";
    - args: v
   -
    - empc # decide space unit TODO init soon
    - 5
    - |
      $v .= 'em' if $v !~ /(%|em|px)/;
      $v =~ s/^-?0em$/0%/;
      $v;
    - args: v 
 - K: chov/sharp #c
   D:
   - MZ: sticks:V
   -
    - geo
    - 3
    - |
      my $s = join ' ', map{0+$_} v.x, v.y, v.radial;
      $s .= ' '.v.scale if v.scale;
      at.sc.geo = $s;
      C.sc.ab = delete v.ab if v.ab;
   -
    - nspc
    - 2
    - |
      $J = C.sc.J;
      my $squ = C.sc.yspc || J.d.y.spc;
      my $ratio = $squ / $v;
      my $s = sprintf '%.2f', $ratio;
      my $cl = 0.02;
      my $max = C.sc.nspc_max || 1;
      $s = $max if $s > $max;
      if ($s > 1+$cl || $s < 1-$cl) {
          C.sc.geo ? 
          C.sc.geo.scale = $s
          :
          C.sc.tr.scale = $s;
      }
   - 
    - enid
    - 5.9 
    - |
      at.id = $v;
      at.c.nobody = 1; 
      #say "enid j.l :::: ";
      at.t = j.l;
      
      if (my $J = C.sc.J) {
          my $aj = C.sc.J.oJ.A.W->[-1];
          my $l = aj.c->[0];
          if (!aj.sent && ref $l) {
              
              my ($t,$y,$c,$sc) = @$l;
              if ($t eq j.l) {
                  die if c.id ne at.id;
                  %$sc = (%$sc,%{at.sc});
                  at._aux = 1;
              }
          }
      }
    - way: 1
   -
    - css
    - 5.55
    - |
      $v = join ';', map{"$_:$v->{$_}"} sort keys %$v if ref $v eq 'HASH';
      for my $set (split ';', $v) {
          my ($k,$v) = split ':', $set;
          at.sc.css->{$k} = $v;
      }
   -
    - src
    - 5.56
    - |
      at.src = $v
   - #
    - cm
    - 5.84 
    - |
      my $wt = {id=>at.id, value=>at.s};
      at.id || die"noid".wdump 2,$at;
      at.dig = C.sc.dig || die "no diggy";
      at.sc.cod = $wt;
      at.s = '';
   - #
    - J
    - 5
    - |
       #at.ishtml = 1;
   - #
    - pi
    - 5
    - |
       $v = C.sc.J || die'enoJ'.C.t;
       die "Pi v.r has s" if v.s;
       #saygr "Throw away: ".wdump 2,
       delete at.s if defined at.s;
       die "Pi v.r no .Ec" if !@{v.Ec};
       acum $at, 'Esc', $_ for @{v.Ec};
   -
    - idly
    - 5.8
    - |
      my $id = mkuid();
      at.id && die "arl";
      at.id = $id;
      j.sc ||= C.sc;
      J.idyl->($J, $id, $j);
      #die wdump 2, A.J
      #
   - WZ: /stwa


    
 - K: chov/sharpish #c
   D:
   - MZ: sticks:V  
   - [lp,     5, "at.ishtml = 1;"]
   - [ishtml, 5, "at.ishtml = 1;"]
   -
    - id
    - 5
    - |
      at.id = $v;
   -
    - tt
    - 5
    - |
      at.title = $v;
   -
    - canvas
    - 5
    - |
      at.canvas = $v;
   -
    - type
    - 5.1
    - |
      at.type = $v;
      at.ishtml = 1;
      at.title = undef;
   -
    - tag
    - 5
    - |
      at.tag = $v;
   -
    - at
    - 5
    - |
      die;
      $v =~ /^(?:(\S+):)?(\S+)$/;
      $at->{$1} = $2;
   - #
    - atrp
    - 5
    - |
      die "heloarp";
       at.rp = $v;
    - way: 1
   - [path, 5, ''] # TODO compile J.ys
   - [origin, 5, '']
   - [pwar, 5, '']
   - [Joint, 5, '']
 - K: scr/nobody #c
   D:
   - MZ: cc:jsc
   -
     - om #c
     - 2
     - args: A,C,G,T
     - |
       A = $.extend({},A);
       C = G.inC(C); 
       if (!T.d)
           T.d=1; 
       if (typeof C.c === 'string')
           return a.er('c string: '+C.c);
       
       var see = 'w'+T.d+' '+C.t+' '+a.ks(C.c)+'%'+a.ks(C.sc);
       
       if (C.c.W)
           A.on = $('#'+C.c.W);
       if (C.c.el)
           G.el(A,C,G,T);
       if (C.c.nobody)
           A.on = $('#'+C.c.nobody);
       if (C.c.rm) {
           a.m(see);
           var delay = C.c.rm;
           if (!delay)
              delay = 10;
           delay *= 100;
           $(A.on).fadeOut(delay, function() { $(this).remove(); });
           return;
       } 
           
       if (!C.sc)
           C.sc = {};
       
       if (C.sc.z) { 
           //T.d++;
           $.each(C.sc.z, function(i,v) {
               var nC = G.inC(v);
               //a.yl(1, function () { 
                G.om(A,nC,G,{d:T.d+1});
               //});
           });
       }
       
       if (!C.sc.css)
          C.sc.css = {};
          C.sc.anc = {};
       var ung = ['ab','geo'];
       $.each(ung, function(i,v) {
           if (C.sc[v]) {
               var nC = {c: C.sc[v], sc: C.sc};
               var way = 'sc_'+v;
               
               var f = {n: G[way]};
               
               f.n(A,nC,G,T);
           }
       });
       
       
       if (C.sc.css) {
           $.each(C.sc.css, function(i,v) {
                $(A.on).css(i, v);
           });
       }
       if (C.sc.anc) {
           $(A.on).animate(C.sc.anc, (C.sc.ant||900));
       }
       if (C.sc.cod) {
           a.cod(C.sc.cod);
       }
   -
    - sc_geo #c A,C,G,T
    - 3
    - |
      var s = C.c.split(' ');
      C.c = {x:s[0],y:s[1],rad:s[2],scale:s[3]};
      C.sc.css.top = (C.c.y * 100)+'%';
      C.sc.css.left = (C.c.x * 100)+'%';
      C.sc.css['transform-origin'] = '0% 0%';
      
      C.sc.css['transform'] = 'rotate('+C.c.rad+'rad)';
      if (C.c.scale)
          C.sc.css['transform'] += ' scale('+C.c.scale+')';
   -
    - sc_ab #c A,C,G,T
    - 3
    - |
      if (C.c === '100') {
          C.sc.css.width = '100%';
          C.sc.css.height = '100%';
      }
      C.sc.css.position = 'absolute';
   -
    - el #c A,C,G,T
    - 3
    - |
      if (!C.c.attr)
          C.c.attr = {};
      if (C.c.id) { 
          C.c.attr.id = C.c.id;
          var aid = $(A.on).attr('id');
          if (aid && C.c.id) { 
              var to = '#'+aid+' #'+C.c.id;
              var ex = $(to);
              if (ex) {
                  a.m('rm '+ex.prop('tagName')+' '+to);
                  if (ex.prop('tagName') === 'undefined')
                     a.m('?');
                  $(ex).remove();
              }
          }
      }
      var div = $("<"+C.t+">", C.c.attr);
      var el;
      $(div).appendTo(A.on).each(function(i,v){el=v});
      if (C.c.s)
          $(el).html(C.c.s);
      A.on = el;
      
 - K: chov/outs #c
   D:
    -
     - Esc
     - 6.4
     - |
       my $c = at.c ||= {};
       my $sc = at.sc ||= {};
       my $note = {};
       my $not = sub {
           my $k = shift;
           $note->{$k} = 1;
           return $at->{$k} if exists $at->{$k};
           return ();
       };
       my $MM = sub {
           map {[
               (defined _.t ? _.t : ''),
               (defined _.y ? _.y : ''),
               _.c,_.sc
           ]} @_
       };
       
       if (c.nobody) {
           c.nobody = $not->('id');
           $not->($_) for 's', 'ishtml';
       }
       else {
           my $tag = not&tag || do {
             (my $ts = j.l)  =~ s/[^\w]/Ã±/sg; "$ts"
           };
           $tag = "Z$tag" if $tag !~ /^[a-z]/i || $tag =~ /^([sbu]|style)$/i;
           at.t = "$tag";
           
           c.id = $_ for not&id;
           
           not&name;
           not&title;
           not&src;
            
           my $s = not&s;
           $s = encode_entities($s) unless not&ishtml;

           c.s = $s;
           
           die 'attr $something>' if at.rp;
           my $of = {map{$_=>1}qw's ishtml t y c sc Esc Ec id css tag rp'};
           
           c.el = $pat ? 2 : 1;
           
           sc.z = [@{not&Esc||[]}];
           
           if (J.most.J.name eq 'Wander') {
             #say "Off.... j.r". wdump 5, sc.z;
           }
           delete sc.z if !@{sc.z};
           
           # here hangs loose, we would want to conduct at.c/sc business cleanly
           
           # clang
           c.attr->{$_} = $at->{$_} for            
               sort grep {!/^_/ && !$of->{$_} } keys %$at;
       }
       my $may = 0;
       #$may = 1 if not&_aux;
       
       my $to = {};
       for my $k (keys %$at) {
           next if $k =~ /^_/;
           next if $note->{$k};
           $to->{$k} = $at->{$k};
       }
       
       warn "Got $_" for grep { $_ !~ /^(t|y|c|sc)$/ } keys %$to;
       if (J.V) {
           saybl "=------ ".ki 2, $to;
           if (my $cM = to.sc.z) {
              saybl " M  ".$_->[0]."\t".ki $_->[2]."\t((( ".ki $_->[3] for @$cM;
              saybl "MMMM ".@$cM;
           }
       }
       
       acum $lv, 'Ec', $MM->($to);# unless $may;
       # so we add here locally ^
       # and 
       #sayyl sjson lv.Ec;# if j.l eq '/';
stwa: # STASHINGS
 - #c absolute # ORDER uglies
  - sz
  - 3.1
  - |
    my $si = length(C.s);
    ($v, my $lim) = split '/',$v;
    my $di = $v/$si;
    $di = $lim if $lim && $di > $lim;
    Gmeat(fsi=>$di);
    Gmeat(fsi=>1) if $di > 2;
    return;
    #        $fs = "font-size:$fs%;";
    #        if ($si > $tev) {
    #            $text = ($text=~/^(.{$tev})/s)[0];
    #        }
  - way: 1
 -
  - ab 
  - 3.3
  - |
    at.sc.ab = $v;
  - way: 1
 -
  - deco # splurge many, get this pipe sorted...
  - 3.2
  - |
    at.sc.css->{"text-decoration"} = "underline";
 -
  - is
  - 3.2
  - |
    my ($t,$z) = split ':', $v;
    $z ||= C.s;
    
    my $i = sum map { ord $_ } split '', $z;
    $i -= 9 until $i < 10;
    C.sc.hs = "${i}75";
  - way: 1
 -
  - mu
  - 3.2
  - |
    if ($v eq 'g') {
        C.s || die "nos : ".wdump 2, $C;
        C.s = Rw mugwu $d:C.s;
        C.sc.hs ||= "576";
    }
    else {
     die "how mu $v? C.s";
    }
  - way: 1
  
  
 -
  - poi # pointer-events
  - 3.2
  - |
    at.sc.css->{"pointer-events"} = ($v =~ /^([1ay])/ ? 'all' : 'none');
 -
  - at #
  - 3
  - |
     $at.>$_ = $v.>$_ for keys %$v;
 -
  - tag #
  - 3
  - |
     at.tag = $v;
 -
  - sha # it
  - 3
  - |
     my @m = split m/\s/, $v;
     $m[-1] = g.cole->($m[-1]);
     at.sc.css->{"text-shadow"} = sprintf '%dpx %dpx %dpx %s', @m;
 -
  - co # it
  - 3.3
  - |
    my $s = g.cole->($v);
    #sayyl "j.r co goes $v   => $s";
    at.sc.css->{"color"} = $s;
 -
  - hs # color: hsla
  - 3.3
  - |
    my $s = g.hsle->($v);
    #sayyl "j.r hs goes $v   => $s";
    at.sc.css->{"color"} = $s;
 - #c ground etc
  - zi 
  - 3
  - |
    at.sc.css->{"z-index"} = 0+$v;
 -
  - zig # it alley, primary, ground
  - 3
  - |
    at.sc.css->{"z-index"} = 0+($v-20);
 -
  - zie # suuuuuu, ether
  - 3
  - |
     at.sc.css->{"z-index"} = 0+($v-10);
 -
  - bgi # background image
  - 3.2
  - |
     at.sc.css->{"background-image"} = "url('$v')";
 -
  - bg # background something
  - 3.2
  - |
     at.sc.css->{"background"} = "$v";
 -
  - bgh # background hsla
  - 3.2
  - |
     at.sc.css->{"background-color"} = g.hsle->($v);
 -
  - fsi # it
  - 6.9
  - |
     at.sc.css.>font-size = int($v*100).'%';
 -
  - fs # it
  - 7
  - |
     $v *= 9;
     at.sc.css.>font-size = int($v).'%';
 -
  - fw # it
  - 7
  - |
    at.sc.css->{"font-weight"} = int($v*100);
 -
  - ws # it
  - 7
  - |
    if ($v eq 'p') { 
        $v = 'pre';
    }
    if ($v eq 'n') {
        $v = 'nowrap';
    }
    at.sc.css->{"white-space"} = $v;
 - #c filterszzzz weird style using com to agg.
  - opa # seetrhu
  - 3
  - |
     at.sc.css->{"opacity"} = $v;
 -
  - tro #
  - 3.6
  - |
    at.sc.css->{"transform-origin"} = $v;
 -
  - rad # radial tr
  - 3.6
  - |
    C.sc.tr.rotate = $v.'rad' if $v;
 -
  - scale # zzz tr
  - 3.6
  - |
    C.sc.tr.scale = $v;
 -
  - tr # filterszzzz weird style using com to agg.
  - 3.7
  - |
    at.sc.css->{"-webkit-transform"} = join' ', map {"$_($v->{$_})"} keys %$v;
 -
  - of
  - 3.7
  - |
    C.sc.css->{"-webkit-filter"} = join' ', map {"$_($v->{$_})"} keys %$v;
 -
  - blr # it
  - 3.6
  - |
    C.cs.of.blur = $v.'px';
 -
  - sat # it saturation
  - 3.6
  - |
    C.cs.of.saturate = $v;
 -
  - con # it contrast
  - 3.6
  - |
    C.cs.of.contrast = $v;
 -
  - bri # it bright
  - 3.6
  - |
    C.cs.of.brightness = $v;
 -
  - hue # it bright
  - 3.6
  - |
    C.cs.of->{'hue-rotate'} = $v.'deg';
 -
  - sep # it old
  - 3.6
  - |
    C.cs.of.sepia = $v;
 -
  - inv # it old
  - 3.6
  - |
    C.cs.of.invert = $v;
 -
  - gray # it old
  - 3.6
  - |
    C.cs.of.grayscale = $v;
 - #c limbic space
  - ls # it
  - 3
  - |
    C.sc.css->{"letter-spacing"} = g.empc->($v);
 -
  - lh # it
  - 3
  - |
    C.sc.css->{"line-height"} = g.empc->($v);
 -
  - ml # it
  - 3
  - |
    C.sc.css->{"margin-left"} = g.empc->($v);
 -
  - mr # it
  - 3
  - |
    C.sc.css->{"margin-right"} = g.empc->($v);
 -
  - mt # it
  - 3
  - |
    C.sc.css->{"margin-top"} = g.empc->($v);
 -
  - mb # it
  - 3
  - |
    C.sc.css->{"margin-bottom"} = g.empc->($v);
 -
  - m # margrin
  - 3
  - |
    C.sc.css->{margin} = $v;
 -
  - right # yep
  - 3.4
  - |
    C.sc.css->{right} = $v;
 -
  - left # yep
  - 3.4
  - |
    C.sc.css->{left} = $v;
 -
  - top # yep
  - 3.4
  - |
    C.sc.css->{top} = $v;
 -
  - bottom # yep
  - 3.4
  - |
    C.sc.css->{bottom} = $v;
 -
  - mw # y
  - 3.4
  - |
    C.sc.css->{"max-width"} = $v;
 -
  - mh # y
  - 3.4
  - |
    C.sc.css->{"max-height"} = $v;
 -
  - miw # y
  - 3.4
  - |
    C.sc.css->{"min-width"} = $v;
 -
  - width # y
  - 3.4
  - |
    C.sc.css->{"width"} = $v;
 -
  - height # y
  - 3.4
  - |
    C.sc.css->{"height"} = $v;
 -
  - over # y 
  - 3.4
  - |
    C.sc.css->{"overflow"} = $v;
 -
  - float # y 
  - 3.4
  - |
    C.sc.css->{"float"} = $v;
 -
  - bo # border
  - 3.4
  - |
    C.sc.css->{"border"} = $v;

