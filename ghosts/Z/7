
R_Jz:
 - K: geomo/sticks #c rejoin the pipelining - form style trance
   D:
    -
     - cts_V #
     - 5.3
     - |
       my $sc;
       for my $k (keys %{lv.sc}) {
           my $v = lv.sc->{$k};
           my $om = $1 if $k =~ s/(#.+)$//;
           sayre "j.r      ==== $k => $v";
           $sc->{$k}= $v;
       }
       
        #my @s = $X->{$tk}->($v, $tks, $com, $cs, $at, $lv, $J, $j);
       for my $ct (@{wJ.cts.V}) {
           next unless exists $sc->{ct.t};
           my $v = $sc->{ct.t};
           wJ.ctx.V->{ct.x}->($J,$j,$lv,$v,$sc,$at);
       }
       saybl "j.r   =------ ".join" ",@{at.css};
       
    - MZ: dorp:ctx_V
    - WZ: /flung
    - MZ: dorp:0 sticks:V
    - WZ: /stylat
    
 - K: ym/sticks #c
   D: |
     n.sc.ct = $v;
     n.sc->{"ct_${v}_args"} = '$J,$j,$lv,$v,$sc,$at';
stylat:
 - #
  - cm
  - 5.8
  - |
    my $wt = ejson {id=>at.id, value=>at.s};
    at.id || die;
    at.dig = sc.dig || die "no diggy";
    acum $at, Esc => " a\.cod($wt);";
    at.s = '';
 - #
  - pi
  - 5
  - |
     at.ishtml = 1;
 - #
  - lp
  - 5
  - |
     at.ishtml = 1;

 - #
  - ishtml
  - 5
  - |
     at.ishtml = 1;

 -
  - sf # has a way to $a the gp action within...
  - 5
  - |
    push @{at.css}, map { $R::f->{$_} || die "no style $_"} split '_', $v;
 -
  - css
  - 5
  - |
    $v = join ';', map{"$_:$v->{$_}"} sort keys %$v if ref $v;
    push @{at.css}, $v;
 -
  - id
  - 5
  - |
    at.id = $v;
 -
  - tt
  - 5
  - |
    at.title = $v;
 -
  - canvas
  - 5
  - |
    at.canvas = $v;
 -
  - nt
  - 5
  - |
    at.title = undef;
 -
  - type
  - 5.1
  - |
    at.type = $v;
    at.ishtml = 1;
    at.title = undef;
 -
  - tag
  - 5
  - |
    at.tag = $v;
 -
  - at
  - 5
  - |
    $v =~ /^(?:(\S+):)?(\S+)$/;
    $at->{$1} = $2;
 - #
  - atrp
  - 5
  - |
     at.rp = $v;
 -
  - path
  - 5
  - |
    # TODO compile J.ys
    # should get %idly if not lev/gp too
 -
  - origin
  - 5
  - |
    #
 -
  - waves
  - 5
  - |
    #
 -
  - pwar
  - 5
  - |
    #
 -
  - Joint
  - 5
  - |
    #
 -
  - idly
  - 5
  - |
    my $id = $H->mkuid;
    at.id && die "arl";
    at.id = $id;
    J.idyl->($J, $id, $j);
    #
flung: # func y
 - 
  - mktk # language expansion
  - 3
  - |
     my ($_tks, $name, $s) = @_;
     my @t = split ',', $s;
     my $t = {};
     for (@t) {
         my ($k, $v) = split ':', $_;
         $_tks->{$k}->{$name} = $v;
         # or rejoint another trip to $k if passed...
         #sayyl "mktk $name $k : $v";
     }
     return;
 -
  - cole # it
  - 3
  - |
    my $v = shift;
        my $h;
        (h.r, h.g, h.b, h.a) = ($1, $2, $3, $4)
                  if $v =~ /^(\w)(\w)(\w)(\w)?$/ || die "not cole: $v";
        
        if (defined h.a) {
           # do an rgba(255,255,255,1)
           for my $k (qw'r g b a') {
               my $e = $h->{$k};
               $e = "$e$e" if length $e == 1; # out of 255
               $h->{$k} = hex $e;
           }
           h.la = sprintf '%.2f', h.la / 255; # out of 1
           return "rgba(h.r,h.g,h.b,h.a)";
        }
        else {
           return sprintf "#%s%s%s", h.r, h.g, h.b;
        }
 -
  - hsle # ray lih, unhassley
  - 3
  - |
    my $v = shift;
        my $h;
        if ($v =~ /^(\S+) (\S+) (\S+)(?: (\S+))?$/) {
            (h.h, h.s, h.l, h.a) = ($1, $2, $3, $4);
        }
        elsif ($v =~ /^(\d+)\.(\d+)\.(\d+)(?:\.(\d+))?$/) {
            (h.h, h.s, h.l, h.a) = ('0.'.$1, '0.'.$2, '0.'.$3, '0.'.$4);
        }
        else {
            die "not hsle : $v";
        }
        h.h = h.h * 360 if h.h < 1;
        $h->{$_} = ($h->{$_}*100).'%' for 's','l';
        
        my $al = ", h.a" if defined h.a;
        "hsl".($al?'a':'')."(h.h, h.s, h.l$al)";
        # 1423
 -
  - empc # decide space unit TODO init soon
  - 3
  - |
    my $v = shift;
     $v .= 'em' if $v !~ /(%|em|px)/;
     $v =~ s/^-?0em$/0%/;
     $v;
stwa: # STASHINGS
 - 
  - jsc # some compression
  - 3
  - |
     '%jsc'=>$v
 -
  - argzs # some compression pattern
  - 3
  - |
     '%argzs'=>$v

 -
  - FLYING #
  - 3
  - |
    #warn "all these were flying: ".wdump $v;
    my @style;
    for my $lma (sort keys %$v) {
        my $lm = $v->{$lma};
        for my $com (sort keys %$lm) {
            push @style, '%'.$lma => $lm->{$com};
        }
    }
    @style;
 -
  - ab # absolute # ORDER uglies
  - 3.3
  - |
     $v = 'width:100%,height:100%' if $v eq '100';
     if ($v =~ /^.+:.+/) {
         X.mktk->($tks, abc => $v);
         $v = 1;
     }
     elsif ($v ne '1') {
         die "whatab:$v";
     }
     $v = "absolute" if $v eq '1';
     "position:$v";
 -
  - deco # splurge many, get this pipe sorted...
  - 3.2
  - |
     "text-decoration:underline";
 -
  - poi # pointer-events
  - 3.2
  - |
     "pointer-events:".($v =~ /^([1ay])/ ? 'all' : 'none');
 -
  - at #
  - 3
  - |
     my @ats;
     while (my ($k,$v) = each %$v) {
         push @ats, '%at:'.$k, $v;
     }
     @ats
 -
  - tag #
  - 3
  - |
     '%tag' => $v
 -
  - sha # it
  - 3
  - |
     my @m = split m/\s/, $v;
     $m[-1] = X.cole->($m[-1]);
     sprintf 'text-shadow:%dpx %dpx %dpx %s', @m;
 -
  - co # it
  - 3
  - |
     "color:".X.cole->($v)
 -
  - hs # color: hsla
  - 3
  - |
     "color:".X.hsle->($v)
 -
  - zi #c ground etc
  - 3
  - |
     "z-index:".$v
 -
  - zig # it alley, primary, ground
  - 3
  - |
     "z-index:".($v-20)
 -
  - zie # suuuuuu, ether
  - 3
  - |
     "z-index:".($v-10)
 -
  - bgi # background image
  - 3.2
  - |
     "background-image:url('$v')"
 -
  - bg # background something
  - 3.2
  - |
     "background:$v"
 -
  - bgh # background hsla
  - 3.2
  - |
     "background-color:".X.hsle->($v)
 -
  - fs # it
  - 3
  - |
     $v *= 9;
     'font-size:'.int($v).'%';
 -
  - fw # it
  - 3.5
  - |
     'font-weight:'.int($v*100);
 -
  - ws # it
  - 3
  - |
     $v = $v =~ /p/ ? 'pre' : $v =~ /n/ ? 'nowrap' : '';
     return 'white-space:'.$v if $v;
 -
  - opa # seetrhu
  - 3
  - |
     "opacity:$v"
 -
  - tr # filterszzzz weird style using com to agg.
  - 3.7
  - |
    '-webkit-transform:'.join' ', map {"$_($v->{$_})"} keys %$v;
 -
  - tro #
  - 3.6
  - |
    'transform-origin:'.$v
 -
  - rad # radial tr
  - 3.6
  - |
     tks.tr.rad.rotate = $v.'rad' if $v;
     return;
 - #c filterszzzz weird style using com to agg.
  - fl
  - 3.7
  - |
    '-webkit-filter:'.join' ', map {"$_($v->{$_})"} keys %$v;
 -
  - blr # it
  - 3.6
  - |
     cs.of.blur = $v.'px';
     return
 -
  - sat # it saturation
  - 3.6
  - |
     cs.of.saturate = $v;
     return
 -
  - con # it contrast
  - 3.6
  - |
     cs.of.contrast = $v;
     return
 -
  - bri # it bright
  - 3.6
  - |
     cs.of.brightness = $v;
     return
 -
  - hue # it bright
  - 3.6
  - |
     cs.of->{'hue-rotate'} = $v.'deg';
     return
 -
  - sep # it old
  - 3.6
  - |
     cs.of.sepia = $v;
     return
 -
  - inv # it old
  - 3.6
  - |
     cs.of.invert = $v;
     return
 -
  - gray # it old
  - 3.6
  - |
     cs.of.grayscale = $v;
     return
 - #c limbic space
  - ls # it
  - 3
  - |
     "letter-spacing:".X.empc->($v);
 -
  - ml # it
  - 3
  - |
     "margin-left:".X.empc->($v);
 -
  - mr # it
  - 3
  - |
     "margin-right:".X.empc->($v);
 -
  - mt # it
  - 3
  - |
     "margin-top:".X.empc->($v);
 -
  - mb # it
  - 3
  - |
     "margin-bottom:".X.empc->($v);
 -
  - m # margrin
  - 3
  - |
     "margin:$v";
 -
  - right # yep
  - 3.4
  - |
     "right:$v";
 -
  - left # yep
  - 3.4
  - |
     "left:$v"
 -
  - top # yep
  - 3.4
  - |
     "top:$v"
 -
  - bottom # yep
  - 3.4
  - |
     "bottom:$v"
 -
  - mw # y
  - 3.4
  - |
     "max-width:$v"
 -
  - mh # y
  - 3.4
  - |
     "max-height:$v"
 -
  - miw # y
  - 3.4
  - |
     "min-width:$v"
 -
  - width # y
  - 3.4
  - |
     "width:$v"
 -
  - height # y
  - 3.4
  - |
     "height:$v"
 -
  - over # y 
  - 3.4
  - |
     "overflow:$v"
 -
  - float # y 
  - 3.4
  - |
     "float:$v"
 -
  - bo # border
  - 3.4
  - |
     "border:$v"

