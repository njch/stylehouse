
R_Jz:

 - K: shv #c  and to compile J5 rounds ahead
   n_D:
     yJ: |
       'shv quigeo'
     curves: | 
       spun 0 0.15
       zoom 0 2
       y    0  0
       x    0  0.33
       curve 0 -0.4
     defon: |
       #twang 0.1 Z/2 
       #twong 0.1 Z/3
     up: | # if the in up, pha wakeups out - all response to editing
       J.cv = 20;
       J.mody = 'ano';
       my $coi = Rw pha $J $k=shvs;
       
       my $oJ = Rw oJ $J je;
       if (my $i = ar.i) {
          oJn(i.name, 0.3, {s=>$i,J=>$i});
       }
       
       my $vs = Rw tyv $J:oJ;
       my $M=[];
       for my $lv (@$vs) {
           my $j = lv.j;
           next if j.s.dead;
           sayre "GOT ".gp j.s;
           Mn(j.l,'',j.l,{J=>j.s,enid=>j.s.id});
       }
       J.V=1;
       #die wdump $M;
       Rw om/bal $J $oM:M $in=0.001 $out=0.9;
       J.V=0;
       
       coi.exactl->();
       
       
       Rw oJ $J geo &up $noesc=1;
       
       
       $vs = Rw tyv $J;
       for my $lv (@$vs) {
        saygr " lv.j.r      => ".ki lv.sc;
       }
        
       Rw chuv $J;   
 - K: chuv/flows/chov #c
   D: |
     #MZ pa:geomo
     flow 1
     nesting 4
     stiz 3
     sticks 5
     stool 5
     sharp 5
     #etcs 6
     outs 7
 - K: shuv/flows/geomo #c
   D: |
     flow 1
     nesting 4
     stiz 3
     sticks 5
     stool 5
     sharp 5
     etcs 6
     outs 7
 - K: chov/flow #c
   D: |
     # 1
     G.oin.idJy->{J.id} ||= $J;
     
     # 3 spewing two-step
     my $vs = Rw tyv $J;
     my @s;
     
     # 3.9
     for my $lv (@$vs) {
         push @s, $lv;
         my $j = lv.j;
         #saygr wdump 2, lv.sc;
         die "reffy j.s in j.l ON J.name".wdump 3, [ar.ip, $j] if ref j.s;
         
         # 4 #
         my $coi = Rw pha $J:aJ $k:j.r;
         coi.qui = 1;
         my $xat = do {
             Rw lv_same $lv $x:coi $J:aJ;
         } if aJ.bb->{"j.l%at\t".j.cv} && j.l !~ /\//;
         
         
         my $at;
         my $pat;
         my $plv;
         if (!$xat) {
             $at = {};
             # 5.2
             at.s = j.s;
             # may be creating, overhead thought
             at.__ajid1 = aj.id;
             
             # 5.4
         }
         # 5.78 at beam
         $pat = aJ.bb->{"j.l%at\t".j.cv};
         $plv = aJ.bb->{"j.l%lv\t".j.cv};
         if (!$xat) {
             aJ.bb->{"j.l%lv\t".j.cv} = $lv;
             aJ.bb->{"j.l%at\t".j.cv} = $at;
             
             coi.exactl->();
         }
         else {
             aJ.bb->{"j.l%lv\t".j.cv} = $lv;
             $at = $pat;
         }
         # 5.8
         # gets self aware in waves
         # above can now trust lvs to have iter-sane E{s,}c[] impulses / same s
         at.__ajid2 = aj.id;
         lv.at = $at;
         #die wdump $X;#$F[0]->{bab}."";
         
         # 7.9 # heaps ^ all of at outwardsing
     }
     # 8 check lv up cover
     if (J.yy.may.noroot) {
         die 'noroot ag has s'.wdump($_) for grep {_.s} @s;
         aj.c = [map{@{_.Ec||[]}}@s];
         aj.sc = [map{@{_.Esc||[]}}@s];
     }
     else {
         my $lv = aJ.bb->{"/%lv\t0.9"};
         aj.s = lv.s;
         delete aj.s if lv.scon; # no repeat emit
         aj.c = lv.Ec || [];
         aj.sc = lv.Esc || [];
     }
     # 8.8
     if (!ar.catj) {
         Rw Em $aj;
     }
     # 9
     $aj
     
 - K: chov/sticks #c rejoin the pipelining - form style trance
   D:
    -
     - STYCKS #
     - 5.3
     - |
       my $sc;
       sayyl "STICKS :   j.r    ".join' ', sort keys %{lv.sc};
       for my $k (keys  %{lv.sc}) {
           my $v = lv.sc->{$k};
           my $om = $1 if $k =~ s/(#.+)$//;
           $sc->{$k}= $v;
       }
       for my $ct (@{wJ.cts.Y}) {
           next unless exists $sc->{ct.t};
           my $v = $sc->{ct.t};
           #sayyl "Y j.r ct.t $v";
           wJ.ctx.Y->{ct.x}->($J,$j,$lv,$v,$sc,$at,$aj,$aJ);
           die "j.r ct.t $v  make css" if ref at.css eq 'ARRAY';
       }
       for my $ct (@{wJ.cts.V}) {
           next unless exists $sc->{ct.t};
           my $v = $sc->{ct.t};
           #saygr "V j.r ct.t $v";
           wJ.ctx.V->{ct.x}->($J,$j,$lv,$v,$sc,$at,$aj,$aJ);
           die "j.r ct.t $v  make css" if ref at.css eq 'ARRAY';
       }
       saybl "=------ ".ki 2, $at;
 - K: chov/sharp #c
   D:
   - MZ: sticks:V
   
   - 
    - enid
    - 5.1 
    - |
      at.id = $v;
      at.c.nobody = 1;
    - way: 1
   -
    - css
    - 5
    - |
      $v = join ';', map{"$_:$v->{$_}"} sort keys %$v if ref $v eq 'HASH';
      for my $set (split ';', $v) {
          my ($k,$v) = split ':', $set;
          at.sc.css->{$k} = $v;
      }
    - way: 1
   - WZ: geomo/shrap
 - K: chov/outs #c switchapol val shifter, 7 hoisting to comp, find selv
   D: 
    -
     - Esc
     - 6.4
     - |
       my $c = at.c ||= {};
       my $note = {};
       my $not = sub {
           my $k = shift;
           $note->{$k} = 1;
           return $at->{$k};
       };
       if (at.Esc) {
           #map { acum $lv, 'Esc', $_ } @{at.Esc};
       }
       if (c.nobody) {
           c.nobody = $not->('id');
           $not->($_) for 's', 'ishtml';
       }
       else {
           my $tag = not&tag || do {
             my $ts = j.l;
             $ts =~ s/[^\w]/Ã±/sg;
             "$ts"
           };
           $tag = "Z$tag" if $tag !~ /^[a-z]/i;
           at.t = "$tag";
           
           at.name = "Tom";
           not&name;
           
           my $s = not&s;
           $s = encode_entities($s) if not&ishtml;
           c.s = $s;
           
           die 'attr $something>' if at.rp;
           my $of = {map{$_=>1}qw's ishtml t y c sc Esc Ec id css tag rp'};
           
           c.attr->{$_} = $at->{$_} for 
               sort grep {!/^_/ && !$of->{$_} } keys %$at;
           
           c.el = not&id;
           c.M = not&Esc;
           
           #lv.scon = 1 if lv.s eq plv.s;

           if (pat.id) { # S-C
               lv.scon = 1 if lv.s eq plv.s;
               # need to relax the _jointed, cannot find?
               #say "j.r      pat __jointed: ". wdump 2, plv.__jointed;
               # acum $lv, 'Ec', jsq ' $(%s).replaceWith(%s);', '#'.pat.id, at.s;
           }
           # here hangs loose, we would want to conduct at.c/sc business cleanly
       }
       my $to = {};
       for my $k (keys %$at) {
           next if $k =~ /^_/;
           next if $note->{$k};
           $to->{$k} = $at->{$k};
       }
       warn "Got $_" for grep { $_ !~ /^(t|y|c|sc)$/ } keys %$to;
       saybl ord('a').chr (26 + ord 1);
       acum $lv, 'Ec', $to;
       sayyl wdump 5, [lv.Ec, lv.Esc];
 - K: scr/nobody #c
   D:
   - MZ: cc:jsc
   -
     - o #
     - 1
     - args: Wid, K, C
     - |
       var W = a.WW(Wid);
       var A = W.A;
       
       C = a.inC(C);
       
       var G = a;
       // should be receiver, W.G, auto locals + uni
       // looks in W.G, W.G.incs, a
       // passes ACGT
       var T = {};
       
       a[K](A, C, G, T);
   -
     - inC #
     - 1
     - args: C
     - |
       if (C.constructor == 'Array') {
           if (C.length !== 4)
               a.er("nolly", C);
           C = {t:C[0], y:C[1], c:C[2], sc:C[3]};
       }
       if (typeof C == 'string') {
           C = {c: {s: C}};
       }
       C
   -
    - el # A,C,G,T
    - 3
    - |
      a.m('hi');
 - K: geomo/sticks #c rejoin the pipelining - form style trance
   D:
    -
     - cts_V #
     - 5.3
     - |
       my $sc;
       sayyl "STICKS :   j.r    ".join' ', sort keys %{lv.sc};
       for my $k (keys  %{lv.sc}) {
           my $v = lv.sc->{$k};
           my $om = $1 if $k =~ s/(#.+)$//;
           $sc->{$k}= $v;
       }
       for my $ct (@{wJ.cts.Y}) {
           next unless exists $sc->{ct.t};
           my $v = $sc->{ct.t};
           wJ.ctx.Y->{ct.x}->($J,$j,$lv,$v,$sc,$at);
       }
       for my $ct (@{wJ.cts.V}) {
           next unless exists $sc->{ct.t};
           my $v = $sc->{ct.t};
           wJ.ctx.V->{ct.x}->($J,$j,$lv,$v,$sc,$at);
       }
       saybl "=------ ".ki 2, $at;

    - 
     - uxooo
     - 6.33
     - |
       if (my $cs = at.cs) {
           warn "CS: ".ki $cs;
           if (%$cs) {
               at.style .= join '',
                   map {"$_:$cs->{$_};"}sort keys %$cs;
               #acum $at, 'Esc', " $js;";#die "Movovie $v". wdump 2, at.cs;
           }
       }
     - way: 1
 - K: ym/sticks #c
   D: |
     n.sc.ct = $v;
     n.sc->{"ct_${v}_args"} = '$J,$j,$lv,$v,$sc,$at,$aj,$aJ';
 - K: geomo/sharp #c
   D:
   - MZ: sticks:V
   - 
    - uxmv
    - 5.1 
    - |
      my $cs = delete at.cs;
      my $js = join '.',
      "\$('#$v')", map {"css('$_','$cs->{$_}')"}sort keys %$cs;
      acum $at, 'Esc', " $js;";
    - way: 1
   -
    - css
    - 5
    - |
      $v = join ';', map{"$_:$v->{$_}"} sort keys %$v if ref $v eq 'HASH';
      for my $set (split ';', $v) {
          my ($k,$v) = split ':', $set;
          push @{at.css}, "$k:$v;";
          #at.cs->{$k} = $v;
      }
    - way: 1
   - WZ: geomo/shrap
 - K: geomo/shrap #c
   D:
   - #
    - cm
    - 5.8
    - |
      my $wt = ejson {id=>at.id, value=>at.s};
      at.id || die;
      at.dig = sc.dig || die "no diggy";
      acum $at, Esc => " a\.cod($wt);";
      at.s = '';
   - #
    - J
    - 5
    - |
       at.ishtml = 1;
   - #
    - pi
    - 5
    - |
       at.ishtml = 1;
   - #
    - lp
    - 5
    - |
       at.ishtml = 1;

   - #
    - ishtml
    - 5
    - |
       at.ishtml = 1;
   -
    - id
    - 5
    - |
      at.id = $v;
   -
    - tt
    - 5
    - |
      at.title = $v;
   -
    - canvas
    - 5
    - |
      at.canvas = $v;
   -
    - nt
    - 5
    - |
      at.title = undef;
   -
    - type
    - 5.1
    - |
      at.type = $v;
      at.ishtml = 1;
      at.title = undef;
   -
    - tag
    - 5
    - |
      at.tag = $v;
   -
    - at
    - 5
    - |
      $v =~ /^(?:(\S+):)?(\S+)$/;
      $at->{$1} = $2;
   - #
    - atrp
    - 5
    - |
       at.rp = $v;
   -
    - path
    - 5
    - |
      # TODO compile J.ys
      # should get %idly if not lev/gp too
   -
    - origin
    - 5
    - |
      #
   -
    - waves
    - 5
    - |
      #
   -
    - pwar
    - 5
    - |
      #
   -
    - Joint
    - 5
    - |
      #
   -
    - idly
    - 5
    - |
      my $id = mkuid();
      at.id && die "arl";
      at.id = $id;
      J.idyl->($J, $id, $j);
      #

    
 - K: geomo/stiz #c
   D:
     - MZ: sticks:Y
     -
      - geo
      - 3.2
      - |
        at.sc.geo = $v;
     -
      - ab # absolute # ORDER uglies
      - 3.3
      - |
        sc.css.position = 'absolute';
        sc.css.width = '100%';
        sc.css.height = '100%';
     -
      - left # yep
      - 3.4
      - |
        sc.css.left = $v;
     -
      - top # yep
      - 3.4
      - |
        sc.css.top = $v;
     -
      - tr # filterszzzz weird style using com to agg.
      - 3.7
      - |
        sc.css->{'-webkit-transform'} = join' ', map {"$_($v->{$_})"} keys %$v;
     -
      - tro #
      - 3.6
      - |
        sc.css->{'transform-origin'} = $v;
     -
      - rad # radial tr
      - 3.6
      - |
        sc.tr.rotate = $v.'rad' if $v;
         return;
stwa: # STASHINGS
 -
  - ab # absolute # ORDER uglies
  - 3.3
  - |
     $v = 'width:100%,height:100%' if $v eq '100';
     if ($v =~ /^.+:.+/) {
         X.mktk->($tks, abc => $v);
         $v = 1;
     }
     elsif ($v ne '1') {
         die "whatab:$v";
     }
     $v = "absolute" if $v eq '1';
     "position:$v";
 -
  - deco # splurge many, get this pipe sorted...
  - 3.2
  - |
     "text-decoration:underline";
 -
  - poi # pointer-events
  - 3.2
  - |
     "pointer-events:".($v =~ /^([1ay])/ ? 'all' : 'none');
 -
  - at #
  - 3
  - |
     my @ats;
     while (my ($k,$v) = each %$v) {
         push @ats, '%at:'.$k, $v;
     }
     @ats
 -
  - tag #
  - 3
  - |
     '%tag' => $v
 -
  - sha # it
  - 3
  - |
     my @m = split m/\s/, $v;
     $m[-1] = X.cole->($m[-1]);
     sprintf 'text-shadow:%dpx %dpx %dpx %s', @m;
 -
  - co # it
  - 3
  - |
     "color:".X.cole->($v)
 -
  - hs # color: hsla
  - 3
  - |
     "color:".X.hsle->($v)
 -
  - zi #c ground etc
  - 3
  - |
     "z-index:".$v
 -
  - zig # it alley, primary, ground
  - 3
  - |
     "z-index:".($v-20)
 -
  - zie # suuuuuu, ether
  - 3
  - |
     "z-index:".($v-10)
 -
  - bgi # background image
  - 3.2
  - |
     "background-image:url('$v')"
 -
  - bg # background something
  - 3.2
  - |
     "background:$v"
 -
  - bgh # background hsla
  - 3.2
  - |
     "background-color:".X.hsle->($v)
 -
  - fs # it
  - 3
  - |
     $v *= 9;
     'font-size:'.int($v).'%';
 -
  - fw # it
  - 3.5
  - |
     'font-weight:'.int($v*100);
 -
  - ws # it
  - 3
  - |
     $v = $v =~ /p/ ? 'pre' : $v =~ /n/ ? 'nowrap' : '';
     return 'white-space:'.$v if $v;
 -
  - opa # seetrhu
  - 3
  - |
     "opacity:$v"
 -
  - tr # filterszzzz weird style using com to agg.
  - 3.7
  - |
    '-webkit-transform:'.join' ', map {"$_($v->{$_})"} keys %$v;
 -
  - tro #
  - 3.6
  - |
    'transform-origin:'.$v
 -
  - rad # radial tr
  - 3.6
  - |
     tks.tr.rad.rotate = $v.'rad' if $v;
     return;
 - #c filterszzzz weird style using com to agg.
  - fl
  - 3.7
  - |
    '-webkit-filter:'.join' ', map {"$_($v->{$_})"} keys %$v;
 -
  - blr # it
  - 3.6
  - |
     cs.of.blur = $v.'px';
     return
 -
  - sat # it saturation
  - 3.6
  - |
     cs.of.saturate = $v;
     return
 -
  - con # it contrast
  - 3.6
  - |
     cs.of.contrast = $v;
     return
 -
  - bri # it bright
  - 3.6
  - |
     cs.of.brightness = $v;
     return
 -
  - hue # it bright
  - 3.6
  - |
     cs.of->{'hue-rotate'} = $v.'deg';
     return
 -
  - sep # it old
  - 3.6
  - |
     cs.of.sepia = $v;
     return
 -
  - inv # it old
  - 3.6
  - |
     cs.of.invert = $v;
     return
 -
  - gray # it old
  - 3.6
  - |
     cs.of.grayscale = $v;
     return
 - #c limbic space
  - ls # it
  - 3
  - |
     "letter-spacing:".X.empc->($v);
 -
  - ml # it
  - 3
  - |
     "margin-left:".X.empc->($v);
 -
  - mr # it
  - 3
  - |
     "margin-right:".X.empc->($v);
 -
  - mt # it
  - 3
  - |
     "margin-top:".X.empc->($v);
 -
  - mb # it
  - 3
  - |
     "margin-bottom:".X.empc->($v);
 -
  - m # margrin
  - 3
  - |
     "margin:$v";
 -
  - right # yep
  - 3.4
  - |
     "right:$v";
 -
  - left # yep
  - 3.4
  - |
     "left:$v"
 -
  - top # yep
  - 3.4
  - |
     "top:$v"
 -
  - bottom # yep
  - 3.4
  - |
     "bottom:$v"
 -
  - mw # y
  - 3.4
  - |
     "max-width:$v"
 -
  - mh # y
  - 3.4
  - |
     "max-height:$v"
 -
  - miw # y
  - 3.4
  - |
     "min-width:$v"
 -
  - width # y
  - 3.4
  - |
     "width:$v"
 -
  - height # y
  - 3.4
  - |
     "height:$v"
 -
  - over # y 
  - 3.4
  - |
     "overflow:$v"
 -
  - float # y 
  - 3.4
  - |
     "float:$v"
 -
  - bo # border
  - 3.4
  - |
     "border:$v"

