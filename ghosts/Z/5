R_Jz:

 - K: flow #c K-flow
   D: |
     my $name = $m->[0];
     my $oJ = Rw oJ $J $name $style=fl;
     Rw up $J:oJ;
 - K: fl #c stitch at/cs solvents via $oJ/flows/M(Carbony patchbay)
   n_D:
     yJ: |
       'fl'
     up: |
       # later shoot out only changed words
       my $h = slm 8, dig ejson[J.Jo.style,J.name];
       
       my $oJ = G.drop.flows->{$h} ||= Rw fl/op + $h;
       
       saybl "Flop: ".F_delta;
       
       Rw oJ.hw/flow $J:J.Jo $fJ:J $oJ;
       saybl "Flow: ".F_delta;
       #   enter ^ for ^ bits ^ loaf ^
       # (lost bits)
     op: |
       # 
       Rw thy $J:J.Jo $oJ:J flows/J.name;
       # where to suck localness ^
       my $oJ;
       oJ.hw = "fl/h/$h";
       Rw suJ $J:oJ;
       
       my $vs = Rw tyv $J;
       @$vs||die;
       
       my $path;
       
       for my $lv (@$vs) { 
           my $j = lv.j;
           sayre "Stitchup j.r    ".ki lv.sc;
           
           my $Z = Rw muck - J.name/j.l;
           
           for my $k (sort keys %$Z) {
               my $s = $Z->{$k};
               
               $path = j.l if j.cv == 0.1;
               
               #say " *  $k   ".slim 40, $s;
               if (ref $s eq 'ARRAY') {
                   die 'mod styley into j.l, sc inherit';
               }
               elsif (ref $s eq 'HASH') {
                   die 'possible lma fire...'
               }
               else {
                   ref $s && die $s;
                   !$path && die "noapth";
                   my $c = {};
                   c.K = j.l;
                   c.v = j.cv;
                   c.s = $s;
                   c.sc = lv.sc;
                   c.sc.com ||= "# c.K c.v";
                   
                   Rw Nucleoues $c $path $oJ:J $J:oJ;
               }
           }
       }
       
       my $coms = {};
       my $wtf = Rw concat $J:oJ $coms;
       
       my $real = Rw wtfity $wtf;
       
       oJ.way = {};
       for my $pin (sort keys %$real) {
           my $n = $real->{$pin};
           Rw loadup $u:oJ.way $pin $n;
       }
       Rw loadup $u:R.way.hooks $pin:oJ.hw $n:oJ.way;
       
       $oJ
 - K: wtfity #c
   D: |
     my $real = {};
     
     for my $l (sort keys %$wtf) {
         my $cvs = $wtf->{$l};
         
         for my $cvit (sort keys %$cvs) {
             my $v = $cvs->{$cvit};
             
             my $type = G.drop.conv->($cvit);
             # con cvit # make zp(1) to round zero point numbers to 1, etc
             
             $v = join "\n", @$v;        # # <<<<<<<
             
             if ($type eq 'YIN') {
                 $real->{$l} = $v;
             }
             else {
                 $real->{$l} || die;
                 $real->{$l} =~ s/(# $type.*?)$/$1\n$v/sm
                    
                    || die "no $type in $l ...";
             }
         }
     }
     
     $real
       
 - K: concat #c tlv -> wtf.$l.$cvit [ j.s
   D: |
       # shove togeth modn
       # get a cv sorter  that puts 3 > 32, since 3 is 3 all the way down > 3232323...
       # tesalation
       my $vs = Rw tlv $J;
       # ^ hash styles, things are l+com, like $tks
       my $wtf;
       for my $lv (@$vs) {
           my $j = lv.j;
           die if !%$j;
           
           lv.sc && die "wop";
           
           acum ar.coms, j.cv => j.com if ar.coms;
           
           my $was = $wtf->{j.l} ||= {};
           
           acum $was, G.drop.vonc->(j.cv), j.s;
           # aggs to wanted dp, fractionated in as the src wants, in the order of tlvness
           # <<<<<<< cv collapse unto elements #? rel src to round cv...
       }
       $wtf
 - K: loadup #c
   D: |
     my $pin = ar.p||ar.pin;
     my $ac = join'',map{"{$_"}split'/',$pin;
     $R->loadup($u, $ac, $n);
     
 - K: Carbonjour #c 3ish
   D: |
       #$p .= '(#*)?' if $p =~ /^C /;
       #my $tw = Rw fund $p;
       
       my $J = {};
       Rw suJ $J;
       
       my $p = "$the/el/*";
       my $ty = Rw huck $p;
       $ty = {map{
            my $type = $1 if /el\/(.+)$/ || die;
            my $an = $ty->{$_};
            die if @$an > 1;
            $type => $an->[0];
       }keys %$ty};
       
       
       for my $file (sort keys %$tw) {
           my $Cs = $tw->{$file};
           my $coi = Rw pha $J $k:file;
           
           for my $c (@$Cs) {
               #die wdump $c if ref $c eq 'HASH' && (c.MZ || c.K eq 'MZ');
               # occasional c.MZ for things that always want in...
               # homex ty, local modulation, the radio
               # some carbon fits
               # also from $the/el
               
               if (ref $c eq 'HASH') {
                   my @wsy = grep {m/\S\s\S/} keys %$c;
                   for my $zk (@wsy) {
                       my $D = $c->{$zk};
                       my ($k, $v) = split m/\s/, $zk;
                       #die "$k ne $the      $path" if $k ne $the; # the redund
                       c.v ||= $v;
                       c.s = $D;
                       c.sc.com = "# $zk @ c.K  ";

                       Rw Nucleoues $file $ty $c $the $path $J;
                   }
               }
               elsif (ref $c eq 'ARRAY') {
                   my $n = {};
                   (n.K, n.v, n.s, n.sc) = @$c;
                   n.sc.com ||= "# n.K n.v";
                   
                   Rw Nucleoues $file $ty $c:n $the $path $J;
               }
               else {
                   die wdump $c;
               }
           }
           coi.end->();
       }
       $J
 - K: Nucleoues #c
   D: |
          my (@l,@lr,@r);
          c.K || die;
          c.v ||= 3;
          c.v += 0;
          
          my $ome = c.K; # as uncompressed in the bb key? wtf if K dup
          
          die c.v if c.v !~ /^\d/;

          # if for c.cs, for implant condits # sche
          my $cv = c.v;
          my $D = c.s;
          my $type = G.drop.conv->($cv);
          # z downgrasp (ty above) self if MZ
          my $sc;
          $sc = c.sc.MZ if c.sc && c.sc.MZ;
          my $ty = {};
          $sc ||= $ty->{$type};
          $sc ||= {};
          $sc = {%$sc, %{c.sc}} if c.sc;
          c.sc = $sc;
          
          # per $path if maybe ?? emberd whatsits
          # some special K of c may have meta for this too
          
               if (my $sub = sc.subhash) {
                   unshift @l, "G\.drop\.$path\.$sub\.c.K = sub {";
                   
                   my $args = '$v,$tks,$'.$sub;
                   
                   if (my $arp = sc.subhash_X_arp) {
                       $args .= ",$arp";
                   }
                   push @lr, '    my ('.$args.') = @_;'; # gets $X, etc
                   $D = ind '     ', $D;
                   push @r, '};';
                   if (my $list = sc.droplist) {
                       push @r, "push \@{G\.drop\.$path\.$list}, 'c.K';"; 
                       J bz ${path}_$sub#rese$list 1 "G\.drop\.$path\.$list = [];"
                   }
                   my $haD = join "\n", (sc.com||"#!?"), @l, @lr, $D, @r;
                   @l = (); @lr = (); @r = ();
                   
                   J.bz->("${path}_$sub#rese\t1", "G\.drop\.$path\.$sub = {};");
                   J.bz->("${path}_$sub#$ome\t$cv", $haD);
                   J.bz->("${path}_$sub#return\t9", "G\.drop\.$path\.$sub;");
                   J.bz->("$path#upsubhash-$sub\t1",
                     "my \$$sub = G\.drop\.$path\.$sub ||= Rw ${path}_$sub;");
                     
                   return; #
               }
          
          # see twisty ops in lightcones
          # could resolve curve embeddings like this
          # same in bush of stuff to cv out
          # cv in
          
          if (my $cs = sc.qmco) {
              push @l, ':', "\$tk eq 'c.K' ? do {";
              if (my $sub = sc.subhash) {
                  $D = "G\.drop\.$path\.$sub\.c.K->(\$v, \$tks)";
              }
              $D = ind '     ', $D;
              push @r, '}';
          }
          
          # if (sc.this) { DO } +
               if (my $cs = sc.csfrm) {
                   $cs = c.K if $cs eq 'cK';
                   sc.com .= "# cs=$cs  ";
                   unshift @l, "if (exists c\.$cs) {"
                       ."\n    my \$cs = c\.$cs;";
                   $D = ind '     ', $D;
                   push @r, '}';
               }
                
               if ($type eq 'TRAVEL') {
                   # lets D
                   J.bz->("c.K\t1", $D);
                   # dup pha check^
                   #die ki $sc;
                   my $d = {%$c};
                   delete d.s;
                   acum $J, tvs => $d;
                   #die wdump [$path, $ome, $cv, c.K, $sc, $type];
                   return;
               }
               
               $D = join "\n", (sc.com||"#!?"), @l, @lr, $D, @r;
               J.bz->("$path#$ome\t$cv", $D);

