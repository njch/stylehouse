R_Jz:
 - K: awm #c 
   n_D:
     yJ: |
       'awm clw gui heag'
     up: |
       my $coi = Rw pha $J $k=jo;
       
       Jn(',',0.9,',');
       Rw suck + */upl $V=1;
       
       
       my $M=[];
       Rw the + on $M;
       sayyl wdump $M;
       Jn('hihi',{o=>$M}) if @$M;
       say "comat ".F_delta;
       
       coi.exactl->(); 
       
       
 - K: gui #c
   n_D:
     yJ: |
       J.cv = 20;
       J.most.mody = 'ano';
       J.most.eo = 'chuv';
       'gui quigeo' 
     out: |
       #sayyl "gui GGEO OUTING J.name";
       Rw oJ $J geo &up $noesc=1;
       Rw chuv;
 - K: shv #c  and to compile J5 rounds ahead
   n_D:
     yJ: |
       'shv gui uppy waz nohead quiet'
     curves: | 
       spun 0 0
       zoom 0 1.2
       y    0  0
       x    0  0.15
       curve 0 -0.2
       curve 0.4 0.4
       spin 0.3 2
     M: | # if the in up, pha wakeups out - all response to editing
       #J.mody = 'mani';
       #J.V = 1;
       my $oJ = Rw oJ $J je;
       if (my $i = ar.i || ar.aj.J) {
          oJn(i.name, 0.3, {J=>$i});
       }
       my $vs = Rw tyv $J:oJ;
       for my $lv (@$vs) {
           my $j = lv.j;
           my $oJ = lv.sc.J||die wdump 2, $lv;
           next if oJ.dead;
           #J.V = 1;
           Mn(j.l,'',"vv j.l",{J=>$oJ,enid=>oJ.id,nspc=>0.4});
       }
 - K: heag #c
   n_D:
     yJ: |
       'headi'
     up: |
       Rw Jhead;
 - K: zoc #c
   D: |
     Rw exprob;
     Rw loD;
     Rw zurc;
 - K: zurc #c
   D: |
     Rw newwave
     || do {
         Rw zoybracken;
         Rw fresh_init;
     };
     
     
 - K: loD #c
   D: |
     delete G.drop;
     Rw loadc $l=w/c;
     Rw lodname;
 - K: loadc #c
   D: |
     my $l = ar.l || 'w/c';
     $l =~ s/\/*$/\//;
     my @f = map{chomp$_;$_}`find $l -type f`;
     @f || die "no $l";
     sayyl "loadc: $l : @f";
     for my $file (@f) {
         my $m = Rw Loadc $file;
         for my $p (keys %$m) {
             my $n = $m->{$p};
             my $u = $R ne $G ? R.way.hooks : G.way;
             Rw loadup $u $p $n;
         }
     }
 - K: Loadc #c
   D: |
     my $s = read_file($file);
     saybl "Loading $file";
     my $e = eval { Load($s); };
     die join"\n","ERRRSYCK $file",(split"\n",$s)[$1-3..$1+3],'',$@ if $@ =~ /Syck parser \(line (\d+),/;
     $e
 - K: lodname #c
   D: |
     my $st = Rw wuck - lod/H.name;
     for my $v (values %$st) {
         for my $p (keys %$v) {
             my $n = $v->{$p};
             Rw loadup $u:G.way $p $n;
         }  
     }  
     
 - K: wo1 #c 
   n_D:
     yJ: |
       'awm'
     on: |
       #won 0.1 eye/fug {ou:eye}
       won 0.1 g/c {ou:eye}
     upl: |
       
 - K: wam #c 
   n_D:
     yJ: |
       'awm zipl'
     on: |
       #twzng 0.1 w/c {ou:eye}
       tweg 0.1 w/c {ou:eye}
       #twzng 0.5 J/2 {dir:ghosts,ou:file}
     
 - K: wut #c 
   n_D:
     yJ: |
       'awm'
     upl: |
       J.iM = ar.M if ar.M;
       J.V = 1;
       Jn('hihi',{o=>J.iM}) if J.iM;
       J.iM || Jn('not',0.1,'nothing');
       J.V = 0;

 - K: pi/lie #c s = d/C for a file
   D: |
     my $sc = u.sc;
     
     J.d.c.pwth='J5:cod';
       
     #Jn(catch => 0.03, {pi=>'hangleft',s=>{pi=>'text',s=>sc.r},scwa=>'right:0em'}, '{ab:1,hs:3 9 7 9,fs:13}');
     Jn(lines => 0.07, {pi=>'hangleft',s=>sc.lines}, '{ab:1,co:f42,fs:13}');
     #Jn(linein => 0.034, {pi=>'hangleft',s=>sc.in,scwa=>'right:3em'}, '{ab:1,co:e72,fs:10}');
     
     
     #my $ind = $1 if sc.h =~ /^(.+?)\Qsc.K\E/;
     my $al = $1 if sc.h =~ /\Qsc.K\E(.+)$/;
     #Jn(ind => 0.09, $ind, "{co:38e,fs:12}");
     Jn(K => 0.1, sc.K, "{hs:347,fs:17}");
     # go look for the right side of /K
     #Jn(al => 0.11, {s=>slm(20, $al)}, "{co:5ae,fs:12}");
     
     
     #Jn(com => 0.3, {s=>sc.com}, '{co:342,fs:9}');
     #Jn(
 - K: fil #c index of files?
   n_D:
     yJ: |
       'fil'
     o: |
       my $f = Rw fil/e;
       my $o = {};
       Rw around $J:f $o;
       $o;
     e: |
       my $J = Rw J5 - fil;
       die if !ref $J;
       my $fid = slm 8, dig $file;
       my $fJ = J.bb->{"$fid\t0.1"};
       if (!$fJ) {
           $fJ = Rw oJ $J $name=lie.$fid $style=lie;
           fJ.bz->("file\t0.1" => $file);
           J.bz->("$fid\t0.1", $fJ, '%file'=>$file);
       }
       $fJ
 - K: lie #c one file vector, expanding reconvening substructure of io mess to artifacts and stuff in 0.8
   n_D:
     yJ: |
       'lie'
     in: |
       my $o = {};
       Rw around $J $o;
       my ($it) = grep { _.t eq u.t && _.y.cv == u.y.cv } @{o.M};
       $it || die "u.t   u.y.cv not found!";
       it.sc.dig eq u.sc.dig || die "NOT UP";
       it.c.s = u.c.s;
       #die wdump [$it, $u];
       my $file = J.bb->{"file\t".0.1};
       
       write_file($file, join("\n", map {_.c.s} @{o.M})."\n\n");
       
       Rw around;
       
       if (my $sJ = J.WWsub) {
       warn "arounding ".gp(sJ.most.J);
           Rw around $J:sJ.most.J;
       }
       say "Saved?";
     around: |
       J.cv ||= 0.5;
       Rw lief $J;
       ar.o &&
       Rw out;
       sayyl "Doof ". F_delta;
     out: |
       my $out = Rw tyc $J;
       my @hum = sort {a.sc.in<=>b.sc.in} grep{_.y.cv == 0.4} @$out;
       o.M = \@hum;
       o.oJ = $J;
       o.ou = 'lie';
 - K: lief/flows/folate #c
   D: |
     flow 1  {} {}
     stat 6.1 {} {tv:file,et:0}
     read 6.2 {} {tv:file,et:130}
     jam  6.3 {} {tv:read,et:340}
 - K: folate/flow #c
   D: |
     # 2
     for my $c (@{wJ.tvs}) {
         my $coi = Rw pha $J $k=c.K/c.v;
         
         coi.off = c.sc.et if defined c.sc.et;
         sayyl "Trying c.K    c.v        off=coi.off";
         
         my $ip;
         ip.l = c.sc.tv if c.sc.tv;
         my $vs = Rw tyv $J $ip;
         
         my $nc = Rw lv_same $vs $x:coi $J $V=1;
         next if $nc;
         
         die if @$vs > 1;
         for my $lv (@$vs) {
             my $j = lv.j;
             # resolve $offness, add $and to lv_same
             # if change exactl swoops an init linehum wd
             
             sayyl "c.v Effect: c.K ";
             saybl "In: j.r   => ".slim 20, j.s;
               
             my $at = {};
             Rw c.wa $J $j $at $c $sc:lv.sc;
               # ^
               # at travels fast
               # v
               Rw jamsc $J $j $sc:at;
               
               # STYLE
          }
          coi.same_wd ||= do { # catchup (all wong)
              my $vs = Rw tyv $J $ip;
              delete coi.off;
              Rw lv_same $vs $x:coi $J $ret=1 $V=1;
          };
          
          coi.V = 1;
          my $y = coi.exactl->();
       }
 - K: folate/stat #c
   D: |
     at.is_file = -f j.s;
     my @s = stat j.s;
     at.ino = $s[1];
     at.size = $s[7];
     at.mtime = $s[9];
     at.ctime = $s[10];
 - K: folate/read #
   D: |
     my $s = read_file(j.s);
     my $dig = dig $s;
     Jn('read' => 0.3 => $s, {dig=>$dig});
     at.dig = $dig;
 - K: folate/jam #
   D: |
         my $i = 0;
         my $l = {map { $i++ => $_ } split "\n", j.s};
         Jn('lines' => 0.3 => $l);
         my @bu;
         my @nol;
         my $R_Jz = 0;
         for my $li (sort {$a<=>$b} keys %$l) {
             my $n = {in=>$li};
             n.s = $l->{$li};
             n.h = n.s;
             $R_Jz = 1 if n.s =~ /^R_Jz/;
             
             if ($R_Jz ? n.s =~ /^.?.?\w/ : n.s =~ /^.?\S/) {
                 n.r = 'low';
             }
             if (n.s =~ /#(c)(.*)$/) {
                 n.r = 'c';
                 n.com = $2 if $2;
             }
             
             n.K = $1 if n.s =~ /K: (\w+[^#]+)/; 
             n.K ||= $1 if n.s =~ /^[^#]*?(\w+[^#]+)/;
             n.K =~ s/\s+$// if n.K;
             if (n.r && n.K) {
                 if (@nol) {
                     n.s = join"\n",@nol,n.s;
                     @nol = ();
                     n.in = 0;
                 }
                 push @bu, $n;
             }
             elsif (@bu) {
                 my $las = $bu[-1]; 
                 las.s .= "\n".n.s;
                 las.out = $li;
             }
             else {
                 push @nol, n.s
             }
         }
         for my $n (@bu) {
             my $s = delete n.s;
             $s||die;
             n.dig = slm 7, dig $s;
             n.lines = split "\n", $s;
             my $j;
             j.l = n.K||n.h;
             j.l =~ s/[^\w]+//sgm;
             j.cv = 0.4;
             Jn(j.l, j.cv, $s);
             Rw jamsc $J $j $sc:n;
             #saybl "N: n.K        ".slim 40, ki $n;
         }

