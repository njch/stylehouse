R_Jz:
 - K: awm #c 
   n_D:
     yJ: |
       'awm clw gui heag'
     up: |
       my $coi = Rw pha $J $k=jo;
       
       Jn(',',0.9,',');
       Rw clw/upl;
       Rw suck */upl;
       
       my $M=[];
       Rw the + on $M;
       Jn('hihi',{o=>$M}) if @$M;
       say "comat ".F_delta;
       
       coi.exactl->(); 
       
       
 - K: gui #c
   n_D:
     yJ: |
       J.cv = 20;
       J.most.mody = 'ano';
       J.most.eo = 'chuv';
       'gui quigeo uppy' 
     out: |
       #saygr "GEO J.name    GEO J.name    GEO J.name GEO J.name GEO J.name" for 1..5;
       sayyl "gui GGEO OUTING J.name";
       Rw oJ $J geo &up $noesc=1;
       Rw chuv $J;
 - K: shv #c  and to compile J5 rounds ahead
   n_D:
     yJ: |
       'shv gui geoex'
     curves: | 
       spun 0 0
       zoom 0 2
       y    0  0
       x    0  0.15
       curve 0 -0.2
       curve 0.6 0.4
     defon: |
       #twang 0.1 Z/2 
       #twong 0.1 Z/3
     up: | # if the in up, pha wakeups out - all response to editing
       my $coi = Rw pha $J $k=shvs; 
        
       my $oJ = Rw oJ $J je;
       if (my $i = ar.i) {
          oJn(i.name, 0.3, {s=>$i,J=>$i});
       }
       
       my $vs = Rw tyv $J:oJ;
       my $M=[];
       for my $lv (@$vs) {
           my $j = lv.j;
           next if j.s.dead;
           Mn(j.l,'',j.l,{J=>j.s,enid=>j.s.id});
       }
       Rw om/bal $J $oM:M $in=0.001 $out=0.9;
       
       coi.qui=1;
       coi.exactl->(); 
 - K: heag #c
   n_D:
     yJ: |
       'headi'
     up: |
       Rw Jhead;
 - K: zoc #c
   D: |
     Rw loD;
     Rw brack;
     Rw fresh_init;
     
 - K: loD #c
   D: |
     delete G.drop;
     Rw loadc;
     Rw lodname;
 - K: loadc #c
   D: |
     my $l = ar.l || 'w/c';
     $l =~ s/\/*$/\//;
     my @f = map{chomp$_;$_}`find $l -type f`;
     @f || die "no $l";
     for my $file (@f) {
         my $m = Rw Loadc $file;
         for my $p (keys %$m) {
             my $n = $m->{$p};
             Rw loadup $u:G.way $p $n;
         }
     }
 - K: Loadc #c
   D: |
     my $s = read_file($file);
     Load($s);
 - K: lodname #c
   D: |
     my $st = Rw wuck - lod/H.name;
     for my $v (values %$st) {
         for my $p (keys %$v) {
             my $n = $v->{$p};
             Rw loadup $u:G.way $p $n;
         }  
     }  
     
 - K: wo1 #c 
   n_D:
     yJ: |
       'awm'
     on: |
       #won 0.1 eye/fug {ou:eye}
       won 0.1 g/c {ou:eye}
     upl: |
       
 - K: wam #c 
   n_D:
     yJ: |
       'awm'
     on: |
       #twzng 0.1 w/c {ou:eye}
       tweg 0.1 w/c {ou:eye}
       #twzng 0.5 J/2 {dir:ghosts,ou:file}
     upl: |
     
     
     
 - K: wut #c 
   n_D:
     yJ: |
       'awm'
     upl: |
       J.iM = ar.M if ar.M;
       J.V = 1;
       Jn('hihi',{o=>J.iM}) if J.iM;
       J.iM || Jn('not',0.1,'nothing');
       J.V = 0;
 - K: pi/eye #c
   D: |
     my $file = $u;
     J.V = 1;
     #J.d.c.path = 'amp';
     Jn('ey',0.09,"ey",'{hs:636}');
     Jn('file',0.1,"$file",'{hs:277}');
     Jn($file,{o=>{}},{pi=>'ls',s=>$file});
     J.V = 0;
 - K: pi/ls #c
   D: |
     my $file = $u;
     J.d.c.pwth = 'somewhere';
     J.d.sc.tt = 'somewhere';
     
     Jn('fiule',0.1,"J.d.t",'{hs:4889}');
         
     return
     Jn('ends',0.2,'@','{hs:6984,ml:-0.3em}')
     if J.d.y.spc < 0.02;
     
     if (-l $file) {
         Jn('-s',0.12,'-s','{co:fca}');
         my $to = readlink $file;
         my $oo = $file;
         $oo =~ s/(^|\/)[^\/]+$//;
         undef $oo if $oo eq '';
         $oo = (defined$oo?"$oo/":"").$to;
         
         Jn('sb',0.1231,"$to",'{co:f6a}');
         
         $oo || die "$file => $oo";
         $file = $oo;
     }
     
     # cm smartIndent 
     my $oM=[];
     if (!-e $file) {
         Jn("not",0.2,"!$file:$!",'{co:fca}');
     }  
     elsif (-f $file) {
         Jn('-f',0.2,'-f');
         
         oMn('.','',{pi=>'fi',s=>$file});
     }
     elsif (-d $file) {
         Jn('diry',0.2,'/','{hs:3555}');
         
         opendir(my $dh, $file) || die "can't opendir $file: $!";
         my @ma = readdir($dh);
         
         @ma = sort grep {$_ ne '.' && $_ ne '..'} @ma;
         
         my @fa;
         @ma = map { -d "$u/$_" ? push @fa, $_ : $_ } @ma;
         @ma = (@fa,@ma); 
         
         closedir $dh;
         
         my $rl = int(14 * (J.d.y.spc / 0.3 * J.d.y.spc));
         $rl = 7 if $rl < 7;
         @ma = @ma[0..$rl] if @ma > $rl;
         sayyl "ls $u   (J.d.t) e $rl    in J.d.y.spc";
         #saybl wdump 2, {J.d.t=>\@ma};
         oMn($_,{},{pi=>'ls',s=>"$u/$_"}) for @ma;
     }
     
     Jn('ls',{o=>$oM},{});
     
 - K: somewhere #c
   D: |
     my $J = J2.sc.pi;
     my @path = $J;
     while (1) {
        my $l = $path[0];
        unshift @path, l.Jiter || last;
     }
     my @lspath;
     for (reverse @path) {
         _.y eq 'ls' || last;
         push @lspath, _.d.t;
     }
     my $path = join '/', reverse @lspath;
     my $M = [];
     Mn('fro',{},"$path",'{ou:file}');
     Rw J5 wut $M;
 - K: pi/fi #c -f
   D: |
     my $y;
     $y ||= 'thumbnail' if $u =~ /(png|gif|jpe?g)$/i;
     $y ||= 'file' if $u =~ /^w\/c|^g/;
     $y ||= 'text';
     my $oM = [];
     
     oMn($y,{},{pi=>$y,s=>$u});
     
     Jn('fis',{o=>$oM},{});
     
 - K: pi/file #c
   D: |
     my $file = $u;
     defined $file || die 'nofile';
     if (my $dir = C.sc.dir) {
         $dir =~ s/\/?$/\//;
         $file = "$dir$file";
     }
     sayyl "oufile: $file";
     
     Jn("filename",0.1,$file,'{fs:20,hs:5563}');
     
     my $met = `file '$file'`;
     die $met unless $met =~ /text/;
     my $o = Rw fil/o $file;
     
     Jn('nmyd',{o=>$o});
     sayre J.r."   ".ki J.d.y;
 - K: inmid #c
   D: |
     my $y = J.d.y;
     my $oM = [];
     oMn("what",{thy=>1},"y.cv out=".(0+y.ov),'{fs:8,hs:3.5.6.9}');
     
     my $lum = 3;
     my $i = 0;
     for (@{o.M}) {
         oMn(_.t, {thy=>$lum,%{_.y}}, {pi=>o.ou,s=>$_},{oJ=>o.oJ});
         $i++;
         $lum = 2 if $i == 4;
         $lum = 1 if $i == 7;
     }
     
     oMn("what",
     {thy=>1},
     "");
     
     delete _.y.cv for @$oM;
     
     my $thic = y.ov - y.cv;
     warn "THICKNESS of J.r : y.ov - y.cv    (".$thic;
     my $y = {in => y.cv+0.06, out => y.ov};
     
     Rw om/bal $J:J.Jiter $oM $t=thelov $y;
     
 - K: pi/lie #c s = d/C for a file
   D: |
     my $sc = u.sc;
     
     J.d.c.pwth='J5:cod';
       
     #Jn(catch => 0.03, {pi=>'hangleft',s=>{pi=>'text',s=>sc.r},scwa=>'right:0em'}, '{ab:1,hs:3 9 7 9,fs:13}');
     #Jn(lines => 0.07, {pi=>'hangleft',s=>sc.lines}, '{ab:1,co:f42,fs:13}');
     #Jn(linein => 0.034, {pi=>'hangleft',s=>sc.in,scwa=>'right:3em'}, '{ab:1,co:e72,fs:10}');
     
     
     #my $ind = $1 if sc.h =~ /^(.+?)\Qsc.K\E/;
     #my $al = $1 if sc.h =~ /\Qsc.K\E(.+)$/;
     #Jn(ind => 0.09, $ind, "{co:38e,fs:12}");
     Jn(K => 0.1, sc.K, "{hs:347,fs:17}");
     # go look for the right side of /K
     #Jn(al => 0.11, {fadwi=>$al,s=>slm(20, $al)}, "{co:5ae,fs:12}");
     
     
     #Jn(com => 0.3, {s=>sc.com}, '{co:342,fs:9}');
     #Jn(
 - K: fil #c index of files?
   n_D:
     yJ: |
       'fil'
     o: |
       my $f = Rw fil/e;
       my $o = {};
       Rw around $J:f $o;
       $o;
     e: |
       my $J = Rw J5 - fil;
       die if !ref $J;
       my $fid = slm 8, dig $file;
       my $fJ = J.bb->{"$fid\t0.1"};
       if (!$fJ) {
           $fJ = Rw oJ $J $name=lie.$fid $style=lie;
           fJ.bz->("file\t0.1" => $file);
           J.bz->("$fid\t0.1", $fJ, '%file'=>$file);
       }
       $fJ
 - K: lie #c one file vector, expanding reconvening substructure of io mess to artifacts and stuff in 0.8
   n_D:
     yJ: |
       'lie'
     in: |
       my $o = {};
       Rw around $J $o;
       my ($it) = grep { _.t eq u.t && _.y.cv == u.y.cv } @{o.M};
       $it || die "u.t   u.y.cv not found!";
       it.sc.dig eq u.sc.dig || die "NOT UP";
       it.c.s = u.c.s;
       #die wdump [$it, $u];
       my $file = J.bb->{"file\t".0.1};
       
       write_file($file, join("\n", map {_.c.s} @{o.M})."\n\n");
       
       Rw around;
       
       if (my $sJ = J.WWsub) {
       warn "arounding ".gp(sJ.most.J);
           Rw around $J:sJ.most.J;
       }
       say "Saved?";
     around: |
       J.cv ||= 0.5;
       Rw lief $J;
       ar.o &&
       Rw out;
       sayyl "Doof ". F_delta;
     out: |
       my $out = Rw tyc $J;
       my @hum = sort {a.sc.in<=>b.sc.in} grep{_.y.cv == 0.4} @$out;
       o.M = \@hum;
       o.oJ = $J;
       o.ou = 'lie';
 - K: lief/flows/folate #c
   D: |
     flow 1  {} {}
     stat 6.1 {} {tv:file,et:0}
     read 6.2 {} {tv:file,et:130}
     jam  6.3 {} {tv:read,et:340}
 - K: folate/flow #c
   D: |
     # 2
     for my $c (@{wJ.tvs}) {
         my $coi = Rw pha $J $k=c.K/c.v;
         
         coi.off = c.sc.et if defined c.sc.et;
         sayyl "Trying c.K    c.v        off=coi.off";
         
         my $ip;
         ip.l = c.sc.tv if c.sc.tv;
         my $vs = Rw tyv $J $ip;
         
         my $nc = Rw lv_same $vs $x:coi $J $V=1;
         next if $nc;
         
         die if @$vs > 1;
         for my $lv (@$vs) {
             my $j = lv.j;
             # resolve $offness, add $and to lv_same
             # if change exactl swoops an init linehum wd
             
             sayyl "c.v Effect: c.K ";
             saybl "In: j.r   => ".slim 20, j.s;
               
             my $at = {};
             Rw c.wa $J $j $at $c $sc:lv.sc;
               # ^
               # at travels fast
               # v
               Rw jamsc $J $j $sc:at;
               
               # STYLE
          }
          coi.same_wd ||= do { # catchup (all wong)
              my $vs = Rw tyv $J $ip;
              delete coi.off;
              Rw lv_same $vs $x:coi $J $ret=1 $V=1;
          };
          
          coi.V = 1;
          my $y = coi.exactl->();
       }
 - K: folate/stat #c
   D: |
     at.is_file = -f j.s;
     my @s = stat j.s;
     at.ino = $s[1];
     at.size = $s[7];
     at.mtime = $s[9];
     at.ctime = $s[10];
 - K: folate/read #
   D: |
     my $s = read_file(j.s);
     my $dig = dig $s;
     Jn('read' => 0.3 => $s, {dig=>$dig});
     at.dig = $dig;
 - K: folate/jam #
   D: |
         my $i = 0;
         my $l = {map { $i++ => $_ } split "\n", j.s};
         Jn('lines' => 0.3 => $l);
         my @bu;
         my @nol;
         my $R_Jz = 0;
         for my $li (sort {$a<=>$b} keys %$l) {
             my $n = {in=>$li};
             n.s = $l->{$li};
             n.h = n.s;
             $R_Jz = 1 if n.s =~ /^R_Jz/;
             
             if ($R_Jz ? n.s =~ /^.?.?\w/ : n.s =~ /^.?\S/) {
                 n.r = 'low';
             }
             if (n.s =~ /#(c)(.*)$/) {
                 n.r = 'c';
                 n.com = $2 if $2;
             }
             
             n.K = $1 if n.s =~ /K: (\w+[^#]+)/; 
             n.K ||= $1 if n.s =~ /^[^#]*?(\w+[^#]+)/;
             n.K =~ s/\s+$// if n.K;
             if (n.r && n.K) {
                 if (@nol) {
                     n.s = join"\n",@nol,n.s;
                     @nol = ();
                     n.in = 0;
                 }
                 push @bu, $n;
             }
             elsif (@bu) {
                 my $las = $bu[-1]; 
                 las.s .= "\n".n.s;
                 las.out = $li;
             }
             else {
                 push @nol, n.s
             }
         }
         for my $n (@bu) {
             my $s = delete n.s;
             $s||die;
             n.dig = slm 7, dig $s;
             n.lines = split "\n", $s;
             my $j;
             j.l = n.K||n.h;
             j.l =~ s/[^\w]+//sgm;
             j.cv = 0.4;
             Jn(j.l, j.cv, $s);
             Rw jamsc $J $j $sc:n;
             #saybl "N: n.K        ".slim 40, ki $n;
         }

