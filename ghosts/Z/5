R_Jz:

 - K: flow #c K-flow
   D: |
     my $name = $m->[0];
     my $oJ = Rw oJ $J $name $style=fl;
     Rw up $J:oJ;
 - K: fl #c stitch at/cs solvents via $oJ/flows/M(Carbony patchbay)
   n_D:
     yJ: |
       'fl'
     up: |
       # later shoot out only changed words
       my $h = ejson[J.Jo.style,J.name];
       sayyl $h."   ".ejson(J.yt) for 1..5;
       $h = slm 8, dig $h;
       my $oJ = G.drop.flows->{$h} ||= Rw fl/op + $h;
       
       saybl "Flop: ".F_delta;
       
       Rw oJ.hw/flow $J:J.Jo $fJ:J $oJ;
       saybl "Flow: ".F_delta;
       #   enter ^ for ^ bits ^ loaf ^
       # (lost bits) 
     op: |
       # 
       Rw thy $J:J.Jo $oJ:J flows/J.name;
       # where to suck localness ^
       my $oJ;
       oJ.hw = "fl/h/$h";
       Rw suJ $J:oJ;
       
       my $vs = Rw tyv $J;
       @$vs||die;
       
       my $path;
       
       for my $lv (@$vs) { 
           my $j = lv.j;
           sayre "Stitchup j.r    ".ki lv.sc;
           
           my $Z = Rw muck - J.name/j.l;
           die "nothing from J.name/j.l   fo" if !%$Z;
           for my $k (sort keys %$Z) {
               my $s = $Z->{$k};
               
               $path = j.l if G.drop.conv->(j.cv) eq 'YIN';
               
               my @N = ref $s eq 'ARRAY' ? do {
                   my $M = [];
                   Rw MyN $N:s $M;
                   @$M;
               }
               :
               ref $s eq 'HASH' ? do {
                   die 'possible lma fire...'
               }
               :
               ref $s ? die "no $s" : do {
                   my $M = [];
                   my $i = 0.01;
                   my @cs;
                   #sayre $s if j.l =~ /flow/;
                   my $up = sub {
                       @cs || return "nothing in j.l $i";
                       my $c;
                       c.t = j.l;
                       c.y.cv = $i;
                       c.s = join "\n", @cs;
                       c.sc = lv.sc;
                       push @$M, $c;
                       @cs = ();
                   };
                   for my $l (split "\n", $s) {
                       if ($l =~ /^\s*# (\d\S*)/) {
                           my $ni = $1;
                           $up->();
                           $i = $ni;
                       }
                       push @cs, $l;
                   }
                   $up->();
                   @$M;
               };
               !$path && die "noapth";
               
               for my $c (@N) {
                   Rw Nucleoues $c $path $oJ:J $J:oJ;
                   saybl '==================';
               }
           }
       }
       
       my $coms = {};
       my $wtf = Rw concat $J:oJ $coms;
       
       my $real = Rw wtfity $wtf;
       
       oJ.way = {};
       for my $pin (sort keys %$real) {
           my $n = $real->{$pin};
           Rw loadup $u:oJ.way $pin $n;
       }
       Rw loadup $u:R.way.hooks $pin:oJ.hw $n:oJ.way;
       
       saygr wdump oJ.way;
       
       $oJ
 - K: wtfity #c
   D: |
     my $real = {};
     
     for my $l (sort keys %$wtf) {
         my $cvs = $wtf->{$l};
         
         for my $cvit (sort keys %$cvs) {
             my $v = $cvs->{$cvit};
             
             my $type = G.drop.conv->($cvit);
             # con cvit # make zp(1) to round zero point numbers to 1, etc
             
             $v = join "\n", @$v;        # # <<<<<<<
             
             if ($type eq 'YIN') {
                 $real->{$l} = $v;
                 #die "split: $v";
             }
             else {
                 $real->{$l} || die;
                 $real->{$l} .= "\n$v";
                 #$real->{$l} =~ s/(# $type.*?)$/$1\n$v/sm
                 #   || die "no $type in $l ... $real->{$l}";
             }
         }
     }
     
     $real
       
 - K: concat #c tlv -> wtf.$l.$cvit [ j.s
   D: |
       # shove togeth modn
       # get a cv sorter  that puts 3 > 32, since 3 is 3 all the way down > 3232323...
       # tesalation
       my $vs = Rw tlv $J;
       # ^ hash styles, things are l+com, like $tks
       my $wtf;
       for my $lv (@$vs) {
           my $j = lv.j;
           die if !%$j;
           
           lv.sc && die "wop";
           
           acum ar.coms, j.cv => j.com if ar.coms;
           
           my $was = $wtf->{j.l} ||= {};
           
           acum $was, G.drop.vonc->(j.cv), j.s;
           # aggs to wanted dp, fractionated in as the src wants, in the order of tlvness
           # <<<<<<< cv collapse unto elements #? rel src to round cv...
       }
       $wtf
 - K: Nucleoues #c
   D: |
          my (@l,@lr,@r);
          c.K ||= c.t;
          c.K || die;
          c.v ||= c.y.cv;
          c.v ||= 3;
          c.v += 0;
          
          my $ome = c.K; # as uncompressed in the bb key? wtf if K dup
          
          die c.v if c.v !~ /^\d/;

          # if for c.cs, for implant condits # sche
          my $cv = c.v;
          my $D = c.s || c.c.s;
          my $type = G.drop.conv->($cv);
          # z downgrasp (ty above) self if MZ
          my $sc;
          $sc = c.sc.MZ if c.sc && c.sc.MZ;
          my $ty = {};
          $sc ||= $ty->{$type};
          $sc ||= {};
          $sc = {%$sc, %{c.sc}} if c.sc;
          c.sc = $sc;
          sc.com = "# c.v c.K sc.com";
          
          # per $path if maybe ?? emberd whatsits
          # some special K of c may have meta for this too
          
               if (my $sub = sc.subhash) {
                   unshift @l, "oJ\.drop\.$path\.$sub\.c.K = sub {";
                   
                   my $args = '$v,$tks,$'.$sub;
                   
                   if (my $arp = sc.subhash_X_arp) {
                       $args .= ",$arp";
                   }
                   push @lr, '    my ('.$args.') = @_;'; # gets $X, etc
                   $D = ind '     ', $D;
                   push @r, '};';
                   if (my $list = sc.droplist) {
                       push @r, "push \@{oJ\.drop\.$path\.$list}, 'c.K';"; 
                       J bz ${path}_$sub#rese$list 1 "oJ\.drop\.$path\.$list = [];"
                   }
                   my $haD = join "\n", (sc.com||"#!?"), @l, @lr, $D, @r;
                   @l = (); @lr = (); @r = ();
                   
                   J.bz->("${path}_$sub#rese\t1", "oJ\.drop\.$path\.$sub = {};");
                   J.bz->("${path}_$sub#$ome\t$cv", $haD);
                   J.bz->("${path}_$sub#return\t9", "oJ\.drop\.$path\.$sub;");
                   J.bz->("$path#upsubhash-$sub\t1",
                     "my \$$sub = oJ\.drop\.$path\.$sub ||= Rw J.hw/${path}_$sub;");
                     
                   return; #
               }
          
          # see twisty ops in lightcones
          # could resolve curve embeddings like this
          # same in bush of stuff to cv out
          # cv in
          
          if (my $cs = sc.qmco) {
              push @l, ':', "\$tk eq 'c.K' ? do {";
              if (my $sub = sc.subhash) {
                  $D = "G\.drop\.$path\.$sub\.c.K->(\$v, \$tks)";
              }
              $D = ind '     ', $D;
              push @r, '}';
          }
          
          # if (sc.this) { DO } +
               if (my $cs = sc.csfrm) {
                   $cs = c.K if $cs eq 'cK';
                   sc.com .= "# cs=$cs  ";
                   unshift @l, "if (exists c\.$cs) {"
                       ."\n    my \$cs = c\.$cs;";
                   $D = ind '     ', $D;
                   push @r, '}';
               }
                
               if (sc.tv) {
                   # lets D
                   J.bz->("c.K\t1", $D);
                   # dup pha check^
                   #die ki $sc;
                   my $d = {%$c};
                   delete d.s;
                   acum $J, tvs => $d;
                   #die wdump [$path, $ome, $cv, c.K, $sc, $type];
                   return;
               }
               
               $D = join "\n", (sc.com||"#!?"), @l, @lr, $D, @r;
               J.bz->("$path#$ome\t$cv", $D);

