
Ray: 
 - K: J
   findway: R_J
hooks:
  elv: |
    $R = G.theJ;
    Rw elv $m;
  percolate_R: | # capow! R
    G.theJ = $G->R('J');
  percolate: |
    my $R = G.theJ;
    Rw olde;
R_Jz:
 - K: olde #c
   D: |
     Rw zoybracken;

     if (H.name eq 'K') {
         Rw J5 scr;
         Rw J5 somestyles;
         $G->su(S => sub {
            my $m = shift; 
            return unless $m =~ s/^ghostchanges\s+//;
            return unless $m =~ /\/k\//;
            Rw make/up $y=3;
         });
     }
     else { die H.name };
     
 - K: expro #c 
   D: |
     
     Rw zoc;
 - K: zoybracken #c embed ww # a super JJJ
   D: |
     G.oin ?
     Rw up $J:G.oin
     :
     Rw JJJ join;
 - K: join #c
   n_D:
     yJ: |
       G.oin = $J;
       'join clw'
     up: |
       # G.oin root ww:
       Rw J5 wu;
       # iterations:
       Rw J5 toc;
     in: |
       my $oJ = $J; # classic 8 stuf
       $J = G.oin;
       if (my $X = J.bb->{"oJ.name\t0.3"}) {
           Rw join/X $J:X;
       }
       Jn(oJ.name, 0.3, {s=>$oJ}, {});
       J.idJy->{oJ.id} = $oJ;
     X: |
       my $oJ = $J; # classic 8 stuf
       $J = G.oin;
       my $name = oJ.name;
       #die wdump [ sort keys %{J.bb} ];
       my $is = J.bb->{"oJ.name\t0.3"};
       warn "not latest oJ.name... delete both ".wdump 3,[$is,$oJ] if $is ne $oJ;
       for my $oJ ($oJ, $is) {
           Rw J5 wu $X:oJ;
           Rw delbbl $J $l:oJ.name;
           oJ.dead = 1; # etcrise
       }
       sayyl "delete is.name";
       if (e.S) {
           Rw J5 $name;
       }
 - K: exprob #c https://soundcloud.com/jsg89g9
   D: |
    (H.name,H.style,my @etc) = reverse @ARGV;
    H.style ||= 'hut';
    H.id = mkuid; 
    H.ol = "H.style/H.name/H.id";
    H.uptime = hitime;   
    say "     H Fresh init H.style H.name";
    
    return if H.style !~ /^[sh]/;
  
    Rw hostinfo;
    
    my $reS = sub {
        my $m = shift; 
        Rw reS $m;
    };
    $G->su(S => $reS);
    $G->su("S/H.style" => $reS);
    $G->su("S/H.style/H.name" => $reS);
    $G->su("S/H.style/H.name/H.id" => $reS);
    
    $G->timer(60*9+(20 * rand 4), sub {
        return if H.nosuddendeath;
        sayre "voluntary reexec" for 1..13;
        Rw rez;
    });
    
    # start git torrent
    # do it all
    # $0 has become a runtime
 - K: rez #c entropy! the randomness can antrophy
   D: |
     exec("nice perl $0 @ARGV");
 - K: reS #c pump someth Teeth
   D: |
    my $Eb = ar.E->pi."-" if ar.E;
    saybl "$Eb > ".slim(75,80,$m);
    my $j = $m =~ /^\w/ ? $m : djson($m);
    
    #G.reSway->{$way}->($am) if G.reSway->{$way};
    
    if (ref $j eq "HASH") {
        die "hash wide/skinny ".wdump($j) if keys %$j != 1;
        my ($uno) = keys %$j;
        my $ar = {
            j => $j,
            m => $m,
            $uno => $j->{$uno},
        };
        Rw S/$uno;
        # hit or not? see post 6 with r  ### o
        return;
    }  
    
    die "weird shit: '$m'" if ref $j; 
    
    $j =~ /^([\w\/]+)(?: (.+))?$/ ? 
        Rw S/$1 $m:2
    :
    die "wei tet '$j'";  
 - K: S # 
   n_D:
     ghostchanges: | #c
       # nothing, gets compiled and broadcast:
     wayup: |
       -f $m || die;
       delete G.drop; 
       $G->wayup($m);
       Rw recoded_init;
     reexec: |
       Rw rez;
     speaks: | # loop conealed elvis 
       Rw reS $m
     event: | # 
      my $e = ar.e = j.event;
      
      G.lastWe = $e if e.W; # \  
      
      if (e.type =~ /^key/ && !e.W && G.lastWe) {
          my $We = G.lastWe;
          for my $k (keys %$We) {
              $e->{$k} = $We->{$k} unless exists $e->{$k};
          }
      }
      
      e.W && return
      Rw S/W;
      warn "Strange". wdump $e;
     W: |
        $e->{$_} =~ /^\w+$/ || delete $e->{$_} for qw'id ux W';
        
        my $meta = $G->tri('W/'.e.W.'.i');
        $meta || return warn "no such e.W ... ".ki 2, $e;
        $meta = djson $meta if $meta;
        
        my $hol = meta.hol;
        G.keysto = $hol;
        
        my $a = {};
        if (my $J = G.Wh->{e.W}) {
            Rw event $J $e;
        }
        elsif ($hol ne H.ol) {
            sayyl "HSW H.ol -> $hol";
            saybl "e: ".wdump($e);
            $G->pub("S/$hol", "speaks $m"); # our json event again over there
        }
        else {
            die "goner";
        }
     hostinfo/ack: | #
        my (@s) = split /\s+/, $m;
        if (rand(1) > 0) {
            my $lag = (1000*sprintf('%.3f',hitime - $s[-1])).'ms';
            saygr "... $lag";
        }
        G.hostinfo_waits = 0;
 - K: hostinfo #c
   D: | # REname Hostinfo, polari
    if (!H.lastinfo) {
        $G->recur(29 => sub {
            Rw hostinfo;
        });
    }
    
    my $info;
    info.now = hitime;
    info.hol = H.ol;
    info.pid = $$;
    info.begin = H.uptime ||= hitime;
    
    saygr "hostinfo: ".ki $info if rand(1) > 0.7;
    
    # TODO some Purs have core v
    
    $G->tai("H/H.ol", $info);
    
    $G->pub("Hostinfo", "info.hol info.now", 'ig');
    
    $G->pub("Hi" => H.ol) if !H.lastinfo || ar.withHi;
    
    H.lastinfo = $info; 
    
    G.hostinfo_waits++;
    if (G.hostinfo_waits > 1) {
        sayre "hostinfo uncollected";
    }
 - K: recoded_init #c wake up
   D: |
     sayre "ANY!"; 
     Rw suck */recoded_init;
     
 - K: fresh_init #c
   D: |
     Rw suck */fresh_init;
  
 - K: any_init #c
   D: |
     Rw suck */any_init;
  
 - K: elv #c is online
   D: |
     saybl " Elvis e !: $m";
     sleep 1 if H.name ne 'K';
     H.G w reexec;
 - K: toc #c
   n_D:
     yJ: |
       'toc'
     around: |
       Rw vortex toc/up $J $d=4;
     up: | #
       # hops, rhythm aesthetics
       # things pur ambiently & incur pipes of sprawlingness into music
       # to space it out right...
       # for the mass of the atom of thought
       # wants emit with precision, figure processing/Em route into time
       
       my $oJ = G.oin;
       my $ip = {style=>'wantime'};
       my @timey = Rw tvo $J:oJ $ip;
       my @go;
       for my $j (@timey) {
           my $y = j.s;
           my $x = J.bb->{"j.l%timex\t0.3"};
           $x += $d; # vortex 4s
           if ($x >= $y) {
               $x = 0;
               push @go, oJ.bb->{"j.l%J\t0.3"} || die "no find j.l oin";
           }
           else {
               #say "ti $x -- $y";
           }
           J.bz->("j.l%timex\t0.3" => $x);
       }
       for my $J (@go) {
           sayyl "toc up: J.name\n\n";
           Rw up $J;
       }
       #say 'timing '.join', ', map{_.l} @timey;
       #saybl "makde ".F_delta();
 - K: vortex #c do recur while J as in G.oin
   D: |
     my $m = ar.m||[];
     my $d = ar.d||4;
     my $o = Rw pul $cs:m way;
     o.way || die;
     
     my $loopr = J.name."%loopid#o.way\t0.3";
     my $id = G.oin.bb->{$loopr};
     saybl "timer replaco J.name o.way" if $id;
     # if last hit and delta are whack
     # tiny hairs of sanity
     Mojo::IOLoop->remove($id) if $id;
     
     my $bl = {};
     bl.id = 
     G.oin.bb->{$loopr} = 
         $G->recur($d => sub {
             return Mojo::IOLoop->remove(bl.id)
                 if G.oin.bb->{$loopr} ne bl.id;
             Rw o.way $J $d;
         });

     

