
Ray: 
 - K: J
   findway: R_J
hooks:
  percolate_R: | # capow! R
    G.theJ = $G->R('J');
  percolate: |
    my $R = G.theJ;
    Rw zoybracken;
R_Jz:
 - K: Em #c send love
   D: |
     my $J = Rw oJ wu;
     # aj.id is the J zipped .c to E in one, stream?
     aj.Wid || die "not Wid?";
     aj.hol = "H.style/H.name/H.id";
     aj.hitime = hitime;
     aj.name ||= J.name;
     # also some J.headlev readings for .i
     
     G0.Wh->{aj.Wid} ||= do {
         my $ij = {}; map {
         $ij->{$_} = $aj->{$_} if !/^[sc]+/; } keys %$aj;
         ij.id = delete ij.Wid;
         ij.y = 'W';
         
         sayyl "Life! of ij.y ij.id";
         0->tai("ij.y/ij.id\.i", $ij);
         0->tac("V/H.style/H.name/H.id\.s", ztm($ij));
         G0.WhR->{aj.Wid} = $R;
         aj.J;
     };

     Rw up $J $aj;
     #Jn(aj.Wid, 0.2, {tsup=>'1'});
     #Jn(aj.Wid.'/'.aj.id, 0.3,
     
     aj.y ||= 'J';
     aj.yy = 'W';
     Rw aji $aj;
     Rw blabaj $aj;
 - K: aji #c
   D: |
     my $z = ztm($aj);
     if (aj.yy) {
         0->tac("aj.yy/".$aj->{aj.yy.'id'}.'.s', $z);
     }
     my $m = join "\n", map {@{$aj->{$_}}} sort grep{/^[sc]+/} keys %$aj;
     0->tai("aj.y/aj.id\.c", $m);
     0->tac("aj.y\.s", $z);
     
 - K: blabaj #c
   D: |
     saybl "E    aj.name    aj.yy/".$aj->{aj.yy.'id'}."   (  aj.id";
     for my $k (sort grep{/^[sc]+/} keys %$aj) {
         my $v = $aj->{$k};
         if (ref $v eq 'ARRAY') {
             saybl "$k => ".@$v;
             map { saybl slim $k eq 'c' ? 690 : 90, $_ } @$v 
         }
         else {
             saybl "$k    => ".slim 80, $v;
         }
     }
 - K: wu #c cattach anything under ww, trainyard, patch bay, hash out space <body>
   n_D:
     yJ: |
       'wu'
     up: |
       if (my $s = delete aj.s) {
           unshift @{aj.c}, jsq 
               " a\.wu(%s, %s, %s);",
               G.oin.id, aj.Wid, $s;
       }
       $aj;
 - K: zoy #c boat for catching/tlv looking the fishes
   n_D:
     yJ: |
       qw'zoy headi oci mayo'
     curves: |
       spun 0  3
       y    0  0
       x    0  0.02
       zoom 0.1 0.5
       curve 0.3 -0.2
     up: |
       Rw Jhead;
       Jn(wam => 0.2, {s=>'wam',pwth=>'J5:wam'});
       Jn(oot => 0.3, {s=>'oot',pwth=>'J5:oot'});
       #Rw zoybracken;
       Rw J5 wam;
       Rw oJ $J geo &up;
 - K: wam #c 
   n_D:
     yJ: |
       'wam mayo clw'
     up: | # if the in up, pha wakeups out - all response to editing
       Rw Jhead;
       my $oJ = Rw oJ $J on;
       oJn( twang => 0.2 => 'Z/2');
       Rw up $J:oJ;
       # bounce different ways...
       
       # hire a Con...
       # requireway, with parameters
       # then patch bay for groups of style to feed in
       # also the other elements present in may...
       # farmed out
       
       
       my $onl = Rw very $in=0.4 $out=0.9 $J:oJ $tot:J.cv;
       # pin down top level
       # primitives for geo site
       for my $x (@$onl) {
           Rw ix/suro + $x;
       }
       
       Jn(wamo => 0.2, {s=>'wam',pwth=>'J5:wam'}); 
       
       Rw oJ $J geo &up;
 - K: zoybracken #c embed ww # a super JJJ
   D: |
     my $J = G.oin ||= do{ # START
         my $J = G.oin = Rw JJ $name=join;
         # could JJJ where suJ self embeds before adJ?
         Rw adJ $J;
         #$afterid;
         $J
     };
     Rw up $J;
     $J
 - K: join #c
   n_D:
     yJ: |
       G.oin = $J;
       'join clw'
     up: |
       # to communicate
       J.wwcup ||= 
         Rw join/wwcup $J;
       Rw J5 scr;
       Rw J5 sts;
       Rw J5 occie;
       Rw J5 zoy;
       Rw J5 toc;
       
       my $ip = {style=>'J'};
       sayyl "JOIN join : _.l ".keys %{_.s.bb} for
           Rw tvo $J $ip;
           
     wwcup: |
       Jn('/', 0.9, {}, "{id:J.id,tag:ww,ab:100,zi:1,bgh:33.5.3.1}");
       my $ip = {l=>'/'};
       say _.r for
       Rw tvo $J $ip;
       
       my $aj = Rw may $J $catj=1 $ip;
       if (my $s = delete aj.s) {
           unshift @{aj.c}, jsq " \$('#ux').append(%s);", $s;
           #" \$('#' + \$('#$afterid').parent().attr('id') + ' ww').remove();",
           #" \$('#$afterid').after(".ejson($s).");"
       }
       Rw Em $aj;
       $aj;
 - K: scr #c 
   n_D:
     yJ: |
       J.yy.may.noroot = 1;
       'scr clw mayo'
     up: | # if the in up, pha wakeups out - all response to editing
       Rw thy $J comprsc;
       Rw thy $J canvas;
       Rw thy $J other;
       
       #Rw thy $J youtube;
 - K: on #c
   n_D:
     yJ: |
       J.yl.nojb = 1;
       'on';
     up: | # tak tlv J.on into iterations of upgoing clever
       my $vs = Rw tyv $J $ip:ar.ip;
       
       for my $lv (@$vs) {
           my $j = lv.j;
           my $k = "j.r xatly";
           my $coi = Rw pha $J $k;
           #sayyl " ** *  lv.j.r     =>   lv.j.s\n*  *  ".ki(lv.sc);
           my $ln = Rw linehum $lv;
           sayyl ejson $ln;
           if (!lv.sc) {
               say "INIT STYLO ".ejson $lv;
               #if (ln
               # looking at this J's abilities to upgrade string input with ou thinkg/crawl
           }
           #my $xat = Rw lv_same $lv $x:coi $J;
           #say "xat" if $xat;
       }
       
       
 - K: geo #c
   n_D:
     yJ: |
       'geo'
     up: |
       my $sr = J.Jo;
       
       saybl "geo of sr.name";
       
       Rw thy curves $J:sr $oJ:J
       ||
       Rw geolo $J;
       
       Rw oJ $J phz &up;
 - K: phz #c transfer
   n_D:
     yJ: |
       'phz'
     up: |
       my $geo = J.Jo;
       my $io = J.Jo.Jo;
       Rw phairo $J $oJ:io $geo;
       
       Rw outhere $J $oJ:io;
 - K: mayo #c
   n_D:
     yJ: |
       'mayo'
     out: |
       # splurt of compressions so may can do more
       Rw may $J;
       
 - K: clw #c
   n_D:
     curves: |
       spun 0  2
       y    0  0.3
       x    0  0
       zoom 0.1 0.5
       curve 0.3 -0.2
 - K: thy #c rollbar grab
   D: |
     my $what = $m->[0];
     my $wt = Rw wuck $J */$what;
     $J = ar.oJ || $J;
     my $M = [];
     my $nc = 1;
     for my $k (sort keys %$wt) {
         my $N = $wt->{$k};
         
         my $coi = Rw pha $J $k;
         
         my $d = ref $N ? ejson($N) : $N;
         
         next if Rw ph_same $J $x:coi $d;
         
         if (!ref $N) {
             $N = [ map { [$_] } split "\n",$N ];
         }
         #say " ** waything $what from $k";
         Rw MyN $N $J;
          
         my $y = coi.exactl->();
         $nc = 0 if !y.same;
     }
     $nc
 - K: adJ #c embed J
   D: |
     my $oJ = G.oin || die;
     J.name || die;
     J.r && die;
     oJn(J.name, 0.3, {s=>$J,J=>$J}, {});
     oJ.idJy->{J.id} = $J;
     Rw around $J;
 - K: oJ #c materialise G.oin.oJ.$name or J.oJ.$name
   D: |
     # squiggly time reconvogation
     # golden mean swivels
     my $wha = $1 if ar.m && ar.m->[-1] =~ /^&(.+)$/ && pop @{ar.m};
     my $oJ = ar.J || G.oin;
     my $and = ar.name || ar.m && ar.m->[0];
     if ($and) {
         $oJ = oJ.oJ->{$and} ||
             Rw JJJJ $J:oJ $name:and;
     }
     if ($wha) {
         Rw $wha $J:oJ;
     }
     $oJ;
     
 - K: J5 #c & Jmod cs like, resume/resync by name, JJJ underneath, hits */around (update or up) 
   D: |
     my $m = ar.m||[];
     my $o = Rw pul + $cs:m name style+;
     my $J = G.oin.bb->{o.name."\t0.3"};
     my $is = " *" if $J;
     sayyl " JJJJJ  o.name$is";
     if ($J) {
         # resync style
        Rw around $J;
     }
     else {
        $J = Rw JJJ;
     }
     $J
 - K: JJJJ #c from $J above, emb   J.oJ.$name = $J2   and   J2.Jo = $J
   D: |
     die unless G.oin;
     my $J2 = Rw JJ;
     J2.most.J = $J;
     J2.Jo = $J;
     J.oJ->{J2.name} = $J2;
     sayyl "J J J J  J2.name";
     $J2;
 - K: JJJ #c G.oin embedding spawn # 3 = REPLACEY, see J5 for ambient arounding
   D: |
     my $J = Rw JJ;
     sayyl " J J J  J.name";
     Rw adJ $J;
 - K: JJ #c make J that most.J = self
   D: |
     my $J = {};
     my $m = ar.m||[];
     my $o = Rw pul + $cs:m name style+;
     J.name = o.name;
     o.style = join ' ', @{o.style} if ref o.style;
     J.style = o.style || o.name;
     J.style = [split /\s+/, J.style] if !ref J.style;
     J.most.J = $J;
     
     Rw mkJid $J;
     
     Rw suJ $J;
     
     
     Rw Jup $J;
     
     sayyl "  J J   J.name";
     
     $J
 - K: suJ #c bbdomining for any sorta J
   D: |
     J.bb = {};
     J.ord = [];
     J.bz = Rw as $J;
     J.phy = {};
     J.phl = {};
     
     J.idyl = sub {
         my ($J, $id, $oj) = @_;
         J.most.J.idly->{$id} = {J=>$J, j=>$oj};
     };
     
     # 3
     # 4
 - K: Jup #c behaviouriser (lingo)
   D: |
     push @{J.style}, J.name if !grep{$_ eq J.name} @{J.style};
     J.yt = {};
     my $exp;$exp = sub {
         my $s = shift;
         my @wk = uniq
             grep{length} map {split /\s+/}
             Rw suck + $pin=$s/yJ;
         for my $k (@wk) {
             next if exists J.yt->{$k}; # many styles leading to the same style
             J.yt->{$k} ||= {};
             $exp->($k);
         }
     };
     $exp->($_) for @{J.style};
     warn "no style for   @{J.style}   (J.name)" if !%{J.yt};
     saygr "J.name yJup: ".join(' + ', @{J.style})." -> ".join(' ~ ', sort keys %{J.yt});
 - K: toc #c
   n_D:
     yJ: |
       'toc'
     around: |
       Rw vortex $J up $d=4;
     up: | #
       saybl "hi  ".slm 16, R.way.hooks.may;
       # hops, rhythm aesthetics
       # things pur ambiently & incur pipes of sprawlingness into music
       # to space it out right...
       # for the mass of the atom of thought
       # wants emit with precision, figure processing/Em route into time
       
       #G.oin.no->(G.oin, "J.name",0.3,{wantime=>8});
       
       my $oJ = G.oin;
       my $ip = {style=>'wantime'};
       my @timey = Rw tvo $J:oJ $ip;
       my @go;
       for my $j (@timey) {
           my $y = j.s;
           my $x = J.bb->{"j.l%timex\t0.3"};
           $x += $d; # vortex 4s
           if ($x >= $y) {
               $x = 0;
               push @go, oJ.bb->{"j.l%J\t0.3"};
           }
           else {
               say "ti $x -- $y";
           }
           J.bz->("j.l%timex\t0.3" => $x);
       }
       for my $J (@go) {
           say J.name;
           Rw up $J;
       }
       my $l = {map{_.l => 1}@timey};
       # make {$v=>1} == $v in ip for hash multitudes
       $ip = {style=>'J',l=>$l};
       my @l = Rw tvo $J:G.oin $ip;
       say "on time: _.r" for @l;
       # makes a pile to see/curve in J.up, tiny geos? things hop
       saybl "makde ".F_delta();
 - K: vortex #c do recur while J as in G.oin
   D: |
     my $m = ar.m||[];
     my $d = ar.d||4;
     my $o = Rw pul $cs:m way;
     o.way || die;
     
     my $loopr = J.name."%loopid#o.way\t0.3";
     my $id = G.oin.bb->{$loopr};
     saybl "timer replaco J.name o.way" if $id;
     # if last hit and delta are whack
     # tiny hairs of sanity
     Mojo::IOLoop->remove($id) if $id;
     
     my $bl = {};
     bl.id = 
     G.oin.bb->{$loopr} = 
         $G->recur($d => sub {
             return Mojo::IOLoop->remove(bl.id)
                 if G.oin.bb->{$loopr} ne bl.id;
             Rw o.way $J $d;
         });

     
Juping: |
  # anything in j.t should be fine
  # parse j.r in one regex, tightened at the right (cv) end
  # First need a top level J for holding all the others while they are alive, 8ing
  # 
Jo: # fills the rhymth dispatcher J
 -
  - oyo
  - ''
  - curves: clingleftwall # sets x+y like zoy
  - comb: # ambient rhythm to dispatch up (passive), pha con still
Then: |
   the J.d.c ^ suJways:
     - curves hooks up, but we have the compression living in the J for reinit
    # somewhere to:
      find the W M V I top level index of things...
      unfold from there
      tinier Jhead
     intersplice maka replacement

