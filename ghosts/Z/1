
R_Jz:
 - K: Em #c send love
   D: |
     my $J = Rw oJ wu;
     Rw up $J $aj;
     for my $k (sort keys %$aj) {
         my $v = $aj->{$k};
         say "$k => $v";
         map { saybl slim 260, $_ } @$v if ref $v eq 'ARRAY';
     }
     
 - K: wu #c attach anything under ww, trainyard
   n_D:
     yJup: |
       'wu'
     up: |
       if (my $s = delete aj.s) {
           my $wwid = G.oin.id;
           my $Wid = aj.Wid;
           unshift @{aj.c},
           " \$('ww#$wwid').append(".ejson($s).");";
       }
       my @M = (@{aj.c}, @{aj.sc});
       #Jn(aj.Wid, 0.2, {tsup=>'1'});
       #Jn(aj.Wid.'/'.aj.id, 0.3,
       for (@M) {
          E($_);
       }
       return;
       E(join("\n",@M));
 - K: scr #c 
   n_D:
     yJup: |
       'scr clingleftwall'
     around: |
       Rw suck */up;
       Rw suck */out;
     up: | # if the in up, pha wakeups out - all response to editing
       Rw thy $J comprsc;
       Rw thy $J canvas;
     out: |
       # splurt of compressions so may can do more
       Rw may $J;
       
 - K: thy #c rollbar grab
   D: |
     my $what = $m->[0];
     my $wt = Rw wuck $J */$what;
     my $M = [];
     for my $k (sort keys %$wt) {
         my $N = $wt->{$k};
         
         my $coi = Rw pha $J $k;
         
         my $d = ref $N ? ejson($N) : $N;
         
         next if Rw ph_same $J $x:coi $d;
         
         if (!ref $N) {
             $N = [ map { [$_] } split "\n",$N ];
         }
         #say " ** waything $what from $k";
         Rw MyN $N $J;
          
         my $y = coi.end->();
         my $ex = Rw ph_exactl $J $y;
     }
 - K: zoy #c boat for catching/tlv looking the fishes
   n_D:
     yJup: |
       qw'zoy oci'
     curves: |
       spun 0  3
       y    0  0
       x    0  0.02
       zoom 0.1 0.5
       curve 0.3 -0.2
     up: |
       Rw Jhead;
       
       if(1){
       my @jo = Rw tvo $J:G.oin;
       my $M = [];
       for my $j (@jo) {
           j.l eq '/' && next;
           my $sc = {bo=>'3px solid 8df'};
           sc.hs = '6.5.4.9' if _.style eq 'J';
           Mn(j.l, '', j.l, $sc);
       }
       Rw om/bal $J $oM:M jesu 0.1-0.5;
       }
       
       J.bz->("something\t0.2","bwall");
       
       Rw zoybracken $afterid:u.at.id;
 - K: pi/shelfo #c mhmm
   D: |
     Jn('yop', 0.8, J.d.t);
 - K: zoybracken #c embed ww # a super JJJ
   D: |
     #return sayre "NONREPEAT G_oin" if G.oin;
     # delete G.oin;
     
     my $J = G.oin ||= do{
         my $J = G.oin = Rw JJ $name=join;
         Rw adJ $J;
         Rw join/wwcup $J $afterid;
         $J
     };
     Rw J5 toc;
     Rw J5 scr;
     Rw up $J;
     # setup wrinkle
     # of time
     
     # make a background putter from a mod file mash injectsd
     # and place Js from join/up....
     # extra dimension implied, drag things through time
     # incremental
     
     # eat bees, up reports
     $J
 - K: join #c
   n_D:
     yJup: |
       'join clingleftwall'
     up: | #
       #my $z = Rw oJ $J zling;
       #Rw up $J:z;
       my $ip = {style=>'J'};
       my @l = Rw tvo $J $ip;
       for (@l) {
           sayyl "join : _.l ".keys %{_.s.bb};
       }
       # makes a pile to see/curve in J.up, tiny geos? things hop
     wwcup: |
       Jn('/', 0.9, {}, "{tag:ww,ab:100,poi:n,zi:1,bgh:33.5.3.1}");
       my $ip = {l=>'/'};
       my $aj = Rw may $J $catj=1 $ip;
       if (my $s = delete aj.s) {
           unshift @{aj.c}, 
           " \$('#' + \$('#$afterid').parent().attr('id') + ' ww').remove();",
           " \$('#$afterid').after(".ejson($s).");"
       }
       Rw Em $aj;
 - K: zling #c
   n_D:
     yJup: |
       'zling clingleftwall'
  
 - K: adJ #c embed J
   D: |
     my $oJ = G.oin;
     J.name || die;
     J.r && die;
     oJn(J.name, 0.3, {s=>$J,J=>$J}, {});
     Rw around $J;
 - K: oJ #c asume G.oin.oJ.$name
   D: |
     # squiggly time reconvogation
     # golden mean swivels
     my $oJ = G.oin;
     my $and = ar.name || ar.m && ar.m->[0];
     if ($and) {
         $oJ = oJ.oJ->{$and} ||= Rw JJJJ $J:oJ $name:and;
     }
     $oJ;
     
 - K: J5 #c & Jmod cs like, resume/resync by name, JJJ underneath, hits */around (update or up)
   D: |
     my $m = ar.m||[];
     my $o = Rw pul + $cs:m name style+;
     my $J = G.oin.bb->{o.name."\t0.3"};
     my $is = " *" if $J;
     sayyl " JJJJJ  o.name$is";
     if ($J) {
         # resync style
        Rw around $J;
     }
     else {
        $J = Rw JJJ;
     }
     $J
 - K: JJJJ #c from $J above, emb   J.oJ.$name = $J2   and   J2.Jo = $J
   D: |
     die unless G.oin;
     my $J2 = Rw JJ;
     J2.most.J = $J;
     J2.Jo = $J;
     J.oJ->{J2.name} = $J2;
     sayyl "J J J J  J2.name";
     $J2;
 - K: JJJ #c G.oin embedding spawn # 3 = REPLACEY, see J5 for ambient arounding
   D: |
     die unless G.oin;
     my $J = Rw JJ;
     sayyl " J J J  J.name";
     Rw adJ $J;
 - K: JJ #c make J that most.J = self
   D: |
     my $J = {};
     my $m = ar.m||[];
     my $o = Rw pul + $cs:m name style+;
     J.name = o.name;
     o.style = join ' ', @{o.style} if ref o.style;
     J.style = o.style || o.name;
     J.style = [split /\s+/, J.style] if !ref J.style;
     J.most.J = $J;
     
     Rw mkJid $J;
     
     Rw suJ $J;
     
     
     Rw Jup $J;
     
     sayyl "  J J   J.name";
     
     $J
 - K: suJ #c bbdomining for any sorta J
   D: |
     J.bb = {};
     J.ord = [];
     J.bz = Rw as $J;
     J.phy = {};
     J.phl = {};
     
     J.idyl = sub {
         my ($J, $id, $oj) = @_;
         J.most.J.idly->{$id} = {J=>$J, j=>$oj};
     };
     
     # 3
     # 4
 - K: Jup #c behaviouriser (lingo)
   D: |
     push @{J.style}, J.name if !grep{$_ eq J.name} @{J.style};
     J.yt = {};
     my $exp;$exp = sub {
         my $s = shift;
         my @wk = uniq
             grep{length} map {split /\s+/}
             Rw suck + $pin=$s/yJup;
         #saybl " - sty $s -> @wk" if @wk;
         for my $k (@wk) {
             next if exists J.yt->{$k}; # many styles leading to the same style
             J.yt->{$k} ||= {};
             $exp->($k);
         }
     };
     $exp->($_) for @{J.style};
     die "no style for   @{J.style}   (J.name)" if !%{J.yt};
     saygr "J.name yJup: ".join(' + ', @{J.style})." -> ".join(' ~ ', sort keys %{J.yt});
 - K: toc #c
   n_D:
     yJup: |
       'toc'
     around: |
       Rw vortex $J up;
     up: | #
       saybl "hi";
       # hops, rhythm aesthetics
       # things pur ambiently & incur pipes of sprawlingness into music
       # to space it out right...
       # for the mass of the atom of thought
       # wants emit with precision, figure processing/Em route into time
       
       my $ip = {style=>'wantime'};
       my @timey = Rw tvo $J:G.oin $ip;
       my $l = {map{_.l => 1}@timey};
       # make {$v=>1} == $v in ip for hash multitudes
       $ip = {style=>'J',l=>$l};
       my @l = Rw tvo $J:G.oin $ip;
       say _.r for @l;
       # makes a pile to see/curve in J.up, tiny geos? things hop
 - K: vortex #c do recur while J as in G.oin
   D: |
     my $m = ar.m||[];
     my $o = Rw pul $cs:m way;
     o.way || die;
     
     my $loopr = J.name."%loopid#o.way\t0.3";
     my $id = G.oin.bb->{$loopr};
     saybl "timer replaco J.name o.way" if $id;
     # if last hit and delta are whack
     # tiny hairs of sanity
     Mojo::IOLoop->remove($id) if $id;
     
     my $bl = {};
     bl.id = 
     G.oin.bb->{$loopr} = 
         $G->recur(4 => sub {
             return Mojo::IOLoop->remove(bl.id)
                 if G.oin.bb->{$loopr} ne bl.id;
             Rw o.way $J;
         });

     
Juping: |
  # anything in j.t should be fine
  # parse j.r in one regex, tightened at the right (cv) end
  # First need a top level J for holding all the others while they are alive, 8ing
  # 
Jo: # fills the rhymth dispatcher J
 -
  - oyo
  - ''
  - curves: clingleftwall # sets x+y like zoy
  - comb: # ambient rhythm to dispatch up (passive), pha con still
Then: |
   the J.d.c ^ suJways:
     - curves hooks up, but we have the compression living in the J for reinit
    # somewhere to:
      find the W M V I top level index of things...
      unfold from there
      tinier Jhead
     intersplice maka replacement

