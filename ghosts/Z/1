
Ray: 
 - K: J
   findway: R_J
hooks:
  elv: |
    $R = G.theJ;
    Rw elv $m;
  percolate_R: | # capow! R
    G.theJ = $G->R('J');
  percolate: |
    my $R = G.theJ;
    Rw olde;
R_Jz:
 - K: olde #c
   D: |
     Rw zoybracken;
     
 - K: expro #c
   D: |
     Rw exprob;
     my $z = "ඬƾ";
     
     Rw zoybracken;
     
     Rw zoc;
     
     Rw fresh_init;
     Rw any_init;
 - K: zoybracken #c embed ww # a super JJJ
   D: |
     G.oin ?
     Rw up $J:G.oin
     :
     Rw JJJ join;
 - K: join #c
   n_D:
     yJ: |
       G.oin = $J;
       'join clw'
     up: |
       # G.oin root ww:
       Rw J5 wu;
       # iterations:
       Rw J5 toc;
       
       Rw suck */upon/H.name $J;
     upon:
       K: |
         Rw J5 scr;
         Rw J5 somestyles;
       C: |
         Rw J5 occie; 
     bollox: |
       Rw J5 zoy;
     in: |
       my $oJ = $J; # classic 8 stuf
       $J = G.oin;
       if (my $X = J.bb->{"oJ.name%J\t0.3"}) {
           Rw join/X $J:X;
       }
       Jn(oJ.name, 0.3, {s=>$oJ,J=>$oJ}, {});
       J.idJy->{oJ.id} = $oJ;
     X: |
       my $oJ = $J; # classic 8 stuf
       $J = G.oin;
       $oJ = e.J;
       my $name = oJ.name;
       my $is = J.bb->{"$name%J\t0.3"};
       warn "not latest $name... continuing delete" if $is ne $oJ;
       for my $oJ ($oJ, $is) {
           Rw J5 wu $X:oJ;
           Rw delbbl $J $l:oJ.name;
           oJ.dead = 1; # etcrise
       }
       sayyl "delete is.name";
       if (e.S) {
           Rw J5 $name;
       }
 - K: zoy #c boat for catching/tlv looking the fishes
   n_D:
     yJ: |
       qw'zoy clw heag gui oci'
     up: |
       #n('/',0.91,{}, {});
       my $coi = Rw pha $J $k=3ell;
       Jn(C   => 0.1, {s=>'C',pwth=>'cl/reC'}, '{fs:29,co:b238}');
       
       my $Js = Rw Jnwith $y=clw;
       say wdump $Js;
       
       my $M=[];
       map {
           Mn($_ => '', {s=>$_,pwth=>"J5:$_"});
       } @$Js;
       Rw om/bal $J $oM:M $in=0.2 $out=0.6;
       
       coi.exactl->();
       0->timer(0,sub{
       warn "Hname: H.name";
           Rw suck */upon/H.name $J;
       }) if !ar.J2;
     upon:
       C: |
         Rw J5 shv;
         Rw J5 wo1;
         Rw J5 wam;
       D: |
         Rw J5 wam;
 - K: exprob #c https://soundcloud.com/jsg89g9
   D: |
    (H.name,H.style,my @etc) = reverse @ARGV;
    H.style ||= 'hut';
    H.id = mkuid; 
    H.ol = "H.style/H.name/H.id";
    H.uptime = hitime;   
    say "     H Fresh init H.style H.name";
  
    Rw hostinfo;
    
    my $reS = sub {
        my $m = shift; 
        Rw reS $m;
    };
    $G->su(S => $reS);
    $G->su("S/H.style" => $reS);
    $G->su("S/H.style/H.name" => $reS);
    $G->su("S/H.style/H.name/H.id" => $reS);
    
    $G->timer(60*9+(20 * rand 4), sub {
        return if H.nosuddendeath;
        sayre "voluntary reexec" for 1..13;
        Rw rez;
    });
    
    # start git torrent
    # do it all
    # $0 has become a runtime
 - K: rez #c entropy! the randomness can antrophy
   D: |
     exec("nice perl $0 @ARGV");
 - K: reS #c pump someth Teeth
   D: |
    my $Eb = ar.E->pi."-" if ar.E;
    saybl "$Eb > ".slim(75,80,$m);
    my $j = $m =~ /^\w/ ? $m : djson($m);
    
    #G.reSway->{$way}->($am) if G.reSway->{$way};
    
    if (ref $j eq "HASH") {
        die "hash wide/skinny ".wdump($j) if keys %$j != 1;
        my ($uno) = keys %$j;
        my $ar = {
            j => $j,
            m => $m,
            $uno => $j->{$uno},
        };
        Rw S/$uno;
        # hit or not? see post 6 with r  ### o
        return;
    }  
    
    die "weird shit: '$m'" if ref $j; 
    
    $j =~ /^([\w\/]+)(?: (.+))?$/ ?
        Rw S/$1 $m:2
    :
    die "wei tet '$j'";  
 - K: S # 
   n_D:
     ghostchanges: |
       # nothing, gets compiled and broadcast:
       H.style ne 'shed' && H.style ne 'hut' &&
       Rw loadc;
     wayup: |
       -f $m || die;
       delete G.drop;
       $G->wayup($m);
       Rw wayedup;
     reexec: |
       Rw rez;
     speaks: | # loop conealed elvis 
       Rw reS $m
     event: | # 
      my $e = ar.e = j.event;
      
      G.lastWe = $e if e.W; # \  
      
      if (e.type =~ /^key/ && !e.W && G.lastWe) {
          my $We = G.lastWe;
          for my $k (keys %$We) {
              $e->{$k} = $We->{$k} unless exists $e->{$k};
          }
      }
      
      e.W && return
      Rw S/W;
      warn "Strange". wdump $e;
     W: |
        $e->{$_} =~ /^\w+$/ || delete $e->{$_} for qw'id ux W';
        
        my $meta = $G->tri('W/'.e.W.'.i');
        $meta || return warn "no such e.W ... ".ki 2, $e;
        $meta = djson $meta if $meta;
        
        my $hol = meta.hol;
        G.keysto = $hol;
        
        my $a = {};
        if (my $J = G.Wh->{e.W}) {
            Rw event $J $e;
        }
        elsif ($hol ne H.ol) {
            sayyl "HSW H.ol -> $hol";
            saybl "e: ".wdump($e);
            $G->pub("S/$hol", "speaks $m"); # our json event again over there
        }
        else {
            die "goner";
        }
     hostinfo/ack: | #
        my (@s) = split /\s+/, $m;
        if (rand(1) > 0) {
            my $lag = (1000*sprintf('%.3f',hitime - $s[-1])).'ms';
            saygr "... $lag";
        }
        G.hostinfo_waits = 0;
 - K: hostinfo #c
   D: | # REname Hostinfo, polari
    if (!H.lastinfo) {
        $G->recur(29 => sub {
            Rw hostinfo;
        });
    }
    my @ps = `ps -p$$ fu`; # j right
    my ($u, $pid, $mem, $cpu) = (split /\s+/, $ps[1])[0,1,2,3];
    $_ = $_ / 100 for $cpu, $mem;
    
    my $info;
    info.cpu = $cpu;
    info.mem = $mem;
    info.now = hitime;
    info.hol = H.ol;
    info.pid = $$;
    
    saygr "hostinfo: $info " if rand(1) > 0.7;
    
    # TODO some Purs have core v
    
    $G->tai("H/H.ol", $info);
    
    $G->pub("Hostinfo", "info.hol info.now", 'ig');
    
    $G->pub("Hi" => H.ol) if !H.lastinfo || ar.withHi;
    
    H.lastinfo = $info;
    
    G.hostinfo_waits++;
    if (G.hostinfo_waits > 1) {
        sayre "hostinfo uncollected";
    }
 - K: recoded_init #c wake up
   D: |
     sayre "ANY!"; 
     snooze 33400; 
     Rw suck */recoded_init;
     
     my @wt = keys %{H.G.lastGd};
      
     my $kno = Load(<<'')->{H.name};
     C:
       W/9: ps
       W/3: hull
       W/4: ash
       W/1: ollox
       or: wo1
     K:
       or: scr
     D:
       or: ghosts
     
      
     for (@wt) {
      saybl "for $_";
         sleep 1;
         my $wu = $1 if /ghosts\/(.+)$/;
         
         my $wh = $kno->{$wu} || kno.or;
         
         saybl "recoded_init Wu: $wu -> $wh";
         undef $wh if $wh eq 'ash' && H.name ne 'D';
         $wh || next;
         Rwyl 0.05 J5 $name:wh; 
     }
     
     my (@em) = Rw figure_lux;
 - K: fresh_init #c
   D: |
     Rw suck */fresh_init;
  
 - K: any_init #c
   D: |
     Rw suck */any_init;
  
 - K: elv #c is online
   D: |
     saybl " Elvis e !: $m";
     sleep 1 if H.name ne 'K';
     H.G w reexec;


 - K: toc #c
   n_D:
     yJ: |
       'toc'
     around: |
       Rw vortex $J up $d=4;
     up: | #
       # hops, rhythm aesthetics
       # things pur ambiently & incur pipes of sprawlingness into music
       # to space it out right...
       # for the mass of the atom of thought
       # wants emit with precision, figure processing/Em route into time
       
       my $oJ = G.oin;
       my $ip = {style=>'wantime'};
       my @timey = Rw tvo $J:oJ $ip;
       my @go;
       for my $j (@timey) {
           my $y = j.s;
           my $x = J.bb->{"j.l%timex\t0.3"};
           $x += $d; # vortex 4s
           if ($x >= $y) {
               $x = 0;
               push @go, oJ.bb->{"j.l%J\t0.3"} || die "no find j.l oin";
           }
           else {
               #say "ti $x -- $y";
           }
           J.bz->("j.l%timex\t0.3" => $x);
       }
       for my $J (@go) {
           sayyl "toc up: J.name";
           Rw up $J;
       }
       #say 'timing '.join', ', map{_.l} @timey;
       #saybl "makde ".F_delta();
 - K: vortex #c do recur while J as in G.oin
   D: |
     my $m = ar.m||[];
     my $d = ar.d||4;
     my $o = Rw pul $cs:m way;
     o.way || die;
     
     my $loopr = J.name."%loopid#o.way\t0.3";
     my $id = G.oin.bb->{$loopr};
     saybl "timer replaco J.name o.way" if $id;
     # if last hit and delta are whack
     # tiny hairs of sanity
     Mojo::IOLoop->remove($id) if $id;
     
     my $bl = {};
     bl.id = 
     G.oin.bb->{$loopr} = 
         $G->recur($d => sub {
             return Mojo::IOLoop->remove(bl.id)
                 if G.oin.bb->{$loopr} ne bl.id;
             Rw o.way $J $d;
         });

     
Juping: |
  # anything in j.t should be fine
  # parse j.r in one regex, tightened at the right (cv) end
  # First need a top level J for holding all the others while they are alive, 8ing
  # 
Jo: # fills the rhymth dispatcher J
 -
  - oyo
  - ''
  - curves: clingleftwall # sets x+y like zoy
  - comb: # ambient rhythm to dispatch up (passive), pha con still
Then: |
   the J.d.c ^ suJways:
     - curves hooks up, but we have the compression living in the J for reinit
    # somewhere to:
      find the W M V I top level index of things...
      unfold from there
      tinier Jhead
     intersplice maka replacement

