R_Jz:
 - K: zoy #c boat for catching/tlv looking the fishes
   n_D:
     yJup: |
       qw'zoy oci'
     curves: |
       spun 0  2
       y    0  0
       x    0  0.02
       zoom 0.1 0.5
       curve 0.1 -0.4
     up: |
       Rw Jhead;
       Jn('shelf', 0.1, {pi=>'shelfo'}, {bo=>'3px solid 8df'});
       
       Rw zoybracken $afterid:u.at.id;
 - K: pi/shelfo #c mhmm
   D: |
     Jn('yop', 0.8, 'top');
 - K: zoybracken #c embed ww
   D: |
     #return sayre "NONREPEAT G_oin" if G.oin;
     
     my $J = G.oin = Rw JJ $name=join;
     
     my $oJ = Rw JJJJ $J er;
     
     oJn('/', 0.9, {}, '{tag:ww,bo:1em solid #df3}');
     
     
     my $h = Rw maka $J:oJ;
     say $h;
     #my $h = "<bb>yab</bb>";
     #Rw adJ $J $J2:J;
     
     # had a spot like a parrot
     E(sayyl " \$('#' + \$('#$afterid').parent().attr('id') + ' ww').remove();");
     E(sayyl " \$('#$afterid').after(".ejson($h).");");
     sayyl "Jid: J.id";
     # eat bees, up reports
     $J
 - K: er
   n_D:
     yJup: |
       'er'
 - K: JJJJ #c
   D: |
     die unless G.oin;
     # pul from $m $name $style ?
     my $name = shift @$m;
     my $style = join ' ', @$m;
     my $J2 = Rw JJ $name $style;
     J2.most.J = $J;
     J2.Jo = $J;
     Jn(J2.name => 0.4, {J=>$J2});
     J.oJ->{J2.name} = $J2;
     $J2;
 - K: JJJ #c
   D: |
     die unless G.oin;
     my $J = Rw JJ $name;
     Rw adJ $J2:J $J:G.oin;
 - K: adJ #c embed J
   D: |
     J2.name || die;
     J2.r && die;
     Jn(J2.name, 0.3, {s=>$J2,J=>$J2}, {});
 - K: JJ #c make J that most.J = self
   D: |
     my $J = {};
     J.name = $name;
     J.style = ar.style ? ar.style : ar.m ? @{ar.m} : $name;
     J.style = [split /\s+/, J.style] if !ref J.style;
     J.most.J = $J;
     
     Rw mkJid $J;
     
     Rw suJ $J;
     
     J.bz->("/\t0.9" => "y");
     
     Rw Jup $J;
     
     # inject G.on
     
     $J
 - K: suJ #c bbdomining for any sorta J
   D: |
     J.bb = {};
     J.ord = [];
     J.bz = Rw as $J;
     J.phy = {};
     J.phl = {};
     
     J.idyl = sub {
         my ($J, $id, $oj) = @_;
         J.most.J.idly->{$id} = {J=>$J, j=>$oj};
     };
     
     # 3
     # 4
 - K: Jup #c
   D: |
     J.yt = {};
     my $exp;$exp = sub {
         my $s = shift;
         my @wk = uniq
             grep{length} map {split /\s+/}
             Rw suck + $pin=$s/yJup;
         #saybl " - sty $s -> @wk" if @wk;
         for my $k (@wk) {
             next if exists J.yt->{$k}; # many styles leading to the same style
             J.yt->{$k} ||= {};
             $exp->($k);
         }
     };
     $exp->($_) for @{J.style};
     die "no style for   @{J.style}   (J.name)" if !%{J.yt};
     saygr "J.name yJup: ".join(' + ', @{J.style})." -> ".join(' ~ ', sort keys %{J.yt});
 - K: join #c
   n_D:
     yJup: |
       'clingleftwall'
     up: | #
       my $ls = Rw tlv
       # makes a pile to see/curve in J.up, tiny geos? things hop
 - K: clingleftwall/curves #c
   D: |
       spun 0  2
       y    0  0.4
       x    0  0.32
Juping: |
  # anything in j.t should be fine
  # parse j.r in one regex, tightened at the right (cv) end
  # First need a top level J for holding all the others while they are alive, 8ing
  # 
Jo: # fills the rhymth dispatcher J
 -
  - oyo
  - ''
  - curves: clingleftwall # sets x+y like zoy
  - comb: # ambient rhythm to dispatch up (passive), pha con still
Then: |
   the J.d.c ^ suJways:
     - curves hooks up, but we have the compression living in the J for reinit
    # somewhere to:
      find the W M V I top level index of things...
      unfold from there
      tinier Jhead
     intersplice maka replacement

