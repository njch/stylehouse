
Ray: 
 - K: J
   findway: R_J
hooks:
  percolate_R: | # capow! R
    G.theJ = $G->R('J');
  percolate: |
    my $R = G.theJ;
    Rw zoybracken;
R_Jz:
 - K: Em #c send love
   D: |
     # aj.id is the J zipped .c to E in one, stream?
     aj.Wid || die "not Wid?";
     aj.hol = "H.style/H.name/H.id";
     aj.hitime = hitime;
     aj.name ||= aj.J.name;
     # also some J.headlev readings for .i
     
     G0.Wh->{aj.Wid} ||= do {
         my $ij = {}; map {
         $ij->{$_} = $aj->{$_} if !/^[sc]+/; } keys %$aj;
         ij.id = delete ij.Wid;
         ij.y = 'W';
         
         sayyl "Life! of ij.y ij.id";
         0->tai("ij.y/ij.id\.i", $ij);
         0->tac("V/H.style/H.name/H.id\.s", ztm($ij));
         G0.WhR->{aj.Wid} = $R;
         aj.J;
     };

     Rw J5 wu $aj;
     
     aj.y ||= 'J';
     aj.yy = 'W';
     Rw aji $aj;
     Rw blabaj $aj;
 - K: aji #c
   D: |
     my $z = ztm($aj);
     if (aj.yy) {
         0->tac("aj.yy/".$aj->{aj.yy.'id'}.'.s', $z);
     }
     my $m = join "\n", map {@{$aj->{$_}}} sort grep{/^[sc]+/} keys %$aj;
     0->tai("aj.y/aj.id\.c", $m);
     0->tac("aj.y\.s", $z);
     
 - K: blabaj #c
   D: |
     saybl "E    aj.name    aj.yy/".$aj->{aj.yy.'id'}."   (  aj.id";
     for my $k (sort grep{/^[sc]+/} keys %$aj) {
         my $v = $aj->{$k};
         if (ref $v eq 'ARRAY') {
             saybl "$k => ".@$v;
             map { saybl slim $k eq 'c' ? 690 : 90, $_ } @$v 
         }
         else {
             saybl "$k    => ".slim 80, $v;
         }
     }
 - K: wu #c cattach anything under ww, trainyard, patch bay, hash out space <body>
   n_D:
     yJ: |
       'wu'
     around: |
       J.stup ||= Rw wu/wup;
       ar.aj ?
          Rw wu/ajwu
       :
       ar.X ?
          Rw wu/unwu
       :();
     wup: | # non self id wirdness
       J.stup = 1; # as we Em->wu
       Jn('/', 0.9, {}, "{id:J.id,tag:ww,ab:100,zi:1,bgh:33.5.3.1}");
       my $ip = {l=>'/'};
       say " _.r               _.s"for
       Rw tvo $J $ip;
       
       my $aj = Rw may $J $catj=1 $ip;
       if (my $s = delete aj.s) { # OUR ww/ a W multiplex of Ws
           unshift @{aj.c}, jsq " \$('#ux').append(%s);", $s;
       }
       Rw Em $aj;
       $aj;
     ajwu: |
       # transact aj into W...
       # a.wu is blob kinda a.o
       #Jn(aj.Wid, 0.2, {tsup=>'1'});
       #Jn(aj.Wid.'/'.aj.id, 0.3,
       if (my $s = delete aj.s) { # first timey, otherwise C knows all
           unshift @{aj.c}, jsq 
               " a\.wu(%s, %s, %s);",
               J.id, aj.Wid, $s;
       }
       $aj;
     unwu: |
       if (my $J = X.oJ.A) {
           Rw around $J $X;
       }
       else {
           die "kill no oJ: X.name X.id";
       }
       
 - K: zoy #c boat for catching/tlv looking the fishes
   n_D:
     yJ: |
       qw'zoy headi oci mayo'
     curves: |
       spun 0  3
       y    0  0
       x    0  0.02
       zoom 0.1 0.5
       curve 0.3 -0.2
     up: |
       Rw Jhead;
       Jn(C   => 0.1, {s=>'C',pwth=>'cl/reC'}, '{fs:29,co:b238}');
       Jn(wam => 0.2, {s=>'wam',pwth=>'J5:wam'});
       Jn(oot => 0.3, {s=>'oot',pwth=>'J5:oot'});
       Rw suck */upon/H.name $J;
       Rw oJ $J geo &up;
     upon:
       C: |
         Rw J5 wam;
 - K: wam #c 
   n_D:
     yJ: |
       'wam mayo clw headi'
     up: | # if the in up, pha wakeups out - all response to editing
       Rw Jhead;
       
       my $oJ = Rw oJ $J on filey;
       
       oJn( twang => 0.2 => 'Z/2');
       
       Rw up $J:oJ;
       
       # bounce different ways...
       # hire a Con...
       # requireway, with parameters
       # then patch bay for groups of style to feed in
       # also the other elements present in may...
       # farmed out
       
       my $onl = Rw very $in=0.4 $out=0.9 $J:oJ $tot:J.cv;
       
       # pin down top level
       # primitives for geo site
       for my $x (@$onl) {
           Rw ix/suro + $x;
       }
       
       Jn(wamo => 0.2, {s=>'wam',pwth=>'J5:wam'}); 
       
       Rw oJ $J geo &up;
 - K: filey #c
   n_D:
     yJ: |
       'filey'
     uplv: |
       my $sc;
       if (!lv.sc) {
           say "INIT STYLO ".ejson $lv;
           if (j.s =~ /^[A-Z0]/) {
               sc.ou = 'file';
               sc.dir = 'ghosts/';
           }
           # looking at this J's abilities to upgrade string input with ou thinkg/crawl
       }
       Rw jamsc $J $j $sc;
 - K: jamsc #c 
   D: |
     return if !$sc;
     for my $k (sort keys %$sc) {
         my $v = $sc->{$k};
         J.bb->{"j.l%$k\t".j.cv} = $v;
     }
     
 - K: on #c
   n_D:
     yJ: |
       J.yl.nojb = 1;
       'on';
     up: | # tak tlv J.on into iterations of upgoing clever
       my $vs = Rw tyv $J $ip:ar.ip;
       
       for my $lv (@$vs) {
           my $j = lv.j;
           my $k = "j.r xatly";
           my $coi = Rw pha $J $k;
           #sayyl " ** *  lv.j.r     =>   lv.j.s\n*  *  ".ki(lv.sc);
           my $ln = Rw linehum $lv;
           
           Rw suck */uplv $J $lv $j;
           
           #my $xat = Rw lv_same $lv $x:coi $J;
           #say "xat" if $xat;
           coi.end->();
       }
       
       
 - K: ou/file #c
   D: |
     my $file = x.j.s;
     defined $file || die 'nofile';
     if (my $dir = sc.dir) {
         $dir .= '/' if $dir !~ /\/$/;
         $file = "$dir$file";
     }
     my $J = Rw J5 fil;
     my $fJ = Rw around $J $file;
     my @o = Rw around $J:fJ;
     say "FIL:". wdump \@o;
     
 - K: fil #c
   n_D:
     yJ: |
       'fil'
     around: |
       ar.file ?
          Rw fil/ile
       :();
     ile: |
       my $fid = slm 8, dig $file;
       my $fJ = J.bb->{"$fid\t0.1"};
       if (!$fJ) {
           $fJ = Rw oJ $J $name=lie.$fid $style=lie;
           fJ.bz->("file\t0.1" => $file);
           J.bz->("$fid\t0.1", $fJ, '%file'=>$file);
       }
       $fJ
 - K: flu #c creativity is a disease
   n_D:
     yJ: |
       'flu'
     around: |
       ar.cJ ?
           Rw flu/cod
       :();
     cod: |
       sayre "Her 09i 93i9" for 1..3;
       my $h = slm 6, dig ejson[cJ.style,$name];
       
       my $oJ = G.drop.flows->{$h};
       return $oJ if $oJ;
       
       $oJ = Rw oJ $J $name=flz.$h;
       
       Rw thy $oJ $J:cJ flows/$name
       ||
       sayyl("Flaginate!") &&
       Rw flaginate $J:oJ $oJ:J;
       
       $oJ
       
 - K: perc #c
   D: |
     my $vs = Rw tyv $J;
     for my $lv (@$vs) {
         my $j = lv.j;
         #my $coi = Rw pha $J $k=j.r;
         #my $xat = Rw lv_same $lv $x:coi $J;
         #my $y = coi.exactl->();
         sayyl "j.r   is j.s";
     }
     
 - K: flow #c K-flow
   D: |
     my $name = $m->[0];
     my $uJ = Rw J5 flu;
     my $oJ = Rw around $J:uJ $cJ:J $name;
     
     #die wdump $oJ;
     #fol
     
     
     
     
     
     
     
     
     
     #fol
 - K: lie #c
   n_D:
     yJ: |
       'lie'
     flows:
       folate: |
         filesitu 0.1
         fileopen 0.2
         filejam 0.3
         filesow
     around: |
       J.cv ||= 0.3;
       
       Rw flow $J folate;
       
       return map { "_.r           _.s" }
       Rw tvo;
 - K: zoybracken #c embed ww # a super JJJ
   D: |
     my $J = G.oin;
     if (!$J) { # START
         # has to do this instead of JJJ
         $J = Rw JJJ join;
     }
     else {
         Rw up $J;
     }
     $J
 - K: join #c
   n_D:
     yJ: |
       G.oin = $J;
       'join clw'
     up: |
       # G.oin root ww:
       Rw J5 wu;
       # iterations:
       Rw J5 toc;
       
       Rw suck */upon/H.name $J;
     upon:
       K: |
         # compressions:
         Rw J5 scr;
         # styles:
         Rw J5 sts;
       C: |
         # statspastic css compressions:
         Rw J5 occie;

         Rwyl 0.0001 join/bollox;
     bollox: |
       Rw J5 zoy;
       
       my $ip = {style=>'J'};
       sayyl "J.name  J.id  : ".join'     ',
           map {"_.l(".keys %{_.s.bb}}
           Rw tvo $J $ip;
     in: |
       my $oJ = $J; # classic 8 stuf
       $J = G.oin;
       if (my $X = J.bb->{"oJ.name%J\t0.3"}) {
           Rw join/X $J:X;
       }
       Jn(oJ.name, 0.3, {s=>$oJ,J=>$oJ}, {});
       J.idJy->{oJ.id} = $oJ;
     X: |
       my $oJ = $J; # classic 8 stuf
       $J = G.oin;
       my $is = J.bb->{"oJ.name%J\t0.3"};
       warn "not latest oJ.name... continuing delete" if $is ne $oJ;
       
       Rw J5 wu $X:oJ;
       Rw delbbl $J $l:oJ.name;
       oJ.dead = 1; # etcrise
       sayyl "delete is.name";
 - K: scr #c 
   n_D:
     yJ: |
       J.yy.may.noroot = 1;
       'scr clw mayo'
     up: | # if the in up, pha wakeups out - all response to editing
       Rw thy $J comprsc;
       Rw thy $J canvas;
       Rw thy $J other;
       
       #Rw thy $J youtube;
 - K: geo #c
   n_D:
     yJ: |
       'geo'
     up: |
       my $sr = J.Jo;
       
       saybl "geo of sr.name";
       
       Rw thy curves $J:sr $oJ:J
       ||
       Rw geolo $J;
       
       Rw oJ $J phz &up;
 - K: phz #c transfer
   n_D:
     yJ: |
       'phz'
     up: |
       my $geo = J.Jo;
       my $io = J.Jo.Jo;
       Rw phairo $J $oJ:io $geo;
       
       Rw outhere $J $oJ:io;
 - K: mayo #c
   n_D:
     yJ: |
       'mayo'
     out: |
       Rw may $J;
     
       
 - K: geomay #c
   n_D:
     yJ: |
       'mayo'
     out: |
       Rw oJ $J geo &up;
       Rw may $J;
     
       
 - K: clw #c
   n_D:
     curves: |
       spun 0  2
       y    0  0.3
       x    0  0
       zoom 0.1 0.5
       curve 0.3 -0.2
 - K: oJ #c materialise G.oin.oJ.$name or J.oJ.$name
   D: |
     my $oJ = ar.J || G.oin;
     my $wha = $1 if ar.m && ar.m->[-1] =~ /^&(.+)$/ && pop @{ar.m};
     # squiggly time reconvogation
     # golden mean swivels
     my $o = Rw pul + name style+;
     if (o.name) {
         $oJ = oJ.oJ->{o.name} || do {
             Rw JJJJ $J:oJ $o;
         };
     }
     if ($wha) {
         Rw $wha + $J:oJ;
     }
     $oJ;
     
 - K: adJ #c embed J & GO AROUND
   D: |
     Rw join/in $J;
     J.name || die;
     J.r && die;
     ar.noround ||
     Rw around $J;
 - K: J5 #c & Jmod cs like, resume/resync by name, JJJ underneath, hits */around (update or up) 
   D: |
     my $o = Rw pul + name style+;
     my $J = G.oin.bb->{o.name."\t0.3"};
     my $is = " *" if $J;
     
     sayyl " JJJJJ  o.name$is";
     $J ||= Rw JJJ $o;
     
     Rw around + $J;
     
     $J
 - K: JJJJ #c from $J above, emb   J.oJ.$name = $J2   and   J2.Jo = $J
   D: |
     die unless G.oin;
     my $J2 = Rw JJ;
     J2.most.J = $J;
     J2.Jo = $J;
     J.oJ->{J2.name} = $J2;
     sayyl "J J J J  J2.name";
     $J2;
 - K: JJJ #c G.oin embedding spawn # 3 = REPLACEY, see J5 for ambient arounding
   D: |
     my $J = Rw JJ;
     sayyl " J J J  J.name";
     Rw adJ $J;
     $J
 - K: JJ #c make J that most.J = self
   D: |
     my $J = {};
     my $o = ar.o ||
         Rw pul + name style+;
     J.name = o.name;
     o.style = join ' ', @{o.style} if ref o.style;
     delete o.name if o.name =~ /\./;
     J.style = o.style || o.name;
     J.style = [split /\s+/, J.style] if !ref J.style;
     J.most.J = $J;
     
     Rw mkJid $J;
     
     Rw suJ $J;
     
     Rw Jup $J;
     
     $J
 - K: suJ #c bbdomining for any sorta J
   D: |
     J.bb = {};
     J.ord = [];
     J.bz = Rw as $J;
     J.phy = {};
     J.phl = {};
     
     J.idyl = sub {
         my ($J, $id, $oj) = @_;
         J.most.J.idly->{$id} = {J=>$J, j=>$oj};
     };
     
     # 3
     # 4
 - K: Jup #c behaviouriser (lingo)
   D: |
     push @{J.style}, J.name if J.name !~ /\./ && !grep{$_ eq J.name} @{J.style};
     J.yt = {};
     my $exp;$exp = sub {
         my $s = shift;
         my @wk = uniq
             grep{length} map {split /\s+/}
             Rw suck + $pin=$s/yJ;
         for my $k (@wk) {
             next if exists J.yt->{$k}; # many styles leading to the same style
             J.yt->{$k} ||= {};
             $exp->($k);
         }
     };
     $exp->($_) for @{J.style};
     warn "no style for   @{J.style}   (J.name)" if !%{J.yt};
     saygr "J.name yJup: ".join(' + ', @{J.style})." -> ".join(' ~ ', sort keys %{J.yt});
 - K: toc #c
   n_D:
     yJ: |
       'toc'
     around: |
       Rw vortex $J up $d=4;
     up: | #
       # hops, rhythm aesthetics
       # things pur ambiently & incur pipes of sprawlingness into music
       # to space it out right...
       # for the mass of the atom of thought
       # wants emit with precision, figure processing/Em route into time
       
       my $oJ = G.oin;
       my $ip = {style=>'wantime'};
       my @timey = Rw tvo $J:oJ $ip;
       my @go;
       for my $j (@timey) {
           my $y = j.s;
           my $x = J.bb->{"j.l%timex\t0.3"};
           $x += $d; # vortex 4s
           if ($x >= $y) {
               $x = 0;
               push @go, oJ.bb->{"j.l%J\t0.3"} || die "no find j.l oin";
           }
           else {
               #say "ti $x -- $y";
           }
           J.bz->("j.l%timex\t0.3" => $x);
       }
       for my $J (@go) {
           sayyl "toc up: J.name";
           Rw up $J;
       }
       #say 'timing '.join', ', map{_.l} @timey;
       #saybl "makde ".F_delta();
 - K: vortex #c do recur while J as in G.oin
   D: |
     my $m = ar.m||[];
     my $d = ar.d||4;
     my $o = Rw pul $cs:m way;
     o.way || die;
     
     my $loopr = J.name."%loopid#o.way\t0.3";
     my $id = G.oin.bb->{$loopr};
     saybl "timer replaco J.name o.way" if $id;
     # if last hit and delta are whack
     # tiny hairs of sanity
     Mojo::IOLoop->remove($id) if $id;
     
     my $bl = {};
     bl.id = 
     G.oin.bb->{$loopr} = 
         $G->recur($d => sub {
             return Mojo::IOLoop->remove(bl.id)
                 if G.oin.bb->{$loopr} ne bl.id;
             Rw o.way $J $d;
         });

     
Juping: |
  # anything in j.t should be fine
  # parse j.r in one regex, tightened at the right (cv) end
  # First need a top level J for holding all the others while they are alive, 8ing
  # 
Jo: # fills the rhymth dispatcher J
 -
  - oyo
  - ''
  - curves: clingleftwall # sets x+y like zoy
  - comb: # ambient rhythm to dispatch up (passive), pha con still
Then: |
   the J.d.c ^ suJways:
     - curves hooks up, but we have the compression living in the J for reinit
    # somewhere to:
      find the W M V I top level index of things...
      unfold from there
      tinier Jhead
     intersplice maka replacement

