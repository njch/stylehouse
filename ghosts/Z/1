
Ray: 
 - K: J
   findway: R_J
hooks:
  elv: |
    $R = G.theJ;
    Rw elv $m;
  percolate_R: | # capow! R
    G.theJ = $G->R('J');
  percolate: |
    my $R = G.theJ;
    
       Rw zoybracken;
R_Jz:
 
 - K: expro #c
   D: |
     Rw exprob;
     my $z = "ඬƾ";
     
     Rw zoybracken;
     
     Rw fresh_init;
     Rw any_init;
 - K: rez #c entropy! the randomness can antrophy
   D: |
     exec("nice perl $0 @ARGV");
 - K: reS #c pump someth Teeth
   D: |
    my $Eb = ar.E->pi."-" if ar.E;
    saybl "$Eb > ".slim(75,80,$m);
    my $j = $m =~ /^\w/ ? $m : djson($m);
    
    #G.reSway->{$way}->($am) if G.reSway->{$way};
    
    if (ref $j eq "HASH") {
        die "hash wide/skinny ".wdump($j) if keys %$j != 1;
        my ($uno) = keys %$j;
        my $ar = {
            j => $j,
            m => $m,
            $uno => $j->{$uno},
        };
        Rw S/$uno;
        # hit or not? see post 6 with r  ### o
        return;
    }  
    
    die "weird shit: '$m'" if ref $j; 
    
    $j =~ /^([\w\/]+)(?: (.+))?$/ ?
        Rw S/$1 $m:2
    :
    die "wei tet '$j'";  
 - K: S # 
   n_D:
     ghostchanges: |
       # nothing, gets compiled and broadcast:
     wayup: |
       -f $m || die;
       $G->wayup($m);
     reexec: |
       Rw rez;
     speaks: | # loop conealed elvis
       Rw reS $m
     event: | #
      my $e = ar.e = j.event;
      
      G.lastWe = $e if e.W; # \
      
      if (e.type =~ /^key/ && !e.W && G.lastWe) {
          my $We = G.lastWe;
          for my $k (keys %$We) {
              $e->{$k} = $We->{$k} unless exists $e->{$k};
          }
      }
      
      e.W && return
      Rw S/W;
      warn "Strange". wdump $e;
     W: |
        $e->{$_} =~ /^\w+$/ || delete $e->{$_} for qw'id ux W';
        
        my $meta = $G->tri('W/'.e.W.'.i');
        $meta || return warn "no such e.W ... ".ki 2, $e;
        $meta = djson $meta if $meta;
        
        my $hol = meta.hol;
        G.keysto = $hol;
        
        my $a = {};
        if (my $J = G.Wh->{e.W}) {
            Rw event $J $e;
        }
        elsif ($hol ne H.ol) {
            sayyl "HSW H.ol -> $hol";
            saybl "e: ".wdump($e);
            $G->pub("S/$hol", "speaks $m"); # our json event again over there
        }
        else {
            die "goner";
        }
     hostinfo/ack: | #
        my (@s) = split /\s+/, $m;
        if (rand(1) > 0) {
            my $lag = (1000*sprintf('%.3f',hitime - $s[-1])).'ms';
            saygr "... $lag";
        }
        G.hostinfo_waits = 0;
 - K: exprob #c https://soundcloud.com/jsg89g9
   D: |
    H.style = 'shed';
    H.name = 'C';
    H.id = mkuid;
    H.ol = "H.style/H.name/H.id";
    H.uptime = hitime;   
    say "     H Fresh init H.style H.name";
  
    Rw hostinfo;
    
    my $reS = sub {
        my $m = shift; 
        Rw reS $m;
    };
    $G->su(S => $reS);
    $G->su("S/H.style" => $reS);
    $G->su("S/H.style/H.name" => $reS);
    $G->su("S/H.style/H.name/H.id" => $reS);
    
    $G->timer(60*9+(20 * rand 4), sub {
        return if H.nosuddendeath;
        sayre "voluntary reexec" for 1..13;
        Rw rez;
    });
    
    # start git torrent
    # do it all
    # $0 has become a runtime
 - K: hostinfo #c
   D: | # REname Hostinfo, polari
    if (!H.lastinfo) {
        $G->recur(29 => sub {
            Rw hostinfo;
        });
    }
    my @ps = `ps -p$$ fu`; # j right
    my ($u, $pid, $mem, $cpu) = (split /\s+/, $ps[1])[0,1,2,3];
    $_ = $_ / 100 for $cpu, $mem;
    
    my $info;
    info.cpu = $cpu;
    info.mem = $mem;
    info.now = hitime;
    info.hol = H.ol;
    info.pid = $$;
    
    saygr "hostinfo: $info " if rand(1) > 0.7;
    
    # TODO some Purs have core v
    
    $G->tai("H/H.ol", $info);
    
    $G->pub("Hostinfo", "info.hol info.now", 'ig');
    
    $G->pub("Hi" => H.ol) if !H.lastinfo || ar.withHi;
    
    H.lastinfo = $info;
    
    G.hostinfo_waits++;
    if (G.hostinfo_waits > 1) {
        sayre "hostinfo uncollected";
    }
 - K: recoded_init #c wake up
   D: |
     sayre "ANY!"; 
     snooze 33400; 
     Rw suck */recoded_init;
     
     my @wt = keys %{H.G.lastGd};
      
     my $kno = Load(<<'')->{H.name};
     C:
       W/9: ps
       W/3: hull
       W/4: ash
       W/1: ollox
       or: wo1
     K:
       or: scr
     D:
       or: ghosts
     
      
     for (@wt) {
      saybl "for $_";
         sleep 1;
         my $wu = $1 if /ghosts\/(.+)$/;
         
         my $wh = $kno->{$wu} || kno.or;
         
         saybl "recoded_init Wu: $wu -> $wh";
         undef $wh if $wh eq 'ash' && H.name ne 'D';
         $wh || next;
         Rwyl 0.05 J5 $name:wh; 
     }
     
     my (@em) = Rw figure_lux;
 - K: fresh_init #c
   D: |
     Rw suck */fresh_init;
  
 - K: any_init #c
   D: |
     Rw suck */any_init;
  
 - K: elv #c is online
   D: |
     saybl " Elvis e !: $m";
     sleep 1 if H.name ne 'K';
     H.G w reexec;
 - K: overth #c birth canalching
   D: |
     my $name = "shedding_".hitime;
     my $wd = `pwd`;chomp$wd;
     `cd ../; git clone $wd $name`;
     `cd../$name; ln -s ../shed/life`;
     
     
 - K: Em #c send love
   D: |
     # aj.id is the J zipped .c to E in one, stream?
     aj.Wid || die "not Wid?";
     aj.hol = "H.style/H.name/H.id";
     aj.hitime = hitime;
     aj.name ||= aj.J.name;
     # also some J.headlev readings for .i
     
     G.Wh->{aj.Wid} ||= do {
         my $ij = {}; map {
         $ij->{$_} = $aj->{$_} if !/^[sc]+/; } keys %$aj;
         ij.id = delete ij.Wid;
         ij.y = 'W';
         
         sayyl "Life! of ij.y ij.id";
         0->tai("ij.y/ij.id\.i", $ij);
         0->tac("V/H.style/H.name/H.id\.s", ztm($ij));
         aj.J;
     };

     Rw J5 wu $aj;
     
     aj.y ||= 'J';
     aj.yy = 'W';
     Rw aji $aj;
     Rw blabaj $aj;
 - K: aji #c
   D: |
     my $z = ztm($aj);
     if (aj.yy) {
         0->tac("aj.yy/".$aj->{aj.yy.'id'}.'.s', $z);
     }
     my $m = join "\n", map {@{$aj->{$_}}} sort grep{/^[sc]+/} keys %$aj;
     0->tai("aj.y/aj.id\.c", $m);
     0->tac("aj.y\.s", $z);
     
 - K: blabaj #c
   D: |
     saybl "E    aj.name    aj.yy/".$aj->{aj.yy.'id'}."   (  aj.id";
     
     for my $k (sort grep{/^[sc]+/} keys %$aj) {
         my $v = $aj->{$k};
         if (ref $v eq 'ARRAY') {
             saybl "$k => ".@$v;
             map { saybl slim $k eq 'c' ? 290
             #690
             : 90, $_ } @$v 
         }
         else {
             saybl "$k    => ".slim 80, $v;
         }
     }
 - K: wu #c cattach anything under ww, trainyard, patch bay, hash out space <body>
   n_D:
     yJ: |
       'wu'
     around: | 
       J.stup ||= Rw wu/wup;
       ar.aj ?
          Rw wu/ajwu
       :
       ar.X ?
          Rw wu/unwu
       :();
     wup: | # non self id wirdness
       J.stup = 1; # as we Em->wu
       Jn('/', 0.9, {}, "{id:J.id,tag:ww,poi:0,ab:100,bgh:33.5.3.1}");
       G.Wid = J.id;
       my $ip = {l=>'l'};
       my $aj = Rw may $J $catj=1 $ip;
       if (my $s = delete aj.s) { # OUR ww/ a W multiplex of W uxy
           unshift @{aj.c}, jsq " \$('#ux').append(%s);", $s;
       }
       Rw Em $aj;
       $aj;
     ajwu: |
       # transact aj into W...
       # a.wu is blob kinda a.o
       #Jn(aj.Wid, 0.2, {tsup=>'1'});
       #Jn(aj.Wid.'/'.aj.id, 0.3,
       # ux 7 APADO
       if (my $s = delete aj.s) { # first timey, otherwise C knows all
           unshift @{aj.c}, jsq
               " a\.wu(%s, %s, %s);",
               J.id, aj.Wid, $s;
           
       }
       if (H.name ne 'V' && (aj.J.yt.clw || aj.J.yt.cly)) {
           Rwyl 0.0005 J5 shv $i:aj.J;
       }
       $aj;
     unwu: |
       if (my $J = X.oJ.A) {
           Rw around $J $X;
       }
       else {
           die "kill no oJ: X.name X.id";
       }
       
 - K: zoy #c boat for catching/tlv looking the fishes
   n_D:
     yJ: |
       qw'zoy clw headi oci mayo'
     up: |
       #n('/',0.91,{}, {});
       my $coi = Rw pha $J $k=3ell;
       Rw Jhead;
       Jn(C   => 0.1, {s=>'C',pwth=>'cl/reC'}, '{fs:29,co:b238}');
       
       my $Js = Rw Jnwith $y=clw;
       say wdump $Js;
       my $M=[];
       map {
           Mn($_ => '', {s=>$_,pwth=>"J5:$_"});
       } @$Js;
       Rw om/bal $J $oM:M $in=0.2 $out=0.6;
       
       coi.exactl->();
       0->timer(0,sub{
           Rw suck */upon/H.name $J;
       }) if !ar.J2;
       
       Rw oJ $J geo &up;
     upon:
       C: |
         Rw J5 shv;
         Rw J5 wo1;
         Rw J5 wam;
       D: |
         Rw J5 wam;
 - K: Jnwith #c
   D: |
     my $ty = Rw wuck - */yJ;
     my @n;
     while (my ($k,$v) = each %$ty) {
         my $n = $1 if $k =~ /^(.+)\/yJ$/;
         push @n, $n if $v =~ /\b$y\b/;
     }
     [@n]
 - K: zoybracken #c embed ww # a super JJJ
   D: |
     my $J = G.oin;
     if (!$J) { # START
         # has to do this instead of JJJ
         $J = Rw JJJ join;
     }
     else {
         Rw up $J;
     }
     $J
 - K: join #c
   n_D:
     yJ: |
       G.oin = $J;
       'join clw'
     up: |
       # G.oin root ww:
       Rw J5 wu;
       # iterations:
       Rw J5 toc;
       
       Rw suck */upon/H.name $J;
     upon:
       K: |
         Rw J5 scr;
         Rw J5 somestyles;
       C: |
         Rw J5 occie; 
         
         Rwyl 0.0001 join/bollox;
     bollox: |
       Rw J5 zoy;
     in: |
       my $oJ = $J; # classic 8 stuf
       $J = G.oin;
       if (my $X = J.bb->{"oJ.name%J\t0.3"}) {
           Rw join/X $J:X;
       }
       Jn(oJ.name, 0.3, {s=>$oJ,J=>$oJ}, {});
       J.idJy->{oJ.id} = $oJ;
     X: |
       my $oJ = $J; # classic 8 stuf
       $J = G.oin;
       my $name = oJ.name;
       my $is = J.bb->{"$name%J\t0.3"};
       warn "not latest $name... continuing delete" if $is ne $oJ;
       
       Rw J5 wu $X:oJ;
       Rw delbbl $J $l:oJ.name;
       oJ.dead = 1; # etcrise
       sayyl "delete is.name";
       
       if (e.S) {
           Rw J5 $name;
       }

 - K: toc #c
   n_D:
     yJ: |
       'toc'
     around: |
       Rw vortex $J up $d=4;
     up: | #
       # hops, rhythm aesthetics
       # things pur ambiently & incur pipes of sprawlingness into music
       # to space it out right...
       # for the mass of the atom of thought
       # wants emit with precision, figure processing/Em route into time
       
       my $oJ = G.oin;
       my $ip = {style=>'wantime'};
       my @timey = Rw tvo $J:oJ $ip;
       my @go;
       for my $j (@timey) {
           my $y = j.s;
           my $x = J.bb->{"j.l%timex\t0.3"};
           $x += $d; # vortex 4s
           if ($x >= $y) {
               $x = 0;
               push @go, oJ.bb->{"j.l%J\t0.3"} || die "no find j.l oin";
           }
           else {
               #say "ti $x -- $y";
           }
           J.bz->("j.l%timex\t0.3" => $x);
       }
       for my $J (@go) {
           sayyl "toc up: J.name";
           Rw up $J;
       }
       #say 'timing '.join', ', map{_.l} @timey;
       #saybl "makde ".F_delta();
 - K: vortex #c do recur while J as in G.oin
   D: |
     my $m = ar.m||[];
     my $d = ar.d||4;
     my $o = Rw pul $cs:m way;
     o.way || die;
     
     my $loopr = J.name."%loopid#o.way\t0.3";
     my $id = G.oin.bb->{$loopr};
     saybl "timer replaco J.name o.way" if $id;
     # if last hit and delta are whack
     # tiny hairs of sanity
     Mojo::IOLoop->remove($id) if $id;
     
     my $bl = {};
     bl.id = 
     G.oin.bb->{$loopr} = 
         $G->recur($d => sub {
             return Mojo::IOLoop->remove(bl.id)
                 if G.oin.bb->{$loopr} ne bl.id;
             Rw o.way $J $d;
         });

     
Juping: |
  # anything in j.t should be fine
  # parse j.r in one regex, tightened at the right (cv) end
  # First need a top level J for holding all the others while they are alive, 8ing
  # 
Jo: # fills the rhymth dispatcher J
 -
  - oyo
  - ''
  - curves: clingleftwall # sets x+y like zoy
  - comb: # ambient rhythm to dispatch up (passive), pha con still
Then: |
   the J.d.c ^ suJways:
     - curves hooks up, but we have the compression living in the J for reinit
    # somewhere to:
      find the W M V I top level index of things...
      unfold from there
      tinier Jhead
     intersplice maka replacement

