R_Jz:

 - K: anno/Y #c
   D:
    -
     - cts_Y #
     - 2
     - |
       A.wJ = $wJ;
       A.muav = 1;
       for my $ct (@{wJ.cts.Y}) {
           next unless ct.any or exists $C->{ct.t_k} && exists $C->{ct.t_k}->{ct.t};
           my $v = $C->{ct.t_k}->{ct.t} unless ct.any;
           my $at = {};
           my $T = {};
           my $g = wJ.ctx.Y;
           
           wJ.ctx.Y->{ct.x}->($A,$C,$g,$T,C.y,$v);
       }
 - K: anno/o #c
   D:
   - EZ: anno/Bal
   - MZ: Cy:Y
   -
    - o
    - 2
    - |
      my $o = $v;
      $o = C.y.o = {M=>$o} if ref $o eq 'ARRAY';
      
           o.M ||= [$C];
           
           o.M = [map{
               my $d;
               d.t = _.t;
               d.y = {%{_.y}};
               d.c = {%{_.c}};
               delete d.y.cv;
               # TR
               if (o.ou) { # inside our
                   d.c.pi = o.ou;
                   d.c.s = $_;
               }
               if (o.oJ) {
                    d.sc.oJ = o.oJ;
               }
               #sayyl "     d.t";
               if (my $b = $G->gip(A.J.A.in, d.t)) { # outside in
                   $b = b._;
                   say "d.t in: ".wdump $b;
                   g.extend->($d, $b);
               }
               $d
           }@{o.M}];
           
           
       my $J = A.J;
       my $Jy = J.d.y;
       
       if (my $lt = C.y.limn) {
           my $rl = int(45 * Jy.spc);
           sayre "$rl from Jy.spc";
           $rl = 3 if $rl < 3;
           
           my $was = @{o.M};
           if ($was > $rl) {
               my @um = @{o.M};
               @um = @um[0..$rl-1];
               @{o.M} = @um;
               # space mod
               Jn("lim",0.7,"}$rl<$was");
           }
       }
       
       C.y.bal = o.M || die"nomo";
       
       # unless y unlimited...until
       o.J = J.most.J if $Jy && Jy.o && Jy.spc > 0.1;
       my $shut = $Jy && Jy.o && !o.J;
       
       C.y.over = (Jy.o && Jy.over && Jy.over || 0) + 0.06 if y.o.J;
       
       #sayre "Jyspace: spc:  J.d.y.spc  or aspace: Jy.aspace" if $Jy;
       
       
       C.y.in ||= $shut ? 0.3 : $Jy ? Jy.cv + Jy.spc * 0.1 : 0.1;
       C.y.out ||= $shut ? 0.4 : $Jy ? Jy.ov - Jy.spc * 0.1 : 0.9;
       
       C.c.lumfa = 1 if J.most.J.name eq 'wam'||1;
       
       #sayyl "IS o  J.d.t  J.d.c.pi: " if 1||A.J.V;

   - MZ: Cy:xY
   -
    - extend
    - 3
    - |
      while (my($k,$v) = each %$b) {
          $T->{$k} = ref $v ? {%{$T->{$k}||{}}, %$v} : $v;
      }
    - args: T,b
       
 - K: mooj/i #c
   D:
   - EZ: mooj/BB
   - MZ: Cy:Yany
   -
    - i # build wave manifold, fore loop
    - 1.1
    - |
       C.y = {thi => C.y} if !ref C.y;
   -
    - i # build wave manifold, fore loop
    - 3
    - |
       die "cv+in".k2 $C if y.cv && y.in;
       
       
       y.in ||= 0.1; 
       y.out ||= 0.9; # up to
       y.thi ||= 1; 
       y.space = y.out - y.in; # could spiral much space away from spine
       y.space *= -1 unless y.space > 0;
       y.aspace = y.space / y.thi;
   -
    - i # build wave manifold, fore loop
    - 6
    - |
       # twist, lay into segment
       A.v = defined y.cv ? y.cv : defined y.in ? y.in : die "no yiny".ki$y;
       my $wJ = A.wJ;
       
       for (1..y.thi) {
           my $T = {};
           g.extend->($T, $C);
           T.y.i = $_-1;
           push @{A.is}, $T;
           
           for my $ct (@{wJ.cts.B}) {
               next unless ct.any or exists $C->{ct.t_k} && exists $C->{ct.t_k}->{ct.t};
               my $v = $C->{ct.t_k}->{ct.t} unless ct.any;
               
               wJ.ctx.B->{ct.x}->($A,$C,$g,$T,T.y);
           }
           say "KAp T.t  T.y.cv   T.y.ov" if A.J.V;
       }
       #sayyl wdump 2, A.is;
 - K: anno/Bal #c
   D:
   - EZ: anno/lumfa
   - MZ: Cy:Y
   -
    - bal
    - 2.3
    - |
       y.thi = @$v;
   -
    - bal
    - 4
    - |
      my $total = sum(map { _.y.thy||1 } @$v) || 1;
      my $over = @$v || 1;
      A.muav = $over / $total;
      saygr "Ybal 4 A.muav over  ". @{y.bal} if A.J.V;
 - K: anno/lumfa #c
   D: |
   - MZ: Cc:Y
   -
    - lumfa
    - 3
    - |
      my $lum = 3;
      my $i = 0;
      my $y = C.y;
      y.bal || die "lumfa no ybal ".k2 $C;
      for (@{y.bal}) {
          _.y.thy+=$lum;
          $i++;
          $lum = 2 if $i == 4;
          $lum = 1 if $i == 7;
      }
   - MZ: Cc:B
   -
    - lumfa
    - 5
    - |
      my $spc = T.y.spc;
      my $upt = 0;#0.9 / @{d.y.bal};
      $spc = $upt if $spc < $upt;
      my $fl = ($spc / 0.02) * 4;
      #sayyl "d.t   d.y.ov - d.y.cv  ::: $spc d.y.aspace \t\t $fl";
      d.sc.fs = $fl if $fl < 9;
      #d.sc.tt="d.t at d.y.cv for d.y.spc";
 - K: mooj/BB #c
   D:  
   - MZ: Cy:Bany
   -
    - yinvout # build wave manifold, fore loop, reclimb vines
    - 1.1
    - |
      die "if " if $y ne T.y;
      die "nov" if !A.v;
      y.cv = 0+sprintf '%.6f', A.v;
      y.pcv = 0+sprintf '%.6f', $_ / C.y.thi;
      A.mu = 1;
      saygr "Mad T.t  is T.y.cv  (T.y.i / C.y.thi)" if A.J.V;
   -
    - bally 
    - 3.2
    - |
      my $b = {};
      
      if (C.y.bal) {
          $b = C.y.bal->[y.i] if C.y.bal;
          g.extend->($T, $b);
      }
      
      A.mu = T.y.thy if exists T.y.thy;
      say "A.J.d.t  /  T.t ist A.mu  among A.muav" if A.J.V;
      A.mu = A.mu * A.muav if A.muav;
      #if (J.d.c.cv && b.y.thy) {
      #    say "C.c.cv * C.y.aspace * $mu  === ". (C.c.cv * C.y.aspace * $mu);
      #    b.c.cv ||= J.d.c.cv * C.y.aspace * $mu
      #} 
   -
    - over # cap
    - 4
    - |
      sayyl "T.r   A.v  iwl +=    y.aspace * A.mu    =".(y.aspace * A.mu) if A.J.V;
      A.v += y.aspace * A.mu;
      y.ov = sprintf '%.6f', A.v;
      y.spc = y.ov - y.cv;
      T.r = join "\t", T.t, (y.cv+0);
      #sayyl "T.r ist T.y.cv -> T.y.ov" if A.J.V;
   -
    - yangbalin # 
    - 7
    - |
       $y->{$_} = 0+sprintf('%.6f',$y->{$_}) for qw'cv ov aspace spc';
       
       if (T.y.over) {
           T.sc.ml = (T.y.over * 40)."%"; 
       }

