R_Jz:
 - K: swi #c 
   n_D:
     yJ: |
       'swi clw gui'
     defon: |
       #twang 0.1 Z/2
       #twong 0.1 Z/3
     up: | # if the in up, pha wakeups out - all response to editing
       Jn('some',0.3,'thing!');
       J.V = 1;
       Rw thi afghanrug/mods;
       Jn('ee',0.4,'THINGS!');
       
       Rw on_xor_geo $J $nomay=1 $nogeo=1;
 - K: geomoss/flows/geomo #c
   D: |
     flow 1
     nesting 2
     style 5
     etcs 6
     outs 7
         
       
 - K: shuv/flows/geomo #c
   D: |
     flow 1
     nesting 4
     stiz 3
     sticks 5
     stool 5
     sharp 5
     etcs 6
     outs 7
 - K: geomo/flow #c
   D: |
     # 1
     G.oin.idJy->{J.id} ||= $J;
     
     # 3 spewing two-step
     my $vs = Rw tyv $J;
     my @s;
     
     # 3.9
     for my $lv (@$vs) {
         push @s, $lv;
         my $j = lv.j;
         #saygr wdump 2, lv.sc;
         die "reffy j.s in j.l ON J.name".wdump 3, [ar.ip, $j] if ref j.s;
         
         # 4 #
         my $coi = Rw pha $J:aJ $k:j.r;
         coi.qui = 1;
         my $xat = do {
             Rw lv_same $lv $x:coi $J:aJ;
         } if aJ.bb->{"j.l%at\t".j.cv} && j.l !~ /\//;
         
         
         my $at;
         my $pat;
         my $plv;
         if (!$xat) {
             $at = {css=>[]};
             # 5.2
             at.s = j.s;
             # may be creating, overhead thought
             at.__ajid1 = aj.id;
             
             # 5.4
         }
         # 5.78 at beam
         $pat = aJ.bb->{"j.l%at\t".j.cv};
         $plv = aJ.bb->{"j.l%lv\t".j.cv};
         if (!$xat) {
             aJ.bb->{"j.l%lv\t".j.cv} = $lv;
             aJ.bb->{"j.l%at\t".j.cv} = $at;
             
             coi.exactl->();
         }
         else {
             aJ.bb->{"j.l%lv\t".j.cv} = $lv;
             $at = $pat;
         }
         # 5.8
         # gets self aware in waves
         # above can now trust lvs to have iter-sane E{s,}c[] impulses / same s
         at.__ajid2 = aj.id;
         lv.at = $at;
         
         # 7.9 # heaps ^ all of at outwardsing
     }
     # 8 check lv up cover
     if (J.yy.may.noroot) {
         die 'noroot ag has s'.wdump($_) for grep {_.s} @s;
         aj.c = [map{@{_.Ec||[]}}@s];
         aj.sc = [map{@{_.Esc||[]}}@s];
     }
     else {
         my $lv = aJ.bb->{"/%lv\t0.9"};
         aj.s = lv.s;
         delete aj.s if lv.scon; # no repeat emit
         aj.c = lv.Ec || [];
         aj.sc = lv.Esc || [];
     }
     # 8.8
     if (!ar.catj) {
         Rw Em $aj;
     }
     # 9
     $aj
     
 - K: geomo/nesting #c
   D:
     -
      - backl
      - 1
      - |
       if (!J.yy.may.noroot) {
           exists J.bb->{"/\t0.9"} ||
           J.bz->("/\t0.9", "y", "%tag"=>J.name);
           exists J.bb->{"/%id\t0.9"} ||
           J.bz->("/%id\t0.9", J.id);
       }
     -
      - A
      - 2
      - |
       my $aJ = Rw oJ $J A;
       #  ^ v MMMMMMMMMM aj ejector
       my $aj = Rw up $J:aJ;
     
     -
      - knowone
      - 3.7
      - |
       # know what we are ignoring and destroying
       # bi-pha
       # pingy statechange graphicly allele towers
       # $vs should stretch over aJ as far as any $ip is
       #
       my $now = {map{_.j.r => 1} @$vs};
       for (keys %{aJ.bb}) {
           /^(.+)%.+?\t(\S+)$/||die$_; 
           if (!$now->{"$1\t$2"}) {
               sayre "Gone: $_";
               delete aJ.bb->{$_};
           }
       }
     -
      - vsord
      - 3.2189
      - |
        # puts /s backwards and last:
        $vs = Rw ordlv $J $vs $slashtopi=1;
     -
      - nesto
      - 4.189
      - |
        # >< up from... # carbon hapsso env 
        if (j.l =~ /^(.*)\/$/) {
            X.nestw->($1,$j,$at,$aJ,$lv);
            @s = ();
        }
     -
      - nests
      - 6.189
      - | 
        # eats hoist
        X.nestz->($j,$at,$aJ,$aj,$lv) if at._joins;
        
     - MZ: dorp:X
     -
      - nestw
      - 3
      - |
        my ($p,$j,$at,$aJ,$lv) = @_;
            # grep tw for $1/things
            $p .= '/' if length $p;
            #sayre "looking for '$p' directed";
            my $olvr = "j.l%lv\t".j.cv;
            # assume this/ is for this/*, / is for *
            my @lvs =
                sort { a.j.cv <=> b.j.cv }
                sort{ a.j.r cmp b.j.r }
                grep {_.j.l ne j.l}
                grep {!_.at._jointed || grep {$_ eq $olvr} @{_.at._jointed}}
                # $lv ^
                map {aJ.bb->{$_}}
                grep {/^$p/}
                grep {/%lv\s+\S+$/}
                keys %{aJ.bb};
                
            # j sc may have a motice to grab something
            acum $at, _joins => "_.j.l%lv\t"._.j.cv for @lvs;
            
            _.at || die "no at _.j.r (we j.r)".wdump($_) for @lvs;
            acum _.at, __jointed => $olvr for @lvs;
            
            # really like n.sc.M = [...]
            at.ishtml = 1;
            at.s = '';
     - 
      - nestz
      - 3
      - |
        my ($j,$at,$aJ,$aj,$lv) = @_;
            my @lvs = map { aJ.bb->{$_} } @{at._joins};
            
            say "j.r eats    ".join',   ', map{_.j.r} @lvs;
            # or compressions in c, sc
            # make them tubes real nice
            my @live = grep {_.at.__ajid2 eq aj.id} @lvs;
            my @skip = grep {_.at.__ajid2 ne aj.id} @lvs;
            # can trust lvs c/sc from this aj (pipe/time)
            # circumference
            # future should be all self...
            # el:
            # C[/:ux, 0.3, {id:$id,cl:$class,etc:whatsit}, [
            #   C[Jhead, 0.1, ["yt",:h3YO-zOl82g}, [
            
            
            # hoist at.Cs into our at.C t y c sc ssc
            #
            # assume @live phased will sane s/c/sc
            map { acum $at, 'Esc', $_ for @{_.Ec} } @live;
            map { acum $at, 'Esc', $_ for @{_.Esc} } @live;
            
            # these are flying blind chunks of html in s
            # few replace selves, say lv.scon = 1;
            # make at.s [ [_.j.r => _.s] ... ] and shake down...
            # filter out who is scon'ing for themselves
            # they want to Jtube through us
            at.s = join '', map { _.s } @lvs;
            sayre "Got some lv s should Esc: ".slim 80, at.s if at.s;
            # these are curving down into things
        
               
               

 - K: geomo/style #c
   D:
     -
      - siome #
      - 5.3
      - |
        my ($tks, $cs, $it) = Rw sit geomoss O X $lv;
        #sayre wdump 2, lv.sc;
        #saybl wdump $tks;
        while (1) {
            my ($tk, $com, $v, $tks) = $it->();
            last if !$tk;
            my @s = $X->{$tk}->($v, $tks, $com, $cs, $at, $lv, $J, $j);
        }
     - MZ: dorp:XO
     - WZ: /C may#styley
 - K: geomo/stool #c
   D:
   - MZ: dorp:ctx_V
   - 
    - mktk # language expansion
    - 3
    - |
       my ($_tks, $name, $s) = @_;
       my @t = split ',', $s;
       my $t = {};
       for (@t) {
           my ($k, $v) = split ':', $_;
           $_tks->{$k}->{$name} = $v;
           # or rejoint another trip to $k if passed...
           #sayyl "mktk $name $k : $v";
       }
       return;
   -
    - cole # it
    - 3
    - |
      my $v = shift;
          my $h;
          (h.r, h.g, h.b, h.a) = ($1, $2, $3, $4)
                    if $v =~ /^(\w)(\w)(\w)(\w)?$/ || die "not cole: $v";

          if (defined h.a) {
             # do an rgba(255,255,255,1)
             for my $k (qw'r g b a') {
                 my $e = $h->{$k};
                 $e = "$e$e" if length $e == 1; # out of 255
                 $h->{$k} = hex $e;
             }
             h.la = sprintf '%.2f', h.la / 255; # out of 1
             return "rgba(h.r,h.g,h.b,h.a)";
          }
          else {
             return sprintf "#%s%s%s", h.r, h.g, h.b;
          }
   -
    - hsle # ray lih, unhassley
    - 3
    - |
      my $v = shift;
          my $h;
          if ($v =~ /^(\S+) (\S+) (\S+)(?: (\S+))?$/) {
              (h.h, h.s, h.l, h.a) = ($1, $2, $3, $4);
          }
          elsif ($v =~ /^(\d+)\.(\d+)\.(\d+)(?:\.(\d+))?$/) {
              (h.h, h.s, h.l, h.a) = ('0.'.$1, '0.'.$2, '0.'.$3, '0.'.$4);
          }
          else {
              die "not hsle : $v";
          }
          h.h = h.h * 360 if h.h < 1;
          $h->{$_} = ($h->{$_}*100).'%' for 's','l';

          my $al = ", h.a" if defined h.a;
          "hsl".($al?'a':'')."(h.h, h.s, h.l$al)";
          # 1423
   -
    - empc # decide space unit TODO init soon
    - 3
    - |
      my $v = shift;
       $v .= 'em' if $v !~ /(%|em|px)/;
       $v =~ s/^-?0em$/0%/;
       $v;
 - K: geomo/sharp #c
   D:
   - MZ: sticks:V
   -
    - css
    - 5
    - |
      $v = join ';', map{"$_:$v->{$_}"} sort keys %$v if ref $v eq 'HASH';
      for my $set (split ';', $v) {
          my ($k,$v) = split ':', $set;
          push @{at.css}, "$k:$v;";
          #at.cs->{$k} = $v;
      }
    - way: 1
   - WZ: geomo/shrap
 - K: geomo/shrap #c
   D:
   - #
    - cm
    - 5.8
    - |
      my $wt = ejson {id=>at.id, value=>at.s};
      at.id || die;
      at.dig = sc.dig || die "no diggy";
      acum $at, Esc => " a\.cod($wt);";
      at.s = '';
   - #
    - J
    - 5
    - |
       at.ishtml = 1;
   - #
    - pi
    - 5
    - |
       die "Pi v.r has s" if v.s;
       die "Pi v.r no .Ec" if !@{v.Ec};
       acum $at, 'Esc', $_ for @{v.Ec};
   - #
    - lp
    - 5
    - |
       at.ishtml = 1;

   - #
    - ishtml
    - 5
    - |
       at.ishtml = 1;
   -
    - id
    - 5
    - |
      at.id = $v;
   -
    - tt
    - 5
    - |
      at.title = $v;
   -
    - canvas
    - 5
    - |
      at.canvas = $v;
   -
    - type
    - 5.1
    - |
      at.type = $v;
      at.ishtml = 1;
      at.title = undef;
   -
    - tag
    - 5
    - |
      at.tag = $v;
   -
    - at
    - 5
    - |
      $v =~ /^(?:(\S+):)?(\S+)$/;
      $at->{$1} = $2;
   - #
    - atrp
    - 5
    - |
       at.rp = $v;
   - [path, 5, ''] # TODO compile J.ys
   - [origin ,5, '']
   - [pwar, 5, '']
   - [Joint, 5, '']
   -
    - idly
    - 5
    - |
      my $id = mkuid();
      at.id && die "arl";
      at.id = $id;
      J.idyl->($J, $id, $j);
      #

    
 - K: geomo/sticks #c rejoin the pipelining - form style trance
   D:
    -
     - cts_V #
     - 5.3
     - |
       my $sc;
       sayyl "STEOCKOS :   j.r    ".join' ', sort keys %{lv.sc};
       for my $k (keys  %{lv.sc}) {
           my $v = lv.sc->{$k};
           my $om = $1 if $k =~ s/(#.+)$//;
           $sc->{$k} = $v;
       }
       for my $ct (@{wJ.cts.Y}) {
           next unless exists $sc->{ct.t};
           my $v = $sc->{ct.t};
           wJ.ctx.Y->{ct.x}->($J,$j,$lv,$v,$sc,$at);
       }
       for my $ct (@{wJ.cts.V}) {
           next unless exists $sc->{ct.t};
           my $v = $sc->{ct.t};
           wJ.ctx.V->{ct.x}->($J,$j,$lv,$v,$sc,$at);
       }
       saybl "=------ ".ki 2, $at;
     - way: 1
 - K: geomo/etcs #c
   D:
    - 
     - uxooo
     - 6.33
     - |
       if (my $cs = at.cs) {
           die "CS: ".ki $cs;
       }
     - way: 1
    -
     - symetr
     - 6.1
     - |
       my $sat = X.inv->($at);
       my $spat = X.inv->($pat) if $pat;
       my $ateq = $sat eq $spat;
    -
     - cleaves # leaves away c/sc lines
     - 6.3
     - |
       if (at.c) { 
           # mast/beam - patterns to keep embedding higher and hire/hoistre
           # if beef
           if ($ateq && !at.pur) {
               #acum $lv, 'Ec', " a\.m('nothing');";
               next;
           }
           # args for y
           # some day G.w(y, @args);
           my $js = ref at.s eq 'ARRAY' ?
               join(',',map{ ejson($_) }@{at.s})
               : ejson(at.s);
           acum $lv, 'Ec', ' a.'.at.c.'('.$js.');';
           # eventual lv.C = [ [...]... ] and then aj.C = [lvs{}C];
           # yet vectory again
           # bucket fountain, musical atitude
           # where mess goes into black hole, proofs strung up
           next;
       }
    - MZ: dorp:X
    -
     - inv
     - 5.7
     - |
       my $wa = shift;
       my $ig = shift;
       return ejson $wa if ref $wa eq 'ARRAY';
       join"            ", map{"$_:".ejson($wa->{$_})}
       sort grep {!$ig||$_ !~ /^($ig)$/} grep{!/^__/} keys %$wa;
    -
     - tryig
     - 5.7
     - |
       my ($pat,$at,$ig) = shift;
       X.inv->($pat, $ig) eq X.inv->($at, $ig)
       
    -
     - kinv
     - 5.7
     - |
       my ($pat,$at,$k) = shift;
       X.inv->($at->{$k}) ne X.inv->($pat->{$k})
 - K: geomo/stiz #c
   D:
     - MZ: sticks:Y
     -
      - geo
      - 3.2
      - |
        at.sc.geo = $v;
     -
      - ab # absolute # ORDER uglies
      - 3.3
      - |
        sc.css.position = 'absolute';
        sc.css.width = '100%';
        sc.css.height = '100%';
     -
      - left # yep
      - 3.4
      - |
        sc.css.left = $v;
     -
      - top # yep
      - 3.4
      - |
        sc.css.top = $v;
     -
      - tr # filterszzzz weird style using com to agg.
      - 3.7
      - |
        sc.css->{'-webkit-transform'} = join' ', map {"$_($v->{$_})"} keys %$v;
     -
      - tro #
      - 3.6
      - |
        sc.css->{'transform-origin'} = $v;
     -
      - rad # radial tr
      - 3.6
      - |
        sc.tr.rotate = $v.'rad' if $v;
         return;
 - K: geomo/outs #c switchapol val shifter, 7 hoisting to comp, find selv
   D:
    -
     - Esc
     - 6.4
     - |
       map { acum $lv, 'Esc', $_ } @{at.Esc} if at.Esc;
    -
     - csstidy # togo while symmetrical... some 7 of extrude, keeps outer grouping for komp
     - 5.39712
     - |
       @{at.css} = map { join '', map{"$_;"} 
       grep{defined} split ';', $_ } @{at.css};
    -
     - css2style
     - 6.5
     - |
       at.style = join '', map{"$_;"} 
       grep{defined} map { split ';' } @{at.css};
       delete at.style if !length at.style;
       # <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
       #Rw attitle $at $j;
    -
     - outw
     - 7.1
     - |
       my $s = at.s;
       my $ishtml = at.ishtml;
       $s = encode_entities($s) if !$ishtml;
    -
     - outw
     - 7.4
     - |
       my $tag = at.tag;
       my $ts = j.l;
       $ts =~ s/[^\w]/Ã±/sg;
       $tag ||= "$ts";
       $tag = "Z$tag" if $tag !~ /^[a-z]/i;
       my $arp = at.rp if exists at.rp;
    -
     - outw
     - 7.6
     - |
       my $of = {map{$_=>1}qw's ishtml css tag rp'};
       my $mat = join " ", $tag,
           map { $_ }
           map { $_.'="'.$at->{$_}.'"' } # attra
           grep { $at->{$_} } sort grep {!/^_/ && !$of->{$_} } keys %$at;
       $mat .= ' '.$arp if defined $arp;
    -
     - outw
     - 7.7
     - |
       lv.s = "<$mat>$s</$tag>";
       lv.scon = 1 if lv.s eq plv.s;
       
       if (pat.id) { # S-C
           lv.scon = 1 if lv.s eq plv.s;
           # need to relax the _jointed, cannot find?
           #say "j.r      pat __jointed: ". wdump 2, plv.__jointed;
           # acum $lv, 'Ec', jsq ' $(%s).replaceWith(%s);', '#'.pat.id, at.s;
       }
       # here hangs loose, we would want to conduct at.c/sc business cleanly

