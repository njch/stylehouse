R_Jz:

 - K: anno/Y #c
   D:
    -
     - cts_Y #
     - 2
     - |
       A.wJ = $wJ;
       for my $ct (@{wJ.cts.Y}) {
           next unless ct.any or exists $C->{ct.t_k} && exists $C->{ct.t_k}->{ct.t};
           my $v = $C->{ct.t_k}->{ct.t} unless ct.any;
           my $at = {};
           my $T = {};
           my $g = wJ.ctx.Y;
           
           wJ.ctx.Y->{ct.x}->($A,$C,$g,$T,C.y,$v);
       }
       
 - K: anno/o #c
   D:
   - EZ: anno/Bal
   - MZ: Cy:Y
   -
    - o
    - 2
    - |
      my $o = $v;
      if (ref $o eq 'ARRAY') {
          $o = C.y.o = {M=>$o};
      }
      else {
           o.M ||= [$C];
           o.M = [map{
               my $d;
               d.t = _.t;
               d.y = {%{_.y}};
               d.c = {%{_.c}};
               delete d.y.cv;
               # TR
               if (o.ou) { # inside our
                   d.c.pi = o.ou;
                   d.c.s = $_;
               }
               if (o.oJ) {
                    d.sc.oJ = o.oJ;
               }
               $d
           }@{o.M}]
       }
       C.y.bal = o.M || die"nomo";
       my $J = A.J;
       my $Jy = J.d.y;
       C.y.o.J = J.most.J if $Jy && Jy.o && Jy.aspace > 0.2;
       
       C.y.over = (Jy.o && Jy.over && Jy.over || 0) + 0.06 if y.o.J;
       
       C.y.in ||= $Jy ? Jy.cv + 0.03 : 0.1;
       C.y.out ||= $Jy ? Jy.ov - 0.03 : 0.9;
       
       C.c.lumfa = 1 if J.most.J.name eq 'wam';
       
       sayyl "IS o  C.t  C.y.cv    ".ki(C.c)."    ".ki(C.sc) if A.J.V;
 - K: mooj/i #c
   D:
   - EZ: mooj/BB
   - MZ: Cy:Yany
   -
    - i # build wave manifold, fore loop
    - 1.1
    - |
       C.y = {thi => C.y} if !ref C.y;
   -
    - i # build wave manifold, fore loop
    - 3
    - |
       die "cv+in".k2 $C if y.cv && y.in;
       
       
       y.in ||= 0.1; 
       y.out ||= 0.9; # up to
       y.thi ||= 1; 
       y.space = y.out - y.in; # could spiral much space away from spine
       y.space *= -1 unless y.space > 0;
       y.aspace = y.space / y.thi;
   -
    - i # build wave manifold, fore loop
    - 6
    - |
       # twist, lay into segment
       A.v = defined y.cv ? y.cv : defined y.in ? y.in : die "no yiny".ki$y;
       my $wJ = A.wJ;
       
       for (1..y.thi) {
           my $T = {%$C};
           while (my($k,$v) = each %$T) {
               $T->{$k} = {%$v} if ref $v;
           }
           T.y.i = $_-1;
           push @{A.is}, $T;
           
           for my $ct (@{wJ.cts.B}) {
               next unless ct.any or exists $C->{ct.t_k} && exists $C->{ct.t_k}->{ct.t};
               my $v = $C->{ct.t_k}->{ct.t} unless ct.any;
               
               wJ.ctx.B->{ct.x}->($A,$C,$g,$T,T.y);
           }
           say "KAp T.t  T.y.cv   T.y.ov" if A.J.V;
       }
       #sayyl wdump 2, A.is;
 - K: anno/Bal #c
   D:
   - EZ: anno/lumfa
   - MZ: Cy:Y
   -
    - bal
    - 2.3
    - |
       y.thi = @$v;
   -
    - bal
    - 4
    - |
       A.muav = ( sum(map{_.y.thy} @{y.bal}) /  (@{y.bal}||1) )||1;
       saygr "Ybal 4 A.muav over". k2 $y if A.J.V;
 - K: anno/lumfa #c
   D: |
   - MZ: Cc:Y
   -
    - lumfa
    - 3
    - |
      my $lum = 3;
      my $i = 0;
      y.bal || die "lumfa no ybal ".k2 $C;
      for (@{y.bal}) {
          _.y.thy=$lum;
          $i++;
          $lum = 2 if $i == 4;
          $lum = 1 if $i == 7;
      }
   - MZ: Cc:B
   -
    - lumfa
    - 5
    - |
      my $spc = T.y.spc;
      my $upt = 0;#0.9 / @{d.y.bal};
      $spc = $upt if $spc < $upt;
      my $fl = ($spc / 0.02) * 4;
      sayyl "d.t   d.y.ov - d.y.cv  ::: $spc d.y.aspace \t\t $fl";
      d.sc.fs = $fl if $fl < 9;
      #d.sc.tt="d.t at d.y.cv for d.y.spc";
 - K: mooj/BB #c
   D:  
   - MZ: Cy:Bany
   -
    - yinvout # build wave manifold, fore loop, reclimb vines
    - 1.1
    - |
      die "if " if $y ne T.y;
      die "nov" if !A.v;
      y.cv = 0+sprintf '%.6f', A.v;
      y.pcv = 0+sprintf '%.6f', $_ / C.y.thi;
      A.mu = 1;
      saygr "Mad T.t  is T.y.cv  (T.y.i / C.y.thi)" if A.J.V;
   -
    - bally 
    - 3.2
    - |
      my $b = {};
      
      if (C.y.bal) {
          $b = C.y.bal->[y.i] if C.y.bal; 
        saygr "ISCYBAL y.i  -> b.t  ".ki b.y."   ".slim 30,ki b.c if A.J.V;
      }
      
      while (my($k,$v) = each %$b) {
          sayyl "clon $k    ".gp($T->{$k})."   ->  ".gp($v) if A.J.V;
          $T->{$k} = ref $v ? {%{$T->{$k}||{}}, %$v} : $v;
      }
      
      A.mu = T.y.thy if exists T.y.thy;
      say "T.t ist A.mu  among A.muav" if A.J.V;
      A.mu = A.mu / A.muav if A.muav;
      #if (J.d.c.cv && b.y.thy) {
      #    say "C.c.cv * C.y.aspace * $mu  === ". (C.c.cv * C.y.aspace * $mu);
      #    b.c.cv ||= J.d.c.cv * C.y.aspace * $mu
      #} 
   -
    - over # cap
    - 4
    - |
      sayyl "A.v  iwl +=    y.aspace * A.mu    =".(y.aspace * A.mu) if A.J.V;
      A.v += y.aspace * A.mu;
      y.ov = sprintf '%.6f', A.v;
      y.spc = y.ov - y.cv;
      T.r = join "\t", T.t, (y.cv+0);
      sayyl "T.r ist T.y.cv -> T.y.ov" if A.J.V;
   -
    - yangbalin # 
    - 7
    - |
       $y->{$_} = 0+sprintf('%.6f',$y->{$_}) for qw'cv ov aspace spc';
       
       if (T.y.over) {
           T.sc.ml = (T.y.over * 40)."%"; 
       }

