R_Jz:
 - K: swi #c 
   n_D:
     yJ: |
       'swi clw headi geomoss'
     curves: | 
       spun 0  2
       zoom 0 0.5
       y    0  0
       x    0  0.2
       curve 0 -0.1
     defon: |
       #twang 0.1 Z/2
       #twong 0.1 Z/3
     up: | # if the in up, pha wakeups out - all response to editing
       J.cv = 20;
       
       Jn('some',0.3,'thing!');
       J.V = 1;
       Rw thi afghanrug/mods;
       Jn('ee',0.4,'THINGS!');
       Rw on_xor_geo $J $nomay=1;  
        
       Rw flow $J geomo;   
 - K: geomoss #c
   n_D:
     flows:
       geomo: |
         flow 1
         nesting 4
         style 5
         etcs 6
         outs 7
         
       
 - K: ym/dorp #c
   D: |
     my $o;
     if ($v eq 'XO') {
         o.droplist = 'O';
         o.sh = 'X';
         o.sh_X_args = '$v,$tks,$com,$cs,$at,$lv,$J,$j';
     }
     if ($v eq 'X') {
         o.sh = 'X';
     }
     $o||die "ym/dorp of $v";
     n.sc->{$_} = $o->{$_} for keys %$o;
 - K: geomo/etcs #c
   D:
    - MZ: dorp:X
    -
     - inv
     - 5.7
     - |
       my $wa = shift;
       my $ig = shift;
       return ejson $wa if ref $wa eq 'ARRAY';
       join"            ", map{"$_:".ejson($wa->{$_})}
       sort grep {!$ig||$_ !~ /^($ig)$/} grep{!/^__/} keys %$wa;
    -
     - tryig
     - 5.7
     - |
       my ($pat,$at,$ig) = shift;
       X.inv->($pat, $ig) eq X.inv->($at, $ig)
       
    -
     - kinv
     - 5.7
     - |
       my ($pat,$at,$k) = shift;
       X.inv->($at->{$k}) ne X.inv->($pat->{$k})
 - K: geomo/outs #c
   D:
    -
     - symetr
     - 6.1
     - |
       my $sat = X.inv->($at);
       my $spat = X.inv->($pat) if $pat;
       my $ateq = $sat eq $spat;
    -
     - cleaves # leaves away c/sc lines
     - 6.3
     - |
       if (at.c) { 
       # which are really just patterns to keep embedding higher and hire
           if ($ateq && !at.pur) {
               #acum $lv, 'Ec', " a\.m('nothing');";
               next;
           }
           # args for y
           # some day G.w(y, @args);
           my $js = ref at.s eq 'ARRAY' ?
               join(',',map{ ejson($_) }@{at.s})
               : ejson(at.s);
           acum $lv, 'Ec', ' a.'.at.c.'('.$js.');';
           # eventual lv.C = [ [...]... ] and then aj.C = [lvs{}C];
           # yet vectory again
           # bucket fountain, musical atitude
           # where mess goes into black hole, proofs strung up
           next;
       }
       
    -
     - Esc
     - 6.4
     - |
       map { acum $lv, 'Esc', $_ } @{at.Esc} if at.Esc;
       # at out scribe,
       # slump to end
       # switch up pool of lang > styles
       # maybe .html if X.tryig->('s')
               # or replaceWith if spat.id or we can find ourselves
               # for aj.C streams it shall easy...
    -
     - csstidy #c togo while symmetrical... some 7 of extrude, keeps outer grouping for komp
     - 5.4712
     - |
       @{at.css} = map { join '', map{"$_;"} 
       grep{defined} split ';', $_ } @{at.css};
    -
     - css2style
     - 6.5
     - |
       at.style = join '', map{"$_;"} 
       grep{defined} map { split ';' } @{at.css};
       delete at.style if !length at.style;
       # <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
       #Rw attitle $at $j;
    -
     - outw
     - 7.1
     - |
       my $s = at.s;
       my $ishtml = at.ishtml;
       $s = encode_entities($s) if !$ishtml;
    -
     - outw
     - 7.4
     - |
       my $tag = at.tag;
       my $ts = j.l;
       $ts =~ s/[^\w]/Ã±/sg;
       $tag ||= "$ts";
       $tag = "Z$tag" if $tag !~ /^[a-z]/i;
       my $arp = at.rp if exists at.rp;
    -
     - outw
     - 7.6
     - |
       my $of = {map{$_=>1}qw's ishtml css tag rp'};
       my $mat = join " ", $tag,
           map { $_ }
           map { $_.'="'.$at->{$_}.'"' } # attra
           grep { $at->{$_} } sort grep {!/^_/ && !$of->{$_} } keys %$at;
       $mat .= ' '.$arp if defined $arp;
    -
     - outw
     - 7.7
     - |
       lv.s = "<$mat>$s</$tag>";
       lv.scon = 1 if lv.s eq plv.s;
       
       if (pat.id) { # S-C
           lv.scon = 1 if lv.s eq plv.s;
           # need to relax the _jointed, cannot find?
           #say "j.r      pat __jointed: ". wdump 2, plv.__jointed;
           # acum $lv, 'Ec', jsq ' $(%s).replaceWith(%s);', '#'.pat.id, at.s;
       }
       #saybl "left j.r   ".lv.s;
       # here hangs loose, we would want to conduct at.c/sc business cleanly
 - K: geomo/nesting #c
   D:
     -
      - vsord
      - 3.2189
      - |
        # puts /s backwards and last:
        $vs = Rw ordlv $J $vs $slashtopi=1;
     -
      - nesto
      - 4.189
      - |
        # >< up from... # carbon hapsso env 
        if (j.l =~ /^(.*)\/$/) {
            # grep tw for $1/things
            my $p = $1;
            $p .= '/' if length $p;
            #sayre "looking for '$p' directed";
            my $olvr = "j.l%lv\t".j.cv;
            # assume this/ is for this/*, / is for *
            my @lvs =
                sort { a.j.cv <=> b.j.cv }
                sort{ a.j.r cmp b.j.r }
                grep {_.j.l ne j.l}
                grep {!_.at._jointed || grep {$_ eq $olvr} @{_.at._jointed}}
                # $lv ^
                map {aJ.bb->{$_}}
                grep {/^$p/}
                grep {/%lv\s+\S+$/}
                keys %{aJ.bb};
                
            # j sc may have a motice to grab something
            acum $at, _joins => "_.j.l%lv\t"._.j.cv for @lvs;
            
            _.at || die "no at _.j.r (we j.r)".wdump($_) for @lvs;
            acum _.at, __jointed => $olvr for @lvs;
            
            # really like n.sc.M = [...]
            at.ishtml = 1;
            at.s = '';
            @s = ();
        }
     -
      - nests
      - 6.189
      - | 
        # eats hoist
        if (at._joins) {
            my @lvs = map { aJ.bb->{$_} } @{at._joins};
            
            say "j.r eats    ".join',   ', map{_.j.r} @lvs;
            # or compressions in c, sc
            # make them tubes real nice
            my @live = grep {_.at.__ajid2 eq aj.id} @lvs;
            my @skip = grep {_.at.__ajid2 ne aj.id} @lvs;
            # can trust lvs c/sc from this aj (pipe/time)
            # circumference
            # future should be all self...
            # el:
            # C[/:ux, 0.3, {id:$id,cl:$class,etc:whatsit}, [
            #   C[Jhead, 0.1, ["yt",:h3YO-zOl82g}, [
            
            
            # hoist at.Cs into our at.C t y c sc ssc
            #
            # assume @live phased will sane s/c/sc
            map { acum $lv, 'Esc', $_ for @{_.Ec} } @live;
            map { acum $lv, 'Esc', $_ for @{_.Esc} } @live;
            
            # these are flying blind chunks of html in s
            # few replace selves, say lv.scon = 1;
            # make at.s [ [_.j.r => _.s] ... ] and shake down...
            # filter out who is scon'ing for themselves
            # they want to Jtube through us
            at.s = join '', map { _.s } @lvs;
            # these are curving down into things
        }
               
               
 - K: geomo/style #c
   D:
     - MZ: dorp:XO
     - WZ: /C may#styley
     -
      - siome
      - 5
      - |
        # ETC
 - K: geomo/flow #c
   D: |
     # 1
     G.oin.idJy->{J.id} ||= $J;
     # think these want to be injected crazily
     if (!J.yy.may.noroot) {
         exists J.bb->{"/\t0.9"} ||
         J.bz->("/\t0.9", "y", "%tag","ux","%tt"=>J.name);
         exists J.bb->{"/%id\t0.9"} ||
         J.bz->("/%id\t0.9", J.id);
     }
     # 2
     
     my $aJ = Rw oJ $J A;
     #  ^ v MMMMMMMMMM aj ejector
     my $aj = Rw up $J:aJ;
     
     # 3 spewing two-step
     my $vs = Rw tyv $J;
     my @s;
     
     # 3.7 know what we are ignoring and destroying
     # bi-pha
     # pingy statechange graphicly allele towers
     # $vs should stretch over aJ as far as any $ip is
     #
     my %now = map{_.j.r => 1} @$vs;
     for (keys %{aJ.bb}) {
         /^(.+)%.+?\t(\S+)$/||die$_;
         if (!$now{"$1\t$2"}) {
             delete aJ.bb->{$_};
         }
     }
     
     for my $lv (@$vs) {
         push @s, $lv;
         my $j = lv.j;
         die "reffy j.s in j.l ON J.name".wdump 3, [ar.ip, $j] if ref j.s;
         
         # 4 #c
         my $coi = Rw pha $J:aJ $k:j.r;
         coi.qui = 1;
         my $xat = do {
             Rw lv_same $lv $x:coi $J:aJ;
         } if aJ.bb->{"j.l%at\t".j.cv} && j.l !~ /\//;
         
         
         my $at;
         my $pat;
         my $plv;
         if (!$xat) {
             $at = {css=>[]};
             at.s = j.s;
             # may be creating, overhead thought
             at.__ajid1 = aj.id;
             
             my ($tks, $cs, $it) = Rw sit flow O X $lv $wJ;
             #sayre wdump lv.sc;
             #saybl wdump $tks;
             # 5.3 # sciterate
             while (1) {
                 my ($tk, $com, $v, $tks) = $it->();
                 last if !$tk;
                 my @s = $X->{$tk}->($v, $tks, $com, $cs, $at, $lv, $J, $j);
             }
             # 5.4
         }
         # 5.78 at beam
         $pat = aJ.bb->{"j.l%at\t".j.cv};
         $plv = aJ.bb->{"j.l%lv\t".j.cv};
         if (!$xat) {
             aJ.bb->{"j.l%lv\t".j.cv} = $lv;
             aJ.bb->{"j.l%at\t".j.cv} = $at;
             
             coi.exactl->();
         }
         else {
             aJ.bb->{"j.l%lv\t".j.cv} = $lv;
             $at = $pat;
         }
         # 5.8
         # gets self aware in waves
         # above can now trust lvs to have iter-sane E{s,}c[] impulses / same s
         at.__ajid2 = aj.id;
         lv.at = $at;
         
         # 7.9 # heaps ^ all of at outwardsing
     }
     # 8 check lv up cover
     if (J.yy.may.noroot) {
         die 'noroot ag has s'.wdump($_) for grep {_.s} @s;
         aj.c = [map{@{_.Ec||[]}}@s];
         aj.sc = [map{@{_.Esc||[]}}@s];
     }
     else {
         my $lv = aJ.bb->{"/%lv\t0.9"};
         aj.s = lv.s;
         delete aj.s if lv.scon; # no repeat emit
         aj.c = lv.Ec || [];
         aj.sc = lv.Esc || [];
     }
     # 8.8
     if (!ar.catj) {
         Rw Em $aj;
     }
     # 9
     $aj
     

