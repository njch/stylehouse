R_Jz:

 - K: anno/Y #c
   D:
    -
     - cts_Y #
     - 2
     - |
       A.wJ = $wJ;
       for my $ct (@{wJ.cts.Y}) {
           next unless ct.any or exists $C->{ct.t_k} && exists $C->{ct.t_k}->{ct.t};
           my $v = $C->{ct.t_k}->{ct.t} unless ct.any;
           my $at = {};
           my $T = {};
           my $g = wJ.ctx.Y;
           
           wJ.ctx.Y->{ct.x}->($A,$C,$g,$T,C.y,$v);
       }
       
 - K: mooj/i #c
   D:
   - EZ: mooj/BB
   - MZ: Cy:Yany
   -
    - i # build wave manifold, fore loop
    - 1
    - |
       C.y = {thi => C.y} if !ref C.y;
   -
    - i # build wave manifold, fore loop
    - 1.2
    - |
       sayyl 'i 1.2  '.k2 $C;
       saygr k2 $y;
       
       die "cv+in".k2 $C if y.cv && y.in;
       
       y.in ||= 0.1; 
       y.out ||= 0.9; # up to
       y.thi ||= 1; 
       y.space = y.out - y.in; # could spiral much space away from spine
       y.space *= -1 unless y.space > 0;
       y.aspace = y.space / y.thi;
   -
    - i # build wave manifold, fore loop
    - 6
    - |
       # twist, lay into segment
       A.v = defined y.cv ? y.cv : defined y.in ? y.in : die "no yiny".ki$y;
       warn "histtwqay". k2 $C;
       
       for (1..y.thi) {
           my $T;
           T.y.i = $_-1;
           push @{A.is}, $T;
           my $A = {%$A};
           
           my $wJ = A.wJ;
           for my $ct (@{wJ.cts.YB}) {
               next unless ct.any or exists $C->{ct.t_k} && exists $C->{ct.t_k}->{ct.t};
               my $v = $C->{ct.t_k}->{ct.t} unless ct.any;
               
               wJ.ctx.YB->{ct.x}->($A,$C,$g,$T,T.y);
           }
       }
 - K: anno/o #c
   D:
   - EZ: anno/Bal
   - MZ: Cy:Y
   -
    - o
    - 2
    - |
      my $o = $v;
      if (ref $o eq 'ARRAY') {
          $o = C.y.o = {M=>$o};
      }
      else {
           o.M ||= [$C];
           o.M = [map{
               my $d;
               d.t = _.t;
               d.y = {%{_.y}};
               d.c = {%{_.c}};
               delete d.y.cv;
               # TR
               if (o.ou) { # inside our
                   d.c.pi = o.ou;
                   d.c.s = $_;
               }
               if (o.oJ) {
                    d.sc.oJ = o.oJ;
               }
               $d
           }@{o.M}]
       }
       C.y.bal = o.M || die"nomo";
       
       my $Jy = J.d.y;
       C.y.o.J = J.most.J if $Jy && Jy.o && Jy.aspace > 0.2;
       
       C.y.over = (Jy.o && Jy.over && Jy.over || 0) + 0.06 if d.y.o.J;
       
       C.y.in ||= $Jy ? Jy.cv + 0.03 : 0.1;
       C.y.out ||= $Jy ? Jy.ov - 0.03 : 0.9;
       C.c.lumfa = 1 if J.most.J.name eq 'wam';
 - K: anno/Bal #c
   D:
   - EZ: anno/lumfa
   - MZ: Cy:Y
   -
    - bal
    - 4
    - |
       C.y.thi = @$v;
       A.muav = ( sum(map{_.y.thy} @{y.bal}) /  (@{y.bal}||1) )||1;
 - K: anno/lumfa #c
   D: |
   - MZ: Cc:Y
   -
    - lumfa
    - 3
    - |
      my $lum = 3;
      my $i = 0;
      for (@{y.bal}) {
          _.y.thy=$lum;
          $i++;
          $lum = 2 if $i == 4;
          $lum = 1 if $i == 7;
      }
   -
    - lumfa
    - 4
    - |
       if (T.c.lumfa) {
           my $spc = d.y.spc;
           my $upt = 0;#0.9 / @{d.y.bal};
           $spc = $upt if $spc < $upt;
           my $fl = ($spc / 0.02) * 4;
           #sayyl "d.t   d.y.ov - d.y.cv  ::: $spc d.y.aspace \t\t $fl";
           d.sc.fs = $fl if $fl < 9;
           #d.sc.tt="d.t at d.y.cv for d.y.spc";
       }
 - K: mooj/BB #c
   D:  
   - MZ: Cy:YBany
   -
    - yinvout # build wave manifold, fore loop, reclimb vines
    - 1
    - |
      y.cv = sprintf '%.6f', A.v;
      y.pcv = sprintf '%.6f', $_ / C.y.thi;
      s/0+$/0/ for y.cv, y.pcv;
      A.mu = 1;
      
   -
    - bally 
    - 3.2
    - |
      my $b = $C; # clone
      
      $b = C.y.bal->[y.i] if C.y.bal;
      
      for my $k (keys %$b) {
          my $v = $b->{$k};
          $T->{$k} = ref $v ? {%{$C->{$k}||{}}, %$v} : $v;
      }
      
      A.mu = T.y.thy if exists T.y.thy;
      A.mu /= A.muav||1;
      
      #if (J.d.c.cv && b.y.thy) {
      #    say "C.c.cv * C.y.aspace * $mu  === ". (C.c.cv * C.y.aspace * $mu);
      #    b.c.cv ||= J.d.c.cv * C.y.aspace * $mu
      #} 
   -
    - over # cap
    - 4
    - |
      A.v += y.aspace * A.mu;
      y.ov = sprintf '%.6f', A.v;
   -
    - yangbalin # 
    - 7
    - |
       T.r = join "\t", T.t, (y.cv+0);
       
       y.spc = y.ov - y.cv;
       $y->{$_} = 0+sprintf('%.6f',y->{$_}) for qw'cv ov aspace spc';
       
       if (d.y.over) {
           d.sc.ml = (d.y.over * 40)."%"; 
       }

