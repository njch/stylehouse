R_Jz:
 - K: wam #c 
   n_D:
     yJ: |
       'wam mayo clw headi'
     up: | # if the in up, pha wakeups out - all response to editing
       Rw Jhead;
       
       my $oJ = Rw oJ $J on filey;
       # ^ makes a J:on:on+filey
       # to upgrade strings v into somewhere brained (ou/file)
       oJn( twang => 0.2 => 'Z/2');
       
       Rw up $J:oJ;
       
       # bounce different ways...
       # hire a Con...
       # requireway, with parameters
       # then patch bay for groups of style to feed in
       # also the other elements present in may...
       # farmed out
       
       my $onl = Rw very $in=0.1 $out=0.8 $J:oJ $tot:J.cv;
       
       # pin down top level
       # primitives for geo site
       for my $x (@$onl) {
           Rw ix/suro + $x;
       }
       
       Jn(wam => 0.2, {s=>'wam',pwth=>'J5:wam'}); 
       
       Rw oJ $J geo &up;
 - K: filey #c note uplv for the from $lv, projecting flavour
   n_D:
     yJ: |
       'filey'
     uplv: |
       my $sc;
       if (!lv.sc) {
           say "INIT STYLO ".ejson $lv;
           if (j.s =~ /^[A-Z0]/) {
               sc.ou = 'file';
               sc.dir = 'ghosts/';
           }
           # looking at this J's abilities to upgrade string input with ou thinkg/crawl
       }
       Rw jamsc $J $j $sc;
 - K: ou/file #c
   D: |
     my $file = x.j.s;
     defined $file || die 'nofile';
     if (my $dir = sc.dir) {
         $dir .= '/' if $dir !~ /\/$/;
         $file = "$dir$file";
     }
     my $J = Rw fil/e $file;
     my @o = Rw around $J;
     @o = sort { a.sc.in <=> b.sc.in } @o;
      
     push @{o.r}, $_ for map{
          my $sc = _.lie_sc = delete _.sc;
          _.s = sc.com if sc.com;
          _.sc.fs = 4 if !sc.com;
          _.s = 4 if !sc.com;
          _.c.gp.cv = 0.4;
          $_
     }@o;
     
     o.dig = dig sjson \@o;
     
 - K: fil #c index of files
   n_D:
     yJ: |
       'fil'
     e: |
       my $J = Rw J5 - fil;
       Rw around + $J;
     around: |
       ar.file ?
          Rw fil/ile
       :();
     ile: |
       my $fid = slm 8, dig $file;
       my $fJ = J.bb->{"$fid\t0.1"};
       if (!$fJ) {
           $fJ = Rw oJ $J $name=lie.$fid $style=lie;
           fJ.bz->("file\t0.1" => $file);
           J.bz->("$fid\t0.1", $fJ, '%file'=>$file);
       }
       $fJ
 - K: lie #c one file vector, expanding reconvening substructure of io mess to artifacts and stuff in 0.8
   n_D:
     yJ: |
       'lie'
     flows:
       folate: |
         file/stat 0.1 {} {et:0}
         file/read 0.2 {} {et:10}
         read/jam 0.3 {} {et:40}
     around: |
       J.cv ||= 0.3;
       
       Rw flow $J folate;
       
       my $ip = {cv=>0.4};
       my $vs = Rw tyv $J $ip;
       
       map { {
          t => _.j.t,
          cv => _.j.cv,
          s => _.j.s,
          sc => _.sc,
       } } @$vs;
 - K: folate #c
   n_D:
     file:
       stat: | #  lv  = 0.1s
         at.is_file = -f j.s;
         my @s = stat j.s;
         at.size = $s[7];
         at.mtime = $s[9];
         at.ctime = $s[10];
       read: |
         my $s = read_file(j.s);
         Jn('read' => 0.3 => $s, {dig=>dig $s});
     read:
       jam: |
         my $i = 0;
         my $l = {map { $i++ => $_ } split "\n", j.s};
         Jn('lines' => 0.3 => $l);
         my @bu;
         my @nol;
         for my $li (sort keys %$l) {
             my $n = {in=>$li};
             n.s = $l->{$li};
             n.h = n.s;
             if (n.s =~ /^.?.?\S/) {
                 n.r = 'low';
             }
             if (n.s =~ /#(c)(.*)$/) {
                 n.r = 'c';
                 n.com = $2 if $2;
             }
             n.K = $1 if n.s =~ /K: (\w+[^#]+)/; 
             n.K ||= $1 if n.s =~ /^[^#]*?(\w+[^#]+)/;
             n.K =~ s/\s+$// if n.K;
             if (n.r && n.K) {
                 if (@nol) {
                     n.s = join"\n",@nol,n.s;
                     @nol = ();
                     n.in = 0;
                 }
                 push @bu, $n;
             }
             elsif (@bu) {
                 my $las = $bu[-1]; 
                 las.s .= "\n".n.s;
                 las.out = $li;
             }
             else {
                 push @nol, n.s
             }
         }
         for my $n (@bu) {
             my $s = delete n.s;
             $s||die;
             n.dig = slm 7, dig $s;
             my $j;
             j.l = n.K||n.h;
             j.cv = 0.4;
             Jn(j.l, j.cv, $s);
             Rw jamsc $J $j $sc:n;
             saybl "N: n.K        ".slim 40, ki $n;
         }
 - K: flow #c K-flow
   D: |
     my $flow = $m->[0];
     #my $uJ = Rw J5 flu;
     #my $oJ = Rw around $J:uJ $cJ:J $flow;
     
     
       my $fl = Rw oJ $J fl-$flow;
       Rw thy $J $oJ:fl flows/$flow;
       my $fvs = Rw tyv $J:fl; 
       
       for my $fv (@$fvs) {
           my ($forl,$gap,$re) = fv.j.l =~ /(.+)(\/|:)(.+)/;
           my $ip = {l=>$forl};
           my $vs = Rw tyv $J $ip;
           
           $re = "$forl$gap$re" unless $gap eq ':';
           
           say ki fv.sc;
           for my $lv (@$vs) {
               my $j = lv.j;
               my $coi = Rw pha $J $k=fv.j.l*j.r;
               
               my $off = fv.sc.et;
               # resolve $offness, add $and to lv_same
               # if change exactl swoops an init linehum wd
               my $nc = coi.begin - coi.head.begin < $off &&
                   Rw lv_same $lv $j $x:coi $J;
               
               if ($nc) {
                   sayyl "skip fv.j.r";
                   next;
               }
               sayyl "Effect: fv.j.r  fv.j.s";
               
               sayre "NO CHANGE" if $nc;
               #$nc || saybl "Changijie\ngjjijgeij " for 1..4;
               my $at = {};
               Rw $flow/fv.j.l $J $j $at $sc:lv.sc;
               
               # at travels fast
               sayyl ki $at;
               
               Rw jamsc $J $j $sc:at;
               
               say coi.head;
               # coi
               coi.same_wd ||= do {
                 saybl "fresh, making samewd" for 1..5;
                   my $ip = {l=>j.l};
                   my $vs = Rw tyv $J $ip;
                   my $lv = $vs->[0];
                   Rw lv_same $lv $x:coi $J $ret=1;
               };
               saybl coi.same_wd for 1..5;
           
               my $y = coi.exactl->();
               sayyl "  is ".slim 60, j.s;
           }
       }
 - K: flu #c index: creativity is a disease - hang them on G.drop
   n_D:
     yJ: |
       'flu'
     around: |
       ar.cJ ?
           Rw flu/cod
       :();
     cod: |
       # look at this word in the context of yay style
       my $h = slm 6, dig ejson[cJ.style,$flow];
       #return G.drop.flows->{$h} ||= do {
           my $oJ = Rw oJ $J $name=flz.$h $style=flz;
           
           Rw thy $oJ $J:cJ flows/$flow;
           # ^nc || v setup
           Rw around $J:oJ;
           $oJ;
       #};
 - K: flz #c created way jumping into vector, stringing to paths
   n_D:
     yJ: |
       'flz'
     around: |
       sayyl "Around of J.name !" for 1..2;
       my $oJ = Rw oJ $J way;
       
       my $vs = Rw tyv $J;
       my $gs = Rw ordlv $J $vs $ninefirst=1;
       
       for my $lv (@$vs) { 
           my $j = lv.j;
           my $coi = Rw pha $J $k=j.r;
           #my $xat = Rw lv_same $lv $x:coi $J;
           #Rw thi $p:j.t $J;
           # makes a bunch of coils around lvs
           # so one set of styles runs at a time
           # grabs a template... 0.9
           # 0.8 is the join to the template from the most-sorted Carbonja 0.7
           sayyl "j.r   is j.s";
           my $y = coi.exactl->();
       }
       
       
  
 - K: ya #c
   n_D:
     am:
      -
       - whole
       - 0.1
       - |
         my $vs = Rw tyv $J;
         my $gs = Rw ordlv $J $vs;
         
         
 - K: C _fyl #c
   n_D:
     el:
       STYLE: | #
         {droplist => 'O',
          subhash => 'X',
          subhash_X_arp => '$com,$cs,$at,$lv,$J,$j',
         }

     u: |
       # oJ
       
       # 3
       my $vs = Rw tyv $J $ip:ar.ip;
       # 3.1 puts /s backwards and last:
       my $gs = Rw ordlv $J $vs;
       
       # lvitate
       for my $lv (@$gs) {
           my $j = lv.j;
           
           my $coi = Rw pha $J:oJ $k=j.r-xatly;
           # Rw lv_same $lv $x:coi $J:oJ; # ends coi
           # know style's styles
           # so
           
           
           my $at;
           my $pat;
           my $plv;
           if (!$xat) {
               $at = {css=>[]};
               at.s = j.s;
               # may be creating, overhead thought
               at.__ajid1 = aj.id;
               
               my ($tks, $cs, $it) = Rw sit may O X $lv;
               
               # sciterate, can add to $tks
               while (1) {
                   my ($tk, $com, $v, $tks) = $it->();
                   last if !$tk;
                   #say " $tk, $com, $v, $tks";

                   $X->{$tk}->($v, $tks, $X, $com, $cs, $at, $lv, $J, $j);
                   #say "May X $tk returned: ". wdump [@s] if @s;
               }
               # 5.6
               # lv/at cache
               
               my $y = coi.end->();
               my $ex = Rw ph_exactl $J:oJ $y;
           }
           else {
               $pat = oJ.bb->{"j.l%at\t".j.cv};
               $plv = oJ.bb->{"j.l%lv\t".j.cv};
               oJ.bb->{"j.l%lv\t".j.cv} = $lv;
               $at = $pat;
           }
           
           # gets self aware in waves
           # above can now trust lvs to have iter-sane E{s,}c[] impulses / same s
           at.__ajid2 = aj.id;
           lv.at = $at;
           
           my $inv = sub {
              my $wa = shift;
              my $ig = shift;
              return ejson $wa if ref $wa eq 'ARRAY';
              join"            ", map{"$_:".ejson($wa->{$_})}
              sort grep {!$ig||$_ !~ /^($ig)$/} grep{!/^__/} keys %$wa;
           };
           my $tryig = sub {
              my $ig = shift;
              $inv->($pat, $ig) eq $inv->($at, $ig)
           };
           my $kinv = sub {
              my $k = shift;
              $inv->($at->{$k}) ne $inv->($pat->{$k})
           };
           

