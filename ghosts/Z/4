R_Jz:
 - K: on #c
   n_D:
     yJ: |
       J.yl.nojb = 1;
       'on';
     up: | # tak tlv J.on into iterations of upgoing clever
       my $vs = Rw tyv $J $ip:ar.ip;
       
       if (!@$vs && !ar.rev) {
           Rw thy $oJ:J $J:J.Jo defon
           >=0 && return
           Rw up + $rev=1;
       }
       
       sayyl "ON J.Jo.name";
       my $nc = 1;
       for my $lv (@$vs) {
           my $j = lv.j;
           my $coi = Rw pha $J $k=j.r;
           coi.off=100;
           
           my $lnc = Rw lv_same $lv $j $x:coi $J $V=1;
           sayyl "LINEHUM SAME: $lnc";
           $nc = 0 if !$lnc;
           next if $lnc;
           
           Rw suck */uplv $J $lv $j;
           
           #my $xat = Rw lv_same $lv $x:coi $J;
           #say "xat" if $xat;
           coi.end->();
       }
       $nc;
       
       
 - K: pi/infrom #c
   D: |
     my $x = $u;
     
     Jn('onl', 0.1, "x.j.l", '{co:38f,fs:12}');
     
     Jn('is',0.102,{s=>':',pwth=>'whack'},'{fs:20,co:eee}');
     
     Jn('s', 0.11, {pi=>'',s=>x.j.s},'{fs:15}');
     
     
     
     my $in = {%{x.sc||{}}};
     Jn('sc',0.3, {pi=>'scbund',s=>x.sc},
         {fs=>23 ,co=>'314',sha=>'1 1 3 fff'});
     
     if (my $time = x.sc.ts) { # can't be zero, so relative
         Rw ii/time + $time;
     }
 - K: wam #c 
   n_D:
     yJ: |
       'wam clw headi'
     defon: |
       twang 0.1 Z/3
     in: |
       my @up = $J2;
       push @up, $up[-1]->{Jiter} until !$up[-1]->{Jiter};
       my ($se,$xor) = reverse @up;
       
       say "We se.name and xor.r";
       
       my $c = xor.d.c;
       my $J = Rw oJ $J cod;
       Rw up $J $o:c.o $r:c.r;
       
     up: | # if the in up, pha wakeups out - all response to editing
       J.cv = 20;
       
       my $coi = Rw pha $J $k=upix;
       Rw Jhead;
       my $oJ = Rw oJ $J on filey;
       
       my $nc = Rw up $J:oJ;
       #return coi.abandon->('same on') if $nc;
       
       Rw onxor $J $oJ;
       
       
       coi.exactl->();
       
       Rw oJ $J geo &up;
       Rw may $J;

       say "comat ".F_delta;
 - K: cod #c
   n_D:
     yJ: |
       'cod';
     in: |
       my $r = J.row;
       my $o = J.ooo;
       my $u;
       u.t = r.t;
       u.cv = r.cv;
       u.dig = e.dig;
       u.s = e.code;
       my $oJ = o.oJ;
       Rw in $J:o.oJ $u;
     up: |
       my $x = Rw pha swoosh;
       Rw Jhead;
       J.row = $r;
       J.ooo = $o;
       Jn('srcvector',0.1,{pi=>'',s=>o.oJ});
       Jn('row',0.2,{s=>r.s},{idly=>1,cm=>'perl',dig=>r.sc.dig});
       
       x.exactl->();
       Rw oJ $J geo &up;
       Rw may $J;
     curves: |
       spun 0  2
       zoom 0 0.5
       y    0  0.5
       x    0  0.4
 - K: onxor #c
   D: |
       my $onl = Rw very $in=0.1 $out=0.9 $J:oJ $tot:J.cv;
       for my $x (@$onl) {
           my $M = [];
           Mn(x.j.l.'-cap' => {thy=>x.thi/5},{pi=>'infrom',s=>$x});
           
           my $o = Rw oundo $x;
           say "   oundoof: ".F_delta;
           my $thy = x.thi / (o.thi||1);
           
           #say join '  ', sort keys %$o;
           
           for my $r (@{o.r}) {
               #say join " ", sort keys %$r;
               Mn( r.t, {thy=>$thy},
                  {pi=>'xor',x=>$x,o=>$o,r=>$r,cv=>0.8},
                  {idly=>1,fs=>7});
           }
           if (o.more) {
               Rw ii/more $x $o $M;
           }
           Rw om/bal $J $oM:M $t:x.j.l $thi:x.thi $in:x.in $out:x.out;
       }
 - K: pi/xor #c
   D: |
     my $c = J.d.c;
     my ($x,$o,$r) = (c.x,c.o,c.r);
     my $pi = o.pig || 'rune';
     my $cv = r.cv || 0.8;
     Jn(r.t,'',{pi=>$pi,s=>$r,gp=>{cv=>$cv}});
    
 - K: clw #c
   n_D:
     curves: |
       spun 0  2
       zoom 0 0.5
       y    0  0.3
       x    0  0.1
       curve 0 -0.1
 - K: pi/lie #c
   D: |
     my $sc = u.sc;
     
     #Jn(catch => 0.03, {pi=>'hangleft',s=>{pi=>'text',s=>sc.r},scwa=>'right:0em'}, '{ab:1,hs:3 9 7 9,fs:13}');
     Jn(lines => 0.07, {pi=>'hangleft',s=>sc.lines}, '{ab:1,co:f42,fs:13}');
     Jn(linein => 0.034, {pi=>'hangleft',s=>sc.in,scwa=>'right:3em'}, '{ab:1,co:e72,fs:10}');
     
     
     my $ind = $1 if sc.h =~ /^(.+?)sc.K/;
     
     
     my $al = $1 if sc.h =~ /sc.K(.+)$/;
     Jn(ind => 0.09, $ind, "{co:38e,fs:12}");
     Jn(K => 0.1, sc.K, "{co:f42,fs:17}");
     # go look for the right side of /K
     Jn(al => 0.11, {fadwi=>$al,s=>slm(20, $al)}, "{co:5ae,fs:12}");
     
     
     #Jn(com => 0.3, {s=>sc.com}, '{co:f42,fs:9}');
     #Jn(
 - K: pi/hangleft #c
   D: |
     my $sq = J.d.c.scwa || 'right:1em';
     Jn(lines => 0.1, $u, "{ab:1,$sq}");
 - K: oundo #c hound god from a crux of inness $x
   D: |
     my $o = {r=>[]};
     # fills up @r to $thi
     # also $plucky to select hash key order
     # a space for tiny-part-of-huge-set access
     
     my $u = x.j.s;
     my $sc = x.sc;
     
     # $plucky could rate the things it gets passed
     # and the $thi yins up out here
     
     sc.ou ||= 'text' if !ref $u;
     sc.ou ||= 'array' if ref $u eq 'ARRAY';
     sc.ou ||= 'code' if ref $u eq 'CODE';
     sc.ou ||= 'hash';
     
     # further dimensional sc if {} or something?
     # so the spec can curve data all the way
     Rw ou/sc.ou + $u $o $x $sc;
     
     sc.grp &&
     Rw og/sc.grp + $u $o $x $sc;
     
     # $r rows over the contents
     # r.c probably for pi, other stuff may pick stuff up...
     
     o.thi = @{o.r};
     $o
 - K: filey #c note uplv for the from $lv, projecting flavour
   n_D:
     yJ: |
       'filey'
     uplv: |
       my $sc;
       if (!lv.sc) {
           say "INIT STYLO ".ejson $lv;
           if (j.s =~ /^[A-Z0]\/./) {
               sc.ou = 'file';
               sc.dir = 'ghosts/';
           }
           # upgrade strings to thoughts
           # drag in 
       }
       Rw jamsc $J $j $sc;
 - K: ou/file #c
   D: |
     my $file = x.j.s;
     defined $file || die 'nofile';
     if (my $dir = sc.dir) {
         $dir .= '/' if $dir !~ /\/$/;
         $file = "$dir$file";
     }
     
     my $J = Rw fil/e $file;
     
     Rw around $J $o $x;
     
 - K: fil #c index of files
   n_D:
     yJ: |
       'fil'
     e: |
       my $J = Rw J5 - fil;
       Rw around + $J;
     around: |
       ar.file ?
          Rw fil/ile
       :();
     ile: |
       my $fid = slm 8, dig $file;
       my $fJ = J.bb->{"$fid\t0.1"};
       if (!$fJ) {
           $fJ = Rw oJ $J $name=lie.$fid $style=lie;
           fJ.bz->("file\t0.1" => $file);
           J.bz->("$fid\t0.1", $fJ, '%file'=>$file);
       }
       $fJ
       
       
       
       
 - K: lie #c one file vector, expanding reconvening substructure of io mess to artifacts and stuff in 0.8
   n_D:
     yJ: |
       'lie'
     flows:
       folate: |
         flow 0.1  {} {}
         stat 0.61 {} {tv:file,et:0}
         read 0.62 {} {tv:file,et:130}
         jam  0.63 {} {tv:read,et:340}
     in: |
       my $o = {};
       Rw around $J $o;
       my ($it) = grep { _.t eq u.t && _.cv eq u.cv } @{o.r};
       $it || die "u.t   u.cv not found!";
       it.sc.dig eq u.dig || die "NOT UP";
       it.s = u.s;
       
       my $file = J.bb->{"file\t".0.1};
       
       write_file($file, join("\n", map {_.s} @{o.r})."\n\n");
       
       Rw around;
       
       say "Saved?";
     around: |
       J.cv ||= 0.3;
       
       Rw flow $J folate;
       
       Rw out
       if ar.o;
     out: |
       my $ip = {cv=>0.4};
       my $vs = Rw tyv $J $ip;
       
       push @{o.r||=[]}, sort { a.sc.in <=> b.sc.in } map { {
          t => _.j.t,
          cv => _.j.cv,
          s => _.j.s,
          sc => _.sc,
       } } @$vs;
       
       o.oJ = $J;
       o.pig = 'lie';
 - K: folate/stat #c
   D: |
     at.is_file = -f j.s;
     my @s = stat j.s;
     at.size = $s[7];
     at.mtime = $s[9];
     at.ctime = $s[10];
 - K: folate/read #c
   D: |
     my $s = read_file(j.s);
     my $dig = dig $s;
     Jn('read' => 0.3 => $s, {dig=>$dig});
     at.dig = $dig;
 - K: folate/jam #c
   D: |
         my $i = 0;
         my $l = {map { $i++ => $_ } split "\n", j.s};
         Jn('lines' => 0.3 => $l);
         my @bu;
         my @nol;
         for my $li (sort {$a<=>$b} keys %$l) {
             my $n = {in=>$li};
             n.s = $l->{$li};
             n.h = n.s;
             
             if (n.s =~ /^.?.?\w/) {
                 n.r = 'low';
             }
             if (n.s =~ /#(c)(.*)$/) {
                 n.r = 'c';
                 n.com = $2 if $2;
             }
             
             n.K = $1 if n.s =~ /K: (\w+[^#]+)/; 
             n.K ||= $1 if n.s =~ /^[^#]*?(\w+[^#]+)/;
             n.K =~ s/\s+$// if n.K;
             if (n.r && n.K) {
                 if (@nol) {
                     n.s = join"\n",@nol,n.s;
                     @nol = ();
                     n.in = 0;
                 }
                 push @bu, $n;
             }
             elsif (@bu) {
                 my $las = $bu[-1]; 
                 las.s .= "\n".n.s;
                 las.out = $li;
             }
             else {
                 push @nol, n.s
             }
         }
         for my $n (@bu) {
             my $s = delete n.s;
             $s||die;
             n.dig = slm 7, dig $s;
             n.lines = split "\n", $s;
             my $j;
             j.l = n.K||n.h;
             j.cv = 0.4;
             Jn(j.l, j.cv, $s);
             Rw jamsc $J $j $sc:n;
             #saybl "N: n.K        ".slim 40, ki $n;
         }
 - K: folate/flow #c
   D: |
       my $fvs = Rw tyv $J:fJ;
       
       for my $fv (@$fvs) {
           my $f = fv.j;
           my $fsc = fv.sc;
           my $vs = Rw tyv $J $l:fsc.tv;
           sayre "Outis: f.r";
           
           for my $lv (@$vs) {
               my $j = lv.j;
               my $coi = Rw pha $J $k=fv.j.l*j.r;
               coi.off = fv.sc.et;
               # resolve $offness, add $and to lv_same
               # if change exactl swoops an init linehum wd
               my $nc = Rw lv_same $lv $j $x:coi $J;
               next if $nc;
               sayyl "f.cv Effect: f.t  f.s";
               saybl "In: j.r   => ".slim 20, j.s;
               
               my $at = {};
               Rw $flow/f.t $J $j $at $sc:lv.sc;
               # ^
               # at travels fast
               # v
               Rw jamsc $J $j $sc:at;
               
               # coi
               coi.same_wd ||= do {
                   my $vs = Rw tyv $J $l:j.l;
                   my $lv = $vs->[0];
                   Rw lv_same $lv $x:coi $J $ret=1;
               };
           
               my $y = coi.exactl->();
           }
       }
 - K: flow #c K-flow
   D: |
     my $name = $m->[0];
     my $oJ = Rw oJ $J $name $style=fl;
     Rw up $J:oJ;
 - K: fl #c stitch at/cs solvents 
   n_D:
     yJ: |
       'fl'
     up: |
       # later shoot out only changed words
       my $h = slm 8, dig ejson[J.Jo.style,J.name];
       
       my $cJ = G.drop.flows->{$h} ||= Rw fl/op;
       
       R.way.hooks.fl->{$h} = cJ.way;
       
       Rw fl/$h/flow $J:J.Jo $fJ:J $cJ;
       #   this ^ for ^ bits ^ loaf ^
     op: |
       # $oJ/flows/M(Carbon switchboard)
       Rw thy $J:J.Jo $oJ:J flows/J.name;
       
       my $vs = Rw tyv $J;
       @$vs || die "no 0.9 on J.name";
       
       my $cJ = Rw oJ $J way;
       Rw suJ $J:ctJ;
       
       # all these ways
       # "Bloody Zipper" plays
       for my $lv (@$vs) { 
           my $j = lv.j;
           sayre "Stitchup j.r    ".ki lv.sc;
           
           my $Z = Rw muck - J.name/j.l;
           my ($s,$no) = values %$Z;
           say $s;
           
           die "wtf".wdump$Z if $no || ref $s eq 'HASH';
           if (ref $s eq 'ARRAY') {
               # mod styley into j.l
           }
           next;
           #wJ.bz->(j.
               
               die wdump $s;
               die "J.flow/j.l $Z";
               die wdump R.way.hooks.folate;
               #J.way = j.s if 
       }
       say wdump [ J.name." styled way: "=>J.way ];
       
       $cJ

