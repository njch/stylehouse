R_Jz:
 - K: on #c
   n_D:
     yJ: |
       J.yl.nojb = 1;
       'on';
     up: | # tak tlv J.on into iterations of upgoing clever
       Rw thy $oJ:J $J:J.Jo defon;
       
       my $vs = Rw tyv $J $ip:ar.ip;
       
       # yawl!
       sayyl "ON J.Jo.name";
       my $nc = -1;
       for my $lv (@$vs) {
           $nc = 0 if $nc == -1;
           my $j = lv.j;
           my $coi = Rw pha $J $k=j.r;
           coi.off=100;
           my $lnc = Rw lv_same $lv $j $x:coi $J $V=1;
           $nc = 0 if !$lnc;
           if ($lnc) {
               sayyl "LINEHUM SAME";
               next;
           }
           
           my $sc = {};
           if (!lv.sc) {
               say "INIT STYLO ".ejson $lv;
               if (j.s =~ /^[A-Z0]\/./) {
                   sc.ou = 'file';
                   sc.dir = 'ghosts/';
               }
               # upgrade strings to thoughts
               # drag in
               Rw jamsc $J $j $sc;
           }
           
           coi.end->();
       }
       $nc;
       
       
 - K: pi/infrom #c
   D: |
     my $x = $u;
     
     Jn('onl', 0.1, "x.j.l", '{co:38f,fs:12}');
     
     Jn('is',0.102,{s=>':',pwth=>'whack'},'{fs:20,co:eee}');
     
     Jn('s', 0.11, {pi=>'',s=>x.j.s},'{fs:15}');
     
     
     
     my $in = {%{x.sc||{}}};
     Jn('sc',0.3, {pi=>'scbund',s=>x.sc},
         {fs=>23 ,co=>'314',sha=>'1 1 3 fff'});
     
     if (my $time = x.sc.ts) { # can't be zero, so relative
         Rw ii/time + $time;
     }
 - K: clw #c
   n_D:
     curves: |
       #spun 0  2
       zoom 0 0.5
       y    0  0
       x    0  0
       curve 0 -0.1
     
 - K: wam #c 
   n_D:
     yJ: |
       'wam clw headi'
     defon: |
       #twang 0.1 Z/2
       #twong 0.1 Z/3
       twzng 0.1 J/2
     up: | # if the in up, pha wakeups out - all response to editing
       J.cv = 20;
       J.mody = 'ano';
       
       my $vs = Rw tvy $J:G.oin;
       die wdump $vs;
       
       Rw on_xor_geo + $J;
       
 - K: cod #c code piece, frontal lobe to the coiled lies
   n_D:
     yJ: |
       'cod';
     in: |
       # GARSP 8 xor flippering tubeway, $e compiling
       
       # could be legit use of B
       my $o = J.cc.o;
       my $r = J.cc.r;
       my $u; # thruster
       
       u.t = r.t;
       u.cv = r.cv;
       u.dig = e.dig;
       u.s = e.code || return sayre "Some kindao ".ki$e;
       
       Rw in $J:o.oJ $u;
     up: |
       my $coi = Rw pha swoosh;
       Rw Jhead;
       
       say gp($J)."   #################>   ".gp($J2);
       die unless $J2;
       J.cc = J2.d.c;
       die gp($J2)."   _d_c notlike xor: ".ki(J2.d) if !J.cc.x;
       # into on^
       # to xor 8ly # all of this ^v codding is tiny coupling
       
       
       my $x = J.cc.x || die 'nox o';
       my $o = J.cc.o;
       my $r = J.cc.r;
       sayyl "oJ      ".gp(o.oJ);
       sayre "x.j.r   x.j.s        " . ki x.sc;
       saybl "r      r.r";
       
       Jn('srcvector',0.1,{pi=>'',s=>o.oJ});
       
       Jn('row',0.2,{s=>r.s},{idly=>1,cm=>'perl',dig=>r.sc.dig,height=>'10em'});
       
       coi.exactl->();
       Rw oJ $J geo &up;
       Rw may $J;
     curves: |
       spun 0  2
       zoom 0 0.5
       y    0  0.37
       x    0  0.37
 - K: lie #c one file vector, expanding reconvening substructure of io mess to artifacts and stuff in 0.8
   n_D:
     yJ: |
       'lie lief'
     in: |
       my $o = {};
       Rw around $J $o;
       my ($it) = grep { _.t eq u.t && _.cv eq u.cv } @{o.r};
       $it || die "u.t   u.cv not found!";
       it.sc.dig eq u.dig || die "NOT UP";
       it.s = u.s;
       
       my $file = J.bb->{"file\t".0.1};
       
       write_file($file, join("\n", map {_.s} @{o.r})."\n\n");
       
       Rw around;
       
       say "Saved?";
     around: |
       J.cv ||= 0.3;
       
       Rw lief $J;
       
       # $o put
       Rw out
       if ar.o;
     out: |
       my $ip = {cv=>0.4};
       my $vs = Rw tyv $J $ip;
       
       push @{o.r||=[]}, sort { a.sc.in <=> b.sc.in } map { {
          r => _.j.r,
          t => _.j.t,
          cv => _.j.cv,
          s => _.j.s,
          sc => _.sc,
       } } @$vs;
       
       o.oJ = $J;
       o.pig = 'lie';
 - K: lief/flows/folate #c
   D: |
     flow 0.1  {} {}
     stat 0.61 {} {tv:file,et:0}
     read 0.62 {} {tv:file,et:130}
     jam  0.63 {} {tv:read,et:340}
 - K: on_xor_geo #c
   D: |
       my $coi = Rw pha $J $k=upix;
       Rw Jhead $J;
       
       my $oJ = Rw oJ $J on;
       my $nc = Rw up $J:oJ;
       # sayre(("ABABAN") x 5) && coi.abandon->('same on') if $nc;
       
       Rw onxor $J $oJ;
       
       coi.exactl->();
       Rw oJ $J geo &up;
       
       Rw shuv $J
       if !ar.nomay;

       say "comat ".F_delta;
     
 - K: onxor #c
   D: |
       my $onl = Rw very $in=0.1 $out=0.9 $J:oJ $tot:J.cv;
       for my $x (@$onl) {
           my $M = [];
           Mn(x.j.l.'-cap' => {thy=>x.thi/5},{pi=>'infrom',s=>$x});
           
           my $o = Rw oundo $x;
           say "   oundoof: ".F_delta;
           my $thy = x.thi / (o.thi||1);
           
           
           for my $r (@{o.r}) {
               #say join " ", sort keys %$r;
               my $fs = sprintf '%.2f', $thy * 9;
               #say " This n x.thi  o o.thi   ==  $thy      $fs";
               Mn( "xor/r.t", {thy=>$thy},
                  {pi=>'xor',x=>$x,o=>$o,r=>$r,cv=>0.6,pwth=>'J5:cod'},
                  {fs=>$fs});
           }
           if (o.more) {
               Rw ii/more $x $o $M;
           }
           Rw om/bal $J $oM:M $t:x.j.l $thi:x.thi $in:x.in $out:x.out;
       }
 - K: pi/xor #c
   D: |
     my $c = J.d.c;
     my ($x,$o,$r) = (c.x,c.o,c.r);
     my $pi = o.pig || 'rune';
     my $cv = r.cv || 0.8;
     Jn(r.t,'',{pi=>$pi,s=>$r,gp=>{cv=>$cv}});
    
 - K: pi/lie #c
   D: |
     my $sc = u.sc;
     
     #Jn(catch => 0.03, {pi=>'hangleft',s=>{pi=>'text',s=>sc.r},scwa=>'right:0em'}, '{ab:1,hs:3 9 7 9,fs:13}');
     Jn(lines => 0.07, {pi=>'hangleft',s=>sc.lines}, '{ab:1,co:f42,fs:13}');
     Jn(linein => 0.034, {pi=>'hangleft',s=>sc.in,scwa=>'right:3em'}, '{ab:1,co:e72,fs:10}');
     
     
     my $ind = $1 if sc.h =~ /^(.+?)sc.K/;
     
     
     my $al = $1 if sc.h =~ /sc.K(.+)$/;
     Jn(ind => 0.09, $ind, "{co:38e,fs:12}");
     Jn(K => 0.1, sc.K, "{co:f42,fs:17}");
     # go look for the right side of /K
     Jn(al => 0.11, {fadwi=>$al,s=>slm(20, $al)}, "{co:5ae,fs:12}");
     
     
     #Jn(com => 0.3, {s=>sc.com}, '{co:f42,fs:9}');
     #Jn(
 - K: pi/hangleft #c
   D: |
     my $sq = J.d.c.scwa || 'right:1em';
     Jn(lines => 0.1, $u, "{ab:1,$sq}");
 - K: oundo #c hound god from a crux of inness $x
   D: |
     my $o = {r=>[]};
     # fills up @r to $thi
     # also $plucky to select hash key order
     # a space for tiny-part-of-huge-set access
     
     my $u = x.j.s;
     my $sc = x.sc;
     
     # $plucky could rate the things it gets passed
     # and the $thi yins up out here
     
     sc.ou ||= 'text' if !ref $u;
     sc.ou ||= 'array' if ref $u eq 'ARRAY';
     sc.ou ||= 'code' if ref $u eq 'CODE';
     sc.ou ||= 'hash';
     
     # further dimensional sc if {} or something?
     # so the spec can curve data all the way
     my $thi = x.thi || die;
     Rw ou/sc.ou + $u $o $x $sc $thi;
     
     sc.grp &&
     Rw og/sc.grp + $u $o $x $sc;
     
     # $r rows over the contents
     # r.c probably for pi, other stuff may pick stuff up...
     
     o.thi = @{o.r};
     $o
 - K: fil #c index of files
   n_D:
     yJ: |
       'fil'
     e: |
       my $J = Rw J5 - fil;
       Rw around + $J;
     around: |
       ar.file ?
          Rw fil/ile
       :();
     ile: |
       my $fid = slm 8, dig $file;
       my $fJ = J.bb->{"$fid\t0.1"};
       if (!$fJ) {
           $fJ = Rw oJ $J $name=lie.$fid $style=lie;
           fJ.bz->("file\t0.1" => $file);
           J.bz->("$fid\t0.1", $fJ, '%file'=>$file);
       }
       $fJ
       
       
       
       
 - K: folate/flow #c
   D: |
     # 2
     for my $c (@{wJ.tvs}) {
         my $coi = Rw pha $J $k=c.K/c.v;
         
         coi.off = c.sc.et if defined c.sc.et;
         sayyl "Trying c.K    c.v        off=coi.off";
         
         my $ip;
         ip.l = c.sc.tv if c.sc.tv;
         my $vs = Rw tyv $J $ip;
         
         my $nc = Rw lv_same $vs $x:coi $J $V=1;
         next if $nc;
         
         die if @$vs > 1;
         for my $lv (@$vs) {
             my $j = lv.j;
             # resolve $offness, add $and to lv_same
             # if change exactl swoops an init linehum wd
             
             sayyl "c.v Effect: c.K ";
             saybl "In: j.r   => ".slim 20, j.s;
               
             my $at = {};
             Rw c.wa $J $j $at $c $sc:lv.sc;
               # ^
               # at travels fast
               # v
               Rw jamsc $J $j $sc:at;
               
               # STYLE
          }
          coi.same_wd ||= do { # catchup (all wong)
              my $vs = Rw tyv $J $ip;
              delete coi.off;
              Rw lv_same $vs $x:coi $J $ret=1 $V=1;
          };
          
          coi.V = 1;
          my $y = coi.exactl->();
       }
 - K: folate/stat #c
   D: |
     at.is_file = -f j.s;
     my @s = stat j.s;
     at.size = $s[7];
     at.mtime = $s[9];
     at.ctime = $s[10];
 - K: folate/read #c
   D: |
     my $s = read_file(j.s);
     my $dig = dig $s;
     Jn('read' => 0.3 => $s, {dig=>$dig});
     at.dig = $dig;
 - K: folate/jam #c
   D: |
         my $i = 0;
         my $l = {map { $i++ => $_ } split "\n", j.s};
         Jn('lines' => 0.3 => $l);
         my @bu;
         my @nol;
         for my $li (sort {$a<=>$b} keys %$l) {
             my $n = {in=>$li};
             n.s = $l->{$li};
             n.h = n.s;
             
             if (n.s =~ /^.?.?\w/) {
                 n.r = 'low';
             }
             if (n.s =~ /#(c)(.*)$/) {
                 n.r = 'c';
                 n.com = $2 if $2;
             }
             
             n.K = $1 if n.s =~ /K: (\w+[^#]+)/; 
             n.K ||= $1 if n.s =~ /^[^#]*?(\w+[^#]+)/;
             n.K =~ s/\s+$// if n.K;
             if (n.r && n.K) {
                 if (@nol) {
                     n.s = join"\n",@nol,n.s;
                     @nol = ();
                     n.in = 0;
                 }
                 push @bu, $n;
             }
             elsif (@bu) {
                 my $las = $bu[-1]; 
                 las.s .= "\n".n.s;
                 las.out = $li;
             }
             else {
                 push @nol, n.s
             }
         }
         for my $n (@bu) {
             my $s = delete n.s;
             $s||die;
             n.dig = slm 7, dig $s;
             n.lines = split "\n", $s;
             my $j;
             j.l = n.K||n.h;
             j.cv = 0.4;
             Jn(j.l, j.cv, $s);
             Rw jamsc $J $j $sc:n;
             #saybl "N: n.K        ".slim 40, ki $n;
         }

