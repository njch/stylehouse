C may:
 -
   - jsc
   - 3
   - |
     hi hi
R_Jz:
 - K: C_may #c
   n_D:
     el:
       CARBON: | #
         {droplist => 'O', subhash => 'X'} # qmco:sutff
     u: | # around
       # so '.this > .that' can move to '.another > .that' bunch of styles
       # lending to high dynamic, low cost of tape
       
       my $seg = ar.m->[0] if ar.m;
       my @css;
       die "nonrefsc u asc esc usc". wdump(ar.m) if !ref $sc; # parse strings too
       # invent the stevecraig format, playing music
       # YIN
       
       # ^ list esc.O
       my $tks; # expand (k:)?lma:v to lma:k:v
       for my $k (sort keys %$sc) {
           my $v = $sc->{$k};
           my $com = ref $v eq 'HASH' ? $k : '';
           my $t = ref $v eq 'HASH' ? $v : {$k=>$v};
           
           for my $tk (sort keys %$t) {
               $tks->{$tk}->{$com} = $t->{$tk};
           }
       }
       
       my $unseen = {map{$_=>1}keys%$tks};
       my $tw; # bang
       for my $tk (@{G.drop.may.O}) {
           my $oms = $tks->{$tk};
           delete $unseen->{$tk};
           next if !$oms;
           for my $com (sort keys %$oms) {
               my $v = $oms->{$com};
               
               my @s = $X->{$tk}->($v, $tks, $X); # < $mish carbon adapt
               # could be a big...
               # tks for X to inject this stream: lma:k:v style (com is k)
               # make better looking pyramids
               
               unshift @s, '%css' if @s == 1;
               while (@s) {
                   my $sty = shift @s;
                   my $s = shift @s;
                   die "$com $sty all3    @s"
                       if defined $tw->{$com}->{$tk}->{$sty};
                       
                   $tw->{$com}->{$tk}->{$sty} = $s;
               }
           }
       }
       die "invent ".join' & ', keys %$unseen if keys %$unseen;
       
       for my $com (sort keys %$tw) {
           my $tks = $tw->{$com};
           for my $tk (sort keys %$tks) {
               my $stys = $tks->{$tk};
               for my $sty (sort keys %$stys) {
                   my $s = $stys->{$sty};
                   #say " ghave $com $sty => $s";
                   $sty .= "#".join('-', grep{$_} $seg, $com, $tk)
                       unless $sty =~ /#/;
                   push @css, $sty => $s;
               }
           }
       }
       #sayre "CSS  @css";
       @css;
       
 - K: maky #c FLAKEY!
   D: |
       # should be somehow, not necessarily # sorta J/1 in gpasm
       J.bz->("/%id\t0.9" => J.id) if J.id && !J.noJid;
       # we may not return html, we dont want wild / hanging around in pristine vectors
       # here is the build up
       # phases of liney (suggestible substrata)
       # gobbling buckies, stretching over the space they tookover
       # and c + sc phased:
       #  t y c sc
       #  stream
       # who can see the previous one (parse next and link current before doing)
       # so the t locator can compress through y somehow
       # ie where in the space to drop the thing so the big thing is...
       
       J.o = {};
       my $vs = Rw tyv $J;
       
       # want the target projection to bounce diffs
       # and so to regroup, do / like envelopes
       # the maka on the border between ux and J wants to have id and tag=ux imposed down, everything else imposed up
       # interesting V shape, laces
       # execution order in J.o is ev
           
       my @s;
       J.ty.maka.s = \@s;
       
       my @things = @$vs;
       my @toplevels; # emerge from things
       
       while (@things || @toplevels) {
           my $lv = shift @things;
           $lv ||= shift @toplevels;
           my $j = lv.j;
           my $sc = lv.sc;
           my $s = j.s;
           my $l = j.l;
           #say "j.r \t\t". join "\t", sort keys %$sc; # gp($sc->{$_})
           
           my $cssdb = 0;
           
           sayyl " thji: j.r" if $cssdb;
           if (j.l eq '/') {
               die "god non 0.9 && j.l eq '/'".wdump(2,$j)
                   if j.cv != 0.9;
               if (@things) {
                      #sayre "defer ".wdump 2, $lv;
                   push @toplevels, $lv; # defer to last
                   next;
               }
           }
           die "reffy $s in $l".wdump(2,$j) if ref $s;
           
           # want to do a bit of voltage vading, opacity...
           # to all the little j makas in the most.J J
           # should take about 1 second
           # can move across network
           
           # top volt for thing selection?: # whattage
           # skip o0 &&verlap of K + name
           # should be fo pi 6 stuff
           next if $l eq 'K' && J.bb->{"name 0.1"} eq $s
              && $s ne J.bb->{"K 0.2"};
           # appearance 
           my $ishtml;
           my $at = {};
           my $css = [];

           if ($l eq '/') {  # thingness # swoosh, swallows up the rest of @s
               # could know this is coming and defer tiny contents
               # favour big picture, only need to surf by...
               # water keeps watering anywhere you look at it
               # the @s gets too big for one message too
               $ishtml = 1;
               $s = join "", @s;
               @s = ();
           }
           for my $k (sort keys %$sc) {
               my $cs = $sc->{$k};
               my ($style,$com) = split '#', $k;
               # < >< >< >?
               # < >< >< >?
               # Jung Cs have injected langauge
               # to grab themselves by...
               # < >< >< >?
               if ($style eq 'gp' || $style eq 'lp' || $style eq 'ishtml') {
                   $ishtml = 1;
               }
               # has a way to $a the gp action within...
               elsif ($style eq 'sf') {
                       push @$css,
                       map { $R::f->{$_} || die "no style $_"}
                           split '_', $cs;
                       #sayre "bit of sf: $cs";
               }
               elsif ($style eq 'css') {
                       $cs = join ';', map{"$_:$cs->{$_}"}
                           sort keys %$cs
                           if ref $cs;
                       push @$css, $cs;
                       sayre "bit of css: $cs" if ar.db;
               }
               elsif ($style eq 'id') {
                   at.id = $cs;
               }
               elsif ($style eq 'tt') {
                   at.title = $cs;
               }
               elsif ($style eq 'tag') {
                   at.tag = $cs;
               }
               elsif ($style =~ /^at:(\S+)$/) {
                   $at->{$1} = $cs;
               }
               elsif ($style eq 'path') {
                   # TODO compile J.ys
                   # should get %idly if not lev/gp too
               }
               elsif ($style eq 'origin') {
               }
               elsif ($style eq 'waves') {
               }
               elsif ($style eq 'pwar') {
               }
               elsif ($style eq 'Joint') {
               }
               elsif ($style eq 'idly') { # is knowable j id
                   my $id = $H->mkuid;
                   at.id && die "arl";
                   at.id = $id;
                   J.idyl->($J, $id, $j);
               }
               elsif ($style eq 'jsc') {
                   at.tag = 'script';
                   at.type = 'text/javascript';
                   sayre "j.l               j.r        ". $s;
               }
               else {
                   die "style??".wdump[$style,$cs];
               }
           }
           @$css = map {
               join '', map{"$_;"} grep{defined} split ';', $_
           } @$css;
           # TODO hold things in pockets relative to origin css comment
           # to help things break down into styles better
           at.style = join '', map{"$_;"}
               grep{defined} map { split ';' } @$css;
           
           # /////////////////////////////////////////////////////
           
       # thingness <-> appearance
       # stylecompressor 3s6 aboves
       # hooch
           if (at.title || !a.untitled) {
               at.title = join " ", grep{defined}
                   (!a.untitled ? "j.cv $l" : undef),
                   (at.title ? at.title : undef);
           }
           my $tag = delete at.tag;
           my $ts = j.l;
           $ts =~ s/[^\w]/Ã±/sg;
           $tag ||= "a$ts";
           $at = join " ", $tag,
               map { saybl " : $_ " if $cssdb; $_ }
               map { $_.'="'.$at->{$_}.'"' } # attra
               grep { $at->{$_} } sort keys %$at;
           
           $s = encode_entities($s) if !$ishtml;
           $s = "<$at>$s</$tag>" if defined $s;
           push @s, $s;
       }
       @s = "no?" if !@s;
       my $html = join '', @s;
       $html;
         

