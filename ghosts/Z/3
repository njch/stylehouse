C may#styley:
 - #
  - gp
  - 5
  - |
     at.ishtml = 1;
 - #
  - lp
  - 5
  - |
     at.ishtml = 1;

 - #
  - ishtml
  - 5
  - |
     at.ishtml = 1;

 -
  - sf # has a way to $a the gp action within...
  - 5
  - |
    push @{at.css}, map { $R::f->{$_} || die "no style $_"} split '_', $v;
 -
  - css
  - 5
  - |
    $v = join ';', map{"$_:$v->{$_}"} sort keys %$v if ref $v;
    push @{at.css}, $v;
 -
  - id
  - 5
  - |
    at.id = $v;
 -
  - tt
  - 5
  - |
    at.title = $v;
 -
  - canvas
  - 5
  - |
    at.canvas = $v;
 -
  - nt
  - 5
  - |
    at.title = undef;
 -
  - type
  - 5.1
  - |
    at.type = $v;
    at.ishtml = 1;
    at.title = undef;
 -
  - tag
  - 5
  - |
    at.tag = $v;
 -
  - at
  - 5
  - |
    $v =~ /^(?:(\S+):)?(\S+)$/;
    $at->{$1} = $2;
 - #
  - atrp
  - 5
  - |
     at.rp = $v;
 -
  - path
  - 5
  - |
    # TODO compile J.ys
    # should get %idly if not lev/gp too
 -
  - origin
  - 5
  - |
    #
 -
  - waves
  - 5
  - |
    #
 -
  - pwar
  - 5
  - |
    #
 -
  - Joint
  - 5
  - |
    #
 -
  - idly
  - 5
  - |
    my $id = $H->mkuid;
    at.id && die "arl";
    at.id = $id;
    J.idyl->($J, $id, $j);
    #
R_Jz:
 - K: sctks #c # expand (k:)?lma:v to lma:k:v
   D: |
     my $tks = {};
     for my $k (sort keys %$sc) {
         my $v = $sc->{$k};
         # possible extra {} level couples into com '' behind $k
         # com is for many of same styles
         my $com = ref $v eq 'HASH' ? $k : '';
         my $t = ref $v eq 'HASH' ? $v : {$k=>$v};

         for my $tk (sort keys %$t) {
             $tks->{$tk}->{$com} = $t->{$tk};
         }
     }
     $tks
     
 - K: gyv #c
   D: |
       my @tops;
       @$vs = grep{defined} map {
           if (_.j.l eq '/') { # make envelope aft
               push @tops, $_;
               $_ = undef;
           } # COMPRESSION v
           elsif (_.j.l eq 'K' && J.bb->{"name 0.1"} eq _.j.s
               && _.j.s ne J.bb->{"K 0.2"}) {
               $_ = undef;
           }
           else {}
           $_    
       } @$vs;
       push @$vs, @tops;
       $vs
     
 - K: scitl #c iterate iterations
   D: |
     my @dl = @$styles;
     warn "nodl" if !@dl;
     
     my $i = 0;
     my @om;
     my $flying = 0;
     sub {
         if (@om) {
             my $o = shift @om;
             $flying = 0;
             return @$o;
         }
         while (1) {
             return if !keys %$tks;
             if (!exists $dl[$i]) {
                 $i = 0;
                 if ($flying++ > 2) {
                     my $cs = {};
                     $cs->{$_} = delete $tks->{$_} for keys %$tks;
                     $flying = 0;
                     if (X.FLYING) {
                         return 'FLYING', '', $cs, $tks;
                     }
                     else {
                         sayre $F[2]->pi,
                         $F[0]->pi,
                         "    unnibblable (make FLYING to catch): ".ki 2, $cs;
                         return;
                     }
                 }
                 next;
             }
             my $tk = $dl[$i];
             if (!exists $tks->{$tk}) {
                 $i++;
                 next;
             }
             my $oms = delete $tks->{$tk};
             # delete so if tks come back, we repeat
             for my $com (sort keys %$oms) {
                 my $v = $oms->{$com};
                 push @om, [$tk, $com, $v, $tks];
             }
             $i++;
             if (@om) {
                 my $o = shift @om;
                 $flying = 0;
                 return @$o;
             }
         }
     }
   

   
 - K: kyv #c go tyv -> com style $cs
   D: |
     my $ts = {};
     for my $k (sort keys %$sc) {
         my $cs = $sc->{$k};
         my ($style,$com) = split '#', $k;
         die if $style =~ /\W/;
         $ts->{$com}->{$style} = $cs;
     }
     $sc = $ts;
 - K: tks_cs #c tks -> style=>v
   D: |
     my $cs = {};
     for my $k (sort keys %$tks) {
         my $w = $tks->{$k};
         my @wks = sort keys %$w;
         my ($el) = @wks;
         my $v = $w->{$el};
         if (@wks > 1) {
             warn "ar.r   style $k collaprse ::: ".ki($w)."\n"
             ." went with $el: $v";
         }
         $cs->{$k} = $v;
     }
     $cs
           
 - K: non #c
   n_D:
     yJup: |
       'non'
    
 - K: linehum #c arrayngement of line
   D: | 
     my @line = 
     sort { a.cv <=> b.cv }
       sort{ a.r cmp b.r }
       lv.j, values %{lv.sj};
     return [ map { [ _.t, _.cv, _.s ] } @line ];
 - K: C_may #c
   n_D:
     el:
       STYLE: | #
         {droplist => 'O',
          subhash => 'X',
          subhash_X_arp => '$d,$at,$J,$j',
         }
     Conned: |
       sayre "conned may:";
       my @l = Rw tvo $J;
       saybl _.r for @l;
     u: |
       # YIN
       #sayyl "Maky on J.name: R.way.hooks.may_X";
       # v should be somehow, not necessarily # sorta J/1 in gpasm
       J.bz->("/\t0.9"=>"y","%id"=>J.id,"%tag"=>"ux");
       
       my $oJ = Rw oJ $J non;
       #  ^ v MMMMMMMMMM
       my $aj = {Wid=>J.id,id=>mkuid,c=>[],sc=>[]};
       
       my $ip = ar.ip || {};
       my $vs = Rw tyv $J $ip;
       # puts / last:
       my $gs = Rw gyv $J $vs;
       
       my @s; # heading
       
       for my $lv (@$gs) {
           my $j = lv.j;
           my $d;
           d.lv = $lv;
           d.s = j.s;
           die "reffy d.s in j.l   ip: ".ki($ip)."\n\n".wdump(2,$j) if ref d.s;
           say "niner j.r" if j.cv == 0.9;
           
           my $k = "j.r xatly";
           my $coi = Rw pha $J:oJ $k;
           my $ln = Rw linehum $lv;
           my $ig = dig ejson($ln);
           my $xat;
           if (oJ.bb->{"at/j.r"}) { # < $at stored & v hum same
               $xat = Rw ph_same $oJ $x:coi $d:ig;
           }
           
           my $at;
           my $pat;
           if (!$xat) {
               $at = d.at = {css=>[]};
               at.s = d.s;

               if (j.l eq '/') { # carbon hapso
                   at.ishtml = 1;
                   at.s = join "", @s;
                   # really like n.sc.M = [...]
                   @s = ();
               }
               
               # keyscrunch
               my $sc = lv.sc;
               # the law is to make it not to crazy
               say "j.r    ".join(' ',sort keys $sc)."     $ig";
               
               # style#Com / v (sctks should eat this, esc chang)
               $sc = Rw kyv $sc;
               # com / style / v
               my $tks = Rw sctks $sc;
               # style / com / v
               d.cs = Rw tks_cs $r:j.r $tks;
               # style / v
               my $styles = G.drop.may.O;
               my $it = Rw scitl $X $tks $styles;
               while (1) {
                   my ($tk, $com, $v, $tks) = $it->();
                   last if !$tk;
                   #say " $tk, $com, $v, $tks";

                   my @s = $X->{$tk}->($v, $tks, $X, $d, $at, $J, $j);
                   #say "May X $tk returned: ". wdump [@s] if @s;
               }
               $pat = oJ.bb->{"at/j.r"};
               oJ.bb->{"at/j.r"} = $at;
               
               my $y = coi.end->();
               my $ex = Rw ph_exactl $J:oJ $y;
           }
           else {
               $pat = $at = d.at = oJ.bb->{"at/j.r"};
           }
           
           #for my $k () {
                
           # } if !$xatly;
           
           
           
           #say wdump $ex;
           # entropiate 
           # rtight here from thy of up
           $at = {%$at}; # must fall apart
           
           my $ats = sub { my $at = shift;
              join',', map{"$_:".ejson($at->{$_})} sort keys %$at;
              };
           
           my $sat = $ats->($at);
           my $spat = $ats->($pat);
           
           if (at.c) {
               next if $sat eq $spat && !at.pur;
               # args for y
               # some day G.w(y, @args);
               my $js = ref at.s eq 'ARRAY' ?
                   join(',',map{ ejson($_) }@{at.s})
               :
                   ejson(at.s);
               acum $aj, 'c', ' a.'.at.c.'('.$js.');';
               next;
           }
           
           # AND .... scribe, slump to end
           my $css = delete at.css;
           @$css = map {
               join '', map{"$_;"} grep{defined} split ';', $_
           } @$css;
           
           # TODO hold things in pockets relative to origin css comment
           # to help things break down into styles better
           # this is what language for,
           at.style = join '', map{"$_;"}
               grep{defined} map { split ';' } @$css;
           
           # compressior
           # stylecompressor 3s6 aboves
           # hooch
           if (!exists at.title || defined at.title) {
               at.title = "j.cv j.l".(defined at.title && " at.title");
           }
           
           my $s = delete at.s;
           my $ishtml = delete at.ishtml;
           $s = encode_entities($s) if !$ishtml;
           
           my $tag = delete at.tag;
           my $ts = j.l;
           $ts =~ s/[^\w]/Ã±/sg;
           $tag ||= "a$ts";
           my $arp = delete at.rp if exists at.rp;
           my $mat = join " ", $tag,
               map { saybl " : $_ "; $_ }
               map { $_.'="'.$at->{$_}.'"' } # attra
               grep { $at->{$_} } sort keys %$at;
           
           $mat .= ' '.$arp if defined $arp;
           
           $s = "<$mat>$s</$tag>";
           push @s, $s;
       }
       @s = "no?" if !@s;
       my $html = join '', @s;
       
       aj.s = $html;
       
       if (!ar.catj) {
           Rw Em $aj;
       }
       
       $aj
       # STYLE
       

