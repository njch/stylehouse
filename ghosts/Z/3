C may:
 - #
  - gp
  - 5
  - |
     at.ishtml = 1;
 - #
  - lp
  - 5
  - |
     at.ishtml = 1;

 - #
  - ishtml
  - 5
  - |
     at.ishtml = 1;
 -
  - sf # has a way to $a the gp action within...
  - 5
  - |
    push @$css, map { $R::f->{$_} || die "no style $_"} split '_', $v;
 -
  - css
  - 5
  - |
    $v = join ';', map{"$_:$v->{$_}"} sort keys %$v if ref $v;
    push @$css, $v;
 -
  - id
  - 5
  - |
    at.id = $v;
 -
  - tt
  - 5
  - |
    at.title = $v;
 -
  - tag
  - 5
  - |
    at.tag = $v;
 -
  - at
  - 5
  - |
    $v =~ /^(?:(\S+):)?(\S+)$/;
    $at->{$1} = $2;
 -
  - path
  - 5
  - |
    # TODO compile J.ys
    # should get %idly if not lev/gp too
 -
  - origin
  - 5
  - |
    #
 -
  - waves
  - 5
  - |
    #
 -
  - pwar
  - 5
  - |
    #
 -
  - Joint
  - 5
  - |
    #
 -
  - idly
  - 5
  - |
    my $id = $H->mkuid;
    at.id && die "arl";
    at.id = $id;
    J.idyl->($J, $id, $j);
    #
 -
  - jsc
  - 5
  - |
    at.tag = 'script';
    at.type = 'text/javascript';
    sayre "j.l               j.r        ". d.s;
    d.s = "a.".j.l." = function (A,C,G,T) {\n".d.s.";\n"
    say wdump d.s;
    #
R_Jz:
 - K: kyv #c go tyv -> style com $cs
   D: |
     my $ts = {};
     for my $k (sort keys %$sc) {
         my $cs = $sc->{$k};
         my ($style,$com) = split '#', $k;
         $ts->{$style}->{$com} = $cs;
     }
     $sc = $ts;
 - K: gyv #c gplumb
   D: |
       @$vs = grep{defined} map {
           if (_.j.l eq '/') { # make envelope aft
               push @tops, $_;
               $_ = undef;
           } # COMPRESSION v
           elsif (_.j.l eq 'K' && J.bb->{"name 0.1"} eq _.j.s
               && _.j.s ne J.bb->{"K 0.2"}) {
               $_ = undef;
           }
           else {}
           $_    
       } @$vs;
       $vs
     
 - K: scitl #c iterate iterations
   D: |
     my ($n,$h) = @$m;
     
     my @dl = @{G.drop->{$n}->{$h}};
     warn "nodl" if !@dl;
     my $pr = {%$tks};
     
     my $unseen = {map{$_=>1}keys%$tks};
     
     my $i = 0;
     my @om;
     sub {
         if (@om) {
             my $o = shift @om;
             return @$o;
         }
         while (1) {
             return if !keys %$tks;
             if (!exists $dl[$i]) {
                 $i = 0;
                 
             }
             my $tk = $dl[$i];
             my $oms = delete $tks->{$tk};
             # delete so if tks come back, we repeat
             for my $com (sort keys %$oms) {
                 my $v = $oms->{$com};
                 push @om, [$tk, $com, $v, $tks];
             }
             $i++;
             if (@om) {
                 my $o = shift @om;
                 return @$o;
             }
         }
     }
   
 - K: C_may #c
   n_D:
     el:
       STYLE: | #
         {droplist => 'O',
          subhash => 'X',
          subhash_X_arp => '$d,$at,$css,$J,$j',
         }
     Conned: |
       sayre "conned may:";
       sayyl R.way.hooks.may_X;
       my @l = Rw tvo $J;
       saybl _.r for @l;
     u: |
       # YIN
       # should be somehow, not necessarily # sorta J/1 in gpasm
       J.bz->("/%id\t0.9" => J.id) if J.id && !J.noJid;
       
       my $vs = Rw tyv $J;
       sayyl "Maky on J.name: R.way.hooks.may";
       
       $vs = Rw gyv $J $vs;
       
       my @s;
       
       for my $lv (@$vs) {
           my $d;
           my $j = lv.j;
           my $sc = lv.sc;
           d.s = j.s;
           die "reffy d.s in j.l".wdump(2,$j) if ref d.s;
           say "niner j.r" if j.cv == 0.9;
           my $at = d.at = {};
           my $css = d.css = [];
           
           if (j.l eq '/') { # carbon hapso
               at.ishtml = 1;
               d.s = join "", @s;
               @s = ();
           }
           
           $sc = Rw kyv $sc;
           my $tks = Rw sctks $sc;
           my $it = Rw scitl $tks may O;
           while (1) {
               my ($tk, $com, $v, $tks) = $it->();
               last if !$tk;
               say " $tk, $com, $v, $tks";

               my @s = $X->{$tk}->($v, $tks, $X, $d, d.at, d.css, $J, $j);
               say wdump [@s];
           }
           # Jung Cs have injected langauge
           # to grab themselves by...
           # < >< >< >?
           
           @$css = map {
               join '', map{"$_;"} grep{defined} split ';', $_
           } @$css;
           # TODO hold things in pockets relative to origin css comment
           # to help things break down into styles better
           at.style = join '', map{"$_;"}
               grep{defined} map { split ';' } @$css;
           
           # /////////////////////////////////////////////////////
           
       # thingness <-> appearance
       # stylecompressor 3s6 aboves
       # hooch
           if (at.title || !J.untitled) {
               at.title = join " ", grep{defined}
                   (!J.untitled ? "j.cv j.l" : undef),
                   (at.title ? at.title : undef);
           }
           
           my $ishtml = delete at.ishtml;
           my $tag = delete at.tag;
           my $ts = j.l;
           $ts =~ s/[^\w]/Ã±/sg;
           $tag ||= "a$ts";
           $at = join " ", $tag,
               map { saybl " : $_ "; $_ }
               map { $_.'="'.$at->{$_}.'"' } # attra
               grep { $at->{$_} } sort keys %$at;
           
           my $s = d.s;
           $s = encode_entities($s) if !$ishtml;
           $s = "<$at>$s</$tag>" if defined $s;
           push @s, $s;
       }
       @s = "no?" if !@s;
       my $html = join '', @s;
       say "make all of $html";
       $html;
       
       # STYLE
       
 - K: 333 #c FLAKEY!
   D: |
         

