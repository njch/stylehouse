oo/flows/ooj: |
   flow 1
   Y 2
   C 4
   time 7
   ing 3
   JJ 3
   
ooj/flow: |
   my $A = {J=>$J,C=>$C};
   
   # 3
   
   # 7
   
   # 9
   C.sc.J
ooj/Y:
    -
     - cts_Y #
     - 2
     - |
       for my $ct (@{wJ.cts.Y}) {
           next unless ct.any or exists $C->{ct.t_k} && exists $C->{ct.t_k}->{ct.t};
           my $v = $C->{ct.t_k}->{ct.t} unless ct.any;
           my $at = {};
           my $T = {};
           my $d = $C; # bendy stick throw
           my $c = C.c; # <v contation
           my $g = wJ.ctx.Y;
           
           wJ.ctx.Y->{ct.x}->($A,$C,$g,$T,$J,$d,$v,$at);
           
           return die @{T.return} if T.return;
           die "atgot ". ki $at if %$at;
           die "Tgot ct.x ". ki $T if %$T;
       }
       
ooj/C:
    -
     - cts_C #
     - 5
     - |
       A.note = {};
       A.note.not = sub {
           my ($ct,$k) = @_;
           A.note.>$ct.>$k = 1;
       };
       
       my $g = wJ.ctx.C;
       for my $ct (@{wJ.cts.C}) {
           next unless ct.any or exists $C->{ct.t_k}->{ct.t};
           my $v = $C->{ct.t_k}->{ct.t} unless ct.any;
           ct.t_k eq "c" && A.note.not&c,ct.t;
           my $at = {};
           my $T = {};
           my $at = {};
           my $d = $C; # bendy stick throw
           my $c = C.c; # <v contation
           wJ.ctx.C->{ct.x}->($A,$C,$g,$T,$J,$d,$v,$at);
           
           
           for my $k (keys %$at) {
               C.sc->{$k} = $at->{$k};
           }
           return @{T.return} if T.return;
           last if T.last;
           #die "Tgot ". ki $T if %$T;
       }
       
anno/opi:
   - MZ: moz:C
   - [s, 2, 'd.s = $v;']
   - [pi, 2, 'd.s = "ou?$v";']
   - MZ: isway:1
   - [oJ, 1.12, 'Rw oJ1;']
   - [J, 1.2, 'Rw oJ2;']
   - [W, 2,  'Rw oW2;']
   - [pi, 2, 'Rw opi2;']
   - [J, 3, 'Rw oJ3;']
   - [J, 6, 'Rw oJ6;']
   - [J, 7, 'Rw oJ7;']
ooj/ing: 
   - MZ: Cc:C
   -
    - sc
    - 1
    - |
     C.sc = delete C.c.sc;
      
   - MZ: Cc:Cany
   -
    - puts
    - 7
    - |
       my @jh = grep{!A.note.c->{$_}}keys %{C.c};
       if (@jh) {
           sayyl "oo  C.t C.y.cv   ->  ".join "      ",
               map { "$_ = ".gp C.c->{$_}}@jh unless C.sc.J.yt.quiet;
           A.hav = 1;
       }
       else {
           sayyl "oo  C.t C.y.cv" unless C.sc.J.yt.quiet;
       }
ooj/JJ: 
   - MZ: Cc:C
   - MZ: isway:1
   -
    - J
    - 1.12
    - |
     C.c.W = C.c.J;
     Rw oW2;
     
   - MZ: Csc:C
   -
    - J
    - 3
    - |
      die if !C.t;
      die if !C.y.cv;
      Rw oJ3;
      die if !ref C.sc.J;
      #Rw jamsc $J $C $sc:C.sc;
      
      
    - way: 1

   - MZ: Csc:Cany
   -
    - Joing 
    - 8
    - |
      Rw oJ6;
    - way: 1
ooj/time:
   - MZ: Cc:Yany
   -
    - time
    - 3
    - |
      A.ztime = C.c.time || 8;
      A.time = sub {
           my ($J,$wa) = @_;
           A.ztime >= $wa ? 1 : do {
               Rw comb oo $J $A $C $wa;
           };
      };
    - way: 1
      
   - MZ: Cc:C
   -
    - ok
    - 2.2
    - |
       A.ztime = 1;
       A.note.not&csrm,'ok';
       
       my $co = A.jr&ok-$v;
       my $til = $co - hitime;
       # cv wave column to plant next self in
       A.waov = $v;
       # assume that v shapes delay until DNS of tension
       my $del = $v;
       if ($co && $til < 0) {
           sayre "running late: ". $til if $til < -0.1;
           A.ztime = $v if $v > A.ztime; # on there
           undef $co;
       }
       elsif (!$co) {
           $del = 0.1;
           sayyl "begins";
       }
       $del *= 3.7;
       $del *= 1.2 if rand 5 > 3;
       $co ||= $del + hitime;
       
       A.watime = $co;
       
       A.jr&ok-$v,$co;
   - MZ: Cc:Cany
   -
    - time2
    - 2.9
    - |
       Atime(2) or T.return = [];
   -
    - time4
    - 4.9
    - |
       Atime(4) or T.return = [];
   -
    - time8
    - 8.9
    - |
       Atime(8) or T.return = [];

