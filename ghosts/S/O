
C:
  - K: Elvis
    max_tooth_Hz: 12
    Gw: 1
hooks:
  fresh_init: |
    saygr "freshly H.ol ".`fig O`;
    
    H.O = $G;
    
    H.G w Jexit;
  recoded_init: |
    w retile;
    $G->pub('S/hut/o', 'Hiwtidy');
  Teeth: |
    H.G w Teeth; 
  mux: |
    ar.as ||= '?';
    push @{G.muxis||=[]}, ar.as;
    0->sing(retile => sub {
        sayyl "mux after: ".join"\n , ",@{G.muxis};
        G.muxis = [];
        w retile;
    }, begin => 0.2, again => 0.2);
  send_Elvis: |
    die;
    H.G w O_Elvis;
  websocket: | # Mojo throws connection over here
    my $u = { K=>'Elvis', B=>{tx => $M->tx, M => $M}};
    w G.R fuu[$u];
  elvibe: |
    sayyl "elvibe ?? jjj | ".$E->pi;
    
    my $js = " return elvis "; # random number
    my $cb = sub{ w elvibium(e => shift, E=>$E); };
    H.G w jaw[$js,$cb,$E];
    
  elvibium: |
    E.e = $e; 
    0->accum($H,'who',$E);
    for my $m (@{H.Jels}) {
        w $E send[$m];
    }
    w z/clon;
    w z/keon;
    
    $G->pub("S/H.style", "elv ".($e+0));

        
  elvis_leaves: |
    0->deaccum($H,'who',$E);
    sayre "Finash";
  z:
    getgeometry: |
      $H->send(" w".".reply({geometry: {x: screen.availWidth, y: screen.availHeight}});");
    empty_body: |
      $H->send("\$('body').empty();");
    clon: |
      $H->send(" clon();");
    keon: |
      $H->send(" keon();");
    hitground: |
      $H->JS("\$('#sky').stop().slideUp();");
    wzy: |
      $E->send(" s\.r('wsy '+ w\.conin +' '+ s\.conin );");
    coninto: |
      $H->send(" a\.con({conin: '$conin'});");
    
  Elvis: #
      # here we want to graph things out real careful
      # because it is how things get around
      # the one to the many
      # apps can be multicasting too
      # none of these workings should be trapped at this level
      # send it out there and get the hair on it
    flows_D: |
      Sw tx_uglies;
      S.mouth = [];
      
      B.elvii = ++H.elvii;
      B.sign ||= "eeeeeeeeeeeeeeeeeeeeee";
      
    swoosh: |
      saygr $sign;
      
    humms_D: |
      w elvibe(E=>$S);
    
    print: |
      $elvii.'@'.$address;
    
    send: |
      my $cb = ar.cb;
      $tx->send($m, $cb);
      
    speaks: |      
      my $E = $S;#1
      saybl "> ".$E->pi;
      H.elvis = $E;
      w Teeth[$m, $E];#...
      Sw swoosh; #9
      
      
    mouthfull: |
      for my $mJ (@{S.mouth}) {
            return 1 if mJ.dig eq J.dig &&
                (1 / (J.hitime - mJ.hitime)) > S.max_tooth_Hz
      }
      push @{S.mouth}, $J;
      shift @{S.mouth} if @{S.mouth} > 3;
      return 0;
    
    populi: |
      my @all = w G.R fi(f=>{K=>"Elvis"});
      if (@all > 1) {
          sayre " Elvis is taking over!";
          _.B.tx->finish for @all;
          sayre " restarting...";
          w reexec;
      }
      
    leaves: |
      sayre "Elvis leaves: ".$S->pi."  $address - $code, $reason";
      Sw disco;
    disconecktie: |
      $tx->finish;
      sayyl "Dsicog ".$S->pi;
      Sw disco;
    disco: |
      S.disco = 1;
      w elvis_leaves(E=>$S);
    
    tx_uglies: |
      Mojo::IOLoop->stream($tx->connection)->timeout(300000);
      $M->on(message => sub {
          my ($M, $m) = @_;
          eval { Sw speaks[$m]; };
          sayre "Elvis-induced error ".$S->pi."  $@" if $@;
          $@ = "";
      });
      $M->on(finish => sub {
          my ($M, $code, $reason) = @_;
          Sw leaves[$code, $reason];
      });
      B.address = $tx->remote_address;
  retile: | # TODO use J
    die "retile rid of H.r";
    my @m = map { /W\/(.+)$/ } H.r->keys("W/*");
    @m = map { $H->djson(H.r->get("W/$_")) } @m;
    
    H.G w TODOWhack(meta=>$_) for grep { _.dead } @m;
    @m = grep { !_.dead } @m;
    
    @m = grep { _.styles =~ /\bNZ\b/ } @m;
    @m = sort { a.hol cmp b.hol } @m;
    
    my $space = 1;
    $space += 0.5 until $space * $space >= @m;
    my $r = floor $space;
    my $l = ceil $space;
    my $div = ["width:left $l", "height:top $r"];
    
    say "needed ".@m." so $space is $l $r";
    
    my $grid = {};
    for my $p (@$div) {
        my ($iv, $parts) = split ' ', $p;
        my ($mags, $ax) = split ':', $iv;
        # magnitudes of width
        # axed from unified by left, etc.
        my $in = sprintf("%.3f", 1 / $parts);
        
        my @ground = map { [$_ => $grid->{$_} ] } sort keys %$grid;
        @ground = [] if !@ground;
        my $pole = [];
        $grid = {};
        
        my $here = 0; # in accum
        for my $i (1..$parts) {
            my $ox = {};
            ox.part = $i;
            $ox->{$ax} = $here;
            $here += $in;
            $ox->{$mags} = $in;
            push @$pole, $ox;
        }
        
        for my $g (@ground) {
            my ($k, $v) = @$g;
            $v ||= {};
            for my $ox (@$pole) {
                my $K = (defined $k?"$k ":"") . ox.part;
                my $x = $grid->{$K} = {%$v, %$ox};
                delete x.part;
            }
        }
    }
    
    my @holes = sort keys %$grid;
    say "Got ".@m." pegs for ".@holes." holes: ".wdump[@m];
    for my $meta (@m) {
        my $h = shift @holes;
        my $o = {%{$grid->{$h}}};
        
        $o->{$_} = ($o->{$_} * 100)."%" for keys %$o;
        
        meta.ces = $o;
        H.r->set("W/meta.Wid" => $H->ejson($meta));
        
        my $cssset = ".animate(".$H->ejson($o).", 0)";
        my $unhide = ".removeClass('NZ')";
        
        $H->send(" \$('#".meta.Wid."')$cssset$unhide".";");
    }
  waits: |
    my $towait = ar.towait || 1;
    my $to = ar.to;
    
    my $max = max map { _.div } @$to;
    _.span = $max / _.div for @$to;
    
    my $tot = sum map { _.span } @$to;
    my $one = $towait / $tot;
    
    my $ord = {};
    for my $t (@$to) {
        my $waits = $one * t.span;
        $waits = sprintf("%.7f", $waits);
        t.waits = $waits;
        push @{ $ord->{$waits} ||= [] }, $t
    }
    return $ord;
    

