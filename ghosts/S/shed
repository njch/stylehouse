hooks:


  recoded_init: |
    w retile;
  non: |
      my @olds = H.r->keys("H/$a[1]/$a[2]*");
      for my $oth (@olds) {
          my @b = split '/', $oth;
          if ($b[3] eq $a[3]) {
              sayyl " haf self";
            next;
          }
          my $hol = join '/', @b[2..4];
          for my $vh (H.r->keys("V/$b[3]*")) {
              my (@v) = split '/', $vh;
              my $ww = $v[2];
              $H->send(" \$('#ux > #$ww').remove();");
              H.r->del($vh);
              H.r->del("W/$ww");
          }
          H.r->del($oth); 
      }
  node: #c
      O:
       - D: |
           H.r->ping() || die "no redids?";
           $G->su("Elvis", sub {
             my $a = shift;
             H.G w pubbedElvis[$a];
           });
      
           
      Z:
       - GAK: 0
  minorport: |
      my $p = ord(H.name);
      $p += 8000;
      say "Sport: $p";
      $p;
  elvus: |
      sayg "elvission modio";
      w elvis_enters;
    
  singul: |
      sayg "sSingu mode";
      w elvis_enters;   
      
      w z/clon;
      w z/keon;

      Mojo::IOLoop->recurring(6 => sub{ w honk; });
  honk: |
      $H->send('.'. (("  ")x int(2 + rand 3))."!!!");
       
  pull_conin: | # head receives the headless
    saygr "H.style/H.name        pulls conin     $m";
    my ($style, $name, $id, $conin) = split ' ', $m;
    die "mal cone push: '$m'" if !$conin;
    H.G w z/coninto[$conin];
    
  push_conin: | # the headless seeks heads
    saygr "H.style/H.name        pushes conin";
    $H->pub("S", "push_conin H.style H.name H.id H.listen_ws");   

      

  Elvis: #
      # here we want to graph things out real careful
      # because it is how things get around
      # the one to the many
      # apps can be multicasting too
      # none of these workings should be trapped at this level
      # send it out there and get the hair on it
    flows_D: |
      Sw tx_uglies;
      S.mouth = [];
      
      B.elvii = ++H.elvii;
      B.sign ||= "eeeeeeeeeeeeeeeeeeeeee";
      
    swoosh: |
      saygr $sign;
      
    humms_D: |
      w elvibe(E=>$S);
    
    print: |
      "$elvii $elvii =B.style=B.name=B.id B.conin $address";
    
    send: |
      my $cb = ar.cb;
      $tx->send($m, $cb);
      
    speaks: |      
      my $E = $S;#1
      H.who = $E;
      w Teeth[$m, $E];#...
      Sw swoosh; #9
      
      
    disconecktie: |
      $tx->finish;
      Sw disco;
    disco: |
      S.disco = 1;
      w elvis_leaves(E=>$S);
      
    mouthfull: |
      for my $mJ (@{S.mouth}) {
            return 1 if mJ.dig eq J.dig &&
                (1 / (J.hitime - mJ.hitime)) > S.max_tooth_Hz
      }
      push @{S.mouth}, $J;
      shift @{S.mouth} if @{S.mouth} > 3;
      return 0;
    
    populi: |
      my @all = 0->rei({K=>"Elvis"});
      if (@all > 1) {
          sayre " Elvis is taking over!";
          _.B.tx->finish for @all;
          sayre " restarting...";
          w reexec;
      }
      
    leaves: |
      sayre "Elvis leaves: ".$S->pi."  $address - $code, $reason";
      Sw disco;
    
    tx_uglies: |
      Mojo::IOLoop->stream($tx->connection)->timeout(300000);
      $M->on(message => sub {
          my ($M, $m) = @_;
          eval { Sw speaks[$m]; };
          $H->error("$@") if $@;
          $@ = "";
      });
      $M->on(finish => sub {
          my ($M, $code, $reason) = @_;
          Sw leaves[$code, $reason];
      });
      B.address = $tx->remote_address;
  figure_port: |
    my $listen = readlink('listen');
    my ($host,$port, $wa) = split ':', $listen;
    die "too much listen" if $wa;
    ($port, $host) = (2000, undef) if !$port && $host =~ /^\d+$/;
    $port ||= 2000;
    $host ||= '127.0.0.1';

    $port += w minorport;
    
    H.listen_http = "http://$host:$port";   
    H.listen_ws = "ws://$host:$port/s";
    
  websocket: | # Mojo throws connection over here
    0->TafuB(Elvis => {tx => $M->tx, M => $M});
  websockout: | # we make websockets out # BROKE
    Say "Ws out $conin";
    use Mojo::UserAgent;
    my $ua = Mojo::UserAgent->new;
    $ua->websocket($conin => sub {
      my ($ua, $tx) = @_;
      die "HELLO!";
      die "WebSocket handshake failed! $conin" and return unless $tx->is_websocket;
      Say "Connecto!";
      0->TafuB(Elvis => {tx => $tx, M => $tx, %$ar});
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
    
  S:
    push_conin: |
      w pull_conin if H.singul;
    please_push_conin: |
      w push_conin if !H.singul;
    wsy: |
      my $C = G.conz ||= {};
      my ($w, $s) = split ' ', $m;
      # check the tip for dup
      my $EE = G.conz->{$w};
      if ($EE && !EE.disco && 0) {
          w elvash[$E, $EE];
      }
      G.conz->{$w} = $E;
      (E.c->{w}, E.c.s) = ($w, $s);
      E.singul = 1 if $w eq $s; 
      
      w elvjs;
  z:
    getgeometry: |
      $H->send(" w".".reply({geometry: {x: screen.availWidth, y: screen.availHeight}});");
    empty_body: |
      $H->send("\$('body').empty();");
    clon: |
      $H->send(" clon();");
    keon: |
      $H->send(" keon();");
    hitground: |
      $H->JS("\$('#sky').stop().slideUp();");
    wzy: |
      $E->send(" s\.r('wsy '+ w\.conin +' '+ s\.conin );");
    coninto: |
      $H->send(" a\.con({conin: '$conin'});");
  elvash: |
    sayre "A new ".$E->pi."  closing => ".$EE->pi;
    w $EE disconecktie;
    $EE->send(" C[s\.conin] = s;");
    H.who = $E;
  elvjs: | # elvis swam through wsy, is js client
    if (E.singul) {
        H.who = $E;
        H.singul = 1;
        w singul;
    }
    else {
        H.singul = 0;
        w elvus;
    }
  elvibium: |
    if (H.Jels) {
        $H->send($_) for @{H.Jels};
    }
  elvibe: |
    Say "En nnnn Elvis ?? J | ".$E->pi;
    if (E.B.style) {
        Say "Elvis got it ".$E->pi;
        return;
    }
    w z/wzy; # conz, swim
    
  send_Elvis: |
    my $Elvis = ar.Elvis || ar.E || H.who;
    my $cb = ar.cb;
    if (!$Elvis) {
        warn "no infiduvial? $m";
        push @{H.Jels||=[]}, $m;
        return;
    }
    $m =~ /\n/ && say "Message contains \\n:\n$m\n\n";
    $m =~ s/\n//g;
    saybl " < ".slim(30,30,$m);
    w $Elvis send[$m, $cb];

 #heisto thing
 
  aj: | 
    if (j._) {
        saygr j.G->pi." unified field! see for ".@{j.s};
        H.G.A.W->{j._.at.id} = j.G.W;
    }
    
    0->accum($G, Js => $j);
    
    my @Es = w Es;
    for my $E (@Es) {
        w sEnj[$E, $j];
    }
    sayg "j to the ".@Es;
  sEnj: |
    my @lot = reverse @{j.s};
    push @lot, reverse @{j.c};
    saygr scalar(@lot)." ->->->-> ".$E->pi;
    
    for my $l (@lot) {
        ref $l && die "reff $l";
        $E->send(" ".$l);
    }
    
    if (j._) {
        saygr "j.G.name unified field hits tiles!";
        0->sing(retile => sub { H.G w retile[$E]; }, begin => 0.8);
    }
    # after U - direct to tape instead of catching JS in H
    
  Es: |
    uniq @{G.Es};
  elvis_enters: |
    saygr "jump on the j train ".$E->pi;
    0->accum($G, 'Es', $E);
    
    if (H.singul) {
        $H->pub("S", "please_push_conin");
    }
    
    for my $j (@{G.Js}) {
        w sEnj[$E, $j];
    }
  elvis_leaves: |
    0->deaccum($G => Es => $E);

