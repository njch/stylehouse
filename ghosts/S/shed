hooks:
  in: |
      H.h = G.A->spawn(G => "Ϡ", 'S', "S/H.style", "S/H.style/H.name");
      
  node: #c
      O:
       - D: |
           H.r->ping() || die "no redids?";
           sayyl "Subbing Elvis*";
           $G->su("Elvis*", sub {
             my $a = shift;
             H.G w pubbedElvis[$a];
           });
           sayyl "Do:";
           
      Z:
       - GAK: 0
  any_init: |
    sayre join "  ", H.r->keys("*"); 
  minorport: |
      my $p = ord(H.name);
      $p += 8000;
      say "Sport: $p";
      $p;

  elvus: |
      sayg "elvission modio";
      G:Ϡ w elvis_enters;
    
  singul: |
      sayg "sSingu mode";
      G:Ϡ w elvis_enters;   
      
      w z/clon;
      w z/keon;

      Mojo::IOLoop->recurring(6 => sub{ w honk; });
  honk: |
      $H->send('.'. (("  ")x int(2 + rand 3))."!!!");
       
  pull_conin: | # head receives the headless
    saygr "H.style/H.name        pulls conin     $m";
    my ($style, $name, $id, $conin) = split ' ', $m;
    die "mal cone push: '$m'" if !$conin;
    H.G w z/coninto[$conin];
    
  push_conin: | # the headless seeks heads
    saygr "H.style/H.name        pushes conin";
    $H->pub("S", "push_conin H.style H.name H.id H.listen_ws");   

      
  mess: |
    # TODO R should handle incoming
    # and outgoing subs, pubs
    # in between is quiet Accumessing
    unless (H._future) {
        # circular or pre-G:H # R catch
        saygr "prefut ar.what  = ".
            join"  ", map {gpty($_)} flatline(ar.thing);
        return;
    }
    my $S = 0->TB(mess => {thing => $thing, what => $what});
    S.m = $what;
    S.Flab = $G->Flab($S);
    
    $_->($S) for @{G.messtrigs||=[]}; # way?
    
    if (S.m =~ /^(Ambientness|Vitals)$/) {
        # keep only 5?
        my @ze = 0->rei({K=>'mess', m=>$1});
        shift @ze for 1..5;
        $_ ne $S && 0->del($_) for @ze;
    }
    my @ze = 0->rei({K=>'mess'});
    shift @ze for 1..50;
    $_ ne $S && 0->del($_) for @ze;

    
    H._future = 1;
    
  Elvis: #
      # here we want to graph things out real careful
      # because it is how things get around
      # the one to the many
      # apps can be multicasting too
      # none of these workings should be trapped at this level
      # send it out there and get the hair on it
    flows_D: |
      Sw tx_uglies;
      S.mouth = [];
      
      Sw populi if ! H.h; # dodge
      H.who = $S if ! H.h; # hut later
      B.elvii = ++H.elvii;
      B.sign ||= join "", (`figlet '<<<<'`)[-2]; chomp B.sign;
      
    swoosh: |
      saygr $sign;
      
    humms_D: |
      w elvibe(E=>$S);
    
    print: |
      "$elvii $elvii =B.style=B.name=B.id B.conin $address";
    
    send: |
      $tx->send(J.B.m, J.B.cb);
      
    speaks: |      
      my $E = $S;#1
      my $J = 0->Bu(J => {m=>$m});#2
      if (w $S mouthfull[$J]) {#3 pyramid full
          sayyl "elvis losing teeth ".$S->pi;
          return; # more stim than stamp
      }
      H.who = $E;
      w Teeth[$J, $E];#...
      Sw swoosh; #9
      
      
    disconecktie: |
      $EE->send(" C[s\.conin] = s;");
      $tx->finish;
      Sw disco;
    disco: |
      S.disco = 1;
      G:Ϡ w elvis_leaves(E=>$S) if G:Ϡ;
      
    mouthfull: |
      for my $mJ (@{S.mouth}) {
            return 1 if mJ.dig eq J.dig &&
                (1 / (J.hitime - mJ.hitime)) > S.max_tooth_Hz
      }
      push @{S.mouth}, $J;
      shift @{S.mouth} if @{S.mouth} > 3;
      return 0;
    
    populi: |
      my @all = 0->rei({K=>"Elvis"});
      if (@all > 1) {
          sayre " Elvis is taking over!";
          _.B.tx->finish for @all;
          sayre " restarting...";
          w reexec;
      }
      
    leaves: |
      sayre "Elvis leaves: ".$S->pi."  $address - $code, $reason";
      Sw disco;
    
    tx_uglies: |
      Mojo::IOLoop->stream($tx->connection)->timeout(300000);
      $M->on(message => sub {
          my ($M, $m) = @_;
          eval { Sw speaks[$m]; };
          $H->error("$@") if $@;
          $@ = "";
      });
      $M->on(finish => sub {
          my ($M, $code, $reason) = @_;
          Sw leaves[$code, $reason];
      });
      B.address = $tx->remote_address;
  figure_port: |
    my $listen = readlink('listen');
    my ($host,$port, $wa) = split ':', $listen;
    die "too much listen" if $wa;
    ($port, $host) = (2000, undef) if !$port && $host =~ /^\d+$/;
    $port ||= 2000;
    $host ||= '127.0.0.1';

    $port += w minorport;
    
    H.listen_http = "http://$host:$port";   
    H.listen_ws = "ws://$host:$port/s";
    
  websocket: | # Mojo throws connection over here
    0->TafuB(Elvis => {tx => $M->tx, M => $M});
  websockout: | # we make websockets out # BROKE
    Say "Ws out $conin";
    use Mojo::UserAgent;
    my $ua = Mojo::UserAgent->new;
    $ua->websocket($conin => sub {
      my ($ua, $tx) = @_;
      die "HELLO!";
      die "WebSocket handshake failed! $conin" and return unless $tx->is_websocket;
      Say "Connecto!";
      0->TafuB(Elvis => {tx => $tx, M => $tx, %$ar});
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
    
  S:
    push_conin: |
      G:Ϡ w pull_conin if H.singul;
    please_push_conin: |
      G:Ϡ w push_conin if !H.singul;
    wsy: |
      my $C = G.conz ||= {};
      my ($w, $s) = split ' ', $m;
      # check the tip for dup
      my $EE = G.conz->{$w};
      if ($EE && !EE.disco) {
          w elvash[$E, $EE];
      }
      G.conz->{$w} = $E;
      (E.c->{w}, E.c.s) = ($w, $s);
      E.singul = 1 if $w eq $s; 
      
      w z/conz;
      w elvjs;
    
    conz: |
        while (my ($id, $conin) = each %$conz) {
            next unless $conin eq H.listen_ws; # ours
            next if H.G.A.W->{$id}; # current # lookup (into the unified)
            $E->send(" delete conz['$id']; \$('#$id').remove();");
        }
  z:
    getgeometry: |
      $H->send(" w".".reply({geometry: {x: screen.availWidth, y: screen.availHeight}});");
    empty_body: |
      $H->send("\$('body').empty();");
    clon: |
      $H->send(" clon();");
    keon: |
      $H->send(" keon();");
    hitground: |
      $H->JS("\$('#sky').stop().slideUp();");
    conz: |
      $E->send(" s\.reply({conz:conz});");
    wzy: |
      $E->send(" s\.r('wsy '+ w\.conin +' '+ s\.conin );");
    coninto: |
      $H->send(" a\.con({conin: '$conin'});");
  elvash: |
    # close older one? closes newer, $E
    ($E, $EE) = ($EE, $E);
    sayre "Already on ".$EE->pi."  disco necktie ing => ".$E->pi;
    w $E disconecktie[$EE];
  elvjs: | # elvis swam through wsy, is js client
    if (E.singul) {
        H.who = $E;
        H.singul = 1;
        w singul;
    }
    else {
        H.singul = 0;
        w elvus;
    }
  elvibe: |
    Say "En nnnn Elvis ?? J | ".$E->pi;
    if (E.B.style) {
        Say "Elvis got it ".$E->pi;
        return;
    }
    w elvibium;
    w z/wzy; # conz, swim
    
  send_Elvis: |
    my $Elvis = ar.Elvis || ar.E || H.who || die "no infiduvial? $m";
    $m =~ /\n/ && say "Message contains \\n:\n$m\n\n";
    $m =~ s/\n//g;
    my $J = 0->Bu(J => {m => ar.m, cb => ar.cb});
    w $J print_out(pi => $Elvis->pi);
    w $Elvis send[$J];

 #heisto thing
 
  aj: | #  Ϡ Ϡ ϠϠ Ϡ ϠϠϠϠϠ ϠϠϠϠ  Ϡ  Ϡ Ϡ Ϡ Ϡ
    if (j._) {
        saygr j.G->pi." unified field! see for ".@{j.s};
        H.G.A.W->{j._.at.id} = j.G.W;
    }
    
    0->accum($G, Js => $j);
    
    my @Es = w Es;
    for my $E (@Es) {
        w sEnj[$E, $j];
    }
    sayg "j to the ".@Es;
  sEnj: |
    my @lot = reverse @{j.s};
    push @lot, reverse @{j.c};
    saygr scalar(@lot)." ->->->-> ".$E->pi;
    
    for my $l (@lot) {
        ref $l && die "reff $l";
        $l = " $l" if H.h;
        $E->send(" ".$l);
    }
    
    if (j._) {
        saygr "j.G.name unified field hits tiles!";
        0->sing(retile => sub { w retile[$E]; }, begin => 0.8);
    }
    # after U - direct to tape instead of catching JS in H
    
  Es: |
    uniq @{G.Es};
  elvis_enters: |
    saygr "jump on the j train ".$E->pi;
    0->accum($G, 'Es', $E);
    
    if (H.singul) {
        $H->pub("S", "please_push_conin");
    }
    
    my @GGs = ar.GG || @{G.GGs};
    for my $g (@GGs) {
        $g w elvibe;
    }
    
    for my $j (@{G.Js}) {
        w sEnj[$E, $j];
    }
  elvis_leaves: |
    0->deaccum($G => Es => $E);

