hooks:

  fresh_init: |
    H.who = [];
  recoded_init: |
    w retile;
  non: |
    die;
  node: #c
      O:
       - D: |
           H.r->ping() || die "no redids?";
           $G->su("Elvis", sub {
             my $a = shift;
             H.G w pubbedElvis[$a];
           });
      
           
      Z:
       - GAK: 0
  minorport: |
      my $p = ord(H.name);
      $p += 8000;
      say "Sport: $p";
      $p;
  honk: |
      $H->send('.'. (("  ")x int(2 + rand 3))."!!!");
       
  pull_conin: | # head receives the headless
    saygr "H.style/H.name        pulls conin     $m";
    my ($style, $name, $id, $conin) = split ' ', $m;
    die "mal cone push: '$m'" if !$conin;
    H.G w z/coninto[$conin];
    
  push_conin: | # the headless seeks heads
    saygr "H.style/H.name        pushes conin";
    $H->pub("S", "push_conin H.style H.name H.id H.listen_ws");   

      

  Elvis: #
      # here we want to graph things out real careful
      # because it is how things get around
      # the one to the many
      # apps can be multicasting too
      # none of these workings should be trapped at this level
      # send it out there and get the hair on it
    flows_D: |
      Sw tx_uglies;
      S.mouth = [];
      
      B.elvii = ++H.elvii;
      B.sign ||= "eeeeeeeeeeeeeeeeeeeeee";
      
    swoosh: |
      saygr $sign;
      
    humms_D: |
      w elvibe(E=>$S);
    
    print: |
      "$elvii $elvii =B.style=B.name=B.id B.conin $address";
    
    send: |
      my $cb = ar.cb;
      $tx->send($m, $cb);
      
    speaks: |      
      my $E = $S;#1
      H.elvis = $E;
      w Teeth[$m, $E];#...
      Sw swoosh; #9
      
      
    mouthfull: |
      for my $mJ (@{S.mouth}) {
            return 1 if mJ.dig eq J.dig &&
                (1 / (J.hitime - mJ.hitime)) > S.max_tooth_Hz
      }
      push @{S.mouth}, $J;
      shift @{S.mouth} if @{S.mouth} > 3;
      return 0;
    
    populi: |
      my @all = 0->rei({K=>"Elvis"});
      if (@all > 1) {
          sayre " Elvis is taking over!";
          _.B.tx->finish for @all;
          sayre " restarting...";
          w reexec;
      }
      
    leaves: |
      sayre "Elvis leaves: ".$S->pi."  $address - $code, $reason";
      Sw disco;
    disconecktie: |
      $tx->finish;
      Sw disco;
    disco: |
      S.disco = 1;
      w elvis_leaves(E=>$S);
    
    tx_uglies: |
      Mojo::IOLoop->stream($tx->connection)->timeout(300000);
      $M->on(message => sub {
          my ($M, $m) = @_;
          eval { Sw speaks[$m]; };
          $H->error("$@") if $@;
          $@ = "";
      });
      $M->on(finish => sub {
          my ($M, $code, $reason) = @_;
          Sw leaves[$code, $reason];
      });
      B.address = $tx->remote_address;
  figure_port: |
    my $listen = readlink('listen');
    my ($host,$port, $wa) = split ':', $listen;
    die "too much listen" if $wa;
    ($port, $host) = (2000, undef) if !$port && $host =~ /^\d+$/;
    $port ||= 2000;
    $host ||= '127.0.0.1';

    $port += w minorport;
    
    H.listen_http = "http://$host:$port";   
    H.listen_ws = "ws://$host:$port/s";
    
  websocket: | # Mojo throws connection over here
    0->TafuB(Elvis => {tx => $M->tx, M => $M});
  websockout: | # we make websockets out # BROKE
    Say "Ws out $conin";
    use Mojo::UserAgent;
    my $ua = Mojo::UserAgent->new;
    $ua->websocket($conin => sub {
      my ($ua, $tx) = @_;
      die "HELLO!";
      die "WebSocket handshake failed! $conin" and return unless $tx->is_websocket;
      Say "Connecto!";
      ua.Elvis = 0->TafuB(Elvis => {tx => $tx, M => $tx, %$ar});
    });
    $ua;
  z:
    getgeometry: |
      $H->send(" w".".reply({geometry: {x: screen.availWidth, y: screen.availHeight}});");
    empty_body: |
      $H->send("\$('body').empty();");
    clon: |
      $H->send(" clon();");
    keon: |
      $H->send(" keon();");
    hitground: |
      $H->JS("\$('#sky').stop().slideUp();");
    wzy: |
      $E->send(" s\.r('wsy '+ w\.conin +' '+ s\.conin );");
    coninto: |
      $H->send(" a\.con({conin: '$conin'});");
    
  elvibe: |
    sayyl "elvibe ?? jjj | ".$E->pi;
    
    my $js = " return elvis "; # random number
    my $cb = sub{ w elvibium(e => shift, E=>$E); };
    w jaw[$js,$cb,$E];
    
  elvibium: |
    E.e = $e; 
    0->accum($H,'who',$E);
    for my $m (@{H.Jels}) {
        w $E send[$m];
    }
    w z/clon;
    w z/keon;

        
  send_Elvis: |
    my $Elvis = ar.Elvis || ar.E || H.who;
    my $cb = ar.cb;
    if (!$Elvis || ref $Elvis eq "ARRAY" && !@$Elvis) {
        saybl "no infiduvia ----- will spring on .... ".slim($m);
        push @{H.Jels||=[]}, $m;
        return;
    }
    $m =~ /\n/ && say "Message contains \\n:\n$m\n\n";
    $m =~ s/\n//g;
    saybl " < ".slim(30,30,$m);
    for my $Elvis (ref $Elvis eq "ARRAY" ? @$Elvis : $Elvis) {
        w $Elvis send[$m, $cb];
    }
  elvis_leaves: |
    0->deaccum($H,'who',$E);

