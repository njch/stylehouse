hooks:

  fresh_init: |
    H.who = [];
  recoded_init: |
    w retile;
  node: #c
      O:
       - D: |
           H.r->ping() || die "no redids?";
           $G->su("Elvis", sub {
             my $a = shift;
             H.G w pubbedElvis[$a];
           });
      
  minorport: |
      my $p = ord(H.name);
      $p += 8000;
      say "Sport: $p";
      $p;
  Elvis: #
      # here we want to graph things out real careful
      # because it is how things get around
      # the one to the many
      # apps can be multicasting too
      # none of these workings should be trapped at this level
      # send it out there and get the hair on it
    flows_D: |
      Sw tx_uglies;
      S.mouth = [];
      
      B.elvii = ++H.elvii;
      B.sign ||= "eeeeeeeeeeeeeeeeeeeeee";
      
    swoosh: |
      saygr $sign;
      
    humms_D: |
      w elvibe(E=>$S);
    
    print: |
      "$elvii $elvii =B.style=B.name=B.id B.conin $address";
    
    send: |
      my $cb = ar.cb;
      $tx->send($m, $cb);
      
    speaks: |      
      my $E = $S;#1
      H.elvis = $E;
      w Teeth[$m, $E];#...
      Sw swoosh; #9
      
      
    mouthfull: |
      for my $mJ (@{S.mouth}) {
            return 1 if mJ.dig eq J.dig &&
                (1 / (J.hitime - mJ.hitime)) > S.max_tooth_Hz
      }
      push @{S.mouth}, $J;
      shift @{S.mouth} if @{S.mouth} > 3;
      return 0;
    
    populi: |
      my @all = w G.R fi(f=>{K=>"Elvis"});
      if (@all > 1) {
          sayre " Elvis is taking over!";
          _.B.tx->finish for @all;
          sayre " restarting...";
          w reexec;
      }
      
    leaves: |
      sayre "Elvis leaves: ".$S->pi."  $address - $code, $reason";
      Sw disco;
    disconecktie: |
      $tx->finish;
      sayyl "Dsicog ".$S->pi;
      Sw disco;
    disco: |
      S.disco = 1;
      w elvis_leaves(E=>$S);
    
    tx_uglies: |
      Mojo::IOLoop->stream($tx->connection)->timeout(300000);
      $M->on(message => sub {
          my ($M, $m) = @_;
          eval { Sw speaks[$m]; };
          $H->error("$@") if $@;
          $@ = "";
      });
      $M->on(finish => sub {
          my ($M, $code, $reason) = @_;
          Sw leaves[$code, $reason];
      });
      B.address = $tx->remote_address;
  figure_port: |
    my $listen = readlink('listen');
    my ($host,$port, $wa) = split ':', $listen;
    die "too much listen" if $wa;
    ($port, $host) = (2000, undef) if !$port && $host =~ /^\d+$/;
    $port ||= 2000;
    $host ||= '127.0.0.1';

    $port += w minorport;
    
    H.listen_http = "http://$host:$port";   
    H.listen_ws = "ws://$host:$port/s";
    
  websocket: | # Mojo throws connection over here
    my $u = { K=>'Elvis', B=>{tx => $M->tx, M => $M}};
    w G.R fuu[$u];
  z:
    getgeometry: |
      $H->send(" w".".reply({geometry: {x: screen.availWidth, y: screen.availHeight}});");
    empty_body: |
      $H->send("\$('body').empty();");
    clon: |
      $H->send(" clon();");
    keon: |
      $H->send(" keon();");
    hitground: |
      $H->JS("\$('#sky').stop().slideUp();");
    wzy: |
      $E->send(" s\.r('wsy '+ w\.conin +' '+ s\.conin );");
    coninto: |
      $H->send(" a\.con({conin: '$conin'});");
    
  elvibe: |
    sayyl "elvibe ?? jjj | ".$E->pi;
    
    my $js = " return elvis "; # random number
    my $cb = sub{ w elvibium(e => shift, E=>$E); };
    w jaw[$js,$cb,$E];
    
  elvibium: |
    E.e = $e; 
    0->accum($H,'who',$E);
    for my $m (@{H.Jels}) {
        w $E send[$m];
    }
    w z/clon;
    w z/keon;

        
  send_Elvis: |
    my $Elvis = ar.Elvis || ar.E || H.who;
    my $cb = ar.cb;
    if (!$Elvis || ref $Elvis eq "ARRAY" && !@$Elvis) {
        saybl "no infiduvia ----- will spring on .... ".slim($m);
        push @{H.Jels||=[]}, $m;
        return;
    }
    $m =~ /\n/ && say "Message contains \\n:\n$m\n\n";
    $m =~ s/\n//g;
    saybl " < ".slim(60,90,$m);
    
    my @e = map { [$_, undef] } ref $Elvis eq "ARRAY" ? @$Elvis : $Elvis;
    $e[-1]->[1] = $cb if $cb;
    
    for my $e (@e) {
        my ($Elvis,$cb) = @$e;
        w $Elvis send[$m, $cb];
    }
  elvis_leaves: |
    0->deaccum($H,'who',$E);
    sayre "Finash";

