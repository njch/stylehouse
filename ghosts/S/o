
name: o
C:
  - K: Hi
hooks:
  fresh_init: | # sub hostinfos before w in does our hostinfo
    $G->su("Hi", sub { my $m = shift; w Hi[$m]; });
    $G->su("Hostinfo", sub { my $m = shift; w Hostinfo[$m]; });
    $G->recur(10, sub {
        my $fi = `find ghosts -type f`;
        $fi =~ s/\n/ /g;
        saygr "lies: ".((`wc -l $fi`)[-1]  =~ /(\d+) total/)[0];
    });
    
    H.G w hostinfo; 
  in: |
    $G->timer(9, sub{w Hiwtidy;});
  Hostinfo: |
        my ($hol, $inf) = split ' ', $m, 2;
        sayyl " - $m";
        $hol =~ s/\x{0}//sgm;
        return if !$hol;
        die if !$hol;
        sayre "no $hol  ... $m" if !$hol;
        $G->pub("S/$hol", "hostinfo/ack $m", 'ig');
        saygr "from $hol -> $inf";
        G.hostinfo->{$hol} = {
            info => $inf,
            when => $H->hitime,
        };
  Hi: |
      sayyl "--------\n---------\n------\n   Hi  to $m";
      my ($hol, $m) = split ' ', $m, 2;
      $hol =~ s/\x{0}//sgm;
      (my $sn = $hol) =~ s/\/\w+$//;
      
      if (-d "life/V/$sn") { # would be good to control
          # a more than yay old TODO like J
          my @Vol = `find life/V/$sn -type f`; # doesn't go through symlinks
          for my $iss (@Vol) {
              chomp $iss;
              sayre "rm ing $iss";
              if ($iss =~ /\.s$/) {
                  my $s = read_file($iss);
                  if ($s =~ /^\x{0}+$/) {
                      warn "NULLY $iss";
                      $s = '';
                  }
                  my @s = split "\n", $s;
                  my $js;
                  say "in $iss: ".wdump \@s;
                  my $wt = '';
                  for my $s (@s) {
                      my $meta = djson($s);
                      my $t = "meta.y/meta.id";
                      $js .= w jsrm(id=>meta.id); # 
                      sayre "rm ingiog $t";
                      `rm life/$t.*`;
                      $wt .= " $t";
                  }
                  saybl "###### $js       $wt";
                  $H->send($js) if $js;
              }
              `rm $iss`;
          }
      }
      
      my @olds = uniq map { /^H\/(.+)\/.+?$/;$_ } `find life/H/$sn -type f`;
      for my $oth (@olds) {
          chomp $oth;
          say "OLD: $oth";
          (my $olo = $oth) =~ s/^.+H\///;
          my ($Hid) = reverse split '/', $oth;
          sayre "o $olo   4vs $hol";
          if ($olo eq $hol) {
              sayyl " haf self";
                next;
          }
          
          `rm life/S/$olo*`;
          `rm life/H/$olo`;
      }
      
      say "" for 1..3;
      waylay 1 Hiwtidy;
  jsrm: |
    " \$('#$id').css('position','absolute').fadeOut(1000, function() { \$(this).remove(); });";
  Hiwtidy: |
   # could take more clues
    my $js =
      " var e = []; "
     ."\$('#ux > ww').each(function(){"
     ." e\.push(\$(this).attr('id'));"
     ."});"
     ."return e\.join(' ');";
    
    my $cb = sub { my $m = shift; w Hiwtidy_ja[$m]; };
    H.G w jaw[$js, $cb];
  Hiwtidy_ja: |
    my @W = split ' ', $m;
    saybl "There: @W";
    @W = grep { !-f "life/W/$_\.i" } @W;
    say "Wild: @W";
    my $js;
    for (@W) {
        # TODFO javascript guns
        #die;
        $js .= w jsrm(id=>$_);
    }
    saybl $js;
    $H->send($js) if $js;
    say "Done Hiwtidy";
    
  reextet: |
    my @olds = uniq map { /^H\/(.+)\/.+?$/ } `find life/H -type f`;
    @olds = grep {$_ ne "H.style/H.name"} @olds;
    say wdump[@olds];
    #$G->pub('S/hut/O', "reextet ".join",",@olds);
    # pipes gone, slurp ps and kill hup
    my @perls = map { /^\S+\s+(\d+)/||die'pspar'; $1 } 
        grep {/S\.pm/} `ps faux | grep perl`;
    say wdump[@perls];
    for my $pid (@perls) {
        next if $pid eq $$;
        kill 'HUP', $pid;
    }
    # one second wait in ^ for v to hap without replacing files
    `rm $_` for map{chomp;$_}`find life/ -type f`;
    H.G w reexec;
    

