name: Styluxyio
include: T/braid

B:
  - K: V
    B:
      1/5: |
        w RW(top => G.T.W);# T encapsu is whole ux W
      2/5: |
        # interested in grep { _.i.K eq "ux" } @{ $G->W->CS }
                                    # l( @ Lu.o   # fu( via v
        ar.uxs = [ map {
            0->visTp_TafuBl({L=>$_}, [ux => {Lu=>$_}])
        } @{$Ls} ];
      3/5: |
        sayre "UXS: ".@$uxs;
        for my $ux (@$uxs) {
            my $ix = w ux_above_via_Lu[$ux]; # join uxLis together like the origin
            $ix ||= w RM(W => ux.B.Lu.G.T.W); # or the ux for its W
            0->visTp_l_u({i=>$ix}, $ux);
            w sane/V3[$ux, $ix, $uxs];
        }
      4/5: |
        w DooB(K => 'U'); # %
      5/5: |
        my $html = T.i.html;
        G.O.V.ux->takeover($html);
        w send_contents_awaiting;
        Say $html;
        
  - K: U
    Y:
      6/9: |
        for my $i (@{T.L.o}) {
            $i==T.i && next Say "Infinasm";
            w anTop[$i];
        }
    B:
      1/4: |
        my $u = T.i;
        w utricks/spawn[$u];
        w sane/U1[$u];
      2/4: |
        my $u = T.i;
        
        u._at = u.at;
        my $at = u.at = {}; # heres some state
        
        at.id = w $u S/id_D[$at];
        at.id ||= u.Li.uuid;
        
        at.styles = U->jgd(u.styles); # coalescing/merging
        at.tag ||= U->firstdef(u.B.tag, u.S.tag); # overriding
        
        unless (u.O eq 'ux') {
            my $n = u.B.n;
            at.tag ||= "y$n";
            at.conty = w $u S/content_D;
            
            at.styles = U->jgd(at.styles, "y$n", u.B.styles);
        }
        at.tag ||= u.K;
        die "no tag" .sw($u) if !at.tag;
      
      3/4: |
        my $u = T.i;
        my $at = u.at;
        
        my @content = sort { a.conor <=> b.conor } @{u.Li.o || []};
        
        at.ooze = [@content];
        
        my $conty = defined at.conty ? at.conty : "";
        my $content = join "\n", U->contor(@content);
        
        if (length($conty.$content) > 20000000) {
            $content = "";
            @content = ();
            # via travel add: #$uxid > #$id # in case of mid-y splits...
            my $id = u.at.id;
            my $sel = "#$id";
            push @{G.contents_awaiting||=[]}, {
                sel => $sel,
                u => $u,
            };
        }
        
        $content = "\n".ind("  ", $content)."\n" if @content;
        
        my $attr = { %{u.at} };
        
        attr.style = $G->styles(delete attr.styles); # or so
        
        my $tag = delete attr.tag;
        
        my $conty = delete attr.conty if exists attr.conty;
        $conty = "" if!defined $conty;
        delete attr.ooze;
        attr.title = "";
        
        die "Already got html! u.html" if u.html;

        $attr = join " ", map { $_.'="'.$attr->{$_}.'"' } sort keys %$attr;
        u.html = "<$tag $attr>$conty$content</$tag>";

        
C:            # W M ux
  - K: W # us
    O: ux
    S:
      tag: wormhole
      id_D: |
        ( W.id =~ /-(\w+)$/ )[0]
        
  - K: M
    O: ux
    S:
      tag: MMMM
     
  - K: ux
    O: ux
    S:
      tag: ux
    styles: te
    conor: 1
    print: |
       "(".pint(S.B.Lu.i)." \t".gpty(S.B.Lu.t).")"
    C_n_spawn: [i, t, o]
       
  - K: i     #c uyuyuuyuyyyuyuyuuuuyuuuuyyyuyuyyyuyuuuyuyuyyyyuyuyu
    uy_in_dos:
      Lu_grab_n: i
      n_uys_to_w_n: w
      
    C_n_spawn: [w]
    conor: -0.5
    
  - K: t
    uy_in_dos:
      Lu_grab_n: t
      
    S:
      content_D: |
        die "t content fullity" if S.B.raw || S.raw;
        my $con = gpty($t);
        $con = ($con=~/^(.{30})/s)[0]."..." if length($con) > 50;
        $con;
      
  - K: o
    uy_in_dos:
      Lu_grab_n: o
      n_uys_to_w_n: w
      n_array: 1
      
    C_n_spawn: [w]
    conor: 0.5
    
  - K: w
    S:
      content_D: |
        pint($w);
      
  - K: e
    styles: topleft white little
    S:
      content_D: |
        $e
   
   
hooks:
  event: |
    my $u = L.i;
    my $ux = uxL.i;
    my $E = {%$ar};
    E.L = ux.B.Lu;
    E.uyL = $L if $L ne $uxL;
    Say E.L.G.name;
    E.L.G->w(event => $E);
  
  send_contents_awaiting: |
        my $awa = G.contents_awaiting ||= [];
        for my $ait (reverse @$awa) {
            my $u = ait.u;
            my $sel = ait.sel;
            my @htmls = U->contor(@{u.at.contents});
            #die wdump([$u,\@htmls]);
            for my $html (@htmls) {
                #next if G.fuckery++ > 7;
                $H->JS("\$('$sel').append('$html');");
            }
        }
        G.contents_awaiting = [];
  RW: | # for making the tip, which is a hash anyway
    my $W = ar.top||ar.W;
    ref $W eq "Wormhole" || die sw([$W,"Weird wormhole RW"]);
    my $Bu = [W => {W => $W}];
    my $u = 0->TafuBl(@$Bu);
    0->visTp({ i => $u }) if ar.top && T.i ne $u;
    G.top = $u if ar.top;
    return $u
  RM: | # a tip on the other side, so below our tip but above in space
    ref $W eq "Wormhole" || die sw([$W,"Weird wormhole RM"]);
    0->TafuBl(
        M => {W => $W},
    );
  ux_above_via_Lu: |
    my $Lu = ux.B.Lu || die "no Lu on ux";
    my $pLu = Lu.i.Lo if exists Lu.i.Lo; # up and over
    my ($pux) = findO(ux => pLu.o) if $pLu;
    $pux;

  ux: |
    my $Ls = ar.Ls;
    $Ls ||= ar.W->CS if ar.W;
    $Ls ||= [];
    Say @$Ls." lines -> ux from $Ls->[0]->{name}";
    w DooB(K => "V", Ls => $Ls);
  styles:
    te: |
      q'border-bottom:1px solid black',
      qw' padding:0.4em margin-left:2em
            width:100% float:left position:relative'
    yw: |
        q' margin-left:0.5em '
    yo: |
        q' border:2px solid #fca;'
    20pt: |
      'font-size:20pt;'
    yi: |
        q' border:2px solid #ba8; margin-left:0.5em '
        
    yt: |
        q' padding:0.5em; background:rgba(200,80,130,0.5);'
    
    shlink: |
        q" -webkit-transform:rotate(45deg) scale(1,0.5); ";
        
    rel: |
      qw'position:relative'
    abs: |
      qw'position:absolute'
    topleft: |
      qw'position:absolute top:-5px left:-5px'
    white: |
      qw'color:white'
    little: |
      qw'font-size:60%'
    fulw: |
      qw {height:100% float:left position:absolute},
  any_init: |
    G.U.jgd = sub { join " ", grep { defined } @_ };
    G.U.firstdef = sub { (grep { defined } @_)[0] };
    G.U.contor = sub {
        grep { defined }
        map { _.html || _.content } @_
    };
  recoded_init: |
    H.G->w('re/exec');
  sane:
    V3: |
      die "ix not Li " unless ix.Li;
      die "ux not in above ux o: ".sw({uxs=>$uxs,ix=>$ix})
          unless ix.O ne "ux" || grep { $_ eq $ux } @{ix.Li.o};
    U1: |
        my $Lu = u.B.Lu || die "no Lu".sw({" no Lu"=>$u}) if u.K eq "ux";
        die "ux has no ways out, expected SOMETHING!?".sw(u.Li)
            if u.K eq "ux" && !@{u.Li.o};
  utricks:
    spawn: | #c
        if (my $uyKs = u.C_n_spawn) {
            for my $uy (map { 0->sway({K=>$_}) } @$uyKs) {
                uy.B ||= {};
                
                w utricks/ngrab[$uy, $u];
                
                my @uys = w utricks/multi[$uy, $u];
                
                for my $uu (@uys) {
                    my $uy = 0->fu($uu);
                    if ($uy) {
                        say "u fu uu.K ".ki(uu.B);
                        next;
                    }
                    say "u not found! uu.K ".ki(uu.B);
                    $uy = 0->T({i => $uu});
                    0->l($uy);
                    # and $uy is it
                }
            }
        }
    multi: | #c
      my @uys = $uy;
                if (u.uy_in_dos) {
                    if (u.uy_in_dos.n_array) {
                        my $n = uy.B.n;
                        my $val = uy.B->{$n};
                        ref $val eq "ARRAY" || die "was promised $n would be array, is $val ".wdump($uy);
                        
                        @uys = ();
                        my $i = 0;
                        for my $an (@$val) {
                            next if an.K eq "ux"; # that hangs out in the origin lines o
                            my $anuy = $uy->spawn;
                            anuy.B->{$n} = $an;
                            anuy.K = uy.K."[".$i++;
                            push @uys, $anuy;
                        }
                    }
                }
      @uys
    ngrab: | #c
                if (u.uy_in_dos) {
                    if (my $ton = u.uy_in_dos->{"n_uys_to_".uy.K."_n"}) {
                        uy.B->{$ton} = u.B->{u.B.n};
                        uy.B.n = $ton;
                    }
                }
                if (uy.uy_in_dos) {
                    if (my $n = uy.uy_in_dos.Lu_grab_n) {
                        uy.B->{$n} = u.B.Lu->{$n};
                        uy.B.n = $n;
                    }
                }

