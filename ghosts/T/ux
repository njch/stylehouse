name: Styluxyio
include: T/braid
dials:
  max_depth: 7
  form: 42
chains:

hooks:
  ways:
    ux:
      K: ux
      O: ux
      styles: te
      tag: ux
      print: |
        "(".pint(S.Lu.i)." \t".gpty(S.Lu.t).")"
    uy:
      K: uy
      O: uy
      print: |
        "(".join(",  ", map { "$_ = ".pty(S.B->{$_}) } keys %{S.B}).")"
          
  event: |
    my $u = L.i;
    my $ux = uxL.i;
    my $E = {%$ar};
    E.L = ux.Lu;
    E.uyL = $L if $L ne $uxL;

    ux.Lu.G->w(event => $E);
  uyBs: # TODO ways build up from places like this
   - K: i
     uys: w
   - K: t
     D_html: |
       $t
   - K: o
     uys: w
   - K: w
     nah: 1
     D_html: |
       U->ups('shlink') if
           (grep { $_ eq $w } G.L.o) && findO(ux => w.Li.o);
       # ^ w on a line. octave lower display & glue?
       pint($w);
   - K: e
     styles: topleft white little
     nah: 1
     D_html: |
       gpty($e)
  
   
  any_init: |
    G.U.stoops = [ sub {#c
        my $u = G.L.i;
        my $uL = G.L;
         # B into style
        # spawn guts
        # ways can compress/Loose (and lookup) via K
        
        my $Lu = u.Lu || die "no Lu" if u.O eq "ux";
        my $old = { map { _.B.K => $_ } findO(uy => uL.o) };
        G.U.h.ul.creating_that_u = sub {
            my $uy = shift;
            $old->{uy.B.K} &&
            $G->U(deaccum => $uL, "o", $old->{uy.B.K});
        };
        
        my $uyBs = $G->findway('uyBs');
        my $uyBsK = sub {
            my $uyK = shift;
            (grep { _.K eq $uyK } @$uyBs)[0]
        };
        
        my @fluyB;
        my $pafly = sub {
            my $from = shift;
            push @fluyB, { %$from, @_ }
        };
        for my $uyB (@$uyBs) { # ux spawns uys
            next if u.O eq "uy";
            next if uyB.nah;
            my $n = uyB.n ||= uyB.K;
            my $y = $Lu->{$n};
            uyB.styles ||= 'rel';
            if ($n eq "o" && ref $y eq "ARRAY") {
                my $i = 0;
                for my $o (@$y) {
                    next if o.O eq "ux";
                    $pafly->(
                        $uyB,
                        $n => $o,
                        K => uyB.K."[".$i++,
                    );
                }
            }
            else {
                $pafly->(
                    $uyB,
                    $n => $y,
                );
            }
        }
        if (my $uys = delete u.B.uys) { 
            for my $uyK (split ' ', $uys) {
                my $uyB = $uyBsK->($uyK);
                my $n = uyB.n ||= uyB.K;
                $pafly->(
                    $uyB,
                    $n => u.B->{ u.B.n },
                )
            }
        }
        if (u.O eq "uy") {
            u.B.K eq "e" || $pafly->($uyBsK->("e"), n => 'e', e => u.B.n);
        }
        for my $uyB (@fluyB) {
            $G->U(uys => $uyB);
        }
        
        delete G.U.h.ul.creating_that_u;
    } ];
    G.U.ups = sub {#c
        my $u = shift;
        u.B.styles = U->jgd(u.B.styles, @_);
    };
    G.U.jgd = sub { join " ", grep { defined } @_ };
    G.U.toos = [ sub {
        my $u = G.L.i;
        my $uL = G.L;
        die "empty Lu on ".wdump($u)  if u.Lu && !%{u.Lu};
        die "uy Lu".wdump(2, $u)      if u.K eq 'uy' && u.Lu;
        die "uy Lu".wdump(2, $u)      if u.K eq 'ux' && !u.Lu;
        die "ux has no ways out"      if u.K eq "ux" && !@{uL.o};
        
        say "utoo: ".pint($u);
        my $at;
        my @html;
        
        at.id = uL.uuid;
        at.tag = U->jgd(u.B.tag, u.tag);
        at.styles = U->jgd(u.styles);
        
        if (u.K eq "uy") {
            my $n = u.B.n;
            at.tag = "y$n";
            at.content = $G->w('B/D_html', {}, $u);
            at.styles = U->jgd(at.styles, "y$n", u.B.styles);
        }
        die "no tag" .wdump($u) if !at.tag;
        push @html, '<'.at.tag.' id="'.at.id.'" style="'.$G->styles(at.styles).'">';
        
        my $s = {};
        for my $uu (@{uL.o}) {
            G.U.accum->(($s->{uu.O}||=[]), $uu);
        }
        my $oh = join "\n", grep { defined } map { _.html } @{s.uy}, @{s.ux};
        if (at.content) {
            push @html, "\n" if $oh;
            push @html, at.content;
        }
        if ($oh) {
            push @html, "\n".ind('  ',$oh)."\n"
        }
        
        push @html, "</at.tag>";
        u.html = join "", @html;

    } ];
  ux: |
    Say @$Ls." lines -> ux from $Ls->[0]->{name}";
    
    my @uxs;
    for my $Lu (@{$Ls}) { #say "install ux outways to Lu";
        push @uxs, G.U.ul->(
            u => G.U.mku->(ux => {Lu=>$Lu}),
            p => $Lu,
        );
    }
    # ux could be all new
    # could be (new)ux.uL.i.Lo.ux(old): wedge in
    # 
    my @tux;
    for my $ux (@uxs) {   #say "join uL lines together like the origin (ux.Lu.i.K - ux.Lu.t)";
        G.L = ux.Li;
        my $Lu = ux.Lu || die;
        my $pLu = Lu.i.Lo if exists Lu.i.Lo; # up and over
        my ($pux) = findO(ux => pLu.o) if $pLu;
        unless ($pux) {
            push @tux, $ux;
        }
        else {
            #say "joining ".pint($ux).' to '.pint($pux);
            G.U.ul->(
                u => $ux,
                p => pux.Li,
            );
            #say "put ".pint($ux)." onto ".pint($pux)."\n\n";
            die unless grep { $_ eq $ux } @{pux.Li.o};
        }
    }
    
    
        for my $ux (@tux) {
            G.L = ux.Li || die "no ux Li";
            G.U.antop->();
        }
        
    my @eh;
    for my $ux (@tux) {
        push @eh, ux.html;
    }
    #die "hue" if @tux > 1;
    
    my $W = $G->W;
    my ($id) = W.id =~ /-(\w+)$/;
    
    my $html = join "\n", '<wormhole style="font-size:70%;position:relative;"id="'.$id.'">', @eh, '</wormhole>';
    
    say "ux antop ".$G->F_delta()."\n\n\n";
    G.view->takeover($html);
    
  styles:
    te: |
      q'border-bottom:1px solid black',
      qw' padding:0.4em margin-left:2em
            width:100% float:left position:relative'
    yw: |
        q' margin-left:0.5em '
    yo: |
        q' position:absolute; left:30em; border:2px solid #fca;'
        
    yi: |
        q' border:2px solid #ba8; margin-left:0.5em '
        
    yt: |
        q' padding:0.5em; background:rgba(200,80,130,0.5);'
    
    shlink: |
        q" transform:rotate(135deg) scale(2,.5); ";
        
    rel: |
      qw'position:relative'
    topleft: |
      qw'position:absolute top:-5px left:-5px'
    white: |
      qw'color:white'
    little: |
      qw'font-size:60%'
    fulw: |
      qw {height:100% float:left position:absolute},

