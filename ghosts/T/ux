name: Styluxyio
dials:
  max_depth: 7
  form: 42
chains:
 - K: xW #c
   dom_depth: 0
   arr_if: |
     ref $thing eq "Wormhole";
   B_: |
     $thing
   foreach_travel:
     each: grep { $_->{depth} == 0 } @{$thing->{script}}
   print: |
     ".$Li->{n}"
 
 - K: xL
   iK: xW|xL
   arr_if: |
     ref $thing eq "HASH"
     && ref $thing->{o} eq "ARRAY"
   print: |
     ".$Li->{n}"
   foreach_travel:
     each: grep { defined $_ } map { $_->{B}->{Li} } @{$thing->{o}};
hooks:
  ux: |
    Say @$Ls." lines -> ux from $Ls->[0]->{name}";
    my $wayfindO = sub {
        grep { _.O eq $_[0] } @{$_[1]}
    };
    my @uxs;
    for my $Lu (@{$Ls}) { # install ux outways to Lu
        my ($ux) = $wayfindO->(ux => Lu.o);
        if (!$ux) {
            $ux = $G->nw(K=>'Lu', O=>'ux', Lu=>$Lu);
            push @{Lu.o}, $ux;
        }
        push @uxs, $ux;
    }
     
    my @loose;
    my @hupped;
    my @eh;
    for my $ux (@uxs) {
        my $Lu = ux.Lu;
        # find parent ux via origin W (Lu)
        my $pLu = Lu.i.Lo;
        my ($pux) = $wayfindO->(ux => pLu.o) if $pLu;
        
        # if $pLu && !$pux # flare ends
        say "under: ".pint(pLu.i) if $pux;
        say "  - ".pint(Lu.i);
        
        if ($pux) {
            if (!grep { $ux eq $_ } @{pux.o}) {
                push @{pux.o}, $ux;
                say "  brand new ";
            }
            else {
                say "  reux";
            }
            push @hupped, $pux; # things to render, add @uxs
        }
        else {
            say "    loose";
            push @loose, $ux;
        }
    }
    my $hup = {};
    $hup->{"$_"} = $_ for @hupped;
    
    for my $lux (@loose) {
        # delete $hup->{"$lux"} for any ux we update,render
        
    }
    # remaining $hup rechild # extra roots of updated things
        
        
    $G->{M} = "inflate";
    w travel(i=>$_) for @loose;
    $G->{M} = "map";
    
    
    
  travel: |
    if ($G->{M} eq "inflate") {
        $G->T('aye', undef, $i);
    }
    elsif ($G->{M} eq "map") {
        w arr(ux=>$i);
    }
    
  arr: |
    my $ux = $ar->{ux} || G.i;
    ux.O eq "ux" || die wdump(2,$ux);
    if ($G->{M} eq "inflate") {
        G.t = ux.Lu;
        for my $hux (@{ux.h||[]}) {
        die "here";
            my $exists = grep { $hux eq $_ } @{G.o}; # h is the impulse, updateness
            if (!$exists) { 
                hux.travel = undef;
                push @{G.o}, $hux;
            }
        }
    }
    elsif ($G->{M} =~ /^map/) {
        ux.Li.o;
    }
    
  x_to_h: |
    my $x = L.i.B.x;
    my $h = L.i.B.h = {};
    my $attr = {};
    my @style = ();
    my @class = ();
    attr.id = x.id          if exists x.id;
    attr.title = x.title if exists x.title;
    
        for my $a (qw{height width left top}) {
            if (exists $x->{$a}) {
                my $v = $x->{$a};
                $v = ($v * 100).'%' if $v !~ /em$/;
                push @style, "$a:$v"; 
            }
        }
        if (exists x.height && x.height =~ /em$/ && x.width == 1) {
            push @style, "float:left";
        }
        if (exists x.left || exists x.top) {
            push @style, "position:absolute";
        }
        if (x.class) {
            push @class, @{x.class};
        }
        if (x.style) {
            for my $styley (@{x.style}) {
                my $styles = [ flatline($styley) ];
                push @style, @$styles;
            }
        }
         
        my $tag = x.tag || "uh";
        if (!defined L.i.B.Lo) {
            $tag = "wormhole";
            my $W = $G->W;
            attr.title = G.name;
            (attr.id) = W.id =~ /-(\w+)$/;
        }
        
        attr.style = join "; ", @style if @style;
        attr.class = join " ", @class if @class;
        
        h.attr = $attr;
        h.tag = $tag;
        h.children = L.o;
        h.content = sub {
            return x.content if x.content;
            return join "", grep {defined}
                map { _.B.h.ash->() }
                grep { _.B && _.B.h } @{h.children}
        };
        h.ash = sub {
            "<h.tag ".join(" ", map {"$_=\"h.attr->{$_}\""} sort keys %h.attr).">"
            ."\n".ind("  ", h.content->())."\n"."</h.tag>\n"
        };
    
    
    
    
    # etc
    
        
    
  T_end: |
    @$r = $L
        
  next_phase: |
      for my $L (@{G.Torail}) {
            w style_to_x[$L];
      }
      for my $L (@{G.Torail}) {
            w x_to_h[$L];
      }
      return L.i.B.h.ash->();
      
  style_to_x: |
    my $x = L.i.B.x = {};
    my $yL = L.t;
    my $got = {
    l => [ grep { !_.B.Li } @{yL.o} ],
    t => [ grep { _.B.Li } @{yL.o} ],
    i => [ yL.i ],
    };
    my $hg = sub {
        my ($what, $order) = @_;
        my @R;
        for my $yg (split '', $order) {
            for my $w (@{$got->{$yg}}) {
                if (w.B && w.B.s) {
                    if (exists w.B.s->{$what}) {
                        push @R, w.B.s->{$what}
                    }
                    if (exists w.B.s->{$what."_D"}) {
                        push @R, $G->w("B/s/".$what."_D", {}, $w)
                    }
                }
            }
        }
        @R
    };
    
    
    my @content = $hg->(content => 'li');
    @content > 1             && die "cont > 1";
    @content && @{got.t}     && die "cont & t";
    ($x->{content}) = @content if @content;
    
    $x->{class} = [ flatline($hg->(class => 'il')) ];
    $x->{style} = [ flatline($hg->(style => 'il')) ];
    ($x->{tag}) = grep {defined} flatline($hg->(tag => 'li')), "te";
    $x->{style} = [ flatline($hg->(style => 'il')) ];
    $x->{id} = L.uuid;
    $x->{title} = "yL.n yL.depth ".pint(yL.t.i) if ref yL.t eq 'HASH';
    
    my @div = $hg->(div => 'li');
    @div > 1                 && die "div > 1";
    if (@div) {
        my ($v) = @div;
        my $vi = {};
        ($vi->{width},$vi->{height}) = split "x", $v; $v =~/^x/&&die"?";
        while (my ($iv, $parts) = each %$vi) {
            if (!$parts) {
                next;
            }
            my $inc;
            if ($parts =~ /em$/) {
                $inc = $parts;
                $parts = 1;
            }
            $parts = 0+@{ L.o }    if $parts eq "...";
            $parts = 1    if $parts == 0;
            $inc ||= sprintf("%.3f", 1 / $parts);
            my $side = $iv eq "width" ? "left" : "top";
            my $i = 0;
            
            for my $w (@{ L.o }) {
                die "lower w.B.x not yet" unless w.B.x;
                my $ox = w.B.x;
                if ($parts == 1) {
                    $ox->{$iv} = $inc;
                }
                else {
                    $ox->{$side} = $i;
                    $i += $inc;
                    $ox->{$iv} = $inc;
                }
            }
        }
    }
    
    

