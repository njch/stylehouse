name: Styluxyio
include: T/braid T/ravel
chains:
   -  K: Wormhole
      O: ux
      
      
   -  K: ux
      O: ux
      styles: te
      conor: 1
      print: |
        "(".pint(S.Lu.i)." \t".gpty(S.Lu.t).")"
        
      T_remembers_last: 1
      chainlink: [i, t, o]
      lness:
        Lo: called Lu if diff_ghost


   - K: i
     in_dos:
       Lu_grab_n: i
       n_uys_to_w_n: w
       
     chainlink: [w]
     conor: -0.5
     
   - K: t
     uy_in_dos:
       Lu_grab_n: t
       
     content_D: |
       die "t content fullity" if S.B.raw || S.raw;
       my $con = gpty($t);
       $con = ($con=~/^(.{30})/s)[0]."..." if length($con) > 50;
       $con;
       
   - K: o
     uy_in_dos:
       Lu_grab_n: i
       n_uys_to_w_n: w
       
     chainlink: [w]
     conor: 0.5
     
   - K: w
     content_D: |
       pint($w);
       
   - K: e
     styles: topleft white little
     content_D: |
       $e
   
   
dials:
  max_depth: 7
  form: 42
chains:
hooks:
  event: |
    my $u = L.i;
    my $ux = uxL.i;
    my $E = {%$ar};
    E.L = ux.Lu;
    E.uyL = $L if $L ne $uxL;

    ux.Lu.G->w(event => $E);
  ux: |
    Say @$Ls." lines -> ux from $Ls->[0]->{name}";
    
    0->visTp({
        i => 0->TafuB(Wormhole => {W => G.W}),
    });
    my $what = $T;
    
    my @uxs;
    for my $Lu (@{$Ls}) { #say "install ux outways to Lu";
        push @uxs, 0->visTp_TafuBl({L=>$Lu}, [ux => {Lu=>$Lu}]);
    }
    
    my $_mirror = sub {
        my $ux = shift;
        my $Lu = ux.Lu || die "no Lu on ux";
        my $pLu = Lu.i.Lo if exists Lu.i.Lo; # up and over
        my ($pux) = findO(ux => pLu.o) if $pLu;
        $pux;
    };
    my $LuWs;
    my $_wormhole = sub {
        my $ux = shift;
        my $W = ux.Lu.G.W;
        $LuWs->{"$W"} ||= 0->TafuBl(Wormhole => {W => $W});
    };
    
    my @tux;
    for my $ux (@uxs) {   #say "join uL lines together like the origin (ux.Lu.i.K - ux.Lu.t)";
        
        my $ix = $_mirror->($ux) || $_wormhole->($ux);
        
        0->visTp_l_u({i=>$ix}, $ux);
        
        die "ux not in above ux o" unless
            ix.O ne "ux" || grep { $_ eq $ux } @{ix.Li.o};
    }
    
    # now go antopping from/to T.L (root Wormhole (ux itself))
    # doing that thing we do...
    
        for my $ux (@tux) {
            G.L = ux.Li || die "no ux Li";
            U->antop();
        }
        
    my @eh;
    for my $ux (@tux) {
        push @eh, ux.html;
    }
    #die "hue" if @tux > 1;
    
    my $W = $G->W;
    my ($id) = W.id =~ /-(\w+)$/;
    
    my $html = join "\n", '<wormhole style="font-size:70%;position:relative;"id="'.$id.'">', @eh, '</wormhole>';
     
    G.view->takeover($html);
    U->send_contents_awaiting();
    Say $html;
    Say "ux antop ".$G->F_delta()."\n\n\n";
    
  any_init: |
    
    G.U.jgd = sub { join " ", grep { defined } @_ };
    G.U.send_contents_awaiting = sub {
        my $awa = G.contents_awaiting ||= [];
        G.fuckery = 0;
        for my $ait (reverse @$awa) {
            my $u = ait.u;
            my $sel = ait.sel;
            my @htmls = U->contor(@{u.at.contents});
            #die wdump([$u,\@htmls]);
            for my $html (@htmls) {
                #next if G.fuckery++ > 7;
                $H->JS("\$('$sel').append('$html');");
            }
        }
        G.contents_awaiting = [];
    };
    G.U.contor = sub {
        grep { defined }
        map { _.html || _.content } @_
    };
  stoops:
    0: |
        my $u = T.i
        my $Lu = u.Lu || die "no Lu" if u.K eq "ux";
        # B into style
        # spawn guts
        # ways can compress/Loose (and look UP) via K
        
        my $uyBs = $G->findway('uyBs'); # THIS THING NEXT  T O D O   T O D O   T O D O   T O D O 
        my $uyBsK = sub {
            my $uyK = shift;
            my ($uyB) = grep { _.K eq $uyK } @$uyBs;
            $uyB || die "No such uyK $uyK";
            { %$uyB } 
        };
        my @fluyB;
        my $pafly = sub {
            my $from = shift;
            push @fluyB, { %$from, @_ }
        };
        if (my $uys = u.B.uys) { 
            for my $uyK (split ' ', $uys) {
                my $uyB = $uyBsK->($uyK);
                next if u.K eq "ux";
                
                if (my $to = u.B.yBs->{"n_uys_to_".uyB.K."_n"}) {
                    $uyB->{$to} = u.B->{u.B.n};
                    uyB.n = $to;
                }
                if (my $n = uyB.yBs.Lu_grab_n) {
                    my $y = $Lu->{$n};
                    $uyB->{$n} = $y;
                    uyB.n = $n;
                }
                my @uyBits = ($uyB);
                if (my $n = uyB.yBs.multi_n) {
                    if (my $y = $uyB->{$n}) {
                        if (ref $y eq "ARRAY") {
                            @uyBits = ();
                            my $i = 0;
                            for my $o (@$y) {
                                push @uyBits, {
                                    %$uyB,
                                    $n => $o,
                                    K => uyB.K."[".$i++,
                                };
                            }
                        }
                    }
                }
                for my $uyB (@uyBits) {
                    $pafly->($uyB);
                }
            }
        }
        for my $uyB (@fluyB) {
            if (1) {
                U->uys($uyB);
            }
            else {
                my $u = 0->TafuBl(uy => $uyB);
                #die "liney" if u.Lo ne G.L;
                die "miso" if !grep{$_ eq $u}@{G.L.o};
                die wdump($u);
            }
        }
  toos:
    0: |
        my $u = T.i
        
        my $Lui = Tlux.Lu.i;
        die "empty Lu on ".wdump($u)  if u.Lu && !%{u.Lu};
        die "uy Lu".wdump(2, $u)      if u.K eq 'uy' && u.Lu;
        die "uy Lu".wdump(2, $u)      if u.K eq 'ux' && !u.Lu;
        die "ux has no ways out"      if u.K eq "ux" && !@{u.Li.o};
        
        my $at;
        
        at.id = u.Li.uuid;
        at.styles = U->jgd(u.styles);
        my $y = u.K eq "uy";
        if ($y) {
            my $n = u.B.n;
            at.tag = "y$n";
            at.content = w $u B/content_D;
            
            at.styles = U->jgd(at.styles, "y$n", u.B.styles);
        }
        at.tag ||= U->jgd(u.B.tag, u.tag);
        die "no tag" .wdump($u) if !at.tag;
        
        if ($y && Lui.uxs) {
            my $path = "uxs/y/u.B.n/at_D";
            $G->w($path, { at => $at }, $Lui);
        }
        
        u.E_at = u.at;
        u.at = $at;
        my $tag = sub {
            my $content = shift || '';
            my $attr = { %{u.at} };
            attr.style = $G->styles(delete attr.styles); # or so
            attr.style .= "position:relative;"
            unless attr.style =~ /position[^\w]+absolute/;
            my $tag = delete attr.tag;
            my $conty = delete attr.content if exists attr.content;
            $conty = "" if!defined $conty;
            delete attr.contents;
            
            $attr = join " ", map {
                $_.'="'.$attr->{$_}.'"' } sort keys %$attr;
            "<$tag $attr>$conty$content</$tag>";
        };
        
        my @content = 
        sort { (a.conor || a.B.conor) <=> (b.conor || b.B.conor) }
        (findO(uy => uL.o), findO(ux => uL.o));
        
        at.contents = [@content];
                
        my $content_max = 2000;
        my $content =
            (defined u.content ? u.content : "")
            .join "\n", U->contor(@content);
        
        if (length($content) > $content_max) {
            $content = "";
            @content = ();
            # via travel add: #$uxid > #$id # in case of mid-y splits...
            my $id = u.at.id;
            my $uxid = G.last_ux.at.id if G.last_ux;
            my $sel = "#$id";
            $sel = "ux#$uxid > $sel" if $uxid && $uxid ne $id;
            push @{G.contents_awaiting||=[]}, {
                sel => $sel,
                u => $u,
            };
        }
            
        #die wdump(3,[u.at, $content]) if u.K eq "ux";
        $content = "\n".ind("  ", $content)."\n" if @content;
        
        u.html = $tag->($content);
 
  styles:
    te: |
      q'border-bottom:1px solid black',
      qw' padding:0.4em margin-left:2em
            width:100% float:left position:relative'
    yw: |
        q' margin-left:0.5em '
    yo: |
        q' border:2px solid #fca;'
    20pt: |
      'font-size:20pt;'
    yi: |
        q' border:2px solid #ba8; margin-left:0.5em '
        
    yt: |
        q' padding:0.5em; background:rgba(200,80,130,0.5);'
    
    shlink: |
        q" -webkit-transform:rotate(45deg) scale(1,0.5); ";
        
    rel: |
      qw'position:relative'
    abs: |
      qw'position:absolute'
    topleft: |
      qw'position:absolute top:-5px left:-5px'
    white: |
      qw'color:white'
    little: |
      qw'font-size:60%'
    fulw: |
      qw {height:100% float:left position:absolute},

