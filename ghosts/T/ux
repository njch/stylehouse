name: Styluxyio

C:            # W M ux
  - K: W # us
    O: ux
    spawn:
      - K: somewhere
    S:
      tag: wormhole
      id_D: |
        ( W.id =~ /-(\w+)$/ )[0]
        
  - K: M
    O: ux
    spawn:
      - K: h1
        content_D: |
          W.G.name
    S:
      tag: MMMM
     
  - K: ux
    O: ux
    spawn:
      - K: i
      - K: t
      - K: o
    S:
      tag: ux
    styles: te
    conor: 1
    print: |
       "(".pint(S.B.Lu.i)." \t".gpty(S.B.Lu.t).")"
       
  - K: i     #c uyuyuuyuyyyuyuyuuuuyuuuuyyyuyuyyyuyuuuyuyuyyyyuyuyu
    spawn:
      - K: w
        Bset:
          w: Lu.i
    conor: -0.5
    
  - K: t
    S:
      content_D: |
        die "t content fullity" if S.B.raw || S.raw;
        my $con = gpty(Lu.t);
        $con = ($con=~/^(.{30})/s)[0]."..." if length($con) > 50;
        $con;
      
  - K: o
    spawn:
      - K: w
        multiBy: w
        Bset:
          w: Lu.o
    conor: 0.5
    
  - K: w
    S:
      content_D: |
        pint($w);
      
  - K: e
    styles: topleft white little
    S:
      content_D: |
        $e
  
  - K: somewhere #c
    styles: te
    S:
      sendo_init_D: |
        return;
        $H->JS("\$('#somewhere').appendTo('#S.at.id');");
        my $css = 'pointer-events:none; -webkit-filter: brightness(1.2) saturate(3) drop-shadow(10px 0px 30px black); width:60em;';
        $H->JS("\$('#somewhere').attr('style', '$css');");
  
  - K: h1
    styles: blubor
  - K: h2
    
   
hooks:
  styles:
    blubor: |
      q'border:3px solid rgba(20,20,255,0.5);';
    tinyer: |
        q'-webkit-transform:scale(0.7,0.5)'
    te: |
      q'border-bottom:1px solid black',
      qw' padding:0.4em margin-left:2em
            width:100% float:left position:relative'
    yw: |
        q' margin-left:0.5em '
    yo: |
        q' color:#a3f'
    20pt: |
      'font-size:20pt;'
    yi: |
        q' margin-left:0.5em color:#fca'
        
    yt: |
        qw'font-size:120% '
    red: |
       q' color:red ';
    tinyer: |
        q'-webkit-transform:scale(0.7,0.5)'
    shlink: |
        q" -webkit-transform:rotate(45deg) scale(1,0.5); ";
        
    rel: |
      qw'position:relative'
    abs: |
      qw'position:absolute'
    topleft: |
      qw'position:absolute top:-5px left:-5px'
    white: |
      qw'color:white'
    little: |
      qw'font-size:60%'
    fulw: |
      qw {height:100% float:left position:absolute},
  event: |
    my $u = L.i;
    my $ux = uxL.i;
    my $uu = ux.B.Lu.i;
    my $uy = $u if $u ne $ux;
    my $E = {
        e => $e,
        W => $W,
        L => uu.Li,
        u => $uu,
        ux => $ux,
        uy => $uy,
    };
    
    # come from within something we don't grasp
    return H.G->w('serve/TV', {e=>E.e}) unless E.L;
    
    # TODO make a pattern about y=to match against Eways...
    E.L.G->w(event => $E);
  
  U: |
    0->visTp($ar, "Fun") if ar.i;
    my $u = T.i;
    
    w utricks/spawn[$u];
    w sane/U1[$u];
    
        w U(i=>$_) for reverse @{T.L.o};

    w compile_figure[$u];
    w wayout_sendo[$u];
    
            w J if G.top == T.i;
  J: |
    0->visTp($ar, "Fun") if ar.i;
    my $u = T.i;
    
    for my $do (@{u.sendo || []}) {
        $do->();
    }

        w J(i=>$_) for @{T.L.o};
  compile_figure: |
        my $j = sub { join " ", grep { defined } @_ };
        my $Lui = u.B.Lu.i if u.B.Lu;
        my $at = u.at = {};
        
        at.id = u.S.id_D ? do {w $u S/id_D;} :  u.Li.uuid;
        
        at.tag = u.B.tag || u.S.tag;
        
        at.class = u.B.class || u.S.class || u.B.class;
        if (u.B.class) {
            die "LUI!".sw($u);
        }
        
        at.styles = $j->(u.styles);
        
        if (u.O ne 'ux') {
            at.styles .= " y".u.K;
            at.tag ||= "y".u.K;
        }
        if (u.K eq 'ux') {
            if ($Lui && Lui.styles) {
                die "Lui styles ".sw($Lui);
            }
            at.styles .= " ".u.B.Lu.i.styles
        }
        at.tag ||= u.K;
        die "no tag" .sw($u) if !at.tag;
        at.conty = u.B.content if u.B.content;
        at.conty = w $u S/content_D(e=>'') if u.S.content_D;
        at.conty = "" if !defined at.conty;
        
        at.ooze = [sort { a.conor <=> b.conor } @{u.Li.o || []}];
        
  wayout_sendo: |
        my $at = u.at;
        my $Lui = u.B.Lu.i if u.K eq "ux";
        my $sendo = u.sendo = [];
        my $_t = u._at;
        
            my $conty = defined at.conty ? at.conty : "";
            $conty = encode_entities($conty);
            my @oozs = grep { defined } map { _.html } @{ at.ooze };
            my $content = join "\n", @oozs;
            
            
        # always update html, doesn
        
        my $attr = at.attr = {
            id => at.id,
            style => $G->styles(at.styles),
            class => at.class,
        };
            
        if (!$_t) {
            die "conty and ooze ".pint($u) if $conty && $content;

            if (length($conty.$content) > 25000) {
                $content = "";
                push @$sendo, sub {
                    $H->JS("\$('#at.id').append('$_');") for @oozs
                };
            }
            push @$sendo, sub { w $u S/sendo_init_D(e=>'') } if u.S.sendo_init_D;
            push @$sendo, sub { G.O.V.ux->takeover(u.html) } if $u eq G.top;
        }
        else {
            my $ino = sub { my ($u, $in) = @_; grep { $_ eq $u } @$in; };
            my $sendojs = sub {
                my ($id, $sp, @int) = @_;
                push @$sendo, sub {
                    $H->JS("\$('#$id')".sprintf($sp, @int).";")
                };
            };
            
            for my $newz (grep { !$ino->($_, u._at.ooze) } @{at.ooze}) {
                $sendojs->(at.id, q{.append('%s')}, 0->jsq(newz.html));
            }
            for my $gone (grep { !$ino->($_, at.ooze) } @{u._at.ooze}) {
                $sendojs->(gone.id, q{.remove()});
            }
            if (at.conty ne _t.conty) {
                saybl "CONTIGITY" for 1..10;
                $sendojs->(at.id, q{.text('%s')}, 0->jsq(at.conty));
            }
            while (my ($k, $v) = each %{ at.attr }) {
                if ($v ne _t.attr->{$k}) {
                    saybl "UPTRIB $k\n -  $_t->{$k}\n +  $v" for 1..2;
                    $sendojs->(at.id, q{.attr('%s', '%s')}, 0->jsq($k), 0->jsq($v));
                }
            }
            # attr updates
            
        }
        my $tag = at.tag;
        # style/class gets misccss/Wcss
        $attr = join " ", map { $_.'="'.$attr->{$_}.'"' }
            grep { defined $attr->{$_} && $attr->{$_} ne "" } sort keys %$attr;
            
        u.html = "<$tag $attr>$conty$content</$tag>";
        
        sayyl " Cododnny ".wdump($attr) if $Lui && Lui.K eq "Codon";
        
        u._at = $at;
  RW: | # for making the tip, which is a hash anyway
    my $W = ar.top||ar.W;
    ref $W eq "Wormhole" || die sw([$W,"Weird wormhole RW"]);
    my $Bu = [W => {W => $W}];
    my $u = 0->TafuBl(@$Bu);
    0->visTp({ i => $u }) if ar.top && T.i ne $u;
    G.top = $u if ar.top;
    return $u
    
  RM: | # a tip on the other side, so below our tip but above in space
    ref $W eq "Wormhole" || die sw([$W,"Weird wormhole RM"]);
    0->TafuBl(
        M => {W => $W},
    );
  ux_above_via_Lu: |
    my $Lu = ux.B.Lu || die "no Lu on ux";
    my $pLu = Lu.i.Lo if exists Lu.i.Lo; # up and over
    my ($pux) = findO(ux => pLu.o) if $pLu;
    $pux;
  ux: |
    my $Ls = ar.Ls;
    $Ls ||= ar.W->CS if ar.W;
    $Ls ||= [];
    saybl @$Ls." lines -> ux from $Ls->[0]->{name}";
    
    w RW(top => G.T.W);# T encapsu is whole ux W
    # interested in grep { _.i.K eq "ux" } @{ $G->W->CS }
    # l( @ Lu.o   # fu( via v
    my $uxs = [ map {
        0->visTp_TafuBlA({L=>$_}, [ux => {Lu=>$_}])
    } @{$Ls} ]; 
    
    for my $ux (@$uxs) {
        my $ix = w ux_above_via_Lu[$ux]; # join uxLis together like the origin
        $ix ||= w RM(W => ux.B.Lu.G.T.W); # or the ux for its W
        0->visTp_l_u({i=>$ix}, $ux);
        w sane/V3[$ux, $ix, $uxs];
    }
    
    w U;
    
    my $es =  "done ".$G->F_delta();
    sayre "ux -------- $es " for 1..5;
    
  sane:
    V3: |
      die "ix not Li " unless ix.Li;
      die "ux not in above ux o: ".sw({uxs=>$uxs,ix=>$ix})
          unless ix.O ne "ux" || grep { $_ eq $ux } @{ix.Li.o};
    U1: |
        my $Lu = u.B.Lu || die "no Lu".sw({" no Lu"=>$u}) if u.K eq "ux";
        die "ux has no ways out, expected SOMETHING!?".sw(u.Li)
            if u.K eq "ux" && !@{u.Li.o};
  utricks:
    spawn: | #c
        my @uys;
        my $ui = u.B.Lu.i;
        if (ui.S) {
            $u->from(ui.S);
        }
        if (my $spawn = u.spawn) {
            for my $sp (@$spawn) {
                my $Bs = {};
                if (sp.Bset) {
                    while (my ($k, $v) = each %{sp.Bset}) {
                        $Bs->{$k} = $u->find("B.$v"); # v=Lu.i
                    }
                }
                else {
                    $Bs = u.B;
                }
                my $uy = 0->sway({K=>sp.K}, {B=>$Bs}, {e=>''});
                uy.S.content_D = sp.content_D if sp.content_D;
                push @uys, w utricks/multi[$uy, $u, $sp]; 
            }
        }
        
        for my $uu (@uys) {
            if (my $uy = 0->fu($uu)) {
            }
            else {
                sayyl "NEW u ! uu.K ".ki(uu.B);
                $uy = 0->T({i => $uu});
                0->l($uy);
            }
        }
    multi: | #c
      my @uys = $uy;
      if (my $n = sp.multiBy) {
            my $val = uy.B->{$n};
          ref $val eq "ARRAY" || die "was promised $n would be array, is $val ".wdump($uy);
          @uys = ();
          my $i = 0;
          for my $an (@$val) {
              next if an.K eq "ux"; # that hangs out in the origin lines o
              my $anuy = $uy->spawn;
              anuy.B->{$n} = $an;
              anuy.K ."[".$i++;
              push @uys, $anuy;
          }
      }
      @uys
    ngrab: | #c
                if (u.uy_in_dos) {
                    if (my $ton = u.uy_in_dos->{"n_uys_to_".uy.K."_n"}) {
                        uy.B->{$ton} = u.B->{u.B.n};
                        uy.B.n = $ton;
                    }
                }
                if (uy.uy_in_dos) {
                    if (my $n = uy.uy_in_dos.Lu_grab_n) {
                        uy.B->{$n} = u.B.Lu->{$n};
                        uy.B.n = $n;
                    }
                }

