name: Styluxyio

C:            # W M ux
  - K: W # us
    O: ux
    spawn:
      - K: style
        conor: -1.5
        B:
          SS: pri
      - K: style
        conor: -1.4
        B:
          SS: tri
    S:
      tag: wormhole
      id_D: |
        ( W.id =~ /-(\w+)$/ )[0]
        
  - K: style
    attrs:
      scoped: 1
      type: text/css
    S:
      content_D: |
        w stylesheet(SS => S.B.SS);
      
  - K: M
    O: ux
    spawn:
      - K: h1
        content_D: |
          W.G.name
    S:
      tag: MMMM
     
  - K: ux
    O: ux
    spawn:
      - K: i
      - K: t
      - K: o
    S:
      tag: ux
    styles: te
    conor: 1
    print: |
       "(".pint(S.B.Lu.i)." \t".gpty(S.B.Lu.t).")"
       
  - K: i     #c uyuyuuyuyyyuyuyuuuuyuuuuyyyuyuyyyuyuuuyuyuyyyyuyuyu
    spawn:
      - K: w
        Bset:
          w: Lu.i
        Scc: 1
    conor: -0.5
    
  - K: t
    S:
      content_D: |
        die "t content fullity" if S.B.raw || S.raw;
        my $con = gpty(Lu.t);
        $con = ($con=~/^(.{30})/s)[0]."..." if length($con) > 50;
        $con;
      
  - K: o
    spawn:
      - K: w
        multiBy: w
        Scc: 1
        Bset:
          w: Lu.o
    conor: 0.5
    
  - K: w
    S:
      content_D: |
        pint($w);
      
  - K: e
    styles: topleft white little
    S:
      content_D: |
        $e
  
  - K: somewhere #c
    styles: te
    S:
      sendo_init_D: |
        return;
        $H->JS("\$('#somewhere').appendTo('#S.at.id');");
        my $css = 'pointer-events:none; -webkit-filter: brightness(1.2) saturate(3) drop-shadow(10px 0px 30px black); width:60em;';
        $H->JS("\$('#somewhere').attr('style', '$css');");
    S:
      content_D
  - K: h1 #c
    styles: h1
  - K: h2 
  - K: pre
    styles: skinny pre
  - K: script
    S:
      no_implied_attr: 1

   
hooks:
  

  any_init: |
    w styleup;
  styleup: |
    my $SS = $G->findway('StyleS');
    %$SS = ();
    for my $SSS (qw'pri tri') {
        my $Sc = $G->findway("SS_$SSS");
        %$SS = (%$SS, %$Sc);
    }
  stylesheet: |
    $SS = "SS_$SS";
    $SS = $G->findway($SS);
    join "\n", map {
        ".$_ { ". join(";", @{$SS->{$_}}) ." }"
    } grep { !/_D$/ } sort keys %$SS;
  StyleS: {}
  SS_pri:
    yi: 
      - margin-left:0.5em
      - color:#fca
      - font-size:66%
    yo: 
      - color:#a3f
      - font-size:80%
    yt: 
      - font-size:120%
    yw: 
      - " margin-left:0.5em "
    te: 
      - border-bottom:1px solid black
      - padding-left:2em
      - float:left
      - position:relative
      - width:calc(100% - 2em)
      - background:rgba(150,100,50,0.1)
  SS_tri:
    20pt: 
      - font-size:20pt;
    abs: 
      - position:absolute
    antrail: 
      - border-left:8px solid rgba(255,255,255,0.7);
    bg018: 
      - background:rgba(0,25,200)
    chtit: 
      - color:#fff
      - font-size:240%
    fulw: 
      - height:100%
      - float:left
      - position:absolute
    h1: 
      - font-size:170%
      - color:#77f
    h2: 
      - font-size:200%
      - color:#55f
      - font-weight:5
    hugeblurbackname: 
      - color:rgba(255,255,255,0.5)
    little: 
      - font-size:60%
    nottoobig_D: |
      'z94' if length u.at.conty > 10
    pre: 
      - overflow-wrap:break-word
      - margin:0em
    red: 
      - " color:red "
    rel: 
      - position:relative
    shlink: 
      - " -webkit-transform:rotate(45deg) scale(1,0.5); "
    skinny: 
      - margin:0.2em
    tinyer: 
      - -webkit-transform:scale(0.7,0.5)
    topleft: 
      - position:absolute
      - top:-5px
      - left:-5px
    wanderleft3em: 
      - left:0em
    white: 
      - color:white
    z4: 
      - font-size:44.44%
    z94: 
      - font-size:144.44%
  
  event: |
    my $u = L.i;
    my $ux = uxL.i;
    my $uu = ux.B.Lu.i;
    my $uy = $u if $u ne $ux;
    my $E = {
        e => $e,
        W => $W,
        L => uu.Li,
        u => $uu,
        ux => $ux,
        uy => $uy,
    };
    
    # come from within something we don't grasp
    return H.G->w('serve/TV', {e=>E.e}) unless E.L;
    
    # TODO make a pattern about y=to match against Eways...
    E.L.G->w(event => $E);
    
    #sw($E) unless uy.K eq "t";
  
  U: |
    0->visTp($ar, "Fun") if ar.i;
    my $u = T.i;
    
    w utricks/spawn[$u];
    w sane/U1[$u];
    
        w U(i=>$_) for reverse @{T.L.o};

    w compile_figure[$u];
    w wayout_sendo[$u];
    
            w J if G.top == T.i;
  J: |
    0->visTp($ar, "Fun") if ar.i;
    my $u = T.i;
    
    for my $do (@{u.sendo || []}) {
        $do->();
    }

        w J(i=>$_) for @{T.L.o};

  compile_figure: |
        my $j = sub { join " ", grep { defined } @_ };
        my $ui = u.B.Lu.i if u.B.Lu;
        my $at = u.at = {};
        
        my $wi = ui.G->findway(ui.K) if ui.Gw;
        # 
        my $tryf = sub {         # prefer S thing_Ds
            my ($w, $ac, $pa, $wa) = @_;
            my $f = $w->{$ac}; # poss. from fragment
            return unless $f;
            my $way = $wa || $w; # call non fragment
            my $some = way.G->w("$ac/$pa"."_D", {}, $way) if $f->{"$pa"."_D"};
            #die sw([$w, $ac, $f, $f->{$pa}, $pa, $some]) if $wa && $pa =~ /ishtml/;
            return $some if $some;
            $f->{$pa} if $f->{$pa};
        };
        my $Gww = sub {           # prefer Gw S things
            my ($w, @a) = @_;
            my $Gw = w.G->findway(w.K) if w.Gw;
            $Gw = $tryf->($Gw, @a, $w) if $Gw;
            $Gw || $tryf->($w, @a);
        };
        my $ui_or_u = sub {     # prefer ui S things
            $Gww->($ui, @_) || $Gww->($u, @_)
        };
        
        # ^ the look-around-for-style-etc vortex v
        
        at.id = $ui_or_u->(S => 'id') || u.Li.uuid;
        
        at.tag = $ui_or_u->(S => 'tag') || u.K;
        
        at.ishtml = $ui_or_u->(S => 'ishtml');
        
        at.class = $ui_or_u->(S => 'class');
        
        my @styles;
        push @styles, " y".u.K if u.O ne 'ux';
        at.tag ||= "y".u.K if u.O ne 'ux';
        push @styles, u.styles, u.S.styles;
        push @styles, ui.styles, ui.S.styles if $ui;
        
        at.styles = $j->(@styles);
        
        
        at.tag ||= u.K;
        die "no tag" .sw($u) if !at.tag;
        
        at.conty = $ui_or_u->(S => 'content');
        
        at.conty = "" if !defined at.conty;
        at.conty = encode_entities(at.conty) unless at.ishtml;
        
        at.ooze = [sort { a.conor <=> b.conor } @{u.Li.o || []}];
  stylezo: |
    # u at->attribute traslator
    # builds up W or M styles from ux or ui.G styles
    #my $W = G.top;
    my $s = $G->findway('StyleS');
    my $apply;
    $apply = sub {
        my $style = shift;
        if ($style =~ / /) {
            return map { $apply->($_) } split ' ', $style
        }
        if ($s->{$style}) {
            attr.class .= " $style";
        }
        elsif ($s->{$style."_D"}) {
            my $ysty = $G->w("StyleS/".$style."_D", $ar);
            $apply->($ysty) if $ysty;
        }
    };
    $apply->($styles);
  wayout_sendo: |
        my $at = u.at;
        my $ui = u.B.Lu.i if u.K eq "ux";
        my $sendo = u.sendo = [];
        my $_t = u._at;
        
            my $conty = defined at.conty ? at.conty : "";
            my @oozs = grep { defined } map { _.html } @{ at.ooze };
            my $content = join "\n", @oozs;
            
            
        
        my $attr = at.attr = {
            id => at.id,
            class => at.class,
            %{ u.attrs || {} },
        };
        my $styles = at.styles;
        
        w stylezo[$u, $ui, $styles, $attr];
            
        if (!$_t) {
            #w sendnew[$u, $ui, $attr, $at, $conty, $content];
            if ( $conty && $content ){
                warn "conty and ooze ".sw(["contooz", $u, $conty, $content]);
                $conty = "";
            }

            if (length($conty.$content) > 25000) {
                $content = "";
                push @$sendo, sub {
                    $H->JS("\$('#at.id').append('$_');") for @oozs
                };
            }
            push @$sendo, sub { w $u S/sendo_init_D(e=>'') } if u.S.sendo_init_D;
            
            #die "Sendno" if u.sendo_init_D;
            push @$sendo, sub { G.O.V.ux->takeover(u.html) } if $u eq G.top;
        }
        else {
            #w sendnew[$u, $ui, $attr, $at, $conty, $content];
            my $ino = sub { my ($u, $in) = @_; grep { $_ eq $u } @$in; };
            my $sendojs = sub {
                my ($id, $sp, @int) = @_;
                push @$sendo, sub {
                    $H->JS("\$('#$id')".sprintf($sp, @int).";")
                };
            };
            
            for my $newz (grep { !$ino->($_, u._at.ooze) } @{at.ooze}) {
                $sendojs->(at.id, q{.append('%s')}, 0->jsq(newz.html));
            }
            for my $gone (grep { !$ino->($_, at.ooze) } @{u._at.ooze}) {
                $sendojs->(gone.id, q{.remove()});
            }
            if (at.conty ne _t.conty) {
                saybl "CONTIGITY" for 1..10;
                $sendojs->(at.id, q{.text('%s')}, 0->jsq(at.conty));
            }
            while (my ($k, $v) = each %{ at.attr }) {
                if ($v ne _t.attr->{$k}) {
                    saybl "UPTRIB $k\n -  $_t->{$k}\n +  $v" for 1..2;
                    $sendojs->(at.id, q{.attr('%s', '%s')}, 0->jsq($k), 0->jsq($v));
                }
            }
            # attr updates
            
        }
        my $tag = at.tag;
        # style/class gets misccss/Wcss
        $attr = join " ", map { $_.'="'.$attr->{$_}.'"' }
            grep { defined $attr->{$_} && $attr->{$_} ne "" } sort keys %$attr;
            
        u.html = "<$tag $attr>$conty$content</$tag>";
        
        sayyl " Cododnny ".wdump($attr) if $ui && ui.K eq "Codon";
        
        u._at = $at;
  RW: | # for making the tip, which is a hash anyway
    my $W = ar.top||ar.W;
    ref $W eq "Wormhole" || die sw([$W,"Weird wormhole RW"]);
    my $Bu = [W => {W => $W}];
    my $u = 0->TafuBl(@$Bu);
    0->visTp({ i => $u }) if ar.top && T.i ne $u;
    G.top = $u if ar.top;
    return $u
    
  RM: | # a tip on the other side, so below our tip but above in space
    ref $W eq "Wormhole" || die sw([$W,"Weird wormhole RM"]);
    0->TafuBl(
        M => {W => $W},
    );
  ux_above_via_Lu: |
    my $Lu = ux.B.Lu || die "no Lu on ux";
    my $pLu = Lu.i.Lo if exists Lu.i.Lo; # up and over
    my ($pux) = findO(ux => pLu.o) if $pLu;
    $pux;
  ux: |
    my $Ls = ar.Ls;
    $Ls ||= ar.W->CS if ar.W;
    $Ls ||= [];
    saybl @$Ls." lines -> ux from $Ls->[0]->{name}";
    
    w RW(top => G.T.W);# T encapsu is whole ux W
    # interested in grep { _.i.K eq "ux" } @{ $G->W->CS }
    # l( @ Lu.o   # fu( via v
    my $uxs = [ map {
        0->visTp_TafuBlA({L=>$_}, [ux => {Lu=>$_}])
    } @{$Ls} ]; 
    
    for my $ux (@$uxs) {
        my $ix = w ux_above_via_Lu[$ux]; # join uxLis together like the origin
        $ix ||= w RM(W => ux.B.Lu.G.T.W); # or the ux for its W
        0->visTp_l_u({i=>$ix}, $ux);
        w sane/V3[$ux, $ix, $uxs];
    }
    
    w U;
    
    my $es =  "done ".$G->F_delta();
    sayre "ux -------- $es " for 1..5;
    
  sane:
    V3: |
      die "ix not Li " unless ix.Li;
      die "ux not in above ux o: ".sw({uxs=>$uxs,ix=>$ix})
          unless ix.O ne "ux" || grep { $_ eq $ux } @{ix.Li.o};
    U1: |
        my $Lu = u.B.Lu || die "no Lu".sw({" no Lu"=>$u}) if u.K eq "ux";
        die "ux has no ways out, expected SOMETHING!?".sw(u.Li)
            if u.K eq "ux" && !@{u.Li.o};
  utricks:
    spawn: | #c
        my @uys;
        my $ui = u.B.Lu.i;
        u.B.ui = $ui if $ui;
        if (ui.u_from) {
            $u->from(ui.u_from);
        }
        if (my $spawn = u.spawn) {
            for my $sp (@$spawn) {
                
                my $Bs = {};
                if (sp.Bset) {
                    while (my ($k, $v) = each %{sp.Bset}) {
                        $Bs->{$k} = $u->find("B.$v"); # i=Lu.i etc
                    }
                }
                else {
                    $Bs = u.B;
                }
                my $uy = 0->sway({K=>sp.K}, {B=>$Bs}, {e=>''});
                
                $uy->from({S=>u.S}) if delete sp.Scc;
                
                $uy->from($sp);
                
                push @uys, w utricks/multi[$uy, $u, $sp]; 
            }
        }
        
        for my $uu (@uys) {
            if (my $uy = 0->fu($uu)) {
            }
            else {
                sayyl "NEW u ! uu.K ".ki(uu.B);
                $uy = 0->T({i => $uu});
                0->l($uy);
            }
        }
    multi: | #c
      my @uys = $uy;
      if (my $n = sp.multiBy) {
            my $val = uy.B->{$n};
          ref $val eq "ARRAY" || die "was promised $n would be array, is $val ".wdump($uy);
          @uys = ();
          my $i = 0;
          for my $an (@$val) {
              next if an.K eq "ux"; # that hangs out in the origin lines o
              my $anuy = $uy->spawn;
              anuy.B->{$n} = $an;
              anuy.K ."[".$i++;
              push @uys, $anuy;
          }
      }
      @uys
    ngrab: | #c
                if (u.uy_in_dos) {
                    if (my $ton = u.uy_in_dos->{"n_uys_to_".uy.K."_n"}) {
                        uy.B->{$ton} = u.B->{u.B.n};
                        uy.B.n = $ton;
                    }
                }
                if (uy.uy_in_dos) {
                    if (my $n = uy.uy_in_dos.Lu_grab_n) {
                        uy.B->{$n} = u.B.Lu->{$n};
                        uy.B.n = $n;
                    }
                }

