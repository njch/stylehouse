name: Styluxyio

C:            # W M ux
  - K: W # us
    O: ux
    spawn:
      - K: somewhere
    S:
      tag: wormhole
      id_D: |
        ( W.id =~ /-(\w+)$/ )[0]
        
  - K: M
    O: ux
    spawn:
      - K: h1
        content_D: |
          W.G.name
    S:
      tag: MMMM
     
  - K: ux
    O: ux
    spawn:
      - K: i
      - K: t
      - K: o
    S:
      tag: ux
    styles: te
    conor: 1
    print: |
       "(".pint(S.B.Lu.i)." \t".gpty(S.B.Lu.t).")"
       
  - K: i     #c uyuyuuyuyyyuyuyuuuuyuuuuyyyuyuyyyuyuuuyuyuyyyyuyuyu
    spawn:
      - K: w
        Bset:
          w: Lu.i
    conor: -0.5
    
  - K: t
    S:
      content_D: |
        die "t content fullity" if S.B.raw || S.raw;
        my $con = gpty(Lu.t);
        $con = ($con=~/^(.{30})/s)[0]."..." if length($con) > 50;
        $con;
      
  - K: o
    spawn:
      - K: w
        multiBy: w
        Bset:
          w: Lu.o
    conor: 0.5
    
  - K: w
    S:
      content_D: |
        pint($w);
      
  - K: e
    styles: topleft white little
    S:
      content_D: |
        $e
  
  - K: somewhere #c
    styles: te
    S:
      sendo_init_D: |
        return;
        $H->JS("\$('#somewhere').appendTo('#S.at.id');");
        my $css = 'pointer-events:none; -webkit-filter: brightness(1.2) saturate(3) drop-shadow(10px 0px 30px black); width:60em;';
        $H->JS("\$('#somewhere').attr('style', '$css');");
  
  - K: h1
    styles: blubor
    
   
hooks:
  styles:
    blubor: |
      q'border:3px solid rgba(20,20,255,0.5);';
    tinyer: |
        q'-webkit-transform:scale(0.7,0.5)'
    te: |
      q'border-bottom:1px solid black',
      qw' padding:0.4em margin-left:2em
            width:100% float:left position:relative'
    yw: |
        q' margin-left:0.5em '
    yo: |
        q' color:#bbb'
    20pt: |
      'font-size:20pt;'
    yi: |
        q' margin-left:0.5em color:#fff'
        
    yt: |
        qw'font-size:120% '
    
    tinyer: |
        q'-webkit-transform:scale(0.7,0.5)'
    shlink: |
        q" -webkit-transform:rotate(45deg) scale(1,0.5); ";
        
    rel: |
      qw'position:relative'
    abs: |
      qw'position:absolute'
    topleft: |
      qw'position:absolute top:-5px left:-5px'
    white: |
      qw'color:white'
    little: |
      qw'font-size:60%'
    fulw: |
      qw {height:100% float:left position:absolute},
  event: |
    my $u = L.i;
    my $ux = uxL.i;
    my $E = {%$ar};
    E.L = ux.B.Lu;
    unless (E.L) {
        # come from within something we don't grasp
        return H.G->w('serve/TV', {e=>E.e});
    }
    E.uyL = $L if $L ne $uxL;
    E.L.G->w(event => $E);
  
  U: |
    0->visTp($ar, "Fun") if ar.i;
    my $u = T.i;
    
    w utricks/spawn[$u];
    w sane/U1[$u];
    
        w U(i=>$_) for @{T.L.o};

    w compile_figure[$u];
    w wayout_sendo[$u];
    
            w J if G.top == T.i;
  J: |
    0->visTp($ar, "Fun") if ar.i;
    my $u = T.i;
    
    for my $do (@{u.sendo || []}) {
        $do->();
    }

        w J(i=>$_) for @{T.L.o};
  compile_figure: |
        my $j = sub { join " ", grep { defined } @_ };
        my $at = u.at = {
            id => (u.S.id_D ? do {w $u S/id_D;} :  u.Li.uuid),
            tag => (u.B.tag || u.S.tag),
        };
        at.styles = $j->(u.styles);
        
        if (u.O ne 'ux' && u.B.n) {
            at.styles .= " y".u.B.n;
            at.tag ||= "y".u.B.n;
        }
        if (u.K eq 'ux') {
            at.styles .= " ".u.B.Lu.i.styles
        }
        at.tag ||= u.K;
        die "no tag" .sw($u) if !at.tag;
        at.conty = u.B.content if u.B.content;
        at.conty = w $u S/content_D(e=>'') if u.S.content_D;
        
        at.ooze = [sort { a.conor <=> b.conor } @{u.Li.o || []}];
        
  wayout_sendo: |
        my $at = u.at;
        my $sendo = u.sendo = [];
        my $first = !u._at;
        
            my $conty = defined at.conty ? at.conty : "";
            my @oozs = grep { defined } map { _.html } @{ at.ooze };
            my $content = join "\n", @oozs;
            
        if ($first) {
            say "First";
            die "conty and ooze ".pint($u) if $conty && $content;

            if (length($conty.$content) > 25000) {
                $content = "";
                push @$sendo, sub {
                    $H->JS("\$('#at.id').append('$_');") for @oozs
                };
            }
            if (u.S.sendo_init_D) {
                push @$sendo, sub { w $u S/sendo_init_D(e=>'') };
            }
            if ($u eq G.top) {
                push @$sendo, sub { G.O.V.ux->takeover(u.html) };
            }
        }
        else {
            my $ino = sub { my ($u, $in) = @_; grep { $_ eq $u } @$in; };
            my $oze = u._at.ooze;
            for my $newz (grep { !$ino->($_, $oze) } @{at.ooze}) {
                say "some newz";
                # where not in oze ^
                push @$sendo, sub { $H->JS("\$('#at.id').append('newz.html');") };
            }
            for my $gone (grep { !$ino->($_, at.ooze) } @$oze) {
                push @$sendo, sub { $H->JS("\$('#gone.id').remove();") };
            }
            
            # attr updates
            
        }
        # always update html, doesn
        my $attr = {
            id => at.id,
            style => $G->styles(at.styles),
            class => at.class,
        };
        my $tag = at.tag;
        # style/class gets misccss/Wcss
        $attr = join " ", map { $_.'="'.$attr->{$_}.'"' }
            grep { defined $attr->{$_} && $attr->{$_} ne "" } sort keys %$attr;
            
        u.html = "<$tag $attr>$conty$content</$tag>";
        u._at = $at;
  RW: | # for making the tip, which is a hash anyway
    my $W = ar.top||ar.W;
    ref $W eq "Wormhole" || die sw([$W,"Weird wormhole RW"]);
    my $Bu = [W => {W => $W}];
    my $u = 0->TafuBl(@$Bu);
    0->visTp({ i => $u }) if ar.top && T.i ne $u;
    G.top = $u if ar.top;
    return $u
    
  RM: | # a tip on the other side, so below our tip but above in space
    ref $W eq "Wormhole" || die sw([$W,"Weird wormhole RM"]);
    0->TafuBl(
        M => {W => $W},
    );
  ux_above_via_Lu: |
    my $Lu = ux.B.Lu || die "no Lu on ux";
    my $pLu = Lu.i.Lo if exists Lu.i.Lo; # up and over
    my ($pux) = findO(ux => pLu.o) if $pLu;
    $pux;
  ux: |
    my $Ls = ar.Ls;
    $Ls ||= ar.W->CS if ar.W;
    $Ls ||= [];
    saybl @$Ls." lines -> ux from $Ls->[0]->{name}";
    
    w RW(top => G.T.W);# T encapsu is whole ux W
    # interested in grep { _.i.K eq "ux" } @{ $G->W->CS }
    # l( @ Lu.o   # fu( via v
    my $uxs = [ map {
        0->visTp_TafuBl({L=>$_}, [ux => {Lu=>$_}])
    } @{$Ls} ]; 
    
    for my $ux (@$uxs) {
        my $ix = w ux_above_via_Lu[$ux]; # join uxLis together like the origin
        $ix ||= w RM(W => ux.B.Lu.G.T.W); # or the ux for its W
        0->visTp_l_u({i=>$ix}, $ux);
        w sane/V3[$ux, $ix, $uxs];
    }
    
    w U;
    
  recoded_init: |
    #H.G->w('re/exec');
    Say "Booyah"; 
    
  sane:
    V3: |
      die "ix not Li " unless ix.Li;
      die "ux not in above ux o: ".sw({uxs=>$uxs,ix=>$ix})
          unless ix.O ne "ux" || grep { $_ eq $ux } @{ix.Li.o};
    U1: |
        my $Lu = u.B.Lu || die "no Lu".sw({" no Lu"=>$u}) if u.K eq "ux";
        die "ux has no ways out, expected SOMETHING!?".sw(u.Li)
            if u.K eq "ux" && !@{u.Li.o};
  utricks:
    spawn: | #c
        my @uys;
        
        if (my $spawn = u.spawn) {
            for my $sp (@$spawn) {
                my $Bs = {};
                if (sp.Bset) {
                    while (my ($k, $v) = each %{sp.Bset}) {
                        $Bs->{$k} = $u->find("B.$v"); # v=Lu.i
                    }
                }
                else {
                    $Bs = u.B;
                }
                my $uy = 0->sway({K=>sp.K}, {B=>$Bs});
                uy.S.content_D = sp.content_D if sp.content_D;
                push @uys, w utricks/multi[$uy, $u, $sp]; 
            }
        }
        
        for my $uu (@uys) {
            if (my $uy = 0->fu($uu)) {
                say "u fu uu.K ".ki(uu.B); # cache
            }
            else {
                say "u not found! uu.K ".ki(uu.B);
                $uy = 0->T({i => $uu});
                0->l($uy);
                # and $uy is it
            }
        }
    multi: | #c
      my @uys = $uy;
      if (my $n = sp.multiBy) {
            my $val = uy.B->{$n};
          ref $val eq "ARRAY" || die "was promised $n would be array, is $val ".wdump($uy);
          @uys = ();
          my $i = 0;
          for my $an (@$val) {
              next if an.K eq "ux"; # that hangs out in the origin lines o
              my $anuy = $uy->spawn;
              anuy.B->{$n} = $an;
              anuy.K = uy.K."[".$i++;
              push @uys, $anuy;
          }
      }
      @uys
    ngrab: | #c
                if (u.uy_in_dos) {
                    if (my $ton = u.uy_in_dos->{"n_uys_to_".uy.K."_n"}) {
                        uy.B->{$ton} = u.B->{u.B.n};
                        uy.B.n = $ton;
                    }
                }
                if (uy.uy_in_dos) {
                    if (my $n = uy.uy_in_dos.Lu_grab_n) {
                        uy.B->{$n} = u.B.Lu->{$n};
                        uy.B.n = $n;
                    }
                }

