name: Styluxyio
C:            # W M ux ...
  - K: W # us
    O: ux
    _Ss: [u, x]
    flows_D: |
      w stylespawn[$S, $W]; # stylesheets to spawn
    S:
      tag: wormhole
      id_D: |
        ( W.id =~ /-(\w+)$/ )[0]
      
  - K: M
    O: ux
    flows_D: |
      w stylespawn[$S, $W];
    spawn:
      - K: h1
        content_D: |
          W.G.name
    S:
      tag: MMMM
        
  - K: style
    conor: -1.5
    attrs:
      scoped: undef
      type: text/css
    S:
      content_D: |
        my $GG = S.Lo.i.B.W.G; # G from M or W # Lui.B.W might work
        # something already interroGGd for <styles> here's one:
        my $A = B.A || "S";
        # may need to careful order new appendages too?
        my $sheet = w stylesheet[$GG, $A];
        $sheet ? "\n$sheet\n" : "";
     
  - K: ux
    O: ux
    spawn:
      - K: i
      - K: t
      - K: o
    S:
      tag: ux
    styles: te
    conor: 1
    print: |
       "(".pint(S.B.Lu.i)." \t".gpty(S.B.Lu.t).")"
       
  - K: i     #c uyuyuuyuyyyuyuyuuuuyuuuuyyyuyuyyyuyuuuyuyuyyyyuyuyu
    spawn:
      - K: w
        Bset:
          w: Lu.i
        Scc: 1
    conor: -0.5
    
  - K: t
    S:
      content_D: |
        die "t content fullity" if S.B.raw || S.raw;
        my $con = gpty(Lu.t);
        $con = ($con=~/^(.{30})/s)[0]."..." if length($con) > 50;
        $con;
      
  - K: o
    spawn:
      - K: w
        multiBy: w
        Scc: 1
        Bset:
          w: Lu.o
    conor: 0.5
    
  - K: w
    S:
      content_D: |
        pint($w);
      
  - K: e
    styles: topleft white little
    S:
      content_D: |
        $e
  
  - K: somewhere #c
    styles: te
    S:
      sendo_init_D: |
        return;
        $H->JS("\$('#somewhere').appendTo('#S.at.id');");
        my $css = 'pointer-events:none; -webkit-filter: brightness(1.2) saturate(3) drop-shadow(10px 0px 30px black); width:60em;';
        $H->JS("\$('#somewhere').attr('style', '$css');");
    S:
      content_D
  - K: h1 #c
    styles: h1
  - K: h2 
  - K: pre
    styles: skinny pre
  - K: script
    S:
      no_implied_attr: 1

   
hooks:
  any_init: |
    #G.h = {};
    #map { w styleup(GG => $_); } $G;# map{_.G}grep{_.i.K eq "M"}@{G.T.W.script};
  stylespawn: |
    my $GG = W.G;
    my $sp = S.spawn ||= [];
    my $As = S._Ss || GG._Ss || [];
    for my $A (@$As) {
        push @$sp, { K => 'style', B=>{A => $A} };
        w styleup[$GG, $A];
    }
  styleup: |
    my $SS = w styleway[$GG, $A];
    ref $SS eq "ARRAY" || die sw(["style ${A}_S not found", $A, $SS, $GG]);
    0->wayray($SS, $GG); # hook these up elsewhere
    for my $S (@$SS) {
        G.h->{S.K} = $S;
    }
  styleway: |
    $GG->findway($A.'_S') || $G->findway($A.'_S');
  stylesheet: |
    $A ||= "S";
    my $SS = w styleway[$GG, $A];
    $SS || die "NoiSSSS $A on ux or GG.name";
    my ($c, @s);
    my $san = sub {
        my $props = shift;
        join ";", map {
            ref $_ eq "HASH" && die
                "oi c.K from GG.name's $A _S !"
                ." css line got YAML-munted into a HASH !"
                ." remove the space after the colon?";
            $_
        } @$props
    };
    join"\n",map{
        $c = $_;
        if (c.css) {
            ".".c.K."{".$san->(c.css)."}"
        }
        elsif (c.keif) {
            my $keif = join "\n", map {
                _.K."{".$san->(_.css)."}"
            } @{c.keif};
            my $yep = "@"."-webkit-keyframes ".c.K."{\n"
                .ind('  ', $keif)
            ."\n}";
            $yep
        }
    } @$SS;
  stylezo: |
    # u at->attribute traslator
    # kind of an argument resolver
    # everything should be styleup'd to G.h
    # making this a G1 function we call from ux with M's W.G
    # some $style has space(s), leads through D to other style
    # speaking of style
    # which is what these capital letter concepts as individuals speak
    # which is our language held nicely
    my $GG = $G; # having said G1 etc we shove it all into G(ux) for now
    my $apply;
    $apply = sub {
        my $style = shift;
        return if $style !~ /./;
        return map { $apply->($_) } split ' ', $style if $style =~ / /;
        
        my $S = GG.h->{$style};
        # lingosa
        S.css ? do{ 
            u.at.attr.class .= " $style";
        }:
        S.D ? do{
            my $ysty = $G->w("D", $ar, $S); # ux or whatever models joints here
            $apply->($ysty) if $ysty;
        }:
        do{ 
            sayre "wtf '$style'" unless $style =~ /^(yi|te)$/;
        };
    };
    $apply->($styles);
  u_S: # styles for wormhole liney primitives
    - K: yi
      css: 
        - margin-left:0.5em
        - color:#fca
        - font-size:66%
    - K: yo
      css: 
        - color:#a3f
        - font-size:80%
    - K: yt
      css: 
        - font-size:120%
    - K: yw
      css: 
        - " margin-left:0.5em "
    - K: te
      css: 
        - border-bottom:1px solid black
        - padding-left:2em
        - float:left
        - position:relative
        - width:calc(100% - 2em)
        - background:rgba(150,100,50,0.1)
  x_S: # special effects
    - K: 20pt
      css: 
        - font-size:20pt;
    - K: abs
      css: 
        - position:absolute
    - K: antrail
      css: 
        - border-left:8px solid rgba(35,80,170,0.7);
    - K: bg018
      css: 
        - background:rgba(0,25,200)
    - K: fulw
      css: 
        - height:100%
        - float:left
        - position:absolute
    - K: h1
      css: 
        - font-size:170%
        - color:#77f
    - K: h2
      css: 
        - font-size:200%
        - color:#55f
        - font-weight:5
    - K: hugeblurbackname
      css: 
        - color:rgba(255,255,255,0.5)
    - K: little
      css: 
        - font-size:60%
    - K: contrim
      D: |
        'z94' if length u.at.conty > 10
    - K: pre
      css: 
        - overflow-wrap:break-word
    - K: red
      css: 
        - " color:red "
    - K: rel
      css: 
        - position:relative
    - K: shlink
      css: 
        - " -webkit-transform:rotate(45deg) scale(1,0.5); "
    - K: skinny
      css: 
        - margin:0.2em
    - K: tinyer
      css: 
        - -webkit-transform:scale(0.7,0.5)
    - K: topleft
      css: 
        - position:absolute
        - top:-5px
        - left:-5px
    - K: wanderleft3em
      css: 
        - left:0em
    - K: white
      css: 
        - color:white
    - K: z4
      css: 
        - font-size:44.44%;
    - K: z94
      css: 
        - font-size:144.44%
  event: |
    my $u = L.i; # the clicked id: uy probly.
    my $ux = uxL.i; # first parent <ux>
    my $uu = ux.B.Lu.i;
    my $uy = $u if $u ne $ux;
    my $E = {
        e => $e,
        W => $W,
        L => uu.Li,
        u => $uu,
        ux => $ux,
        uy => $uy,
    };
    
    # come from within something we don't grasp
    return H.G->w('serve/TV', {e=>E.e}) unless E.L;
    
    # TODO make a pattern about y=to match against Eways...
    E.L.G->w(event => $E);
  U: |
    0->visTp($ar, "Fun") if ar.i;
    my $u = T.i;
    
    w utricks/spawn[$u];
    w sane/U1[$u];
    
        w U(i=>$_) for reverse @{T.L.o};

    w compile_figure[$u];
    w wayout_sendo[$u];
  J: |
    0->visTp($ar, "Fun") if ar.i;
    my $u = T.i;
    
    for my $do (@{u.sendo || []}) {
        $do->();
    }

        w J(i=>$_) for @{T.L.o};
  compile_figure: |
        my $j = sub { join " ", grep { defined } @_ };
        my $ui = u.B.Lu.i if u.B.Lu;
        my $at = u.at = {};
        
        my $wi = ui.G->findway(ui.K) if ui.Gw;
        # 
        my $tryf = sub {         # prefer S thing_Ds
            my ($w, $ac, $pa, $wa) = @_;
            my $f = $w->{$ac}; # poss. from fragment
            return unless $f;
            my $way = $wa || $w; # call non fragment
            my $some = way.G->w("$ac/$pa"."_D", {}, $way) if $f->{"$pa"."_D"};
            #die sw([$w, $ac, $f, $f->{$pa}, $pa, $some]) if $wa && $pa =~ /ishtml/;
            return $some if $some;
            $f->{$pa} if $f->{$pa};
        };
        my $Gww = sub {           # prefer Gw S things
            my ($w, @a) = @_;
            my $Gw = w.G->findway(w.K) if w.Gw;
            $Gw = $tryf->($Gw, @a, $w) if $Gw;
            $Gw || $tryf->($w, @a);
        };
        my $ui_or_u = sub {     # prefer ui S things
            $Gww->($ui, @_) || $Gww->($u, @_)
        };
        
        # ^ the look-around-for-style-etc vortex v
        
        at.id = $ui_or_u->(S => 'id') || u.Li.uuid;
        
        at.tag = $ui_or_u->(S => 'tag') || u.K;
        
        at.ishtml = $ui_or_u->(S => 'ishtml');
        
        at.class = $ui_or_u->(S => 'class');
        
        my @styles;
        push @styles, " y".u.K if u.O ne 'ux';
        at.tag ||= "y".u.K if u.O ne 'ux';
        push @styles, u.styles, u.S.styles;
        push @styles, ui.styles, ui.S.styles if $ui;
        
        at.styles = $j->(@styles);
        
        
        at.tag ||= u.K;
        die "no tag" .sw($u) if !at.tag;
        
        at.conty = $ui_or_u->(S => 'content');
        
        at.conty = "" if !defined at.conty;
        at.conty = encode_entities(at.conty) unless at.ishtml;
        
        at.ooze = [sort { a.conor <=> b.conor } @{u.Li.o || []}];
  wayout_sendo: |
        my $at = u.at;
        my $ui = u.B.Lu.i if u.K eq "ux";
        my $sendo = u.sendo = [];
        my $_t = u._at;
        
            my $conty = defined at.conty ? at.conty : "";
            my @oozs = grep { defined } map { _.html } @{ at.ooze };
            my $content = join "\n", @oozs;
        
        
        my $attr = at.attr = {
            id => at.id,
            class => at.class,
            %{ u.attrs || {} },
        };
        my $styles = at.styles;
        
        w stylezo[$u, $ui, $styles];
            
        if (!$_t) {
            #w sendnew[$u, $ui, $attr, $at, $conty, $content];
            if ( $conty && $content ){
                warn "conty and ooze ".sw(["contooz", $u, $conty, $content]);
                $conty = "";
            }

            if (length($conty.$content) > 25000) {
                $content = "";
                push @$sendo, sub {
                    $H->JS("\$('#at.id').append('$_');") for @oozs
                };
            }
            push @$sendo, sub { w $u S/sendo_init_D(e=>'') } if u.S.sendo_init_D;
            
            #die "Sendno" if u.sendo_init_D;
            push @$sendo, sub { G.O.V.ux->takeover(u.html) } if $u eq G.uW; # chain
        }
        else {
            #w sendnew[$u, $ui, $attr, $at, $conty, $content];
            my $ino = sub { my ($u, $in) = @_; grep { $_ eq $u } @$in; };
            my $sendojs = sub {
                my ($id, $sp, @int) = @_;
                push @$sendo, sub {
                    $H->JS("\$('#$id')".sprintf($sp, @int).";")
                };
            };
            
            for my $newz (grep { !$ino->($_, u._at.ooze) } @{at.ooze}) {
                $sendojs->(at.id, q{.append('%s')}, 0->jsq(newz.html));
            }
            for my $gone (grep { !$ino->($_, at.ooze) } @{u._at.ooze}) {
                $sendojs->(gone.id, q{.remove()});
            }
            if (at.conty ne _t.conty) {
                saybl "CONTIGITY" for 1..10;
                $sendojs->(at.id, q{.text('%s')}, 0->jsq(at.conty));
            }
            while (my ($k, $v) = each %{ at.attr }) {
                if ($v ne _t.attr->{$k}) {
                    saybl "@ $k -- $_t->{$k}   ++ $v";
                    $sendojs->(at.id, q{.attr('%s', '%s')}, 0->jsq($k), 0->jsq($v));
                }
            }
            # attr updates
            
        }
        my $tag = at.tag;
        my $mkat = sub {
            my $a = shift;
            my $v = $attr->{$a};
            return $a if $v eq "undef";
            return $a.'="'.$attr->{$a}.'"'
        };
        # style/class gets misccss/Wcss
        $attr = join " ", map { $mkat->($_) }
            grep { defined $attr->{$_} && $attr->{$_} ne "" } sort keys %$attr;
            
        u.html = "<$tag $attr>$conty$content</$tag>";
        
        saygr "u.html" if $tag =~ /style/;
        sayyl " Cododnny ".wdump($attr) if $ui && ui.K eq "Codon";
        
        u._at = $at;
  R: |
    my ($a, $W) = %$ar;
    ref $W eq "Wormhole" || die sw(["Weird wormhole R $a", $ar]);
    my $uW = 0->TafuB( $a => {W=>$W} );
    0->l($uW) unless $a eq "W";
    return $uW
  ux: |
    my $Ls = ar.Ls;
    $Ls ||= ar.W->CS if ar.W;
    $Ls ||= [];
    saybl @$Ls." lines -> ux from $Ls->[0]->{name}";
    
    G.uW = w R(W => G.T.W);
    0->visTp({i => G.uW});
    
    my $uxs = [];
    my $al = [];
    for my $L (@$Ls) {
        next unless keys %$L; #wtf
        if (my ($alx) = grep { _.O eq "ux" && _.G eq $G } @{L.o}) {
            push @$al, $alx;
        }
        push @$uxs,
            0->visTp_TafuBlA({L=>$L}, [ux => {Lu=>$L}])
    }
    
    for my $ux (@$uxs) {
        my $ix = w utricks/ux_above_via_Lu[$ux]; # join uxLis together like the origin
        $ix ||= w R(M => ux.B.Lu.G.T.W); # or the ux for its W
        0->visTp_l_u({i=>$ix}, $ux);
        w sane/V3[$ux, $ix, $uxs];
    }
    
    w U(i => G.uW);
    w J(i => G.uW);
    
    my $es =  "done ".$G->F_delta();
    sayre "ux -------- $es " for 1..5;
    
  sane:
    V3: |
      die "ix not Li " unless ix.Li;
      die "ux not in above ux o: ".sw({uxs=>$uxs,ix=>$ix})
          unless ix.O ne "ux" || grep { $_ eq $ux } @{ix.Li.o};
    U1: |
        my $Lu = u.B.Lu || die "no Lu".sw({" no Lu"=>$u}) if u.K eq "ux";
        die "ux has no ways out, expected SOMETHING!?".sw(u.Li)
            if u.K eq "ux" && !@{u.Li.o};
  utricks:
    spawn: | #c
        my @uys;
        my $ui = u.B.Lu.i;
        u.B.ui = $ui if $ui;
        if (ui.u_from) {
            $u->from(ui.u_from);
        }
        if (my $spawn = u.spawn) {
            for my $sp (@$spawn) {
                
                my $Bs = {};
                if (sp.Bset) {
                    while (my ($k, $v) = each %{sp.Bset}) {
                        $Bs->{$k} = $u->find("B.$v"); # i=Lu.i etc
                    }
                }
                else {
                    $Bs = u.B;
                }
                my $uy = 0->sway({K=>sp.K}, {B=>$Bs}, {e=>''});
                
                $uy->from({S=>u.S}) if delete sp.Scc;
                
                $uy->from($sp);
                
                push @uys, w utricks/multi[$uy, $u, $sp]; 
            }
        }
        
        for my $uu (@uys) {
            if (my $uy = 0->fu($uu)) {
            }
            else {
                sayyl "NEW u ! uu.K ".ki(uu.B);
                $uy = 0->T({i => $uu});
                0->l($uy);
            }
        }
    multi: | #c
      my @uys = $uy;
      if (my $n = sp.multiBy) {
            my $val = uy.B->{$n};
          ref $val eq "ARRAY" || die "was promised $n would be array, is $val ".wdump($uy);
          @uys = ();
          my $i = 0;
          for my $an (@$val) {
              next if an.K eq "ux"; # that hangs out in the origin lines o
              my $anuy = $uy->spawn;
              anuy.B->{$n} = $an;
              anuy.K ."[".$i++;
              push @uys, $anuy;
          }
      }
      @uys
    ngrab: | #c
                if (u.uy_in_dos) {
                    if (my $ton = u.uy_in_dos->{"n_uys_to_".uy.K."_n"}) {
                        uy.B->{$ton} = u.B->{u.B.n};
                        uy.B.n = $ton;
                    }
                }
                if (uy.uy_in_dos) {
                    if (my $n = uy.uy_in_dos.Lu_grab_n) {
                        uy.B->{$n} = u.B.Lu->{$n};
                        uy.B.n = $n;
                    }
                }
    ux_above_via_Lu: | #c
      my $Lu = ux.B.Lu || die "no Lu on ux";
      my $pLu = Lu.i.Lo if exists Lu.i.Lo; # up and over
      my ($pux) = findO(ux => pLu.o) if $pLu;
      $pux;

