name: Styluxyio
include: T/braid
C:            # W M ux
  - K: W # us
    O: ux
    S:
      tag: wormhole
      id_D: |
        ( W.id =~ /-(\w+)$/ )[0]
        
  - K: M
    O: ux
    S:
      tag: MMMM
     
  - K: ux
    O: ux
    S:
      tag: ux
    styles: te
    conor: 1
    print: |
       "(".pint(S.B.Lu.i)." \t".gpty(S.B.Lu.t).")"
    T_remembers_last: 1
    C_n_spawn: [i, t, o]
       
  - K: i     #c uyuyuuyuyyyuyuyuuuuyuuuuyyyuyuyyyuyuuuyuyuyyyyuyuyu
    uy_in_dos:
      Lu_grab_n: i
      n_uys_to_w_n: w
      
    C_n_spawn: [w]
    conor: -0.5
    
  - K: t
    uy_in_dos:
      Lu_grab_n: t
      
    S:
      content_D: |
        die "t content fullity" if S.B.raw || S.raw;
        my $con = gpty($t);
        $con = ($con=~/^(.{30})/s)[0]."..." if length($con) > 50;
        $con;
      
  - K: o
    uy_in_dos:
      Lu_grab_n: o
      n_uys_to_w_n: w
      n_array: 1
      
    C_n_spawn: [w]
    conor: 0.5
    
  - K: w
    S:
      content_D: |
        pint($w);
      
  - K: e
    styles: topleft white little
    S:
      content_D: |
        $e
   
   


hooks:
  event: |
    my $u = L.i;
    my $ux = uxL.i;
    my $E = {%$ar};
    E.L = ux.B.Lu;
    E.uyL = $L if $L ne $uxL;
    Say E.L.G.name;
    E.L.G->w(event => $E);
  RW: | # for making the tip, which is a hash anyway
    my $W = ar.top||ar.W;
    my $u = 0->visTp_TafuBl(
        {},
        [W => {W => $W}],
    );
    0->visTp({ i => $u }) if ar.top;
    return $u
  RM: | # a tip on the other side, so below our tip but above in space
    0->visTp_TafuBl(
        {i => G.top},
        [M => {W => $W}],
    );
  ux_above_via_Lu: |
    my $Lu = ux.B.Lu || die "no Lu on ux";
    my $pLu = Lu.i.Lo if exists Lu.i.Lo; # up and over
    my ($pux) = findO(ux => pLu.o) if $pLu;
    $pux;
  ux: |
    my $Ls = ar.Ls;
    $Ls ||= ar.W->CS if ar.W;
    $Ls ||= [];
    Say @$Ls." lines -> ux from $Ls->[0]->{name}";
    
    w atop;
    
    # in Lu.o\
    my $uxec = sub {
        grep { _.i.K eq "ux" } @{ $G->W->CS };
    };
    my $uxec_fore = $uxec->();
    my $g0ld = $G0->{db};
    $G0->{db} = 5;
    my @uxs = map { 0->visTp_TafuBl({L=>$_}, [ux => {Lu=>$_}]) } @{$Ls};
    $G0->{db} = $g0ld;
    
    my $uxec_aft = $uxec->();
    Say " ux numbers  $uxec_fore ->  $uxec_aft";
    
    
    
    
    my @tux;
    for my $ux (@uxs) {
        my $ix = w ux_above_via_Lu[$ux]; # join uxLis together like the origin
        
        $ix ||= w RM(W => ux.B.Lu.G.W); # or the ux for its W
        
        0->visTp_l_u({i=>$ix}, $ux);
        
        die "ix not Li " unless ix.Li;
        die "ux not in above ux o: ".sw({uxs=>\@uxs,ix=>$ix})
            unless ix.O ne "ux" || grep { $_ eq $ux } @{ix.Li.o};
    }
    
    # now go from/to the ux for ux's W so we can interpret events
    #which T is at already^
    w braid(Ds => 'uxalot');

    my $html = T.i.html;
    
    G.view->takeover($html);
    U->send_contents_awaiting();
    Say $html;
    Say "ux antop ".$G->F_delta()."\n\n\n";
  
  atop: |
    w RW(top => $G->W);# T encapsu is whole ux W
      
  styles:
    te: |
      q'border-bottom:1px solid black',
      qw' padding:0.4em margin-left:2em
            width:100% float:left position:relative'
    yw: |
        q' margin-left:0.5em '
    yo: |
        q' border:2px solid #fca;'
    20pt: |
      'font-size:20pt;'
    yi: |
        q' border:2px solid #ba8; margin-left:0.5em '
        
    yt: |
        q' padding:0.5em; background:rgba(200,80,130,0.5);'
    
    shlink: |
        q" -webkit-transform:rotate(45deg) scale(1,0.5); ";
        
    rel: |
      qw'position:relative'
    abs: |
      qw'position:absolute'
    topleft: |
      qw'position:absolute top:-5px left:-5px'
    white: |
      qw'color:white'
    little: |
      qw'font-size:60%'
    fulw: |
      qw {height:100% float:left position:absolute},
  any_init: |
    
    G.U.jgd = sub { join " ", grep { defined } @_ };
    G.U.firstdef = sub { (grep { defined } @_)[0] };
    G.U.send_contents_awaiting = sub {
        my $awa = G.contents_awaiting ||= [];
        G.fuckery = 0;
        for my $ait (reverse @$awa) {
            my $u = ait.u;
            my $sel = ait.sel;
            my @htmls = U->contor(@{u.at.contents});
            #die wdump([$u,\@htmls]);
            for my $html (@htmls) {
                #next if G.fuckery++ > 7;
                $H->JS("\$('$sel').append('$html');");
            }
        }
        G.contents_awaiting = [];
    };
    G.U.contor = sub {
        grep { defined }
        map { _.html || _.content } @_
    };
  recoded_init: |
    H.G->w('re/exec');
  uytricks:
    multi: | #c
      my @uys = $uy;
                if (u.uy_in_dos) {
                    if (u.uy_in_dos.n_array) {
                        my $n = uy.B.n;
                        my $val = uy.B->{$n};
                        ref $val eq "ARRAY" || die "was promised $n would be array, is $val ".wdump($uy);
                        
                        @uys = ();
                        my $i = 0;
                        for my $an (@$val) {
                            next if an.K eq "ux"; # that hangs out in the origin lines o
                            my $anuy = $uy->spawn;
                            anuy.B->{$n} = $an;
                            anuy.K = uy.K."[".$i++;
                            push @uys, $anuy;
                        }
                    }
                }
      @uys
    ngrab: | #c
                if (u.uy_in_dos) {
                    if (my $ton = u.uy_in_dos->{"n_uys_to_".uy.K."_n"}) {
                        uy.B->{$ton} = u.B->{u.B.n};
                        uy.B.n = $ton;
                    }
                }
                if (uy.uy_in_dos) {
                    if (my $n = uy.uy_in_dos.Lu_grab_n) {
                        uy.B->{$n} = u.B.Lu->{$n};
                        uy.B.n = $n;
                    }
                }
  uxalot:
    0.1: | #c
      my $u = T.i;
        my $Lu = u.B.Lu || die "no Lu" if u.K eq "ux";
        
        if (my $uyKs = u.C_n_spawn) {
            for my $uy (map { 0->sway({K=>$_}) } @$uyKs) {
                uy.B ||= {};
                
                w uytricks/ngrab[$uy, $u];
                
                my @uys = w uytricks/multi[$uy, $u];
                
                for my $uye (@uys) {
                
                    0->Taful($uye);
                }
            }
        }
        
        
        die "0.1: ux has no ways out, expected SOMETHING!?".sw(u.Li)
        
            if u.K eq "ux" && !@{u.Li.o};
    0.5: | #c
      for my $i (@{T.L.o}) {
          next if $i==T.i;
          w anTop[$i];
      }
    0.6: | #c
      my $u = T.i;
        
        my $Lu = u.B.Lu || die "no Lu".sw({" no Lu"=>$u}) if u.K eq "ux";
        die "ux has no ways out, expected SOMETHING!?".wdump(u.Li)
        
            if u.K eq "ux" && !@{u.Li.o};
        
        my $at; # heres some state
        
        at.id = w $u S/id_D[$at];
        at.id ||= u.Li.uuid;
        
        at.styles = U->jgd(u.styles); # coalescing/merging
        at.tag ||= U->firstdef(u.B.tag, u.S.tag); # overriding
        
        unless (u.O eq 'ex') {
            my $n = u.B.n;
            at.tag ||= "y$n";
            at.content = w $u S/content_D;
            
            at.styles = U->jgd(at.styles, "y$n", u.B.styles);
        }
        at.tag ||= u.K;
        
        die "no tag" .sw($u) if !at.tag;
        
        u.E_at = u.at;
        u.at = $at;
        my $tag = sub {
            my $content = shift || '';
            my $attr = { %{u.at} };
            attr.style = $G->styles(delete attr.styles); # or so
            attr.style .= "position:relative;"
            unless attr.style =~ /position[^\w]+absolute/;
            my $tag = delete attr.tag;
            my $conty = delete attr.content if exists attr.content;
            $conty = "" if!defined $conty;
            delete attr.contents;
            attr.title = $G->W->{id}."/ u.B.W.name";
            
            $attr = join " ", map {
                $_.'="'.$attr->{$_}.'"' } sort keys %$attr;
            "<$tag $attr>$conty$content</$tag>";
        };
        
        my @content = @{u.Li.o || []};
        
        
        @content = sort { (a.conor || a.B.conor) <=> (b.conor || b.B.conor) } @content;
        
        at.contents = [@content];
                
        my $content_max = 2000;
        my $content =
            (defined u.content ? u.content : "")
            .join "\n", U->contor(@content);
        
        if (length($content) > $content_max) {
            $content = "";
            @content = ();
            # via travel add: #$uxid > #$id # in case of mid-y splits...
            my $id = u.at.id;
            my $uxid = G.last_ux.at.id if G.last_ux;
            my $sel = "#$id";
            $sel = "ux#$uxid > $sel" if $uxid && $uxid ne $id;
            push @{G.contents_awaiting||=[]}, {
                sel => $sel,
                u => $u,
            };
        }
            
        #die wdump(3,[u.at, $content]) if u.K eq "ux";
        $content = "\n".ind("  ", $content)."\n" if @content;
        
        u.html = $tag->($content);
 

