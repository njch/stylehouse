name: Styluxyio
dials:
  max_depth: 7
  form: 42
chains:

hooks:
  ways:
    ux:
      K: ux
      O: ux
      print: |
        "(".pint(S.Lu.i)." \t".gpty(S.Lu.t).")"
    uy:
      K: uy
      O: uy
      print: |
        "(".join(",  ", map { "$_ = ".pty(S.B->{$_}) } keys %{S.B}).")"
          
  event: |
    my $ux = L.i;
    $Ly->w(somewhere => {thing => $ux});
  any_init: |
    $U ||= {};
    U.mku = sub { # make this use Ghost::L for uL, move these codes to G:subs?
        my ($way, $B) = @_; 
        confess "B B".wdump([@_]) if B.B;
        say "L ".pint(G.L.i);
        say "mku $way   ".join ",  ", map { "$_ = ".pty($B->{$_}) } keys %$B;
        my $w = $G->nw()->from(
              $G->findway('ways/'.$way)        )->from({B=>$B});
        w.Lu = w.B.Lu if w.B.Lu;
        die "makedad".wdump($B) if w.Lu && w.O ne "ux";
        $w
    };
    U.accum = sub {
        my ($a, $t) = @_;
        if (!grep { $_ eq $t } @$a) {
            push @$a, $t
        }
    };
    U.findu = sub {
        my $u = shift;
        my $L;
        for my $LL (@{$G->W->{script}}) {
            my $i = LL.i;
            if ($i eq $u) {
                $L = i.Lo;
                last;
            }
            elsif (u.B) {
                my $f = 0;
                for my $k (keys %{u.B}) {
                    $f = 1 unless u.B->{$k} eq i.B->{$k}
                }
                $L = $LL unless $f;
            }
        }
        $L ? L.i : $u;
    };

    U.ul = sub { # look for u way
        my $z = {@_};
        my $u = z.u;
        $u = U.findu->(z.u)                  unless u.Li;
        $G->T("anu: ".pint($u), undef, $u)    unless u.Li;
        die "no Li after T"                   unless u.Li;
        die "Aft". wdump($u) if !u.O;
        if (z.p){
            if (u.O eq "ux") {
                U.accum->(z.p.o => $u);
                u.Lo = z.p
            }
            elsif (u.O eq "uy") {
                U.accum->(z.p.o => $u);
                U.accum->((u.Loose||=[]), z.p); # .B.Lo many
            }
            else {
            }
        }
        $u
    };

    U.o_uxs = sub {
        my $L = shift || G.L || die "no L";
        findO(ux => L.o);
    };
    U.uL_o_Lu_find = sub {
        my $t = shift;
        grep { $t eq _.Lu } U.o_uxs->();
    };
    
    U.cu_Lu = sub {
        my $w = shift;
        w.Li && U.uL_o_Lu_find->(w.Li)
    };
    U.Luyon = sub {
        my $n = shift;
        grep { _.O eq "uy" && exists _.B->{$n} } U.o_uxs->();
    };

    U.uys = sub {
        my ($n, $y, @etc) = @_;
        return if U.Luyon->($n); # uy there

        my $u = U.ul->( 
            u => U.mku->(uy => {$n=>$y,@etc}),
            p => G.L,
        );
        die "shunno".pty(G.L)." not have ".pint($u)
            unless 1 || grep { $_ eq $u } @{G.L.o};
        $u;
    };
    U.fign = sub {
        my $t = shift;
        my @n = grep { /^(a|i|t|o|m|te|w)$/ } keys %{t.B};
        die join "\n",wdump(2, $t)," has n =",@n if @n != 1;
        shift @n;
    };
    U.antop = sub {#c
        my $u = G.L.i;
        my $uL = G.L;
        die "ul is :".wdump(2,$uL)unless uL.i.K =~ /^u[xy]$/; 
        
        U.ugstop->();
        
        my $back = G.L;
        for my $uo (@{uL.o}) {
            G.L = uo.Li;
            ref $uo eq "Way" && uo.Li
                && uo.Li.i && uo.Li.i.K =~ /^u[xy]$/ && uo.Li.i eq $uo
                
                || die "nahrre";
            U.antop->();
        }
        G.L = $back;
        
        U.ugto->();
    };
    
    U.ugstop = sub {#c
        my $u = G.L.i;
        my $uL = G.L;
         # B into style
         
        # spawn guts
        
        # ways can compress/Loose
                    
        die wdump(2,$uL) unless u.O =~ /^u[xy]$/;
        if (u.O eq "ux") {
            
            my $Lu = u.Lu || die;
            for my $n (qw'a i t o m') {
                next unless "it" =~ $n;
                my $y = $Lu->{$n};
                
                my $styles = 'rel';
                if ($n eq "o" && ref $y eq "ARRAY") {
                    for my $o (@$y) {
                        next if o.O eq "ux";
                        next if U.cu_Lu->($o);
                        U.uys->($n, $o, styles=>$styles);
                    }
                }
                else {
                    U.uys->($n, $y, styles=>$styles);
                }
            }
        }
        elsif (u.O eq "uy") {
            my $n = U.fign($u);
            U.uys->(te => "$n", styles => 'topleft white little')
                unless $n eq "te";
            if ($n eq "i" || $n eq "o") {
                my $o = U.uys->(w => u.B->{$n}, styles => 'rel');
            }
        }
        else {
            die "topmost... uL=". wdump(2, $u);
        }
    };
    
    U.ugto = sub {
        my $u = G.L.i;
        my $uL = G.L;
        my $at = {id=>uL.uuid};
        if (u.Lu && !%{u.Lu}) {
            #die "empty Lu on ".pint($u)."\n".wdump($u);
            delete u.Lu ;
        }
        die wdump(2, $u) if u.K eq 'uy' && u.Lu || u.K eq 'ux' && !u.Lu;
        
        my @html;
        
        say "u: ".pint($u);
        if (u.K eq "ux") {
            die "ux has no ways out" unless @{uL.o};
            at.styles = 'te';
            at.tag = "ux";
        }
        elsif (u.K eq "uy") {
            my $n = U.fign->($u);
            my $pn = U.fign->(u.Lo.i) if exists u.Lo && exists u.Lo.i;
            (at.tag) = "y$n";
            at.styles = "y$n";
            at.styles = "u.B.styles at.styles" if u.B.styles;
            
            
            if ($n eq "w" && (!$pn || $pn ne "o"
                || !grep { $_ eq u.B.w } findO(ux=>uL.o))) {
                # if o, only not ux below
                push @html, pint(u.B.w);
            }
            push @html, gpty(u.B.t) if $n eq "t";
            push @html, u.B.te if $n eq "te";
        }
        unshift @html, '<'.at.tag.' id="'.at.id.'" style="'.$G->styles(at.styles).'">';
        
        my $s = {};
        for my $uu (@{uL.o}) {
            U.accum->(($s->{uu.O}||=[]), $uu);
        }
        my @ou;
        push @ou, _.html for @{s.uy};
        push @ou, _.html for @{s.ux};
        my $oh = join "\n", grep { defined } @ou;
        if ($oh) {
            push @html, ind('  ',$oh)
        }
        
        push @html, "</at.tag>";
        u.html = join "\n", @html;

    };
  ux: |
    Say @$Ls." lines -> ux from $Ls->[0]->{name}";
    
    my @uxs;
    for my $Lu (@{$Ls}) { say "install ux outways to Lu";
        push @uxs, U.ul->(
            u => U.mku->(ux => {Lu=>$Lu}),
            p => $Lu,
        );
    }
    my @tux;
    for my $ux (@uxs) {   #say "join uL lines together like the origin (ux.Lu.i.K - ux.Lu.t)";
        G.L = ux.Li;
        my $Lu = ux.Lu || die;
        my $pLu = Lu.i.Lo if exists Lu.i.Lo; # up and over
        my ($pux) = findO(ux => pLu.o) if $pLu;
        unless ($pux) {
            push @tux, $ux;
        }
        else {
            say "joining ".pint($ux).' to '.pint($pux);
            U.ul->(
                u => $ux,
                p => pux.Li,
            );
            say "put ".pint($ux)." onto ".pint($pux)."\n\n";
            die unless grep { $_ eq $ux } @{pux.Li.o};
        }
    }
    
    
        for my $ux (@tux) {
            G.L = ux.Li || die "no ux Li";
            U.antop->();
        }
    my @eh;
    for my $ux (@tux) {
        push @eh, ux.html;
    }
    
    my $W = $G->W;
    my ($id) = W.id =~ /-(\w+)$/;
    
    my $html = join "\n", '<wormhole style="font-size:70%;position:relative;"id="'.$id.'">', @eh, '</wormhole>';
    
    say "ux antop ".$G->F_delta()."\n\n\n";
    return $html;
    
  styles:
    te: |
      q'border-bottom:1px solid black',
      qw' padding:0.4em margin-left:2em
            width:100% float:left position:relative'
    yw: |
        q' margin-left:0.5em '
    yo: |
        q' position:absolute; left:30em; border:2px solid #fca;'
        
    yi: |
        q' border:2px solid #ba8; margin-left:0.5em '
        
    yt: |
        q' padding:0.5em; background:rgba(200,80,130,0.5);'
        
    rel: |
      qw'position:relative'
    topleft: |
      qw'position:absolute top:-5px left:-5px'
    white: |
      qw'color:white'
    little: |
      qw'font-size:60%'
    fulw: |
      qw {height:100% float:left position:absolute},
  x_to_h: |
    my $x = L.i.B.x;
    my $h = L.i.B.h = {};
    my $attr = {};
    my @style = ();
    my @class = ();
    attr.id = x.id          if exists x.id;
    attr.title = x.title if exists x.title;
    
        for my $a (qw{height width left top}) {
            if (exists $x->{$a}) {
                my $v = $x->{$a};
                $v = ($v * 100).'%' if $v !~ /em$/;
                push @style, "$a:$v"; 
            }
        }
        if (exists x.height && x.height =~ /em$/ && x.width == 1) {
            push @style, "float:left";
        }
        if (exists x.left || exists x.top) {
            push @style, "position:absolute";
        }
        if (x.class) {
            push @class, @{x.class};
        }
        if (x.style) {
            for my $styley (@{x.style}) {
                my $styles = [ flatline($styley) ];
                push @style, @$styles;
            }
        }
         
        my $tag = x.tag || "uh";
        if (!defined L.i.B.Lo) {
            $tag = "wormhole";
            my $W = $G->W;
            attr.title = G.name;
            (attr.id) = W.id =~ /-(\w+)$/;
        }
        
        attr.style = join "; ", @style if @style;
        attr.class = join " ", @class if @class;
        
        h.attr = $attr;
        h.tag = $tag;
        h.children = L.o;
        h.content = sub {
            return x.content if x.content;
            return join "", grep {defined}
                map { _.B.h.ash->() }
                grep { _.B && _.B.h } @{h.children}
        };
        h.ash = sub {
            "<h.tag ".join(" ", map {"$_=\"h.attr->{$_}\""} sort keys %h.attr).">"
            ."\n".ind("  ", h.content->())."\n"."</h.tag>\n"
        };
    
    
    
    
    # etc
    
        
    
  next_phase: |
      for my $L (@{G.Torail}) {
            w style_to_x[$L];
      }
      for my $L (@{G.Torail}) {
            w x_to_h[$L];
      }
      return L.i.B.h.ash->();
      
  style_to_x: |
    my $x = L.i.B.x = {};
    my $yL = L.t;
    my $got = {
    l => [ grep { !_.B.Li } @{yL.o} ],
    t => [ grep { _.B.Li } @{yL.o} ],
    i => [ yL.i ],
    };
    my $hg = sub {
        my ($what, $order) = @_;
        my @R;
        for my $yg (split '', $order) {
            for my $w (@{$got->{$yg}}) {
                if (w.B && w.B.s) {
                    if (exists w.B.s->{$what}) {
                        push @R, w.B.s->{$what}
                    }
                    if (exists w.B.s->{$what."_D"}) {
                        push @R, $G->w("B/s/".$what."_D", {}, $w)
                    }
                }
            }
        }
        @R
    };
    
    
    my @content = $hg->(content => 'li');
    @content > 1             && die "cont > 1";
    @content && @{got.t}     && die "cont & t";
    ($x->{content}) = @content if @content;
    
    $x->{class} = [ flatline($hg->(class => 'il')) ];
    $x->{style} = [ flatline($hg->(style => 'il')) ];
    ($x->{tag}) = grep {defined} flatline($hg->(tag => 'li')), "te";
    $x->{style} = [ flatline($hg->(style => 'il')) ];
    $x->{id} = L.uuid;
    $x->{title} = "yL.n yL.depth ".pint(yL.t.i) if ref yL.t eq 'HASH';
    
    my @div = $hg->(div => 'li');
    @div > 1                 && die "div > 1";
    if (@div) {
        my ($v) = @div;
        my $vi = {};
        ($vi->{width},$vi->{height}) = split "x", $v; $v =~/^x/&&die"?";
        while (my ($iv, $parts) = each %$vi) {
            if (!$parts) {
                next;
            }
            my $inc;
            if ($parts =~ /em$/) {
                $inc = $parts;
                $parts = 1;
            }
            $parts = 0+@{ L.o }    if $parts eq "...";
            $parts = 1    if $parts == 0;
            $inc ||= sprintf("%.3f", 1 / $parts);
            my $side = $iv eq "width" ? "left" : "top";
            my $i = 0;
            
            for my $w (@{ L.o }) {
                die "lower w.B.x not yet" unless w.B.x;
                my $ox = w.B.x;
                if ($parts == 1) {
                    $ox->{$iv} = $inc;
                }
                else {
                    $ox->{$side} = $i;
                    $i += $inc;
                    $ox->{$iv} = $inc;
                }
            }
        }
    }
    
    

