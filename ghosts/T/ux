name: Styluxyio

C:            # W M ux ...
  - K: W # us
    O: ux
    flows_D: |
      w stylespawn[$S, $W];
    Ss: [u, x, X]
    S:
      styles: OxO nopoi
      tag: ww 
      id_D: |
        ( W.id =~ /-(\w+)$/ )[0]
  
  - K: uW
    O: ux
    
  - K: M
    O: ux
    flows_D: |
      w stylespawn[$S, $W];
    Ss: *
    S:
      styles: OxO poi
      tag: MMMM
        
  - K: style
    conor: -1.5
    ishtml: 1
    S:
      attr:
        scoped: undef
        type: text/css
      content_D: |
        my $GG = S.Lo.i.B.W.G; # G from M or W # Lui.B.W might work
        my $sheet = w stylesheet[$GG, $K];
        # may need to careful order new appendages too?
        $sheet ? "\n$sheet\n" : "";
     
  - K: ux
    O: ux
    flows_D: |
      Lu.i.v->{$G} = $S;
    spawn:
      - K: i
      - K: t
      - K: o
    S:
      tag: ux
    styles: te
    conor: 1
    print: |
       "(".pint(S.B.Lu.i)." \t".gpty(S.B.Lu.t).")"
       
  - K: i     #c uyuyuuyuyyyuyuyuuuuyuuuuyyyuyuyyyuyuuuyuyuyyyyuyuyu
    tag: yi
    conor: -0.5
    styles: yi
    spawn:
      - K: w
        Bset:
          w: Lu.i
        Scc: 1
    
  - K: t
    tag: yt
    styles: yt
    S:
      content_D: |
        slim(50,30,gpty(Lu.t));
      
  - K: o
    tag: yo
    conor: 0.5
    styles: yo
    spawn:
      - K: w
        multiBy: w
        Scc: 1
        Bset:
          w: Lu.o
    
  - K: w
    tag: yw
    styles: yw
    S:
      content_D: |
        pint($w);
      ishtml: 1
      
  - K: e
    styles: topleft white little
    flows_D: |
      B.e ||= "Lu.i.K";
    S:
      content_D: |
        $e
  
  - K: somewhere #c
    styles: te
    S:
      sendo_init_D: |
        return;
        $H->JS("\$('#somewhere').appendTo('#S.at.id');");
        my $css = 'pointer-events:none; -webkit-filter: brightness(1.2) saturate(3) drop-shadow(10px 0px 30px black); width:60em;';
        $H->JS("\$('#somewhere').attr('style', '$css');");
    S:
      content_D
  - K: h1 #c
    styles: h1
  - K: h2 
  - K: pre
    styles: skinny pre
  - K: script
    S:
      no_implied_attr: 1
  - K: X
    styles: X
S:
 - K: u #c  u for wormhole liney primitives
   Ss:
    - K: yi
      css: 
        - margin-left:0.5em
        - color:#fca
        - font-size:66%
    - K: yo
      css: 
        - color:#a3f
        - font-size:80%
    - K: yt
      css: 
        - font-size:120%
    - K: yw
      css: 
        - " margin-left:0.5em "
    - K: te
      css: 
        - border-bottom:1px solid black
        - padding-left:2em
        - float:left
        - position:relative
        - width:calc(100% - 2em)
        - background:rgba(150,100,50,0.1)
 - K: X #c  very special effects
   Ss:
    - K: Helium
      css: [ color:white ]
    - K: nopoi
      css: [pointer-events:none]
    - K: poi
      css: [pointer-events:all]
    - K: OxO
      styles: ab
      css: [height:100%, width:100%]
    - K: ab
      css: [position:absolute]
 - K: x #c  special effects
   Ss:
    - K: 20pt
      css: 
        - font-size:20pt;
    - K: antrail
      css: 
        - border-left:8px solid rgba(35,80,170,0.7);
    - K: bg018
      css: 
        - background:rgba(0,25,200)
    - K: fulw
      css: 
        - height:100%
        - float:left
        - position:absolute
    - K: h1
      css: 
        - font-size:170%
        - color:#77f
    - K: h2
      css: 
        - font-size:200%
        - color:#55f
        - font-weight:5
    - K: hugeblurbackname
      css: 
        - color:rgba(255,255,255,0.5)
    - K: little
      css: 
        - font-size:60%
    - K: contrim
      D: |
        'z94' if length u.at.conty > 10
    - K: pre
      css: 
        - overflow-wrap:break-word
    - K: red
      css: 
        - " color:red "
    - K: rel
      css: 
        - position:relative
    - K: X
      css:
        - position:relative
        - width:100%
        - height:100%
    - K: shlink
      css: 
        - " -webkit-transform:rotate(45deg) scale(1,0.5); "
    - K: skinny
      css: 
        - margin:0.2em
    - K: tinyer
      css: 
        - -webkit-transform:scale(0.7,0.5)
    - K: topleft
      css: 
        - position:absolute
        - top:-5px
        - left:-5px
    - K: wanderleft3em
      css: 
        - left:0em
    - K: white
      css: 
        - color:white
    - K: z4
      css: 
        - font-size:44.44%;
    - K: z94
      css: 
        - font-size:144.44%
 
hooks:
  any_init: |
    #G.h = {};
    #map { w styleup(GG => _.G); } 0->scGre({K,'M'})
    G.U.uiuS = sub {
        my ($u, $b) = @_;
        my $a = "S";
        my $ui = u.B.Lu.i if u.B.Lu; # even if below thingy?
        
        for my $w ($ui, $u) {
            next if !$w;
            
            my $Gw = w.G->findway(w.K) if w.Gw;
            
            for my $ww ($Gw, $w) {
                next if !$ww;
                next if !$ww->{$a};
                if ($ww->{$a}->{"${b}_D"}) {
                    $G->Flab("got a $a $b _D  ", $u);
                    my $some = w.G->w("$a/${b}_D", {u=>$u}, $w);
                    return $some if $some;
                }
                my $some = $ww->{$a}->{$b};
                return $some if $some;
            }
        }
    };
  recoded_init: |
      G.O->w(uxd=>{});

  stylespawn: |
    my $GG = W.G;
    my $SsKs = S.Ss ||= [];
    if ($SsKs eq "*") {
        my $eS = $GG->anyway('S');
        $SsKs = [ map { _.K } @$eS ];
    }
    for my $K (@$SsKs) {
        push @{S.spawn||=[]}, {
            K => 'style',
            B => {K=>$K},
        };
        w styleup[$GG, $K];
    }
  styleup: |
    my $SS = w styleway[$GG, $K];
    $SS || die sw(["style $K not found", $K, $SS, $GG]);
    0->wayray(SS.Ss);
    
    my @SSSs = @{SS.Ss};
    for my $S (@SSSs) { # mix the stylebits together
        if (S.spawns) {
            for my $w (w $S spawns) {
                w._spawns = delete w.spawns;
                push @{SS.Ss}, $w unless grep { _.K eq w.K } @{SS.Ss};
            }
        }
    }
    for my $S (@{SS.Ss}) { # mix the stylebits together
        G.h->{S.K} = $S;
    }
  styleway: |
    for my $tryG ($GG, $G) {
        
        my $SS = $tryG->_0("0->CsK", {s=>'S', K=>$K});
        return $SS if $SS;
    }
  stylesheet: |
    $K ||= "S";
    my $SS = w styleway[$GG, $K];
    $SS || die "NoiSSSS $K on ux or GG.name";
    my $Ss = SS.Ss;
    my ($c, @s);
    my $san = sub {
        my $props = shift;
        join ";", map {
            ref $_ eq "HASH" && die
                "oi c.K from GG.name's $K _S !"
                ." css line got YAML-munted into a HASH !"
                ." remove the space after the colon?";
            $_
        } @$props
    };
    join "\n", grep {defined}
    map{
        $c = $_;
        if (c.css) {
            ".".c.K."{".$san->(c.css)."}"
        }
        elsif (c.keif) {
            my $keif = join "\n", map {
                _.K."{".$san->(_.css)."}"
            } @{c.keif};
            my $yep = "@"."-webkit-keyframes ".c.K."{\n"
                .ind('  ', $keif)
            ."\n}";
            $yep
        }
    } @{SS.Ss};
    
  stylezo: |
    # u at->attribute traslator
    # kind of an argument resolver
    # everything should be styleup'd to G.h
    # making this a G1 function we call from ux with M's W.G
    # some $style has space(s), leads through D to other style
    # speaking of style
    # which is what these capital letter concepts as individuals speak
    # which is our language held nicely
    my $GG = $G; # having said G1 etc we shove it all into G(ux) for now
    my $apply;
    my @deply;
    $apply = sub {
        my $style = shift;
        return if $style !~ /./;
        return map { $apply->($_) } split ' ', $style if $style =~ / /;
        
        my $S = GG.h->{$style};
        if (!$S) {
            return push @deply, $1 if $style =~ /^-(.+)$/;
            my $DS = GG.h->{$1."_n"} if $style =~ /^(\w+)(\d+)$/;
            if ($DS) {
                DS.D || die sw["D found style not have D", $DS];
                $G->w(D => {%$ar, n => $2}, $DS);
            }
            else {
                 warn "no ifndo $style";
            }
        }
        else {
            # lingosa
            if (S.styles) {
                $apply->(S.styles);
            }
            S.css ? do{ 
                at.attr.class .= " $style";
            }:
            S.D ? do{
                my $ysty = $G->w("D", $ar, $S); # ux or whatever models joints here
                $apply->($ysty) if $ysty;
            }:
            do {
                sayre "wtf '$style'" unless $style =~ /^(yi|te)$/;
            };
        }
    };
    $apply->($styles);
    for my $d (@deply) {
        at.attr.class =~ s/$d//;
    }
    at.attr.class =~ s/^\s+|\s+$|\s\s+//sg;
    
    if (u.K eq "W") { # class to style="" outside <style> scope 
        for my $style (split ' ', u.at.attr.class) {
            my $S = GG.h->{$style};
            for my $css (@{S.css}) {
                my ($k, $v) = split ":", $css;
                at.Z->{$k} ||= $v;
            }
        }
        delete at.attr.class;
    }
    
    
  ux: |
    my $Ls = ar.Ls;
    die "no W to ux G.K" if ar.W;
    $Ls = [ map { _.Li || die "noLi" } ar.i || @{ar.is||[]} ] if ar.i || ar.is;
    #saybl @$Ls." lines -> ux G.K from $Ls->[0]->{name}";
    
    inter({G_K=>G.K});
    G.uW = w R(W => G.W);
    0->visTp({i => G.uW});
    
    G.ssp=[];
    my $uxs = [];
    
    w sane/Ls[$Ls];
    my $Wis = w sane/getW[$Ls];
    for my $L (@$Ls) {
        next unless keys %$L; #wtf
        my $y = 'ux';
        $y = 'uW' if L.i.K eq "W";
        
        push @$uxs, 0->visTp_TafuBlA({L=>$L}, [$y => {Lu=>$L}]);
    }
    for my $ux (@$uxs) {
        if (my $ui = ux.B.Lu.i) {
            ux.B.ui = $ui; #set up
            die "non Way way in" if ref $ui ne "Way";
        }
    }
    
    
    my $uM;
    my ($ux1) = @$uxs if @$uxs == 1;
    if ($ux1 && ux1.K eq 'uW') {
        my $ui = ux1.B.Lu.i;
        sayyl "G.name uxd a uW - ux1.K from ui.K ui.G.name";
        $uM = G.uW;
    }
    else {
        $Wis || die sw["wtf no Gux Waaa?",$Ls];
        $uM = w R(M => $Wis); # the lines' W mirrored
    }
    
    for my $ux (@$uxs) {
        # ux nests under another ux like origin : tops in M.o
        my $ix = w utricks/ux_above_via_Lu[$ux] || $uM;
        0->visTp_l_u({i=>$ix}, $ux);
        
        w sane/V3[$ux, $ix, $uxs];
    }
    
    
    my @flatly = ();
    my @recur = G.uW;
    my $desc;
    if (ar.i || ar.is) {
        @recur = @$uxs;
        @flatly = uniq( map{_.Lo.i} @recur );
        $desc = (0+@flatly)." x ".(@recur+0);
    }
    $desc ||= "all";
    
    my $j = $G->nw(K=>'j', s=>[]);
    for my $u (@recur) {
        my $a = {i => $u, j => $j};
        w U(%$a);
        #w J(%$a);
    }
    for my $u (@flatly) {
        my $a = {i => $u, j => $j, flatly => 1};
        w U(%$a);
        #w J(%$a);
    }
    
    G:Ϡ ->w('aj' => { j => $j });
    
    sayre "ux -------- G.K $desc done\t".@$Ls." lines\t".$G->F_delta()."  load ".$H->la;
  R: |
    my ($a, $W) = %$ar;
    ref $W eq "Wormhole" || die sw(["Weird wormhole R $a", $ar]);
    my $u = 0->TafuB( $a => {W=>$W} );
    0->l($u) if $a eq "M";
    return $u
  sane:
    getW: |
      my $W;
      for my $L (@$Ls) {
            $W ||= L.W;
          die "L_W changed along lines W.name L.W.name etc etc".sw[$W,ne=>L.W] if $W ne L.W;
      }
      $W;
    Ls: |
      die "No lines in lines..." if !@$Ls;
      die "one line, empty hash...".wdump(2, $Ls) if @$Ls == 1 && !keys %{$Ls->[0]};
      die "one line, no W on line...".wdump(2, $Ls) if @$Ls == 1 && !$Ls->[0]->{W};
    V3: |
      die "ix not Li " unless ix.Li;
      die "ux not in above ux o: ".sw({uxs=>$uxs,ix=>$ix})
          unless ix.O ne "ux" || grep { $_ eq $ux } @{ix.Li.o};
    U1: |
        my $Lu = u.B.Lu || die "no Lu".sw({" no Lu"=>$u}) if u.K eq "ux";
        #warn "ux has no ways out: ".$u->pint if u.K eq "ux" && !@{u.Li.o};
  utricks:
    spawn: | #c
        my @uys;
        my $ui = u.B.ui if u.B.ui;
        die G.sdjjkhrg++ || sw[nonWayui=>$u] if $ui && ref $ui ne "Way";
        if ($ui && ui.ux && u.K eq "ux") {
            $u->from(ui.ux);
        }
        
        if (my $spawn = u.spawn) {
            for my $sp (@$spawn) {
                my $Bs = {};
                if (sp.Bset) {
                    while (my ($k, $v) = each %{sp.Bset}) {
                        $Bs->{$k} = $u->find("B.$v"); # i=Lu.i etc
                    }
                }
                else {
                    $Bs = u.B;
                }
                my $uy;
                if (my $uxy = 0->CsK({K=>sp.K})) {
                    $uy = 0->sway({from=>$uxy});
                }
                if ($ui) {
                    if (my $xiy = 0->CsK({K=>sp.K}, ui.G)) {
                        $G->Flab("ui.G.name hemisphere uxy: ", $uy, $xiy);

                        if (xiy.nojo) { # nnnnnnnnnnnnn is the other to u
                            $uy = 0->sway({from=>$xiy});
                        }
                        else {
                            $uy ||= $G->nw();
                            $uy->from($xiy); # G to xiy.G etc B merged
                        }
                    }
                }
                
                $uy || die sw(["no thingy sp.K", $G->anyway('C')]);
                
                $uy->from({B=>$Bs});
                
                $uy->from({S=>u.S}) if delete sp.Scc;
                
                $uy->from($sp);
                
                push @uys, w utricks/multi[$uy, $u, $sp]; 
            }
        }
        
        my $old = { map { _.uuid => $_ } grep { _.O ne "ux" } @{u.Li.o} };
        my @spun;
        for my $uu (@uys) {
            my $uy;
            if ($uy = 0->fu($uu)) {
            }
            else {
                sayyl "NEW u ! uu.K ".ki(uu.B);
                $uy = 0->T({i => $uu});
                0->l($uy);
            }
            push @spun, $uy;
            delete $old->{uy.uuid};
        }
        if (keys %$old) {
            say $u->pint."  has old stuff under...";
            say $_->pint for values %$old;
            say "NEW STUFF:";
            say $_->pint for @spun;
            for my $o (values %$old) {
                0->deaccum(u.Li, 'o', $o);
                o.dead = 1;
            }
        }
    multi: | #c
      my @uys = $uy;
      if (my $n = sp.multiBy) {
            my $val = uy.B->{$n};
          ref $val eq "ARRAY" || die "was promised $n would be array, is $val ".wdump($uy);
          @uys = ();
          my $i = 0;
          for my $an (@$val) {
              next if an.K eq "ux"; # that hangs out in the origin lines o
              my $anuy = $uy->spawn;
              anuy.B->{$n} = $an;
              anuy.K ."[".$i++;
              push @uys, $anuy;
          }
      }
      @uys
    ngrab: | #c
                if (u.uy_in_dos) {
                    if (my $ton = u.uy_in_dos->{"n_uys_to_".uy.K."_n"}) {
                        uy.B->{$ton} = u.B->{u.B.n};
                        uy.B.n = $ton;
                    }
                }
                if (uy.uy_in_dos) {
                    if (my $n = uy.uy_in_dos.Lu_grab_n) {
                        uy.B->{$n} = u.B.Lu->{$n};
                        uy.B.n = $n;
                    }
                }
    ux_above_via_Lu: | #c
      my $Lu = ux.B.Lu || die "no Lu on ux";
      my $pLu = Lu.i.Lo if exists Lu.i.Lo; # up and over
      my ($pux) = findO(ux => pLu.o) if $pLu;
      $pux if pux.G eq $G;
  U: |
    0->visTp($ar, "Fun") if ar.i;
    my $u = T.i;
    
    inter({u => u.K});
    
    w utricks/spawn[$u];
    w sane/U1[$u];
    
    for my $i (w dook) {
        my $a = {%$ar};
        a.i = $i;
        w U(%$a);
    }
    
    w compile_figure[$u];
    w wayout_sendo[$u, $j];
  J: |
    0->visTp($ar, "Fun") if ar.i;
    my $u = T.i;
    
    for my $do (@{u.sendo || []}) {
        $do->();
    }

    for my $i (w dook) {
        w J[$i];
    }
  compile_figure: |
        my $j = sub { join " ", grep { defined } @_ };
        my $ui = u.B.Lu.i if u.B.Lu;
        my $at = u.at = {};
        
        if (u.K eq "uW") {
            u.at = ui.at;
            return;
        }
        
        # v the look-around-for-style-etc vortex v
        at.id = U->uiuS($u => 'id') || u.Li.uuid;
        at.tag = U->uiuS($u => 'tag') || u.tag || u.K;
        at.ishtml = U->uiuS($u => 'ishtml');
        at.class = U->uiuS($u => 'class');
        
        my @styles;
        push @styles, u.styles, u.S.styles;
        push @styles, ui.styles, ui.S.styles if $ui;
        
        at.styles = $j->(@styles);
        
        
        at.tag ||= u.K;
        die "no tag" .sw($u) if !at.tag;
        
        at.conty = U->uiuS($u => 'content');
        
        at.conty = "" if !defined at.conty;
        at.conty = encode_entities(at.conty) unless at.ishtml;
        at.ooze = [
            sort { a.conor <=> b.conor }
            w dook[$u]
        ];
  wayout_sendo: |
        my $at = u.at;
        my $ui = u.B.Lu.i if u.K eq "ux";
        my $sendo = u.sendo = [];
        my $sdo = sub {
            my $cb = shift;
            push @$sendo, $cb;
            push @{j.s}, $cb;
        };
        my $sendojs = sub {
            my ($id, $sp, @int) = @_;
            $sdo->(sub {
                $H->JS("\$('#$id')".sprintf($sp, @int).";")
            });
        };
        my $_t = u._at;
        
        if (u.K eq "uW" && !$_t) { # TODO gone
            $ui = u.B.ui;
            die "ui Lu i swi" unless $ui eq u.B.Lu.i;
            u.html = ui.html;
            u._at = ui._at;
            return;
        }
        
        my $attr = at.attr = { #c callamity
            id => at.id,
            class => at.class,
            %{ U->uiuS($u => "attr") || {} },
        };
        
        my $conty = defined at.conty ? at.conty : "";
        my $oozs = [ grep { defined } map { _.html } @{ at.ooze } ];
        my $content = join "\n", @$oozs;
        
        at.Z = {}; # zip v
        
        at.Z = { %{at.Z}, %{u.Z} } if u.Z; # from u
        
        my $styles = at.styles;
        w stylezo[$u, $ui, $styles, $at];
        
        my $Z = U->uiuS($u => "Z"); # from ui S/Z(_D)
        at.Z = { %{at.Z}, %$Z } if $Z;
        
        $Z && attr.style && die "got uiu $Z\t\tattr.style already";
        
        at.css = at.Z;
        while (my($k,$v) = each %{at.css}) {
            if (ref $v eq 'HASH') {
                delete at.css->{flit} if at.css->{flit};
                at.css->{'-webkit-filter'} = join " ",
                    map{ "$_($v->{$_})" } sort keys %$v;
            }
        }
        
        
        if (u.K eq "W") {
            attr.title = "G.O.name    G.way    G.K";
        }
            
        if (!$_t) { #c suqundo
            if ( $conty && $content ){
                warn "conty and ooze ".$u->pint;#sw(["contooz", $u, $conty, $content]);
                $conty = ",";
            }
            if (length($conty . $content) > 25000) {
                $content = "";
                $sdo->(sub {
                    $H->JS("\$('#at.id').append('$_');") for @$oozs
                });
            }
            if (u.S.sendo_init_D) {
                $sdo->(sub { w $u S/sendo_init_D(e=>'') });
            }
            if ($ui && ui.S.sendo_init_D) {
                $sdo->(sub { w $ui S/sendo_init_D(e=>'') });
            }
            
            if ($u eq G.uW) { # unified field of this W
                $sdo->(sub {
                    $H->JS("\$('#ux').append('".0->jsq(u.html)."');");
                });
                j._ && die "Already unified!?";
                j._ = $u; # TODO diffy for the J
            }
        }
        else {
            my $ino = sub { my ($u, $in) = @_; grep { $_ eq $u } @$in; };
            
            for my $newu (grep { !$ino->($_, u._at.ooze) } @{at.ooze}) {
                $sendojs->(at.id, q{.append('%s')}, 0->jsq(newu.html));
            }
            for my $gonu (grep { !$ino->($_, at.ooze) } @{u._at.ooze}) {
                $sendojs->(gonu.at.id, q{.remove()});
            }
            if (at.conty ne _t.conty) {
                my $s = 0->jsq(at.conty);
                $s =~ s/\\ \\ n/\n/x;
                $sendojs->(at.id, q{.text("%s")}, $s);
            }
            while (my ($k, $v) = each %{ at.attr }) {
                next if $v eq _t.attr->{$k};
                $sendojs->(at.id, q{.attr('%s', '%s')}, 0->jsq($k, $v));
            }
            if (at.css) {
                while (my($k,$v) = each %{at.css}) {
                    next if $v eq _t.css->{$k};
                    my $isa = '++';
                    # an uiuS for mergins Anim/* ?
                    my $anim = $ui && ui.Anim->{$k};
                    $anim = G.O->w('Anims', {k=>$k}) if !defined $anim;
                    if ($anim) {
                        my $dur = $anim."00";
                        my $d = $dur; # leading zeros push into tinyness
                        $d = $d / 10 for split '', $dur =~ m/^(0+)/;
                        $d ||= 400;
                        $isa = "$d>>";
                        
                        $sendojs->(at.id, q".animate({'%s':'%s'}, %s)",
                            0->jsq($k, $v), $d);
                    }
                    else {
                        $sendojs->(at.id, q{.css('%s', '%s')}, 0->jsq($k, $v));
                    }
                }
            }
        }
        attr.style .= shtocss(at.css) if at.css;
        my $tag = at.tag;
        my $mkat = sub {
            my $a = shift;
            my $v = $attr->{$a};
            return $a if $v eq "undef";
            return $a.'="'.$attr->{$a}.'"'
        };
        # style/class gets misccss/Wcss
        $attr = join " ", map { $mkat->($_) }
            grep { defined $attr->{$_} && $attr->{$_} ne "" } sort keys %$attr;
            
        u.html = "<$tag $attr>$conty$content</$tag>";
        
        u._at = $at;
  dook: |
    my @o;
    my $L = ar.u.Li || T.L;
    for my $u (@{L.o}) {
        next if ar.flatly && u.O ne 'ux';
        die "leads back" if $u eq L.i;
        
        unless (u.G eq $G || u.G eq G.O) {
            # to skip O=ux plants on nested vortexen (uW{ui=W)
            # uy maybe spawned from G.O Cs
            #say "skipping u.K u.uuid on T.i.K cos u.G.name ne here", $u, T.i;
            next;
        }
        # to skip O=ux plants on nested vortexen (uW{ui=W) # but go into uy spawned from G.O Clange
        if (u.dead || u.B.ui && u.B.ui.dead) {
            sayre "DEAD DEAD DEAD u.K removing from G.K ux ". u.B.ui->pint();
            0->deaccum($L, 'o', $u);
            next;
        }
        push @o, $u;
    }
    @o;
  event: |
    my $u = L.i; # the clicked id: uy probly.
    my $ux = uxL.i; # first parent <ux>
    my $uu = ux.B.Lu.i;
    my $uy = $u if $u ne $ux;
    my $E = {
        e => $e,
        W => $W,
        L => uu.Li,
        u => $uu,
        ux => $ux,
        uy => $uy,
    };
    
    # come from within something we don't grasp
    return H.G->w('serve/TV', {e=>E.e}) unless E.L;
    
    # TODO make a pattern about y=to match against Eways...
    E.L.G->w(event => $E);
dials:
  db: -3

