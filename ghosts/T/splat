name: wormhole splatter
tractors:
  - K: Wormhole Splat
    arr_if: |
      $splatname =~ /\w+/ && ref $wormhole->{script} eq "ARRAY";
    B_: |
      $splatname
    first_time: |
      my $style = "padding: 1em;position:absolute;overflow:hidden;";
      if ($splatname eq "wing") {
          $style .= "bottom:0px;right:0px;border:5px solid green;width:10em;z-index:20;"
      }
      $S->{view} = ($G->{floozal} || $H->{sky})->spawn_floozy($G, $splatname, $style);
      
    nonfirst_times: |
      $S->{view}->fadehtml();
    print: |
      $S->{K} .": ". $S->{B}->{_}
hooks:
  load_ways_post: |
    #grab A/WS
    # nest, styles tied to atom thing
    # everything will have its own texty things going on
    # the gname
    # junction
    # so it's just over yonder in the chain
  go: |
    Info "\n splat go:   ".join "  ", %$ar;
    exists $ar->{line}
      ? $G->w('open_line', $ar)
      : $O->w('somewhere', $ar);
    
  open_line: |
    my $CG = $O->Gf("crawl") || die "no O G crawl";
    
    my $NS = $CG->w('revisit', { line => $line, push_depth => 1 });
    $NS || die "NO!";
    
    my $wormhole = { script => $NS };
    
    my $A = Afind[$splatname];
    die "noA splatname=$splatname" unless $A;
    # new stuff, wedge into html like it has in the wormhole
    w script_out[$A, $wormhole, $splatname, $append];
  lcodon: |
    my @files;
    my $t = $line->{t};
    if (ref $t eq "Ghost") {
        @files = @{ $t->{wayfiles} };
    }
    else { die "get codes from $t"; }
    
    for my $file (@files) {
        my $c = Codon->new($H->intro,
            { codo => $H->getapp("Codo"),
            filename => $file }
        );
        $c->{show} = $S->{view}->spawn_floozy($G, "codon-del-$line->{uuid}",  "width:89%; background:#80182; color:#afc; height:23em;", after => $A->{C}->{Line}->{S}->{id});
        $c->display();
    }
  
  Splat: |
    my ($splatname, $wormhole) = %$ar;
    $wormhole = w aWstract[$wormhole];
    my $A = Arr[$splatname, $wormhole];
    w script_out[$A, $splatname, $wormhole];
  aWstract: |
    $wormhole ne $G->W
        ? $wormhole
        : { script => [@{$wormhole->{script}}] }
  script_out: |
    my $lines = [];
    my $i = 0;
    for my $line (@{$wormhole->{script}}) {
        if($i++ > 400) {
            push @$lines, "more...";
            last;
        }
        my ($R, $B) = ([], {});
        push @$lines, w make_line[$splatname, $i, $R, $B, $line];
    }
    my $th = {
        nospace => 1,
        class => 'menu',
        tuxtstyle => 'width: 100%;',
    };
    $th->{append} = $ar->{append} if $ar->{append};
    
    my $t = $A->{view}->newtext($lines, $th);
    return $t;
  
  make_line: |
    ref $line eq "HASH" || die  "FUKN ".wdump($line);
    
    w line/value; # R <-> B to be tractored

    return { _spawn => [ $R, {
        nospace => 1,
        B => $B,
        tuxtstyle => 'opacity:1; height:120%;position: relative; float: left; background: #0066CC; ',
        tuxts_to_htmls => sub {
            my $texty = shift;
            my $tx = $texty->{tuxts};
            
            w tuxtsB(B => $B, tx => $tx);
            w line/style;
        },
    }]}
  tuxtsB: |
      for (@$tx) {
          next unless $_->{bb};
          $B->{$_->{bb}}->{s} = $_;
      }
  line:
    value: |
      my @atom = qw[d i t o m]; # TODO combine d+i = a
      if ($splatname eq "wing") {
          @atom = qw[t m];
      }
      for my $bb (@atom) {
          my $b = $B->{$bb} = {line => $line, bb => $bb};
          my $v = $G->w("line/$bb/v", {%$ar, b=>$b});
          $v = "!bb=$bb $v" unless ref $v;
          push @$R, $v;
      }
      # ^ v here's the void; many R come to B, pretty much via Texty::mktuxts
    style: |
        while (my ($bb, $b) = each %$B) {
            $G->w("line/$bb/s",{%$ar,
            b => $b, s => $b->{s}, line => $b->{line}});
        }
    event: |
        my $append = $s->{id};
        
        my $t = $line->{t};
        $splatname eq 'trev' ?
            sub { w go[$splatname, $line, $append] } :
            $splatname eq 'wing' ?
                sub { w go(thing => $t->{B}->{thing}) } :
                sub { w go(thing => $t) };
    m:
      v: |
        my $t = $line->{t};
        my $menu = [];
        
        if (ref $t && "$t" =~ /HASH/ && $t->{G} && ref $t->{G} eq "Ghost") {
            push @$menu, $t->{G} Tw splatmenues;
        }
        
        push @$menu, 't' => sub { w go( thing => $t ) };
        push @$menu, 'Ώ' => sub { w go( wormhole => $t ) }
            if ref $t eq "Wormhole";
        push @$menu, '⊟' => sub { w lcodon[$line] }
            if "$t" =~ /Codon|Ghost/;
        
        {
        contyt => { bb => $b->{bb} },
        _spawn => [ [], {
        nospace => 1,
        event => { menu => $menu },
        class => 'menu',
        tuxtstyle => "font-size:25pt;",
        }]
        }
      s: |
        $s->{style} .= "font-size:35pt;";
#c thing background=#fca
    t:
      v: |
        my $t = $line->{t};
        if ($t && ref $t eq "HASH") {
            # way in like: Hostinfo ->{ file_stream >@ this HASH
            #
            # means we want bring $t->{filename} to the surface and show here
            # organicness just around the corner.....
        }
        "$t";
      s: |
        my $t = $line->{t};
        die $s->{value} if ref $s->{value};
        my $inc = sub { $s->{html}=1;'<t style="color:'.shift.';">'.shift.'</t>' };
        my $emb = sub { $inc->("rgba(255,200,200,0.4);font-size:29pt;position:absolute;left:-1em;top:-7px;", encode_entities(shift)) };
        my $color;
        my $name = "$t";
        my $fs;
        if (my $ref = ref $t) {
            if ($name =~ /HASH/) {
                $color = "f66";
                $name = "{";
                if ($ref eq "HASH") {
                    my $k = join " ", sort keys %$t;
                    $name .= "$k";
                $fs = 10;
                }
                else {
                    $fs = 22;
                    $name = $ref.$name;
                    if ($ref eq "View") {
                        $name .= "#".$t->{divid};
                    }
                }
                if ($t->{name}) {
                    $name .= " ".$t->{name};
                }
                $s->{style}.="border-left:40px solid #$1;"
                    if $t->{id} && $t->{id} =~ m/^\w+-\w{5}(\w{3})/;
            }
            if ($ref eq "ARRAY") {
                $color = "090";
                $name = "[".$inc->('black',0+@$t)."]"; 
                my $fromG = $line->{i}->{L}->{t};
                if ($fromG && ref ${fromG} eq "Ghost") {
                    if ($line->{i}->{each} eq "GG") {
                        $name .= " ";
                        for (@$t) {
                            $name .= $inc->('black','[G')."$_->{way} ";
                        }
                    }
                }
            }
            if ($ref eq "Way") { 
                $name = w $t print;
                $name ||= join " ", sort keys %$t;
                $name = $emb->('ϖ').$name;
            }
            if ($ref =~ /(T|G|W)(host|ravel|ormhole)/) {
                my $ty = $1;
                my ($nb, $nl);
                if ($ty eq "T") {
                    $name = "$t->{G}->{way}";
                    $color = "8c6";
                }
                if ($ty eq "W") {
                    $name = $t->{G}->{name};
                    $color = "4c6";
                }
                if ($ty eq "G") {
                    $name = $t->{name};
                    $color = "4c6";
                }
                ($nb,$nl) = $name =~ /^(.+)\(([^\)]+)\)$/;
                $nl ||= $name;
                $s->{style}.="border-left:40px solid #$1;"
                    if $nb =~ m/^\w+-\w{5}(\w{3})/;
                $s->{html} = 2;
                $name = $emb->($ty).$inc->('#111;font-size:8pt', $nb).$nl;
            }
            
            $s->{style} .= "text-shadow:2px 3px 3px "
                .(@{$line->{o}} ?"#89F":"#0F3694 ")  .";";
            $s->{style} .= "font-weight: 900;";
        }
        else {
            if ($t =~ m/^\w+-\w{5}(\w{3})/) {
                $s->{style}.="border-left:18px solid #$1;";
            }
            $color = "999";
            $s->{style} .= "font-weight: 500;";
            
        }
        $s->{value} = $name;
        my $l = length($name);
        $fs ||= 17 if $l > 10;
        $fs ||= 10 if $l > 20;
        $fs ||= 25;
        $s->{style} .= "font-size:${fs}pt;";
        
        $s->{style}.="max-width: 20em;";
        $s->{style}.="word-wrap:break-word; max-height:5em; min-width: 10em;";
        $s->{style}.="color:#$color;";
        
        $s->{style} .= "font-size:11pt;font-family:serif;" if !ref $t;
        $s->{_event} = w line/event;
        $s->{class}.= " splatt ";
    d:
      v: |
        $line->{depth}
      s: |
        $s->{style} .="color: #3D52A8; font-size:20pt; position: absolute; background:none; top:-0.25em;";
        $s->{_event} = sub {
            my ($e, $s, $t) = @_;
            $H->JS("\$('.$t->{id}').slideUp();");
        };
#c i o
    i:
      v: |
        $b->{c} = $line->{i};
        w desc/chain(+ c => $b->{c});
      s: |
        $s->{class} .= " splat-w ";
        $s->{style}.="margin-top:1px;background:rgba(130,108,33,0.5);direction:rtl;"
            ."width: "
        .(($line->{depth}) * 5 + 3)."em;"
            if $line->{depth} > 0;
        
        my $K = $b->{c}->{K};
        
        my $ilt = $line->{i}->{last_line}->{t};
        if ($ilt && ref $ilt
            && "$ilt" =~ "HASH"
            && $ilt->{id}
            && $ilt->{id} =~ /^\w+-\w{5}(\w{3})/) {
                $s->{style}.="border:3px solid #$1;";
        }
        
        $s->{style}.="color: #".(
            $K eq 'dsc/%' ? "FF8533" :
            $K eq 'dsc/@' ? "85FF33" :
            'bbb' ).";" if $K;
            
        $s->{_event} = sub { w go(thing => $line->{i}) }
    o:
      v: |
        $b->{c} = $line->{o};
        w desc/chain(+ c => $b->{c});
      s: |
        $s->{class} .= " splat-w ";
        $s->{style} .= "font-size:7pt;" if length($s->{value}) > 8;
        $s->{style} .= "max-width:15em; background:rgba(130,108,33,0.5);";
        $s->{style} .= "color: #f82;" unless $s->{value} eq "none";
        $s->{_event} = sub { w go(thing => $line->{o}) }
  
  desc:
    chain: |
      return "?" unless $c;
      
      if (ref $c eq "ARRAY") {
          my @cl;
          
          for my $cc (@$c) {
              push @cl,
            scalar w desc/chain(+ c => $cc)
          }
          return "[]" unless @cl;
          
          
          my @names = @cl;
          return scalar(@cl)." @names";
      }
      my $l = w $c print;
      unless (defined $l) {
          $l = 
          join ", ",
              map { "$_: $c->{$_}" }
              sort keys %$c;
      }
     
      if (0 && $c->{as_from}) {
          $l .= "<".w desc/chain(+ c => $c->{as_from});
      }
      return $l
    
  wdump: |
    use Data::Dumper;
    $Data::Dumper::Maxdepth = 2;
    return Dumper($in);

  colorf: |
    my $fing = $in;
    my ($l,$r,$b) = @_;
    my ($color) = ($in || "0") =~ /\(0x....(...)/;
    $color ||= $fing if $in && ref \$in eq "SCALAR" && $in =~ /^(\x{3}|\x{6})$/;
    $color ||= "663300";
    $l ||= 0;
    $r ||= 0;
    $b ||= 3;
    return "text-shadow: ${l}px ${r}px ${b}px #$color;";

  random_shadow: |
    my ($rgb) = join", ", map int rand 255, 1 .. 3;
    return "text-shadow: 0px 0px 4px rgb($rgb);";
  random_colour: |
    my ($rgb) = join", ", map int rand 255, 1 .. 3;
    return "rgb($rgb);";
  random_colour_background: |
    my ($rgb) = join", ", map int rand 255, 1 .. 3;
    return "rgb($rgb);";

