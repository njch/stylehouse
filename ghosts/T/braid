name: spiral braid
hooks:
  any_init: |
    say "hi";
    G.U ||= {};
    G.U.mku = sub {#c
        my ($way, $B) = @_; 
        confess "B B".wdump([@_]) if B.B;
        $B = {%$B};
        say "L ".pint(G.L.i);
        say "mku $way   ".join ",  ", map { "$_ = ".pty($B->{$_}) } keys %$B;
        my $w = $G->nw()->from(
            $G->findway('ways/'.$way)
        )->from({B=>{%$B}});
        
        w.Lu = w.B.Lu if w.B.Lu;
        die "makedad".wdump($w) if w.Lu && w.O ne "ux";
        $w
    };
    G.U.accum = sub {#c
        my ($a, $t) = @_;
        if (!grep { $_ eq $t } @$a) {
            push @$a, $t
        }
    };
    G.U.deaccum = sub {#c
        my ($S, $ac, $t) = @_;
        my $a = $S->{$ac};
        my $i = 0;
        for (@$a) {
            return splice(@$a, $i, 1) if $_ eq $t;
            $i++;
        }
    };
    G.U.findu = sub {#c
        my $u = shift;
        my $L;
        for my $LL (@{$G->W->{script}}) {
            my $i = LL.i;
            if ($i eq $u) {
                $L = i.Lo;
                last;
            }
            elsif (u.B) {
                my $f = 0;
                for my $k (keys %{u.B}) {
                    $f = 1 unless u.B->{$k} eq i.B->{$k}
                }
                $L = $LL unless $f;
            }
        }
        $L ? L.i : $u;
    };
    
    
    
    G.U.ul = sub {#c # look for u way
    say "ul ";
        my $z = {@_};
        my $u = z.u;
        $u = G.U.findu->(z.u)                  unless u.Li;
        
        if (z.p){
            if (u.O eq "uy") {
                G.U.accum->(z.p.o => $u);
                G.U.accum->((u.Loose||=[]), z.p); # .B.Lo many
            }
            else {
                G.U.accum->(z.p.o => $u);
                G.u.Lo = z.p
            }
        }
        unless (u.Li) {
              G.U.h.ul.creating_that_u->($u)
              if G.U.h.ul.creating_that_u;
             
            $G->T("anu: ".pint($u), undef, $u) unless u.Li;
        }
        die "no Li after T"                   unless u.Li;
           
        G.U.h.ul.done->($u) if G.U.h.ul.done;
        $u
    };
    G.U.mk = sub {#c
        G.U.ul->( 
            u => G.U.mku->(@_),
            p => G.L,
        );
    };
    
    G.U.o_uxs = sub {#c
        my $L = shift || G.L || die "no L";
        findO(ux => L.o);
    };
    G.U.uL_o_Lu_find = sub {#c
        my $t = shift;
        grep { $t eq _.Lu } G.U.o_uxs->();
    };
    
    G.U.cu_Lu = sub {#c
        my $w = shift;
        w.Li && G.U.uL_o_Lu_find->(w.Li)
    };
    G.U.Luyon = sub {#c
        my $n = shift;
        grep { _.O eq "uy" && exists _.B->{$n} } G.U.o_uxs->();
    };
    G.U.uys = sub {#c
        my ($uyB) = @_;

        my $u = G.U.ul->( 
            u => G.U.mku->(uy => $uyB),
            p => G.L,
        );
        die "shunno".pty(G.L)." not have ".pint($u)
            unless 1 || grep { $_ eq $u } @{G.L.o};
        $u;
    };
    G.U.braid = sub {#c
        my $u = G.L.i;
        my $uL = G.L;
        
        die "no stoops" if !@{G.U.stoops};
        die "no toos" if !@{G.U.toos};
        die "toos != stoops" if !@{G.U.stoops} != !@{G.U.toos};
        my $til = @{G.U.toos}-1;
        for my $i (0..$til) {
            G.U.ug_i = $i;
            
            G.U.antop->();
            G.L = $uL;
            
        }
    };
    G.U.antop = sub {#c
        my $u = G.L.i;
        my $uL = G.L;
        die "ul is :".wdump(2,$uL)unless uL.i.K =~ /^u[xy]$/; 
        
        G.U.stoops->[    G.U.ug_i    ]->();
        
        for my $uo (@{uL.o}) {
            G.L = uo.Li;
            G.U.antop->();
        }
        G.L = u.Li;
        
        G.U.toos->[      G.U.ug_i    ]->();
    };

