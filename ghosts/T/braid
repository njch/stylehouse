name: spiral braid
hooks:
  any_init: |
    G.U ||= {};

    G.U.yakanTop = sub {#c
        my $ar = shift;
        die "I ".ki($ar) if ar.i;
        my $ds = "";
        $ds .= "    " for 0..@{T._trail.i};
        say "anTop $ds ".join"    - ",map{my $w = $ar->{$_}; "$_ => ".pint($w)} keys %$ar;
    };
  braid: |
    # do thebusiness from T
    # Ds will be spin one day
    my $Ds = ar.Ds || T.Ds || die "No Ds to braid";
    unless (ref $Ds eq "HASH") {
        $Ds = $G->findway($Ds);
        die "malformed Ds ".wdump($Ds)
            unless ref $Ds eq "HASH";
    }
    $Ds = {%$Ds};
    
    my $Y = delete $Ds->{0.5} if $Ds->{0.5};
    my @Ds = map {
        { K => $_, D => $Ds->{$_} }
    } sort keys %$Ds;
    
    my $p = {};
    p._trail._no_circles = 1;
    p._braid = { Ds => \@Ds, Di => 0, Y => $Y }; # top level stuff
    0->visTp($p, "Fun");
    
    my $Tbr = T._braid;
    # we can inject meanwhile into Ds, fractionating complexity
    # if this was processing a list it could mean wrapping things in maps and sanity
    # args to anTop may change i from inside the braid for recursion
    # or Dw if top
    # T._braid._no_circles catches recursion via _trail.i
    # and yeah... we are in already and return to from anTop the top of the braid 
    while (defined( my $Dw = Tbr.Ds->[Tbr.Di] )) {
        say "Doing Di=Tbr.Di  at Dw.K";
        w anTop[$Dw];
        Tbr.Di++;
    }
  anTop: |
    U->yakanTop($ar);
    0->visTp($ar, "Fun") if %$ar;
    T.L || die "no Line from i... antop";
    if (T.Dw.K < 0.5) {
        $G->doo(T.Dw.D);
        Say "Did T.Dw.K";
    }
    
    $G->doo(T._braid.Y);
    Say "Diddle";
    if (T.Dw.K > 0.5) {
        $G->doo(T.Dw.D);
        Say "Did T.Dw.K";
    }

