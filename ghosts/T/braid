name: spiral braid
hooks:
  recoded_init: |
    H.G->w('re/exec');
  any_init: |
    G.U ||= {};
  DooB: |
    my $B = 0->sway({CsK => 'B', K => $K});
    $B || die "no $K";
    say wdump($B);
    
  braid: |
    my $Ds = ar.Ds || T.Ds || die "No Ds to braid";
    unless (ref $Ds eq "HASH") {
        $Ds = $G->findway($Ds);
        die "malformed Ds ".wdump($Ds)
            unless ref $Ds eq "HASH";
    }
    $Ds = {%$Ds};
    
    my $Y = delete $Ds->{0.5} if $Ds->{0.5};
    
    my @Ds = map {
        { K => $_, D => $Ds->{$_} }
    } sort keys %$Ds;
    
    my $p = {};
        p._trail._no_circles = 1;
        p._braid = {};
    0->visTp($p, "Fun");
    
    my $Tbr = T._braid;
    Tbr.Ds = \@Ds;
    Tbr.Di = 0;
    T.Y = $Y; 
    
    while (defined( my $Dw = Tbr.Ds->[Tbr.Di] )) {
        say "Doing Di=Tbr.Di  at Dw.K";
        w anTop[$Dw];
        Tbr.Di++;
    }
  anTop: |
    my $ds='';
    if (T._trail && ref T._trail.is eq "ARRAY") {
        $ds .= "    " for 0..@{T._trail.is||[]} 
    }
    my $sets = join "     ",
        (ar.Dw && "Dw"." -> T.Dw.K"),
        (ar.i && ref ar.i eq "Way" && "i -> ar.i.K"),
        ;
        
    #say "anTop $ds $sets";
    0->visTp($ar, "Fun") if %$ar;
    
    T.L || die "no Line from i... antop";
    if (T.Dw.K < 0.5) {
        say " - $ds   >   T.Dw.K T.i.K" if $G->deeby;
        $G->doo(T.Dw.D);
    }
    
    T.Y || die "NO Y";
    #say " - $ds  Y from T.i.K";
    my $r = $G->doo(T.Y);
    
    if (T.Dw.K > 0.5) {
        say " - $ds <       T.Dw.K T.i.K" if $G->deeby;
        $G->doo(T.Dw.D);
    }

