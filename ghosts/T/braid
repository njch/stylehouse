name: spiral braid
hooks:
  any_init: |
    say "hi";
    G.U ||= {};
    G.U.mku = sub {#c
        my ($way, $B) = @_; 
        confess "B B".wdump([@_]) if B.B;
        $B = {%$B};
        #say "L ".pint(G.L.i);
        #say "mku $way   ".join ",  ",
        #map { "$_ = ".pty($B->{$_}) } keys %$B;
        my $w = $G->nw()->from(
            $G->findway('ways/'.$way)
        )->from({ B => {%$B} });
        
        w.Lu = w.B.Lu if w.B.Lu;
        die "makedad".wdump($w) if w.Lu && w.O ne "ux";
        $w
    };
    G.U.findu = sub {#c
        my $u = shift;
        my $L;
        for my $LL (@{$G->W->{script}}) {
            my $i = LL.i;
            if ($i eq $u) {
                $L = $LL;
                last;
            }
            elsif (u.B) {
                my $f = 0;
                #say "looking for ".wdump(2,["B",u.B, $u]);
                for my $k (keys %{u.B}) {
                    $f = 1 unless u.B->{$k} eq i.B->{$k}
                }
                unless ($f) {
                    die "FOUNDO" unless i.Li;
                }
                $L = $LL unless $f;
            }
        }
        $L ? L.i : $u;
    };
    
    
    
    G.U.ul = sub {#c # look for u way
    #say "ul ";
        my $z = {@_};
        my $u = z.u;
        $u = G.U.findu->(z.u)                  unless u.Li;
        
        if (z.p){
            if (u.O eq "uy") {
                0->accum(z.p, 'o', $u);
                0->accum($u, 'Loose', z.p); # .B.Lo many
            }
            else {
                0->accum(z.p, 'o', $u);
                0->accum($u, 'Lo', z.p);
            }
        }
        unless (u.Li) {
              G.U.h.ul.creating_that_u->($u)
              if G.U.h.ul.creating_that_u;
             
            $G->T("anu: ".pint($u), undef, $u) unless u.Li;
        }
        die "no Li after T"                   unless u.Li;
           
        G.U.h.ul.done->($u) if G.U.h.ul.done;
        $u
    };
    G.U.mk = sub {#c
        G.U.ul->( 
            u => G.U.mku->(@_),
            p => G.L,
        );
    };
    
    G.U.uL_o_Lu_find = sub {#c
        my $t = shift;
        grep { $t eq _.Lu } findO(ux => G.L.o);
    };
    
    G.U.cu_Lu = sub {#c
        my $w = shift;
        w.Li && G.U.uL_o_Lu_find->(w.Li)
    };
    G.U.uys = sub {#c
        my ($uyB) = @_;

        my $u = G.U.ul->( 
            u => G.U.mku->(uy => $uyB),
            p => G.L,
        );
        die "shunno".pty(G.L)." not have ".pint($u)
            unless 1 || grep { $_ eq $u } @{G.L.o};
        $u;
    };
    G.U.braid = sub {#c
        my $u = G.L.i;
        my $uL = G.L;
        
        die "no stoops" if !@{G.U.stoops};
        die "no toos" if !@{G.U.toos};
        die "toos != stoops" if !@{G.U.stoops} != !@{G.U.toos};
        my $til = @{G.U.toos}-1;
        for my $i (0..$til) {
            G.U.ug_i = $i;
            
            G.U.antop->();
            G.L = $uL;
            
        }
    };
    G.U.antop = sub {#c
        my $u = G.L.i;
        my $uL = G.L;
        die "ul is :".wdump(2,$uL)unless uL.i.K =~ /^u[xy]$/; 
        my $prevx = G.last_ux;
        my $lastx = G.last_ux = $u if u.K eq 'ux';
        
        G.U.stoops->[    G.U.ug_i    ]->();
        
        for my $uo (@{uL.o}) {
            G.L = uo.Li;
            G.U.antop->();
            G.last_ux = $lastx;
        }
        G.last_ux = $prevx;
        G.L = u.Li;
        
        G.U.toos->[      G.U.ug_i    ]->();
        
        G.last_ux = $prevx;
    };

