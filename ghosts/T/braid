name: spiral braid
hooks:
  any_init: |
    G.U ||= {};
    G.U.mku = sub {#c
        my ($way, $B) = @_; 
        confess "B B".wdump([@_]) if B.B;
        $B = {%$B};
        #say "L ".pint(G.L.i);
        #say "mku $way   ".join ",  ",
        #map { "$_ = ".pty($B->{$_}) } keys %$B;
        my $w = $G->nw()->from(
            $G->findway('ways/'.$way)
        )->from({ B => {%$B} });
        
        if (w._postsketch) {
            w $w _postsketch;
            delete w._postsketch;
        }
        die "makedad".wdump($w) if w.B.Lu && w.O ne "ux";
        $w
    };
    G.U.findu = sub {#c
        my $u = shift;
        my $L;
        for my $LL (@{$G->W->{script}}) {
            my $i = LL.i;
            if ($i eq $u) {
                $L = $LL;
                last;
            }
            elsif (u.B) {
                my $f = 0;
                #say "looking for ".wdump(2,["B",u.B, $u]);
                for my $k (keys %{u.B}) {
                    $f = 1 unless u.B->{$k} eq i.B->{$k}
                }
                unless ($f) {
                    die "FOUNDO" unless i.Li;
                }
                $L = $LL unless $f;
            }
        }
        my ($here, $g0) = (L.i, );#0->fu($u));
        #if ($here ne $g0) {
        #    Say "Findu sitchn:\n".wdump(3,[$here,'','','','','',$g0,'','','','',$u]);
        #}
            return $here || $u;
    };
    
    
    
    G.U.ul = sub {#c # look for u way
    #say "ul ";
        my $z = {@_};
        die "DONT";
        my $u = z.u;
        
        $u = G.U.findu->(z.u)                  unless u.Li;
        
        
        if (z.p){
            if (u.O eq "uy") {
                0->accum(z.p, 'o', $u);
                0->accum($u, 'Loose', z.p); # .B.Lo many
            }
            else {
                0->accum(z.p, 'o', $u);
                0->accum($u, 'Lo', z.p);
            }
        }
        unless (u.Li) {
              G.U.h.ul.creating_that_u->($u)
              if G.U.h.ul.creating_that_u;
             
            $G->T("anu: ".pint($u), undef, $u) unless u.Li;
        }
        die "no Li after T"                   unless u.Li;
           
        G.U.h.ul.done->($u) if G.U.h.ul.done;
        $u
    };
    G.U.mk = sub {#c
        G.U.ul->( 
            u => G.U.mku->(@_),
            p => G.L,
        );
    };
    
    G.U.uL_o_Lu_find = sub {#c
        my $t = shift;
        grep { $t eq _.B.Lu } findO(ux => G.L.o);
    };
    
    G.U.cu_Lu = sub {#c
        my $w = shift;
        w.Li && G.U.uL_o_Lu_find->(w.Li)
    };
    G.U.uys = sub {#c
        my ($uyB) = @_;
        #
        my $u = G.U.ul->( 
            u => G.U.mku->(uy => $uyB),
            p => G.L,
        );
        die "shunno".pty(G.L)." not have ".pint($u)
            unless grep { $_ eq $u } @{G.L.o};
        $u;
    };
    G.U.yakanTop = sub {#c
        my $ar = shift;
        my $ds = "";
        $ds .= "    " for 0..@{T._trail.i};
        say "anTop $ds ".join"    - ",map{my $w = $ar->{$_}; "$_ => ".pint($w)} keys %$ar;
    };
  braid: |
    # do thebusiness from T
    # Ds will be spin one day
    my $Ds = ar.Ds || T.Ds || die "No Ds to braid";
    unless (ref $Ds eq "HASH") {
        $Ds = $G->findway($Ds);
        die "malformed Ds ".wdump($Ds)
            unless ref $Ds eq "HASH";
    }
    $Ds = {%$Ds};
    
    my $Y = delete $Ds->{0.5} if $Ds->{0.5};
    my @Ds = map {
        { K => $_, D => $Ds->{$_} }
    } sort keys %$Ds;
    
    my $p = {};
    p._trail._no_circles = 1;
    p._braid = { Ds => \@Ds, Di => 0, Y => $Y }; # top level stuff
    0->visTp($p, "Fun");
    
    my $Tbr = T._braid;
    # we can inject meanwhile into Ds, fractionating complexity
    # if this was processing a list it could mean wrapping things in maps and sanity
    # args to anTop may change i from inside the braid for recursion
    # or Dw if top
    # T._braid._no_circles catches recursion via _trail.i
    # and yeah... we are in already and return to from anTop the top of the braid 
    while (defined( my $Dw = Tbr.Ds->[Tbr.Di] )) {
        say "Doing Di=Tbr.Di  at Dw.K";
        w anTop[$Dw];
        Tbr.Di++;
    }
  anTop: |
    U->yakanTop($ar);
    0->visTp($ar, "Fun") if %$ar;
    T.L || die "no Line from i... antop";
    if (T.Dw.K < 0.5) {
        $G->doo(T.Dw.D);
        Say "Did T.Dw.K";
    }
    
    $G->doo(T._braid.Y);
    if (T.Dw.K > 0.5) {
        $G->doo(T.Dw.D);
        Say "Did T.Dw.K";
    }

