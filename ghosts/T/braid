name: spiral braid
hooks:
  any_init: |
    G.U ||= {};
    G.U.mku = sub {#c
        my ($way, $B) = @_; 
        confess "B B".wdump([@_]) if B.B;
        $B = {%$B};
        #say "L ".pint(G.L.i);
        #say "mku $way   ".join ",  ",
        #map { "$_ = ".pty($B->{$_}) } keys %$B;
        my $w = $G->nw()->from(
            $G->findway('ways/'.$way)
        )->from({ B => {%$B} });
        
        if (w._postsketch) {
            w $w _postsketch;
            delete w._postsketch;
        }
        die "makedad".wdump($w) if w.B.Lu && w.O ne "ux";
        $w
    };
    G.U.findu = sub {#c
        my $u = shift;
        my $L;
        for my $LL (@{$G->W->{script}}) {
            my $i = LL.i;
            if ($i eq $u) {
                $L = $LL;
                last;
            }
            elsif (u.B) {
                my $f = 0;
                #say "looking for ".wdump(2,["B",u.B, $u]);
                for my $k (keys %{u.B}) {
                    $f = 1 unless u.B->{$k} eq i.B->{$k}
                }
                unless ($f) {
                    die "FOUNDO" unless i.Li;
                }
                $L = $LL unless $f;
            }
        }
        my ($here, $g0) = (L.i, );#0->fu($u));
        #if ($here ne $g0) {
        #    Say "Findu sitchn:\n".wdump(3,[$here,'','','','','',$g0,'','','','',$u]);
        #}
            return $here || $u;
    };
    
    
    
    G.U.ul = sub {#c # look for u way
    #say "ul ";
        my $z = {@_};
        die "DONT";
        my $u = z.u;
        
        $u = G.U.findu->(z.u)                  unless u.Li;
        
        
        if (z.p){
            if (u.O eq "uy") {
                0->accum(z.p, 'o', $u);
                0->accum($u, 'Loose', z.p); # .B.Lo many
            }
            else {
                0->accum(z.p, 'o', $u);
                0->accum($u, 'Lo', z.p);
            }
        }
        unless (u.Li) {
              G.U.h.ul.creating_that_u->($u)
              if G.U.h.ul.creating_that_u;
             
            $G->T("anu: ".pint($u), undef, $u) unless u.Li;
        }
        die "no Li after T"                   unless u.Li;
           
        G.U.h.ul.done->($u) if G.U.h.ul.done;
        $u
    };
    G.U.mk = sub {#c
        G.U.ul->( 
            u => G.U.mku->(@_),
            p => G.L,
        );
    };
    
    G.U.uL_o_Lu_find = sub {#c
        my $t = shift;
        grep { $t eq _.B.Lu } findO(ux => G.L.o);
    };
    
    G.U.cu_Lu = sub {#c
        my $w = shift;
        w.Li && G.U.uL_o_Lu_find->(w.Li)
    };
    G.U.uys = sub {#c
        my ($uyB) = @_;
        #
        my $u = G.U.ul->( 
            u => G.U.mku->(uy => $uyB),
            p => G.L,
        );
        die "shunno".pty(G.L)." not have ".pint($u)
            unless grep { $_ eq $u } @{G.L.o};
        $u;
    };

  braid: |
    # Ds will be spin one day
    my $Ds = ar.Ds || T.Ds || die "No Ds to braid";
    unless (ref $Ds eq "HASH") {
        $Ds = $G->findway($Ds);
        die "malformed Ds ".wdump($Ds)
            unless ref $Ds eq "HASH";
    }
    say "braid happens";
    0->visTp({_trail=>{_no_cirles => 1}}, "Fun");
    for my $k (sort keys %$Ds) {
        # T._braid
        my $D = $Ds->{$k};
        w anTop[$D];
    }
  anTop: |
    my $ds = join "", ("   ") x 1+@{T._trail.i};
    say "anTop $ds ".join"    - ",map{my $w = $ar->{$_}; "$_ => ".pint($w)} keys %$ar;
            $DB::single = 1;
    0->visTp($ar, "Fun") if %$ar;
    T.L || die "no Line from i... antop";
    T._braid.D = ar.D if ar.D;
    $G->doo(T._braid.D); # or however

