name: spiral braid
hooks:
  any_init: |
    G.U ||= {};
    G.U.mku = sub {#c
        my ($way, $B) = @_; 
        confess "B B".wdump([@_]) if B.B;
        $B = {%$B};
        #say "L ".pint(G.L.i);
        #say "mku $way   ".join ",  ",
        #map { "$_ = ".pty($B->{$_}) } keys %$B;
        my $w = $G->nw()->from(
            $G->findway('ways/'.$way)
        )->from({ B => {%$B} });
        
        if (w._postsketch) {
            w $w _postsketch;
            delete w._postsketch;
        }
        die "makedad".wdump($w) if w.Lu && w.O ne "ux";
        $w
    };
    G.U.findu = sub {#c
        my $u = shift;
        my $L;
        for my $LL (@{$G->W->{script}}) {
            my $i = LL.i;
            if ($i eq $u) {
                $L = $LL;
                last;
            }
            elsif (u.B) {
                my $f = 0;
                #say "looking for ".wdump(2,["B",u.B, $u]);
                for my $k (keys %{u.B}) {
                    $f = 1 unless u.B->{$k} eq i.B->{$k}
                }
                unless ($f) {
                    die "FOUNDO" unless i.Li;
                }
                $L = $LL unless $f;
            }
        }
        my ($here, $g0) = (L.i, );#0->fu($u));
        #if ($here ne $g0) {
        #    Say "Findu sitchn:\n".wdump(3,[$here,'','','','','',$g0,'','','','',$u]);
        #}
            return $here || $u;
    };
    
    
    
    G.U.ul = sub {#c # look for u way
    #say "ul ";
        my $z = {@_};
        my $u = z.u;
        
        $u = G.U.findu->(z.u)                  unless u.Li;
        
        
        if (z.p){
            if (u.O eq "uy") {
                $DB::single = 1;
                0->accum(z.p, 'o', $u);
                0->accum($u, 'Loose', z.p); # .B.Lo many
            }
            else {
                0->accum(z.p, 'o', $u);
                0->accum($u, 'Lo', z.p);
            }
        }
        unless (u.Li) {
              G.U.h.ul.creating_that_u->($u)
              if G.U.h.ul.creating_that_u;
             
            $G->T("anu: ".pint($u), undef, $u) unless u.Li;
        }
        die "no Li after T"                   unless u.Li;
           
        G.U.h.ul.done->($u) if G.U.h.ul.done;
        $u
    };
    G.U.mk = sub {#c
        G.U.ul->( 
            u => G.U.mku->(@_),
            p => G.L,
        );
    };
    
    G.U.uL_o_Lu_find = sub {#c
        my $t = shift;
        grep { $t eq _.Lu } findO(ux => G.L.o);
    };
    
    G.U.cu_Lu = sub {#c
        my $w = shift;
        w.Li && G.U.uL_o_Lu_find->(w.Li)
    };
    G.U.uys = sub {#c
        my ($uyB) = @_;
        #
        my $u = G.U.ul->( 
            u => G.U.mku->(uy => $uyB),
            p => G.L,
        );
        die "shunno".pty(G.L)." not have ".pint($u)
            unless grep { $_ eq $u } @{G.L.o};
        $u;
    };
    G.U.braid_stop = sub {#c
        my $side = shift;
        my $stop = G.U.braid_stop;
        my $stops = $G->findway($side);
        my $thestop = (sort keys %$stops)[$stop] || die "not $stop on $side in G.name";
        $G->w("$side/$thestop", {});
    };
  braiT: |
    my $til;
    for my $side (qw'stoops toos') {
        my $wa = $G->findway($side);
        my $ops = 1- keys %$wa;
        die "no $side G.name" if !$ops;
        die "stoops != toos G.name" if defined $til && $til != $ops;
        $til ||= $ops;
    }
    for my $bs (0..$til) {
        G.U.braid_stop = $bs; # on T?
        w anTop(%$ar);
    }
  anTop: |
    0->visTp({i => ar.i}, "Fun") if ar.i;
    T.L || die "no Line from i... antop";
    
    U->braid_op('stoops');
    for my $o_u (@{T.L.o}) {
        w anTop(i => $o_u);
     }
    U->braid_op('toos');

