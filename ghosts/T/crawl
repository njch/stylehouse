name: ghost data structure crawl
chains:
 - K: 'HASH'#c
   arr_if: |
     ref $thing eq 'HASH'
   foreach_travel:
     each: sort keys %$thing
     next_thing: $thing->{$each}
   print: |
        $S->{each}
        
 - K: 'WayF'#c
   cracks:
     Flab: 1
     thing: 1
     F: 1
     B: 1
     #stack: 1
     #waystack: 1
     timer_from: 1
   arr_if: | 
     $S->{cracks}->{$G->{i}->{each}}
     && ref $G->{i}->{L}->{t} eq "Way"
   grav_add: 1
   
 - K: 'Waym'#c
   arr_if: | 
     my ($lM,$lB) = (
         $G->{i}->{L}->{i}->{L},
         $G->{i}->{L},
     );
     $lM && ref $lM->{t} eq "Way"
     && $lB && $lB->{i}->{each} eq "B"
     && $G->{i}->{each} eq "thing"
   grav_add: 1
   
 - K: 'Wayslim'
   arr_if: |
     ref $thing eq "Way"
   eat: "HASHish"
   each_ignore: 'id huid print B_ K arr_if first_time'
   
 - K: 'WayFF'#c
   _disabled: 1
   arr_if: |
     ref $thing eq "Way" && $thing->{F};
   foreach_travel:
     each: @{ $thing->{F} }
     next_thing: $each
   print: |
     "WF [ ".$S->{i}
   

   
   
   
   
 - K: 'GsGG'#c
   arr_if: |
     ref $thing eq "Ghost"
   foreach_travel:
     each: @{ $thing->{GG} }
     next_thing: $each
   print: |
     "GG [ ".$S->{i}
   
 - K: 'Gslim'
   arr_if: |
     ref $thing eq "Ghost"
   eat: "HASHish"
   each_ignore: 'id GG huid way T load_ways_count unrush_'
   each_order: 'name i O'
        
 - K: 'HASHish'#c
   arr_if: |
     ref $thing && "$thing" =~ /=HASH/
   foreach_travel:
     each: |
       sort keys %$thing;
     next_thing: $thing->{$each}
   print: |
        $S->{each}
     
 - K: 'ARRAY'#c
   arr_if: ref $thing eq 'ARRAY'
   foreach_travel:
     each: @$thing
     next_thing: $each
   print: |
        $S->{i}
dials:
  max_depth: 1
hooks:
  arr: |
    my @actcs;
    for my $c ($G->chains) {
        if (w $c arr_if) {
            push @actcs, $c->spawn;
        }
    }
    my @f;
    for my $c (@actcs) {
        push @f, w c_follow_as(+ c => $c);
    }
    @actcs = @f;
    @f = ();
    
    
    for my $c (@actcs) {
        if ($c->{eat}) {
            map { $_->{eaten_by} = $c } grep { $_->{K} eq $c->{eat} } @actcs;
        }
        else {
            push @f, $c;
        }
    }
    
    @actcs = @f;
    @f = ();
    
    for my $c (@actcs) {
        if (my $a = $c->{grav_add}) {
            $_->{gravity} += $c for @actcs;
        }
        else {
            push @f, $c;
        }
    }
    
    @actcs = @f;
    @f = ();
            
    for my $c (@actcs) {
        w figureout(+ c => $c);
    }
    # all these motions we want to grab finer pictures of eventually
  crank: |
    my ($dial, $to) = %$ar;
    exists $G->{$dial} || die "no $dial";
    my $o = $G->{$dial};
    my $undo = sub { $G->{$dial} = $o };
    $G->{$dial} = $to;
    $undo;
  revisit: |
    my $W = $G->RW;
    my $und = w crank(max_depth => $line->{depth} + $ar->{push_depth});
    
    $G->T($line->{t}, undef, $line->{i}, $line->{depth});
    
    $und->();
    my $N = $G->W->CS;
    my @fore;
    push @fore, shift @$W until !@$W || $W->[0]->{uuid} eq $line->{uuid};
    my $O = shift @$W;
    @$W = (@fore, @$N, @$W);
    $G->W->{script} = $W;
    return $N;
  figureout: |
    my $gravity = $c->{gravity} || $c->{as_from}->{gravity} || 0;
    my $max = $G->{max_depth} + $gravity;
    
    return if $G->{depth} >= $max;
    
    if (my $fe = $c->{foreach_travel}) {
        my @list = $G->doo(
            $fe->{each}, $ar
        );
        if (my $ei = $c->{eaten_by}->{each_ignore}) {
            @list = grep { my $on = $_; !grep { $on eq $_ } split ' ', $ei } @list;
        }
        if (my $eo = $c->{eaten_by}->{each_order}) {
             my %k = map { $_ => 1 } @list;
             my @k;
             if ($k{id} && $k{huid} && $thing->{id} =~ /$thing->{huid}$/) {
                 delete $k{huid};
             }
             for (split ' ', $eo) {
                 push @k, $_ if delete $k{$_}
             }
             for (@list) {
                 push @k, $_ if $k{$_}
             }
             @list = @k;
        }
       
        my $i = 0;
        for my $each (@list) {
            # eddies of lingo
            my $next_thing = $G->doo(
                $fe->{next_thing}, {%$ar, each => $each}
            );
            my $oc = $c->spawn; # TODO spawn a fresh chain here
            # so W Sline->{i} is nice to look at
            $oc->{travel_this} = $next_thing;
            $oc->{i} = $i++;
            $oc->{each} = $each;
            
            push @{$G->{o}}, $oc;
        }
    }
    else {
        die "canot figure out ".ki($c);
    }
  c_follow_as: |
    my $as = $c->{as};
      return $c unless $as;
    
    my @really = $G->grep_chains("K" => $as);
    @really == 1 || die "cannot find ref=$c->{as}".ddump($c).ddump(@really);
    
    my $asc = shift @really;
    my $nc = $asc->spawn;
    $nc->{as_from} = $c;
    return $nc

