name: Styluxyio
dials:
  max_depth: 7
  form: 42
chains:
 - K: xW #c
   k: ''
   arr_if: |
     $G->{depth} == 0 && ref $thing eq "Wormhole";
   B_: |
     $thing
   foreach_travel:
     each: grep { $_->{depth} == 0 } @{$thing->{script}}
   print: |
     "xW.$Li->{n}"
 
 - K: xL
   k: ''
   arr_if: |
     ($G->{i}->{K} eq "xW"
     || $G->{i}->{K} eq "xL")
     && ref $thing eq "HASH"
     && ref $thing->{o} eq "ARRAY"
   print: |
     "xL.$Li->{n}"
   foreach_travel:
     each: grep { defined $_ } map { $_->{B}->{Li} } @{$thing->{o}};
hooks:
  event: |
    my $xL = $L;
    my $yL = $xL->{t};
    my $yiw = $yL->{i};
    my $yt = $yL->{t};
    Say "Clicked on  ".pint($yiw)."\t\t".$yt;
    if ($yiw->{K} eq "Thing") {
        my $nothing = $yt;
        $O Tw arr[$nothing];
    }
  html: |
        my $Bs = $tw->{B}->{s} ||= {};
        my $c = $Bs->{x};
        my $attr = {};
        my @style = ();
        my @class = ();
        for my $a (qw{id}) {
            $attr->{$a} = $c->{$a} if exists $c->{$a};
        }
        for my $a (qw{height width left top}) {
            if (exists $c->{$a}) {
                my $v = $c->{$a};
                $v = ($v * 100).'%' if $v !~ /em$/;
                push @style, "$a:$v"; 
            }
        }
        if ($c->{height} =~ /em$/ && $c->{width} == 1) {
            push @style, "float:left";
        }
        if (exists $c->{left} || exists $c->{top}) {
            push @style, "position:absolute";
        }
        if ($c->{class}) {
            push @class, @{$c->{class}};
        }
        if ($c->{style}) {
            for my $styley (@{$c->{style}}) {
                my $styles = [ ref $styley eq "ARRAY" ? @$styley : $styley ];
                push @style, @$styles;
            }
        }
        #$attr->{title} = $tw->{B}->{Lo}->{depth}." ".pint($tw)." ~ ".pint($tw->BLi->{t}->{i});
        
        my $tag = $c->{tag} || "te";
        if (!defined $tw->{B}->{Lo}) {
            $tag = "wormhole";
            my $W = $G->W;
            $attr->{title} = $G->{name};
            ($attr->{id}) = $W->{id} =~ /-(\w+)$/;
        }
        my $content = defined $c->{content} ? $c->{content} : "";
        my $cc = $c->{children};
        if ($cc && @$cc) {
            $content && die " $content and ".join "", @{$c->{children}};
            $content = join "", @{$c->{children}};
            $attr->{style} = join "; ", @style if @style;
        }
        $attr->{style} = join "; ", @style if @style;
        $attr->{class} = join " ", @class if @class;
        
        return "<$tag ".join(" ", map {"$_=\"$attr->{$_}\""} sort keys %$attr).">"
        ."\n".ind("  ", $content)."\n"."</$tag>\n"
    
    
    
    
    # etc
    
        
    
  T_end: |
    my $t = $G->{_trail} ||= [];
    my $xL = $L; 
    
    my $yL = $xL->{t};
    my $ytw = [];
    my $ylw = [];
    for my $yw (@{$yL->{o}}) {
        if ($yw->{B}->{Li}) {
            push @$ytw, $yw
        }
        else {
            push @$ylw, $yw
        }
    }
    my $xtw = [];
    for my $xw (@{$xL->{o}}) {
        if ($xw->{B}->{Li}) {
            push @$xtw, $xw
        }
    }
    my $yiw = $yL->{i} || $G->nw()->from({K=>"notTheWayIn!"});
    my $xiw = $xL->{i} || $G->nw()->from({K=>"xnotTheWayIn!"});
    
    my $h = {};
    my $ha = sub { 
        my ($attr,$y,$w,$thing) = @_;
        push @{$h->{$attr}||=[]}, { y=>$y,w=>$w,t=>$thing };
    }; 
    
    my $x = {id=>$xL->{uuid}};
     
    for my $ya (['l',$ylw],['t',$ytw],['i',[$yiw]],['x',[$xiw]]) {
        my ($y,$yww) = @$ya;
        for my $w (@$yww) {
            next unless $w && ref $w eq "Way";
            
            w u[$xL, $yL, $ylw, $ytw, $yiw, $xiw, $xtw,        $y, $w, $ha];
        }
    }
    
    w h[$xL, $yL, $ylw, $ytw, $yiw, $xiw, $xtw,         $h, $x];
    
    
    #w diagontrail[$xL, $yL, $ylw, $ytw, $yiw, $xiw,     $h, $x];
    
    return unless $xL->{depth} == 0;
    
    my $tw = $xiw;
    @$r = w html[$xL, $yL, $ylw, $ytw, $yiw, $xiw, $xtw, $tw];
  h: |
    # grep $h for content, apply whittling...
    my $hg = sub {
        my ($what, $order) = @_;
        my $got = $h->{$what} || [];
        my $ok = [];
        for my $yg (split ',', $order) {
            for my $t (@$got) {
                push @$ok, $t if $t->{y} eq $yg;
            }
        }
        $ok;
    };
    my $content = $hg->('content', 'l,i');
     @$content > 1 && die "cont > 1";
    
    if (!@$content && !@$ytw) {
        #Say "Inventing content... $yL->{i}->{K}";
        @$content = {y=>"?",t=>encode_entities($yL->{t})};
    }
    @$content && @$ytw && die "cont & t";
    if (@$content) {
        $x->{content} = $content->[0]->{t}; # favouring loose style over wayin
    }
    
    my $class = $h->{class} || [];
    for (@$class) {
        push @{$x->{class}||=[]}, $_->{t}
    }
    my $styles = $hg->('style', 'i,l');
    for (@$styles) {
        push @{$x->{style}||=[]}, $_->{t}
    }
    
    my $todiv =  $hg->('div', 't');
    my $div =  $hg->('div', 'l,i');
    if (@$ytw && !@$div) {
        #$H->error("no div & things".wdump(2, $ytw));
        #exit;
    }
    if (@$div) { 
        $H->error("multi div", $div, wdump(2, $h->{div}), $yL->{t}->{t}) if @$div > 1;
        my $v = $div->[0]->{t};
        my $vi = {};
        ($vi->{width},$vi->{height}) = split "x", $v; $v =~/^x/&&die"?";
        while (my ($iv, $parts) = each %$vi) {
            if (!$parts) {
                next;
            }
            my $inc;
            if ($parts =~ /em$/) {
                $inc = $parts;
                $parts = 1;
            }
            if ($parts eq "...") {
                $parts = 0+@$xtw;
            }
            if ($parts == 0) {
                $parts = 1;
            }
            $inc ||= 1 / $parts;
            my $side = $iv eq "width" ? "left" : "top";
            my $i = 0;
            
            for my $tw (@$xtw) {
                my $Bs = $tw->{B}->{s} ||= {};
                if ($parts == 1) {
                    $Bs->{x}->{$iv} = $inc;
                }
                else {
                    $Bs->{x}->{$side} = $i;
                    $i += $inc;
                    $Bs->{x}->{$iv} = $inc;
                }
            }
        }
    }
    
    
    for my $tw (@$xtw) {
        my $html =  w html(%$ar, tw => $tw);
        push @{ $x->{children} ||= [] }, $html;
        
        #font-size-adjust: 0.58;
    }
    
    $xiw->{B}->{s}->{x} = $x;
    
    
  up:
    - h: value
      escape_html: 1
      hh: content
      
    - h: conty
      hh: content
      
    - hh: div
    - h: y_div
      hh: div
    - hh: class
    - hh: style
    - h: y_style
      hh: style
  u: |
    my @wup = $G->findways('up');
    for my $up (@wup) {
        my $v = $up->{h} 
            ? $G->w("B/s/$up->{h}", {}, $w)
            : $w->find("B/s/$up->{hh}");
        next unless defined $v;
        $v = encode_entities($v) if $up->{html};
        $ha->( $up->{hh} => $y,$w, $v );
    }
    
  diagontrail: |
    my $htalk = "";
    while (my ($attr, $hh) = each %$h) {
        $htalk .= join("\n", "$attr:", map{"  ".ki($_)} @$hh)."\n";
    }
    my $xt = join "", map { "$_\n" } @{$x->{children}};
    $xt .= "  $_:$x->{$_}" for grep { $_ ne 'children'} keys %$x;
    my $diag = {
       #"an thing" => ghostlyprinty($yL->{t}),
        "D" => join("",("DDDD")x$yL->{depth}), 
        h => $htalk,
        x => $xt,
        X => $xiw->{B}->{s}->{x}, 
    };
    
    my $ytalk = "!html ";
    for my $ya (['l',$ylw],['t',$ytw],['i',[$yiw]]) {
        my ($y,$yww) = @$ya;
        $ytalk .= join "", map {
            "$y ".
            (ref $_ eq "Way" ?
            ($_->pint.'<t style="color:white;">'.ki($_->{B} ? $_->{B}->{s} : {}).'</t>')
            : "iww!www: $_")."\n"
        } @$yww
    }
    $diag->{ytalk} = $ytalk;
    push @{ $G->{_trail} }, $diag;
   

