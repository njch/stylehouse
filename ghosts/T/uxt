name: Styling
dials:
  max_depth: 7
  form: 42
hooks:

  T_end: |
    my $t = $G->{_trail} ||= [];
    my $xL = $L; 
    
    my $yL = $xL->{t};
    my $ytw = [];
    my $ylw = [];
    for my $yw (@{$yL->{o}}) {
        if ($yw->{B}->{Li}) {
            push @$ytw, $yw
        }
        else {
            push @$ylw, $yw
        }
    }
    my $xtw = [];
    for my $xw (@{$xL->{o}}) {
        if ($xw->{B}->{Li}) {
            push @$xtw, $xw
        }
    }
    my $yiw = $yL->{i} || $G->nw()->from({K=>"notTheWayIn!"});
    my $xiw = $xL->{i};
    
    my $h = {};
    my $ha = sub { 
        my ($attr,$y,$w,$thing) = @_;
        push @{$h->{$attr}||=[]}, { y=>$y,w=>$w,t=>$thing };
    }; 
    
    my $x = {id=>$xL->{uuid}};
     
    for my $ya (['l',$ylw],['t',$ytw],['i',[$yiw]]) {
        my ($y,$yww) = @$ya;
        for my $w (@$yww) {
            next unless $w && ref $w eq "Way";
            
            w u[$xL, $yL, $ylw, $ytw, $yiw, $xiw, $xtw,        $y, $w, $ha];
        }
    }
    
    w h[$xL, $yL, $ylw, $ytw, $yiw, $xiw, $xtw,         $h, $x];
    
    
    w diagontrail[$xL, $yL, $ylw, $ytw, $yiw, $xiw,     $h, $x];
    
    return unless $xL->{depth} == 0;
    
    @$r = w html(tw=>$xiw);
  h: |
    # grep $h for content, apply whittling...
    my $content = $h->{content} || [];
    $content = [grep { $_->{y} ne 't' } @$content];
    $content = [
        (grep { $_->{y} eq 'l' } @$content),
        (grep { $_->{y} eq 'i' } @$content),
    ];
    $H->error("multiple contents", $content) if @$content > 1;
    
    if (!@$content && !@$ytw) {
        @$content = {y=>"?",t=>encode_entities($yL->{t})};
    }
    if (@$content && @$ytw) {
        $H->error("contents & things", $content, $ar);
        @$content = ();
    }
    if (@$content) {
        $x->{content} = $content->[0]->{t}; # favour loose style over wayin
    }
    
    my $div = $h->{div} || [];
    my $todiv = [ grep { $_->{y} eq 't' } @$div ];
    my $div = [
        (grep { $_->{y} eq 'l' } @$div), 
        (grep { $_->{y} eq 'i' } @$div),
    ];
    if (@$ytw && !@$div) {
        #$H->error("no div & things".wdump(2, $ytw));
        #exit;
    }
    if (@$div) { 
        $H->error("multi div", $div) if @$div > 1;
        my $v = $div->[0]->{t};
        my $vi = {};
        ($vi->{width},$vi->{height}) = split "x", $v; $v =~/^x/&&die"?";
        while (my ($iv, $parts) = each %$vi) {
            if (!$parts) {
                next;
            }
            my $inc;
            if ($parts =~ /em$/) {
                $inc = $parts;
                $parts = 1;
            }
            my $inc = 1 / $parts;
            my $side = $iv eq "width" ? "left" : "top";
            my $i = 0;
            
            for my $tw (@$xtw) {
                my $Bs = $tw->{B}->{s} ||= {};
                if ($parts == 1) {
                    $Bs->{x}->{$iv} = $inc;
                    die "$iv = $inc $parts" if $inc =~ /em$/; 
                }
                else {
                    $Bs->{x}->{$side} = $i;
                    $i += $inc;
                    $Bs->{x}->{$iv} = $inc;
                }
            }
        }
    }
    
    for my $tw (@$xtw) {
        push @{ $x->{children} ||= [] },
        
            w html(%$ar, tw => $tw);
    
        #font-size-adjust: 0.58;
    }
    
    $xiw->{B}->{s}->{x} = $x;
    
    
  html: |
        my $Bs = $tw->{B}->{s} ||= {};
        my $c = $Bs->{x};
        my $attr = {};
        my @style = ();
        for my $a (qw{id}) {
            $attr->{$a} = $c->{$a} if exists $c->{$a};
        }
        for my $a (qw{height width left top}) {
            if (exists $c->{$a}) {
                my $v = $c->{$a};
                $v = ($v * 100).'%' if $v !~ /em$/;
                push @style, "$a:$v";
            }
        }
        $attr->{title} = ref $tw eq "Way" ? $tw->pint : wdump(2,$tw);
        #push @style, "position:absolute;";
        if (@style) {
            $attr->{style} = join "; ", @style;
        }
        
        my $tag = $c->{tag} || "te";
        my $content = defined $c->{content} ? $c->{content} : "";
        my $cc = $c->{children};
        if ($cc && @$cc) {
            $content && die " $content and ".join "", @{$c->{children}};
            $content = join "", @{$c->{children}};
        }
        
        return "<$tag ".join(" ", map {"$_=\"$attr->{$_}\""} sort keys %$attr).">"
        ."\n".ind("  ", $content)."\n"."</$tag>\n"
    
    
    
    
    # etc
    
        
    
  up:
    - h: value
      escape_html: 1
      hh: content
      
    - h: conty
      hh: content
      
    - hh: div
  u: |
    my @wup = $G->findways('up');
    for my $up (@wup) {
        my $v = $up->{h} 
            ? $G->w("B/s/$up->{h}", {}, $w)
            : $w->find("B/s/$up->{hh}");
        $v = encode_entities($v) if $up->{html} && defined $v;
        $ha->( $up->{hh} => $y,$w, $v ) if defined $v;
    }
    
  diagontrail: |
    my $htalk = "";
    while (my ($attr, $hh) = each %$h) {
        $htalk .= join("\n", "$attr:", map{"  ".ki($_)} @$hh)."\n";
    }
    my $xt = join "", map { "$_\n" } @{$x->{children}};
    $xt .= "  $_:$x->{$_}" for grep { $_ ne 'children'} keys %$x;
    my $diag = {
       #"an thing" => ghostlyprinty($yL->{t}),
        "D" => join("",("DDDD")x$yL->{depth}), 
        h => $htalk,
        x => $xt,
        X => $xiw->{B}->{s}->{x}, 
    };
    
    my $ytalk = "!html ";
    for my $ya (['l',$ylw],['t',$ytw],['i',[$yiw]]) {
        my ($y,$yww) = @$ya;
        $ytalk .= join "", map {
            "$y ".
            (ref $_ eq "Way" ?
            ($_->pint.'<t style="color:white;">'.ki($_->{B} ? $_->{B}->{s} : {}).'</t>')
            : "iww!www: $_")."\n"
        } @$yww
    }
    $diag->{ytalk} = $ytalk;
    push @{ $G->{_trail} }, $diag;
   

