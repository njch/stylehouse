name: Trabambeist
hooks:

  T:
    flows: | #c
      my $cs = [];
      my $doing = sub {
        my $w = shift;
        my @rc;
        for my $c (@$cs) {
              my $rc = $G->w($w, {c=>$c,cs=>$cs});
            push @rc, $rc if $rc;
        }
        @$cs = @rc;
      };
    
      my @chains = w chains;
      for my $c (@chains) {
          if (w $c arr_if) {
              push @$cs, $c->spawn;
          }
      }

      $doing->("c_follow_as");
      $doing->("c_eat");
      $doing->("c_grav_add");
      $doing->("figureout");
      w aft_arr;
    travels: | #c
        for my $c (@{T.o}) {
            next if c.dont;
            next unless exists c.travel_this || c.travels;
            
            my $p = {
              depth => T.depth+1, 
              t => c.travel_this,
              i => $c,
            };
            my $for = T.i;
            0->T($p);
            die "Argh!~!" unless $for eq T.i;
        }
  chains: |
    my @chains = grep { !$_->{_disabled} } map { @{$_} } $G->anyway('chains');
  
    @chains = grep {
        !defined _.iK || T.i.K =~ /_.iK/
    } @chains;
    
    @chains = grep {
        !defined _.exact_depth || _.exact_depth == T.depth
    } @chains;
    
    my @dom = grep {
        defined _.dom_depth && _.dom_depth == T.depth
    } @chains;
    @chains = @dom if @dom;
    
    @chains
  c_eat: |
    return $c unless c.eat;
    for my $oc (@$cs) {
        if (oc.K eq c.eat) {
            oc.eaten_by = $c
        }
    }
  c_grav_add: |
    return $c unless c.grav_add;    
    for my $oc (@$cs) {
        oc.gravity += c.grav_add 
    }
  revisit: | # TODO
    my $W = 0->RW($G);
    my $und = $G->crank(maxd => $line->{depth} + $ar->{push_depth});
    
    $G->T($line->{t}, undef, $line->{i}, $line->{depth});
    
    $und->();
    my $N = $G->W->CS;
    my @fore;
    push @fore, shift @$W until !@$W || $W->[0]->{uuid} eq $line->{uuid};
    my $O = shift @$W;
    @$W = (@fore, @$N, @$W);
    $G->W->{script} = $W;
    return $N;
  figureout: |
    my $gravity = $c->{gravity} || $c->{as_from}->{gravity} || 0;
    my $max = $G->{maxd} + $gravity;
    
    return if $T->{depth} >= $max;
    
    if (my $fe = $c->{foreach_travel}) {
        w figure_foreach_travel;
    }
    elsif (w figure_some_chain(c=>$c)) {
        # sweet
    }
    else {
        die "canot figure out ".ki($c);
    }
    
    w aft_figureout;
  figure_foreach_travel: |
        my $fe = $c->{foreach_travel};
        my @list;
        if ($fe->{each}) {
            push @list, $G->doo($fe->{each}, $ar);
        }
        if (my $ei = $c->{eaten_by}->{each_ignore}) {
            @list = grep { my $on = $_; !grep { $on eq $_ } split ' ', $ei } @list;
        }
        if (my $eo = $c->{eaten_by}->{each_order}) {
             my %k = map { $_ => 1 } @list;
             my @k;
             if ($k{id} && $k{uuid} && $thing->{id} =~ /$thing->{uuid}$/) {
                 delete $k{uuid};
             }
             for (split ' ', $eo) {
                 push @k, $_ if delete $k{$_}
             }
             for (@list) {
                 push @k, $_ if $k{$_}
             }
             @list = @k;
        }
       
        my $i = 0;
        for my $each (@list) {
            # eddies of lingo
            my $next_thing = $fe->{next_thing} ? $G->doo(
                $fe->{next_thing}, {%$ar, each => $each}
            ) : $each;
            my $oc = $c->spawn; # TODO spawn a fresh chain here
            # so W Sline->{i} is nice to look at
            $oc->{travel_this} = $next_thing;
            $oc->{i} = $i++;
            $oc->{each} = $each;
            
            push @{T.o}, $oc;
        }
  c_follow_as: |
    return $c unless $c->{as};
    
    my @really = $G->grep_chains("K" => $c->{as});
    @really == 1 || die "cannot find ref=$c->{as}".ddump($c).ddump([@really]);
    
    my $asc = shift @really;
    my $nc = $asc->spawn;
    $nc->{as_from} = $c;
    return $nc

