R_Jz:
 - K: make #c
   n_D:
     up: |
       H.GL = $R;
       Rw loadc $l=w/k;
       
       #die wdump 2, R.way.oo;
       
       my $t = Rw wuck - */flows/*;
       my $fr = 0;   
       my $amp = G.ampampamp ||= do{$fr=1;{}};
       for my $k (sort keys %$t) {
           my $v = $t->{$k};
           my ($path,$flows,$from) = split '/', $k;
           
           Rw make/op $amp $pin:k $path $from;
       }
       my $hk = {%{R.way.hooks}};
       for my $z ($hk, $amp) {
           for my $k (keys %$z) {
               next unless $k =~ /^g_(.+)$/;
               say "Has $k";
               $z->{$1} = delete $z->{$k};
           }
       }
       my $x;
       x.wormhole.yr = $hk;  
       x.wormhole.ya = $amp;
       while (my ($dir, $v) = each %$x) {
           while (my ($k, $d) = each %$v) {
               my $y = YAML::Syck::Dump($d);
               die wdump $y if length $y < 50; 
               $y =~ s/^---//;
               encode_utf8 $y;
               fspu("$dir/$k\.yml", $y);
           }    
       }
       
       # maka yml, seeing .s is a gas leak
       `cd wormhole; cat yr\.yml ya\.yml > yb\.yml`;
       #$fr = 1;
       $fr ?
       $G->pub('S/'.$_, "reexec")
       :
       $G->pub('S/'.$_, "wayup w/yb\.yml") for 'shed','coast';
       sayyl "We o ".F_delta();
       
       Rwyl 0.1 J5 scr;
     op: | #c amplify options
       my $J = {};
       Rw suJ $J;
       Rw thi $J $pin;
       
       my $vs = Rw tyv $J;
       @$vs||die $pin;
       Rw suJ $J;
       
       my $M = [];
       
       for my $lv (@$vs) { 
           my $j = lv.j;
           # potential ab pathy via cs craziness at ~/flows/$k M...
           my $Z = Rw muck - $pin=$from/j.l;
           if (!%$Z) {
               for my $nam (split ',', lv.sc.pa) {
                   $Z = Rw muck - $pin=$nam/j.l;
                   if (%$Z) {
                       saygr "$path inherits j.l from $nam  ,,,, $from";
                       last;
                    }
               }
               die "nothing from $from/j.l   fo  j.r  ###sc: ".ki lv.sc if !%$Z;
           } 
           
           
          
           
           for my $k (sort keys %$Z) {
               my $s = $Z->{$k};
               
               my @N = ref $s eq 'ARRAY' ? do {
                   my $M = [];
                   Rw MyN $N:s $M;
                   @$M;
               }
               :
               ref $s eq 'HASH' ? do {
                   die 'possible lma fire...'
               }
               :
               ref $s ? die "no $s" : do {
                   my $M = [];
                   my $i = 0.01;
                   my @cs;
                   my $up = sub {
                       @cs || return "nothing in j.l $i";
                       my $c;
                       c.t = j.l;
                       c.y.cv = $i;
                       c.s = join "\n", @cs;
                       c.sc = lv.sc;
                       push @$M, $c;
                       @cs = ();
                   };
                   if (j.cv == 1) {
                       sayyl "splitting j.l for $path   j.cv";
                       for my $l (split "\n", $s) {
                           if ($l =~ /^\s*# (\d\S*)/) {
                               my $ni = $1;
                               $up->();
                               $i = $ni;
                           }
                           push @cs, $l;
                       }
                       $up->();
                   }
                   else {
                       sayyl "sc atchs j.l for $path j.cv";
                       push @cs, $s;
                       $i = j.cv;
                       $up->();
                   }
                   @$M; 
               };
               
               !$path && die "noapth";
               push @$M, @N;
           }
       }
       
       my $h = G.gekoodiu ||= {};
       my $e = sjson $M;
       #return saygr "$path same" if $e eq $h->{$path};
       
       $h->{$path} = $e;
       
       for my $c (@$M) {
           Rw Nucl $c $path $J;
       }
       
       my $wtf = Rw concat $J;
       #sayre wdump wtf.lief_up if $path eq 'lief';
       my $real = Rw wtfity $wtf;
       #ie wdump $real;
       
       for my $pin (sort keys %$real) {  
           my $n = $real->{$pin};
           sayyl "&&&&&&&&&&&&&&&&&&&&& Loadinup $pin";
           Rw loadup $u:amp $pin $n;
       #    Rw loadup $u:wJ.way $pin $n;
       }
       
       #$wJ
 - K: Nucl #c
   D: |
     my (@l,@lr,@r);
     c.K ||= c.t;
     c.K || die;
     c.v ||= c.y.cv;
     c.v ||= 3;
     c.v += 0;
          
     my $ome = c.K; # as uncompressed in the bb key? wtf if K dup
          
     die c.v if c.v !~ /^\d/;

     # if for c.cs, for implant condits # sche
     my $cv = c.v;
     my $D = c.s || c.c.s;
     my $type = G.drop.conv->($cv);
     # z downgrasp (ty above) self if MZ
     my $sc;
     $sc = c.sc.MZ if c.sc && c.sc.MZ;
     my $ty = {};
     $sc ||= $ty->{$type};
     $sc ||= {};
     $sc = {%$sc, %{c.sc}} if c.sc;
     c.sc = $sc;
     sc.com = "# c.v c.K sc.com";
     
     my $up_path = sub {
         J.bz->("$path#up\t1","my \$wJ={}; 
            \$wJ = G\.drop\.$path\.wJ ||= Rw\ ${path}_up \$wJ;");
         J.bz->("${path}_up#return\t9", "\$wJ;");
     };
     
     # per $path if maybe ?? emberd whatsits
     # some special K of c may have meta for this too
     if (my $sub = sc.sh) { #c
                   unshift @l, "G\.drop\.$path\.$sub\.c.K = sub {";
                   if (my $args = $sc->{"sh_${sub}_args"}) {
                       push @lr, '    my ('.$args.') = @_;';
                   }
                   $D = ind '    ', $D;
                   push @r, '};';
                   if (my $list = sc.droplist) {
                       push @r, "push \@{G\.drop\.$path\.$list}, 'c.K';"; 
                       J bz ${path}_$sub#rese$list 1 "G\.drop\.$path\.$list = [];"
                   }
                   my $haD = join "\n", (sc.com||"#!?"), @l, @lr, $D, @r;
                   @l = (); @lr = (); @r = ();
                   
                   # makes $X or so lexical
                   J.bz->("${path}_$sub#rese\t1", "my \$$sub = G\.drop\.$path\.$sub = {};");
                   J.bz->("${path}_$sub#$ome\t$cv", $haD);
                   J.bz->("${path}_$sub#return\t9", "G\.drop\.$path\.$sub;");
                   J.bz->("$path#upsubhash-$sub\t1",
                     "my \$$sub = G\.drop\.$path\.$sub ||= Rw ${path}_$sub;");
                     
                   return; #
     }
     # see twisty ops in lightcones
     # could resolve curve embeddings like this
     # same in bush of stuff to cv out
     # cv in 
          
          if (my $cs = sc.qmco) { #c
              push @l, ':', "\$tk eq 'c.K' ? do {";
              if (my $sub = sc.subhash) {
                  $D = "G\.drop\.$path\.$sub\.c.K->(\$v, \$tks)";
              }
              $D = ind '     ', $D;
              push @r, '}';
          }
          
          # if (sc.this) { DO } +
               if (my $cs = sc.csfrm) { #c
                   $cs = c.K if $cs eq 'cK';
                   sc.com .= "# cs=$cs  ";
                   unshift @l, "if (exists c\.$cs) {"
                       ."\n    my \$cs = c\.$cs;";
                   $D = ind '     ', $D;
                   push @r, '}';
               }
                
               if (sc.tv) { #c
                   # lets D
                   my $d = {%$c};
                   d.wa = $path.'__'.c.K;
                   J.bz->("d.wa\t1", $D);
                   
                   $up_path->();
                   
                   J.bz->("${path}_up#rese_tvs\t1", 
                    "wJ\.tvs = [];"
                   );
                   delete d.s;
                   J.bz->("${path}_up#tv$ome\t$cv",
                   "push \@{wJ\.tvs}, djson(q[".ejson($d)."]);");
                   
                   return;
               }
                
     if (my $C = sc.ct) { #c
         # lets C
         my $sub = c.t;
         if (sc.nx) {
             # sub has no cv index
             # like we are making a sub if
         }
         else {
             $sub = c.t.'_'.c.v;
             $sub =~ s/\.//sg;
         }
         
         sayyl "$C c.t   for ".ki $sc if $path eq 'lief';
         
         my @s;
         my $d;
         d.t = c.t;
         d.x = $sub;
         $d->{$_} = sc.dat->{$_} for keys %{sc.dat||{}};
         d.t_k = sc.t_k if sc.t_k;
         
         
         push @s, "push \@{wJ\.cts\.$C}, djson(".ejson(ejson($d)).");"
             if !sc.nx;
         push @s, "wJ\.ctx\.".$C.'->{"'.$sub.'"} = sub {';
         my $args;
         if ($args = $sc->{"ct_${C}_args"}) {
             push @s, "    my ($args) = \@_;";
         }
         if (sc.way) {
             my $wp = "${path}_${C}_${sub}";
             J.bz->("$wp\t1", $D);
             $args =~ s/,/ /sg;
             $D = 'Rw'." $wp $args;";
             
         }
         $D = ind '    ', $D;
         push @s, "$D";
         push @s, "};";
         $D = join "\n", (sc.com||"#!?"), @s;
         # makes $X or so lexical
         
         $up_path->();
         
         J.bz->("${path}_up#rese$C\t1", 
          "wJ\.ctx\.$C = {};"
         ."wJ\.cts\.$C = [];"
         );
         J.bz->("${path}_up#$C$ome\t$cv", $D);
         
         return; #
     }
     if (my $C = sc.cl) { #c
         # lets C
         my $sub = c.t;
         if (!sc.nx) {
             $sub = c.t.'_'.c.v;
             $sub =~ s/\.//sg;
         }
         # avalanche cooker
         # watery hydrosoul
         # manuka oil ^ wash
         # for mastitis, cleans cows udders and the rivers as it goes
         # knowledge is like wine" - Pete
         # "if it's incomplete its the antiknowledge
         
         sayyl "$C CL c.t   for ".ki $sc;
         
         my $sob = $C.'_'.$sub;
         
         # boiler
         J.bz->("$path#up\t1","use F_$path;
         my \$wJ = G\.drop\.$path\.wJ ||= new F_$path();");
         
         J.bz->("F_${path}#new\t1", "package F_$path;
         sub new {
             my \$wJ = bless {}, 'F_$path';
             \$wJ->up;
             \$wJ;
         }");
         J.bz->("F_${path}#up\t1.2",
         "sub up {
             my \$wJ = shift;
         ");
         # index
         J.bz->("F_${path}#in/$C\t2",
          "wJ\.ctx\.$C = {};"
         ."wJ\.cts\.$C = [];"
         );
         J.bz->("F_${path}#in/$C/c.v/c.t\t3",
             "push \@{wJ\.cts\.$C}, {t=>'c.t',x=>'$sob'};")
             unless sc.nx;
         J.bz->("F_${path}#epcto\t2.9", "}");
         # chunk
         J.bz->("F_${path}#Cts/$C/c.t/c.v\t3", $_) for do {
             my $args;
             join "\n", grep{defined}
                 (sc.com||"#!?"),
                 "sub $sob {",
                 do{if($args = $sc->{"ct_${C}_args"}) {
                    "    my ($args) = \@_;"
                 }},
                 do{
                     if (sc.way) {
                         my $wp = "${path}_${C}_${sub}";
                         J.bz->("$wp\t1", $D);
                         $args =~ s/,/ /sg;
                         $D = 'Rw'." $wp $args;";

                     }
                     # TODO ind for where
                     $D = ind '    ', $D;
                     $D;
                 },
                 "}"
         };
         
         
         return; #
     }
               
               $D = join "\n", (sc.com||"#!?"), @l, @lr, $D, @r;
               J.bz->("$path#$ome\t$cv", $D);
 - K: flow #c K-flow
   D: |
     my ($name) = delete(ar.name) || @{delete ar.m};
     my $wJ = Rw oJ $J $name $style=fl;
     Rw fl/up + $J:wJ;
 - K: fl #c stitch at/cs solvents via $wJ/flows/M(Carbony patchbay)
   n_D:
     yJ: |
       'fl'
     up: |
       my $h = slm 8, dig ejson[J.Jo.style,J.name];
       
       my $wJ = G.drop.flows->{$h} ||= Rw fl/op + $h;
       
       saybl "Flop: ".F_delta;
       
       return $wJ if ar.re;
       
       my $Jo = ar.oJ || J.Jo;
       saygr wdump wJ.way if Jo.V;
       Rw wJ.hw/flow $J:Jo $fJ:J $wJ;
       #   enter ^ for ^ bits ^ loaf ^
       
       saybl "Flow: ".F_delta;
       # (lost bits) 
     op: | #c amplify options
       Rw thy $J:J.Jo $oJ:J flows/J.name;
       # <stuff>
       my $wJ;
       wJ.hw = "fl/h/$h";
       Rw suJ $J:wJ;
       
       my $vs = Rw tyv $J;
       @$vs||die;
       
       # the point to throw at if there is one
       my $path;
       
       for my $lv (@$vs) { 
           my $j = lv.j;
           sayre "Stitchup j.r    ".ki lv.sc;
           # potential ab pathy via cs craziness at ~/flows/$k M...
           my $Z = Rw muck - J.name/j.l;
           if (!%$Z) {
               for my $nam (split ',', lv.sc.pa) {
                   $Z = Rw muck - $pin=$nam/j.l;
                   if (%$Z) {
                       saygr "J.name inherits j.l from $nam";
                       last;
                    }
               }
               die "nothing from J.name/j.l   fo  j.r  ###sc: ".ki lv.sc if !%$Z;
           }
           for my $k (sort keys %$Z) {
               my $s = $Z->{$k};
               
               if (G.drop.conv->(j.cv) eq 'YIN') {
                   $path = j.l;
               }
               
               my @N = ref $s eq 'ARRAY' ? do {
                   my $M = [];
                   Rw MyN $N:s $M;
                   @$M;
               }
               :
               ref $s eq 'HASH' ? do {
                   die 'possible lma fire...'
               }
               :
               ref $s ? die "no $s" : do {
                   my $M = [];
                   my $i = 0.01;
                   my @cs;
                   #sayre $s if j.l =~ /flow/;
                   my $up = sub {
                       @cs || return "nothing in j.l $i";
                       my $c;
                       c.t = j.l;
                       c.y.cv = $i;
                       c.s = join "\n", @cs;
                       c.sc = lv.sc;
                       push @$M, $c;
                       @cs = ();
                   };
                   for my $l (split "\n", $s) {
                       if ($l =~ /^\s*# (\d\S*)/) {
                           my $ni = $1;
                           $up->();
                           $i = $ni;
                       }
                       push @cs, $l;
                   }
                   $up->();
                   @$M;
               };
               !$path && die "noapth";
               
               for my $c (@N) {
                   Rw Nucleoues $c $path $oJ:J $J:wJ;
               }
           }
       }
       
       my $coms = {};
       my $wtf = Rw concat $J:wJ $coms;
       
       my $real = Rw wtfity $wtf;
       
       wJ.way = {};
       for my $pin (sort keys %$real) {
       sayyl "Loadinup $pin";
           my $n = $real->{$pin};
           Rw loadup $u:wJ.way $pin $n;
       }
       Rw loadup $u:R.way.hooks $pin:wJ.hw $n:wJ.way;
       
       $wJ
 - K: wtfity #c
   D: |
     my $real = {};
     
     for my $l (sort keys %$wtf) {
         my $cvs = $wtf->{$l};
         
         for my $cvit (sort keys %$cvs) {
             my $v = $cvs->{$cvit};
             
             my $type = G.drop.conv->($cvit);
             # con cvit # make zp(1) to round zero point numbers to 1, etc
             
             $v = join "\n", @$v;        # # <<<<<<<
             
             if ($type eq 'YIN') {
                 $real->{$l} = $v;
                 #die "split: $v";
             }
             else {
                 $real->{$l} || die;
                 $real->{$l} .= "\n$v";
                 #$real->{$l} =~ s/(# $type.*?)$/$1\n$v/sm
                 #   || die "no $type in $l ... $real->{$l}";
             }
         }
     }
     
     $real
       
 - K: concat #c tlv -> wtf.$l.$cvit [ j.s
   D: |
       # shove togeth modn
       # get a cv sorter  that puts 3 > 32, since 3 is 3 all the way down > 3232323...
       # tesalation
       my $vs = Rw tlv $J;
       # ^ hash styles, things are l+com, like $tks
       my $wtf;
       for my $lv (@$vs) {
           my $j = lv.j;
           die if !%$j;
           
           lv.sc && die "wop";
           
           my $was = $wtf->{j.l} ||= {};
           
           acum $was, G.drop.vonc->(j.cv), j.s;
           # aggs to wanted dp, fractionated in as the src wants, in the order of tlvness
           # <<<<<<< cv collapse unto elements #? rel src to round cv...
       }
       $wtf
 - K: Nucleoues #c
   D: |
     my (@l,@lr,@r);
     c.K ||= c.t;
     c.K || die;
     c.v ||= c.y.cv;
     c.v ||= 3;
     c.v += 0;
          
     my $ome = c.K; # as uncompressed in the bb key? wtf if K dup
          
     die c.v if c.v !~ /^\d/;

     # if for c.cs, for implant condits # sche
     my $cv = c.v;
     my $D = c.s || c.c.s;
     my $type = G.drop.conv->($cv);
     # z downgrasp (ty above) self if MZ
     my $sc;
     $sc = c.sc.MZ if c.sc && c.sc.MZ;
     my $ty = {};
     $sc ||= $ty->{$type};
     $sc ||= {};
     $sc = {%$sc, %{c.sc}} if c.sc;
     c.sc = $sc;
     sc.com = "# c.v c.K sc.com";
     # per $path if maybe ?? emberd whatsits
     # some special K of c may have meta for this too
     if (my $sub = sc.sh) {
                   unshift @l, "wJ\.drop\.$path\.$sub\.c.K = sub {";
                   if (my $args = $sc->{"sh_${sub}_args"}) {
                       push @lr, '    my ('.$args.') = @_;';
                   }
                   $D = ind '    ', $D;
                   push @r, '};';
                   if (my $list = sc.droplist) {
                       push @r, "push \@{wJ\.drop\.$path\.$list}, 'c.K';"; 
                       J bz ${path}_$sub#rese$list 1 "wJ\.drop\.$path\.$list = [];"
                   }
                   my $haD = join "\n", (sc.com||"#!?"), @l, @lr, $D, @r;
                   @l = (); @lr = (); @r = ();
                   
                   # makes $X or so lexical
                   J.bz->("${path}_$sub#rese\t1", "my \$$sub = wJ\.drop\.$path\.$sub = {};");
                   J.bz->("${path}_$sub#$ome\t$cv", $haD);
                   J.bz->("${path}_$sub#return\t9", "wJ\.drop\.$path\.$sub;");
                   J.bz->("$path#upsubhash-$sub\t1",
                     "my \$$sub = wJ\.drop\.$path\.$sub ||= Rw J.hw/${path}_$sub;");
                     
                   return; #
     }
     # see twisty ops in lightcones
     # could resolve curve embeddings like this
     # same in bush of stuff to cv out
     # cv in
          
          if (my $cs = sc.qmco) {
              push @l, ':', "\$tk eq 'c.K' ? do {";
              if (my $sub = sc.subhash) {
                  $D = "G\.drop\.$path\.$sub\.c.K->(\$v, \$tks)";
              }
              $D = ind '     ', $D;
              push @r, '}';
          }
          
          # if (sc.this) { DO } +
               if (my $cs = sc.csfrm) {
                   $cs = c.K if $cs eq 'cK';
                   sc.com .= "# cs=$cs  ";
                   unshift @l, "if (exists c\.$cs) {"
                       ."\n    my \$cs = c\.$cs;";
                   $D = ind '     ', $D;
                   push @r, '}';
               }
                
               if (sc.tv) {
                   # lets D
                   J.bz->("c.K\t1", $D);
                   # dup pha check^
                   #die ki $sc;
                   my $d = {%$c};
                   delete d.s;
                   acum $J, tvs => $d;
                   #die wdump [$path, $ome, $cv, c.K, $sc, $type];
                   return;
               }
                
     if (my $C = sc.ct) {
         # lets C
         my $sub = c.t;
         if (!sc.nx) {
             $sub = c.t.'_'.c.v;
             $sub =~ s/\.//sg;
             
         }
         
         #sayyl "$C c.t   for ".ki $sc;
         
         my @s;
         push @s, "push \@{wJ\.cts\.$C}, {t=>'c.t',x=>'$sub'};"
             if !sc.nx;
         push @s, "wJ\.ctx\.".$C.'->{"'.$sub.'"} = sub {';
         my $args;
         if ($args = $sc->{"ct_${C}_args"}) {
             push @s, "    my ($args) = \@_;";
         }
         if (sc.way) {
             my $wp = "${path}_${C}_${sub}";
             J.bz->("$wp\t1", $D);
             $args =~ s/,/ /sg;
             $D = 'Rw'." J.hw/$wp $args;";
             
         }
         $D = ind '    ', $D;
         push @s, "$D";
         push @s, "};";
         $D = join "\n", (sc.com||"#!?"), @s;
         # makes $X or so lexical
         J.bz->("${path}_$C#rese\t1", 
          "wJ\.ctx\.$C = {};"
         ."wJ\.cts\.$C = [];"
         );
         
         J.bz->("${path}_$C#$ome\t$cv", $D);
         J.bz->("${path}_$C#return\t9", "wJ\.ctx\.$C;");
         J.bz->("$path#upctx-$C\t1",
             "wJ\.ctx\.$C ||= Rw J.hw/${path}_$C \$wJ;");
         return; #
     }
               
               $D = join "\n", (sc.com||"#!?"), @l, @lr, $D, @r;
               J.bz->("$path#$ome\t$cv", $D);

