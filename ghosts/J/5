R_Jz:
 - K: stev #c steving lambassy
   D: |
     # my $st = already
     my @ev = grep { _.l eq _.t } w $R tvo; # poli
     
     for my $j (@ev) {
         for (j.t) {
             # 6
         }
      }
 - K: forkpi #c
   spesh: 0
   spesh_D: |
     H.name eq "O" || $DB::sub # perl -dw cannot fork # websockets cannot fork?
   babz:
        'gp 2.5': |
            if (J.cv > 0.2 && !J.replaceJid && !J.q) {
                my $la = {%$J};
                la.replaceJid = J.isJid; #$H->mkuid;
                my $lyt = G.jumb.forkpis ||= [];
                push @$lyt, $la;
                J.forking = $la;
                J.cv = 0.1;
            }
        'hiss 8.8': |
            if (my $pias = delete G.jumb.forkpis) {
                # these could be forked right away
                # if they can wait for the M muxing J if they reach O first
                $G->timer(0, sub {
                    Rw forkpi/pias $J $pias;
                });
            }
        'gp 7.1': |
            J.forking.wash = $H->dig(J.s) if J.forking;
        'hiss 2.88': |
            kill 'KILL', $_ for @{delete G.forkpi_tokill || []};
   n_D:
        pias: |
            if (my $pid = fork()) {
                my $Sftk = G.forkpi_tokill ||= [];
                push @$Sftk, $pid;
                return
            }
            H.db = H.pg->db;
            H.isforked = 1;
            # child must exit, after reporting error
            # so nothing else can happen. listening db handle gone anyway?
            my $bail = sub{ exit };
            $G->accum($G0, _aft_err_do => $bail);
            $G->accum($F[0], _aft_etc_do => $bail);
            
            sayyl "pier Forked... ";
            
            my @js;
            my $group = 3;
            for my $a (@$pias) {
                a.replaceJid || do {
                    warn "Jid missing... ". gp($a)
                    ."\n".gp(a.u)."\nJiter: ".gp a.Jiter;
                    next;
                };
                Rw gp $J:a;
                my $html = a.s;
                next if a.wash eq $H->dig($html);
                my $set = $H->ejson($html);
                my $id = a.replaceJid || die wdump(2,$a);
                my $js = qq{ \$('#$id').replaceWith($set);};
                push @js, $js;
                if (@js >= $group) {
                    $H->send(join('', @js));
                    @js = ();
                }
            }
            $H->send(join '', @js) if @js;
            saygr "pier done ".F_delta;
            
 - K: occie #c style komerp # occasional (page) global aggregate
   spesh: 0
   babz:
     'maka 6.1': |
       do {
       my (@css,@class);
       my ($fat, $skinny, $kompi);
       for my $cs (@$css) {
           $fat += length $cs;
           # saybl " a bit $cs";
           G.jumb.shtuuyle->{$cs}++; #<in vout
           if (my $class = G.jumb.shtdc->{$cs}) {
               $kompi += length $class;
               push @class, $class;
           }
           else {
               $skinny += length $cs;
               push @css, $cs;
           }
       }
       #sayyl "Komp: $fat -> $kompi & $skinny" if 4.97 < rand 5;
       at.class = join' ',@class if @class;
       # and redo:
       at.style = join '', map{"$_;"}
       grep{defined} map { split ';' } @css;
       };
   n_D:
        komp: |
            my $dc = G.jumb.shtuuyle || return;
            my $sd;
            my $byii;
            push @{$byii->{$dc->{$_}}||=[]}, $_ for keys %$dc;
            my @order = reverse sort {$a<=>$b} keys %$byii;
            
            my $i = 0;
            my $bored = 5; # bored lower than 5, or as ratio once rolling
            my $limit = 250;
            my $ilimit = @order / 3;
            for my $usk (@order) {
                my $us = $byii->{$usk};
                #say "usk $usk  of ".scalar(@$us);
                last if $usk < $bored;
                for my $u (@$us) {
                    last if $limit-- < 1;
                    last if $ilimit-- < 1;
                    my $sty = join '', map{"$_;"} grep{defined} split ';', $u;
                    die unless $sty;
                    my ($heex) = $H->dig($sty) =~ /^(...)/;
                    $heex =~ tr/0123456789/ghijklmnop/; # no numbers
                    # TODO pack hex into unibabl
                    $sd->{"s".$heex} = $sty;
                }
            }
            if (!$sd) {
                # TOO MUCH NOTHING
                sayyl "NOTHING TO COMPRESS" for 1..20;
                return; 
            }
            sayyl "compression is ".scalar(keys %$sd)." wide";
            
            G.jumb.shtdc = {reverse %$sd};

            # ^ to maka
            # v to elvis

            my $as = {K=>'style', B=>{am=>'styleyo'}};
            my $st = w G.R fuu(u=>$as);
            my $was = st.sheet;
            st.sheet = join "\n", map { ".$_ { $sd->{$_} }" } sort keys %$sd;
            
            st.sheet .= <<"";
            input[type=range] {
                -webkit-appearance: none;
                background: black;
                height: 2px;
            }
            input[type=range]::-webkit-slider-thumb {
              -webkit-appearance: none;
              background: url(i/copper_anodes.jpg);
              height: 12px;
              width: 12px;
              border-radius: 6px;
              cursor: crosshair;
              box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d;
            }
            
            #ux {pointer-events: none;}
            #cux * {pointer-events: all;}
            

            
            w mux(u=>$st) if st.sheet ne $was;

      
 - K: cv #c mod cove
   n_D:
     oe: |
       my $v = ar.v || 9;
       my $wi = length($v);
       my $thi = join '', ('9') x $wi;
       my $n = 1;
       
       my $squidge;
       if (ar.m && join(" ",@{ar.m}) =~ /off(\d+)/) {
           $squidge = int($1 * ($thi / ($v))); # TODO not quite
           $n += $squidge;
           $v += $squidge;
       }
       
       my @is = map { sprintf '%0'.$wi.'d', $_  }
       map { int($_ * ($thi / $v)) } $n..$v;
       
       #sayyl "thehehehhe $squidge $n $v thi $thi". wdump[@is]; 
       die "numbe rdist ".wdump(2,[$v,$wi,$thi,@is]) if uniq(@is) != @is;
       @is;
       
 - K: round #c regroup - smush cove + copy here -> there
   D: |
       my $J4 = ar.J4 || ar.from || ar.humm;
       my $J5 = ar.J5 || ar.to || ar.styje;
       # could multiple J sources and exits, provide roundness, generally...
       
       my @be = Rw tvo $J:J4;
       my $jit; # cv / l / t / $j
       my $ji = {map{$_=>[]}0..9};
       
       for my $j (@be) {
           $jit->{j.cv}->{j.l}->{j.t} && die;
           $jit->{j.cv}->{j.l}->{j.t} = $j;
           next unless j.l eq j.t; # just deal thing spines
           j.cv =~ /^0\.(\d)/ || die;
           my $cvb = $1;
           push @{$ji->{$cvb}}, $j;
       }
       
       # wavesmush
       my $away;
       my $id = 2;
       for my $i (0..9) {
           my $lo = $ji->{$i-1};
           my $no = $ji->{$i};
           my $ro = $ji->{$i+1};
           
           my $bulg = @$no - $id if @$no > $id;
           if ($bulg > 0 && $lo && @$lo < $id) {
               my $idspacl = $id - @$lo;
               push @$lo, map { shift @$no } 1..$idspacl;
           }
           
           $bulg = 0;
           $bulg = @$no - $id if @$no > $id;
           if ($bulg > 0 && $ro) { # without varing  && @$ro < $id
               unshift @$ro, map { pop @$no } 1..$bulg;
           }
           elsif ($bulg > 0) {
               # could flip everything around, raise $id,
               # slosh back toward the middle again
               # very painterly
               # hidden realms
               pop @$no for 1..$bulg;
               $away = {bulg=>$away};
           }
           
       }
       
       
       # measure $ji, mod up locations for things
       # give original j.cv if the $cvb/ set is same
       for my $cvb (sort keys %$ji) {
           my $no = $ji->{$cvb};
           my @cvs = map{_.cv}@$no;
           #die join(":",@cvs) if join(":",@cvs) ne join(":", sort @cvs);
           
           if (@cvs != uniq @cvs) {
               
               my $warp = @$no;
               @cvs = map { "0.".$cvb.$_ } Rw cv/oe $v:warp;
               # wind for thi like in mod
           }
           
           for my $j (@$no) {
               my $ncv = shift @cvs;
               my $ts = $jit->{j.cv}->{j.l};#/j.t => $j
               for my $k (sort keys %$ts) {
                   my $tj = $ts->{$k};
                   if (tj.t eq tj.l) {
                       J5.bz->(j.l."%origin\t".$ncv, $tj); # subtlest A-tion
                       J4.bz->(j.l."%waves\t".$ncv, $j); # subtlest A-tion
                   }
                   J5.bz->(tj.t."\t".$ncv, tj.s);
               }
           }
       }
       
       if ($away) {
           J5.bz->("buckstop\t0.999" => "@".away.bulg."...",
           '%css' => 'color:blue');
       }
       

