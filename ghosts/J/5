R_Jz:
 - K: stev #c steving lambassy
   D: |
     # my $st = already
     my @ev = grep { _.l eq _.t } w $R tvo; # poli
     
     for my $j (@ev) {
         for (j.t) {
             # 6
         }
      }
 - K: occie #c style komerp # occasional (page) global aggregate
   spesh: 0
   babz:
     'maka 6.1': |
       do {
       my (@css,@class);
       my ($fat, $skinny, $kompi);
       for my $cs (@$css) {
           $fat += length $cs;
           # saybl " a bit $cs";
           G.jumb.shtuuyle->{$cs}++; #<in vout
           if (my $class = G.jumb.shtdc->{$cs}) {
               $kompi += length $class;
               push @class, $class;
           }
           else {
               $skinny += length $cs;
               push @css, $cs;
           }
       }
       sayyl "Komp: $fat -> $kompi & $skinny" if 4.93 < rand 5;
       at.class = join' ',@class if @class;
       # and redo:
       at.style = join '', map{"$_;"}
       grep{defined} map { split ';' } @css;
       };
   n_D:
        komp: |
            my $dc = G.jumb.shtuuyle || return;
            my $sd;
            my $byii;
            push @{$byii->{$dc->{$_}}||=[]}, $_ for keys %$dc;
            my @order = reverse sort {$a<=>$b} keys %$byii;
            
            my $i = 0;
            my $bored = 5; # bored lower than 5, or as ratio once rolling
            my $limit = 250;
            my $ilimit = @order / 3;
            for my $usk (@order) {
                my $us = $byii->{$usk};
                say "usk $usk  of ".scalar(@$us);
                last if $usk < $bored;
                for my $u (@$us) {
                    last if $limit-- < 1;
                    last if $ilimit-- < 1;
                    my $sty = join '', map{"$_;"} grep{defined} split ';', $u;
                    die unless $sty;
                    my ($heex) = $H->dig($sty) =~ /^(...)/;
                    $heex =~ tr/0123456789/ghijklmnop/; # no numbers
                    # TODO pack hex into unibabl
                    $sd->{"s".$heex} = $sty;
                }
            }
            if (!$sd) {
                # TOO MUCH NOTHING
                sayyl "NOTHING TO COMPRESS" for 1..20;
                return; 
            }
            sayyl "compression is ".scalar(keys %$sd)." wide";
            
            G.jumb.shtdc = {reverse %$sd};

            # ^ to maka
            # v to elvis

            my $as = {K=>'style', B=>{am=>'styleyo'}};
            my $st = w G.R fuu(u=>$as);
            my $was = st.sheet;
            st.sheet = join "\n", map { ".$_ { $sd->{$_} }" } sort keys %$sd;
            
            w mux(u=>$st) if st.sheet ne $was;

      
 - K: cv #c mod cove
   n_D:
     oe: |
       my $v = ar.v || 9;
       my $wi = length($v);
       my $thi = join '', ('9') x $wi;
       my $n = 1;
       
       my $squidge;
       if (ar.m && join(" ",@{ar.m}) =~ /off(\d+)/) {
           $squidge = int($1 * ($thi / ($v))); # TODO not quite
           $n += $squidge;
           $v += $squidge;
       }
       
       my @is = map { sprintf '%0'.$wi.'d', $_  }
       map { int($_ * ($thi / $v)) } $n..$v;
       
       #sayyl "thehehehhe $squidge $n $v thi $thi". wdump[@is]; 
       die "numbe rdist ".wdump(2,[$v,$wi,$thi,@is]) if uniq(@is) != @is;
       @is;
       
 - K: round #c regroup - smush cove + copy here -> there
   D: |
       my $J4 = ar.J4 || ar.from || ar.humm;
       my $J5 = ar.J5 || ar.to || ar.styje;
       # could multiple J sources and exits, provide roundness, generally...
       
       my @be = Rw tvo $J:J4;
       my $jit; # cv / l / t / $j
       my $ji = {map{$_=>[]}0..9};
       
       for my $j (@be) {
           $jit->{j.cv}->{j.l}->{j.t} && die;
           $jit->{j.cv}->{j.l}->{j.t} = $j;
           next unless j.l eq j.t; # just deal thing spines
           j.cv =~ /^0\.(\d)/ || die;
           my $cvb = $1;
           push @{$ji->{$cvb}}, $j;
       }
       
       # wavesmush
       my $away;
       my $id = 3;
       for my $i (0..9) {
           my $lo = $ji->{$i-1};
           my $no = $ji->{$i};
           my $ro = $ji->{$i+1};
           
           my $bulg = @$no - $id if @$no > $id;
           if ($bulg > 0 && $lo && @$lo < $id) {
               my $idspacl = $id - @$lo;
               push @$lo, map { shift @$no } 1..$idspacl;
           }
           
           $bulg = 0;
           $bulg = @$no - $id if @$no > $id;
           if ($bulg > 0 && $ro) { # without varing  && @$ro < $id
               unshift @$ro, map { pop @$no } 1..$bulg;
           }
           elsif ($bulg > 0) {
               # could flip everything around, raise $id,
               # slosh back toward the middle again
               # very painterly
               # hidden realms
               pop @$no for 1..$bulg;
               $away = {bulg=>$away};
           }
           
       }
       
       
       # measure $ji, mod up locations for things
       # give original j.cv if the $cvb/ set is same
       for my $cvb (sort keys %$ji) {
           my $no = $ji->{$cvb};
           my @cvs = map{_.cv}@$no;
           #die join(":",@cvs) if join(":",@cvs) ne join(":", sort @cvs);
           
           if (@cvs != uniq @cvs) {
               
               my $warp = @$no;
               @cvs = map { "0.".$cvb.$_ } Rw cv/oe $v:warp;
               # wind for thi like in mod
           }
           
           for my $j (@$no) {
               my $ncv = shift @cvs;
               my $ts = $jit->{j.cv}->{j.l};#/j.t => $j
               for my $k (sort keys %$ts) {
                   my $tj = $ts->{$k};
                   if (tj.t eq tj.l) {
                       J5.bz->(j.l."%origin\t".$ncv, $tj); # subtlest A-tion
                       J4.bz->(j.l."%waves\t".$ncv, $j); # subtlest A-tion
                   }
                   J5.bz->(tj.t."\t".$ncv, tj.s);
               }
           }
       }
       
       if ($away) {
           J5.bz->("buckstop\t0.999" => "@".away.bulg."...",
           '%css' => 'color:blue');
       }
       

