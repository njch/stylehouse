R_Jz:
 - K: domi #c Doofer
   n_D:
     any_init: |
       # quick rezip 
       # vamp compressioms
       # that is things before even J personality mods
       # same Jway, phases etc.
       G.drop = {};
       delete G.drop.conv;
       delete G.drop.vonc; # TODO drop all
       Rw conv;
       Rw vonc;
       
       Rw suck */dosc;
       Rw conc;
 - K: conc #c C_whta
   D: |
     sayyl "CONC!" for 1..4;
     delete G.drop.esc;
     my @a = grep {/^C_.+/} sort keys %{R.way.hooks};
     for my $the (@a) {
         my $path = $1 if $the =~ /^C_(.+)/;
         Rw Con $the $path;
     }
 - K: conv #c know about elemental stuff
   D: |
     my $pway = {qw'1 YIN 2 YANG 3 CARBON 5 STYLE 6 TRAVEL 7 CITOZINE 9 RETURN'};
     G.drop.conv = sub {
          my $v = shift;
         my $dig = $1 if $v =~ /^(\d)/;
         $pway->{$dig} || die " not convable $dig from $v";
     };
     G.drop.conv->(ar.v) if ar.v;
 - K: vonc #c elemental
   D: |
     G.drop.vonc = sub {
          my $v = shift;
         my $dig = $1 if $v =~ /^(\d)/;
         return $1;
     };
     G.drop.vonc->(ar.v) if ar.v;
 - K: Con #c the shunt, suck, J maint wayfile story # OSCILATE FUNCS, test frequencies tuned synapse
   D: |
     my $m = ar.m||[];
     my $o = Rw pul + $cs:m the src path;
     my $the = o.the || die;
     my $src = o.src || "$the/u";
     my $path = o.path || "$the/n";
     # or wherever thi src + carbon quags into existence
     # root l=$the := $the/n, otherwis whatever is l
     # so $the/X for subhash X, yin require of user
     # similar smush in G.drop.$the
     my $p = $the =~ /_/ ? "C $path" : "$the c";
     my $J = Rw Carbonja $p $the $path;
     
       # shove togeth modn
       # get a cv sorter  that puts 3 > 32, since 3 is 3 all the way down > 3232323...
       # tesalation
       my $ljs = Rw tlv $J;
       # ^ hash styles, things are l+com, like $tks
       my $wtf;
       my $coms = {};
       for my $lj (@$ljs) {
           my $j = lj.j;
           
           if (!%$j) {
               warn "not j: ".wdump(2,$lj);
               next;
           }
           
           lj.sc && die "wop";
           
           acum $coms, j.cv => j.com;
           
           
           my $cvit = G.drop.vonc->(j.cv);
           my $was = $wtf->{j.l} ||= {};
           acum $was, $cvit, j.s; # <<<<<<< cv collapse unto elements
       }
       
       my $real = {};
       $real->{$path} = R.way->find($src) || die "no $src";
       
       my $imag = {};
       my $tl = {};
       for my $l (sort keys %$wtf) {
           my $was = $wtf->{$l};
           for my $cvit (sort keys %$was) {
               my $v = $was->{$cvit};
               my $type = G.drop.conv->($cvit); # con cvit
               $tl->{$type} = @$v; # diagsum
               
               $v = join "\n", @$v;        # # <<<<<<<
               
               if ($real->{$l}) {
                   # after an elemental aggregation...
                   # these'll be top posting after cv sort?
                   $real->{$l} =~ s/(# $type.*?)$/$1\n$v/sm
                   
                   || die "no $type in ...";
               }
               else {
                   $imag->{$l} .= "\n$v";
               }
           }
       }
       
       my $all = {%$real, %$imag};
       die wdump[[sort keys %$real],[sort keys %$imag],[sort keys %$all]]
       if keys(%$real) + keys(%$imag) != keys %$all;
       for my $pin (sort keys %$all) {
           my $www = $all->{$pin};
           
           $pin = $path if $pin eq $the; # $the/n
           my $ac = join'',map{"{$_"}split'/',$pin;
           
           #say "Injecting   $pin  $ac   with:";
           #sayre ind '   ', slim 5300, $www;
           $R->loadup(R.way.hooks, $ac, $www);
       }
       
       G.jumb.ConJ->{$the} = $J;
     

       
       #talkyelemental 
       my $ev;
       for (sort keys %$coms) {
           my $c = $coms->{$_};
           push @{$ev->{floor($_)}||=[]}, @$c;
       }
       my $sl;
       for my $k (sort keys %$ev) {
           my $r = $ev->{$k};
           $sl .= "   $k * ".(0+@$r)."(".slim(25,join(' ',@$r)).")";
       }
        
       #saybl " _________________  $mw" if $the eq 'esc';
       sayyl "$path <- $the     $sl";
       
       Rw $the/Conned $J;
       # nice thing to print ^
       
 - K: Carbonja #c 3ish
   D: |
       
       $p .= '(#*)?' if $p =~ /^C /;
       
       my $tw = Rw fund $p;
       say ejson $tw if $path eq 'may';
       
       # per way file every $s, each one can be homeo, have some art for zip
       # where to suck local protocols
       die "no '$p'" if !%$tw;
       
       
       my $J = {};
       Rw suJ $J;
       
       my $p = "$the/el/*";
       my $ty = Rw huck $p;
       $ty = {map{
            my $type = $1 if /el\/(.+)$/ || die;
            my $an = $ty->{$_};
            die if @$an > 1;
            $type => $an->[0];
       }keys %$ty};
       
       for my $file (sort keys %$tw) {
           my $Cs = $tw->{$file};
           my $coi = Rw pha $J $k:file;
           
           for my $c (@$Cs) {
               #die wdump $c if ref $c eq 'HASH' && (c.MZ || c.K eq 'MZ');
               # occasional c.MZ for things that always want in...
               # homex ty, local modulation, the radio
               # some carbon fits
               # also from $the/el
               
               if (ref $c eq 'HASH') {
                   my @wsy = grep {m/\S\s\S/} keys %$c;
                   for my $zk (@wsy) {
                       my $D = $c->{$zk};
                       my ($k, $v) = split m/\s/, $zk;
                       #die "$k ne $the      $path" if $k ne $the; # the redund
                       c.v ||= $v;
                       c.s = $D;
                       c.sc.com = "# $zk @ c.K  ";

                       Rw Nucleous $file $ty $c $the $path $J;
                   }
               }
               elsif (ref $c eq 'ARRAY') {
                   my $n = {};
                   (n.K, n.v, n.s, n.sc) = @$c;
                   n.sc.com ||= "# n.K n.v";
                   
                   Rw Nucleous $file $ty $c:n $the $path $J;
               }
               else {
                   die wdump $c;
               }
           }
           coi.end->();
       }
       $J
 - K: Nucleous #c
   D: |
          my (@l,@lr,@r); 
          c.K || die;
          c.v ||= 3;
          c.v += 0;
          my $ome = "#".c.K;
          die c.v if c.v !~ /^\d/;

          # if for c.cs, for implant condits # sche
          my $cv = c.v;
          my $D = c.s;
          my $type = G.drop.conv->($cv);
          # z downgrasp
          my $sc;
          $sc = c.sc.MZ if c.sc && c.sc.MZ;
          $sc ||= $ty->{$type};
          $sc ||= {};
          $sc = {%$sc, %{c.sc}} if c.sc;
          
          # per $path if maybe ?? emberd whatsits
          # some special K of c may have meta for this too
          
               if (my $sub = sc.subhash) {
                   unshift @l, "G\.drop\.$path\.$sub\.c.K = sub {";
                   my $args = '$v,$tks,$'.$sub;
                   if (my $arp = sc.subhash_X_arp) {
                       $args .= ",$arp";
                   }
                   push @lr, '    my ('.$args.') = @_;'; # gets $X, etc
                   $D = ind '     ', $D;
                   push @r, '};';
                   if (my $list = sc.droplist) {
                       push @r, "push \@{G\.drop\.$path\.$list}, 'c.K';"; 
                       J bz ${path}_$sub#rese$list 1 "G\.drop\.$path\.$list = [];"
                   }
                   my $haD = join "\n", (sc.com||"#!?"), @l, @lr, $D, @r;
                   @l = (); @lr = (); @r = ();
                   J bz ${path}_$sub$ome $cv $haD
                   J bz ${path}_$sub#rese 1 "G\.drop\.$path\.$sub = {};"
                   J bz ${path}_$sub#return 9 "G\.drop\.$path\.$sub;"
                   J bz $path#upsubhash-$sub 1 "my \$$sub = G\.drop\.$path\.$sub ||= Rw ${path}_$sub;"
                   return; #
               }
          
          # : EXPR ? DO +
          # or they want elsif
          # see what the cv wants to land on/through
          # see twisty ops in lightcones
          # could resolve curve embeddings like this
          if (my $cs = sc.qmco) {
              push @l, ':', "\$tk eq 'c.K' ? do {";
              if (my $sub = sc.subhash) {
                  $D = "G\.drop\.$path\.$sub\.c.K->(\$v, \$tks)";
              }
              $D = ind '     ', $D;
              push @r, '}';
          }
          
          # if (sc.this) { DO } +
               if (my $cs = sc.csfrm) {
                   $cs = c.K if $cs eq 'cK';
                   sc.com .= "# cs=$cs  ";
                   unshift @l, "if (exists c\.$cs) {"
                       ."\n    my \$cs = c\.$cs;";
                   $D = ind '     ', $D;
                   push @r, '}';
               }
               
               $D = join "\n", (sc.com||"#!?"), @l, @lr, $D, @r;
               J bz $path$ome $cv $D
 - K: round #c regroup - smush cove + copy here -> there
   D: |
       # could multiple J sources and exits, provide roundness, generally...
       # not just from this J but spacing out logic according from what changed
       # a style or intentness of the bzling reshadow
       # increment
       # chunk the curve and rotate each chunk *** piles in spiral
       
       my @be = Rw tvo $J:J2;
       my $jit; # cv / l / t / $j
       my $ji = {map{$_=>[]}0..9};
       
       for my $j (@be) {
           $jit->{j.cv}->{j.l}->{j.t} && die;
           $jit->{j.cv}->{j.l}->{j.t} = $j;
           next unless j.l eq j.t; # just deal thing spines
           j.cv =~ /^0\.(\d)/ || die;
           my $cvb = $1;
           push @{$ji->{$cvb}}, $j;
       }
       
       # wavesmush # DOESn't do spaceouts
       # but that old... 
       my $away; 
       #sayyl "Be: ".@be;
       my $id = J.yy.round.id || 2;
       for my $i (0..9) {
           my $lo = $ji->{$i-1};
           my $no = $ji->{$i};
           my $ro = $ji->{$i+1};
           
           my $bulg = @$no - $id if @$no > $id;
           if ($bulg > 0 && $lo && @$lo < $id) {
               my $idspacl = $id - @$lo;
               push @$lo, map { shift @$no } 1..$idspacl;
           }
           
           $bulg = 0;
           $bulg = @$no - $id if @$no > $id;
           if ($bulg > 0 && $ro) { # without varing  && @$ro < $id
               unshift @$ro, map { pop @$no } 1..$bulg;
           }
           elsif ($bulg > 0) {
               # could flip everything around, raise $id,
               # slosh back toward the middle again
               # very painterly
               # hidden realms
               pop @$no for 1..$bulg;
               $away = {bulg=>$away};
           }
           
       }
       
       
       # measure $ji, mod up locations for things
       # give original j.cv if the $cvb/ set is same
       for my $cvb (sort keys %$ji) {
           my $no = $ji->{$cvb};
           my @cvs = map{_.cv}@$no;
           #die join(":",@cvs) if join(":",@cvs) ne join(":", sort @cvs);
           
           if (@cvs != uniq @cvs) {
               
               my $warp = @$no;
               @cvs = map { "0.".$cvb.$_ } Rw cv/oe $v:warp;
               # wind for thi like in mod
           }
           
           for my $j (@$no) {
               my $ncv = shift @cvs;
               my $ts = $jit->{j.cv}->{j.l};#/j.t => $j
               for my $k (sort keys %$ts) {
                   my $tj = $ts->{$k};
                   if (tj.t eq tj.l) {
                       J.bz->(j.l."%origin\t".$ncv, $tj); # subtlest A-tion
                       J2.bz->(j.l."%waves\t".$ncv, $j); # subtlest A-tion
                   }
                   J.bz->(tj.t."\t".$ncv, tj.s);
               }
           }
       }
       
       if ($away) {
           J.bz->("buckstop\t0.999" => "@".away.bulg."...",
           '%css' => 'color:blue');
       }
       

