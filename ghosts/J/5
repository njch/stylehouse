R_Jz:
 - K: domi #c Doofer
   n_D:
     any_init: |
       # quick rezip 
       # vamp compressioms
       # that is things before even J personality mods
       # same Jway, phases etc.
       delete G.drop.conv;
       delete G.drop.vonc; # TODO drop all
       Rw conv;
       Rw vonc;
       
       Rw suck */dosc;
 - K: conv #c know about elemental stuff
   D: |
     my $pway = {qw'1 YIN 2 YANG 3 CARBON 7 CITOZINE 9 RETURN'};
     G.drop.conv = sub {
          my $v = shift;
         my $dig = $1 if $v =~ /^(\d)/;
         $pway->{$dig} || die " not convable $dig from $v";
     };
     G.drop.conv->(ar.v) if ar.v;
 - K: vonc #c elemental
   D: |
     G.drop.vonc = sub {
          my $v = shift;
         my $dig = $1 if $v =~ /^(\d)/;
         return $1;
     };
     G.drop.vonc->(ar.v) if ar.v;
 - K: Con #c the shunt, suck, J maint wayfile story # OSCILATE FUNCS, test frequencies tuned synapse
   D: |
     my ($the, $src, $path) = @$m;
     $src ||= "$the/u";
     $path ||= "$the/n";
     # or wherever thi src + carbon quags into existence
     # root l=$the := $the/n, otherwis whatever is l
     # so $the/X for subhash X, yin require of user
     # similar smush in G.drop.$the
     my $p = "$the c";
     my $J = Rw Carbonja $p $the;
     
       # shove togeth modn
       # get a cv sorter  that puts 3 > 32, since 3 is 3 all the way down > 3232323...
       # tesalation
       my $ljs = Rw tlv $J;
       # ^ hash styles, things are l+com, like $tks
       my $wtf;
       my $coms = {};
       for my $lj (@$ljs) {
           my $j = lj.j;
           
           if (!%$j) {
               warn "not j: ".wdump(2,$lj);
               next;
           }
           
           lj.sc && die "wop";
           
           acum $coms, j.cv => j.com;
           
           
           my $cvit = G.drop.vonc->(j.cv);
           my $was = $wtf->{j.l} ||= {};
           acum $was, $cvit, j.s; # <<<<<<< cv collapse unto elements
       }
       
       my $real = {};
       $real->{$the} = R.way->find($src) || die "no $src";
       my $imag = {};
       my $tl = {};
       for my $l (sort keys %$wtf) {
           my $was = $wtf->{$l};
           for my $cvit (sort keys %$was) {
               my $v = $was->{$cvit};
               my $type = G.drop.conv->($cvit); # con cvit
               $tl->{$type} = @$v; # diagsum
               
               $v = join "\n", @$v;        # # <<<<<<<
               
               if ($real->{$l}) {
                   # after an elemental aggregation...
                   # these'll be top posting after cv sort?
                   $real->{$l} =~ s/(# $type.*?)$/$1\n$v/sm
                   
                   || die "no $type in ...";
               }
               else {
                   $imag->{$l} .= "\n$v";
               }
           }
       }
       
       my $all = {%$real, %$imag};
       die wdump[[sort keys %$real],[sort keys %$imag],[sort keys %$all]]
       if keys(%$real) + keys(%$imag) != keys %$all;
       for my $pin (sort keys %$all) {
           my $www = $all->{$pin};
           
           $pin = $path if $pin eq $the; # $the/n
           my $ac = join'',map{"{$_"}split'/',$pin;
           
           say "Injecting   $pin  $ac   with:";
           sayre ind '   ', slim 300, $www
               if 0 && $the eq 'esc'; # db
           $R->loadup(R.way.hooks, $ac, $www);
       }
       
       G.jumb.ConJ->{$the} = $J;
     

       
       #talkyelemental 
       my $sl; # elemental spawn coms
       my $cl = "";
       for (sort keys %$coms) {
           my $c = $coms->{$_};
           my $v = G.drop.conv->($_);
           my $fr = " ";
           if ($v ne $cl) {
               $fr = "";
               $cl = $v;
               $sl .= ") " if $sl;
               $sl .= "$v*$tl->{$v}("; # sum
           }
           $sl .= ${fr}.join " ", @$c;
       }
       $sl.=")";
       #saybl " _________________  $mw" if $the eq 'esc';
       sayyl "$path <- $the     $sl";
       # nice thing to print ^
       
 - K: Carbonja #c 3ish
   D: |
       my $tw = Rw fund $p;
       # per way file every $s, each one can be homeo, have some art for zip
       # where to suck local protocols
       die "no '$p'" if !%$tw;
       
       my $J = {};
       Rw suJ $J;
       
       my $p = "$the/el/*";
       my $ty = Rw huck $p;
       $ty = {map{
            my $type = $1 if /el\/(.+)$/ || die;
            my $an = $ty->{$_};
            die if @$an > 1;
            $type => $an->[0];
       }keys %$ty};
       
       for my $file (sort keys %$tw) {
           my $Cs = $tw->{$file};
           my $coi = Rw pha $J $k:file;
           
           if (my ($MZ) = grep{_.K eq 'MZ'}@$Cs) {
               # homex ty, local modulation, the radio
               # some carbon fits
               # also from $the/somemeta
           }
           
           for my $c (@$Cs) {
               my @wsy = grep {m/\S\s\S/} keys %$c;
               for my $zk (@wsy) {
                   my $D = $c->{$zk};
                   my ($k, $v) = split m/\s/, $zk;
                   my $ome = c.K;
                   my $com = "# $zk @ $ome  ";

                   Rw Nucleous $file $ty $c $com $ome $k $v $the $J $D;
               }
           }
           coi.end->();
       }
       $J
 - K: Nucleous #c
   D: |
          my (@l,@lr,@r); 
          
          $ome = "#$ome" if $ome;

          # if for c.cs, for implant condits # sche
          my $type = G.drop.conv->($v);
          # z downgrasp
          my $sc = c.MZ if c.MZ; # per $k if maybe ?? emberd whatsits
          # some special K of c may have meta for this too
          $sc ||= $ty->{$type};
          
               if (my $sub = sc.subhash) {
                   unshift @l, "G\.drop\.$the\.$sub\.c.K = sub {";
                   push @lr, '    my ($v,$tks,$'.$sub.') = @_;'; # gets $X, etc
                   $D = ind '     ', $D;
                   push @r, '};';
                   if (my $list = sc.droplist) {
                       push @r, "push \@{G\.drop\.$the\.$list}, 'c.K';";
                       J bz $k/$sub#rese$list 1 "G\.drop\.$the\.$list = [];"
                   }
                   my $haD = join "\n", $com, @l, @lr, $D, @r;
                   @l = (); @lr = (); @r = ();
                   J bz $k/$sub$ome $v $haD
                   J bz $k/$sub#rese 1 "G\.drop\.$the\.$sub = {};"
                   J bz $k/$sub#return 9 "G\.drop\.$the\.$sub;"
                   J bz $k#upsubhash-$sub 1 "my \$$sub = G\.drop\.$the\.$sub || Rw $k/$sub;"
                   return; #
               }
          
          # : EXPR ? DO +
          # or they want elsif
          # see what the cv wants to land on/through
          # see twisty ops in lightcones
          if (my $cs = sc.qmco) {
              push @l, ':', "\$tk eq 'c.K' ? do {";
              if (my $sub = sc.subhash) {
                  $D = "G\.drop\.$the\.$sub\.c.K->(\$v, \$tks)";
              }
              $D = ind '     ', $D;
              push @r, '}';
          }
          
          # if (sc.this) { DO } +
               if (my $cs = sc.csfrm) {
                   $cs = c.K if $cs eq 'cK';
                   $com .= "cs=$cs  ";
                   unshift @l, 'if (my $cs = c.'.$cs.') {';
                   $D = ind '     ', $D;
                   push @r, '}';
               }
               
               $D = join "\n", $com, @l, @lr, $D, @r;
               J bz $k$ome $v $D
 - K: stev #c steving lambassy
   D: |
     # my $st = already
     my @ev = grep { _.l eq _.t } w $R tvo; # poli
     
     for my $j (@ev) {
         for (j.t) {
             # 6
         }
      }
 - K: forkpi #c
   spesh: 0
   spesh_D: |
     H.name eq "O" || $DB::sub # perl -dw cannot fork # websockets cannot fork?
   babz:
        'gp 2.5': |
            if (J.cv > 0.2 && !J.replaceJid && !J.q) {
                my $la = {%$J};
                la.replaceJid = J.isJid; #$H->mkuid;
                my $lyt = G.jumb.forkpis ||= [];
                push @$lyt, $la;
                J.forking = $la;
                J.cv = 0.1;
            }
        'hiss 8.8': |
            if (my $pias = delete G.jumb.forkpis) {
                # these could be forked right away
                # if they can wait for the M muxing J if they reach O first
                $G->timer(0, sub {
                    Rw forkpi/pias $J $pias;
                });
            }
        'gp 7.1': |
            J.forking.wash = $H->dig(J.s) if J.forking;
        'hiss 2.88': |
            kill 'KILL', $_ for @{delete G.forkpi_tokill || []};
   n_D:
        pias: |
            if (my $pid = fork()) {
                my $Sftk = G.forkpi_tokill ||= [];
                push @$Sftk, $pid;
                return
            }
            H.db = H.pg->db;
            H.isforked = 1;
            # child must exit, after reporting error
            # so nothing else can happen. listening db handle gone anyway?
            my $bail = sub{ exit };
            $G->accum($G0, _aft_err_do => $bail);
            $G->accum($F[0], _aft_etc_do => $bail);
            
            sayyl "pier Forked... ";
            
            my @js;
            my $group = 3;
            for my $a (@$pias) {
                a.replaceJid || do {
                    warn "Jid missing... ". gp($a)
                    ."\n".gp(a.u)."\nJiter: ".gp a.Jiter;
                    next;
                };
                Rw gp $J:a;
                my $html = a.s;
                next if a.wash eq $H->dig($html);
                my $set = $H->ejson($html);
                my $id = a.replaceJid || die wdump(2,$a);
                my $js = qq{ \$('#$id').replaceWith($set);};
                push @js, $js;
                if (@js >= $group) {
                    $H->send(join('', @js));
                    @js = ();
                }
            }
            $H->send(join '', @js) if @js;
            saygr "pier done ".F_delta;
            
 - K: round #c regroup - smush cove + copy here -> there
   D: |
       # could multiple J sources and exits, provide roundness, generally...
       # not just from this J but spacing out logic according from what changed
       # a style or intentness of the bzling reshadow
       # increment
       # chunk the curve and rotate each chunk *** piles in spiral
       
       my @be = Rw tvo $J:J2;
       my $jit; # cv / l / t / $j
       my $ji = {map{$_=>[]}0..9};
       
       for my $j (@be) {
           $jit->{j.cv}->{j.l}->{j.t} && die;
           $jit->{j.cv}->{j.l}->{j.t} = $j;
           next unless j.l eq j.t; # just deal thing spines
           j.cv =~ /^0\.(\d)/ || die;
           my $cvb = $1;
           push @{$ji->{$cvb}}, $j;
       }
       
       # wavesmush # DOESn't do spaceouts
       # but that old... 
       my $away; 
       #sayyl "Be: ".@be;
       my $id = J.yy.round.id || 2;
       for my $i (0..9) {
           my $lo = $ji->{$i-1};
           my $no = $ji->{$i};
           my $ro = $ji->{$i+1};
           
           my $bulg = @$no - $id if @$no > $id;
           if ($bulg > 0 && $lo && @$lo < $id) {
               my $idspacl = $id - @$lo;
               push @$lo, map { shift @$no } 1..$idspacl;
           }
           
           $bulg = 0;
           $bulg = @$no - $id if @$no > $id;
           if ($bulg > 0 && $ro) { # without varing  && @$ro < $id
               unshift @$ro, map { pop @$no } 1..$bulg;
           }
           elsif ($bulg > 0) {
               # could flip everything around, raise $id,
               # slosh back toward the middle again
               # very painterly
               # hidden realms
               pop @$no for 1..$bulg;
               $away = {bulg=>$away};
           }
           
       }
       
       
       # measure $ji, mod up locations for things
       # give original j.cv if the $cvb/ set is same
       for my $cvb (sort keys %$ji) {
           my $no = $ji->{$cvb};
           my @cvs = map{_.cv}@$no;
           #die join(":",@cvs) if join(":",@cvs) ne join(":", sort @cvs);
           
           if (@cvs != uniq @cvs) {
               
               my $warp = @$no;
               @cvs = map { "0.".$cvb.$_ } Rw cv/oe $v:warp;
               # wind for thi like in mod
           }
           
           for my $j (@$no) {
               my $ncv = shift @cvs;
               my $ts = $jit->{j.cv}->{j.l};#/j.t => $j
               for my $k (sort keys %$ts) {
                   my $tj = $ts->{$k};
                   if (tj.t eq tj.l) {
                       J.bz->(j.l."%origin\t".$ncv, $tj); # subtlest A-tion
                       J2.bz->(j.l."%waves\t".$ncv, $j); # subtlest A-tion
                   }
                   J.bz->(tj.t."\t".$ncv, tj.s);
               }
           }
       }
       
       if ($away) {
           J.bz->("buckstop\t0.999" => "@".away.bulg."...",
           '%css' => 'color:blue');
       }
       
 - K: oldschool #c
   D: |
     # next floatation device...
         for my $k (%{J.bb}) {
             if ($k =~ /^(\S*(?:oB|Bo|Bi|Bs))\s+(.+)$/) {
                 J.bb->{"$1\%css#maka25\t$2"} = "color:black";
             }
             if ($k =~ /^thi\s+(.+)$/) {
                 J.bb->{"thi\%css#maka25\t$1"} = "text-decoration:underline";
             }
             if ($k =~ /^name\s+(.+)$/) {
                 J.bb->{"name\%css#maka25\t$1"} = "color:#f93;";
             }
             if ($k =~ /^K\s+(.+)$/) {
                 J.bb->{"K%css#maka25\t$1"} = "color:#3f3";
             }
         }

