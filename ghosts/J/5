R_Jz:
 - K: stev #c steving lambassy
   D: |
     # my $st = already
     my @ev = grep { _.l eq _.t } w $R tvo; # poli
     
     for my $j (@ev) {
         for (j.t) {
             # 6
         }
      }
 - K: forkpi #c
   spesh: 0
   spesh_D: |
     H.name eq "O" || $DB::sub # perl -dw cannot fork # websockets cannot fork?
   babz:
        'gp 2.5': |
            if (J.cv > 0.2 && !J.replaceJid && !J.q) {
                my $la = {%$J};
                la.replaceJid = J.isJid; #$H->mkuid;
                my $lyt = G.jumb.forkpis ||= [];
                push @$lyt, $la;
                J.forking = $la;
                J.cv = 0.1;
            }
        'hiss 8.8': |
            if (my $pias = delete G.jumb.forkpis) {
                # these could be forked right away
                # if they can wait for the M muxing J if they reach O first
                $G->timer(0, sub {
                    Rw forkpi/pias $J $pias;
                });
            }
        'gp 7.1': |
            J.forking.wash = $H->dig(J.s) if J.forking;
        'hiss 2.88': |
            kill 'KILL', $_ for @{delete G.forkpi_tokill || []};
   n_D:
        pias: |
            if (my $pid = fork()) {
                my $Sftk = G.forkpi_tokill ||= [];
                push @$Sftk, $pid;
                return
            }
            H.db = H.pg->db;
            H.isforked = 1;
            # child must exit, after reporting error
            # so nothing else can happen. listening db handle gone anyway?
            my $bail = sub{ exit };
            $G->accum($G0, _aft_err_do => $bail);
            $G->accum($F[0], _aft_etc_do => $bail);
            
            sayyl "pier Forked... ";
            
            my @js;
            my $group = 3;
            for my $a (@$pias) {
                a.replaceJid || do {
                    warn "Jid missing... ". gp($a)
                    ."\n".gp(a.u)."\nJiter: ".gp a.Jiter;
                    next;
                };
                Rw gp $J:a;
                my $html = a.s;
                next if a.wash eq $H->dig($html);
                my $set = $H->ejson($html);
                my $id = a.replaceJid || die wdump(2,$a);
                my $js = qq{ \$('#$id').replaceWith($set);};
                push @js, $js;
                if (@js >= $group) {
                    $H->send(join('', @js));
                    @js = ();
                }
            }
            $H->send(join '', @js) if @js;
            saygr "pier done ".F_delta;
            
 - K: stylesheets #c
   n_D:
     any_init: |
       Rwyl 8 stylesheets/of;
     of: |
       my $tw = Rw huck */stylesheet;

       while (my($t,$w) = each %$tw) {
           my $as = {K=>'style', B=>{am=>$t}};
          my $u = w G.R fuu(u=>$as);
          my $was = u.sheet;
          u.sheet = join "\n",@$w;

          w mux[$u] if u.sheet ne $was;
       } 
 - K: occie #c style komerp # occasional (page) global aggregate
   spesh: 0
   babz:
     'maka 6.1': |
       if (1) {
           my (@css, @class);
           my $fat = sum map { length $_ } @$css;
           for my $cs (@$css) {
               G.jumb.occie->{$cs}++; #<in
               if (my $out = G.yomp.occie->{$cs}) {
                      push @class, $out;
               }
               else {
                   push @css, $cs;
               }
           }
           my $csin = sum map { length $_ } @css;
           my $clin = sum map { length $_ } @class;
           sayyl "Komp: $fat -> $csin      $clin"  if 4.97 < rand 5;
           at.class = join' ',@class if @class;
           # and redo:
           at.style = join '', map{"$_;"}
           grep{defined} map { split ';' } @css;
       }
   n_D:
     fresh_init: |
       # really whenever bored
       timer 6 { w $R occie/komp; };
       recur 40 { w $R occie/komp; };
     styleshout: |
       # entropia & komp
     komp: |
       return unless G.jumb.occie;
       my $u = Rw hamz style occie;
       Rw toof + $u occie;
 - K: toof #c
   D: |
      my $c = shift @$m;
      $u || die "look for u>?"; 
      
      my $pool = G.jumb->{$c};
      
      my @pool = map { { of => $_, sc => $pool->{$_} } } sort keys %$pool;
      
      say "toof $c is ".@pool;
      
      my @order = reverse sort { a.sc <=> b.sc } @pool;
      
      my $komp = {}; # forward and back 
      my $limit = 250;
      my $aimit = @order / 1.2;
      for my $o (@order) {
          last if o.sc < 5;
          # oras ratio ^ rolling
          
          last if $limit-- < 1;
          last if $aimit-- < 1;
          
          my $sty = join('', map{"$_;"} grep{defined} split ';', o.of) || die;
          
          my ($heex) = $H->dig($sty) =~ /^(...)/;
          $heex =~ tr/0123456789/ghijklmnop/; # no numbers
          # TODO name it
          my $y = "s".$heex;
          $komp->{$y} = $sty;
      }
      
      my $wi = keys %$komp;
      $wi || return sayre "NOTHING TO COMPRESS";
      sayyl "compression is $wi wide";

      # komp carbonises, makes up style
      G.yomp->{$c} = {reverse %$komp};

      # ^ to maka, draws in
      # v to elvis, draws out
      
      my $was = u.sheet;
      u.sheet = join "\n", map { ".$_ { $komp->{$_} }" } sort keys %$komp;

      w mux[$u] if u.sheet ne $was;
 - K: round #c regroup - smush cove + copy here -> there
   D: |
       # could multiple J sources and exits, provide roundness, generally...
       # not just from this J but spacing out logic according from what changed
       # a style or intentness of the bzling reshadow
       # increment
       
       my @be = Rw tvo $J:J2;
       my $jit; # cv / l / t / $j
       my $ji = {map{$_=>[]}0..9};
       
       for my $j (@be) {
           $jit->{j.cv}->{j.l}->{j.t} && die;
           $jit->{j.cv}->{j.l}->{j.t} = $j;
           next unless j.l eq j.t; # just deal thing spines
           j.cv =~ /^0\.(\d)/ || die;
           my $cvb = $1;
           push @{$ji->{$cvb}}, $j;
       }
       
       # wavesmush # DOESn't do spaceouts
       # but that old... 
       my $away;
       sayyl "Be: ".@be;
       my $id = J.yy.round.id || 2;
       for my $i (0..9) {
           my $lo = $ji->{$i-1};
           my $no = $ji->{$i};
           my $ro = $ji->{$i+1};
           
           my $bulg = @$no - $id if @$no > $id;
           if ($bulg > 0 && $lo && @$lo < $id) {
               my $idspacl = $id - @$lo;
               push @$lo, map { shift @$no } 1..$idspacl;
           }
           
           $bulg = 0;
           $bulg = @$no - $id if @$no > $id;
           if ($bulg > 0 && $ro) { # without varing  && @$ro < $id
               unshift @$ro, map { pop @$no } 1..$bulg;
           }
           elsif ($bulg > 0) {
               # could flip everything around, raise $id,
               # slosh back toward the middle again
               # very painterly
               # hidden realms
               pop @$no for 1..$bulg;
               $away = {bulg=>$away};
           }
           
       }
       
       
       # measure $ji, mod up locations for things
       # give original j.cv if the $cvb/ set is same
       for my $cvb (sort keys %$ji) {
           my $no = $ji->{$cvb};
           my @cvs = map{_.cv}@$no;
           #die join(":",@cvs) if join(":",@cvs) ne join(":", sort @cvs);
           
           if (@cvs != uniq @cvs) {
               
               my $warp = @$no;
               @cvs = map { "0.".$cvb.$_ } Rw cv/oe $v:warp;
               # wind for thi like in mod
           }
           
           for my $j (@$no) {
               my $ncv = shift @cvs;
               my $ts = $jit->{j.cv}->{j.l};#/j.t => $j
               for my $k (sort keys %$ts) {
                   my $tj = $ts->{$k};
                   if (tj.t eq tj.l) {
                       J.bz->(j.l."%origin\t".$ncv, $tj); # subtlest A-tion
                       J2.bz->(j.l."%waves\t".$ncv, $j); # subtlest A-tion
                   }
                   J.bz->(tj.t."\t".$ncv, tj.s);
               }
           }
       }
       
       if ($away) {
           J.bz->("buckstop\t0.999" => "@".away.bulg."...",
           '%css' => 'color:blue');
       }
       

