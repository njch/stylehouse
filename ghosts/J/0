
C:
 - K: J #c fit in Ds later, which are Js too.
   Gw: 1
   S:
     jsrm: fadeOut(1000, function() { $(this).remove(); }); 
   
 - K: L #c new Ds
   Gw: 1
   
 - K: yep #c impulsive little geometers
   D:
     jCendo: |
       # 
Ray: 
 - K: J
   findway: R_J 
hooks:

  J: # JJJJJJ html pool... 
    print: |
      " JHaya S.name ^S.style^";
    flows_D: |
      w G.theJ setup[$S]; # J level
    uxyou_D: |
      my $bits = join '', split /\D/, S.name;
      ux.conor = 1.7.$bits;
    S: 
      ishtml: 1
      content_D: |
        w G.theJ hiss(J=>$S); # sixer
      Z:
        position: absolute
        width: 100%
        height: 100%
        border: 2px solid rgba(0,0,0,0.3)
        
    E:
      _D: |
        sayyl "To ".$S->pi;
        #w G.theR E[$S, $e];
  L: #c new Ds, a landing to put your stuff on while Js thrash it above
   # hiss may reach out and balance Cs from L into the geo
    print: |
      "S.name o S.id";
    S:
      Z:
        position: absolute
        height: 60%
        width: 60%
        right: 15%
        top: 5%
        font-size: 60%
        border: 1em solid rgba(0,0,0,0.7)
        
  dies_D: |
    if (u.K eq 'L') {
        # let go of the grabbed # some other set can figure it out
        # likely to be gone too via Jassacre pre hijack
        # BEFORE non del cascades delete through n_S
        my @gra = grep {_.L ne $u} map{_.i} @{u.A.n_S||[]};
        0->deaccum(u.A, 'n_S', _.a) for @gra;
        
        #w G.R del[
    }
    if (u.K eq 'J') {
        if (my $l = u.L) {
        # whip things out? M.vom should diff, should fall into the grass of M?
            w G.R del(u=>$l);
        }
    }
    w mux[$u];
  percolate_R: | # capow! R
    G.theJ = $G->R('J');
  percolate: | # waft R
    w jak;
    #recur 7 { $H->la < 1 && w jak; };
  any_init: |
    w jak;  #waylay 2 G.theJ poke;
  jak: |
    w Jassacre;
    my $j = w G.theJ hijack;
  Jassacre: |
    w G.R del(u=>$_) for K J;
  layp: | # TODO a J in itself
    my ($latest) = reverse sort{ a.hitime <=> b.hitime } K J;
    w peev;
    w pv(i=>$latest, t=>'{bb', n=>2);
    
  peev: | # look
    my @a = K J;
    push @a, K R:J;
    w pv(i=>\@a, n=>1);
R_Jz:

  - K: poke #c
    D: |
      my @w;
          push @w, "Yheaps";
          push @w, Rw suck */curves;
          
          w pv(i=>\@w);
  - K: suck #c
    D: |
      #saygr "Got a J!".ar.J->pi."  @{ar.m}" if ar.J;
      my @ps = Rw fi +;
      my @wo;
      for my $p (@ps) {
          my ($dp) = split '/', $p; # domepiece (K) must be in our Jytterspace
          next if ar.J && !ar.J.yt->{$dp};
          push @wo, w $R $p;
      }
      @wo
      
  - K: fi #c
    D: |
      my %wo = Rw findl +;
      map { s/^\///; $_ } keys %wo; 
      
  - K: findl #c
    D: |
            my $point = ar.p || ar.m->[0];
            my @path = split /\/|\./, $point;
            my $h = ar.h || R.way;
            $h = h.hooks if h.hooks;
            
            my $doig;
            $doig = sub {
                my ($p,$h,$s) = @_;
                my @a = @$p;
                
                return $s => $h if !@a; 
                
                ($p) = shift @a;
                
                return undef if !ref $h;
                
                if (exists $h->{$p}) { 
                    $h = $h->{$p};
                    return $doig->([@a],$h,"$s/$p");
                }
                else {
                    if ($p =~ /^(.*)\*(.*)$/) {
                        my ($l,$r) = ($1, $2);
                        my $ma = join '.+', split /\*/, $p;
                        my @ke = grep { /^$l.+$r$/ } keys %$h;
                        my @wu;
                        for my $tk (@ke) {
                            push @wu, $doig->([@a], $h->{$tk}, "$s/$tk");
                        }
                        @wu = grep {defined} @wu;
                        return @wu;
                    }
                    else {
                        return undef;
                    }
                }
            };
            
            grep {defined} $doig->([@path], $h, '');
  - K: bacup #c SCHEMA
    D: |
        my $ss_Ds = R.S.ss_Ds = Load(<<'');
                  n: |
                     n.HASH = {};
                  Ai: |
                     Ai.A = {};
                  Gi: |
                     my $likes = {map{$_=>1}qw{G ways}};
                     Gi.HASH = {
                      it => sub {
                        my $h = shift;
                        my @r = map { { K=>$_, k=>"{".$_, v=>$h->{$_} } } sort keys %$h
                      },
                     };
        
        for my $k (sort keys %$ss_Ds) { # or K array who knows
            my $u = R.S.ss->{$k} = w $R dus;
            my $D = $ss_Ds->{$k};
            $G->D({bab=>$D, ar=>{$k=>$u}});
        }
        
R_surz:
    - K: Jaction #c
      key:
        J: J
        SJ: SJ
        P: P
        I: I
      n_D:
        I: |
          w G.theJ poke;
        SJ: |
          w Jassacre;
        J: |
          w jak;
        P: |
          w layp;

