
C:
 - K: J #c fit in Ds later, which are Js too.
   Gw: 1
   S:
     jsrm: fadeOut(1000, function() { $(this).remove(); }); 
   
 - K: L #c new Ds
   Gw: 1
   
 - K: yep #c impulsive little geometers
   D:
     jCendo: |
       # 
Ray: 
 - K: J
   findway: R_J 
hooks:

  J: # JJJJJJ html pool... 
    print: |
      " JHayaja Shiva Shakary"
    flows_D: |
      w G.theJ setup[$S]; # J level
    uxyou_D: |
      my $bits = join '', split /\D/, S.name;
      ux.conor = 1.7.$bits;
    S: 
      ishtml: 1
      content_D: |
        w G.theJ hiss(J=>$S); # sixer
      Z:
        position: fixed
        height: 62em
        width: 62em
        left: 10%
        top: 10%
        border: 1em solid rgba(0,0,0,0.7)
        
    E:
      _D: |
        sayyl "To ".$S->pi;
        #w G.theR E[$S, $e];
  L: #c new Ds, a landing to put your stuff on while Js thrash it above
   # hiss may reach out and balance Cs from L into the geo
    S:
      Z:
        position: fixed
        height: 62em
        width: 62em
        left: 10%
        top: 10%
        border: 1em solid rgba(0,0,0,0.7)
        
  percolate_R: | # capow! R
    G.theJ = $G->R('J');
  percolate: | # waft R
    w jak;
    #recur 7 { $H->la < 1 && w jak; };
  any_init: |
    w jak;  #waylay 2 G.theJ poke;
  jak: |
    w Jassacre;
    my $j = w G.theJ hijack;
  Jassacre: |
    w G.R del(u=>$_) for K J;
  layp: | # TODO a J in itself
    my ($latest) = reverse sort{ a.hitime <=> b.hitime } K J;
    w peev;
    w pv(i=>$latest, t=>'{bb', n=>2);
    
  peev: | # look
    my @a = K J;
    push @a, K R:J;
    w pv(i=>\@a, n=>1);
R_Jz:
  - K: hijack #c hit J
    D: |
      my $J = w G.theJ makeJ;
      J.spiral = 'jitterbug';
      
      for ($J) {
          _.hol = "H.style/H.name/H.id"; # data bass
          _.tiNZ = 'NZ!';
          _.hitime = $H->hitime;
          w mux(u=>$_);
      }
      $J
  - K: makeJ #c
    D: |
      my $name = ar.name || "J".G.Jnumb++; # additively
      my $u = {K=>'J',name=>$name}; 
      my $J = w G.R fuu[$u];
      Rw uphere/makeJ $J;
      sayyl "made ++ ".$J->pi;
      $J
  - K: poke #c
    D: |
      my @w;
          push @w, "Yheaps";
          push @w, Rw suck */curves;
          
          w pv(i=>\@w);
  - K: suck #c
    D: |
      #saygr "Got a J!".ar.J->pi."  @{ar.m}" if ar.J;
      my @ps = Rw fi +;
      my @wo;
      for my $p (@ps) {
          my ($dp) = split '/', $p; # domepiece (K) must be in our Jytterspace
          next if ar.J && !ar.J.yt->{$dp};
          push @wo, w $R $p;
      }
      @wo
      
  - K: fi #c
    D: |
      my %wo = Rw findl +;
      map { s/^\///; $_ } keys %wo; 
      
  - K: findl #c
    D: |
            my $point = ar.p || ar.m->[0];
            my @path = split /\/|\./, $point;
            my $h = ar.h || R.way;
            $h = h.hooks if h.hooks;
            
            my $doig;
            $doig = sub {
                my ($p,$h,$s) = @_;
                my @a = @$p;
                
                return $s => $h if !@a; 
                
                ($p) = shift @a;
                
                return undef if !ref $h;
                
                if (exists $h->{$p}) { 
                    $h = $h->{$p};
                    return $doig->([@a],$h,"$s/$p");
                }
                else {
                    if ($p =~ /^(.*)\*(.*)$/) {
                        my ($l,$r) = ($1, $2);
                        my $ma = join '.+', split /\*/, $p;
                        my @ke = grep { /^$l.+$r$/ } keys %$h;
                        my @wu;
                        for my $tk (@ke) {
                            push @wu, $doig->([@a], $h->{$tk}, "$s/$tk");
                        }
                        @wu = grep {defined} @wu;
                        return @wu;
                    }
                    else {
                        return undef;
                    }
                }
            };
            
            grep {defined} $doig->([@path], $h, '');
  - K: bacup #c SCHEMA
    D: |
        my $ss_Ds = R.S.ss_Ds = Load(<<'');
                  n: |
                     n.HASH = {};
                  Ai: |
                     Ai.A = {};
                  Gi: |
                     my $likes = {map{$_=>1}qw{G ways}};
                     Gi.HASH = {
                      it => sub {
                        my $h = shift;
                        my @r = map { { K=>$_, k=>"{".$_, v=>$h->{$_} } } sort keys %$h
                      },
                     };
        
        for my $k (sort keys %$ss_Ds) { # or K array who knows
            my $u = R.S.ss->{$k} = w $R dus;
            my $D = $ss_Ds->{$k};
            $G->D({bab=>$D, ar=>{$k=>$u}});
        }
        
R_surz:
    - K: Jaction #c
      key:
        J: J
        SJ: SJ
        P: P
        I: I
      n_D:
        I: |
          w G.theJ poke;
        SJ: |
          w Jassacre;
        J: |
          w jak;
        P: |
          w layp;

