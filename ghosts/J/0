
C:
 - K: J #c fit in Ds later, which are Js too.
   Gw: 1
   
   
 - K: yep #c impulsive little geometers
   D:
     jCendo: |
       # 
Ray: 
 - K: J
   findway: R_J 
hooks:
  any_init: |
    w G.theR Jaction/J;    
  J: # JJJJJJ <-> W@M etc
    print: |
      " JHayaja Shiva Shakary"
    flows_D: |
      w G.theJ setup[$S]; # J level
    uxyou_D: |
      ux.conor = 0.7;
    S: 
      ishtml: 1
      content_D: |
        w G.theJ hiss(J=>$S); # sixer
      Z:
        height: 23em
        width: 47%
    E:
      _D: |
        sayyl "To ".$S->pi;
        #w G.theR E[$S, $e];
  percolate_R: | # capow! R
    G.theJ = $G->R('J');
    waylay wup;
  wup: |
    w G.theR Jaction/J;
  peev: | # look
    my @a = K J;
    push @a, K R:J;
    w pv(i=>\@a, n=>1);
R_surz:
    - K: Jaction #c
      key:
        J: J
        SJ: SJ
        P: P
      n_D:
        SJ: |
          w G.R del(u=>$_) for K J;
        J: |
          w $R Jaction/SJ;
          my $j = w G.theJ hijack;
        P: |
          my ($latest) = reverse sort{ a.hitime <=> b.hitime } K J;
          w peev;
          w pv(i=>$latest, t=>'{bb', n=>2);
    - K: t_w_a #c thingness <-> appearance
      babz:
        'maka 4': |
          my @r = $G->stylekeysort(a.bb);

          a.o = {}; # by voltage, peel
          for my $r (@r) {
                  my ($l, $vo, $or) = split /\s+/, $r; # split style, vectory

                  saygr "igggy $l $vo > a.cv" && next if $cv && $vo > $cv;

                  $or = $vo if !defined $or;

                  my $o = a.o->{$or} ||= []; 
                  push @$o, $r;
          }
              #thingness <-> appearance
              my $th = {};
              my $ap = {};
              my @int;
              for my $ov (sort keys %{a.o}) {
                   my $o = a.o->{$ov};

                   for my $r (@$o) {
                       my $j = $R->shj($r, a.bb);
                       
                       j.style ? do {
                           push @{$ap->{j.l} ||= []}, $j;
                       } : do {
                            warn "replacemont j.l ".wdump(3,[$j,$th->{j.l}]) if exists $th->{j.l};
                           $th->{j.l} = $j;
                           push @int, j.l;
                       }
                  }
              }
R_Jz:
  - K: hijack #c hit J
    D: |
      my $Jhi = w G.theJ makeJ;
      Jhi.spiral = 'dolphy';
      my $J = w G.theJ makeJ;
      J.spiral = 'jitterbug';
      
      for ($J, $Jhi) {
          _.hol = "H.style/H.name/H.id"; # data bass
          _.tiNZ = 'NZ!';
          _.hitime = $H->hitime;
          w mux(u=>$_);
      }
      w G.theD i(i=>$J); # chuck J unit over there
      $J
  - K: makeJ #c
    D: |
      my $name = ar.name || "J".G.Jnumb++; # additively
      my $u = {K=>'J',name=>$name}; 
      my $J = w G.R fuu[$u]; 
      sayyl "made ++ ".$J->pi;
      $J
  - K: bacup #c SCHEMA
    D: |
        my $ss_Ds = R.S.ss_Ds = Load(<<'');
                  n: |
                     n.HASH = {};
                  Ai: |
                     Ai.A = {};
                  Gi: |
                     my $likes = {map{$_=>1}qw{G ways}};
                     Gi.HASH = {
                      it => sub {
                        my $h = shift;
                        my @r = map { { K=>$_, k=>"{".$_, v=>$h->{$_} } } sort keys %$h
                      },
                     };
        
        for my $k (sort keys %$ss_Ds) { # or K array who knows
            my $u = R.S.ss->{$k} = w $R dus;
            my $D = $ss_Ds->{$k};
            $G->D({bab=>$D, ar=>{$k=>$u}});
        }
        

