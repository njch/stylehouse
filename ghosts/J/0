
C:
 - K: J #c fit in Ds later, which are Js too.
   Gw: 1
   S:
     jsrm: fadeOut(1000, function() { $(this).remove(); }); 
   
 - K: L #c new Ds
   Gw: 1
   
 - K: yep #c impulsive little geometers
   D:
     jCendo: |
       # 
Ray: 
 - K: J
   findway: R_J 
hooks:

  J: # JJJJJJ html pool... 
    print: |
      S.name;
    flows_D: |
      w G.theJ suJ(J=>$S); # J level
    uxyou_D: |
      my $bits = join '', split /\D/, S.name;
      ux.conor = 1.7.$bits;
    S: 
      ishtml: 1
      content_D: |
        w G.theJ hiss(J=>$S); # sixer
      Z:
        position: absolute
        pointer-events: none
        width: 90%
        height: 100%
        #border: 2px solid rgba(0,0,0,0.3)
  L: #c new Ds, a landing to put your stuff on while Js thrash it above
   # hiss may reach out and balance Cs from L into the geo
    print: |
      "S.name o S.id";
    S:
      Z:
        height: 100%
        width: 100%
        position: absolute
        
  event: |
    if (i.K ne 'J') {
        w $i event_D;
        return;
    }
    my $R = G.theJ;
    Rw event $J:i $e $r:ar;
  non_event: |
    return sayre "Event bore" if !e.k;
    my $R = G.theJ;
    my $yep = Rw eventkeygrab/grab $e $r:ar;
    return sayyl " Hit event anyway" if $yep;
    sayre "non event";
     
  dies_D: |
    if (u.K eq 'L') {
        # let go of the grabbed # some other set can figure it out
        # likely to be gone too via Jassacre pre hijack
        # BEFORE non del cascades delete through n_S
        my @gra = grep {_.L ne $u} map{_.i} @{u.A.n_S||[]};
        0->deaccum(u.A, 'n_S', _.a) for @gra;
    }
    if (u.K eq 'J') {
        if (my $l = u.L) {
        # whip things out? M.vom should diff, should fall into the grass of M?
            w G.R del(u=>$l);
        }
    }
    w mux[$u];
  percolate_R: | # capow! R
    G.theJ = $G->R('J');
  percolate: | # waft R
    w jak;
    #recur 7 { $H->la < 1 && w jak; };
  fresh_init: |
    H.nosuddendeath = 1;
    G.jumb.cos = {qw(
       1 white
       2 orange
       3 red
       4 blue
       5 yellow
       6 brown
       7 green
       8 pink
       9 purple
    )};
  recoded_init: |
    #waylay jak;  #waylay 2 G.theJ poke;
  any_init: |
    my $wo = $G->CsK({K=>'W'});
    wo.S.styles = 'OxO nopoi ab';
  jak: |
    w Jassacre;
    my $R = G.theJ;
    Rwyl 1 hijack;
  Jassacre: |
    w G.R del(u=>$_) for K J;
  layp: | # TODO a J in itself
    my ($latest) = reverse sort{ a.hitime <=> b.hitime } K J;
    w peev;
    w pv(i=>$latest, t=>'{bb', n=>2);
    
  peev: | # look
    my @a = K J;
    push @a, K R:J;
    w pv(i=>\@a, n=>1);


R_nonz:
  - K: insteta #c
    babz:
      'fuu 3': |
        saybl " IN J 0  SWAY" for 1..10;
        my $uu = $G->sway({K=>u.K}, $u);
        # if many, combine...
      
  - K: CsK #c TODO C vortex reading # TODO
    D: |
        my ($p, $GG) = @_;
        $GG ||= $G;
        p.s ||= 'Cs C';
        my @topK = split ' ', delete p.s;
        my @Cs = map { flatline($_) } map { $GG->anyway($_) } @topK;
        @Cs = grep { 0->ip($p, $_) } @Cs if %$p;
        return wantarray ? @Cs : shift @Cs;
  - K: sway #c
    D: |
        # sucks way matching $p # only supports matching K for now
        my ($p, $s, $P) = @_;
        my ($from) = p.from || 0->CsK($p);
        
        $from || defined P.e || return undef;
        
        my $w = $G->nw();
        $w->from($from) if $from;
        $w->from($p) unless $from;
        $w->from($s) if $s && %$s; # merges in B :D
        
        return $w

