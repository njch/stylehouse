
C:
 - K: J #c fit in Ds later, which are Js too.
   Gw: 1
   
   
 - K: yep #c impulsive little geometers
   D:
     jCendo: |
       # 
Ray: 
 - K: J
   findway: R_J 
hooks:

  J: # JJJJJJ <-> W@M etc
    print: |
      " JHayaja Shiva Shakary"
    flows_D: |
      w G.theJ setup[$S]; # J level
    uxyou_D: |
      my $bits = join '', split /\D/, S.name;
      ux.conor = 1.7.$bits;
    S: 
      ishtml: 1
      content_D: |
        w G.theJ hiss(J=>$S); # sixer
      Z:
        position: fixed
        height: 22em
        width: 22em
        left: 30%
        top: 20%
        background: black
        
    E:
      _D: |
        sayyl "To ".$S->pi;
        #w G.theR E[$S, $e];
  percolate_R: | # capow! R
    G.theJ = $G->R('J');
  percolate: | # waft R
    w G.theR Jaction/J;
    #timer 0.2 { w G.theR Jaction/J; };
  any_init: |
    w G.theR Jaction/J;
    waylay 2 G.theJ poke;
  peev: | # look
    my @a = K J;
    push @a, K R:J;
    w pv(i=>\@a, n=>1);
R_Jz:
  - K: hijack #c hit J
    D: |
      my $J = w G.theJ makeJ;
      J.spiral = 'jitterbug';
      
      for ($J) {
          _.hol = "H.style/H.name/H.id"; # data bass
          _.tiNZ = 'NZ!';
          _.hitime = $H->hitime;
          w mux(u=>$_);
      }
      #w G.theD i(i=>$J); # chuck J unit over there
      $J
  - K: makeJ #c
    D: |
      my $name = ar.name || "J".G.Jnumb++; # additively
      my $u = {K=>'J',name=>$name}; 
      my $J = w G.R fuu[$u]; 
      sayyl "made ++ ".$J->pi;
      $J
  - K: poke #c
    D: |
          #Rw */flam zzz;
          my $p = '*/curves';
          my @w = Rw findl $p:_ for $p;
          
          my @wo = 
          map { w $R $_; } Rw fi */curves;
           
          push @w, "Would:", @wo;
          my $w = [
          Rw suck */curves,
          ];
          
          push @w, Rw suck */curves;
          
          w pv(i=>\@w);
  - K: suck #c
    D: |
      my @ps = Rw fi +;
      my @wo;
      for my $p (@ps) {
          my ($dp) = split '/', $p; # domepiece (K) must be in our Jytterspace
          next if ar.J && ar.J.yt->{$dp};
          push @wo, w $R $p;
      }
      @wo
      
  - K: fi #c
    D: |
      my %wo = Rw findl +;
      map { s/^\///; say $_; $_ } keys %wo; 
      
  - K: findl #c
    D: |
            my $point = ar.p || ar.m->[0];
            my @path = split /\/|\./, $point;
            my $h = ar.h || R.way;
            $h = h.hooks if h.hooks;
            
            my $doig;
            $doig = sub {
                my ($p,$h,$s) = @_;
                my @a = @$p;
                
                return $s => $h if !@a; 
                
                ($p) = shift @a;
                
                return undef if !ref $h;
                
                if (exists $h->{$p}) { 
                    $h = $h->{$p};
                    return $doig->([@a],$h,"$s/$p");
                }
                else {
                    if ($p =~ /^(.*)\*(.*)$/) {
                        my ($l,$r) = ($1, $2);
                        my $ma = join '.+', split /\*/, $p;
                        my @ke = grep { /^$l.+$r$/ } keys %$h;
                        my @wu;
                        for my $tk (@ke) {
                            push @wu, $doig->([@a], $h->{$tk}, "$s/$tk");
                        }
                        @wu = grep {defined} @wu;
                        return @wu;
                    }
                    else {
                        return undef;
                    }
                }
            };
            
            grep {defined} $doig->([@path], $h, '');
  - K: bacup #c SCHEMA
    D: |
        my $ss_Ds = R.S.ss_Ds = Load(<<'');
                  n: |
                     n.HASH = {};
                  Ai: |
                     Ai.A = {};
                  Gi: |
                     my $likes = {map{$_=>1}qw{G ways}};
                     Gi.HASH = {
                      it => sub {
                        my $h = shift;
                        my @r = map { { K=>$_, k=>"{".$_, v=>$h->{$_} } } sort keys %$h
                      },
                     };
        
        for my $k (sort keys %$ss_Ds) { # or K array who knows
            my $u = R.S.ss->{$k} = w $R dus;
            my $D = $ss_Ds->{$k};
            $G->D({bab=>$D, ar=>{$k=>$u}});
        }
        
R_surz:
    - K: Jaction #c
      key:
        J: J
        SJ: SJ
        P: P
        I: I
      n_D:
        I: |
          w G.theJ poke;
        SJ: |
          w G.R del(u=>$_) for K J;
        J: |
          w $R Jaction/SJ;
          my $j = w G.theJ hijack;
        P: |
          my ($latest) = reverse sort{ a.hitime <=> b.hitime } K J;
          w peev;
          w pv(i=>$latest, t=>'{bb', n=>2);

