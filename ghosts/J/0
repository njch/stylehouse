
C:
 - K: J #c fit in Ds later, which are Js too.
   Gw: 1
   S:
     jsrm: fadeOut(1000, function() { $(this).remove(); }); 
   
 - K: L #c new Ds
   Gw: 1
   
 - K: yep #c impulsive little geometers
   D:
     jCendo: |
       # 
Ray: 
 - K: J
   findway: R_J 
hooks:

  J: # JJJJJJ html pool... 
    print: |
      S.name;
    flows_D: |
      w G.theJ setup(J=>$S); # J level
    uxyou_D: |
      my $bits = join '', split /\D/, S.name;
      ux.conor = 1.7.$bits;
    S: 
      ishtml: 1
      content_D: |
        w G.theJ hiss(J=>$S); # sixer
      Z:
        position: absolute
        width: 100%
        height: 100%
        #border: 2px solid rgba(0,0,0,0.3)
  L: #c new Ds, a landing to put your stuff on while Js thrash it above
   # hiss may reach out and balance Cs from L into the geo
    print: |
      "S.name o S.id";
    S:
      Z:
        height: 90%
        width: 90%
        position: absolute
        top: 5%
        left: 5%
        #font-size: 60%
        #border: 1em solid rgba(0,0,0,0.7)
        
  event: |
    if (i.K ne 'J') {
        w $i event_D;
        return;
    }
    my $R = G.theJ;
    Rw event $J:i $e $r:ar;
  dies_D: |
    if (u.K eq 'L') {
        # let go of the grabbed # some other set can figure it out
        # likely to be gone too via Jassacre pre hijack
        # BEFORE non del cascades delete through n_S
        my @gra = grep {_.L ne $u} map{_.i} @{u.A.n_S||[]};
        0->deaccum(u.A, 'n_S', _.a) for @gra;
    }
    if (u.K eq 'J') {
        if (my $l = u.L) {
        # whip things out? M.vom should diff, should fall into the grass of M?
            w G.R del(u=>$l);
        }
    }
    w mux[$u];
  percolate_R: | # capow! R
    G.theJ = $G->R('J');
  percolate: | # waft R
    w jak;
    #recur 7 { $H->la < 1 && w jak; };
  fresh_init: |
    H.nosuddendeath = 1;
    G.jumb.cos = {qw(
       1 white
       2 orange
       3 red
       4 blue
       5 yellow
       6 brown
       7 green
       8 pink
       9 purple
    )};
    timer 3 { w G.theJ occie/komp; };
    recur 40 { w G.theJ occie/komp; };
    Pr S/hut/S 'reexec';
  recoded_init: |
    #waylay jak;  #waylay 2 G.theJ poke;
    die unless H.db->ping;
  jak: |
    w Jassacre;
    my $j = w G.theJ hijack;
  Jassacre: |
    w G.R del(u=>$_) for K J;
  layp: | # TODO a J in itself
    my ($latest) = reverse sort{ a.hitime <=> b.hitime } K J;
    w peev;
    w pv(i=>$latest, t=>'{bb', n=>2);
    
  peev: | # look
    my @a = K J;
    push @a, K R:J;
    w pv(i=>\@a, n=>1);

R_surz:
    - K: Jaction #c
      key:
        J: J
        SJ: SJ
        P: P
        I: I
        Y: Y
      n_D:
        Y: |
          w G.theJ occie/komp;
        I: |
          w G.theJ poke;
        SJ: |
          w Jassacre;
        J: |
          w jak;
        P: |
          w layp;

