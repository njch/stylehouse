
C:
 - K: J #c fit in Ds later, which are Js too.
   Gw: 1
   
   
 - K: yep #c impulsive little geometers
   D:
     jCendo: |
       # 
Ray: 
 - K: J
   findway: R_J 
hooks:
  J:
    flows_D: |
      w G.theJ setup[$S]; # J level
  percolate_R: | # capow! R
    G.theJ = $G->R('J');
  
R_surz:
    - K: Jaction 
      key:
        J: J
      n_D:
        J: |
          my $J = w G.theJ makeJ;
          J.hol = "H.style/H.name/H.id";
          J.tiNZ = 'NZ!';
          J.hitime = $H->hitime;
          w G.theD i(i=>$J);
R_Jz:
  - K: makeJ
    D: |
      my $name = ar.name || "J".G.Jnumb++; # additively
      my $u = {K=>'J',name=>$name}; 
      my $J = w G.R fuu[$u]; 
      sayyl "made ++ ".$J->pi;
      $J
  - K: phat #c sets up $a with bb-domin & accessors
    D: |
        a.bb = {};
        a.ord = [];
        a.bz = w $R as(bb=>a.bb, ord=>a.ord);
        a.fro = sub {
            my $fro = [a.bz, @_];
            w $R gpfro(a=>$fro);
        };
  - K: gpfro #c
    D: |
      my ($aser, $l, $u, $cv, @etc) = @$a;
      
      my $gp = {u=>$u, cv=>$cv};
      if (ref gp.cv) {
          my $mcv = delete gp.cv;
          %$gp = (%$gp, %$mcv);
      }
      my $v = w $R gp(a => $gp);
            
      $aser->($l => $v,
          '%gp' => $gp,
          @etc,
      );
    
  - K: shj #c pronounce $j{r,s,t,cv,ev} from given $r and $d
    D: |
      my ($r, $d) = @_;
      my $j;
      j.r = $r;
      j.s = ref $d eq 'HASH' ? $d->{$r} : $d; # carbon in
      (j.t, j.cv) =
          j.r =~ /^(.+)\t(.+?)$/ ? ($1, $2)
          :
          split /\s+/, j.r, 2;
      (j.cv, my @e) = split /\s+/, j.cv;
      j.ev = \@e if @e;
      $j
  - K: bacup #c SCHEMA
    D: |
        my $ss_Ds = R.S.ss_Ds = Load(<<'');
                  n: |
                     n.HASH = {};
                  Ai: |
                     Ai.A = {};
                  Gi: |
                     my $likes = {map{$_=>1}qw{G ways}};
                     Gi.HASH = {
                      it => sub {
                        my $h = shift;
                        my @r = map { { K=>$_, k=>"{".$_, v=>$h->{$_} } } sort keys %$h
                      },
                     };
        
        for my $k (sort keys %$ss_Ds) { # or K array who knows
            my $u = R.S.ss->{$k} = w $R dus;
            my $D = $ss_Ds->{$k};
            $G->D({bab=>$D, ar=>{$k=>$u}});
        }
        

