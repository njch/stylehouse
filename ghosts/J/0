
C:
 - K: J #c fit in Ds later, which are Js too.
   Gw: 1
   
   
 - K: yep #c impulsive little geometers
   D:
     jCendo: |
       # 
Ray: 
 - K: J
   findway: R_J 
hooks:
  J:
    print: |
      " JHayaja Shiva Shakary"
    flows_D: |
      w G.theJ setup[$S]; # J level
    S: 
      ishtml: 1
      content_D: | 
        "Wup"
    E:
      _D: |
        sayyl "To ".$S->pi;
        #w G.theR E[$S, $e];
  percolate_R: | # capow! R
    G.theJ = $G->R('J');
  
R_surz:
    - K: Jaction 
      key:
        J: J
      n_D:
        J: |
          my $J = w G.theJ makeJ;
          J.hol = "H.style/H.name/H.id";
          J.tiNZ = 'NZ!';
          J.hitime = $H->hitime;
          w G.theD i(i=>$J);
R_Jz:
  - K: makeJ #c
    D: |
      my $name = ar.name || "J".G.Jnumb++; # additively
      my $u = {K=>'J',name=>$name}; 
      my $J = w G.R fuu[$u]; 
      sayyl "made ++ ".$J->pi;
      $J
  - K: setup #c
    D: |
      my $a = S.a = {};
      w $R phat[$a];
  - K: phat #c sets up $a with bb-domin & accessors
    D: |
        a.bb = {};
        a.ord = [];
        a.bz = w $R as(bb=>a.bb, ord=>a.ord);
        a.fro = sub {
            my $fro = [a.bz, @_];
            w $R gpfro(a=>$fro);
        };
  - K: as #c get abulator
    D: |
        #my $bb = shift;
        #my $ord = shift;
        my $j = {};
        my $do;
        $do = sub {
            my $j = {%$j};
            my $ad = [@_];
            my %j = %$j;
            while (@$ad) {
                my ($k, $v) = (shift @$ad, shift @$ad);
                
                my $comp = $k =~ /^(%|\+)/;
                my $j = {%j} if $comp;
                if ($comp) {
                    $k =~ s/^\+// if $comp;
                    j.t .= $k if $comp;
                }
                else {
                    (j.t, j.cv) = split /\s+/, $k, 2;
                    %j = %$j;
                }
                j.cv || die;
                j.r = "j.t j.cv";
                j.s = $v;
                $bb->{j.r} = j.s;
                push @$ord, {%$j} if $ord;
            }
            sub{$do->(%$j, @_)}
        };
        $do
  - K: shj #c pronounce $j{r,s,t,cv,ev} from given $r and $d # post abulator but similar
    D: |
      my ($r, $d) = @_;
      my $j;
      j.r = $r;
      j.s = ref $d eq 'HASH' ? $d->{$r} : $d; # carbon in
      (j.t, j.cv) =
          j.r =~ /^(.+)\t(.+?)$/ ? ($1, $2)
          :
          split /\s+/, j.r, 2;
      (j.cv, my @e) = split /\s+/, j.cv;
      j.ev = \@e if @e;
      $j
  - K: gpfro #c fatten by 
    D: |
      my ($aser, $l, $u, $cv, @etc) = @$a;
      
      my $gp = {u=>$u, cv=>$cv};
      %$gp = (%$gp, %{delete gp.cv}) if ref gp.cv;
      
      my $v = w $R gp(a => $gp);
            
      $aser->($l => $v,
          '%gp' => $gp,
          @etc,
      );
    
  - K: bacup #c SCHEMA
    D: |
        my $ss_Ds = R.S.ss_Ds = Load(<<'');
                  n: |
                     n.HASH = {};
                  Ai: |
                     Ai.A = {};
                  Gi: |
                     my $likes = {map{$_=>1}qw{G ways}};
                     Gi.HASH = {
                      it => sub {
                        my $h = shift;
                        my @r = map { { K=>$_, k=>"{".$_, v=>$h->{$_} } } sort keys %$h
                      },
                     };
        
        for my $k (sort keys %$ss_Ds) { # or K array who knows
            my $u = R.S.ss->{$k} = w $R dus;
            my $D = $ss_Ds->{$k};
            $G->D({bab=>$D, ar=>{$k=>$u}});
        }
        

