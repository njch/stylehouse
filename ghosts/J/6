R_Jz:
 - K: hiss #c esque pingas
   D: |
      my $u = {
          id => "not",
          name => "ches",
          G => $G,
          more => "more",
          Bee => "stuff",
      };
      my $arr = {
          a => $J,
          J => $J,
          u => $u,
      };
      
      w $R up(%$arr);
      
      #J.bz->("dot$_"."\t"."0.".(60 + $_) => '.') for 1..20;
      J.bz->("000000000_$_/s"."\t"."0.$_" => $_."-------", '%css' => 'color:red') for 1..3;
      
      J.spiral || die;
      sayre "Spiral del J.spiral";
      w $R J.spiral(%$arr);
      
      
      my $html = w G.theR maka(%$arr); # stuff of 7
      
      saybl "hissings:\n".slim(250,250,$html)."\n";
      return $html
        
 - K: jitterbug #c depasoi
   D: |
     my $tvs = w $R ytv[$J];
     
     J.geo = w G.theJ makeJ(name=>J.name.'-geo');
     
     J.geo.bz->(@$_) for
         ["curve\t"."0.28" => "1rad / 0.2"];
         
     w $R geolo(J=>J.geo);
     # map onto geoloJn
     w $R phairo[$J, $tvs];
 - K: geolo #c begin digging
   D: |
     my $tvs = w $R ytv[$J];
     sayyl '.' for 1..5;
     my $tr = {};
     for my $jkv (sort keys %$tvs) { 
         # compute curve for j ns within
         sayyl "at $jkv";
         for my $j (@{$tvs->{$jkv}}) {
             $tr->{$jkv}->{j.t} = j.s;
             saybl "yep j.r          j.s";
         }
     }
     
     my @br = map{$_ * 0.1} 1..9;
     @br = uniq @br, keys %$tr;
     my $lestr = {};
     for my $b (sort @br) {
         my $plug = $tr->{$b} ? $tr->{$b} : {};
         $lestr = { %$lestr, %$plug };
         J.bz->("b%tr\t".$b => $lestr);
     }
     
     my @be = w $R tvo[$J];
     for my $bj (@be) {
         next unless bj.style;
         say wdump($bj);
     }
     
     
     
     
     
     
     
     
     
     # etc
 - K: phairo #c
   D: |
     my $phi_n = 1;
     map { $phi_n++ } map { @$_ } values %$tvs; # flatly
     
     
     say $_ for @{J.geo.ord};
     
     
     return J.geo;
     
     for my $jkv (sort keys %$tvs) { 
         # compute curve for j ns within
         sayyl "at $jkv";
         for my $j (@{$tvs->{$jkv}}) {
             my $phia = {n=>$phi_n};
             phia.ai = 0.16;
             phia.modi = { map { $_ => 0.5 } 18..$phi_n };
             w $R phi(%$phia);
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
         }
     }
     
 - K: phism #c re/progressive proJammable petalis
   D: |
          my $n = ar.n || 9;
          my $width = 100;
          my $height = 100;
          my $cx = $width / 2;
          my $cy = $height / 2;
          my $lg_diam = $width * 0.85;
          my $lg_rad = $lg_diam / 2; 
          my $outer_rad = $width*0.45;
          my $angle_incr = ar.ai || 9 / $n;
          
          my $xy = [];
          for my $i (1..$n) {
              my $ratio = $i/$n;
              my $spiral_rad = ($ratio *1.3) * $outer_rad;
              my $angi = $angle_incr + 0.15;
              $angi *= ar.modi->{$i} if ar.modi->{$i};
              my $angle = 1.2+$i*$angi;
              my $x = $cx + cos($angle) * $spiral_rad;
              my $y = $cy + sin($angle) * $spiral_rad;
              push @$xy, {
                  radial => sprintf('%.2f', atan2($x - $cx, $y - $cy)),
                  angle => sprintf('%.3f', $angle),
                  x => sprintf('%.2f', $x),
                  y => sprintf('%.2f', $y),
              };
          }
          $xy
 - K: up #c
   D: |
            my $r = {map{$_=>1} sort keys %$u};
            
            my $ordy = {
                A => 1,
                id => 11,
                K => 12,
                name => 13,
                G => 14,
                R => 14,
                W => 24,
                B => 23,
            };
            my $ydro = {};
            push @{$ydro->{$_}||=[]}, $_ for keys %$ordy;
            my @order = map { @{$ydro->{$_}} } sort keys %$ydro;
            
            my @r = grep { delete $r->{$_} } @order;
            push @r, sort keys %$r;
            
            my $ki = 0;
            my $i = 0;
            for my $k (@r) {
                my $v = $u->{$k};
                
                my $ord = $ordy->{$k} || 4;
                
                my $tee = "$k\t".'0.'.$ord;
                a.bz->($tee, ''.$v);
                
                if ($k eq 'name') {
                    a.bb->{"$k%css#wa\t"."0.$ord"} = 'border-bottom: 3px solid white';
                }
                
                $i++;
            }

