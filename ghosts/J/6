R_Jz:

 - K: geolo #c begin digging - smiling egg cup - most reentrant part
     # set up archeology site, anything you want
   D: |
     my $Jeo = J.geo; # woo
     
     for my $j (do{ grep { !_.style } w $R tvo(J=>J.geo); }) {
         #saybl "               ^^^^ yep j.cv j.t          j.s ";
         
         J.geo.bz->("b%tr\t".j.cv => {
             %{J.geo.bb->{"b%tr\t".j.cv} || {}}, # compile trs
            j.t => j.s,
         });
     }
     
     for my $pcv (map{$_ * 0.1} 1..9) {
         my $w = "b%tr\t".$pcv;
         J.geo.bz->($w => {}) if !J.geo.bb->{$w};
         # extra stick pole, sparsitor to trace by, blank as tr(ansf)
     }
     
     # and lay out
     my $last = {x=>0, y=>0, cv=>0.001, rad=>$RADIAN, spin=>0}; # downy
     for my $j (do{ grep { _.style eq 'tr' } w $R tvo(J=>J.geo); }) {
         #sayyl "       <<<< yep j.cv j.t          ".ki j.s;
         $last = {%$last};
         my $here = {};
         here.cv = j.cv;
         
         my $r = j.s;
         here.x  = last.x = r.x if exists r.x;
         here.y = last.y = r.y if exists r.y;
         
         here.rad = 4*$RADIAN * r.spun if exists r.spun;
         
         here.creatin = j.s;#$H->ejson(j.s);
         
         
         here.zoom = 4*$RADIAN * r.zoom if defined r.zoom;
         here.zoom = undef if exists r.zoom && !defined j.s.zoom;
         
         
         w $R atom[$j, $here, $last];
         
         # aft fo smoothi
         here.spin = r.curve if exists r.curve; # on the level
         
         J.geo.bz->("b%ve\t".j.cv => $here);
         $last = $here;
     }
     # etc
 - K: atom #c may +atomb? without compare you are dead
   D: |
         # spacin
         here.dist = here.cv - last.cv;
         # twistin spin inherit
         here.spin += last.spin;
         # scale local-local change
         here.rad += here.spin * here.dist * 10;
         # builds rad on rad
         here.rad += last.rad;
         # distort space
         here.zoom += last.zoom;
         here.dist *= here.zoom if here.zoom;
         # and move
         here.x = last.x + (here.rad ? cos(here.rad) : 0) * here.dist;
         here.y = last.y + (here.rad ? sin(here.rad) : 1) * here.dist;
         
 - K: phairo #c re/progressive proJammable petalis, frequency convogation
   D: |
     J.pha = Rw tent pha;
     
     my @d = grep { _.t eq _.l } w $R tvo[$J]; # dump J things into space
     my @be = grep { _.style eq 've' } w $R tvo(J=>J.geo); # poli
     
     my ($left,$right) = (undef,shift @be);
     $left ||= $right;
     
     for my $j (@d) {
         my $here = {cv => j.cv};
         
         while ($right && here.cv >= $right->{cv} ) { # adjust to poli
             # mix a pool of ways, magnetic fishing rods
             # end $left
             $left = $right;
             $right = shift @be;
             # start $right
         }
         
         here.left = $left;
         here.right = $right; # <^ follow jagging rad, spaces within
         
         my $last = left.s || {};
         w $R atom[$here, $last];
         
         J.pha.bz->(j.r => $here);
     }
     
     saygr "J pha @ ".keys %{J.pha.bb};
     
 - K: dolphy #c
   D: |
     my $tvs = w $R ytv[$J];
     
     my $phi_n = 1;
     map { $phi_n++ } map { @$_ } values %$tvs;
     my $phia = {n=>$phi_n};
     phia.ai = 0.06;
     phia.modi = { map { $_ => 0.5 } 18..$phi_n };
     my $where = w $R phi(%$phia);
     
       #sayyl "!\n";
       
     for my $jkv (sort keys %$tvs) { 
         #sayyl "at $jkv";
         for my $j (@{$tvs->{$jkv}}) {
             #sayyl "    It's j.t !";
             my $whe = shift @$where;
             $whe || die "out of spiral!";
             
             J.bz->(j.t."%css#phi"."\t".j.cv =>
               'position:absolute;'
               .'top:'.whe.x.'%;'
               .'left:'.whe.y.'%;'
               .'-webkit-transform:rotate('.whe.radial.'rad);'
               .'transform-origin:-10% -10%;' # animate that bit
             ); 
             J.bz->(j.t."%tt#phiro"."\t".j.cv => "^".whe.angle);
             # + font-size fit + whe.angle
         }
     }
       #sayyl "!\n";
 
 - K: phi #c re/progressive proJammable petalis
   D: |
     my $n = ar.n || 9;
          my $width = 100;
          my $height = 100;
          my $cx = $width / 2;
          my $cy = $height / 2;
          my $lg_diam = $width * 0.85;
          my $lg_rad = $lg_diam / 2; 
          my $outer_rad = $width*0.45;
          my $angle_incr = ar.ai || 9 / $n;
          
          my $xy = [];
          for my $i (1..$n) {
              my $ratio = $i/$n;
              my $spiral_rad = ($ratio *1.3) * $outer_rad;
              my $angi = $angle_incr + 0.15;
              $angi *= ar.modi->{$i} if ar.modi->{$i};
              my $angle = 1.2+$i*$angi;
              my $x = $cx + cos($angle) * $spiral_rad;
              my $y = $cy + sin($angle) * $spiral_rad;
              push @$xy, {
                  radial => sprintf('%.2f', atan2($x - $cx, $y - $cy)),
                  angle => sprintf('%.3f', $angle),
                  x => sprintf('%.2f', $x),
                  y => sprintf('%.2f', $y),
              };
          }
          $xy

