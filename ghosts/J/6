R_Jz:
 - K: hiss #c esque pingas
   D: |
      my $u = {
          id => "not",
          name => "ches",
          G => $G,
          more => "more",
          Bee => "stuff",
      };
      $u->{'stuff'.$_} = "$_ stuff $_" for 1..7;
      my $arr = {
          a => $J,
          J => $J,
          u => $u,
      };
      
      w $R up(%$arr);
      
      #J.bz->("dot$_"."\t"."0.".(60 + $_) => '.') for 1..20;
      J.bz->("0000_$_/s"."\t"."0.$_" =>
          $_."-------",
          '%css' => 'color:red') for 1..3;
      
      J.spiral || die;
      sayre "Spiral del J.spiral";
      w $R J.spiral(%$arr); # jitterbug
      
      
      
      
      my $html = w G.theR maka(%$arr); # stuff of 7
      
      saybl "hissings";#:\n".slim(250,250,$html)."\n";
      return $html
        
 - K: up #c
   D: |
            my $r = {map{$_=>1} sort keys %$u};
            
            my $ordy = {
                A => 1,
                id => 11,
                K => 12,
                name => 13,
                G => 14,
                R => 14,
                W => 24,
                B => 23,
                more => 4,
                stuff1 => 47,
                stuff2 => 52,
                stuff3 => 57,
                stuff4 => 60,
                stuff5 => 65,
                stuff6 => 72,
                stuff7 => 79,
            };
            my $ydro = {};
            push @{$ydro->{$_}||=[]}, $_ for keys %$ordy;
            my @order = map { @{$ydro->{$_}} } sort keys %$ydro;
            
            my @r = grep { delete $r->{$_} } @order;
            push @r, sort keys %$r;
            
            my $ki = 0;
            my $i = 0;
            for my $k (@r) {
                my $v = $u->{$k};
                
                my $ord = $ordy->{$k} || 4;
                
                my $tee = "$k\t".'0.'.$ord;
                a.bz->($tee, ''.$v);
                
                if ($k eq 'name') {
                    a.bb->{"$k%css#wa\t"."0.$ord"} = 'border-bottom: 3px solid white';
                }
                
                $i++;
            }
 - K: jitterbug #c depasoi
   D: |
     J.geo = w G.theJ makeJ(name=>J.name.'-geo');
     # make fat scrollbars long triangles, behind box of stuff
     
     J.geo.bz->(@$_) for
         ["curve\t"."0.28" => 0.5],
         ["curve\t"."0.34" => 1.3],
     ; # rad per 0.1cv? who knows
     
     # set up archeology site, anything you want
     w $R geolo[$J];
     
     J.pha = w G.theJ makeJ(name=>J.name.'-pha');
     # map what you got onto geoloJn, perhaps unwholy, resolving around poles
     w $R phairo[$J];
     
     
 - K: geolo #c begin digging - smiling egg cup
   D: |
     my $Jeo = J.geo; # woo
     sayyl '.' for 1..5;
     
     for my $j (do{ grep { !_.style } w $R tvo(J=>J.geo); }) {
         my $w = "b%tr\t".j.cv;
         my $tr = J.geo.bb->{$w} || {};
         saybl "               ^^^^ yep j.cv j.t          j.s ";
         $tr = {%{$tr}, j.t => j.s};
         J.geo.bz->($w => $tr); # ^aggregatev
     }
     
     for my $pcv (map{$_ * 0.1} 1..9) {
         my $w = "b%tr\t".$pcv;
         J.geo.bz->($w => {}) if !J.geo.bb->{$w};
         # extra stick pole, sparsitor to trace by, blank as tr(ansf)
     }
     
     # and lay out
     my $last = {x=>0.5, y=>0, cv=>0, rad=>$RADIAN}; # downy
     for my $j (do{ grep { _.style eq 'tr' } w $R tvo(J=>J.geo); }) {
         sayyl "       <<<< yep j.cv j.t          ".ki j.s;
         
         my $here = {};
         here.cv = j.cv;
         here.rad = j.s.curve if j.s.curve; # on the level
         
         w $R atom[$j, $here, $last];
         
         J.geo.bz->("b%ve\t".j.cv => $here);
         $last = $here;
     }
     # etc
 - K: phairo #c
   D: |
     my @d = grep { _.t eq _.l } w $R tvo[$J]; # not style or com
     my @be = grep { _.style eq 've' } w $R tvo(J=>J.geo); # poli
     
     my ($left,$right) = (undef,shift @be);
     
     for my $j (@d) {
         my $here = {};
         here.cv = j.cv;
         
         if ($right && here.cv >= $right->{cv} ) { # adjust to poli
             # mix a pool of ways, magnetic fishing rods
             # end $left
             $left = $right;
             $right = shift @be;
             # start $right
         }
         
         my $last = left.s || {};
         w $R atom[$here, $last];
         
         # unwind
         my $swish = $RADIAN*4;
         $swish *= -1 if here.rad < 0;
         # coil something something
         here.rad -= $swish until here.rad < $swish;
         # random angle like L
         my $rad = here.rad;
         my $radleg = -$RADIAN;
         # from O- is it in the left hemisphere
         $radleg *= -1 unless $rad < -$RADIAN && $rad > $RADIAN;
         $rad -= $radleg; 
         
         
         my $ere = {
             left => $left,
             radial => sprintf('%.4f', $rad),
             angle => sprintf('%.4f', here.rad),
             x => sprintf('%.4f', here.x),
             y => sprintf('%.4f', here.y),
         };
         
         sayre ">>>> yep "
             .sprintf('%-4s', j.cv)." "
             .sprintf('%-16s', j.t)."   "
             .sprintf('%-19s', j.s)."   "
            ." ere.x!ere.y   * ere.radial  ere.angle here.dist";
         
         J.pha.bz->(j.r => $here);
         
         J.bz->("j.t%css#pha\t".j.cv =>  # concert per emportar
             'top:'.(ere.y * 100).'%;'
             .'left:'.(ere.x * 100).'%;'
             .'position:absolute;'
               .'-webkit-transform:rotate('.ere.radial.'rad);'
               .'transform-origin:-10% -10%;' # animate that bit
         );
         J.bz->("j.t%tt\t".j.cv =>  # concert per emportar
             "*".ere.radial
         );
     }
 - K: atom #c 
   D: |
         # spacin
         here.dist = here.cv - last.cv;
         # twistin
         say "twist: here.cv ".(here.dist * 10)."  from last.cv";
         here.rad *= (here.dist * 10);
         here.rad += last.rad; # last real poli
         #* (here.dist * 10);
         say "add here.dist of last.rad to here.rad   or";
         # move
         here.x = last.x + (here.rad ? cos(here.rad) : 0) * here.dist;
         here.y = last.y + (here.rad ? sin(here.rad) : 1) * here.dist;
         
 - K: phism #c re/progressive proJammable petalis
   D: |
          my $n = ar.n || 9;
          my $width = 100;
          my $height = 100;
          my $cx = $width / 2;
          my $cy = $height / 2;
          my $lg_diam = $width * 0.85;
          my $lg_rad = $lg_diam / 2; 
          my $outer_rad = $width*0.45;
          my $angle_incr = ar.ai || 9 / $n;
          
          my $xy = [];
          for my $i (1..$n) {
              my $ratio = $i/$n;
              my $spiral_rad = ($ratio *1.3) * $outer_rad;
              my $angi = $angle_incr + 0.15;
              $angi *= ar.modi->{$i} if ar.modi->{$i};
              my $angle = 1.2+$i*$angi;
              my $x = $cx + cos($angle) * $spiral_rad;
              my $y = $cy + sin($angle) * $spiral_rad;
              push @$xy, {
                  radial => sprintf('%.2f', atan2($x - $cx, $y - $cy)),
                  angle => sprintf('%.3f', $angle),
                  x => sprintf('%.2f', $x),
                  y => sprintf('%.2f', $y),
              };
          }
          $xy

