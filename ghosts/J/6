R_Jz:
 - K: hiss #c esque pingas
   D: |
      my $html = w $R jitterbug[$J];
      return $html
 - K: jitterbug #c depasoi
   D: |
     w $R inness; # finds on, near in, ups # traction gets to 1
     
     w $R up;
      
     w $R howge;
      
     # set up archeology site, anything you want
     w $R geolo;
     
     w $R geoves;
     
     # map what you got onto geoloJn, perhaps unwholy, resolving around poles
     w $R phairo;
     
     my $html = w G.theR maka; # stuff of 7 with 8 -> 1
     
     $html
 - K: inness #c soy packets everywhere # THINGNESS
   D: |
      J.on = w $R makeJ(name=>J.name.'-on'); # babble
      
      # travwel...
      my $u = {
          id => "not",
          name => "ches",
          G => $G,
          more => "more",
          Bee => "stuff",
      };
      
      # the throat
      $u->{'stuff'.$_} = "$_~~~~~~$_" for 1..400;
      # TODO babble like u.stuff$_ so \w+#\w+
      $u->{'stuff4'.$_} = "$_ ~~~ $_" for 2,4..6,8;
      
      # the = is the mod of T, wavedd
      
      # bits of this world's language compress away to geometry
      
      J.on.bz->("u\t".0.1 => $u);
      
 - K: up #c scan
   D: |
       my $u = J.on.bb->{"u\t".0.1};
       my $r = {map{$_=>1} sort keys %$u};
       
       # ^ interpret # compress knowledge
       
       my $ordy = Load(<<'');
       {A: 1, id: 15, K: 17, name: 18,
       G: 14, R: 14, B: 23, more: 543}
       
       
       
       my $ydro = {};
       push @{$ydro->{$_}||=[]}, $_ for keys %$ordy;
       my @order = map { @{$ydro->{$_}} } sort keys %$ydro;

       my @r = grep { delete $r->{$_} } @order;
       
       # TODO ^ v wanna make it like two indexes
       
       push @r, sort keys %$r;
       
       for (@r) {
            my $v = $u->{$_};
            
            my $cv = $1 if /^stuff(\d+)/;
            $cv ||= $ordy->{$_};
            $cv ||= 4;

            # TODO grab l cursor and style
            # and what kind of cursor, fro delays/syncs
            J.bz->("$_\t"."0.$cv" => ''.$v);
            
            J.bz->("$_%css#uff\t"."0.$cv" =>
                #'border-bottom: 2px solid white'
                'opacity:0.3;'
                )
                if /^stuff(\d+)/;
            
            $_ eq 'name' &&
            J.bz->("$_%css#wa\t"."0.$cv" =>
                'border-bottom: 3px solid white');
       }
 - K: howge #c
   D: |
     J.geo = w $R makeJ(name=>J.name.'-geo');
     
     J.geo.bz->(@$_) for
         ["curve\t"."0.2" => 0.12],
         ["curve\t"."0.3" => 0.82 ],
         ["curve\t"."0.5" => -0.30 ],
         ["faster\t"."0.6" => 0.32 ], # this'll cuvre tighter and tigher
         # redistribute from/with the shap of the = as upside down T
         # 1 circle and another kinda axis thing, making a dynamic
         # a 2 circle may involev magnetic fishing rod relay hivi too
         # pulling aspects out of the braid bed, 
     ; # rad per 0.1cv? who knows
     
 - K: geoves #c dpaw
   D: |
     # make .......................
     J.bz->(
        "dot$_"."\t"."0.".sprintf('%03d',$_) =>
        '.')
        for 1..10;
     J.bz->(
         "0000_$_/s"."\t"."0.$_" =>
         $_."-------",
         '%css' => 'color:red')
         for 1..9;
      
     my @be = grep { _.style eq 've' } w $R tvo(J=>J.geo); # poli
     for my $j (@be) {
         my $makaz = {"/%css#jit\t"."0.1" => 'left:10em;position:absolute'}; 
         #my $makaz = {};
         #J.bz->("/%css#jit\t"."0.1" => 'left:30em;position:absolute');
         my $fro = J.fro->(
             "being".j.cv."\t".j.cv, j.s, {cv=>0.2, makaz=>$makaz},
                  '%css', 'white-space:pre;');
         say  wdump(2,$fro);
     }
 - K: geolo #c begin digging - smiling egg cup
   D: |
     my $Jeo = J.geo; # woo
     sayyl '.' for 1..5;
     
     for my $j (do{ grep { !_.style } w $R tvo(J=>J.geo); }) {
         saybl "               ^^^^ yep j.cv j.t          j.s ";
         
         J.geo.bz->("b%tr\t".j.cv => {
             %{J.geo.bb->{"b%tr\t".j.cv} || {}}, # compile trs
            j.t => j.s,
         });
     }
     
     for my $pcv (map{$_ * 0.1} 1..9) {
         my $w = "b%tr\t".$pcv;
         J.geo.bz->($w => {}) if !J.geo.bb->{$w};
         # extra stick pole, sparsitor to trace by, blank as tr(ansf)
     }
     
     # and lay out
     my $last = {x=>0.5, y=>0, cv=>0, rad=>$RADIAN, spin=>0}; # downy
     for my $j (do{ grep { _.style eq 'tr' } w $R tvo(J=>J.geo); }) {
         sayyl "       <<<< yep j.cv j.t          ".ki j.s;
         
         my $here = {};
         here.cv = j.cv;
         here.spin = j.s.curve if j.s.curve; # on the level
         here.creatin = j.s;#$H->ejson(j.s);
         
         w $R atom[$j, $here, $last];
         
         J.geo.bz->("b%ve\t".j.cv => $here);
         $last = $here;
     }
     # etc
 - K: atom #c may +atomb? without compare you are dead
   D: |
         # spacin
         here.dist = here.cv - last.cv;
         # twistin spin inherit
         here.spin += last.spin;
         # scale local-local change
         here.rad = here.spin * here.dist * 10;
         # builds rad on rad
         here.rad += last.rad;
         # and move
         here.x = last.x + (here.rad ? cos(here.rad) : 0) * here.dist;
         here.y = last.y + (here.rad ? sin(here.rad) : 1) * here.dist;
         
 - K: phairo #c re/progressive proJammable petalis, frequency convogation
   D: |
     J.pha = w G.theJ makeJ(name=>J.name.'-pha');
     
     my @d = grep { _.t eq _.l } w $R tvo[$J]; # not style or com
     my @be = grep { _.style eq 've' } w $R tvo(J=>J.geo); # poli
     
     my ($left,$right) = (undef,shift @be);
     
     for my $j (@d) {
         my $here = {};
         here.cv = j.cv;
         
         if ($right && here.cv >= $right->{cv} ) { # adjust to poli
             # mix a pool of ways, magnetic fishing rods
             # end $left
             $left = $right;
             $right = shift @be;
             # start $right
         }
         
         my $last = left.s || {};
         w $R atom[$here, $last];
         
         # unwind # TODO wind blowing crazy
         my $swish = $RADIAN*4;
         $swish *= -1 if here.rad < 0;
         # coil something something
         here.rad -= $swish until here.rad < $swish;
         
         # random angle like L, find the \ direction at least
         # its mass would be good too
         # share space with curves
         my $rad = here.rad;
         my $radleg = -$RADIAN;
         
         # from O- is it in the left hemisphere etc
         $radleg *= -1 unless $rad < -$RADIAN && $rad > $RADIAN;
         $rad -= $radleg; 
         
         ''.$H->hitime =~ /(\d)(\d)(\d)\.(\d)(\d)/;
         my @ent = reverse ($1,$2,$3,$4,$5);
         
         my $ere = {
             left => $left,
             radial => sprintf('%.4f', $rad),
             angle => sprintf('%.4f', here.rad),
             x => sprintf('%.4f', here.x),
             y => sprintf('%.4f', here.y),
         };
         
         sayre ">>>> yep @ent "
             .sprintf('%-4s', j.cv)." "
             .sprintf('%-16s', j.t)."   "
         #    .sprintf('%-19s', " * ere.radial  ere.angle here.dist")
         #    ." ".slim(j.s)
         ;
         
         J.pha.bz->(j.r => $here);
         
         J.bz->("j.t%css#pha\t".j.cv =>  # concert per emportar
             'top:'.(ere.y * 100).'%;'
             .'left:'.(ere.x * 100).'%;'
             .'position:absolute;'
               .'-webkit-transform:rotate('.ere.radial.'rad);'
               .'transform-origin:0% 50%;' # animate that bit
         );
         J.bz->("j.t%tt\t".j.cv =>  # concert per emportar
             "*".ere.radial
         );
     }

