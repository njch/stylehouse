R_Jz:
 - K: geo #c
   n_D:
     yJ: |
       'geo'
     up: |
       my $sr = J.Jo;
       J.noesc = ar.noesc if ar.noesc;
         #die "wa ".wdump 2, $_ if J.bb->{_.l."%nogeo\t"._.cv};
       
       Rw thy curves $J:sr $oJ:J $q=1
       ||
       Rw geolo $J;
       
       Rw oJ $J phz &up;
 - K: phz #c transfer
   n_D:
     yJ: |
       'phz'
     up: |
       my $geo = J.Jo;
       my $io = J.Jo.Jo;
       Rw phairo $J $oJ:io $geo;
       
       Rw outhere $J $oJ:io $geo;
 - K: geolo #c begin digging - smiling egg cup - most reentrant part
     # set up archeology site, anything you want
   D: |
     for my $k ("geo things -> tr") {
         my $ip = {style=>''};
         my $js = Rw tva $J $ip;
         
         my $coi = Rw pha $J $k;
         coi.qui = 1; 
         last if Rw lv_same $js $x:coi $J;
         
         # ^^^^^^^
         for (@$js) {
             my $rtr = "b%tr\t"._.cv;
             my $b = J.bb->{$rtr} || {}; #acumey
             $b->{_.t} = _.s;
             J.bz->($rtr => $b);
         }
         coi.exactl->();
     }
     
     # do about 9
     # extra stick pole, sparsitor to trace by, blank as tr(ansf)
     # keeps exponential dist reactions on track...
     for my $trr (map {"b%tr\t".$_} map {$_ * 0.1} 1..9) {
         J.bz->($trr => {}) if !J.bb->{$trr};
     }
     
     # and lay out
     my $last = {x=>0, y=>0, cv=>0.001, rad=>$RADIAN, spin=>0}; # downy
     
     my $ip = {style=>'tr'};
     my @tr = Rw tvo $J $ip;
     
     # wants to style with styles
     # of course there's lots of geo things
     # and geo things right now is actually style...
     # so demono b
     # default strand o
     # so this'll eventually be lv_sameable as the @js come in waves
     my $coi = Rw pha $J $k=tr_atoms;
     for my $j (@tr) {
         #sayyl "       <<<< yep j.cv j.t          ".ki j.s;
         $last = {%$last};
         # mapping intents into chain reactions
         my $here = {};
         here.cv = j.cv;
         
         my $r = j.s;
         here.x  = last.x = r.x if exists r.x;
         here.y = last.y = r.y if exists r.y;
         
         here.rad = 4*$RADIAN * r.spun if exists r.spun;
         
         here.creatin = j.s;
         
         
         here.zoom = r.zoom if defined r.zoom;
         
         
         Rw atom $j $here $last;
         
         # aft fo smoothi
         here.spin = r.curve if exists r.curve; # on the level
         
         J.bz->("b%ve\t".j.cv => $here);
         $last = $here;
     }
     coi.exactl->('diff');
     # etc
 - K: atom #c may +atomb? without compare you are dead
   D: |
         # spacin
         here.dist = here.cv - last.cv;
         # twistin spin inherit
         here.spin += last.spin;
         # scale local-local change
         here.rad += here.spin * here.dist * 10;
         # builds rad on rad
         here.rad += last.rad;
         # distort space + more ways, orbital
         # chuck skeletons for mods
         # adapt M meta for what kinda places things want
         # into constellations of high level things
         # atomised hairs
         here.zoom ||= last.zoom;
         here.dist *= here.zoom if here.zoom;
         # and move
         here.x = last.x + (here.rad ? cos(here.rad) : 0) * here.dist;
         here.y = last.y + (here.rad ? sin(here.rad) : 1) * here.dist;
         
 - K: phairo #c re/progressive proJammable petalis, frequency convogation
   D: |
     # things from oJ to J (pha)
     my $ip = {l=>{not=>'/'}};
     my $vs = Rw tyv $J:oJ $ip $strange=1;
     my @d; 
     for my $lv (@$vs) {
         #next if lv.sc.nogeo;
         push @d, lv.j;
     }
     
     $ip = {style=>{ve=>1}};
     my @be = Rw tvo $J:geo $ip;
     
     my ($left,$right) = (undef,shift @be);
     $left ||= $right;
     
     my $coi = Rw pha $J $k=phairo;
     for my $j (@d) {
         my $here = {cv => j.cv};
         
         while ($right && here.cv >= $right->{cv} ) { # adjust to poli
             # mix a pool of ways, magnetic fishing rods
             # end $left
             $left = $right;
             $right = shift @be;
             # start $right
         }
         
         here.left = $left;
         here.right = $right; # <^ follow jagging rad, spaces within
         
         my $last = left.s || {};
         Rw atom $here $last;
         
         J.bz->(j.r => $here);
     }
     coi.qui = 1;
     coi.exactl->('diff');
     
 - K: outhere #c out
   D: |
     my $ip = {style=>''};
     my @d = Rw tvo $J $ip;
     
     my $coi = Rw pha $J:oJ $k=outhere;
     for my $j (@d) {
         my $here = j.s;
         # unwind # TODO wind blowing crazy
         my $swish = $RADIAN*4;
         $swish *= -1 if here.rad < 0;
         # coil something something
         here.rad -= $swish until here.rad < $RADIAN*4;
         
         # random angle like L, find the \ direction at least
         # its mass would be good too
         # share space with curves
         my $rad = here.rad;
         # radial -> angle, shouldery thing
         my $radleg = -$RADIAN;
         # and pan to hemisphere...#
         # from O- is it in the left hemisphere etc
          $radleg *= -1 unless $rad < -$RADIAN && $rad > $RADIAN;
         $rad -= $radleg; 
         
         my $e = {
             radial => sprintf('%.5f', $rad),
             angle => sprintf('%.5f', here.rad),
             x => sprintf('%.5f', here.x),
             y => sprintf('%.5f', here.y),
         };
         
         if (oJ.yt.quigeo) {
             e.ab = oJ.yt.geoex ? '100' : '1';
             oJ.bz->("j.t%geo\t".j.cv => {%$e});
             next;
         }
         my $ere = {%$e};
         ere.left = here.left;
         
         # shove com toeget
         sayre ">>>> oJ.name yep nt  j.cv    ". j.t;
         # OR SOMETHING
         # loses its compressibility as csz
         # unless we use %css#omments to spread em
         
         #saygr " ere ". ki $ere;
         
         my $cs;
         cs.top = (ere.y * 100).'%';
         cs.left = (ere.x * 100).'%';
         cs.rad = 0 + ere.radial;
         cs.ab = 1;
         cs.tro = '0% 50%';
         cs.tt = "to:here.cv";
         if (geo.noesc) {
             cs.tro = '0% 0%';
             for my $k (sort keys %$cs) {
                 oJ.bz->("j.t%$k\t".j.cv => $cs->{$k}); # concert per emportar
             }
             next;
         }
         my @css = Rw esc $cs pha;
         while (@css) {
             my $stc = shift @css;
             my $sty = shift @css;
             oJ.bz->("j.t$stc\t".j.cv => $sty); # concert per emportar
         }
      }
      coi.qui = 1;
      coi.exactl->('diff');

