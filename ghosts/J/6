R_Jz:

 - K: atom #c may +atomb? without compare you are dead
   D: |
         # spacin
         here.dist = here.cv - last.cv;
         # twistin spin inherit
         here.spin += last.spin;
         # scale local-local change
         here.rad += here.spin * here.dist * 10;
         # builds rad on rad
         here.rad += last.rad;
         # distort space
         here.zoom += last.zoom;
         here.dist *= here.zoom if here.zoom;
         # and move
         here.x = last.x + (here.rad ? cos(here.rad) : 0) * here.dist;
         here.y = last.y + (here.rad ? sin(here.rad) : 1) * here.dist;
         
 - K: phairo #c re/progressive proJammable petalis, frequency convogation
   D: |
     J.pha = w $R makeJ(name=>J.name.'-pha'); # TODO replace last
     
     my @d = grep { _.t eq _.l } w $R tvo[$J]; # dump J things into space
     my @be = grep { _.style eq 've' } w $R tvo(J=>J.geo); # poli
     
     my ($left,$right) = (undef,shift @be);
     $left ||= $right;
     
     for my $j (@d) {
         my $here = {cv => j.cv};
         
         if ($right && here.cv >= $right->{cv} ) { # adjust to poli
             # mix a pool of ways, magnetic fishing rods
             # end $left
             $left = $right;
             $right = shift @be;
             # start $right
         }
         
         here.left = $left;
         here.right = $right; # <^ follow jagging rad, spaces within
         
         my $last = left.s || {};
         w $R atom[$here, $last];
         
         J.pha.bz->(j.r => $here);
     }
     
     saygr "J pha @ ".keys %{J.pha.bb};
     
 - K: outhere #c out
   D: |
     my @d = grep { _.t eq _.l } w $R tvo(J=>J.pha); # !style||com
     
     for my $j (@d) {
         my $here = j.s;
         # unwind # TODO wind blowing crazy
         my $swish = $RADIAN*4;
         $swish *= -1 if here.rad < 0;
         # coil something something
         here.rad -= $swish until here.rad < $RADIAN*4;
         
         # random angle like L, find the \ direction at least
         # its mass would be good too
         # share space with curves
         my $rad = here.rad;
         my $radleg = -$RADIAN;
         # and pan to hemisphere...#
         # from O- is it in the left hemisphere etc
          $radleg *= -1 unless $rad < -$RADIAN && $rad > $RADIAN;
         $rad -= $radleg; 
         
         my $ere = {
             left => here.left,
             radial => sprintf('%.5f', $rad),
             angle => sprintf('%.5f', here.rad),
             x => sprintf('%.5f', here.x),
             y => sprintf('%.5f', here.y),
         };
         
         #sayre ">>>> yep @ent  j.cv    ". j.t;
         
         J.bz->(
             "j.t%css#pha\t".j.cv =>  # concert per emportar
             'top:'.(ere.y * 100).'%;'
             .'left:'.(ere.x * 100).'%;'
             .'position:absolute;'
               .'-webkit-transform:rotate('.ere.radial.'rad);'
               .'transform-origin:0% 0%;' # animate that bit
         );
         J.bz->(
             "j.t%tt\t".j.cv =>  # concert per emportar
             "*".ere.radial
         );
      }
      sayre join " ", (">") x scalar(@d);

