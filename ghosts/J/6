R_Jz:

 - K: geolo #c begin digging - smiling egg cup - most reentrant part
     # set up archeology site, anything you want
   D: |
     my @t = grep { _.l eq _.t }
        Rw tvo;
        
     for (@t) {
         # ^^^^^^^
         J.bz->("b%tr\t"._.cv => {
             %{J.bb->{"b%tr\t"._.cv} || {}},
             _.t => _.s,
         })
     }
     
     for my $pcv (map{$_ * 0.1} 1..9) {
         my $w = "b%tr\t".$pcv;
         J.bz->($w => {}) if !J.bb->{$w};
         # extra stick pole, sparsitor to trace by, blank as tr(ansf)
     }
     
     # and lay out
     my $last = {x=>0, y=>0, cv=>0.001, rad=>$RADIAN, spin=>0}; # downy
     
     my @tr = grep { _.style eq 'tr' }
         Rw tvo;
         
     for my $j (@tr) {
         #sayyl "       <<<< yep j.cv j.t          ".ki j.s;
         $last = {%$last};
         # mapping intents into chain reactions
         my $here = {};
         here.cv = j.cv;
         
         my $r = j.s;
         here.x  = last.x = r.x if exists r.x;
         here.y = last.y = r.y if exists r.y;
         
         here.rad = 4*$RADIAN * r.spun if exists r.spun;
         
         here.creatin = j.s;
         
         
         here.zoom = r.zoom if defined r.zoom;
         
         
         w $R atom[$j, $here, $last];
         
         # aft fo smoothi
         here.spin = r.curve if exists r.curve; # on the level
         
         J.bz->("b%ve\t".j.cv => $here);
         $last = $here;
     }
     # etc
 - K: atom #c may +atomb? without compare you are dead
   D: |
         # spacin
         here.dist = here.cv - last.cv;
         # twistin spin inherit
         here.spin += last.spin;
         # scale local-local change
         here.rad += here.spin * here.dist * 10;
         # builds rad on rad
         here.rad += last.rad;
         # distort space + more ways, orbital
         # chuck skeletons for mods
         # adapt M meta for what kinda places things want
         # into constellations of high level things
         # atomised hairs
         here.zoom ||= last.zoom;
         here.dist *= here.zoom if here.zoom;
         # and move
         here.x = last.x + (here.rad ? cos(here.rad) : 0) * here.dist;
         here.y = last.y + (here.rad ? sin(here.rad) : 1) * here.dist;
         
 - K: phairo #c re/progressive proJammable petalis, frequency convogation
   D: |
     # things from oJ to J (pha)
     my @d =
         grep { _.t eq _.l }
         Rw tvo $J:oJ;
         
     my @be =
         grep { _.style eq 've' }
         Rw tvo $J:geo;
     
     my ($left,$right) = (undef,shift @be);
     $left ||= $right;
     
     for my $j (@d) {
         my $here = {cv => j.cv};
         
         while ($right && here.cv >= $right->{cv} ) { # adjust to poli
             # mix a pool of ways, magnetic fishing rods
             # end $left
             $left = $right;
             $right = shift @be;
             # start $right
         }
         
         here.left = $left;
         here.right = $right; # <^ follow jagging rad, spaces within
         
         my $last = left.s || {};
         Rw atom $here $last;
         
         J.bz->(j.r => $here);
     }
     
     saygr "J pha @  ".keys %{J.bb};
     

