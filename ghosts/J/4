
R_Jz:
 - K: Mn #c one for MN
   D: |
     my $N = [$n];
     Rw MN + $N;
 - K: MN #c mthemZY
   D: |
     my $peel = sub { # simple hash from string
        my $s = shift;
        $s =~ s/^{//;
        $s =~ s/}$// || die "unpealable $s";
        my @t = split ',', $s;
        my $t = {};
        for (@t) {
            my ($k, $v) = split ':', $_;
            $t->{$k} = $v;
        }
        return $t;
     };
     my $oM;
     my $fl = {};
     if (my $fli = ar.m) {
         $fl->{$_} = 1 for @$fli; # could:this
     }
     for my $s (@$N) {
         my $n = {};
         if (!ref $s) {
             die "string: $s";
         }
         elsif (ref $s eq 'ARRAY') {
             # to four
             if (@$s == 1) {
                 my ($i) = @$s;
                 if (!ref $i) {
                     my $ci = $i;
                     for (qw,t y c sc,) {
                         if ($ci =~ s/^(\S+)\s*//) {
                             my $v = $1;
                             $v = $peel->($v) if $v =~ /^{/;
                             $n->{$_} = $v;
                         }
                     }
                 }
                 else {die $i}
             }
             else {
                 (n.t,n.y) = @$s;
                 n.c = $s->[2] if exists $s->[2];
                 n.sc = $s->[3] if exists $s->[3];
                 die'@>4' if @$s > 4;
             }
         }
         elsif (ref $s eq 'HASH') {
             if (s.MZ) {
                 for (split /\s+/, s.MZ) {
                     /^(.+?)(?::(.+))?$/ || die;
                     $fl->{$1} = $2 || 1;
                     sayre "MZfilter: $1 and $2";
                 }
                 next;
             }
             else {
             die 'hash: ';
             }
         }
         else { die "mmtype:$s" }
         
         for my $k (keys %$fl) {
             my $v = $fl->{$k};
             die if $v ne '1';
             Rw ym/$k $n;
         }
         if (!ref n.y) {
             if (n.y eq '') { # or undef
                 n.y = {};
             }
             elsif (n.y =~ /^(\d+)$/) {
                 n.y = {thi=>$1};
             }
             else {die "strung ny: n.y"};
         }
         die wdump $N if !ref n.y;
         die if !n.y;
         push @$oM, $n;
     }
     Rw iM + $oM;
 - K: ym/pwth #c
   D: |
     n.c.pwth = delete n.y
 - K: the #c pg69make, ongoable
   D: |
     my $what = $m->[0];
     my $wt = Rw wuck $J */$what;
     my $M = [];
     for my $k (sort keys %$wt) {
         my $N = $wt->{$k};
         say " ** waything $what from $k";
         # pha $what, any of:
         # - [t( y)( c)( sc)???]
         # - [t, y]
         # - [t, y, c, sc]
         Rw MN $N $M;
     }
     saybl "the $what: ".ki 1, $_ for @$M;
     # inside the J so
     # ar close braid
     Rw iM + $oM:M;
 - K: iM #c as below, for $M instead of $d
   D: |
     return @$oM if ar.ret;
     if (ar.M) {
         push @{ar.M}, @$oM
     }
     @$oM
     
 - K: iiJM #c an ii magnetises guts into $J or $M, or returns if no
   D: |
     return $d if ar.ret;
     if (ar.M) {
         push @{ar.M}, $d
     }
     elsif (ar.J) {
         Rw yo + $d;
     }
     else {
         die "no way to modulate: ".ki $d;
     }
     $d
 - K: om/bal #c in-fractalise   $whateverM > bal> $M
   D: |
     my ($d,$oM) = Rw iot +;
     d.y.bal = [ map {
         ref $_ eq 'HASH' || die'nothash';
         _.t || die"not: ".ki $_;
         _.c.s ||= _.t;
         $_
     } @$oM ];
     say "G.jumb.yos:::: om/bal: x".@$oM."  t:d.t    y:".ki(d.y)."        c:".ki(d.c)."       sc:".ki(d.sc);
     say "G.jumb.yos ^^ ".ki $ar;
     Rw iiJM + $d;
 - K: om/lev #c envelop $whateverM into $M enve   # o grabs space off 2sphere
   D: |
     my ($d,$oM) = Rw iot +;
     d.c.lev && die;
     d.c.lev = sub {
         my $J2 = shift;
         my $d = Rw om/bal $J:J2 $oM $t:d.t 0.1-0.3;
         sayre "G.jumb.yos !omlev: d.t   ".ki(d.y);
         my $V = 1;
         Rw yo $J:J2 $d $V;
     };
     d.sc.fs = 40;
     say "G.jumb.yos//// om/lev: x".@$oM."   t:d.t    y:".ki(d.y)."        c:".ki(d.c)."       sc:".ki(d.sc);
     say "G.jumb.yos ^^ ".ki $ar;
     Rw iiJM + $d;
 - K: iot #c # o to $d    grabs space off 2sphere
   D: |
     my $d;
     
     my $o = Rw pul + $cs:ar.m t y c sc;
     for (qw't y c sc') { 
          exists $o->{$_} || next;
          $d->{$_} && die;
          $d->{$_} = $o->{$_};
     }
     
     if (d.y && !ref d.y) {
         d.y =~ /^($NUM)(?:-($NUM))?/ || die;
         d.y = {in=>$1};
         d.y.out = $2 if $2;
     }
     
     d.y.in = ar.in if ar.in;
     d.y.out = ar.out if ar.out;
     d.y.in = ar.at if ar.at;
     
     if (!defined d.y.in) {
         d.y.in = 0.3;
         d.y.out = 0.4;
     }
     
     d.c ||= {};
     d.sc ||= {};
     
     my $oM;
     for (grep{/^\w+M$/ || /^_$/}keys %$ar) {
         $oM && die "many oM: $_";
         $oM = $ar->{$_};
         die "no array in ar looking: $oM ".ki$oM if ref $oM ne 'ARRAY'
     }
     $d, $oM
 - K: yM #c yo $M 
   D: |
     sayre "G.jumb.yos===";
     sayre "G.jumb.yos===  yM x".@$M;
     sayre "G.jumb.yos===";
     for my $d (@$M) {
         die "look like d? ".wdump$d unless d.t && d.y;
         Rw yo + $d;
     }
 - K: yo #c yo
   D: |
     if (!ar.q && !J.q) {
         sayyl "G.jumb.yos@@@@   yo:  ar.k     d.t   ".ki(d.y)."     %  "
             .ki(d.c||{})."      %  ".ki(d.sc||{})
     }
     G.jumb.yos .= '    ';
     Rw mod/n +;
     G.jumb.yos =~ s/    $//;
     
 - K: mo/m #c mod outgoing # general yinyang komprendonator, vis $M ^v^v^v^v^v
   D: |
     die;
     my $d = Rw iot +;
     d.y.bal = [ map {
           my ($t,$thing,$c,$sc) = @$_;
           my $p = {};
           p.t = $t;
           p.c = $c || {};
           p.c.s = $t if !exists p.c.s;
           p.c->{$sty} = $thing if $thing ne '';
           p.sc = $sc if $sc;
           $p
       } @$M ];
       
     d.t = $sty.'y'; 
     d.c = {%{ar.c||{}}};
     d.sc = {%{ar.sc||{}}};

     Rw yo $J $d;
 - K: mo/pwth #c
   D: |
      die;
       my $sty = 'pwth';
       Rw mo/m + $sty;
 - K: modstick #c api layer between project and hive # 4d
   D: |
     my $d = {};
     (d.t, d.yin, d.c, d.sc) = @$m;
     
     die if !ref d.c;
     my $wtf = ar.k || $F[4]->{point}.'á£'.$F[2]->{point};
     if (!ar.q && !J.q) {
         sayyl "$wtf mo/m  d.t d.yin   "
             .ki(d.c||{})."    ".ki(d.sc||{})
     }
     
     Rw mod/n + $J $d;
     
 - K: mod #c modi
   n_D:
     el:
       CARBON: | #c
         {csfrm => 'cK'}
     dosc: | #c
       Rw Con mod;
     u: | #c make pool, synth space, want arches
       # fork & rejoin to exciting place
       
       # YIN

       my $n;

       my $dd = $d;
       for my $is (@is) { # THE TIR drop at hands

           # YANG

           # CARBON

           # CITOZINE

           sayre "G.jumb.yos - ------ d.y.i:    d.r" if ar.V;
           #saybl "Post: d.s       @{d.css} " if ar.V;
           
           if (c.lev) {
               J.lev->(
                   d.r => c.lev,
                   @{d.css},
               );
           }
           else {
               J.bz->(
                   d.r => d.s,
                   @{d.css},
               );
           }
       }
mod c:
 - K: yinvis #c the valley, what it means to be here in here YIN
   mod 1: |
     # sub-dome and super-modloop
     # find beginning, end, thickness of loop atmosphere
     # so thi is where the manifolds can attach in the stackening
     # the modulation piles them in evenly (todo)
     d.y = {thi => d.y} if !ref d.y;
     my $y = d.y;
     
     
        if (my $bs = y.bal) {
            y.thi = @$bs;
        }
        
        
     y.in ||= 0.1; 
     y.out ||= 0.9; # up to
     y.thi ||= 1;
     y.space = y.out - y.in; # could spiral much space away from spine
     y.space *= -1 unless y.space > 0;
     y.aspace = y.space / y.thi;
     # twist, lay into segment
     my @is;
     my $csv = y.in;
     for (1..y.thi) {
        my $iy;
        iy.i = $_-1;
        iy.cv = sprintf '%.6f', $csv;
        iy.uiv = sprintf '%.6f', $_ / y.thi;
        push @is, $iy;
        $csv += y.aspace;
     }
 - K: yangbal #c inwave, background language expansion, dewey mezrow   YANG
   mod 2: |
     my $d = {%$dd};
     
     d.y = {%{d.y||die}, %$is};
     d.cv = d.y.cv || die;
     d.t = d.t."".d.y.uiv; # TODO delicate? y.bal overs
     
     d.c || die;
         d.sc = {%{d.sc||{}}};
     #^v  ^v
     #  ^v
     d.cs = {%{d.cs||{}}};
     #  ^v esc
     d.css = [@{d.css||[]}];
     
     #   d.c.$modk = the unravelling mod
     # + d.sc.$esck = outwards, parafin
     # =
     #   d.cs.$modk.$esck = the outwards
     # + d etc
     
     # ^ yanging mods attach style, main accum fet: cs.$modk.$ck = $c
     
     # ^ fed to esc which packs styles with com: #$cometc$modk, defaulting %cs
     
     my $y = d.y;
     if (d.y.bal) {
         # locality
         my $b = d.y.bal->[d.y.i];
         say "G.jumb.yos BAL d.y.i at d.cv    --- d.y.uyiv   ".ki 1, $b;
         for my $k (keys %$b) { # c etc merg in per row
             my $v = $b->{$k};
             if (ref $v) {
                 $d->{$k} = {%{$d->{$k}}, %$v};
             }
             else {
                 $d->{$k} = $v;
             }
         }
     }
     # bal may mod t, this may wannab 
     d.r = join "\t", d.t, d.cv; # always update trio
     
     
     my $c = d.c; # <v contation
     die "notrefc  $c" if !ref $c;
 - K: yangist #c art
   mod 2.3: |
     n.um = sprintf '%.3d', d.y.uiv;
     
 - K: s #c yes
   mod 3.1: |
     acum $n, gl => $cs; # some funky magnation
 - K: i #c  $i is the osc, attach on $v to $n
   mod 3.1: |
     d.t = d.t."-".n.iii->{$cs}++; 
     d.r = join "\t", d.t, d.cv;
 - K: carbcap #c jel like language # n.gl gravity, implosi # agg from chaos
   MZ: {}
   mod 3.9: |
     if (n.gl && @{n.gl}) {
         my $was = d.s;
         d.s = join'',@{n.gl};
         #saybl "carb capin (was '$was') --> d.s" if ar.V;
         delete n.gl;
         # roll ^ dough, the gel that gl may be
         # now snaps off a branch
         # continuous notation we still pick up as chunks of lingo geom
     }
     # ^ es also like looking for most magnity n.thee value heading for $s
     # carbdome...
 - K: dsc #c cs on d, outside mod twistor pipe, modline 4th
   mod 7: |
     # non-thinking modulatios
     # you could say more compressed
     # usu static-ish spec, ie make this button green.
     
     # the sea of synapse we datum
     # mod spec lines go: [$l, $thi, 
     # they were found 
     # also any $sc maybe be like {$k => $sc, $k2 => $sc2}
     # for comments like v
     # so comp is the very last hash, the rest is where etc.
     #push @{d.css}, '%css#'.$_ => d.cs->{$_}
     #    for sort keys %{d.cs};
     if (d.sc && %{d.sc}) {
         push @{d.css}, Rw esc/n $d $sc:d.sc DSC;
     }
 - K: dcs #c cs in da pipe, modulating or so
   mod 7: |
     # cs.$k.$sc -> squiggly first style compressions
     # the wilder pole, coming from mods
     # there's stuff across the whole line too
     # and what's between...
     # exp to css for now...
     if (d.cs && %{d.cs}) { 
         push @{d.css}, Rw esc/n $d $sc:d.cs DCS;
     }

