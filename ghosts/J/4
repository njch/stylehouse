     
R_Jz:
 - K: up #c scan
   D: |
     Rw suck */up;
 - K: cv #c mod cove
   n_D:
     oe: |
       my $v = ar.v || ar.thi || 9;
       my $wi = length($v);
       my $thi = join '', ('9') x $wi;
       my $n = 1;
       
       my $squidge;
       if (ar.off) { # offs both ends? plot shit
           $squidge = int(ar.off * ($thi / ($v))); # TODO not quite
           $n += $squidge;
           $v += $squidge; 
       }
       
       my @is = map { sprintf '%0'.$wi.'d', $_  }
           map { $_ - $squidge }
           map { int($_ * ($thi / $v)) } $n..$v;
       
       #sayyl "thehehehhe $squidge $n $v thi $thi". wdump[@is]; 
       die "numbe rdist ".wdump(2,[$v,$wi,$thi,@is]) if uniq(@is) != @is;
       @is;
       
 - K: howge #c
   D: |
     Rw tent geo;
     J.geo.bz->(@$_) for
     Rw suck */curves,
     ;
     
 - K: geoves #c dpaw
   D: |
     my $tw = Rw muck */mods;
     # 6
     for my $k (sort keys %$tw) {
          my $M = $tw->{$k};
          # coul be entropated all the way to per geomodiff...
          # 7
          for my $m (@$M) {
              Rw modstick $J $m $k;
          }
     }
 - K: modstick #c api layer between project and hive # 4d
   D: |
     my $d = {};
     (d.t, d.thi, d.c, d.sc) = @$m;
     
     die if !ref d.c;
     my $wtf = ar.k || $F[4]->{point}.'á£'.$F[2]->{point};
     sayyl "$wtf @ @ @ @ @ @ @ @  d.t d.thi   "
         .ki(d.c||{})."    ".ki(d.sc||{});
     
     #die R.way.hooks.modn; 
     Rw mod/n + $J $d;
     
 - K: moss #c api layer between project and hive
   D: |
     my $d = {};
     (d.t, d.thi, d.c, d.sc) = @$m;
     d.c = { s => delete d.c } if !ref d.c;
     say "$k  @  d.t d.thi   ".ki(d.c||{})."    ".ki(d.sc||{});
     
     #die R.way.hooks.modn;
     Rw mod/n $J $d;
     
 - K: mod #c modi
   n_D:
     el:
       CARBON: |
         {csfrm => 'cK'}
     dosc: | #c shunt, suck, J maint wayfile story
       Rw Con mod;
     u: | #c make pool, synth space, want arches
       d.css && die;
       d.css = []; # styles in general
       d.c ||= {};
       d.cs ||= {};
       d.sc ||= {};

       my @is;
       # fork & rejoin to exciting place
       
       # YIN

       # $c=d.c is a whole little phase, language
       # this magnet would have a thrust
       my $n; # drop values through with
       my $c = d.c; # <v contation
       die if !ref $c;
       $c = {} if !ref $c;

       my $dd = $d;
       for my $i (@is){ # THE TIR

           my $d = {%$dd, i => $i, css => [@{d.css}]};

           # YANG

           # CARBON

           # CITOZINE

           saybl "Post: d.s       @{d.css} " if ar.V;
           my $r = d.t."$i\t0.".sprintf('%03d',$i);
           
           J.bz->(
             $r => d.s,
             @{d.css},
           );
       }
 - K: esc #c espouse ton carbon product
   n_D:
     el:
       CARBON: |
         {subhash => 'X'}
     u: |
       my $X = G.drop.esc = {};
       # CARBON
       
       $X
     arp: |
       my $seg = ar.m->[0] if ar.m;
       my @css;
       die wdump(ar.m) if !ref $sc; # parse strings too
       # invent the stevecraig format, playing music
       my $X = G.drop.esc ||= Rw esc/n;
       
       my $tw;
       for my $k (sort keys %$sc) {
           my $v = $sc->{$k};
           my $com = ref $v eq 'HASH' ? $k : '';
           my $t = $com ? $v : {$k=>$v};
           for my $tk (sort keys %$t) {
               my $tv = $t->{$tk};

               my @s = $X->{$tk} ? $X->{$tk}->($tv) : die "invent $tk  $tv";
               
               if (@s == 1) {
                   unshift @s, '%css';
               }
               my $to = natatime(2, @s);
               while (my @sty_s = $to->()) {
                   my ($sty, $s) = @sty_s;
                   defined $tw->{$com}->{$tk}->{$sty}
                       && die "$com $sty all3    @s";
                   $tw->{$com}->{$tk}->{$sty} = $s; 
               }
           }
       }
       for my $com (sort keys %$tw) {
           my $tks = $tw->{$com};
           for my $tk (sort keys %$tks) {
               my $stys = $tks->{$tk};
               for my $sty (sort keys %$stys) {
                   my $s = $stys->{$sty};
                   say " ghave $com $sty => $s";
                   $sty .= "#".join('-', grep{$_} $seg, $com, $tk)
                       unless $sty =~ /#/;
                   push @css, $sty => $s;
               }
           }
       }
           sayre "CSS  @css";
       @css;
       
mod c:
 - K: yinvis #c what it means to be here in here            YIN
   mod 1: |
     # sub-dome and super-modloop
     # find beginning, end, thickness of loop atmosphere
     # so thi is where the manifolds can attach in the stackening
     # the modulation piles them in evenly (todo)
     d.in ||= 1;
     d.out ||= d.thi;
     @is = map { int($_ * (999/d.thi)) } d.in..d.out;
 - K: yangco #c background language expansion                YANG
   mod 2: |
     # an extremity at one point
     
     # , time can be grabbed, twisted ?
     # yang may pass arounJ komp struc intact for a while
     #   like M's little j that flies around acuming the message
     #   a 2d stack of elements sets up top-down
     #   some stuff afterwards (c), a little 3d
     
     # aj is like a traversing todo list for modulating changes
     #   using the pyramid of stuff on the ceiling ( M ) to komp
     
     # each one (now) a big fat wave
     # nestling into a tape machine (disc world)
     # and percolating network
     #  and that's all they should need to be...
     # nodes passing compression notes on irc
     # big (way)veforms resting in the wormhole/ etc
     
     # BUT YEAH for now lets bend the sweep...
     my $v = $i / (999 - d.in);
     n.um = sprintf '%.3d', ($i * $v + 5);
 - K: dsc #c cs on d, outside mod twistor pipe, the 4th in @$m
   mod 7: |
     # non-thinking modulatios
     # you could say more compressed
     # usu static-ish spec, ie make this button green.
     
     # the sea of synapse we datum
     # mod spec lines go: [$l, $thi, 
     # they were found 
     # also any $sc maybe be like {$k => $sc, $k2 => $sc2}
     # for comments like v
     # so comp is the very last hash, the rest is where etc.
     #push @{d.css}, '%css#'.$_ => d.cs->{$_}
     #    for sort keys %{d.cs};
     if (d.sc && %{d.sc}) {
         push @{d.css}, Rw esc/arp $sc:d.sc dsc;
     }
 - K: dcs #c cs in da pipe, modulating or so
   mod 7: |
     # cs.$k.$sc -> squiggly first style compressions
     # the wilder pole, coming from mods
     # there's stuff across the whole line too
     # and what's between...
     # exp to css for now...
     if (d.cs && %{d.cs}) { 
         push @{d.css}, Rw esc/arp $sc:d.cs dcs;
     }

