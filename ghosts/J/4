
R_Jz:
 - K: Mn #c one for MyN
   D: |
     my $N = [$n];
     Rw MyN + $N;
 - K: Mno #c whoosh
   D: |
     my $J = shift @$m;
     my $ar = {};
     if (ref $J eq 'ARRAY') {
         ar.M = $J;
     }
     else {
        ar.J = $J
     }
     ar.n = [@$m];
     Rw Mn;
           
 - K: MyN #c mthemZY
   D: |
     # pha $what, any of:
     # - [t( y)( c)( sc)???]
     # - [t, y]
     # - [t, y, c, sc]
     my $peel = sub { # simple as hash from string
        my $s = shift;
        $s =~ s/^{//;
        $s =~ s/}$// || die "unpealable $s";
        my @t = split ',', $s;
        my $t = {};
        for (@t) {
            my ($k, $v) = split ':', $_;
            $t->{$k} = $v;
        }
        return $t;
     };
     # some comp could expectorate lots charstream rhythms ^
     
     my $oM = [];
     my @N = @$N;
     
     my $fl = {};
     if (my $fli = ar.m) {
         $fl->{$_} = 1 for @$fli; # could:this
     }
     my $MZu = sub {
         my $MZ = shift;
         my $n = shift;
         for (split /\s+/, $MZ) {
             /^(.+?)(?::(.+))?$/ || die;
             if (defined $2 && $2 eq '0') {
                 delete $fl->{$1};
             }
             else {
                 $fl->{$1} = $2 || 1;
             }
         }
         n.moozd = 1;
     };
     my $WZu = sub {
         my $WZ = shift;
         my $n = shift;
         
         my $way = 'muck';
         $way = 'fund' if $WZ =~ s/^\///;
         my $Z = Rw $way - $p:WZ $dclone=1;
         
         for my $k (sort keys %$Z) {
              my $s = $Z->{$k};
              die wdump $s if ref $s ne 'ARRAY';
              unshift @N, @$s;
              # or we could do on a stick, so its MZ junk dont linger in this stream
              # ie always flow outwards the sc filtery stuff.
              #my $M = [];
              #Rw MyN $N:s $M;
         }
         n.moozd = 1;
     };
     
     my $fourstring = sub {
         my $s = shift;
         my $n = shift;
         if ($s =~ /^\s*#?\s*MZ (.+)$/) {
             #say "MUZLING $1";
             $MZu->($1, $n);
         }
         elsif ($s =~ /^\s*#/ || $s eq '') {
             #saybl "comment ## $s";
             n.moozd = 1;
         }
         else {
             my $ci = $s;
             for (qw,t y c sc,) {
                 if ($ci =~ s/^(\S+) *//) { # some t are types of space
                     my $v = $1;
                     $v = $peel->($v) if $v =~ /^{/;
                     $n->{$_} = $v;
                 }
             }
         }
     };
     
     my $fouror = sub {
         my $s = shift;
         my $n = shift;
         (n.t, n.y) = @$s;
         n.c  = $s->[2] if exists $s->[2];
         n.sc = $s->[3] if exists $s->[3];
         die'@>4' if @$s > 4;
     };
     
     while (@N) { #c
         my $s = shift @N;
         my $n = {};
         
         if (!ref $s) {
             die "string: $s";
         }
         elsif (ref $s eq 'ARRAY') {
             if (@$s == 1) {
                 die if ref $s->[0];
                 $fourstring->($s->[0], $n);
             }
             else {
                 $fouror->($s, $n);
             }
         }
         elsif (ref $s eq 'HASH') {
            s.MZ ? $MZu->(s.MZ, $n)
            : s.WZ ? $WZu->(s.WZ, $n)
            : die 'hash: '.wdump($s);
         }
         else { die "mmtype:$s" }
         
         next if n.moozd;
         
         for my $k (keys %$fl) { # apply filters that rip elabourate c out of \S+ c
             my $v = $fl->{$k};
             Rw ym/$k $n $v;
         }
         
         if (!ref n.y) {
             if (n.y eq '') { # is or undef
                 n.y = {};
             }
             elsif (0 && n.y =~ /^(\d+)$/ && $1 ne '0') {
                 warn "haps for n.t";
                 n.y = {thi=>$1};
             }
             elsif (n.y =~ /^($NUM)$/) {
                 n.y = {cv=>$1};
             }
             else {die "strung ny: n.y"};
         }
         if (!ref n.c) {
             if (n.c =~ /^{/) {
                 n.c = $peel->(n.c);
             }
             else {
                 n.c = {s => n.c};
             }
         }
         if (!ref n.sc) {
             if (n.sc =~ /^{/) {
                 n.sc = $peel->(n.sc);
             }
         }
         die wdump $N if !ref n.y;
         die "no ny: n.t" if !n.y;
         die "not: ".ki $n if !defined n.t;
         push @$oM, $n;
     }
     #say "ZOYDoM    ". ki $_ for @$oM;
     Rw iM + $oM;
 - K: ym/pwth #c
   D: |
     n.c.pwth = delete n.y
 - K: iM #c as below, for $M instead of $d
   D: |
     # modes: $oM into $J or $M, or $M into $J
     my $J = ar.oJ || ar.J;
     my $oM = ar.oM;
     $oM ||= delete ar.M if ar.M && $J;
     return @$oM if ar.ret;
     my $M = ar.M;
     
     if ($M) {
         sayyl "MMMM ".@$oM."  -0>  M" if ar.V;
         push @$M, @$oM
     }
     elsif ($J) {
         sayyl "@@@@ imol ".@$oM."  -0>  ".gp($J) if ar.V;
         for my $d (@$oM) {
             Rw yo + $J $d;
         }
     }
     else {
         die "no way to modulate: ".wdump $oM;
     }
     @$oM
     
 - K: iiJM #c an ii magnetises guts into $J or $M, or returns if no
   D: |
     return $d if ar.ret;
     my $oM = [$d];
     Rw iM + $oM;
 - K: om/bal #c in-fractalise   $whateverM > bal> $M
   D: |
     my ($d,$oM) = Rw iot +;
     return unless @$oM;
     d.y.bal = [ map {
         ref $_ eq 'HASH' || die'nothash';
         defined _.t || die"not: ".wdump 3,[$_,$oM];
         _.c.s ||= _.t if !defined _.c.s;
         $_
     } @$oM ];
     say "G.jumb.yos:::: om/bal: x".@$oM."  t:d.t    y:".ki(d.y)."        c:".ki(d.c)."       sc:".ki(d.sc) if ar.V;
     #say "G.jumb.yos ^^ ".ki $ar;
     Rw iiJM + $d;
 - K: om/lev #c envelop-in     $whateverM into $M enve
   D: |
     my ($d,$oM) = Rw iot +;
     d.c.pi && die;
     d.c.pi = 'level';
     d.c.s = sub {
         my $J2 = shift;
         if (ar.V) {
             sayyl "Om lev of d.t -> ".ki$_ for @$oM;
         }
         my $d = Rw om/bal $J:J2 $oM $t:d.t;
         #sayre "G.jumb.yos !omlev: d.t   ".ki(d.y);
         my $V = ar.V;
         Rw yo $J:J2 $d $V;
     };
     
     say "G.jumb.yos//// om/lev: x".@$oM."   t:d.t    y:".ki(d.y)."        c:".ki(d.c)."       sc:".ki(d.sc) if ar.V;
     #say "G.jumb.yos ^^ ".ki $ar;
     Rw iiJM + $d;
 - K: pi/level #c envosoub
   D: |
     $u->($J);
     sayyl "J.r made stuff: ". join'    ', sort keys %{J.bb};
 - K: yM #c     yo$M e
   D: |
     sayre "G.jumb.yos===  yM x".@$M;
     for my $d (@$M) {
         die "look like d? ".wdump$d unless d.t && d.y;
         Rw yo + $d;
     }

 - K: C_mod #c modi
   n_D:
     el:
       CARBON: | #
         {csfrm => 'cK'}
     u: | # make pool, synth space, want arches
       # fork & rejoin to exciting place
       
       # YIN

       my $n;

       my $dd = $d;
       for my $is (@is) { # THE TIR drop at hands

           # YANG

           # CARBON

           # CITOZINE

           #sayre "G.jumb.yos - ------ d.y.i:    d.r" if ar.V;
           saybl "G.jumb.yos Post:  "
           ."d.r  \t\t  d.s       ".wdump({@{d.css}}) if ar.V || ar.J.V;
           
           if (c.lev) {
               J.lev->(
                   d.r => c.lev,
                   @{d.css},
               );
           }
           else {
               J.bz->(
                   d.r => d.s,
                   @{d.css},
               );
           }
       }
C mod:
 -
  - s #c d.c.s -> d.s
  - 3.1
  - |
     d.s = $cs;
 -
  - yinvis #c the valley, what it means to be here in here YIN
  - 1
  - |
     # sub-dome and super-modloop
     # find beginning, end, thickness of loop atmosphere
     # so thi is where the manifolds can attach in the stackening
     # the modulation piles them in evenly (todo)
     d.y = {thi => d.y} if !ref d.y;
     my $y = d.y;
     
        if (my $bs = y.bal) {
            y.thi = @$bs;
        }
 -
  - yinvo #c build wave manifold
  - 1.5
  - | 
     die if y.cv && y.in;
     y.in ||= 0.1; 
     y.out ||= 0.9; # up to
     y.thi ||= 1;
     y.space = y.out - y.in; # could spiral much space away from spine
     y.space *= -1 unless y.space > 0;
     y.aspace = y.space / y.thi;
     # twist, lay into segment
     my @is;
     my $csv = defined y.cv ? y.cv : defined y.in ? y.in : die "no yiny".ki$y;
     my $muav;
     for (1..y.thi) {
         my $iy;
         iy.i = $_-1;
         iy.cv = sprintf '%.6f', $csv;
         iy.pcv = sprintf '%.6f', $_ / y.thi;
         s/0+$/0/ for iy.cv, iy.pcv;
         push @is, $iy;
         my $mu = 1;
         if (y.bal) {
             if (!defined $muav) {
                 my $s = sum map{_.y.thy} @{y.bal};
                 my $ov = @{y.bal};
                 $muav = $s/($ov||1);
                 $muav ||= 1;
             }
             my $b = y.bal->[iy.i];
             $mu = b.y.thy if exists b.y.thy;
             $mu = $mu / ($muav||1);
             #saybl " _ iy.cv @ @ @ this thy: $mu y.thi";
             #my $muc = y.aspace * $mu;
             #sayyl "y.aspace * $mu == $muc";
         }
         my $muc = y.aspace * $mu;
         $csv += $muc;
     }
 - 
  - yangtycsc #c inwave, background language expansion, dewey mezrow   YANG
  - 2.1
  - |
     my $d = {%$dd}; # first only & then yangy
     
     d.y = {%{d.y||die}, %$is};
     d.cv = d.y.cv || die;
     d.pcv = d.y.pcv;
     if (d.y.thi > 1) {
         d.t = d.t;#."_not_".d.pcv; # TODO delicate? y.bal overs, but not always wanna
     }
 -
  - csboxen #c the framework... bolts as variables, glowing unevenly recurring hereness
  - 2.2
  - | 
     d.c || die;
     d.sc = {%{d.sc||{}}};
     #^v  ^v
     #  ^v
     d.cs = {%{d.cs||{}}};
     #  ^v esc
     d.css = [@{d.css||[]}];
     #   d.c.$modk = the unravelling mod
     # + d.sc.$esck = outwards, parafin
     # =
     #   d.cs.$modk.$esck = the outwards
     # + d etc
     # ^ yanging mods attach style, main accum fet: cs.$modk.$ck = $c
     # ^ fed to esc which packs styles (default %css) with com: #$cometc$modk
     # some vaguely different piping there for P... grabbed from above I reckon...
 -
  - yangbal #c    suddenly somewhere, pretend to be more somewhere
  - 2.3
  - |
     my $y = d.y;
     if (d.y.bal) {
         # locality
         my $b = d.y.bal->[d.y.i];
         say "G.jumb.yos BAL d.y.i at d.cv    --- d.y.uyiv   ".ki 1, $b if ar.V;
         for my $k (keys %$b) { # c etc merg in per row
             my $v = $b->{$k};
             if (ref $v) {
                 $d->{$k} = {%{$d->{$k}||{}}, %$v};
             }
             else {
                 $d->{$k} = $v;
             }
         }
     }
 -
  - yango #c
  - 2.7
  - |
     # bal may mod t, this may wannab 
     d.r = join "\t", d.t, (d.cv+0); # always update trio
     
     
     my $c = d.c; # <v contation
     die "notrefc  $c" if !ref $c;
 -
  - yangist #c art
  - 2.3
  - |
     n.um = sprintf '%.3d', d.y.uiv;
     
 -
  - dsc #c cs on d, outside mod twistor pipe, modline 4th
  - 7
  - |
     # non-thinking modulatios
     # you could say more compressed
     # usu static-ish spec, ie make this button green.
     
     # the sea of synapse we datum
     # mod spec lines go: [$l, $thi, 
     # they were found 
     # also any $sc maybe be like {$k => $sc, $k2 => $sc2}
     # for comments like v
     # so comp is the very last hash, the rest is where etc.
     #push @{d.css}, '%css#'.$_ => d.cs->{$_}
     #    for sort keys %{d.cs};
     if (d.sc && %{d.sc}) {
         push @{d.css}, Rw esc $d $sc:d.sc SC;
     }
 -
  - dcs #c cs in da pipe, modulating or so
  - 7
  - |
     # cs.$k.$sc -> squiggly first style compressions
     # the wilder pole, coming from mods
     # there's stuff across the whole line too
     # and what's between...
     # exp to css for now...
     if (d.cs && %{d.cs}) { 
         push @{d.css}, Rw esc $d $sc:d.cs CS;
     }

