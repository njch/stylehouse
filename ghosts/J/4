
R_Jz:
 - K: Mn #c one for MyN
   D: |
     my $N = [$n];
     Rw MyN + $N;
 - K: MyN #c mthemZY
   D: |
     my $peel = sub { # simple hash from string
        my $s = shift;
        $s =~ s/^{//;
        $s =~ s/}$// || die "unpealable $s";
        my @t = split ',', $s;
        my $t = {};
        for (@t) {
            my ($k, $v) = split ':', $_;
            $t->{$k} = $v;
        }
        return $t;
     };
     my $oM = [];
     
     my $fl = {};
     if (my $fli = ar.m) {
         $fl->{$_} = 1 for @$fli; # could:this
     }
     my $MZu = sub {
         my $MZ = shift;
         my $n = shift;
         for (split /\s+/, $MZ) {
             /^(.+?)(?::(.+))?$/ || die;
             $fl->{$1} = $2 || 1;
         }
         n.moozd = 1;
     };
     
     my $fourstring = sub {
         my $s = shift;
         my $n = shift;
         if ($s =~ /^\s*#?\s*MZ (.+)$/) {
             #say "MUZLING $1";
             $MZu->($1, $n);
         }
         elsif ($s =~ /^\s*#/) {
             #saybl "comment ## $s";
             n.moozd = 1;
         }
         else {
             #saybl "iiii $s";
             my $ci = $s;
             for (qw,t y c sc,) {
                 if ($ci =~ s/^(\S+) *//) { # some t are types of space
                     my $v = $1;
                     $v = $peel->($v) if $v =~ /^{/;
                     $n->{$_} = $v;
                 }
             }
         }
     };
     
     my $fouror = sub {
         my $s = shift;
         my $n = shift;
         (n.t, n.y) = @$s;
         n.c  = $s->[2] if exists $s->[2];
         n.sc = $s->[3] if exists $s->[3];
         die'@>4' if @$s > 4;
     };
     
     for my $s (@$N) {
         my $n = {};
         
         if (!ref $s) {
             die "string: $s";
         }
         elsif (ref $s eq 'ARRAY') {
             if (@$s == 1) {
                 die if ref $s->[0];
                 $fourstring->($s->[0], $n);
             }
             else {
                 $fouror->($s, $n);
             }
         }
         elsif (ref $s eq 'HASH') {
            die 'hash: ' if !s.MZ;
            $MZu->(s.MZ, $n);
         }
         else { die "mmtype:$s" }
         
         if (n.moozd) {
             #sayyl "TYEYLELYLELYLEL";
             next;
         }
         
         for my $k (keys %$fl) { # apply filters that rip elabourate c out of \S+ c
             my $v = $fl->{$k};
             die if $v ne '1';
             Rw ym/$k $n;
         }
         
         if (!ref n.y) {
             if (n.y eq '') { # is or undef
                 n.y = {};
             }
             elsif (n.y =~ /^(\d+)$/ && $1 ne '0') {
                 n.y = {thi=>$1};
             }
             elsif (n.y =~ /^($NUM)$/) {
                 n.y = {cv=>$1};
             }
             else {die "strung ny: n.y"};
         }
         if (!ref n.c) {
             n.c = {s => n.c};
         }
         die wdump $N if !ref n.y;
         die "no ny: n.t" if !n.y;
         die "not: ".ki $n if !n.t;
         push @$oM, $n;
     }
     #ay "ZOYDoM    ". ki $_ for @$oM;
     Rw iM + $oM;
 - K: ym/pwth #c
   D: |
     n.c.pwth = delete n.y
 - K: wtf #c pi friendly mod stackening, thingy endian # YIN accumuspinny $M parti
   D: |
     my $d = Rw iot;
     d.c.s = ar.s if exists ar.s;
     Rw iiJM + $d;
 - K: iot #c # o to $d  Rw $ar/$m grab    tycscgrabs (starts) space off 2sphere ($d)
   D: |
     my $d;
     
     my $o = Rw pul + $cs:ar.m t y c sc;
     for (qw't y c sc') { 
          exists $o->{$_} || next;
          $d->{$_} && die;
          $d->{$_} = $o->{$_};
     }
     
     if (d.y && !ref d.y) {
         d.y =~ /^($NUM)(?:-($NUM))?/ || die "weird y: d.y";
         d.y = {in=>$1};
         d.y.out = $2 if $2;
     }
     
     d.y.in = ar.in if ar.in;
     d.y.out = ar.out if ar.out;
     d.y.in = ar.at if ar.at;
     
     if (!defined d.y.in) {
         d.y.in = 0.3;
         d.y.out = 0.4;
     }
     
     d.c ||= {};
     d.sc ||= {};
     
     my $oM;
     for (grep{/^\w+M$/ || /^_$/}keys %$ar) {
         $oM && die "many oM: $_";
         $oM = $ar->{$_};
         die "no array in ar looking: $oM ".ki$oM if ref $oM ne 'ARRAY'
     }
     wantarray ? ($d, $oM) : $d
 - K: iM #c as below, for $M instead of $d
   D: |
     # modes: $oM into $J or $M, or $M into $J
     my $J = ar.oJ || ar.J;
     my $oM = ar.oM;
     $oM ||= delete ar.M if ar.M && $J;
     return @$oM if ar.ret;
     my $M = ar.M;
     
     if ($M) {
         push @$M, @$oM
     }
     elsif ($J) {
         sayyl "@@@@ imol ".@$oM."  -0>  ".gp($J);
         for my $d (@$oM) {
             Rw yo + $J $d;
         }
     }
     else {
         die "no way to modulate: ".wdump $oM;
     }
     @$oM
     
 - K: iiJM #c an ii magnetises guts into $J or $M, or returns if no
   D: |
     return $d if ar.ret;
     my $oM = [$d];
     Rw iM + $oM;
 - K: om/bal #c in-fractalise   $whateverM > bal> $M
   D: |
     my ($d,$oM) = Rw iot +;
     d.y.bal = [ map {
         ref $_ eq 'HASH' || die'nothash';
         _.t || die"not: ".wdump 3,[$_,$oM];
         _.c.s ||= _.t;
         $_
     } @$oM ];
     #say "G.jumb.yos:::: om/bal: x".@$oM."  t:d.t    y:".ki(d.y)."        c:".ki(d.c)."       sc:".ki(d.sc);
     #say "G.jumb.yos ^^ ".ki $ar;
     Rw iiJM + $d;
 - K: om/lev #c envelop $whateverM into $M enve
   D: |
     my ($d,$oM) = Rw iot +;
     d.c.lev && die;
     d.c.lev = sub {
         my $J2 = shift;
         my $d = Rw om/bal $J:J2 $oM $t:d.t;
         #sayre "G.jumb.yos !omlev: d.t   ".ki(d.y);
         my $V = 1;
         Rw yo $J:J2 $d $V;
     };
     
     #say "G.jumb.yos//// om/lev: x".@$oM."   t:d.t    y:".ki(d.y)."        c:".ki(d.c)."       sc:".ki(d.sc);
     #say "G.jumb.yos ^^ ".ki $ar;
     Rw iiJM + $d;
 - K: yM #c     yo$M e
   D: |
     sayre "G.jumb.yos===  yM x".@$M;
     for my $d (@$M) {
         die "look like d? ".wdump$d unless d.t && d.y;
         Rw yo + $d;
     }
 - K: yo #c     yrec $d
   D: |
     G.jumb.yos .= '    ';
     if (!ar.q && !J.q && 1) {
         sayyl "G.jumb.yos@@@@   yo:  ar.k     d.t   ".ki(d.y)."     %  "
             .ki(d.c||{})."      %  ".ki(d.sc||{})
     }
     Rw mod/n +;
     G.jumb.yos =~ s/    $//;
     
 - K: mod #c modi
   n_D:
     el:
       CARBON: | #c
         {csfrm => 'cK'}
     dosc: | #c
       Rw Con mod;
     u: | #c make pool, synth space, want arches
       # fork & rejoin to exciting place
       
       # YIN

       my $n;

       my $dd = $d;
       for my $is (@is) { # THE TIR drop at hands

           # YANG

           # CARBON

           # CITOZINE

           #sayre "G.jumb.yos - ------ d.y.i:    d.r" if ar.V;
           saybl "G.jumb.yos Post:          d.r\t\t d.s       @{[]||d.css} " if ar.k eq 'curves';
           
           if (c.lev) {
               J.lev->(
                   d.r => c.lev,
                   @{d.css},
               );
           }
           else {
               J.bz->(
                   d.r => d.s,
                   @{d.css},
               );
           }
       }
mod c:
 - K: yinvis #c the valley, what it means to be here in here YIN
   mod 1: |
     # sub-dome and super-modloop
     # find beginning, end, thickness of loop atmosphere
     # so thi is where the manifolds can attach in the stackening
     # the modulation piles them in evenly (todo)
     d.y = {thi => d.y} if !ref d.y;
     my $y = d.y;
     
     
        if (my $bs = y.bal) {
            y.thi = @$bs;
        }
        
        
     y.in ||= 0.1; 
     y.out ||= 0.9; # up to
     y.thi ||= 1;
     y.space = y.out - y.in; # could spiral much space away from spine
     y.space *= -1 unless y.space > 0;
     y.aspace = y.space / y.thi;
     # twist, lay into segment
     my @is;
     my $csv = defined y.in ? y.in : defined y.cv ? y.cv : die "no yiny".ki$y;
     for (1..y.thi) {
         my $iy;
         iy.i = $_-1;
         iy.cv = sprintf '%.6f', $csv;
         iy.pcv = sprintf '%.6f', $_ / y.thi;
         push @is, $iy;
         $csv += y.aspace;
     }
 - K: yangtycsc #c inwave, background language expansion, dewey mezrow   YANG
   mod 2: |
     my $d = {%$dd}; # first only & then yangy
     
     d.y = {%{d.y||die}, %$is};
     d.cv = d.y.cv || die;
     d.pcv = d.y.pcv;
     if (d.y.thi > 1) {
         d.t = d.t."_not_".d.pcv; # TODO delicate? y.bal overs, but not always wanna
     }
     
     d.c || die;
         d.sc = {%{d.sc||{}}};
     #^v  ^v
     #  ^v
     d.cs = {%{d.cs||{}}};
     #  ^v esc
     d.css = [@{d.css||[]}];
     
     #   d.c.$modk = the unravelling mod
     # + d.sc.$esck = outwards, parafin
     # =
     #   d.cs.$modk.$esck = the outwards
     # + d etc
     
     # ^ yanging mods attach style, main accum fet: cs.$modk.$ck = $c
     
     # ^ fed to esc which packs styles with com: #$cometc$modk, defaulting %cs
     
 - K: yangbal #c suddenly somewhere, pretend to be more somewhere
   mod 2.4: |
     my $y = d.y;
     if (d.y.bal) {
         # locality
         my $b = d.y.bal->[d.y.i];
         #say "G.jumb.yos BAL d.y.i at d.cv    --- d.y.uyiv   ".ki 1, $b;
         for my $k (keys %$b) { # c etc merg in per row
             my $v = $b->{$k};
             if (ref $v) {
                 $d->{$k} = {%{$d->{$k}}, %$v};
             }
             else {
                 $d->{$k} = $v;
             }
         }
     }
 - K: yango #c
   mod 2.7: |
     # bal may mod t, this may wannab 
     d.r = join "\t", d.t, d.cv; # always update trio
     
     
     my $c = d.c; # <v contation
     die "notrefc  $c" if !ref $c;
 - K: yangist #c art
   mod 2.3: |
     n.um = sprintf '%.3d', d.y.uiv;
     
 - K: dsc #c cs on d, outside mod twistor pipe, modline 4th
   mod 7: |
     # non-thinking modulatios
     # you could say more compressed
     # usu static-ish spec, ie make this button green.
     
     # the sea of synapse we datum
     # mod spec lines go: [$l, $thi, 
     # they were found 
     # also any $sc maybe be like {$k => $sc, $k2 => $sc2}
     # for comments like v
     # so comp is the very last hash, the rest is where etc.
     #push @{d.css}, '%css#'.$_ => d.cs->{$_}
     #    for sort keys %{d.cs};
     if (d.sc && %{d.sc}) {
         push @{d.css}, Rw esc/n $d $sc:d.sc DSC;
     }
 - K: dcs #c cs in da pipe, modulating or so
   mod 7: |
     # cs.$k.$sc -> squiggly first style compressions
     # the wilder pole, coming from mods
     # there's stuff across the whole line too
     # and what's between...
     # exp to css for now...
     if (d.cs && %{d.cs}) { 
         push @{d.css}, Rw esc/n $d $sc:d.cs DCS;
     }

