mod c: # pile of stuff on the ceiling
 - K: s #c yes
   mod 3.1: |
     acum $n, gl => $cs; # some funky magnation
 - K: rug #c make carpety
   MZ: {}
   mod 3.2: |
     d.cs.rug.zi = -2;
 - K: unico #c
   mod 3.3: |
      my $c = ref $cs ? $cs : {};
      my $ent = d.s =~ /^(d+)$/ ? $1 : J.ent.2;
      for my $i (1..(c.thi||24)) {
          my $entoi = $1 if ($ent * $i) =~ /(\d)$/;

          my ($b, $dd) = unico(n.um+$i* 100 * $entoi, 1);
          my $pa = $entoi > 7 ? "  " : $entoi > 3 ? " " : "";
          push @{n.gl||=[]}, $pa.$b;
      } 1..34;
 - K: cow #c
   mod 3.4: |
     $i =~ /(\d)?(\d)?(\d)?$/;
     my $col = join'',
       map { /^.*(\d+).*$/; $1 }
       map { J.ent.3 > 6 && $_ > 5 && -4 + J.ent.3 || $_ }
       map{ J.ent.1 > 6 ? $1 * (J.ent.3 / 4) :$_}
       $1,$2,$3;
       # art this shit proply ^
     d.cs.olo.co = $col;
     d.cs.olo.ws = 'p';
 - K: fs #c MOD MOD MOD 1=stable 2=sweep # & SWIM
   mod 3.3: |
     my ($n1,$n2) = $cs =~ /^($NUM)(?:_($NUM))?/;
     # n1 already 0.4 if it wants to be tiny
     my $siz = $n1 * 24;
     $siz -= n.um / $n2 if $n2;
     d.cs.fsgy.fs = $siz;
 - K: sh #c
   MZ: {}
   mod 3: |
     d.cs.awl.sha = '2 2 7 0fc';
 - K: jamit #c
   mod 3: |
     d.cs.awl = "JAMTHATFUELTANK";
 - K: carbcap #c jel like language
   MZ: {}
   mod 3.9: |
     if (n.gl && @{n.gl}) {
         d.s = join'',@{n.gl};
         delete n.gl;
         # roll ^ dough, the gel that gl may be
         # continuous notation we still pick up as chunks of lingo geom
     }
     # ^ es also like looking for most magnity n.thee value heading for $s
     # carbdome...

 - K: yinvis #c what it means to be here
   mod 1: |
     # an extremity at one point
     # two places at once to pack d.in, overallness of loop
     my $v = $i / (999 - d.in);
     n.um = sprintf '%.3d', ($i * $v + 5);
     # hex round sweepage
 - K: yangco #c background language expansion
   mod 2: |
     # yang may pass arounJ komp struc intact for a while
     
 - K: dsc #c cs on d, outside mod twistor pipe
   mod 7: |
     # sc.$sc -> (stable compressions), specd by the */mods vac
     # also any $sc maybe be like {$k => $sc, $k2 => $sc2}
     # for comments like v  # so comp is the very last hash, the rest is where etc.
     #push @{d.css}, '%css#'.$_ => d.cs->{$_}
     #    for sort keys %{d.cs};
     if (%{d.cs}) {
         push @{d.css}, Rw escn $sc:d.sc sc if %{d.sc};
     }
 - K: dcs #c cs in da pipe, modulating or so
   mod 7: |
     # cs.$k.$sc -> squiggly first style compressions
     # the wilder pole, coming from mods
     # there's stuff across the whole line too
     # and what's between...
     # exp to css for now...
     if (%{d.cs}) {
         push @{d.css}, Rw escn $sc:d.cs;
     }
esc c:
 - K: sha #c it
   D: |
     my @m = split m/\s/, $v;
     $m[-1] = X.cole->($m[-1]);
     sprintf 'text-shadow:%dpx %dpx %dpx %s', @m;
 - K: cole #c it
   D: |
        my $h;
        (h.r, h.g, h.b, h.la) = ($1, $2, $3, $4)
                  if $v =~ /^(\w)(\w)(\w)(\w)?$/ || die;
        
        if (defined h.la) {
           # do an rgba(255,255,255,1)
           for my $k (qw'r g b la') {
               my $e = $h->{$k};
               $e = "$e$e" if length $e == 1; # out of 255
               $h->{$k} = hex $e;
           }
           h.la = sprintf '%.2f', h.la / 255; # out of 1
           return "rgba(h.r,h.g,h.b,h.la)";
        }
        else {
           return sprintf "#%s%s%s", h.r, h.g, h.b;
        }
 - K: zi #c it
   D: |
     "z-index:$v"
 - K: co #c it
   D: |
     map { say $_ } "color:".X.cole->($v);
 - K: fs #c it
   D: |
     $v *= 9;
     'font-size:'.int($v).'%';
 - K: ws #c it
   D: |
     my @wtf;
     push @wtf, 'white-space:pre' if $v =~ /p/;
     join ';', @wtf;
 - K: blr #c it
   D: |
     '-webkit-filter:blur('.$v.'px)'
 - K: ml #c it
   D: |
     $v .= 'em' if $v !~ /(%|em|px)/;
     "margin-left:$v"
     
R_Jz:
 - K: esc #c espouse ton carbon product
   D: |
     my $seg = ar.m->[0] if ar.m;
     my @css;
     die if !ref $sc; # parse strings too
     # invent the stevecraig format, playing music
     
     my $X = G.drop.esc ||= {};
     # CARBON subhash=X
     
     my $tw;
     for my $k (sort keys %$sc) {
         my $v = $sc->{$k};
         my $com = ref $v eq 'HASH' ? $k : '';
         my $t = $com ? $v : {$k=>$v};
         for my $tk (sort keys %$t) {
             my $tv = $t->{$tk};
             my $W = $tw->{$com} ||= [];
             
             my $s = $X->{$tk} ? $X->{$tk}->($tv) : die "invent $tk  $tv";
             
             #say " cs #$com# $k    = $tk => $tv         $s";
             push @$W, $s;
         }
     }
     for my $com (sort keys %$tw) {
         my $W = $tw->{$com};
         $com = join'-', grep{$_} $seg, $com; 
         my $sty = '%css';
         $sty .= '#'.$com if $com;
         push @css, $sty => join ';', @$W;
     }
      #   sayre "CSS  @css";
     @css;
 - K: up #c scan
   D: |
     Rw suck */up;
 - K: cv #c mod cove
   n_D:
     oe: |
       my $v = ar.v || ar.thi || 9;
       my $wi = length($v);
       my $thi = join '', ('9') x $wi;
       my $n = 1;
       
       my $squidge;
       if (ar.off) { # offs both ends? plot shit
           $squidge = int(ar.off * ($thi / ($v))); # TODO not quite
           $n += $squidge;
           $v += $squidge; 
       }
       
       my @is = map { sprintf '%0'.$wi.'d', $_  }
           map { $_ - $squidge }
           map { int($_ * ($thi / $v)) } $n..$v;
       
       #sayyl "thehehehhe $squidge $n $v thi $thi". wdump[@is]; 
       die "numbe rdist ".wdump(2,[$v,$wi,$thi,@is]) if uniq(@is) != @is;
       @is;
       
 - K: howge #c
   D: |
     Rw tent geo;
     J.geo.bz->(@$_) for
     Rw suck */curves,
     ;
     
 - K: geoves #c dpaw
   D: |
     my $tw = Rw muck */mods;
     # 6
     for my $k (sort keys %$tw) {
          my $m = $tw->{$k};
          say "goe */mods   $k  ";
          $m || next;
          # coul be entropated all the way to per geomodiff...
          # 7
          Rw modstick $J $m;
     }
 - K: modstick #c api layer between project and hive
   D: |
     my $d = {};
     d.t = shift @$m;
     d.thi = shift @$m;
     d.c = shift @$m;
     d.c = { s => delete d.c } if !ref d.c;
     d.sc = shift @$m;
     #say "duck food ".wdump($d);
     Rw modn $J $d;
       # yep       'color:#8ff;-webkit-filter:blur(3px);margin-left:3em'],
     
 - K: modu #c make pool, synth space, want arches
   D: |
     my $M = G.jumb.modi;
     # lop^
     d.css ||= [];
     d.css = ['%css', d.css] if !ref d.css;

     d.in ||= 1;
     d.out ||= d.thi;

     d.cs ||= {};
     d.c ||= {};
     # d.* is arg line to mod from, from */mods
     # $c=d.c is a whole little phase, language
     # this magnet would have a thrust
     my $n; # drop values through with
     my $c = d.c; # <v contation
     $c = {} if !ref $c;

     my @is = map { int($_ * (999/d.thi)) } d.in..d.out;

     my $dd = $d;
     for my $i (@is){ # THE TIR
         my $d = {%$dd, i => $i, css => [@{d.css}]};
         
         # YIN
         
         # YANG
         
         # CARBON
           
         # CITOZINE

         #saybl "Post: d.s       @{d.css} ";
         my $r = d.t."$i\t0.".sprintf('%03d',$i);
         # 7.1
         J.bz->(
         # 7.2
         $r => d.s,
         # 7.25
         @{d.css},
         # 7.9
         );
     }
 - K: mod #c modi
   n_D:
     any_init: | #c
       Rw suck - */modi;
     modi: | #c shunt, suck, J maint wayfile story
       delete G.drop.esc;
       delete G.drop.conv;
       Rw conv;
       Rw Con mod modu modn;
       Rw Con esc esc escn;
 - K: conv #c cv to somethingness # elements
   D: |
     my $pway = {qw'1 YIN 2 YANG 3 CARBON 7 CITOZINE'};
     G.drop.conv = sub {
          my $v = shift;
         my $dig = $1 if $v =~ /^(\d)/;
         $pway->{$dig} || die " not convable $dig $v";
     };
 - K: Con #c the
   D: |
     my ($the, $src, $path) = @$m;
     # or wherever thi src quags
     my $s = "$the c";
     my $J = Rw Carbonja $s $the;
     
       # shove togeth modn
       # get a cv sorter  that puts 3 > 32, since 3 is 3 all the way down > 3232323...
       # tesalation
       my @daw = Rw tvo $J;
       my $wtf;
       my $coms = {};
       for my $j (@daw) {
           die "non$the?" if j.l ne $the; # how does that work again...
           acum $coms, j.cv => j.com;
           
           my $type = G.drop.conv->(j.cv);
           push @{$wtf->{$type}||=[]}, j.s;
       } 
       
       my $mw = R.way.hooks->{$src};
       my $tl = {};
       for my $k (keys %$wtf) { 
           my $v = $wtf->{$k};
           
           $tl->{$k} = @$v;
           
           $v = join "\n", @$v;
           $mw =~ s/(# $k.*?)$/$1\n$v/sm || die "no $k in ...";
       } 
       my $cl = 'ded';
       my $sl;
       for (sort keys %$coms) {
           my $c = $coms->{$_};
           my $v = G.drop.conv->($_);
           my $fr = " ";
           if ($v ne $cl) {
               $fr = "";
               $cl = $v;
               $sl .= ") " if $sl;
               $sl .= "$v*$tl->{$v}(";
           }
           $sl .= ${fr}.join " ", @$c;
       }
       $sl.=")";
       #saybl " _________________  $mw" if $the eq 'esc';
       sayyl "$path <- $the     $sl";
       # nice thing to print ^
       R.way.hooks->{$path} = $mw;
     
 - K: Carbonja #c 3ish
   D: |
       my @mosd = 0->CsK({s=>$s});
       die "no $s" if !@mosd;
       
       my $inj = sub {
          my ($c, $com, $ome, $k, $v, $the, $J, $D) = @_;
          my (@l,@lr,@r);

          # if for c.cs, for implant condits # sche
          my $type = G.drop.conv->($v);
          # z downgrasp
          my $h = c.MZ; # would be per $k if maybe, D_babz? emberd whatsits
          # assume K stores c formaton 
          $h ||= {csfrm => c.K}
              if $the eq 'mod' && $type eq 'CARBON';

          $h ||= {subhash => 'X'}
              if $the eq 'esc' && $type eq 'CARBON';

               
               
               if (h.subhash) {
                   unshift @l, h.subhash.'.'.c.K." = sub {";
                   push @lr, 'my $v = shift;';
                   $D = ind '     ', $D;
                   push @r, '};';
               }
               
               if (h.csfrm) {
                   $com .= "cs=h.csfrm  ";
                   unshift @l, 'if (my $cs = c.'.h.csfrm.') {';
                   $D = ind '     ', $D;
                   push @r, '}';
               }
               
              
              
               $D = join "\n", $com, @l, @lr, $D, @r;
               $ome = "#$ome" if $ome;
               J bz $k$ome $v $D
       };
       
       my $J = {};
       Rw suJ $J; 
       for my $c (@mosd) {
       
           my @wsy = grep {m/\s/} keys %$c;
           for my $zk (@wsy) {
               my $D = $c->{$zk};
               my ($k, $v) = split m/\s/, $zk;
               my $ome = c.K;
               my $com = "# $zk @ $ome  ";
               
               $inj->($c, $com, $ome, $k, $v, $the, $J, $D);
           }
           
           if (c.D) {
               my $k = $the;
               my $ome = c.K;
               my $com = "# c.K";
               my $v = 3;
               $inj->($c, $com, $ome, $k, $v, $the, $J, c.D);
           }
       }
       $J

