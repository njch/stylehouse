
R_Jz:
 - K: mm #c mthem
   D: |
     my $peel = sub { # simple hash from string
        my $s = shift;
        $s =~ s/^{//;
        $s =~ s/}$// || die "unpealable $s";
        my @t = split ',', $s;
        my $t = {};
        for (@t) {
            my ($k, $v) = split ':', $_;
            $t->{$k} = $v;
        }
        return $t;
     };
     my @mm=();
     my $fl={};
     for my $s (@$m) {
         my $n = {};
         if (!ref $s) {
             die "string: $s";
         }
         elsif (ref $s eq 'ARRAY') {
             # to four
             if (@$s eq 1) {
                 my ($i) = @$s;
                 if (!ref $i) {
                     my $ci = $i;
                     for (qw,t y c sc,) {
                         if ($ci =~ s/^(\S+)\s*//) {
                             my $v = $1;
                             $v = $peel->($v) if $v =~ /^{/;
                             $n->{$_} = $v;
                         }
                     }
                 }
                 else {die $i}
             }
             else {die'@>2'}
         }
         elsif (ref $s eq 'HASH') {
             if (s.MZ) {
                 for (split /\s+/, s.MZ) {
                     /^(.+?)(?::(.+))?$/ || die;
                     $fl->{$1} = $2 || 1;
                     sayre "MZfilter: $1 and $2";
                 }
                 next;
             }
             else {
             die 'hash: ';
             }
         }
         else { die "mmtype:$s" }
         for my $k (keys %$fl) {
             my $v = $fl->{$k};
             die if $v ne '1';
             Rw ym/$k $n;
         }
         push @mm, $n;
     }
     @mm
 - K: ym/pwth #c
   D: |
     n.c.pwth = delete n.y
 - K: om/bal #c enclose $whateverM into $M also balanced   # o grabs space off 2sphere
   D: |
     my ($d,$oM) = Rw iot +;
     d.y.bal = [ map {
         ref $_ eq 'HASH' || die'nothash';
         _.t || die"not: ".ki $_;
         $_
     } @$oM ];
     say "ombl:". wdump $d; 
     Rw shu + $d;
 - K: shu #c     light
   D: |
     push @{ar.M}, $d if ar.M;
     $d;
 - K: iot #c
   D: |
     my $d;
     
     my $o = Rw pul + $cs:m t y c sc;
     
     for (qw't y c sc') {
          exists $o->{$_} || next;
          $d->{$_} && die;
          $d->{$_} = $o->{$_};
     }
     if (d.y && !ref d.y) {
         d.y =~ /^($NUM)(?:-($NUM))?/ || die;
         d.y = {in=>$1};
         d.y.out = $2 if $2;
     }
     if (!defined d.y.in) {
         d.y.in = 0.3;
         d.y.out = 0.4;
     }
     
     d.c ||= {};
     d.sc ||= {};
     
     my $oM;
     for (grep{/^\w+M$/ || /^_$/}keys %$ar) {
         $oM && die "many oM: $_";
         $oM = $ar->{$_};
         die $oM if ref $oM ne 'ARRAY'
     }
     $d, $oM
 - K: yo #c yo
   D: |
     d.yin = d.y || die;
     if (!ar.q && !J.q) {
         sayyl "ar.k   d.t   @ @ @ @   ".ki(d.yin)."     %  "
             .ki(d.c||{})."      %  ".ki(d.sc||{})
     }
     Rw mod/n +;
     
 - K: mo/m #c mod outgoing # general yinyang komprendonator, vis $M ^v^v^v^v^v
   D: |
     my $d = Rw iot +;
     d.y.bal = [ map {
           my ($t,$thing,$c,$sc) = @$_;
           my $p = {};
           p.t = $t;
           p.c = $c || {};
           p.c.s = $t if !exists p.c.s;
           p.c->{$sty} = $thing if $thing ne '';
           p.sc = $sc if $sc;
           $p
       } @$M ];
       
     d.t = $sty.'y'; 
     d.c = {%{ar.c||{}}};
     d.sc = {%{ar.sc||{}}};

     Rw yo $J $d;
 - K: mo/pwth #
   D: |
       my $sty = 'pwth';
       Rw mo/m + $sty;
 - K: modstick # api layer between project and hive # 4d
   D: |
     my $d = {};
     (d.t, d.yin, d.c, d.sc) = @$m;
     
     die if !ref d.c;
     my $wtf = ar.k || $F[4]->{point}.'á£'.$F[2]->{point};
     if (!ar.q && !J.q) {
         sayyl "$wtf @ @ @ @ @ @ @ @  d.t d.yin   "
             .ki(d.c||{})."    ".ki(d.sc||{})
     }
     
     Rw mod/n + $J $d;
     
 - K: mod #c modi
   n_D:
     el:
       CARBON: | #c
         {csfrm => 'cK'}
     dosc: | #c
       Rw Con mod;
     u: | #c make pool, synth space, want arches
       # fork & rejoin to exciting place
       
       # YIN

       my $n;

       my $dd = $d;
       my $i = 0;
       for my $is (@is) { # THE TIR drop at hands

           # YANG

           # CARBON

           # CITOZINE

           #sayre " - ------ d.i :    d.r" if ar.V;
           #saybl "Post: d.s       @{d.css} " if ar.V;
           
           if (c.lev) {
               J.lev->(
                   d.r => c.lev,
                   @{d.css},
               );
           }
           else {
               J.bz->(
                   d.r => d.s,
                   @{d.css},
               );
           }
           $i++;
       }
 - K: esc #c espouse ton carbon product
   n_D:
     el:
       CARBON: | #c
         {droplist => 'O', subhash => 'X'} # qmco:sutff
         # different rhythms to qw == hallucinogenic yaml
     dosc: | #c
       delete G.drop.esc;
       Rw Con esc;
     u: | #c around
       # so '.this > .that' can move to '.another > .that' bunch of styles
       # lending to high dynamic, low cost of tape
       
       my $seg = ar.m->[0] if ar.m;
       my @css;
       die "nonrefsc u asc esc usc". wdump(ar.m) if !ref $sc; # parse strings too
       # invent the stevecraig format, playing music
       # YIN
       
       # ^ list esc.O
       my $tks; # expand (k:)?lma:v to lma:k:v
       for my $k (sort keys %$sc) {
           my $v = $sc->{$k};
           my $com = ref $v eq 'HASH' ? $k : '';
           my $t = ref $v eq 'HASH' ? $v : {$k=>$v};
           
           for my $tk (sort keys %$t) {
               $tks->{$tk}->{$com} = $t->{$tk};
           }
       }
       
       my $unseen = {map{$_=>1}keys%$tks};
       my $tw; # bang
       for my $tk (@{G.drop.esc.O}) {
           my $oms = $tks->{$tk};
           delete $unseen->{$tk};
           next if !$oms;
           for my $com (sort keys %$oms) {
               my $v = $oms->{$com};
               
               my @s = $X->{$tk}->($v, $tks, $X); # < $mish carbon adapt
               # could be a big...
               # tks for X to inject this stream: lma:k:v style (com is k)
               # make better looking pyramids
               
               unshift @s, '%css' if @s == 1;
               while (@s) {
                   my $sty = shift @s;
                   my $s = shift @s;
                   die "$com $sty all3    @s"
                       if defined $tw->{$com}->{$tk}->{$sty};
                       
                   $tw->{$com}->{$tk}->{$sty} = $s;
               }
           }
       }
       die "invent ".join' & ', keys %$unseen if keys %$unseen;
       
       for my $com (sort keys %$tw) {
           my $tks = $tw->{$com};
           for my $tk (sort keys %$tks) {
               my $stys = $tks->{$tk};
               for my $sty (sort keys %$stys) {
                   my $s = $stys->{$sty};
                   #say " ghave $com $sty => $s";
                   $sty .= "#".join('-', grep{$_} $seg, $com, $tk)
                       unless $sty =~ /#/;
                   push @css, $sty => $s;
               }
           }
       }
       #sayre "CSS  @css";
       @css;
       

