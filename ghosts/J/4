     
R_Jz:
 - K: up #c scan
   D: |
     Rw suck */up;
 - K: cv #c mod cove
   n_D:
     oe: |
       my $v = ar.v || ar.thi || 9;
       my $wi = length($v);
       my $thi = join '', ('9') x $wi;
       my $n = 1;
       
       my $squidge;
       if (ar.off) { # offs both ends? plot shit
           $squidge = int(ar.off * ($thi / ($v))); # TODO not quite
           $n += $squidge;
           $v += $squidge; 
       }
       
       my @is = map { sprintf '%0'.$wi.'d', $_  }
           map { $_ - $squidge }
           map { int($_ * ($thi / $v)) } $n..$v;
       
       #sayyl "thehehehhe $squidge $n $v thi $thi". wdump[@is]; 
       die "numbe rdist ".wdump(2,[$v,$wi,$thi,@is]) if uniq(@is) != @is;
       @is;
       
 - K: howge #c
   D: |
     Rw tent geo;
     J.geo.bz->(@$_) for
     Rw suck */curves,
     ;
     
 - K: geoves #c dpaw
   D: |
     my $tw = Rw muck */mods;
     # 6
     for my $k (sort keys %$tw) {
          my $M = $tw->{$k};
          # coul be entropated all the way to per geomodiff...
          # 7
          for my $m (@$M) {
              Rw modstick $J $m $k;
          }
     }
 - K: modstick #c api layer between project and hive # 4d
   D: |
     my $d = {};
     (d.t, d.yin, d.c, d.sc) = @$m;
     
     die if !ref d.c;
     my $wtf = ar.k || $F[4]->{point}.'á£'.$F[2]->{point};
     sayyl "$wtf @ @ @ @ @ @ @ @  d.t d.yin   "
         .ki(d.c||{})."    ".ki(d.sc||{});
     
     #die R.way.hooks.modn; 
     Rw mod/n + $J $d;
     
 - K: mod #c modi
   n_D:
     el:
       CARBON: |
         {csfrm => 'cK'}
     dosc: | #c shunt, suck, J maint wayfile story
       Rw Con mod;
     u: | #c make pool, synth space, want arches
       my @is;
       # fork & rejoin to exciting place
       
       # YIN

       my $n;
       say "YEP   ".join' ', keys %$d;

       my $dd = $d;
       my $i = 0;
       for my $ii (@is){ # THE TIR drop at hands

           # YANG

           # CARBON

           # CITOZINE

           saybl "Post: d.s       @{d.css} " if ar.V;
           
           J.bz->(
             d.r => d.s,
             @{d.css},
           );
           $i++;
       }
 - K: esc #c espouse ton carbon product
   n_D:
     el:
       CARBON: |
         {subhash => 'X'}
     u: |
       # these subs return $s, their own bit of %css or something
       # so the cs/sc can jostle along being expressions at whatever level
       # then turn into whatever encoding/compression pattern
       # as other styles
       # at the point they're leaving the pipelining of the 4 long(yin)wave 
       # also if @s > 1 it must be a list of styles
       # everything, even ^ gets comments like:
       #  #$seg(-$com)?-$tk
       # com haps if there's a d.cs.fo.fo thing going on
       # and when to group styles that can be patched around
       # so '.this > .that' can move to '.another > .that' bunch of styles
       # lending to high dynamic, low cost of tape
       
       my $X = G.drop.esc = {};
       # CARBON
       
       $X
     arp: |
       my $seg = ar.m->[0] if ar.m;
       my @css;
       die wdump(ar.m) if !ref $sc; # parse strings too
       # invent the stevecraig format, playing music
       my $X = G.drop.esc = Rw esc/n;
       
       my $tw;
       for my $k (sort keys %$sc) {
           my $v = $sc->{$k};
           my $com = ref $v eq 'HASH' ? $k : '';
           my $t = $com ? $v : {$k=>$v};
           for my $tk (sort keys %$t) {
               my $tv = $t->{$tk};

               my @s = $X->{$tk} ? $X->{$tk}->($tv) : die "invent $tk  $tv";
               
               if (@s == 1) {
                   unshift @s, '%css';
               }
               my $to = natatime(2, @s);
               while (my @sty_s = $to->()) {
                   my ($sty, $s) = @sty_s;
                   defined $tw->{$com}->{$tk}->{$sty}
                       && die "$com $sty all3    @s";
                   $tw->{$com}->{$tk}->{$sty} = $s; 
               }
           }
       }
       for my $com (sort keys %$tw) {
           my $tks = $tw->{$com};
           for my $tk (sort keys %$tks) {
               my $stys = $tks->{$tk};
               for my $sty (sort keys %$stys) {
                   my $s = $stys->{$sty};
                   #say " ghave $com $sty => $s";
                   $sty .= "#".join('-', grep{$_} $seg, $com, $tk)
                       unless $sty =~ /#/;
                   push @css, $sty => $s;
               }
           }
       }
       #sayre "CSS  @css";
       @css;
       
mod c:
 - K: yinvis #c the valley - what it means to be here in here YIN
   mod 1: |
     # sub-dome and super-modloop
     # find beginning, end, thickness of loop atmosphere
     # so thi is where the manifolds can attach in the stackening
     # the modulation piles them in evenly (todo)
     my $y = d.yin;
     if (!ref $y) {
         say "nonref yin mod: d.yin";
         $y = d.yin = {thi => $y};
     }
     else {
         say "Yin mod: ".wdump($y);
        if (my $bs = y.bal) {
            y.thi = @$bs;
        }
     }
     y.in ||= 1; 
     y.thi ||= 1;
     y.out ||= y.thi;
     # twist, lay into segment
     say "YIN MOD: y.thi   y.in -> y.out";
     @is = map { int($_ * (999/y.thi)) } y.in..y.out;
 - K: yangco #c background language expansion, dewey mezrow   YANG
   mod 2: |
     my $d = {%$dd};
     
     d.cv = "0.".sprintf('%03d',$ii);
     d.t = d.t."$ii"; # delicate? y.bal overs
     d.i = $ii;
     
     d.css = [@{d.css||[]}];
     
     d.cs = {%{d.cs||{}}};
     # ^ yanging mods attach style, main accum fet: cs.$modk.$ck = $c
     # ^ fed to escitozer returns a string for '%css#$cometc$modk'=>$string
     # ^ or a bunch of ('%style'=>$value)+s, will get $cometc so all play nice
     # v this should be overkill, supposed ro or yinbal merges to new
     d.sc = {%{d.sc||{}}};
     # 
     d.c || die;
     
     my $v = $ii / (999 - d.in);
     n.um = sprintf '%.3d', ($ii * $v + 5);
     
     my $y = d.yin;
     if (y.bal) {
         # locality
         my $b = y.bal->[$i];
         for my $k (keys %$b) { # merg in per row
             my $v = $b->{$k};
             if (ref $v) {
                 $d->{$k} = {%{$d->{$k}}, %$v};
             }
             else {
                 $d->{$k} = $v;
             }
         }
     }
     # bal may mod t, this may wannab 
     d.r = join "\t", d.t, d.cv;
     
     my $c = d.c; # <v contation
     die if !ref $c;
     
 - K: dsc #c cs on d, outside mod twistor pipe, modline 4th
   mod 7: |
     # non-thinking modulatios
     # you could say more compressed
     # usu static-ish spec, ie make this button green.
     
     # the sea of synapse we datum
     # mod spec lines go: [$l, $thi, 
     # they were found 
     # also any $sc maybe be like {$k => $sc, $k2 => $sc2}
     # for comments like v
     # so comp is the very last hash, the rest is where etc.
     #push @{d.css}, '%css#'.$_ => d.cs->{$_}
     #    for sort keys %{d.cs};
     if (d.sc && %{d.sc}) {
         push @{d.css}, Rw esc/arp $d $sc:d.sc DSC;
     }
 - K: dcs #c cs in da pipe, modulating or so
   mod 7: |
     # cs.$k.$sc -> squiggly first style compressions
     # the wilder pole, coming from mods
     # there's stuff across the whole line too
     # and what's between...
     # exp to css for now...
     if (d.cs && %{d.cs}) { 
         push @{d.css}, Rw esc/arp $d $sc:d.cs DCS;
     }

