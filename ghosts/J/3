R_Jz:
 - K: Jup #c
   D: |
     my $style = J.style;
     my @style = map {
         saygr "J.name seeking $_...";
         my $p = "$_/styJup";
         Rw suck - $p,
         #Rw suck - */styJup/$_,
        } @$style;
     J.yt = { map{$_=>1} @style};
     saygr "J.name styJupd: @style";
       
     "J".G.jumb.Jnumb++; # additively

 - K: hiJ #c
   D: |
     my $r;
     r.name = shift @$m;
     r.name .=  "-J".G.jumb.Jnumb++; # additively, paranoid
     r.style = [@$m];
     
     my $J = Rw makeJ $r;
     
     Rw Jup $J;
     
     waylay mux(u=>$J);
     
     $J
 - K: makeJ #c
   D: |
      my $r = ar.r || $ar;
      my $u = {K=>'J',%$r}; 
      u.name ||= "J".G.jumb.Jnumb++; # additively
      my $q = 1;
      my $J = w G.R fuu[$u, $q];
      
      sayyl "made ++ ".$J->pi;
      $J
 - K: tent #c pearlesque kings of the
   D: |
     my $na = shift @$m;
     my $name = J.name.'-'.$na;
     my $conJ = Rw makeJ $name;
     $J->{$na} = $conJ;
     conJ.A->umk($J, 'tent');
     conJ.Jmost = J.Jmost || $J;
     $conJ;
 - K: conroll #c rolling con tents, the C Js, away into shadow
   D: |
     my @con = map{_.i} @{J.A.n_tent||[]};
     @con = grep { $_ ne J.on } @con;

     unshift @con, $J;
     
     my @conty;
     la: { for (@con) {
         # somehow plan
         keys %{_.bb} && do{ push @conty, $_; last la }
     } return };
     @con = @conty;

     my @names = map { _.name } @con;
     @names = map { s/^J.name\-//; $_ } @names;

     say "Scraping out ".$J->pi."   tents ".join ", ", @names;
     
     sayre "Jmost bb goners: ".join " ", grep { s/\t(.+?)$// || 1 } 
         sort grep {!/\%/} keys %{J.bb};

     for my $tent (@con) {
         say "Scraping out the ".$tent->pi;
         Rw setup $J:tent;
     }
 - K: JL #c make L bracket # rename Joint
   D: |
      my $u = {K=>'L',%{ar.r || {}}}; 
      u.name ||= "L:J.name:".G.jumb.Lnumb++; # additively
      my $q = 1;
      my $L = w G.R fuu[$u, $q];
      sayyl "made ++ ".$L->pi;
      $L

 - K: fitin #c like push onto the %Joints centipede, which cons
   D: |
     J.bz->(J2.name."\t"."0.".$n => '>:D', '%Joint' => $J2);
     Rw jtrbg $J;
     Rw Joints $J;
 - K: Joints #c
   D: |
     my @things = Rw tvy $J;
     for my $ths (@things) {
         my ($th, @sjs) = @$ths;
         say "y hello ".wdump(1,$th) if th.l ne th.t;
         
         if (my ($Joi) = grep{_.style eq 'Joint'} @sjs) {
             my @jcss = grep{_.style eq 'css' && _.com =~ /^pha/} @sjs;
             my $J2 = $Joi->{s};
             
             Rw oven $J $J2;
             # J2 now disposed to a part of J, all within L
             
             
             my ($Z, $N);
             for my $N (map { _.s } @jcss) {
                 $Z->{$_} = $N->{$_} for keys %$N;
             }
             sayyl " hoping ".$J2->pi." istyle:".wdump($Z);
             
             if ($Z->{'-webkit-transform'} =~ /rotate\((.+?)rad\)/) {
                 $Z->{'-webkit-transform'} = 'rotate('.($1 + -$RADIAN).'rad)',
             }
             
             
             my $beef = J2.S.Z;
             Z.width = '100%';
             Z.height = '100%';
             Z.border = '2px solid rgba(0,0,0,0.3)';
             J2.S.Z = $Z;
             #say "YESSSSS". wdump 2,[tj.r, $beef, map { "   _.r" } @jcss];
         }
     }
 - K: oven #c
   D: |
     J.L ||= Rw JL $J;
     
     sayyl "OVENATING";
     
     w mux(u=>J.L);
     
     for my $k (grep {/^J/} keys %$ar) {
         my $JJ = $ar->{$k};
         JJ.A->umk(J.L => 'S');
         # does that tidy^ TODO
         w mux(u=>$JJ);
     }
     

