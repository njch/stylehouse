R_Jz:
 - K: Jun #c find named J, may return nothing
   D: |
     my $n = Rw Jung;
     my $name = ar.name || ar.m->[0];
     $n->{$name};
 - K: Jung #c find all J
   D: |
     my @aw = K J;
     @aw = grep { !_.A.u_tent } @aw;
     my $na;
     map {
         my $name = $1 if _.name =~ /(^\w+)-J\d+$/ || die;
        $na->{$name} && die "rep of $name";
        $na->{$name} = $_;
     } @aw;
     $na
 - K: Jux #c goto: muxes
   D: |
     my $J = Rw Jun;
     $J || die 'no';
     
     if (ar.in || ar.r) { 
         my $r = ar.in? {i=>ar.in} : ar.r;
         Rw inness $J $r;
     }
     else {
         w mux(u=>$J);
     }
     $J;
 - K: jin #c +GOTO, replaces J: find name->del->hiJ
   D: |
     my $m = ar.m ||= [];
     my $name = ar.name ||= shift(@$m);
     
     Rw Jundel $name;
     
     my $J = Rw hiJ +;
     
     if (ar.in || ar.r) { 
         my $r = ar.in? {i=>ar.in} : ar.r;
         Rw inness $J $r;
     }
     $J;
 - K: Jundel #c ye
   D: |
     my $u = Rw Jun $name;
     $u || return;
     w G.R del[$u];
 - K: onJ #c replace namedo 
   D: |
     my $oJ = Rw Jun $name;
     $oJ ||
     Rw hiJ +;
 - K: Jup #c
   D: |
     my $style = J.style;
     J.yt = {};
     my @blyl;
     my @style;
     for (@$style) {
         my $pin = "$_/yJup";
         my @wk = Rw suck + $pin;
         push @blyl, join '+', uniq @wk;
         for (@wk) {
             push @style, $_;
             J.yt->{$_} ||= {};
             
             my $stick = "$_/life";
             Rw suck + $stick;
         }
     }
     saygr "J.name yJup: @style  -> @blyl";
 - K: hiJ #c add to space # ipv6 goes in
   D: |
     my $u = ar.u ||= {};
     my $m = ar.m ||= [];
     my $name = ar.name ||= shift(@$m) || ar.u.name;
     
     push @$m, $name if !@$m; # def style = name
     
     u.name ||= $name;
     u.name .=  "-J".G.jumb.Jnumb++; # additively, paranoid # individualise
     u.style = [@$m];
     
     my $J = Rw makeJ $u;
     
     Rw Jup $J;
     
     w mux(u=>$J);
     
     $J
 - K: loJ #c les con tent
   D: |
     my $u = ar.u ||= {};
     my $m = ar.m ||= [];
     my $name = ar.name ||= shift(@$m) || ar.u.name;
     
     # etc $m
     u.name ||= $name;
     
     say "loJ: u.name";
     my $J = Rw makeJ $u;
 - K: makeJ #c
   D: |
     u.K ||= 'J';
     u.name || die;
     #life J $u    # carbon
     # ^ babz to:
     my $J = w G.R fuu[$u];
     # ^ has flows_D to suJ, only first time
     $J
 - K: tent #c pearlesque kings of the J...
   D: |
     my $na = shift @$m;
     
     my $name = J.name.'-'.$na;
     
     my $conJ = Rw loJ $name;
     
     $J->{$na} = $conJ;
     conJ.A->umk($J, 'tent');
     conJ.Jmost = J.Jmost || $J;
     #say "Tent of ".$conJ->pi."  ".join"    ",map{_.point}@F[2,4,6,8]; 
     $conJ;


 - K: hamz #c
   D: |
      my $b = shift @$m;
      my $as;
      $b eq 'style' ? do {
          $as = {K=>$b, B=>{am=>shift @$m}};
        die if @$m;
      } :
      do {
          die "unknown $b     @$m ";
      };
      w G.R fuu(u=>$as);

