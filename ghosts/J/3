R_Jz:

 - K: spinash #c J chund/wandry   3erator
   D: |
     my $j;
     j.Jiter = $J; # erse rev
     j.most->{$_} = J.most->{$_} for keys %{J.most||{}};
     # ^ outside v self
     Rw suJ $J:j;
     $j
     
 - K: pha #c temporal phatness, per suJ (encap $M surges within)
   D: |
     my $name = ar.k || shift @{ar.m};
     
     if (my $xx = J.phy->{$name}) {
         # re endtrant
         xx.end->();
         # end - maybe new stuffright as some random part of this process
     }
     for my $outx (grep {_.outsidey} values %{J.phy}) {
        # something? # perhaps a non, fire when no other phy
     }
      
     J.phy ||= {}; # phases
     
     my $x = J.phy->{$name} = {
        begin => hitime(),
        name => $name,
        bb => {},
        ord => [],
        tim => {},
        wtf => {},
     };
     x.head = J.phl->{$name}->{l}->[-1] if J.phy->{$name};
     x.abandon = sub { # upgrades what's there already, early exity lop
         my $why = shift;
         delete J.phy->{$name};
         x.abadoned = $why || 1;
         if (my $xx = x.head) {
             # probably dont want to lie here but...
             (x.begin,x.bb,x.ord,x.tim,x.wtf) = (xx.begin,xx.bb,xx.ord,xx.tim,xx.wtf);
         }
         x.end->();
     };
     x.end = sub {
         my $y = J.phl->{$name} ||= {name=>$name, l=>[]};
         x.ended = hitime();
         delete J.phy->{$name};
         push @{y.l}, $x;
         # layers ^ rolling in time index .r -> the y.l
         # so last phase of $name can be found?
         my $w = @{y.l};
         y.l_bb->{$_} = $w for keys %{x.bb};
         # somewhere thinks about what happened
         return $y;
     };
     x.exactl = sub {
         my $q = shift;
         my $y = x.end->();
         Rw ph_exactl $J $y $q;
     };
     # ensure phase reset with _after_do
     $x;
 - K: ph_same #c loop early exity if $d same
   D: |
     return do {saybl"first x.name";0} if !x.head;
     die"string with order $d" if ref $d;
     x.same_wd = $d;
     if (x.same_wd eq x.head.same_wd) {
         my $why = "$F[2]->{point} @ ph same: x.name";
         saygr $why if !x.qui;
         x.abandon->($why);
         return 1;
     }
     return 0;
 - K: linehum #c arrayngement of line
   D: |
     my @line = ar.js ? @{ar.js} :
     sort { a.cv <=> b.cv }
       sort{ a.r cmp b.r }
       map { _.j, values %{_.sj} } ar.lv ? ar.lv : @{ar.vs};
     return [ map { [ _.t, _.cv, _.s ] } @line ];
 - K: lv_same #c linehum check
   D: |
     if (defined x.off) {
        my $woff = sprintf '%.4f', x.begin - x.head.begin;
        if ($woff > x.off) {
            saygr " lv_same; off !!!!! ($woff > x.off) *****" if ar.V;
            return 0;
        }
        saygr " lv_same; off within ($woff < x.off)" if ar.V;
     }
     my $d = Rw lv_dig +;
     Rw ph_same $J $x $d;
 - K: lv_dig #c linehum dig
   D: |
     my $ln =  Rw linehum +;
     for my $n (@$ln) {
         my $s = $n->[2]; # t/y/(s)
         $s = ref $s eq 'HASH' ? "s.r s.id"
            : ref $s eq 'ARRAY' ? die 'arline'
            : $s;
         $n->[2] = $s;
     }
     my $d = ejson $ln;
     #saygr " Digwa: ".slim 280, $d if ar.V;
     $d = dig $d;
     
     
 - K: blabphys #c
   D: |
     say "Active phases:".(! %{J.phy} && " NONE");
     for my $x (values %{J.phy}) {
         say " - x.name:";
         say "  * $_    == x.bb->{$_}" for sort keys %{x.bb};
     }
 - K: from_phys #c
   D: |
     my $in = {};
     for my $y (values %{J.phl}) {
         if (exists y.l_bb->{$r}) {
             $in->{y.name} = y.l_bb->{$r};
         }
     }
     $in;
 - K: ph_exactl #c or drop not in last
   D: |
       my $wtf = ar.wtf || {};
       my $cur = wtf.cur = y.l->[-1];
       my $last = wtf.last = y.l->[-2];
       wtf.same = 1;
       if (!$last) { # better not get autovivified! 
           wtf.allnew = 1;
           wtf.same = 0;
           sayre "ph_exactl cur.name: all new" if J.verb;
           #return;
           last.bb = {};
       }
       #y.l_bb->{$_} = $w for keys %{x.bb};
       # churn stats like 30% of last disappear, 20% new
       
       for (sort keys %{cur.bb}) {
           if (!exists last.bb->{$_}) {
               sayre " ++ No $_ in last" if !cur.qui && !wtf.allnew;
               wtf.new->{$_} = cur.bb->{$_};
               wtf.same = 0;
           } 
           elsif (last.bb->{$_} ne cur.bb->{$_}) {
               sayre " <> different $_ now" if cur.V || !cur.qui && !ar.q eq 'diff'; # block hash s noise
               wtf.diff->{$_} = cur.bb->{$_};
               wtf.same = 0;
           }
       }
       
       for (grep { !exists cur.bb->{$_} } sort keys %{last.bb}) {
           sayre " rm No $_ in current" if !cur.qui;
           wtf.gone->{$_} = last.bb->{$_};
           wtf.same = 0;
           delete J.bb->{$_};
       }
       
       my $count = keys %{cur.bb};
       my $gl = wtf.same ? "===" : "+-";
       saygr "ph_exactl cur.name: *$count ".
           slim 50, join("  ",($gl) x 6) if !cur.qui && !wtf.allnew;
       $wtf;
     
 - K: tent #c pearlesque kings of the J... NOPE, PUT INSIDE, HIDE FROM WO ETC STYLES ARE WIRES TODO
   D: |
     my $na = shift @$m;
     
     my $name = J.name.'-'.$na;
     my $conJ = Rw loJ $J $name;
     
     $J->{$na} = $conJ;
     #say "We got a $conJ conJ: ".gp $conJ;
     conJ.most.J = J.most.J || $J;
     #say "Tent of ".$conJ->pi."  ".join"    ",map{_.point}@F[2,4,6,8]; 
     $conJ;
 - K: loJ #c les con tent
   D: |
     my $u = ar.u ||= {};
     my $m = ar.m ||= [];
     my $name = ar.name ||= shift(@$m) || ar.u.name;
     
     # etc $m
     u.name ||= $name;
     
     #say "loJ: u.name" if !J.q;
     Rw makeJ $u;
 - K: the #c pg69make, ongoable, rolly grab
   D: |
     my $what = $m->[0];
     my $wt = Rw wuck $J */$what;
     my $M = [];
     for my $k (sort keys %$wt) {
         my $N = $wt->{$k};
         if (!ref $N) {
             $N = [ map { [$_] } split "\n",$N ];
         }
         #say " ** waything $what from $k";
         Rw MyN $N $M;
     }
     #saybl "the $what: ".join', ',map{_.t}@$M;
     # inside the J so
     # ar close braid
     Rw iM + $oM:M $k:what;
 - K: thy #c rollbar grab
   D: |
     my $o = Rw pul + pin;
     o.pin ||= ar.p;
     my $wt = ar.anon ?
         Rw wuck $J $pin:o.pin
     :
         Rw wuck $J */o.pin;
     warn "no o.pin          for ".gp($J) if !$wt;
     
     $J = ar.oJ || $J;
     my $nc = 1;
     
     for my $k (sort keys %$wt) {
         my $N = $wt->{$k};
         
         my $coi = Rw pha $J $k;
         
         my $d = ref $N ? ejson($N) : $N;
         
         next if Rw ph_same $J $x:coi $d;
         
         $N = [ map { [$_] } split "\n",$N ] if !ref $N;
         
         #say " ** waything $what from $k";
         Rw MyN $N $J;
          
         my $y = coi.exactl->();
         $nc = 0 if !y.same;
     }
     $nc = -1 if !%$wt;
     $nc
 - K: thi #c thy rollbar grab, anon
   D: |
     Rw thy + $anon=1;
 - K: wtf #c pi friendly mod stackening, thingy endian # YIN accumuspinny $M parti
   D: |
     my $d = Rw iot;
     d.c.s = ar.s if exists ar.s;
     Rw iiJM + $d;
 - K: iot #c # o to $d  Rw $ar/$m grab    tycscgrabs (starts) space off 2sphere ($d)
   D: |
     my $d;
     
     my $o = Rw pul + t y c sc;
     for (qw't y c sc') { 
          exists $o->{$_} || next;
          $d->{$_} && die;
          $d->{$_} = $o->{$_};
     }
     
     if (d.y && !ref d.y) {
         d.y =~ /^($NUM)(?:-($NUM))?/ || die "weird y: d.y";
         d.y = {in=>$1};
         d.y.out = $2 if $2;
     }
     
     d.y.in = ar.in if ar.in;
     d.y.out = ar.out if ar.out;
     d.y.in = ar.at if ar.at;
     
     if (!defined d.y.in) {
         d.y.in = 0.3;
         d.y.out = 0.4;
     }
     
     d.c ||= {};
     d.sc ||= {};
     
     my $oM;
     for (grep{/^\w+M$/ || /^_$/}keys %$ar) {
         $oM && die "many oM: $_";
         $oM = $ar->{$_};
         die "no array in ar looking: $oM ".ki$oM if ref $oM ne 'ARRAY'
     }
     wantarray ? ($d, $oM) : $d
 - K: shway #c ongoable code view
   D: |
     my $what = $m->[0];
     my $wt = Rw wuck $J */$what;
     my $M = [];
     for my $k (sort keys %$wt) {
         my $N = $wt->{$k};
         my $s = $k;
         my $sw = $1 if $what =~ /^(.+\/)\*/;
         $s =~ s/^.*$sw//;
         my $n = [$s, $k];
         #say " ** waything $what from $k";
         Rw Mn $n $M pwth;
     }
     #saybl "the $what: ".ki 1, $_ for @$M;
     # inside the J so
     # ar close braid
     Rw iM + $oM:M;

