R_Jz:

 - K: spinash #c J chund/wandry   3erator
   D: |
     my $j;
     j.Jiter = $J; # erse rev
     j.most->{$_} = J.most->{$_} for keys %{J.most||{}};
     # ^ outside v self
     Rw suJ $J:j;
     $j
     
 - K: pha #c temporal phatness, per suJ (encap $M surges within)
   D: |
     my $name = ar.k || shift @{ar.m};
     
     if (my $xx = J.phy->{$name}) {
         # re endtrant
         xx.end->();
         # end - maybe new stuffright as some random part of this process
     }
     for my $outx (grep {_.outsidey} values %{J.phy}) {
        # something? # perhaps a non, fire when no other phy
     }
     
     J.phy ||= {}; # phases
     
     my $x = J.phy->{$name} = {
        begin => hitime(),
        name => $name,
        bb => {},
        ord => [],
        tim => {},
        wtf => {},
     };
     x.head = J.phl->{$name}->{l}->[-1] if J.phy->{$name};
     x.abandon = sub { # upgrades what's there already, early exity lop
         my $why = shift;
         delete J.phy->{$name};
         x.abadoned = $why || 1;
         if (my $xx = x.head) {
             # probably dont want to lie here but...
             (x.bb,x.ord,x.tim,x.wtf) = (xx.bb,xx.ord,xx.tim,xx.wtf);
         }
         x.end->();
     };
     x.end = sub {
         my $y = J.phl->{$name} ||= {name=>$name, l=>[]};
         x.ended = hitime();
         delete J.phy->{$name};
         push @{y.l}, $x;
         # layers ^ rolling in time index .r -> the y.l
         # so last phase of $name can be found?
         my $w = @{y.l};
         y.l_bb->{$_} = $w for keys %{x.bb};
         # somewhere thinks about what happened
         return $y;
     };
     # ensure phase reset with _after_do
     $x;
 - K: ph_same #c loop early exity if $d same
   D: |
     return 0 if !x.head;
     die"string with order $d" if ref $d;
     x.same_wd = $d;
     if (x.same_wd eq x.head.same_wd) {
         x.abandon->(saygr "$F[2]->{point} @ ph same: x.name");
         return 1;
     }
     return 0;
 - K: blabphys #c
   D: |
     say "Active phases:".(! %{J.phy} && " NONE");
     for my $x (values %{J.phy}) {
         say " - x.name:";
         say "  * $_    == x.bb->{$_}" for sort keys %{x.bb};
     }
 - K: from_phys #c
   D: |
     my $in = {};
     for my $y (values %{J.phl}) {
         if (exists y.l_bb->{$r}) {
             $in->{y.name} = y.l_bb->{$r};
         }
     }
     $in;
 - K: ph_exactl #c or drop not in last
   D: |
       my $wtf = ar.wtf || {};
       my $cur = wtf.cur = y.l->[-1];
       my $last = wtf.last = y.l->[-2];
       wtf.same = 1;
       if (!$last) { # better not get autovivified! 
           wtf.allnew = 1;
           wtf.same = 0;
           sayre "ph_exactl cur.name: all new" if J.verb;
           #return;
           last.bb = {};
       }
       #y.l_bb->{$_} = $w for keys %{x.bb};
       # churn stats like 30% of last disappear, 20% new
       
       for (sort keys %{cur.bb}) {
           if (!exists last.bb->{$_}) {
               sayre " + No $_ in last" if !wtf.allnew;
               wtf.new->{$_} = cur.bb->{$_};
               wtf.same = 0;
           }
           elsif (last.bb->{$_} ne cur.bb->{$_}) {
               sayre " != different $_ now";
               wtf.diff->{$_} = cur.bb->{$_};
               wtf.same = 0;
           }
       }
       
       for (grep { !exists cur.bb->{$_} } sort keys %{last.bb}) {
           sayre " - No $_ in current";
           wtf.gone->{$_} = last.bb->{$_};
           wtf.same = 0;
           delete J.bb->{$_};
       }
       
       my $gl = wtf.same ? "===" : "+-";
       sayre "ph_exactl cur.name: ". slim 50, join("  ",($gl) x 6) if !wtf.allnew;
       $wtf;
     
 - K: as #c get abulator # TODO sink hashy hooks all over # TODO should chain, broke
   D: |
       my $j = {};
       my $do;
       $do = sub {
           my $j = {%$j};
           my $ad = [@_];
           my %j = %$j;
           while (@$ad) {
               my ($k, $v) = (shift @$ad, shift @$ad);
               
               my $comp = $k =~ /^(%|\+)/;
               my $j = {%j} if $comp;
               if ($comp) {
                   $k =~ s/^\+// if $comp;
                   j.t .= $k if $comp;
               }
               else {
                   (j.t, j.cv) = $k =~ /^(.+)\s+(.+?)$/;
                   %j = %$j;
               }
               defined j.cv || die "NOSEYV: j.cv".wdump($j);
               j.r = j.t."\t".j.cv;
               j.s = $v;
               
               my @Js = $J;
               push @Js, values %{J.phy} if J.phy;
               for my $jj (@Js) {
                   jj.bb->{j.r} = j.s;
                   push @{jj.ord}, {%$j} if jj.ord;
                   jj.tim->{j.r} = hitime() if jj.tim;
                   jj.wtf->{j.r} = $F[0] if jj.wtf;
               }
           }
           wantarray ? ($j, 
               sub{$do->(%$j, @_)} # TODO fucked, get some weed and fix it
           ) : $j
       };
       $do
 - K: shj #c pronounce $j{r,s,t,l,com?,style?,cv,ev?} # to cache or something, is phasey
   D: |
     my $j;
     j.r = $r; # TODO probly sameness
     die if ar.C;
     ar.d = ar.J.bb if ar.J;
     j.s = ar.C || (ar.d)->{$r}; # carbon in, or from abdomin
     (j.t, j.cv) =
         j.r =~ /^(.+)\t(.+?)$/ ? ($1, $2)
         :
         j.r =~ /^(.+)\s+(.+?)$/ ? ($1, $2) : die;
         
     my $t = j.t; # sep orthoogabooga
     j.com = $1 if $t =~ s/#([^\/]+)$//;
     j.style = $1 if $t =~ s/%([^\/]+)$//;
     j.l = $t;
     
     (j.cv, my @e) = split /\s+/, j.cv;
     die if @e;
     j.ev = \@e if @e;
     die if j.b;
     unless (J.yl.nojb) {
         j.b.b.b = ar.d;
         j.b.b.j = ar.J if ar.J;
     }
     $j
 - K: tent #c pearlesque kings of the J... NOPE, PUT INSIDE, HIDE FROM WO ETC STYLES ARE WIRES TODO
   D: |
     my $na = shift @$m;
     
     my $name = J.name.'-'.$na;
     my $conJ = Rw loJ $J $name;
     
     $J->{$na} = $conJ;
     #say "We got a $conJ conJ: ".gp $conJ;
     conJ.most.J = J.most.J || $J;
     #say "Tent of ".$conJ->pi."  ".join"    ",map{_.point}@F[2,4,6,8]; 
     $conJ;
 - K: conroll #c rolling con tents, the C Js, away into shadow TIME
   D: |
     my @con = map{_.i} @{J.A.n_tent||[]};
     
     unshift @con, $J;
      
     @con = grep { !_.yy.conroll.dont } @con;
     
     @con = grep { keys %{_.bb} } @con;
     
     return if !@con;
     
     say "conrolling ".$J->pi."   tents:";
     sayyl map{" - $_"}
         map { _.name =~ /^(J.name\-)?(.+)$/; "$2 * ".
         do {
             my @log = sort keys %{_.bb};
            @log > 5 ? scalar(@log)
            : join "'", @log;
         };
         } @con;
     
     # dont mention mods? sum mods?
     #sayre "Jmost bb goners: ".join " ", grep { s/\t(.+?)$// || 1 } 
     #    sort grep {!/\%/} keys %{J.bb};

     for my $tent (@con) {
         #say "Scraping out the ".$tent->pi;
         Rw suJ $J:tent;
     }
 - K: loJ #c les con tent
   D: |
     my $u = ar.u ||= {};
     my $m = ar.m ||= [];
     my $name = ar.name ||= shift(@$m) || ar.u.name;
     
     # etc $m
     u.name ||= $name;
     
     #say "loJ: u.name" if !J.q;
     Rw makeJ $u;
 - K: the #c pg69make, ongoable, rolly grab
   D: |
     my $what = $m->[0];
     my $wt = Rw wuck $J */$what;
     my $M = [];
     for my $k (sort keys %$wt) {
         my $N = $wt->{$k};
         if (!ref $N) {
             $N = [ map { [$_] } split "\n",$N ];
         }
         #say " ** waything $what from $k";
         Rw MyN $N $M;
     }
     #saybl "the $what: ".join', ',map{_.t}@$M;
     # inside the J so
     # ar close braid
     Rw iM + $oM:M $k:what;
 - K: wtf #c pi friendly mod stackening, thingy endian # YIN accumuspinny $M parti
   D: |
     my $d = Rw iot;
     d.c.s = ar.s if exists ar.s;
     Rw iiJM + $d;
 - K: iot #c # o to $d  Rw $ar/$m grab    tycscgrabs (starts) space off 2sphere ($d)
   D: |
     my $d;
     
     my $o = Rw pul + $cs:ar.m t y c sc;
     for (qw't y c sc') { 
          exists $o->{$_} || next;
          $d->{$_} && die;
          $d->{$_} = $o->{$_};
     }
     
     if (d.y && !ref d.y) {
         d.y =~ /^($NUM)(?:-($NUM))?/ || die "weird y: d.y";
         d.y = {in=>$1};
         d.y.out = $2 if $2;
     }
     
     d.y.in = ar.in if ar.in;
     d.y.out = ar.out if ar.out;
     d.y.in = ar.at if ar.at;
     
     if (!defined d.y.in) {
         d.y.in = 0.3;
         d.y.out = 0.4;
     }
     
     d.c ||= {};
     d.sc ||= {};
     
     my $oM;
     for (grep{/^\w+M$/ || /^_$/}keys %$ar) {
         $oM && die "many oM: $_";
         $oM = $ar->{$_};
         die "no array in ar looking: $oM ".ki$oM if ref $oM ne 'ARRAY'
     }
     wantarray ? ($d, $oM) : $d
 - K: shway #c ongoable code view
   D: |
     my $what = $m->[0];
     my $wt = Rw wuck $J */$what;
     my $M = [];
     for my $k (sort keys %$wt) {
         my $N = $wt->{$k};
         my $s = $k;
         my $sw = $1 if $what =~ /^(.+\/)\*/;
         $s =~ s/^.*$sw//;
         my $n = [$s, $k];
         #say " ** waything $what from $k";
         Rw Mn $n $M pwth;
     }
     #saybl "the $what: ".ki 1, $_ for @$M;
     # inside the J so
     # ar close braid
     Rw iM + $oM:M;

