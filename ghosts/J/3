R_Jz:

 - K: hiJ #c
   D: |
     my $r;
     r.name = shift @$m;
     r.name .=  "-J".G.jumb.Jnumb++; # additively, paranoid
     r.style = [@$m];
     
     my $J = Rw makeJ $r;
     
     Rw Jup $J;
     
     waylay mux(u=>$J);
     
     $J
 - K: Jung #c
   D: |
     my @aw = K J;
     @aw = grep { !_.A.u_tent } @aw;
     my $na;
     map {
         my $name = $1 if _.name =~ /(^\w+)-J\d+$/ || die;
        $na->{$name} && die "rep";
        $na->{$name} = $_;
     } @aw;
     $na
        
     
 - K: figure_busy #c log churn brings lux
   D: |
     my $n = Rw Jung;
     # collect J.biz.onei etc
     my $tago;
     my $now = $H->hitime;
     map {
        my $tilux = $now - _.ent.ti;
        $tilux *= _.ent.lux if _.ent.lux;
         $tago->{$tilux} = $_;
     } values $n;
     my @mago = map { { u=>$tago->{$_},lux=>$_ } } sort keys %$tago;
     @mago;
 - K: makeJ #c
   D: |
      my $r = ar.r || $ar;
      my $u = {K=>'J',%$r}; 
      u.name ||= "J".G.jumb.Jnumb++; # additively
      
      my $r = {q=>1};
      my $J = w G.R fuu[$u, $r];
      # ^ has flows_D
      
      sayyl (r.new?" made + + ":" - J - ").$J->pi;
      $J
 - K: suJ #c a sudo J, %{ r:sets up $a (J or not quite J hash $a, phro etc) with bbdomin stuff
   D: |
     J.bb = {};
     J.ord = [];
     J.bz = Rw as $bb:J.bb $ord:J.ord;
     J.bcj = {};
     
     J.idyl = sub {
         my ($J, $id, $oj) = @_;
         J.Jmost.idly->{$id} = {J=>$J, j=>$oj};
     };
     
     my $by = sub {
         my $that = shift;
         sub {
             my $j = {etc=>[]};
             (j.r, j.s, @{j.etc}) = @_;
             j.Jiter = $J; # easy reverse
             # drifter, expecting 8 (forks & events) approp.
             # this is a tent it is
             j.Jmost = J.Jmost;
             Rw suJ $J:j;
             $that->($j); 
         };
     };
     
     # 3
     # 4
 - K: Jup #c
   D: |
     my $style = J.style;
     J.yt = {};
     my @style = map {
         saygr "J.name seeking $_...";
         my $pin = "$_/styJup";
         Rw suck + $pin;
        } @$style;
     
     J.yt->{$_} ||= 1 for @style;
     saygr "J.name styJupd: @style";
       
     "J".G.jumb.Jnumb++; # additively
 - K: tent #c pearlesque kings of the
   D: |
     my $na = shift @$m;
     my $name = J.name.'-'.$na;
     
     my $conJ = Rw makeJ $name;
     
     $J->{$na} = $conJ;
     conJ.A->umk($J, 'tent');
     conJ.Jmost = J.Jmost || $J;
     $conJ;
 - K: conroll #c rolling con tents, the C Js, away into shadow
   D: |
     my @con = map{_.i} @{J.A.n_tent||[]};
     @con = grep { $_ ne J.on } @con;
     
     unshift @con, $J;
     
     @con = grep { keys %{_.bb} } @con;
     return if !@con;
     
     say "conrolling ".$J->pi."   tents ".join "    ",
         map { _.name =~ /^(J.name\-)?(.+)$/; "$2 * ".
         do {
             my @log = sort keys %{_.bb};
            @log > 5 ? scalar(@log)
            : join "'", @log;
         };
         } @con;
      
     sayre "Jmost bb goners: ".join " ", grep { s/\t(.+?)$// || 1 } 
         sort grep {!/\%/} keys %{J.bb};

     for my $tent (@con) {
         #say "Scraping out the ".$tent->pi;
         Rw suJ $J:tent;
     }
 - K: JL #c make L bracket # rename Joint
   D: |
      my $u = {K=>'L',%{ar.r || {}}}; 
      u.name ||= "L:J.name:".G.jumb.Lnumb++; # additively
      my $q = 1;
      my $L = w G.R fuu[$u, $q];
      sayyl "made ++ ".$L->pi;
      $L
 - K: oven #c
   D: |
     J.L ||= Rw JL $J;
     
     sayyl "OVENATING";
     
     w mux(u=>J.L);
     
     for my $k (grep {/^J/} keys %$ar) {
         my $JJ = $ar->{$k};
         JJ.A->umk(J.L => 'S');
         # does that tidy^ TODO
         w mux(u=>$JJ);
     }
     

