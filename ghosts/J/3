R_Jz:




 - K: hijack #c hit J
   D: |
      my $J = Rw hiJ below hull;
      ar.J = $J;
      Rw suck + */hijack;
      $J
 - K: hiJ #c
   D: |
     my $r;
     r.name = shift @$m;
     r.name .=  "-J".G.jumb.Jnumb++; # additively, paranoid
     r.style = [@$m];
     
     my $J = Rw makeJ $r;
     
     Rw Jup $J;
     
     waylay mux(u=>$J);
     
     $J
 - K: makeJ #c
   D: |
      my $r = ar.r || $ar;
      my $u = {K=>'J',%$r}; 
      u.name ||= "J".G.jumb.Jnumb++; # additively
      my $q = 1;
      my $J = w G.R fuu[$u, $q];
      
      sayyl "made ++ ".$J->pi;
      $J
 - K: Jup #c
   D: |
     my $style = J.style;
     my @style = map {
         saygr "J.name seeking $_...";
         my $p = "$_/styJup";
         Rw suck - $p,
         #Rw suck - */styJup/$_,
        } @$style;
     J.yt = { map{$_=>1} @style};
     saygr "J.name styJupd: @style";
       
     "J".G.jumb.Jnumb++; # additively
 - K: JL #c make L bracket
   D: |
      my $u = {K=>'L',%{ar.r || {}}}; 
      u.name ||= "L:J.name:".G.jumb.Lnumb++; # additively
      my $q = 1;
      my $L = w G.R fuu[$u, $q];
      sayyl "made ++ ".$L->pi;
      $L

 - K: fitin #c
   D: |
     my @so = sort grep {/^J.+/} keys %$ar;
     my $J = ar.J;
     for (sort keys %$ar) {
         /^J(\d+)$/ || next;
         my $cvb = $1;
         my $Jo = $ar->{$_};
         J.bz->(Jo.name."\t"."0.".$cvb => '>:D', '%Joint' => $Jo);
     }
     Rw jtrbg $J;
     Rw Joints $J;
 - K: Joints #c
   D: |
     my @things = Rw tvy $J;
     for my $thing (@things) {
         my ($tj, @sjs) = @$thing;
         if (my ($Joi) = grep{_.style eq 'Joint'} @sjs) {
             my @jcss = grep{_.style eq 'css' && _.com =~ /^pha/} @sjs;
             my $J2 = $Joi->{s};
             
             Rw oven $J $J2;
             # J2 now disposed to a part of J, all within L
             
             
             my ($Z, $N);
             for my $N (map { _.s } @jcss) {
                 $Z->{$_} = $N->{$_} for keys %$N;
             }
             sayyl " hoping ".$J2->pi." istyle:".wdump($Z);
             
             if ($Z->{'-webkit-transform'} =~ /rotate\((.+?)rad\)/) {
                 $Z->{'-webkit-transform'} = 'rotate('.($1 + -$RADIAN).'rad)',
             }
             
             
             my $beef = J2.S.Z;
             Z.width = '100%';
             Z.height = '100%';
             Z.border = '2px solid rgba(0,0,0,0.3)';
             J2.S.Z = $Z;
             #say "YESSSSS". wdump 2,[tj.r, $beef, map { "   _.r" } @jcss];
         }
     }
 - K: oven #c
   D: |
     J.L ||= Rw JL $J;
     
     sayyl "OVENATING";
     
     w mux(u=>J.L);
     for my $k (grep {/^J/} keys %$ar) {
         my $JJ = $ar->{$k};
         JJ.A->umk(J.L => 'S');
         # does that tidy^ TODO
         w mux(u=>$JJ);
     }
     

 - K: lplumb #c abomdin, a level, subby plumbing, tin gplumb
   babz:
     'suJ 3.2': |
       J.lev = $by->(sub {
           my $j = shift;
           j.sub = delete j.s;
           Rw lplumb $J:j;
       });
   D: |
     J.sub->($J);
     my $a = $J;
     J.s = w G.theR maka[$a];
     J.Jiter.bz->(J.r => J.s,
         '%lp' => $J,
         @{J.etc},
     );
 - K: gp # R_sur gp
   babz:
     'suJ 3.1': |
       # another little con tent, backeting a harmonic sur-ish portal
       J.fro = $by->(sub {
           my $j = shift;
           j.u = delete j.s;
           j.cv = shift @{j.etc};
           Rw gp $J:j;
       });
   D: |
        G.jumb.gp_inarow++;
        aft { G.jumb.gp_inarow-- };
        %$J = (%$J, %{delete J.cv}) if ref J.cv;
        J.cv = 0.1 if J.cv < 0.1;
        
        # 3
           sayyl "DDDDDDDDDDDGp ". gp J.r for 1..10;
        
        J.isJid = J.replaceJid || $H->mkuid;
        if (G.jumb.gp_inarow > 1) {
            undef J.isJid;
        }
        #sayyl join(" ", ("  ") x G.jumb.gp_inarow)." ooooo ".gp(J.u);
        J.Jmost.gpa.pis->{J.isJid} = $J if J.isJid;
        # TODO J pass over # maka suction
        # don't need to close it up right now...
        # top down injection gos
        
        my $a = $J; # pretend, sli C7
        my $u = J.u;
        
        my $wa = J.wa || do {
            J.c = $R->cgp($u);
            # ^
            
            # v
            my ($wa) = grep { J.c->{$_} } qw'canpi ARRAY HASH ref undef text';
            $wa = ref $u if $wa eq 'canpi';
            $wa ||= 'wtf';
            $wa;
        };
        # can stick $wa on J.wa for thrashing maths
        
        
        R.way->find("pi/$wa") || die "not $wa equip";
        
        # 5 forking swivel injecty

        # 6
        Rw pi/$wa $a:J $u:J.u;
        
        
        # 7
        J.s = Rw maka $a:J $u;
        
        
        # 8
        
        # 9
        a.Jiter.bz->(J.r => J.s,    '%gp' => $J,    @{J.etc});
        

