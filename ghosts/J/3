R_Jz:

 - K: hiJ #c
   D: |
     my $r;
     r.name = shift @$m;
     r.name .=  "-J".G.jumb.Jnumb++; # additively, paranoid
     r.style = [@$m];
     
     my $J = Rw makeJ $r;
     
     Rw Jup $J;
     
     waylay mux(u=>$J);
     
     $J
 - K: makeJ #c
   D: |
      my $r = ar.r || $ar;
      my $u = {K=>'J',%$r}; 
      u.name ||= "J".G.jumb.Jnumb++; # additively
      my $q = 1;
      my $J = w G.R fuu[$u, $q];
      
      sayyl "made ++ ".$J->pi;
      $J
 - K: Jup #c
   D: |
     my $style = J.style;
     J.yt = {};
     my @style = map {
         saygr "J.name seeking $_...";
         my $pin = "$_/styJup";
         Rw suck + $pin;
        } @$style;
     
     J.yt->{$_} ||= 1 for @style;
     saygr "J.name styJupd: @style";
       
     "J".G.jumb.Jnumb++; # additively
 - K: tent #c pearlesque kings of the
   D: |
     my $na = shift @$m;
     my $name = J.name.'-'.$na;
     my $conJ = Rw makeJ $name;
     $J->{$na} = $conJ;
     conJ.A->umk($J, 'tent');
     conJ.Jmost = J.Jmost || $J;
     $conJ;
 - K: conroll #c rolling con tents, the C Js, away into shadow
   D: |
     my @con = map{_.i} @{J.A.n_tent||[]};
     @con = grep { $_ ne J.on } @con;

     unshift @con, $J;
     
     @con = grep { keys %{_.bb} } @con;
     return saygr "Fresh Con" if !@con;
     
     say "Scraping out ".$J->pi."   tents ".join ", ",
         map { _.name =~ /^(J.name\-)?(.+)$/; $2 } @con;
     
     sayre "Jmost bb goners: ".join " ", grep { s/\t(.+?)$// || 1 } 
         sort grep {!/\%/} keys %{J.bb};

     for my $tent (@con) {
         #say "Scraping out the ".$tent->pi;
         Rw setup $J:tent;
     }
 - K: JL #c make L bracket # rename Joint
   D: |
      my $u = {K=>'L',%{ar.r || {}}}; 
      u.name ||= "L:J.name:".G.jumb.Lnumb++; # additively
      my $q = 1;
      my $L = w G.R fuu[$u, $q];
      sayyl "made ++ ".$L->pi;
      $L


 - K: oven #c
   D: |
     J.L ||= Rw JL $J;
     
     sayyl "OVENATING";
     
     w mux(u=>J.L);
     
     for my $k (grep {/^J/} keys %$ar) {
         my $JJ = $ar->{$k};
         JJ.A->umk(J.L => 'S');
         # does that tidy^ TODO
         w mux(u=>$JJ);
     }
     

