R_Jz:

 - K: jin #c replace namedo 
   D: |
     my $name = $m->[0];
     my $n = Rw Jung;
     w G.R del(u=>$_) for $n->{$name};
     Rw hiJ +;
 - K: Jun #c Jung with name, or not
   D: |
     my $n = Rw Jung;
     my $name = shift @$m;
     return $n->{$name};
 - K: onJ #c replace namedo 
   D: |
     my $name = $m->[0];
     my $n = Rw Jung;
     $n->{$name} ||
     Rw hiJ +;
 - K: hiJ #c
   D: |
     my $r;
     r.name = shift @$m;
     r.name .=  "-J".G.jumb.Jnumb++; # additively, paranoid
     r.style = [@$m];
     
     my $J = Rw makeJ $r;
     
     Rw Jup $J;
     
     waylay mux(u=>$J);
     
     $J
 - K: Jup #c
   D: |
     my $style = J.style;
     J.yt = {};
     my @style = map {
         saygr "J.name seeking $_...";
         my $pin = "$_/yJup";
         Rw suck + $pin;
        } @$style;
     
     J.yt->{$_} ||= 1 for @style;
     saygr "J.name yJup: @style";
 - K: makeJ #c
   D: |
      my $r = ar.r || $ar; # pass through q, passes out the madeness
      my $u = {K=>'J',%$r}; 
      u.name ||= "J".G.jumb.Jnumb++; # additively
      
      my $r = {q=>1};
      my $J = w G.R fuu[$u, $r];
      # ^ has flows_D to suJ, only first time
      
      my $wa = r.new?" made + + ":" - J - ";
      sayyl $wa.$J->pi;
      $J
 - K: tent #c pearlesque kings of the
   D: |
     my $na = shift @$m;
     
     my $name = J.name.'-'.$na;
     
     my $conJ = Rw makeJ $name;
     
     $J->{$na} = $conJ;
     conJ.A->umk($J, 'tent');
     conJ.Jmost = J.Jmost || $J;
     #say "Tent of ".$conJ->pi."  ".join"    ",map{_.point}@F[2,4,6,8]; 
     $conJ;
 - K: Jung #c
   D: |
     my @aw = K J;
     @aw = grep { !_.A.u_tent } @aw;
     my $na;
     map {
         my $name = $1 if _.name =~ /(^\w+)-J\d+$/ || die;
        $na->{$name} && die "rep of $name";
        $na->{$name} = $_;
     } @aw;
     $na
        
     
 - K: conroll #c rolling con tents, the C Js, away into shadow TIME
   D: |
     my @con = map{_.i} @{J.A.n_tent||[]};
     @con = grep { $_ ne J.on } @con;
     
     unshift @con, $J;
     
     @con = grep { keys %{_.bb} } @con;
     return if !@con;
     
     say "conrolling ".$J->pi."   tents ".join "    ",
         map { _.name =~ /^(J.name\-)?(.+)$/; "$2 * ".
         do {
             my @log = sort keys %{_.bb};
            @log > 5 ? scalar(@log)
            : join "'", @log;
         };
         } @con;
     
     # dont mention mods? sum mods?
     #sayre "Jmost bb goners: ".join " ", grep { s/\t(.+?)$// || 1 } 
     #    sort grep {!/\%/} keys %{J.bb};

     for my $tent (@con) {
         #say "Scraping out the ".$tent->pi;
         Rw suJ $J:tent;
     }
 - K: inness #cc soy packets everywhere # THINGNESS as onness
   D: |
      # right handed receiver of 8, informs to humm etc.
      # would involve many uish and the types of perception we want to see
      # laying out the plane of attack
      # just has to find a corner of it as 3
      J.on = Rw tent on;
      # ^ recursor... incubator
      # v def
      my $o = J.onei ||= {i=>$G};
      
      my $r = ar.r;
      
      w mux(u=>$J) if $r; # slower reintro - calc entropy
      
      # ^ inject 6
      # but first...
      # t distributable, listy compressible pass space
      
      %$o = (i => r.i) if r.i;
      o.t||=[];
      
      if (ref r.t eq 'ARRAY') {
          o.t = [@{r.t}];
      }
      else {
          push @{o.t}, r.t if r.t;
      }
      
      # get there
      my $i = o.i;
      for my $t (@{o.t}) {
          sayyl "   -trav $i       $t";
          $i = $R->suets($i, $t);
      }
      sayyl "Inness: ".gp(o.i)."     "
        .join("   ", @{o.t})." ----> ".gp $i
            if $i ne o.i;

      # on ventrickles already, look at the path for clues
      # if last t was {bb 55 stylse
      # the tree of loveliness to hook in as things fly by again soon...
      
      # like J.yy.inness.wants to fold back all the uninteresting stuff
      # also show the groups of phases etc
      # styles from on become humming/rounding protocols
      # 
      
      J.on.bz->("u%travely\t".0.1 => J.onei);
      J.on.bz->("u\t".0.1 => $i);
      
 - K: bacup #c SCHEMA
   D: |
       my $ss_Ds = R.S.ss_Ds = Load(<<'');
                 n: |
                    n.HASH = {};
                 Ai: |
                    Ai.A = {};
                 Gi: |
                    my $likes = {map{$_=>1}qw{G ways}};
                    Gi.HASH = {
                     it => sub {
                       my $h = shift;
                       my @r = map { { K=>$_, k=>"{".$_, v=>$h->{$_} } } sort keys %$h
                     },
                    };
       
       for my $k (sort keys %$ss_Ds) { # or K array who knows
           my $u = R.S.ss->{$k} = w $R dus;
           my $D = $ss_Ds->{$k};
           $G->D({bab=>$D, ar=>{$k=>$u}});
       }
       
 - K: down #c TODO to have maintained down by what comes up from 7 via 8 in motion, tune in values
   D: |
       my $ordy = Load(<<'');
       {A: 13, id: 11, K: 17, name: 185,
       G: 14, R: 15, B: 23, more: 543,
       surf: 8,
       theJ: 23, theM: 28
       }
       
       my $ydro = {};
       push @{$ydro->{$_}||=[]}, $_ for keys %$ordy;
       my @order = map { @{$ydro->{$_}} } sort keys %$ydro;
       
       { order => \@order,
            ordy => $ordy,
       }
 - K: hamz #c
   D: |
      my $b = shift @$m;
      my $as;
      $b eq 'style' ? do {
          $as = {K=>$b, B=>{am=>shift @$m}};
        die if @$m;
      } :
      do {
          die "unknown $b     @$m ";
      };
      w G.R fuu(u=>$as);

