R_Jz:




 - K: hijack #c hit J
   D: |
      my $J = Rw hiJ below hull;
      ar.J = $J;
      Rw suck + */hijack;
      $J
 - K: event #c ITS COMING BACK AROUND # care bout acJuatoring
   D: |
     my $id = e.id;
     sayyl "ID: $id";
     
     my $fro = J.gpa.pis->{$id} || return warn "non $id";#.wdump(2,J.gpa);
     # path must be somewhere around here...
     # on the gp's / which is inside yet outsideness, or the lev... whatev.
     # TODO look-around-for %whatever
     # way is a weird uri-ish string, like {key
     
     my ($the) = my @pathy = Rw uptopathway $lim:J $J:fro;
     die wdump(\@pathy) if @pathy != 1;
     my $t = the.s;
     
     # look for whole l ness
     Rw conty $t, $J3:J;
     
     waylay 3 mux(u=>$J);
     
 - K: uptopathway #c up from J until a %path, but not too far
   D: |
     my $i = 0;
     until ($J eq $lim) {
         my $Jit = J.Jiter;
         my $j = $R->shj(J.r, Jit.bb);
         my $ip = {l => j.l, style => 'path'};
         my @junk = Rw tvo $J:Jit $ip;
         return @junk if @junk;
         die if $i++ > 9;
         $J = $Jit;
     }
     
 - K: conty #c hit J bit, somethingsomething
   D: |
     my $J = J3.jointed;
     say "Finding ".$J->pi."\njoitnted from ".$J3->pi;
     
     my $J2 = Rw suck $J */hijack;
     
     say "Got new ".$J2->pi;
     J2.onei = {%{J3.onei}};
     J2.onei.t = [@{J2.onei.t}] if J2.onei.t;
     
     Rw inness $J:J2 $t;
 - K: tent #c pearlesque kings of the
   D: |
     my $na = shift @$m;
     my $name = J.name.'-'.$na;
     my $conJ = Rw makeJ $name;
     $J->{$na} = $conJ;
     conJ.A->umk($J, 'tent');
     conJ.Jmost = J.Jmost || $J;
     $conJ;
 - K: conroll #c rolling away into shadow effect caused by reiteration
   D: |
       my @con = map{_.i} @{J.A.n_tent||[]};
       @con = grep { $_ ne J.on } @con;
       
       my @names = map { _.name } @con;
       @names = map { s/^J.name//; $_ } @names;
       unshift @con, $J;
       
       say "Scraping out ".$J->pi."   tents ".join ", ", @names;
       sayre "Jmost bb goners: ".join " ", grep { s/\t(.+?)$// || 1 } 
         sort grep {!/\%/} keys %{J.bb};
       
       
       for my $tent (@con) {
           #say "Scraping out the ".$tent->pi;
           Rw setup $J:tent;
       }
 - K: thesurf #c CURVE curver
   n_D:
     curves: |
         #["spun 0" => 0.025],
         ["curve 0" => -0.211],
         ["zoom 0" => 0.15],
         ["zoom 0.21" => -0.04],
         ["curve 0.3" => 0.11],
         
         ["curve 0.712" => -0.05],
     mods: |
       [sq   => 10,  '~'],
       #[sqat   => 20,  '^', {}, 'color:blue', in => 10, ],
       #[sqat   => 20,  'v', {}, 'color:blue', out => 10, ],
 - K: hull #c whole screen iraga
   n_D:
     styJup: |
       'hull',
     curves: |
         ["spun 0" => 0.12],
         ["curve 0" => 0.09],
         ["zoom 0" => 0.2],
     mods: |
       [sqw   => 10,  '~', {}, 'font-size:200%;'],
       [sq   => 20,  '@', {}],
     pathy: |
       
     hijack: |
       die if J.joitne > 9;
       my $jn = "J".(9 - J.joitne);
       J.joitne++ for 1..3;
       
       my $J2 = Rw hiJ bollox sur;
       
       $ar = {J=>$J, $jn=>$J2};
       Rw fitin +;
       
       J2.jointed = $J;
       $J2;
 - K: fitin #c
   D: |
     my @so = sort grep {/^J.+/} keys %$ar;
     my $J = ar.J;
     for (sort keys %$ar) {
         /^J(\d+)$/ || next;
         my $cvb = $1;
         my $Jo = $ar->{$_};
         J.bz->(Jo.name."\t"."0.".$cvb => '>:D', '%Joint' => $Jo);
     }
     Rw jtrbg $J;
     Rw Joints $J;
 - K: Joints #c
   D: |
     my @things = Rw tvy $J;
     for my $thing (@things) {
         my ($tj, @sjs) = @$thing;
         if (my ($Joi) = grep{_.style eq 'Joint'} @sjs) {
             my @jcss = grep{_.style eq 'css' && _.com =~ /^pha/} @sjs;
             my $J2 = $Joi->{s};
             
             Rw oven $J $J2;
             # J2 now disposed to a part of J, all within L
             
             
             my ($Z, $N);
             for my $N (map { _.s } @jcss) {
                 $Z->{$_} = $N->{$_} for keys %$N;
             }
             saybl " hoping ".$J2->pi." istyle:".wdump($Z);
             
             if ($Z->{'-webkit-transform'} =~ /rotate\((.+?)rad\)/) {
                 $Z->{'-webkit-transform'} = 'rotate('.($1 + -$RADIAN).'rad)',
             }
             
             
             my $beef = J2.S.Z;
             Z.width = '100%';
             Z.height = '100%';
             Z.border = '2px solid rgba(0,0,0,0.3)';
             J2.S.Z = $Z;
             say "YES". wdump 2,[tj.r, $beef, map { "   _.r" } @jcss];
         }
     }
 - K: oven #c
   D: |
     J.L ||= Rw JL $J;
     
     sayyl "OVENATING";
     
     w mux(u=>J.L);
     for my $k (grep {/^J/} keys %$ar) {
         my $JJ = $ar->{$k};
         JJ.A->umk(J.L => 'S');
         # does that tidy^ TODO
         w mux(u=>$JJ);
     }
     

