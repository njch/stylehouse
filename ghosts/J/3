R_Jz:



 - K: howge #c
   D: |
     J.geo = w $R makeJ(name=>J.name.'-geo');
     J.geo.bz->(@$_) for
     Rw suck */curves,
     # 2.9
     ;
     
 - K: geolo #c begin digging - smiling egg cup - most reentrant part
     # set up archeology site, anything you want
   D: |
     my $Jeo = J.geo; # woo
     sayyl '.' for 1..5;
     
     for my $j (do{ grep { !_.style } w $R tvo(J=>J.geo); }) {
         saybl "               ^^^^ yep j.cv j.t          j.s ";
         
         J.geo.bz->("b%tr\t".j.cv => {
             %{J.geo.bb->{"b%tr\t".j.cv} || {}}, # compile trs
            j.t => j.s,
         });
     }
     
     for my $pcv (map{$_ * 0.1} 1..9) {
         my $w = "b%tr\t".$pcv;
         J.geo.bz->($w => {}) if !J.geo.bb->{$w};
         # extra stick pole, sparsitor to trace by, blank as tr(ansf)
     }
     
     # and lay out
     my $last = {x=>0, y=>0, cv=>0.001, rad=>$RADIAN, spin=>0}; # downy
     for my $j (do{ grep { _.style eq 'tr' } w $R tvo(J=>J.geo); }) {
         sayyl "       <<<< yep j.cv j.t          ".ki j.s;
         
         my $here = {};
         here.cv = j.cv;
         
         here.spin = j.s.curve if exists j.s.curve; # on the level
         
         here.rad = 4*$RADIAN * j.s.spun if exists j.s.spun;
         
         here.zoom = 4*$RADIAN * j.s.zoom if defined j.s.zoom;
         here.zoom = undef if exists j.s.zoom && !defined j.s.zoom;
         
         here.creatin = j.s;#$H->ejson(j.s);
         
         w $R atom[$j, $here, $last];
         
         J.geo.bz->("b%ve\t".j.cv => $here);
         $last = $here;
     }
     # etc
 - K: geoves #c dpaw
   D: |
     J.yy.gemod = [
     # 3.2
     Rw suck */mods,
     # 3.3
     ];
     for my $d (@{J.yy.gemod}) {
          $d || next;
          w $R mod[$J, $d];
     }
     # 4
     # 5
     # 6
     Rw suck */geolmo,

