R_Jz:
 - K: event #c ITS COMING BACK AROUND # care bout acJuatoring
   D: |
     saybl "_---------------________------____________------------";
     sayyl "ID: e.id";
     
     my ($J2, $j); # the deepest findable ab
     if (my $ju = J.idly->{e.id}) {
         $J2 = ju.J;
         $j = ju.j;
     }
     
     saybl "  /        ".gp(J.jointed); # the J above
     saybl " J      |- ".gp($J); # the J ux we evented, modulator tip
     saybl "    J2 ... ".gp($J2); # gp or so, sometimes
     saybl "        j@ ".j.r if $j; # the bit of line, something%idly etc. line has %path or something interesting
     
     if (e.rval) {
         sayyl "Wants to e.rval!";
         sleep 1;
     }
     
     die if !$J2 && $j;
     
     # ex clues about pathways
     $J2 ||= $J;
     
     my $pa = {};
     Rw upath $J $J2 $j $pa;
     
     Rw contier + $J $J2 $j $pa;
      # auth between ^ v
      
     waylay mux(u=>$J);
 - K: contier #c
   D: |
     return if Rw eventkeygrab/grab;
     
     my $y = pa.pathy;
     say "y pathy is $y";
     if ($y =~ /^!(.+?)(?::(.+))?$/) {
         my $m = [split /(?!^) /, $2];
         say " ! contig $1 -> @$m";
         Rw $1 + $m;
     }
     elsif ($y) {
         say " CONTIER with no y ..." if !$y;
         Rw suck + */conty $y;
     }
     
 - K: upath #c find %path or so between J and J2, a subj, FUZZ
   D: | # it's making spirals of looking for things to jump forward with
     if ($j) {
        sayre "You came on an ID no longer there... "
            .gp($j)."\n".gp($J2) if !exists J2.bb->{j.r};
        #say " j.r    exists in ".gp($J2);
        
        # J(ux) <- <- J2 ) j
        
        # idyly to l
        my $r = {};
        my @path = Rw ship $J:J2 $l:j.l $r path;
        
        say "      o / n   ".gp($J2)." from j.r    ".join" ", map{_.t} @{r.junk};
         
        die wdump \@path if @path > 1;
        
        sayyl _.r for @path;
        
        my ($pj) = @path;
        if (defined $pj) {
            push @{pa.paths||=[]}, $pj;
            say "     upath   >>>>>>> pj.s <<<<<< ";
            if (pa.pathy) {
                sayre  "     extra path above: pj.s  " for 1..3;
            }
            
            pa.pathy = pj.s;
        }
     }
     # try to J3 (up) until its J1 and we have the neighbourhood
     if (my $J3 = J2.Jiter) {
         J2.r || die;
         my $nj = Rw shj $r:J2.r $J:J3;
         
         Rw upath $pa $J $J2:J3 $j:nj;
     }
     # probly wanna start on the random little thing
     
 - K: recoded_init #c       BIZ  one with g, the boat we code from
   D: | 
     Rw suck */recoded_init;
     
     my @wt = keys %{H.G.lastGd};
     my $knowb = {qw{
         W/9 ps
         W/3 hull
         W/4 ash
         W/1 ollox
     }};
     for (@wt) {
     #next;
         my $wu = $1 if /ghosts\/(.+)$/;
         my $wh = $knowb->{$wu} ||                 "oats";
         saybl "recoded_init Wu: $wu -> $wh";
         if (H.name eq 'D') {
             $wh = 'ghosts';
             #sayre "Non ash on D, ig $wh";
             #undef $wh;
         }
         undef $wh if $wh eq 'ash' && H.name ne 'D';
         $wh || next;
         Rw Jix $name:wh; 
     }
     
     my $n = Rw Jung;
     my (@em) = Rw figure_lux;
     for my $n (@em) {
         saygr "    ".n.J->pi ."       \t n.lux"; 
     }
     return; # add ^ to v
     
     my $J = n.oot || n.ollox || return sayre "aloooooooooooooooone"; 
     Rwyl 1 splat $J;
      
 - K: figure_lux #c log churn brings lux phase yoming
   D: |
     my $n = Rw Jung;
     # collect J.biz.onei etc
     my $now = $H->hitime;
     my @mago = map {
        my $J = $n->{$_};
        # 4
        my $lux = $now;
        $lux -= (J.ent.ti || $now);
        $lux *= J.ent.lux if J.ent.lux;
        # 5
         { J=>$J, lux=>$lux }
     } sort keys %$n;
     
     # 7
     my @tago = sort { a.lux <=> b.lux } @mago;
     # 9
     @tago;
 - K: fresh_init #c 
   D: |
     Rw suck */fresh_init;
  
 - K: any_init #c 
   D: |
     Rw suck */any_init;
  
 - K: splat #c it wands out
   D: |
     waylay mux(u=>$J);
 - K: eventkeygrab #c hack in some basic doings
   n_D:
     grab: |
       return 0 unless e.type =~ /^key/;
       my $k = e.k;
       my @try = (e.k, 'w'.e.which);
       my $g = R.way->find('eventkeygrab');
       for my $k (@try) {
           next unless $g->{$k};
           Rw eventkeygrab/$k;
           sayyl "Served e.k";
           return 1;
       }
       return 0;
     w189: | # ½
       # inject J / fontsize --
     w187: | # »
       # inject J / fontsize ++
     H: |
       my $n = Rw Jung;
       n.oot
     G: |
       return if fork();
       sayre "".`figlet GIT`;
       # TODO forking pyramid isolator with error report
       `git gui`;
       exit;
     C: |
         H.G w reexec;
     J: |
         w jak;
     Y: |
         Rw occie/komp;

