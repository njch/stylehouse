R_Jz:
 - K: event #c ITS COMING BACK AROUND # care bout acJuatoring
   D: |
     saybl join("      ", (" JJJ ".$J->pi) x 7);
     sayyl "ID: e.id";
     
     return if Rw eventkeygrab/grab;
     
     my ($J2, $j); # the deepest findable ab
     if (my $ju = J.idly->{e.id}) {
         $J2 = ju.J;
         $j = ju.j;
     }
     
     saybl "HULL;  ".gp(J.jointed); # the J above
     saybl "FROM;  ".gp($J); # the J we evented
     saybl "sejnoi;  ".gp($J2); # gp or so, sometimes
     
     sayyl "\nWOOOO ".wdump(1,$j) if $j;
     
     if (e.rval) {
         sayyl "Wants to e.rval!";
         sleep 1;
     }

     # ex clues about pathways
     $J2 ||= $J;
     my $pa = Rw upath + $J $J2;
     
     Rw suck + */conty $pa $J2;
     
      # auth between ^ v
      
     waylay mux(u=>$J);
 - K: eventkeygrab #c hack in some basic doings
   n_D:
     grab: |
       return 0 unless e.type =~ /^key/;
       my $k = e.k;
       if (R.way.hooks.eventkeygrab->{$k}) {
           Rw eventkeygrab/$k;
           sayyl "Served e.k";
           return 1;
       }
       return 0;
     G: |
       return if fork();
       sayre `figlet GIT`;
       # TODO forking pyramid isolator with error report
       `git gui`;
       exit;
     C: |
         H.G w reexec;
     J: |
         w jak;
     Y: |
         Rw occie/komp;
 - K: upath #c find %path or so between J and J2, a subj, FUZZ
   D: | # it's making spirals of looking for things to jump forward with
     my $py = {Jr=>J.r||J.name, J2r=>J2.r||J2.name};
     
     sayyl "upthy: ".gp($J)."          <->   ".gp($J2);
     # probly wanna start on the random little thing
     
     my $Jo = $J2;
     while (1) { # lurch upwards towards the...
         sayre("topmost") && last if !Jo.Jiter;
         # see if this Jo thing has any styles above
         # .r was a phro/lev thing , blend J j
         my $j = Rw shj $r:Jo.r $J:Jo.Jiter;
         my $ip = {l => j.l};
         my @junk = Rw tvo $J:Jo.Jiter $ip;
         my (@path) = grep { _.style eq 'path' } @junk;
         sayyl "  ? ".gp(Jo.Jiter)."       path search: "
             .join" ", map{_.t} @junk;
         
         die @path if @path > 1;
         if (@path) {
            my ($path) = @path;
            if (!py.pathy) {
                py.pathy = path.s;
                say "pathy: path.s";
            }
            else {
                say "extra path above: path.s";
            }
            push @{py.paths||=[]}, @path;
         }
         last if $Jo eq $J; # complete
         $Jo = Jo.Jiter; # move up
     }
     return $py;
     
 - K: forkpi #c
   spesh: 0
   spesh_D: |
     H.name eq "O" || $DB::sub # perl -dw cannot fork # websockets cannot fork?
   babz:
        'gp 2.5': |
            if (J.cv > 0.2 && !J.replaceJid && !J.q) {
                my $la = {%$J};
                la.replaceJid = J.isJid; #$H->mkuid;
                my $lyt = G.jumb.forkpis ||= [];
                push @$lyt, $la;
                J.forking = $la;
                J.cv = 0.1;
            }
        'hiss 8.8': |
            if (my $pias = delete G.jumb.forkpis) {
                # these could be forked right away
                # if they can wait for the M muxing J if they reach O first
                $G->timer(0, sub {
                    Rw forkpi/pias $J $pias;
                });
            }
        'gp 7.1': |
            J.forking.wash = $H->dig(J.s) if J.forking;
        'hiss 2.88': |
            kill 'KILL', $_ for @{delete G.forkpi_tokill || []};
   n_D:
        pias: |
            if (my $pid = fork()) {
                my $Sftk = G.forkpi_tokill ||= [];
                push @$Sftk, $pid;
                return
            }
            H.db = H.pg->db;
            H.isforked = 1;
            # child must exit, after reporting error
            # so nothing else can happen. listening db handle gone anyway?
            my $bail = sub{ exit };
            $G->accum($G0, _aft_err_do => $bail);
            $G->accum($F[0], _aft_etc_do => $bail);
            
            sayyl "pier Forked... ";
            
            my @js;
            my $group = 3;
            for my $a (@$pias) {
                a.replaceJid || do {
                    warn "Jid missing... ". gp($a)
                    ."\n".gp(a.u)."\nJiter: ".gp a.Jiter;
                    next;
                };
                Rw gp $J:a;
                my $html = a.s;
                next if a.wash eq $H->dig($html);
                my $set = $H->ejson($html);
                my $id = a.replaceJid || die wdump(2,$a);
                my $js = qq{ \$('#$id').replaceWith($set);};
                push @js, $js;
                if (@js >= $group) {
                    $H->send(join('', @js));
                    @js = ();
                }
            }
            $H->send(join '', @js) if @js;
            saygr "pier done ".F_delta;
            

