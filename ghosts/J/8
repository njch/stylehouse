R_Jz:
 - K: event #c ITS COMING BACK AROUND # care bout acJuatoring
   D: |
     saybl (join("      ", (" JJJ ".$J->pi) x 7)) x 3;
     sayyl "ID: e.id";
     
     if (e.type =~ /^key/) {
          my $dont = 0;
          for (e.k) {
              when ('G') {
                  return if fork();
                  sayre `figlet GIT`;
                  # TODO forking pyramid isolator with error report
                  `git gui`;
                  exit;
              }
              when ('C') {
                  H.G w reexec;
              }
              when ('J') {
                  w jak;
              }
              default { $dont = 1}
          }
          return sayyl "Served e.k" if !$dont;
     }
     
     my $J2 = J.gpa.pis->{e.id};

     saybl "HULL;  ".gp(J.jointed); # the J above
     saybl "FROM;  ".gp($J); # the J we evented
     saybl "sejnoi;  ".gp($J2); # gp or so, sometimes

     # ex clues about pathways
     my $pa = Rw upath + $J $J2;
     
     Rw suck + */conty $pa $J2;
     
      # auth between ^ v
      
     waylay 0.3 mux(u=>$J);
      
 - K: upath #c find %path or so between J and J2, a subj, FUZZ
   D: | # it's making spirals of looking for things to jump forward with
     my $py = {Jr=>J.r||J.name, J2r=>J2.r||J2.name};
     
     sayyl "upthy: ".gp($J)."          <->   ".gp($J2);
     # probly wanna start on the random little thing
     
     my $Jo = $J2;
     while (1) { # lurch upwards towards the...
         saybl "  ? ".gp(Jo.Jiter);
         saybl "has: Jo.r";
         sayre("hno Jitter") && last if !Jo.Jiter;
         # see if this Jo thing has any styles above
         # .r was a phro/lev thing , blend J j
         my $j = Rw shj $r:Jo.r $J:Jo.Jiter;
         my $ip = {l => j.l};
         my @junk = Rw tvo $J:Jo.Jiter $ip;
         my (@path) = grep { _.style eq 'path' } @junk;
         sayyl "lolking through ".join" ", map{_.t} @junk;
         
         die @path if @path > 1;
         unless (@path) {
             sayre "nothing in...";
         }
         else {
            my ($path) = @path;
            py.pathy = path.s;
            push @{py.paths||=[]}, \@junk;
         }
         last if $Jo eq $J; # complete
         $Jo = Jo.Jiter; # move up
     }
     return $py;
     
 - K: Jolt #c JjJj how to J -> j, sproutlinger
   D: |
     # balance follicles
     die if J.joitne > 9;
     my $n = J.joitne;
     J.joitne++ for 1..2;
     
     my $J2 = Rw hiJ $m;

     Rw fitin $J $n $J2;

     J2.jointed = $J;
     $J2;
 - K: fitin #c like push onto the %Joints centipede, which cons
   D: |
     J.bz->(J2.name."\t"."0.".$n => '>:D', '%Joint' => $J2);
     Rw jtrbg $J;
     Rw Joints $J;
 - K: Joints #c
   D: |
     my @things = Rw tvy $J;
     for my $ths (@things) {
         my ($th, @sjs) = @$ths;
         say "y hello ".wdump(1,$ths) if th.l ne th.t;
         
         if (my ($Joi) = grep{_.style eq 'Joint'} @sjs) {
             my @jcss = grep{_.style eq 'css' && _.com =~ /^pha/} @sjs;
             my $J2 = $Joi->{s};
             
             Rw oven $J $J2;
             # J2 now disposed to a part of J, all within L
             
             
             my ($Z, $N);
             for my $N (map { _.s } @jcss) {
                 $Z->{$_} = $N->{$_} for keys %$N;
             }
             sayyl " hoping ".$J2->pi." istyle:".wdump($Z);
             
             if ($Z->{'-webkit-transform'} =~ /rotate\((.+?)rad\)/) {
                 $Z->{'-webkit-transform'} = 'rotate('.($1 + 0).'rad)',
             }
             
             
             my $beef = J2.S.Z;
             my $off = 77;
             Z.width = $off.'%';
             Z.height = $off.'%';
             #Z.border = '2px solid rgba(0,0,0,0.3)';
             J2.S.Z = $Z;
             #say "YESSSSS". wdump 2,[tj.r, $beef, map { "   _.r" } @jcss];
         }
     }
 - K: forkpi #c
   spesh: 1
   spesh_D: |
     H.name eq "O" || $DB::sub # perl -dw cannot fork # websockets cannot fork?
   babz:
        'gp#fork_layert 5.6': | 
            if (a.cv > 0.2 && !a.replaceJid && !a.q && $wa ne 'text') {
                my $la = {%$a};
                la.replaceJid = a.isJid; #$H->mkuid;
                my $lyt = R.lastS.layert ||= [];
                push @$lyt, $la;
                a.forking = $la;
                a.cv = 0.1;
            }
        'S#waylayert_pias 8.8': |
            if (my $pias = delete S.layert) {
                # my $it = natatime 5, @$pias;
                # TODO they come back out of order of attachment 
                # fork only the top level pi, not pi within pi?
                $G->timer(0, sub {
                    w $R forkpi/pias[$S, $pias];
                });
            }
        'gp 6.2': |
            R.lastS.a.pis->{a.isJid} = $a; # TODO J pass over # maka suction
        'gp 7.1': |
            a.forking.wash = $H->dig($html) if a.forking;
        'S#tidy 0.113': |
            if (my $tokill = delete S.forkpi_tokill) {
                kill 'KILL', $_ for @$tokill;
            }
   n_D:
        pias: |
            if (my $pid = fork()) {
                my $Sftk = S.forkpi_tokill ||= [];
                push @$Sftk, $pid;
                return
            }
            H.db = H.pg->db;
            H.isforked = 1;
            # child must exit, after reporting error
            # so nothing else can happen. listening db handle gone anyway?
            my $bail = sub{ exit };
            $G->accum($G0, _aft_err_do => $bail);
            $G->accum($F[0], _aft_etc_do => $bail);
            
            sayyl "pier Forked... ";
            
            my @js;
            my $group = 3;
            for my $a (@$pias) {
                my $html = w $R gp[$a];
                next if a.wash eq $H->dig($html);
                my $set = $H->ejson($html);
                my $id = a.replaceJid || die;
                my $js = qq{ \$('#$id').replaceWith($set);};
                push @js, $js;
                if (@js >= $group) {
                    $H->send(join('', @js));
                    @js = ();
                }
            }
            $H->send(join '', @js) if @js;
            saygr "pier done ".F_delta;
            

