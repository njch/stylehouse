R_Jz:
 - K: event #c the join # ITS COMING BACK AROUND # care bout acJuatoring
   D: |
     # J == join/ww, moves to ux
     saybl "_---------------________------____________------------";
     sayyl ki($e)."              SSSSSSSSSSSSSSSS";
     
     my $J = G.oin.idJy->{e.ux};
     
     #die "found J.name              ".ki $e;

     my $J2;
     my $j;
     if (my $ju = J.idly->{e.id}) {
         $J2 = ju.J;
         $j = ju.j;
     }
     
     saybl "  /        ".gp(J.jointed); # the J above
     saybl " J      |- ".gp($J); # the J ux we evented, modulator tip
     saybl "    J2 ... ".gp($J2); # gp or so, sometimes
     saybl "        j@ ".j.r if $j; # the bit of line, something%idly etc. line has %path or something interesting
     
     if (e.rval) {
         sayyl "Wants to e.rval!";
         sleep 1;
     }
     
     die if !$J2 && $j;
     
     # ex clues about pathways
     $J2 ||= $J;
     
     my $pa = {};
     Rw upath $J $J2 $j $pa;
     
     my $upi={};
     Rw contier + $J $J2 $j $pa $upi;
      # auth between ^ v
     
     upi.i ||
     Rw around $J;
     # ambient J up if else
 - K: contier #c
   D: |
     return if Rw eventkeygrab/grab;
     
     my $y = pa.pathy;
     say "y pathy is $y";
     if ($y =~ /^!(.+?)(?::(.+))?$/) {
         my $m = [split /(?!^) /, $2];
         say " ! contig $1 -> @$m";
         upi.i = 1;
         if (my $par = pa.pwar) {
             $ar->{$_} ||= $par->{$_} for keys %$par;
         }
         Rw $1 + $m;
     }
     elsif ($y) {
         say " CONTIER with no y ..." if !$y;
         Rw suck + */conty $y;
     }
     
 - K: upath #c FUZZ bend inside outside
   D: | # it's making spirals of looking for things to jump forward with
     if ($j) {
        sayre "You came on an ID no longer there... "
            .gp($j)."\n".gp($J2) if !exists J2.bb->{j.r};
            
            
        my ($path, $pwar) = Rw ship $J:J2 $l:j.l path pwar;
        #say "on j.r    ". wdump [$path, $pwar];
        die wdump $path if @$path > 1;
         
        
        my ($par) = @$pwar;
        if ($par) {
            pa.pwar ||= par.s;
            saybl "\n     upath/pwar   >>>>>> ".ki(pa.pwar)."\n";
        }
        my ($pj) = @$path;
        if (defined $pj) {
            push @{pa.paths||=[]}, $pj;
            saybl "\n     upath   >>>>>>> pj.s <<<<<< \n";
            if (pa.pathy) {
                sayre  "     extra path above: pj.s  " for 1..3;
            }
            else {
                pa.pathy = pj.s;
            }
        }
     }
     # try to J3 (up) until its J1 and we have the neighbourhood
     if (my $J3 = J2.Jiter) {
         J2.r || die;
         my $nj = Rw shj $r:J2.r $J:J3;
         
         Rw upath $pa $J $J2:J3 $j:nj;
     }
     # probly wanna start on the random little thing
     
 - K: recoded_init #c wake up
   D: |
     Rw suck */recoded_init;
     
     my @wt = keys %{H.G.lastGd};
     my $knowb = {qw{
         W/9 ps
         W/3 hull
         W/4 ash
         W/1 ollox
     }};
     for (@wt) {
     #next;
         my $wu = $1 if /ghosts\/(.+)$/;
         my $wh = $knowb->{$wu} ||                 "wam";
         saybl "recoded_init Wu: $wu -> $wh";
         if (H.name eq 'D') {
             $wh = 'ghosts';
             #sayre "Non ash on D, ig $wh";
             #undef $wh;
         }
         undef $wh if $wh eq 'ash' && H.name ne 'D';
         $wh || next;
         Rw J5 $name:wh; 
     }
     
     my (@em) = Rw figure_lux;
 - K: figure_lux #c log churn brings lux phase yoming, flow control & expression
   D: |
     my $n = Rw Jung;
     # collect J.biz.onei etc
     my $now = $H->hitime;
     my @mago = map {
        my $J = $n->{$_};
        # 4
        my $lux = $now;
        $lux -= (J.ent.ti || $now);
        $lux *= J.ent.lux if J.ent.lux;
        # 5
         { J=>$J, lux=>$lux }
     } sort keys %$n;
     
     # 7
     my @tago = sort { a.lux <=> b.lux } @mago;
     # 9
     @tago;
 - K: fresh_init #c 
   D: |
     Rw suck */fresh_init;
  
 - K: any_init #c 
   D: |
     Rw suck */any_init;
  
 - K: eventkeygrab #c hack in some basic doings
   n_D:
     grab: |
       return 0 unless e.type =~ /^key/;
       my $k = e.k;
       my @try = (e.k, 'w'.e.which);
       my $g = R.way->find('eventkeygrab');
       for my $k (@try) {
           next unless $g->{$k};
           Rw eventkeygrab/$k;
           sayyl "Served e.k";
           return 1;
       }
       return 0;
     w189: | # ½
       # inject J / fontsize --
     w187: | # »
       # inject J / fontsize ++
     H: |
       my $n = Rw Jung;
       n.oot
     G: |
       return if fork();
       sayre "".`figlet GIT`;
       # TODO forking pyramid isolator with error report
       `git gui`;
       exit;
     C: |
         H.G w reexec;
     J: |
         w jak;
     Y: |
         Rw occie/komp;

