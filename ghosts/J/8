R_Jz:

 - K: event #c the join # ITS COMING BACK AROUND # care bout acJuatoring
   D: |
     # J == join/ww, moves to ux
     saybl "_---------------________------____________------------";
     sayyl ki($e);
     my $wuJ = $J;
     sayyl "   W   ".gp($wuJ);
     
     my ($ww, $ux, @ids) = @{e.ids};
     wuJ.id eq $ww || die "noww: $ww wuJ.id";
     my $J = G.oin.idJy->{$ux} || die "noJ...";
     
     saybl "J    ". gp ($J);
     e.J = $J;
     
     # deepest id
     my ($J2, $j);
     if (my $ju = J.idly->{e.id}) {
         $J2 = ju.J;
         $j = ju.j;
     }
     
     $J2 = $j if $J2 eq $J && $j;
     saybl " J2    ".gp($J2);
     saybl " j    ".gp($j);
     
     # and trace backwards
     my @up = $J2;
     push @up, $up[-1]->{Jiter} until !$up[-1]->{Jiter};
     unshift @up, $j if $j;
     push @up, $J if $up[-1] ne $J;

     # make heatmap
     my $tocs = {map{$_=>1}'path','pwar'};
     my @to;
     my $is = '';
     my $lh;
     for my $j (reverse @up) {
         # like c is ar or seome
         saybl "$is ".(j.name||j.r);
         
         if ($lh) {
             my $lv = Rw r_lv $r:j.r $J:lh;
             my $sc = {};
             for my $sj (values %{lv.sj}) {
                 next unless $tocs->{sj.style};
                 $sc->{sj.style} = sj.s;
             }
             if (%$sc) {
                 sayyl "$is has ".ki($sc)."    in lh.name";
                 # may want to J = lh ... pbl on other side of vector pooling
                 push @to, { J => $lh, J2 => $j, sc => $sc };
             }
         }
         $is .= '    ';
         $lh = $j;
     }
     die 'multo' if @to > 1;
     
     saybl "         j@ ".j.r if $j; # something interesting
     
     if (e.rval) {
         sayyl "Wants to e.rval!";
         sleep 1;
     }
     
     die if !$J2 && $j;
     
     return if e.type =~ /^key/ && Rw eventkeygrab/grab;
     
     my $upi={};
     for my $to (@to) {
     
         Rw contier + $J:to.J $J2:to.J2 $pa:to.sc $upi;
     }
     upi.i ||
     Rw in $J $J2 $e;
     # ambient J up elseness
 - K: contier #c 
   D: |
     my $y = pa.path;
     say " pa_path  $y";
     
     if ($y =~ /^!(.+?)(?::(.+))?$/) {
         my $m = [split /(?!^) /, $2];
         say " ! contig $1 -> @$m";
         upi.i = 1;
         if (my $par = pa.pwar) {
             $ar->{$_} ||= $par->{$_} for keys %$par;
         }
         Rw $1 + $m;
     }
     elsif ($y) {
         say " CONTIER with no y ..." if !$y;
         Rw suck + */conty $y;
     }
 - K: r_lv #c
   D: |
     my $jh = Rw shj $r $J;
     my $ip;
     ip.l = jh.l;
     ip.cv = jh.cv;
     my $vs = Rw tyv $J $ip;
     die "m,any ".wdump 2, $vs if @$vs > 1;
     my $lv = $vs->[0];

 - K: figure_lux #c log churn brings lux phase yoming, flow control & expression
   D: |
     my $n = Rw Jung;
     # collect J.biz.onei etc
     my $now = hitime;
     my @mago = map {
        my $J = $n->{$_};
        # 4
        my $lux = $now;
        $lux -= (J.ent.ti || $now);
        $lux *= J.ent.lux if J.ent.lux;
        # 5
         { J=>$J, lux=>$lux }
     } sort keys %$n;
     
     # 7
     my @tago = sort { a.lux <=> b.lux } @mago;
     # 9
     @tago;
 - K: eventkeygrab #c hack in some basic doings
   n_D:
     grab: |
       return 0 unless e.type =~ /^key/;
       my $k = e.k;
       my @try = (e.k, 'w'.e.which);
       for my $k (@try) {
           my @yep = Rw suck - eventkeygrab/$k;
           say wdump \@yep;
           
           sayyl "Served e.k";
           return 1 if @yep;
       }
       return 0;
     w189: | # ½
       # inject J / fontsize --
     w187: | # »
       # inject J / fontsize ++
     G: |
       return if fork();
       sayre "".`figlet GIT`;
       # TODO forking pyramid isolator with error report
       `git gui`;
       exit;
     C: |
         Rw reexec;
     Y: |
         Rw J5 occie;
 - K: ii/standingtext #c
   D: |
     # find standing waves, columns with something there all the way down
     Rw doc $m $d
 - K: doc #c dock swampdoctor, leaving
   D: |
     if (H.name eq 'D') {
        return "";
     }
     
     my $meta = {};
     meta.y = 'doc';
     meta.id = mkuid;
     meta.hol = H.ol;
     meta.hitime = hitime;
     
     my $or = {%$ar};
     or.G = gp $G;
     my $en = wdump($or);
     $en =~ s/^\s+//sgm;
     
     my $m = {};
     m.hol = H.ol;
     m.hitime = hitime;
     m.Fscrape = Rw Doc/Fscrape;
     my $k = m.Fscrape->[2]->{point};
     
     my $f = $F[0];
     m.ar = join',',sort keys %{f.ar};
     m.en = $en;
     
     
      $G->tai("meta.y/meta.id\.c", $m);

      my $tinymeta = {map{$_=>$meta->{$_}}qw{id y}};
      # tas many, eg W/this   and it all joints up
      $G->tas("meta.y", $tinymeta);
     
     # J up zee, store in G.swamp here
     # spurt swamp zip & cargo
     # someone asks this Hid (sleep mode)
     # availing benignities before and after the fact)
 - K: Doc/Fscrape #c to drag tthrough pipe
   D: |
     my @fs;
     my @iF = @F;
     shift @iF for 1..2;
     for my $F (@iF) {
         my $f;
         f.K = F.K;
         f.point = F.point;
         if (!@fs) {
             G.doc.Fknow->{F.id} = $F;
         }
         f.id = F.id if G.doc.Fknow->{F.id};
         f.id ||= '?'; # tracable from near id
         f.intr = {map{$_=>gp(F.intr->{$_})}keys %{F.intr}} if F.intr;
         
         push @fs, $f;
     }
     \@fs
 - K: Doc/exit #c listen to swamp
   D: |
     my $y = 'doc';
     my $l = sub {
         sayyl "DOC         slwing $y =>  :::: $_[0]";
         my $m = shift;
         Rw Doc/exity $J $m;
     };
     $G->ily($y, $l);
       
 - K: Doc/exity #c have sucked the exiting
   D: |
     my $ci = djson $m;
     my $cc = $G->tri("ci.y/ci.id\.c");
     fixutf8($cc);
     my $cd = djson $cc;
     
     cd.en = eval "my \$VAR1; cd.en; \$VAR1";
     die $@ if $@;
     
     my $t = "ci.y/ci.id";
     J bz $t 0.1 $cd, '%ou'=>'fstat', '%ts'=>cd.hitime

