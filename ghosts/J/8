R_Jz:
 - K: event #c ITS COMING BACK AROUND # care bout acJuatoring
   D: |
     saybl (join("      ", (" JJJ ".$J->pi) x 7)) x 3;
     sayyl "ID: e.id";
     
     if (e.type =~ /^key/) {
          my $dont = 0;
          for (e.k) {
              when ('G') {
                  return if fork();
                  sayre `figlet GIT`;
                  # TODO forking pyramid isolator with error report
                  `git gui`;
                  exit;
              }
              when ('C') {
                  H.G w reexec;
              }
              when ('J') {
                  w jak;
              }
              default { $dont = 1}
          }
          return sayyl "Served e.k" if !$dont;
     }
     
     Rw suck + */conty;
     
      # auth between ^ v
      
     waylay 0.3 mux(u=>$J);
      
 - K: upath #c find %path or so between J and J2, a subj, FUZZ
   D: | # it's making spirals of looking for things to jump forward with
     my $py = {Jr=>J.r||J.name, J2r=>J2.r||J2.name};
     
     sayyl "upthy: ".gp($J)."          <->   ".gp($J2);
     # probly wanna start on the random little thing
     
     my $Jo = $J2;
     while (1) { # lurch upwards towards the...
         saybl "  ? ".gp(Jo.Jiter);
         saybl "has: Jo.r";
         sayre("hno Jitter") && last if !Jo.Jiter;
         # see if this Jo thing has any styles above
         # .r was a phro/lev thing , blend J j
         my $j = Rw shj $r:Jo.r $J:Jo.Jiter;
         my $ip = {l => j.l};
         my @junk = Rw tvo $J:Jo.Jiter $ip;
         my (@path) = grep { _.style eq 'path' } @junk;
         sayyl "lolking through ".join" ", map{_.t} @junk;
         
         die @path if @path > 1;
         unless (@path) {
             sayre "nothing in...";
         }
         else {
            my ($path) = @path;
            py.pathy = path.s;
            push @{py.paths||=[]}, \@junk;
         }
         last if $Jo eq $J; # complete
         $Jo = Jo.Jiter; # move up
     }
     return $py;
     
 - K: Jolt #c JjJj how to J -> j, sproutlinger
   D: |
     # balance follicles
     die if J.joitne > 9;
     my $n = J.joitne;
     J.joitne++ for 1..2;
     
     my $J2 = Rw hiJ $m;

     Rw fitin $J $n $J2;

     J2.jointed = $J;
     $J2;
 - K: fitin #c like push onto the %Joints centipede, which cons
   D: |
     J.bz->(J2.name."\t"."0.".$n => '>:D', '%Joint' => $J2);
     Rw jtrbg $J;
     Rw Joints $J;
 - K: Joints #c
   D: |
     my @things = Rw tvy $J;
     for my $ths (@things) {
         my ($th, @sjs) = @$ths;
         say "y hello ".wdump(1,$ths) if th.l ne th.t;
         
         if (my ($Joi) = grep{_.style eq 'Joint'} @sjs) {
             my @jcss = grep{_.style eq 'css' && _.com =~ /^pha/} @sjs;
             my $J2 = $Joi->{s};
             
             Rw oven $J $J2;
             # J2 now disposed to a part of J, all within L
             
             
             my ($Z, $N);
             for my $N (map { _.s } @jcss) {
                 $Z->{$_} = $N->{$_} for keys %$N;
             }
             sayyl " hoping ".$J2->pi." istyle:".wdump($Z);
             
             if ($Z->{'-webkit-transform'} =~ /rotate\((.+?)rad\)/) {
                 $Z->{'-webkit-transform'} = 'rotate('.($1 + 0).'rad)',
             }
             
             
             my $beef = J2.S.Z;
             my $off = 77;
             Z.width = $off.'%';
             Z.height = $off.'%';
             #Z.border = '2px solid rgba(0,0,0,0.3)';
             J2.S.Z = $Z;
             #say "YESSSSS". wdump 2,[tj.r, $beef, map { "   _.r" } @jcss];
         }
     }

