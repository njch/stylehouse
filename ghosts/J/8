R_Jz:
 - K: event #c ITS COMING BACK AROUND # care bout acJuatoring
   D: |
     saybl join("      ", (" JJJ ".$J->pi) x 7);
     sayyl "ID: e.id";
     
     return if Rw eventkeygrab/grab;
     
     my ($J2, $j); # the deepest findable ab
     if (my $ju = J.idly->{e.id}) {
         $J2 = ju.J;
         $j = ju.j;
     }
     
     saybl "HULL;  ".gp(J.jointed); # the J above
     saybl "FROM;  ".gp($J); # the J we evented
     saybl "sejnoi;  ".gp($J2); # gp or so, sometimes
     
     sayyl "\nWOOOO ".wdump(1,$j) if $j;
     
     if (e.rval) {
         sayyl "Wants to e.rval!";
         sleep 1;
     }
     
     die if !$J2 && $j;
     

     # ex clues about pathways
     $J2 ||= $J;
     
     my $pa = {};
     Rw upath $J $J2 $j $pa;
     
     Rw suck + */conty $pa $J2;
     
      # auth between ^ v
      
     waylay mux(u=>$J);
 - K: upath #c find %path or so between J and J2, a subj, FUZZ
   D: | # it's making spirals of looking for things to jump forward with
     if ($j) {
        !exists J2.bb->{j.r} ? die : say " j.r    does exist in ".$J2->pi;
        
        # J(ux) <- <- J2 ) j
        
        my $ip = {l => j.l};
        my @junk = Rw tvo $J:J2 $ip;
        # or so
        my (@path) = grep { _.style eq 'path' } @junk;
        
        sayyl "  ? ".gp($J2)."       path search: "
             .join" ", map{_.t} @junk;
         
        die @path if @path > 1;
        
        if (@path) {
            push @{pa.paths||=[]}, @path;
            my $pj = shift @path;
            if (pa.pathy) {
                sayre  "     extra path above: pj.s  " for 1..3;
            }
            pa.pathy ||= pj.s;
        }
     }
     
     if (my $J3 = J2.Jiter) {
         J2.r || die;
         my $nj = Rw shj $r:J2.r $J:J3;
         
         Rw upath $pa $J $J2:J3 $j:$nj;
     }
     # probly wanna start on the random little thing
     
 - K: recoded_init #c 
     # one with grest 
   D: |
     my $n = Rw Jung;
     my (@em) = Rw figure_busy;
     for my $n (@em) {
         saygr "    ".n.J->pi ."       \t n.sc";
     }
     
     my ($J) = map{_.J} @em;
     
     Rwyl 1 splat $J;
  
 - K: figure_busy #c log churn brings lux phase yoming
   D: |
     my $n = Rw Jung;
     # collect J.biz.onei etc
     my $now = $H->hitime;
     my @mago = map {
        my $J = $n->{$_};
        # 4
        my $lux = $now;
        $lux -= (J.ent.ti || $now);
        $lux *= J.ent.lux if J.ent.lux;
        # 5
         { J=>$J, lux=>$lux }
     } sort keys %$n;
     
     # 7
     my @tago = sort { a.lux <=> b.lux } @mago;
     # 9
     @tago;
 - K: fresh_init #c 
   D: |
     Rw suck */fresh_init;
  
 - K: any_init #c 
   D: |
     Rw suck */any_init;
  
 - K: splat #c it wands out
   D: |
     
     waylay mux(u=>$J);
 - K: eventkeygrab #c hack in some basic doings
   n_D:
     grab: |
       return 0 unless e.type =~ /^key/;
       my $k = e.k;
       if (R.way.hooks.eventkeygrab->{$k}) {
           Rw eventkeygrab/$k;
           sayyl "Served e.k";
           return 1;
       }
       return 0;
     H: |
       my $n = Rw Jung;
       n.oot
     G: |
       return if fork();
       sayre `figlet GIT`;
       # TODO forking pyramid isolator with error report
       `git gui`;
       exit;
     C: |
         H.G w reexec;
     J: |
         w jak;
     Y: |
         Rw occie/komp;

