R_Jz:
 - K: event #c ITS COMING BACK AROUND # care bout acJuatoring
   D: |
     my $id = e.id;
     
     saybl (join("      ", (" JJJ ".$J->pi) x 7)) x 3;
     sayyl "ID: $id";
     
     my $J2 = J.gpa.pis->{$id} || return warn "non $id";#.wdump(2,J.gpa);
     
     # the class etc bits of $e might clue in what to do
     # maybe can mousedown just x y?
     # J is the 1circle, J2 the 2circle
     # path must be somewhere around here...
     # on the gp's / which is inside yet outsideness, or the lev... whatev.
     # TODO look-around-for %whatever
     # way is a weird uri-ish string, like {key
     
     # there's a bunch of paths, there interesting
     my $pa = Rw upath + $J $J2;
     
     my $t = pa.pathy || die wdump(2,[nopathy=>$pa]);
     
     sayyl "goeth J2.r ========  $t";
     
     sayyl" Continuing";
     # look for whole l ness # eats HASH
     Rw conty $J $J2 $pa;
     
     waylay 3 mux(u=>$J);
     
 - K: conty #c hit J bit, dispatch somethingsomething, FUZZ
   D: |
     say `figlet conty pa.pathy`;
     say "Finding ".$J->pi."\njoitnted from ".gp($J2);
     
     Rw suck */hijack +;
 - K: upath #c find %path or so between J and J2, a subj, FUZZ
   D: |
     my $py = {Jr=>J.r, J2r=>J.r};
     
     sayyl "upthy: ".gp($J)."          <->   ".gp($J2);
     my $Jo = $J2;
     while (1) {
         saybl "  ? ".gp(Jo.Jiter);
         saybl "has: Jo.r";
         sayre("hno Jitter") && last if !Jo.Jiter;
         # see if this Jo thing has any styles above
         # .r was a phro/lev thing , blend J j
         my $j = Rw shj $r:Jo.r $J:Jo.Jiter;
         my $ip = {l => j.l};
         my @junk = Rw tvo $J:Jo.Jiter $ip;
         my (@path) = grep { _.style eq 'path' } @junk;
         sayyl "lolking through ".join" ", map{_.t} @junk;
         
         die @path if @path > 1;
         unless (@path) {
             sayre "nothing in...";
         }
         else {
            my ($path) = @path;
            py.pathy = path.s;
            push @{py.paths||=[]}, \@junk;
         }
         last if $Jo eq $J; # complete
         $Jo = Jo.Jiter; # move up
     }
     return $py;
     

