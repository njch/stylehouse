R_Jz:
 - K: event #c ITS COMING BACK AROUND # care bout acJuatoring
   D: |
     saybl join("      ", (" JJJ ".$J->pi) x 7);
     sayyl "ID: e.id";
     
     return if Rw eventkeygrab/grab;
     
     my ($J2, $j); # the deepest findable ab
     if (my $ju = J.idly->{e.id}) {
         $J2 = ju.J;
         $j = ju.j;
     }
     
     saybl "HULL;  ".gp(J.jointed); # the J above
     saybl "FROM;  ".gp($J); # the J we evented
     saybl "sejnoi;  ".gp($J2); # gp or so, sometimes
     
     sayyl "\nWOOOO ".wdump(1,$j) if $j;
     
     if (e.rval) {
         sayyl "Wants to e.rval!";
         sleep 1;
     }

     # ex clues about pathways
     $J2 ||= $J;
     my $pa = Rw upath + $J $J2;
     
     Rw suck + */conty $pa $J2;
     
      # auth between ^ v
      
     waylay mux(u=>$J);
 - K: eventkeygrab #c hack in some basic doings
   n_D:
     grab: |
       return 0 unless e.type =~ /^key/;
       my $k = e.k;
       if (R.way.hooks.eventkeygrab->{$k}) {
           Rw eventkeygrab/$k;
           sayyl "Served e.k";
           return 1;
       }
       return 0;
     G: |
       return if fork();
       sayre `figlet GIT`;
       # TODO forking pyramid isolator with error report
       `git gui`;
       exit;
     C: |
         H.G w reexec;
     J: |
         w jak;
     Y: |
         Rw occie/komp;
 - K: upath #c find %path or so between J and J2, a subj, FUZZ
   D: | # it's making spirals of looking for things to jump forward with
     my $py = {Jr=>J.r||J.name, J2r=>J2.r||J2.name};
     
     sayyl "upthy: ".gp($J)."          <->   ".gp($J2);
     # probly wanna start on the random little thing
     
     my $Jo = $J2;
     while (1) { # lurch upwards towards the...
         sayre("topmost") && last if !Jo.Jiter;
         # see if this Jo thing has any styles above
         # .r was a phro/lev thing , blend J j
         my $j = Rw shj $r:Jo.r $J:Jo.Jiter;
         my $ip = {l => j.l};
         my @junk = Rw tvo $J:Jo.Jiter $ip;
         my (@path) = grep { _.style eq 'path' } @junk;
         sayyl "  ? ".gp(Jo.Jiter)."       path search: "
             .join" ", map{_.t} @junk;
         
         die @path if @path > 1;
         if (@path) {
            my ($path) = @path;
            if (!py.pathy) {
                py.pathy = path.s;
                say "pathy: path.s";
            }
            else {
                say "extra path above: path.s";
            }
            push @{py.paths||=[]}, @path;
         }
         last if $Jo eq $J; # complete
         $Jo = Jo.Jiter; # move up
     }
     return $py;
     

