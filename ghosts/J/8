R_Jz:
 - K: event #c the join # ITS COMING BACK AROUND # care bout acJuatoring
   D: |
     # J == join/ww, moves to ux
     saybl "_---------------________------____________------------";
     sayyl ki($e);
     my $wuJ = $J;
     sayyl "              SSSSSSSSSSSSSSSS   ".gp($wuJ);
     
     # first beloww ww
     my $J = G.oin.idJy->{e.ux} || die "noJ...";
     
     # deepest id
     my ($J2, $j);
     if (my $ju = J.idly->{e.id}) {
         $J2 = ju.J;
         $j = ju.j;
     }
     
     $J2 = $j if $J2 eq $J && $j;
     
     saybl " J2    ".gp($J2);
     saybl " j    ".gp($j);
     
     # and trace backwards
     my @up = $J2;
     push @up, $up[-1]->{Jiter} until !$up[-1]->{Jiter};
     unshift @up, $j if $j;
     push @up, $J if $up[-1] ne $J;

     # make heatmap
     my $tocs = {map{$_=>1}'path','pwar'};
     my @to;
     my $is = '';
     my $lh;
     for my $j (reverse @up) {
         # like c is ar or seome
         saybl "$is ".(j.name||j.r);
         
         if ($lh) {
             my $lv = Rw r_lv $r:j.r $J:lh;
             my $sc = {};
             for my $sj (values %{lv.sj}) {
                 next unless $tocs->{sj.style};
                 $sc->{sj.style} = sj.s;
             }
             if (%$sc) {
                 sayyl "$is has ".ki($sc)."    in lh.name";
                 # may want to J = lh ... pbl on other side of vector pooling
                 push @to, { J => $J, J2 => $j, sc => $sc };
             }
         }
         $is .= '    ';
         $lh = $j;
     }
     die 'multo' if @to > 1;
     
     saybl "         j@ ".j.r if $j; # something interesting
     
     if (e.rval) {
         sayyl "Wants to e.rval!";
         sleep 1;
     }
     
     die if !$J2 && $j;
     
     return if Rw eventkeygrab/grab;
     
     my $upi={};
     for my $to (@to) {
     
         Rw contier + $J:to.J $J2:to.J2 $pa:to.sc $upi;
     }
     upi.i ||
     Rw in $J $J2 $e;
     # ambient J up elseness
 - K: contier #c 
   D: |
     my $y = pa.path;
     say " pa_path  $y";
     
     if ($y =~ /^!(.+?)(?::(.+))?$/) {
         my $m = [split /(?!^) /, $2];
         say " ! contig $1 -> @$m";
         upi.i = 1;
         if (my $par = pa.pwar) {
             $ar->{$_} ||= $par->{$_} for keys %$par;
         }
         Rw $1 + $m;
     }
     elsif ($y) {
         say " CONTIER with no y ..." if !$y;
         Rw suck + */conty $y;
     }
 - K: r_lv #c
   D: |
     my $jh = Rw shj $r $J;
     my $ip;
     ip.l = jh.l;
     ip.cv = jh.cv;
     my $vs = Rw tyv $J $ip;
     die "m,any ".wdump 2, $vs if @$vs > 1;
     my $lv = $vs->[0];
 - K: recoded_init #c wake up
   D: |
     Rw suck */recoded_init;
     
     my @wt = keys %{H.G.lastGd};
     
     my $kno = Load(<<'')->{H.name};
     C:
       W/9: ps
       W/3: hull
       W/4: ash
       W/1: ollox
       or: wo1
     K:
       or: scr
     D:
       or: ghosts
     
     
     for (@wt) {
         my $wu = $1 if /ghosts\/(.+)$/;
         
         my $wh = $kno->{$wu} || kno.or;
         
         saybl "recoded_init Wu: $wu -> $wh";
         undef $wh if $wh eq 'ash' && H.name ne 'D';
         $wh || next;
         Rw J5 $name:wh; 
     }
     
     my (@em) = Rw figure_lux;
 - K: figure_lux #c log churn brings lux phase yoming, flow control & expression
   D: |
     my $n = Rw Jung;
     # collect J.biz.onei etc
     my $now = $H->hitime;
     my @mago = map {
        my $J = $n->{$_};
        # 4
        my $lux = $now;
        $lux -= (J.ent.ti || $now);
        $lux *= J.ent.lux if J.ent.lux;
        # 5
         { J=>$J, lux=>$lux }
     } sort keys %$n;
     
     # 7
     my @tago = sort { a.lux <=> b.lux } @mago;
     # 9
     @tago;
 - K: fresh_init #c 
   D: |
     Rw suck */fresh_init;
  
 - K: any_init #c 
   D: |
     Rw suck */any_init;
  
 - K: eventkeygrab #c hack in some basic doings
   n_D:
     grab: |
       return 0 unless e.type =~ /^key/;
       my $k = e.k;
       my @try = (e.k, 'w'.e.which);
       my $g = R.way->find('eventkeygrab');
       for my $k (@try) {
           next unless $g->{$k};
           Rw eventkeygrab/$k;
           sayyl "Served e.k";
           return 1;
       }
       return 0;
     w189: | # ½
       # inject J / fontsize --
     w187: | # »
       # inject J / fontsize ++
     H: |
       my $n = Rw Jung;
       n.oot
     G: |
       return if fork();
       sayre "".`figlet GIT`;
       # TODO forking pyramid isolator with error report
       `git gui`;
       exit;
     C: |
         H.G w reexec;
     J: |
         w jak;
     Y: |
         Rw occie/komp;

