    gpfro: | #c .fro(...) -> Rw gp $a
      my ($aser, $l, $u, $cv, @etc) = @$a;
      
      my $gp = {u=>$u, cv=>$cv};
      %$gp = (%$gp, %{delete gp.cv}) if ref gp.cv;
      %$gp = (%$gp, %{ar.also}) if ar.also;
      
      my $v = w $R gp(a => $gp);
            
      $aser->($l => $v,
          '%gp' => $gp,
          @etc,
      );
    
    gp: | # R_sur gp # another little con tent, backeting a harmonic sur-ish portal
        G.gp_inarow++;
        my $a = ar.a || die;
        # usuall comes in on a:
        die "ref cv stilla t gp" if ref a.cv;
        %$a = (%$a, %{delete a.cv}) if ref a.cv; # sneak params in...
        a.cv = 0.1 if a.cv < 0.1;
        
        my $u = a.u;
        
        # 3
        $R->phat($a);
        
        a.isJid = a.replaceJid || $H->mkuid;
        undef a.isJid if G.gp_inarow > 1;
        
        my $c = $R->cgp($u);
        
        # 4
        my $wa = a.wa || do {
            my ($wa) = grep { $c->{$_} } qw'canpi ARRAY HASH ref undef text';
            $wa = ref $u if $wa eq 'canpi';
            $wa ||= 'wtf';
            $wa
        };
        R.way->find("pi/$wa") || die "not $wa equip";
        
        # 5

        # 6
        w $R pi/$wa[$a,$u];
        
        # 7
        my $html = w $R maka[$a,$u];
        # don't need to close it up right now...
        # top down injection gos
        
        
        # 8
        
        # 9
        G.gp_inarow--;
        my $ind = join "", ("  ") x scalar @F;
        #sayyl "$ind Done gp for $u ".F_delta;
        $html
        

