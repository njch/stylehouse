R_Jz:
 - K: hull #c whole screen iraga
   n_D:
     conty: | # tyhe other
       sayyl "HULL";
       w mux(u=>$J);
     styJup: |
       qw| hull |
       # geophat
     hijack: |
       # the biggest con! 
       my $sur = Rw hiJ ollox sur;
       
       Rw Jolt + $J2:sur;
       
       my $sur2 = Rw hiJ o22x sur;
       
       Rw Jolt $J $J2:sur2;
       
       my $oot = Rw hiJ oot foot;
       
       Rw Jolt $J $J2:oot;
       
       
     curves: |
         ["spun 0" => 0],
         ["y 0" => 0],
         ["x 0" => 0],
         ["zoom 0" => 0.5],
         ["curve 0.1" => -0.4],
         
         ["zoom 0.4" => -0.12],
         ["curve 0.4" => -0.7],
         
         ["curve 0.8" => -1.4],
     mods: |
       [sqw   => 25,  '~', {}, 'font-size:200%;'],
       [sq   => 10,  '@', {}],
     stylesheet: |
       'ux  {pointer-events: none;}
       ux * {pointer-events: all;}'
          
 - K: Jolt #c JjJj how to J -> j, sproutlinger
   D: |
     my $n = ar.n || shift @{ar.m||[]} || J.jon++;
     
     $n += 0;
     
     # balance follicles
     sayyl "Jont ".$J->pi."  %Joints @ J.jon   ".$J2->pi for 1..5;
     J bz J2.name 0.$n    '>:D', '%Joint' => $J2
     # so then %Joint knows when comparing at corner of con tent
     # what to ....
     # know about one thing in each place ness
     Rw fitin $J $n $J2;

     J2.jointed = $J;
     $J2;
 - K: fitin #c like push onto the %Joints centipede, which cons # mmm
   D: |
     my $cv = 0.7;
     # 
     Rw jitterbug $J $cv;
     Rw Joints $J;
 - K: Joints #c
   D: |
     my @things = Rw tvy $J;
     for my $ths (@things) {
         my ($th, @sjs) = @$ths;
         say "y hello ".wdump(1,$ths) if th.l ne th.t;
         
         if (my ($Joi) = grep{_.style eq 'Joint'} @sjs) {
             my @jcss = grep{_.style eq 'css' && _.com =~ /^pha/} @sjs;
             my $J2 = $Joi->{s};
             
             Rw oven $J $J2;
             # J2 now disposed to a part of J, all within L
             
             
             my ($Z, $N);
             for my $N (map { _.s } @jcss) {
                 $Z->{$_} = $N->{$_} for keys %$N;
             }
             sayyl " hoping ".$J2->pi." istyle:".wdump($Z);
             
             if ($Z->{'-webkit-transform'} =~ /rotate\((.+?)rad\)/) {
                 $Z->{'-webkit-transform'} = 'rotate('.($1 + 0).'rad)',
             }
             
             
             my $beef = J2.S.Z;
             my $off = 77;
             Z.width = $off.'%';
             Z.height = $off.'%';
             #Z.border = '2px solid rgba(0,0,0,0.3)';
             J2.S.Z = $Z;
             #say "YESSSSS". wdump 2,[tj.r, $beef, map { "   _.r" } @jcss];
         }
     }
 - K: JL #c make L bracket # rename Joint
   D: |
      my $u = {K=>'L',%{ar.r || {}}}; 
      u.name ||= "L:J.name:".G.jumb.Lnumb++; # additively
      my $q = 1;
      my $L = w G.R fuu[$u, $q];
      sayyl "made ++ ".$L->pi;
      $L
 - K: oven #c
   D: |
     J.L ||= Rw JL $J;
     
     sayyl "OVENATING";
     
     w mux(u=>J.L);
     
     for my $k (grep {/^J/} keys %$ar) {
         my $JJ = $ar->{$k};
         JJ.A->umk(J.L => 'S');
         # does that tidy^ TODO
         w mux(u=>$JJ);
     }
     

