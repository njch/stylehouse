R_Jz:
 - K: sur #c SURish rondo: on -> square ->
   n_D:
     styJup: | #c
       'thesurf', 'sur'
     up: | #c
       Rw inness;
       
       # TODO 2real joint, like sur
       # finds on, near in, ups
       # traction gets to 1 TODO antlerdaptory
       # move impression of ^ to v, then round
       J.lum = Rw tent lum;
       # TODO replace last
       
       
       my $u = J.on.bb->{"u\t".0.1};
       
       say "U: ".$u->pi;
     
       my $r = {map{$_=>1} keys %$u};
       
       # bunch of keys... ^ interpret, compress knowledge
       # TODO ^make itv like two indexes, polars
       
       my $y = w $R down; # 2ish aggd knowledge, instructions?
       
       my @r = grep { delete $r->{$_} } @{y.order};
       push @r, sort keys %$r;
       
       # META
           J.lum.fro->("J\t"."0.01" => $J, 0.1);
           J.lum.fro->("Jonei\t"."0.03" => J.onei, 0.4);
       
       for $r (@r) {
            my $v = $u->{$r};
            
            my $cv = 0;
            $cv ||= y.ordy->{$r};
            $cv ||= 4;
            
           #J.bz->("$r\t"."0.$cv".0 => $r);
           J.lum.fro->("$r/\t"."0.$cv" => $v,
               {cv=>0.2, makaz=>{ # hooky
                  "/%css#jit\t"."0.1" => 'padding-left:4em;white-space:pre;max-width:10em',
               }},
               '%path' => '{'.$r,
              );
            #J.bz->("$r\t"."0.$cv" => ''.$v, '%css'=>'white-space:pre');
             # has l cursor stashed as a 1shj
             # TODO 5er grab l cursor and style
             # and what kind of cursor, fro delays/syncs
             # start culture
             # the middle
       }
       Rw suck */round;
     round: | #c regroup
       # J.lum -5> $J
       # could multiple J sources and exits, provide roundness, generally...
       
       my @be = Rw tvo $J:J.lum;
       my $jit; # cv / l / t / $j
       my $ji = {map{$_=>[]}0..9};
       
       for my $j (@be) {
           $jit->{j.cv}->{j.l}->{j.t} && die;
           $jit->{j.cv}->{j.l}->{j.t} = $j;
           next unless j.l eq j.t; # just deal thing spines
           j.cv =~ /^0\.(\d)/ || die;
           my $cvb = $1;
           push @{$ji->{$cvb}}, $j;
       }
       
       # wavesmush
       my $id = 4;
       for my $i (0..9) {
           my $lo = $ji->{$i-1};
           my $no = $ji->{$i};
           my $ro = $ji->{$i+1};
           
           my $bulg = @$no - $id if @$no > $id;
           if ($bulg > 0 && $lo && @$lo < $id) {
               my $idspacl = $id - @$lo;
               push @$lo, map { shift @$no } 1..$idspacl;
           }
           
           $bulg = 0;
           $bulg = @$no - $id if @$no > $id;
           if ($bulg > 0 && $ro) { # without varing  && @$ro < $id
               unshift @$ro, map { shift @$no } 1..$bulg;
           }
           elsif ($bulg > 0) {
               die 'backflip';
               # flip everything around, raise $id,
               # slosh back toward the middle again
               # very painterly
           }
           
       }
       
       
       # measure $ji, mod up locations for things
       # give original j.cv if the $cvb/ set is same
       for my $cvb (sort keys %$ji) {
           my $no = $ji->{$cvb};
           my @cvs = map{_.cv}@$no;
           die if join(":",@cvs) ne join(":", sort @cvs);
           
           if (@cvs != uniq @cvs) {
               
               my $warp = @$no;
               @cvs = map { "0.".$cvb.$_ } Rw cv/oe $v:warp;
               # wind for thi like in mod
           }
           
           for my $j (@$no) {
               my $ncv = shift @cvs;
               my $ts = $jit->{j.cv}->{j.l};
               for my $k (sort keys %$ts) {
                   my $tj = $ts->{$k};
                   J.bz->(tj.t."\t".$ncv, tj.s);
               }
               J.bz->(j.l."%origin\t".$ncv, $j); # subtlest A-tion
           }
       }
       
       

