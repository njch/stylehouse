R_Jz:
 - K: bacup #c SCHEMA
   D: |
       my $ss_Ds = R.S.ss_Ds = Load(<<'');
                 n: |
                    n.HASH = {};
                 Ai: |
                    Ai.A = {};
                 Gi: |
                    my $likes = {map{$_=>1}qw{G ways}};
                    Gi.HASH = {
                     it => sub {
                       my $h = shift;
                       my @r = map { { K=>$_, k=>"{".$_, v=>$h->{$_} } } sort keys %$h
                     },
                    };
       
       for my $k (sort keys %$ss_Ds) { # or K array who knows
           my $u = R.S.ss->{$k} = w $R dus;
           my $D = $ss_Ds->{$k};
           $G->D({bab=>$D, ar=>{$k=>$u}});
       }
       

 - K: down #c TODO to have maintained down by what comes up from 7 via 8 in motion, tune in values
   D: |
       my $ordy = Load(<<'');
       {A: 13, id: 11, K: 17, name: 185,
       G: 15, R: 15, B: 23, more: 543,
       surf: 8,
       TheD: 23, TheJ: 23, TheM: 23, TheR: 23
       }
       
       my $ydro = {};
       push @{$ydro->{$_}||=[]}, $_ for keys %$ordy;
       my @order = map { @{$ydro->{$_}} } sort keys %$ydro;
       
       { order => \@order,
            ordy => $ordy,
       }

     
 - K: inness #cc soy packets everywhere # THINGNESS as onness
   D: |
      J.on = Rw tent on;
      # ^ recursor...
      # v def
      my $o = J.onei ||= {i=>$G};
      
      my $r = ar.r;
      
      w mux(u=>$J) if $r; # calc entropy
      
      # ^ inject
      # t distributable, listy compressible pass space
      o.i = r.i if r.i;
      if (ref r.t eq 'ARRAY') {
          o.t = [@{r.t}];
      }
      else {
          push @{o.t||=[]}, r.t if r.t;
      }
      
      my $i = o.i;
      for my $t (@{o.t}) {
          sayyl "   -trav $i       $t";
          $i = $R->suets($i, $t);
      }
      sayyl "Inness: o.i  ".join"  / ", @{o.t||[]};
      sayyl "traut: $i";
      
      J.on.bz->("u%travely\t".0.1 => J.onei);
      J.on.bz->("u\t".0.1 => $i);
      
 - K: sur #c SURish rondo: on -> square ->
   n_D:
     styJup: | #c
       G.surf = $J;
       'thesurf', 'sur'
       # the class etc bits of $e might clue in what to do
       # maybe can mousedown just x y?
       # J is the 1circle, J2 the 2circle
       # path must be somewhere around here...
       # on the gp's / which is inside yet outsideness, or the lev... whatev.
       # TODO look-around-for %whatever
       # way is a weird uri-ish string, like {key

       # there's a bunch of paths, there interesting
     conty: | #css # eats HASH
       my $J2 = J.gpa.pis->{e.id};

       saybl "HULL;  ".gp(J.jointed); # the J above
       saybl "FROM;  ".gp($J); # the J we evented
       
       saybl "sejnoi;  ".gp($J2); # gp or so, sometimes
       
       my $r = {}; # sproutya
       # ex clues about pathways
       my $pa = Rw upath + $J $J2;
       # furth join:
       r.t = pa.pathy if pa.pathy;
       # ^ compressions understood by t2ale of inness J.onei, compiled...
       
       saybl "pat :".wdump(2,$r);
       
       # /
       # \
       
       for (e.type) {
           when ('click') {
               # how to patter along, surge
               # churn same board or unfurling diff
               my $J3 = Rw sur/spawnge $J;
               # same
               sayyl $J3->pi." pattern going in ".ki $r;
               # &or copy if refraction
               if ($J ne $J3) { # copy HEAD before pat(c)h
                   Rw inness $J:J3 $r:J.onei;
               }
               # may not replace ollox but dense net out around the spot
               Rw inness $J:J3 $r;
           }
           when ('keydown') {
               say "is key e.k";
               for (e.k) {
                   when ('0') {
                       my $t = J.onei.t;
                       my @t = @{$t||die};
                       pop @t;
                       my $r = {t=>\@t};
                       Rw inness $J $r;
                   }
               }
           }
           default {
             say "Sur". wdump($e);
           }
       }
     spawnge: | #c spew arm when getting full
       # intermediates inness unfoldment to cellular structure
       # like if e.S we want shift in it, sprouting
       $J; # or return the arm instead
     reit: | #c
       Rw Jolt $J:J.jointed ollox sur;
     up: | #c upper level gplumb
       Rw inness;
       
       # TODO 2real joint, like sur
       # finds on, near in, ups
       # traction gets to 1 TODO antlerdaptory
       # move impression of ^ to v, then round
       J.lum = Rw tent lum;
       # TODO replace last
       
       my $u = J.on.bb->{"u\t".0.1};
       # META
       J.lum.fro->("J\t"."0.01" => $J, {cv=>0.1,untitled=>1});
       
       J.lum.fro->("Jonei\t"."0.03" => J.onei, {cv=>0.4,untitled=>1});
       
       J.lum.fro->("u\t"."0.03" => $u, {cv=>0.2,untitled=>1});
       
       say "U: ".$J->pi."   ".gp($u);
       
       my $y = w $R down; # 2ish aggd knowledge, instructions?
       
       my @r;
       if (!ref $u) {
           push @r, { r=>"text", s=>$u, cv=>0.4 };
       }
       elsif (ref $u eq 'ARRAY') {
           my $i = 0;
           my $warp = @$u; # TODO or less?
           my @warp = Rw cv/oe off1 $v:warp;
           for (@$u) {
               my $cv = "0.". shift @warp;
               push @r, { r=>$i, path=>"[".$i++, v=>$_, cv=>$cv};
           }
       }
       else {
           my $r = {map{$_=>1} keys %$u};

           # bunch of keys... ^ interpret, compress knowledge
           # TODO ^make itv like two indexes, polars
           # any sorta layout knowhow...
       
           my @or = grep { delete $r->{$_} } @{y.order};
           push @or, sort keys %$r;
           
           for (@or) {
               my $cv = y.ordy->{$_} || 4;
               $cv = "0.$cv";
               push @r, { r=>$_, path=>"{$_", s=>$u->{$_}, cv=>$cv };
           }
       }
       
       
       for my $r (@r) { # %{ r, path, v, cv
            
           next if r.r eq 'load_ways_count';
           
           J.lum.lev->("r.r/\t".r.cv => sub {
               my $a = shift;
               
               my $fs = length(r.r) > 9 ? 60 : 80;
               
               my $guec = $2 if r.cv =~ /^(0\.)?(\d)/;
               my $col = G.jumb.cos->{$guec} || warn "was r.cv so $guec";
               
               # TODO curve ^ # make sf of a Q factor that can see $v somehow
               a.bz->(
                    "lable 0.1" => r.r,
                    #'%sf#la' => "ab;pr.5;fs$fs;c0", C that < v
                    "%css#laob" => 'position:absolute;right:0.5em;',
                    "%css#lableg" => "font-size:$fs%",
                    "%css#labcoat" => "color:$col", # TODO unwind cv into colour
                    "%tt#\cv" => r.cv,
               );
               
                  
               a.fro->("gp\t"."0.6" => r.s,
                 {cv=>0.2, makaz=>{ # hooky
                    "/%css#jit 0.9" => 'position:absolute;left:1em;width:30em',
                 }}, # ^ v in out sameish
                 (r.path ? ('%path' => r.path) : ()),
               );
           });
            #J.bz->("$r\t"."0.$cv" => ''.$v, '%css'=>'white-space:pre');
             # has l cursor stashed as a 1shj
             # TODO 5er grab l cursor and style
             # ad what kind of cursor, fro delays/syncs
             # start culture
             # the middle
             # start cuddle
       }
       Rw round $J4:J.lum $J5:J;
       
       #sayyl _.r for 
       
       my @oooo = Rw tvo $J;
       for my $j (@oooo) {
           #say j.r;
       }

