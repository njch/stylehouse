R_Jz:
 - K: hijack #c hit J
   D: |
      my $J = Rw hiJ below hull;
      my $J2 = Rw hiJ bollox sur;
      
      Rw fitin $J $J2;
      
      $J
 - K: fitin #c
   D: |
     my @so = sort grep {/^J.+/} keys %$ar;
     my $J = ar.J;
     for (sort keys %$ar) {
         /^J(\d+)$/ || next;
         my $cvb = $1;
         my $Jo = $ar->{$_};
         J.bz->(Jo.name."\t"."0.".$cvb => '>:D', '%Joint' => $Jo);
     }
     Rw jtrbg $J;
     
     my @things = Rw tvy $J;
     for my $thing (@things) {
         my ($tj, @sjs) = @$thing;
         if (my ($Joint) = grep{_.style eq 'Joint'} @sjs) {
             my @jcss = grep{_.style eq 'css' && _.com =~ /^pha/} @sjs;
             my $J2 = $Joint->{s};
             Rw oven $J $J2;
             say "YES". wdump 2,[tj.r, $Joint->{s}, map { "   _.r" } @jcss];
         }
     }
     
     #J.bz->("j.t%css#pha-$_->[0]\t".j.cv => $_->[1]); # concert per emportar
     #sayyl wdump(2,\@things);
 - K: hiJ #c
   D: |
     my $r;
     r.name = shift @$m;
     r.name .=  "-J".G.Jnumb++; # additively, paranoid
     r.style = [@$m];
     
     my $J = Rw makeJ $r;
     
     Rw Jup $J;
     
     waylay mux(u=>$J);
     
     $J
 - K: makeJ #c
   D: |
      my $r = ar.r || $ar;
      my $u = {K=>'J',%$r}; 
      u.name ||= "J".G.Jnumb++; # additively
      my $q = 1;
      my $J = w G.R fuu[$u, $q];
      
      sayyl "made ++ ".$J->pi;
      $J
 - K: Jup #c
   D: |
     my $style = J.style;
     my @style = map {
         saygr "J.name seeking $_...";
         my $p = "$_/styJup";
         Rw suck - $p,
         #Rw suck - */styJup/$_,
        } @$style;
     saygr "J.name styJupd: @style";
     
      J.yt = { map{$_=>1} @style};
       
     "J".G.Jnumb++; # additively
 - K: thesurf #c CURVE curver
   n_D:
     curves: |
         ["spun 0" => 0.025],
         ["curve 0" => -0.211],
         ["zoom 0" => 0.2],
         ["zoom 0.21" => -0.09],
         ["curve 0.3" => 0.11],
         
         ["curve 0.712" => -0.05],
     mods: |
       [sq   => 10,  '~~~'],
       [sqat   => 20,  '^', {}, 'color:blue',
         in => 10,
       ],
       [sqat   => 20,  'v', {}, 'color:blue',
         out => 10,
       ],
 - K: hull #c whole screen iraga
   n_D:
     styJup: |
       'hull'
     curves: |
         ["spun 0" => 0.025],
         ["curve 0" => -0.211],
         ["zoom 0" => 0.2],
         ["zoom 0.21" => -0.09],
         ["curve 0.3" => 0.11],
         
         ["curve 0.712" => -0.05],
     mods: |
       [sq   => 40,  '.', {}, 'color:blue'],
 - K: sur #c SURish rondo: on -> square ->
   n_D:
     styJup: |
       'thesurf', 'sur'
     inness: | #c soy packets everywhere # THINGNESS
      J.on = w $R makeJ(name=>J.name.'-on'); # babble
      
      # travwel...
      my $u = $G;
      {
          id => "not",
          name => "ches",
          G => $G,
          more => "more",
          Bee => "stuff",
      };
      
      J.on.bz->("u\t".0.1 => $u);
      
     up: | #c 
       Rw suck */inness;
       # TODO 2real joint, like sur
       # finds on, near in, ups
       # traction gets to 1 TODO antlerdaptory
       # move impression of ^ to v, then round
       J.lum = w $R makeJ(name=>J.name.'-lum'); # TODO replace last
       
       
       my $u = J.on.bb->{"u\t".0.1};
     
       my $r = {map{$_=>1} keys %$u};
       
       # bunch of keys... ^ interpret, compress knowledge
       # TODO ^make itv like two indexes, polars
       
       my $y = w $R down; # 2ish aggd knowledge, instructions?
       
       my @r = grep { delete $r->{$_} } @{y.order};
       push @r, sort keys %$r;
       
       for $r (@r) {
            my $v = $u->{$r};
            
            my $cv = 0;
            $cv ||= y.ordy->{$r};
            $cv ||= 4;
            
           #J.bz->("$r\t"."0.$cv".0 => $r);
           J.lum.fro->("$r/\t"."0.$cv" => $v,
               {cv=>0.2, makaz=>{ # hooky
                  "/%css#jit\t"."0.1" => 'padding-left:4em;white-space:pre;max-width:10em',
               }},
               '%path' => $r,
              );
            #J.bz->("$r\t"."0.$cv" => ''.$v, '%css'=>'white-space:pre');
             # has l cursor stashed as a 1shj
             # TODO 5er grab l cursor and style
             # and what kind of cursor, fro delays/syncs
             # start culture
             # the middle
       }
       Rw suck */round;
     round: | #c regroup
       # J.lum -5> $J
       # could multiple J sources and exits, provide roundness, generally...
       
       my @be = Rw tvo $J:J.lum;
       my $jit; # cv / l / t / $j
       my $ji = {map{$_=>[]}0..9};
       
       for my $j (@be) {
           $jit->{j.cv}->{j.l}->{j.t} && die;
           $jit->{j.cv}->{j.l}->{j.t} = $j;
           next unless j.l eq j.t; # just deal thing spines
           j.cv =~ /^0\.(\d)/ || die;
           my $cvb = $1;
           push @{$ji->{$cvb}}, $j;
       }
       
       # wavesmush
       my $id = 4;
       for my $i (0..9) {
           my $lo = $ji->{$i-1};
           my $no = $ji->{$i};
           my $ro = $ji->{$i+1};
           
           my $bulg = @$no - $id if @$no > $id;
           if ($bulg > 0 && $lo && @$lo < $id) {
               my $idspacl = $id - @$lo;
               push @$lo, map { shift @$no } 1..$idspacl;
           }
           
           $bulg = 0;
           $bulg = @$no - $id if @$no > $id;
           if ($bulg > 0 && $ro) { # without varing  && @$ro < $id
               unshift @$ro, map { shift @$no } 1..$bulg;
           }
           elsif ($bulg > 0) {
               die 'backflip';
               # flip everything around, raise $id,
               # slosh back toward the middle again
               # very painterly
           }
           
       }
       
       
       # measure $ji, mod up locations for things
       # give original j.cv if the $cvb/ set is same
       for my $cvb (sort keys %$ji) {
           my $no = $ji->{$cvb};
           my @cvs = map{_.cv}@$no;
           die if join(":",@cvs) ne join(":", sort @cvs);
           
           if (@cvs != uniq @cvs) {
               
               my $warp = @$no;
               @cvs = map { "0.".$cvb.$_ } Rw cv/oe $v:warp;
               # wind for thi like in mod
           }
           
           for my $j (@$no) {
               my $ncv = shift @cvs;
               my $ts = $jit->{j.cv}->{j.l};
               for my $k (sort keys %$ts) {
                   my $tj = $ts->{$k};
                   J.bz->(tj.t."\t".$ncv, tj.s);
               }
               J.bz->(j.l."%origin\t".$ncv, $j); # subtlest A-tion
           }
       }
       
       
 - K: cv #cove
   n_D:
     oe: |
       my $v = ar.v || 9;
       my $wi = length($v);
       my $thi = join '', ('9') x $wi;
       
       my @is = map { sprintf '%0'.$wi.'d', $_  }
       map { int($_ * ($thi / $v)) } 1..$v;
       
       die "numbe rdist ".wdump(2,[$v,$wi,$thi,@is]) if uniq(@is) != @is;
       @is;
       
     
 - K: fLan #c LOCAL AETA NETWORK
   n_D:
     flam: |
         sayre "YEp fLan";
     # redistribute from/with the shap of the = as upside down T
     # 1 circle and another kinda axis thing, making a dynamic
     # a 2 circle may involev magnetic fishing rod relay hivi too
     # pulling aspects out of the braid bed, 
     # rad per 0.1cv? who knows
 - K: geophat #c
   spesh: 0
   n_D:
     geolmo: |
       my @be = grep { _.style eq 've' } w $R tvo(J=>J.geo); # poli
       for my $j (@be) {
           my $s = j.s;
           my $creatin = s.creatin;
           J.fro->("being".j.cv."\t".j.cv => $creatin,
               {cv=>0.8, makaz=>{ # hooky
                  "/%css#jit\t"."0.1" => 'margin-left:6em;',
               }},
              );
       }
 - K: geote #c CURVE curver
   n_D:
     curves: |
         ["spun 0" => 0.025],
         ["curve 0" => -0.211],
         ["zoom 0" => 0.2],
         ["curve 0.21" => 0.011],
         ["zoom 0.31" => -0.09],
         
         ["curve 0.712" => -0.05],
     mods: |
       [sq   => 10,  '~~~'],
       [sqat   => 20,  '^', 'color:blue'],
 - K: unicrowd #c CURVE curver
   n_D:
     mods: |
       [zqeq => 50, J.ent.2, {unico => {thi=>9}, fs=>1_2}],
       [zqeq => 20, J.ent.2, {unico => {thi=>6}, fs=>3_2}],
       [zqeq => 10, J.ent.2, {unico => {thi=>3}, fs=>4_2}],
 - K: mooz #c
   n_D:
     mods: |
       [dotz => 22, 'z', 'color:black;opacity:0.4;white-space:pre;font-size:3200%;font-family:serif;margin-top:-25%'],
       [dots => 10, '             .', '', 'color:yellow;font-size:300%;opacity:0.5'],
       [dots => 11, '___', '', 'color:blue;font-size:300%;opacity:0.5'],
 - K: squi #c ~~~~~~~~~~~~~
   spesh: 0
   n_D:
     mods: |
       [sqw  => 25, '~~`, ~', {fs=>5_3},
       'color:#59d;-webkit-filter:blur(3px);'],
       [sqww => 13, '   ~~', {fs=>8_2},
       'color:#8ff;-webkit-filter:blur(3px);'],
     noms: |
       [sqw  => 6, ' `, `, `,', {fs=>06_2},
       'color:#05d;-webkit-filter:blur(1px);'],
       [sqw  => 3 + J.ent.2, '  ~~`, ~', {fs=>1_2},
       'color:#09d;-webkit-filter:blur(3px);'],
       [sqww => int(13 *(J.ent.2/4)), ' ??  ??', {},
       'color:#8ff;font-size:1100%;-webkit-filter:blur(3px);'],
     
 - K: jextr #c 
   babz:
     'stev#jext 5.7': |
       # add conditional: if J.yp.jextr # woosh
       J.bz->("$_%css#uff\t".j.cv => 'opacity:0.7;') when /^stuff(\d+)/;
 - K: tout #c ~~~~~~~~~~~~
   fishes:
     oly: fan
   D: |
     my $dis = int(rand 5);
     my $win = join '', (" ") x $dis;
       #my $tout = sub {
       #    my $c = shift;
         [sqw  => 33, $win.' 1 0 1 0',
           'color:#95d;font-size:'.($dis * (1800/5)).'%;-webkit-filter:blur(1px);white-space:pre;'],
       #};

