R_Jz:
 - K: uphere #c curve curver
   n_D:
     makeJ: |
       my @style = (
           'thesurf',
         #  'geophat',
           'sur',
       # 'unicrowd',
        #'squi',
        #'mooz', 
       ); # J.something -> something ^ -> that
       J.yt = { map{$_=>1} @style};
       
    
 - K: thesurf #c CURVE curver
   n_D:
     curves: |
         ["spun 0" => 0.025],
         ["curve 0" => -0.211],
         ["zoom 0" => 0.2],
         ["curve 0.21" => 0.31],
         ["zoom 0.21" => -0.09],
         
         ["curve 0.712" => -0.05],
     mods: |
       [sq   => 10,  '~~~'],
       [sqat   => 20,  '^', {}, 'color:blue',
       in => 5,
       ],
 - K: sur #c SURish rondo: on -> square ->
   n_D:
     inness: | #c soy packets everywhere # THINGNESS
      J.on = w $R makeJ(name=>J.name.'-on'); # babble
      
      # travwel...
      my $u = $G;
      {
          id => "not",
          name => "ches",
          G => $G,
          more => "more",
          Bee => "stuff",
      };
      
      J.on.bz->("u\t".0.1 => $u);
      
     up: | #c 
       Rw suck */inness;
       # TODO 2real joint, like sur
       # finds on, near in, ups
       # traction gets to 1 TODO antlerdaptory
       # move impression of ^ to v, then round
       J.lum = w $R makeJ(name=>J.name.'-lum'); # TODO replace last
       
       
       my $u = J.on.bb->{"u\t".0.1};
     
       my $r = {map{$_=>1} keys %$u};
       
       # bunch of keys... ^ interpret, compress knowledge
       # TODO ^make itv like two indexes, polars
       
       my $y = w $R down; # 2ish aggd knowledge, instructions?
       
       my @r = grep { delete $r->{$_} } @{y.order};
       push @r, sort keys %$r;
       
       for $r (@r) {
            my $v = $u->{$r};
            
            my $cv = 0;
            $cv ||= y.ordy->{$r};
            $cv ||= 4;
            
           #J.bz->("$r\t"."0.$cv".0 => $r);
           J.lum.fro->("$r/\t"."0.$cv" => $v,
               {cv=>0.2, makaz=>{ # hooky
                  "/%css#jit\t"."0.1" => 'padding-left:4em;white-space:pre;max-width:10em',
               }},
               '%path' => $r,
              );
            #J.bz->("$r\t"."0.$cv" => ''.$v, '%css'=>'white-space:pre');
             # has l cursor stashed as a 1shj
             # TODO 5er grab l cursor and style
             # and what kind of cursor, fro delays/syncs
             # start culture
             # the middle
       }
       Rw suck */round;
     round: | #c regroup
       # J.lum -> $J
       
       my @be = Rw tvo $J:J.lum;
       my $jit; # cv / l / t / $j
       my $ji = {map{$_=>[]}0..9};
       
       for my $j (@be) {
           $jit->{j.cv}->{j.l}->{j.t} && die;
           $jit->{j.cv}->{j.l}->{j.t} = $j;
           next unless j.l eq j.t; # just deal thing spines
           j.cv =~ /^0\.(\d)/ || die;
           my $cvb = $1;
           push @{$ji->{$cvb}}, $j;
       }
       
       # wavesmush
       my $id = 4;
       for my $i (0..9) {
           my $lo = $ji->{$i-1};
           my $no = $ji->{$i};
           my $ro = $ji->{$i+1};
           
           my $bulg = @$no - $id if @$no > $id;
           if ($bulg > 0 && $lo && @$lo < $id) {
               my $idspacl = $id - @$lo;
               push @$lo, map { shift @$no } 1..$idspacl;
           }
           
           $bulg = 0;
           $bulg = @$no - $id if @$no > $id;
           if ($bulg > 0 && $ro) { # without varing  && @$ro < $id
               unshift @$ro, map { shift @$no } 1..$bulg;
           }
           elsif ($bulg > 0) {
               die 'backflip';
               # flip everything around, raise $id,
               # slosh back toward the middle again
               # very painterly
           }
           
       }
       
       
       # measure $ji, mod up locations for things
       # give original j.cv if the $cvb/ set is same
       for my $cvb (sort keys %$ji) {
           my $no = $ji->{$cvb};
           my @cvs = map{_.cv}@$no;
           die if join(":",@cvs) ne join(":", sort @cvs);
           
           if (@cvs != uniq @cvs) {
               
               my $warp = @$no;
               @cvs = map { "0.".$cvb.$_ } Rw cv/oe $v:warp;
               # wind for thi like in mod
           }
           
           for my $j (@$no) {
               my $ncv = shift @cvs;
               my $ts = $jit->{j.cv}->{j.l};
               for my $k (sort keys %$ts) {
                   my $tj = $ts->{$k};
                   J.bz->(tj.t."\t".$ncv, tj.s);
               }
               J.bz->(j.l."%origin\t".$ncv, $j); # subtlest A-tion
           }
       }
       
       
 - K: cv #cove
   n_D:
     oe: |
       my $v = ar.v || 9;
       my $wi = length($v);
       my $thi = join '', ('9') x $wi;
       
       my @is = map { sprintf '%0'.$wi.'d', $_  }
       map { int($_ * ($thi / $v)) } 1..$v;
       
       die "numbe rdist ".wdump(2,[$v,$wi,$thi,@is]) if uniq(@is) != @is;
       @is;
       
     
 - K: fLan #c LOCAL AETA NETWORK
   n_D:
     flam: |
         sayre "YEp fLan";
     # redistribute from/with the shap of the = as upside down T
     # 1 circle and another kinda axis thing, making a dynamic
     # a 2 circle may involev magnetic fishing rod relay hivi too
     # pulling aspects out of the braid bed, 
     # rad per 0.1cv? who knows
 - K: geophat #c
   spesh: 0
   n_D:
     geolmo: |
       my @be = grep { _.style eq 've' } w $R tvo(J=>J.geo); # poli
       for my $j (@be) {
           my $s = j.s;
           my $creatin = s.creatin;
           J.fro->("being".j.cv."\t".j.cv => $creatin,
               {cv=>0.8, makaz=>{ # hooky
                  "/%css#jit\t"."0.1" => 'margin-left:6em;',
               }},
              );
       }
 - K: geote #c CURVE curver
   n_D:
     curves: |
         ["spun 0" => 0.025],
         ["curve 0" => -0.211],
         ["zoom 0" => 0.2],
         ["curve 0.21" => 0.011],
         ["zoom 0.31" => -0.09],
         
         ["curve 0.712" => -0.05],
     mods: |
       [sq   => 10,  '~~~'],
       [sqat   => 20,  '^', 'color:blue'],
 - K: unicrowd #c CURVE curver
   n_D:
     mods: |
       [zqeq => 50, J.ent.2, {unico => {thi=>9}, fs=>1_2}],
       [zqeq => 20, J.ent.2, {unico => {thi=>6}, fs=>3_2}],
       [zqeq => 10, J.ent.2, {unico => {thi=>3}, fs=>4_2}],
 - K: mooz #c
   n_D:
     mods: |
       [dotz => 22, 'z', 'color:black;opacity:0.4;white-space:pre;font-size:3200%;font-family:serif;margin-top:-25%'],
       [dots => 10, '             .', '', 'color:yellow;font-size:300%;opacity:0.5'],
       [dots => 11, '___', '', 'color:blue;font-size:300%;opacity:0.5'],
 - K: squi #c ~~~~~~~~~~~~~
   spesh: 0
   n_D:
     mods: |
       [sqw  => 25, '~~`, ~', {fs=>5_3},
       'color:#59d;-webkit-filter:blur(3px);'],
       [sqww => 13, '   ~~', {fs=>8_2},
       'color:#8ff;-webkit-filter:blur(3px);'],
     noms: |
       [sqw  => 6, ' `, `, `,', {fs=>06_2},
       'color:#05d;-webkit-filter:blur(1px);'],
       [sqw  => 3 + J.ent.2, '  ~~`, ~', {fs=>1_2},
       'color:#09d;-webkit-filter:blur(3px);'],
       [sqww => int(13 *(J.ent.2/4)), ' ??  ??', {},
       'color:#8ff;font-size:1100%;-webkit-filter:blur(3px);'],
     
 - K: jextr #c 
   babz:
     'stev#jext 5.7': |
       # add conditional: if J.yp.jextr # woosh
       J.bz->("$_%css#uff\t".j.cv => 'opacity:0.7;') when /^stuff(\d+)/;
 - K: tout #c ~~~~~~~~~~~~
   fishes:
     oly: fan
   D: |
     my $dis = int(rand 5);
     my $win = join '', (" ") x $dis;
       #my $tout = sub {
       #    my $c = shift;
         [sqw  => 33, $win.' 1 0 1 0',
           'color:#95d;font-size:'.($dis * (1800/5)).'%;-webkit-filter:blur(1px);white-space:pre;'],
       #};

