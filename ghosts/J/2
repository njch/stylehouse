R_Jz:
 - K: oJ #c materialise G.oin.oJ.$name or J.oJ.$name
   D: |
     my $oJ = ar.J || G.oin;
     my $wha = $1 if ar.m && ar.m->[-1] =~ /^&(.+)$/ && pop @{ar.m};
     # squiggly time reconvogation
     # golden mean swivels
     my $o = Rw pul + name style+;
     if (o.name) {
         $oJ = oJ.oJ->{o.name} || do {
             Rw JJJJ $J:oJ $o;
         };
     }
     if ($wha) {
         Rw $wha + $J:oJ;
     }
     $oJ;
     
 - K: adJ #c embed J & GO AROUND
   D: |
     Rw join/in $J;
     J.name || die;
     J.r && die;
     ar.noround ||
     Rw around $J;
 - K: J5 #c & Jmod cs like, resume/resync by name, JJJ underneath, hits */around (update or up) 
   D: |
     my $o = Rw pul + name style+;
     my $J = G.oin.bb->{o.name."\t0.3"};
     my $is = " *&*" if $J;
     
     sayyl " JJJJJ  o.name$is";
     if (!ar.q) {
         $J ||= Rw JJJ $o $noround=1;
         ar.noround ||
         Rw around + $J;
     }
     
     $J
 - K: JJJJ #c J.oJ.$name = $J2   and  J2.Jo = $J
   D: |
     die unless G.oin;
     my $J2 = Rw JJ;
     J2.most.J = $J;
     J2.Jo = $J; 
     J.oJ->{J2.name} = $J2;
     sayyl "J J J J  J2.name" if J2.name ne 'A';
     $J2;
 - K: JJJ #c G.oin embedding spawn # 3 = REPLACEY, see J5 for ambient arounding
   D: |
     my $J = Rw JJ;
     sayyl " J J J   J.name";
     Rw adJ + $J;
     $J
 - K: JJ #c make J that most.J = self
   D: |
     my $J = {};
     my $o = ar.o ||
         Rw pul + name style+;
     J.name = o.name;
     
     o.style = join ' ', @{o.style} if ref o.style;
     delete o.name if o.name =~ /\./;
     J.style = o.style || o.name;
     J.style = [split /\s+/, J.style] if !ref J.style;
     J.most.J = $J;
     
     Rw mkJid $J;
     
     Rw suJ $J;
     
     Rw Jup $J;
     
     $J
 - K: Jup #c behaviouriser (lingo)
   D: |
     unshift @{J.style}, J.name
         if J.name !~ /\./ && !grep{$_ eq J.name} @{J.style};
     
     J.yt = {};
     J.yy = {};
     my $en = sub {
         my $s = shift;
         J.yt->{$s} ||= do { acum J.yy => styleord => $s; {} };
     };
     my $exp;$exp = sub {
         my $s = shift;
         my @wk = uniq
             grep{length} map {split /\s+/}
             Rw suck + $pin=$s/yJ; 
         $en->($s);
         for my $k (@wk) {
             next if exists J.yt->{$k}; # many styles leading to the same style
             $en->($k);
             $exp->($k);
         }
     };
     $exp->($_) for @{J.style};
     warn "no style for   @{J.style}   (J.name)" if !%{J.yt};
     if (0 && J.name ne 'A') {
         saygr "J.name yJup: ".join(' + ', @{J.style})
            ." -> ".join(' ~ ', sort keys %{J.yt});
     }
 - K: up #c
   D: |
     Rw suck + */up;
 - K: around #c
   D: |
     inter({Jname=>ar.J.name}) if ref ar.J;
     my $tw = Rw huck + */around;
     
     if (!$tw) {
        Rw up +;
        Rw out +;
     }
     
     saygr "around ! J.name ".F_delta()
     unless J.name eq 'wu';
     # try return stuff? pretty aroundo
     @{(values %$tw)[0]} if $tw
 - K: out #c
   D: |
     Rw suck + */out;
 - K: in #c
   D: |
     Rw huck + */in
     ||
     Rw around +;

