R_Jz:
 - K: pul #c pulk # parses list of things from an $m (now $cs) using $m scheme, each could be named in $ar
   D: |
     my $o = {};
     my $csm = [@{ar.cs||[]}];
     for my $n (@$m) {
         # can type things along
         if (defined $ar->{$n}) {
             $o->{$n} = $ar->{$n};
             next;
         }
         my $v = shift @$csm;
         if ($n =~ s/{\+}// && ref $v eq 'HASH') {
             %$o = (%$o, %$v); # other abouts spill off cv modi
         }
         else {
             $o->{$n} = $v;
         }
     }
     $o
 - K: suck #c inhaling pins - reading indexes made from codey vectors (way!) - all the way down to findl vvvv
   D: |
     #saygr "Got a J!".ar.J->pi."  @{ar.m}" if ar.J;
     my @ps = Rw fi +;
     my @wo;
     for my $p (@ps) {
         my ($dp) = split '/', $p; # domepiece (K) must be in our Jytterspace
         next if !ar.pin && ar.J && !ar.J.yt->{$dp};
         push @wo, w $R $p;
     }
     @wo
     
 - K: huck #c
   D: |
     my @ps = Rw fi +;
     my $tw;
     for my $p (@ps) {
         my ($dp) = split '/', $p; # domepiece (K) must be in our Jytterspace
         next if !ar.pin && ar.J && !ar.J.yt->{$dp};
         my @wo = w $R $p;
         $tw->{$p} = \@wo;
     }
     $tw
     
 - K: muck #c
   D: |
     my $tw = Rw wuck +;
     for my $k (keys %$tw) {
         my $v = $tw->{$k};
         die "notar" if ref $v ne 'ARRAY';
         $tw->{$k} = dclone $v
     }
     $tw
     
 - K: wuck #c return path=>strings for static way to memoize, instead of exec+dump
   D: |
     my @ps = Rw fi +;
     my $tw;
     for my $p (@ps) {
         my ($dp) = split '/', $p; # domepiece (K) must be in our Jytterspace
         next if !ar.pin && ar.J && !ar.J.yt->{$dp};
         my $str = R.way->find($p);
         $tw->{$p} = $str;
     }
     $tw
     
 - K: buck #c return path way, to avoid suck $m going down
   D: |
     my @ps = Rw fi +;
     my $tw;
     for my $p (@ps) {
         my ($dp) = split '/', $p; # domepiece (K) must be in our Jytterspace
         next if !ar.pin && ar.J && !ar.J.yt->{$dp};
         $tw = $p;
     }
     $tw
     
 - K: fi #c
   D: |
     my %wo = Rw findl +;
     map { s/^\///; $_ } keys %wo; 
     
 - K: fund #c
   D: |
     my $tw = {};
     for my $way (@{G.ways}) {
         my ($point,$Cs) = Rw findl $h:way $p;
         next if !$point;
         $tw->{way._wayfile} = $Cs;
         #sayyl " ways: ".join("  ", map {_.K} @$Cs);
     }
     $tw
 - K: findl #c
   D: |
           my $point = ar.p || ar.pin || ar.m->[0];
           my @path = split /\/|\./, $point;
           my $h = ar.h || R.way;
           $h = h.hooks if h.hooks;
           
           my $doig;
           $doig = sub {
               my ($p,$h,$s) = @_;
               my @a = @$p;
               
               return $s => $h if !@a; 
               
               ($p) = shift @a;
               
               return undef if !ref $h;
               
               if (exists $h->{$p}) { 
                   $h = $h->{$p};
                   return $doig->([@a],$h,"$s/$p");
               }
               else {
                   if ($p =~ /^(.*)\*(.*)$/) {
                       my ($l,$r) = ($1, $2);
                       my $ma = join '.+', split /\*/, $p;
                       my @ke = grep { /^$l.+$r$/ } keys %$h;
                       my @wu;
                       for my $tk (@ke) {
                           push @wu, $doig->([@a], $h->{$tk}, "$s/$tk");
                       }
                       @wu = grep {defined} @wu;
                       return @wu;
                   }
                   else {
                       return undef;
                   }
               }
           };
           
           grep {defined} $doig->([@path], $h, '');
 - K: delbbl #c
   D: |
     my $ip = {l => $l};
     delete J.bb->{_.r} for
     Rw tvo $J $ip;
 - K: ytv #c sort by voltage making cityscape, things only
   D: |
     my $tvs;
     map{
         push @{ar.ord}, $_ if ar.ord;
           push @{$tvs->{_.cv}||=[]}, $_
       }
       sort{ a.r cmp b.r }
       grep{ _.t eq _.l } # things onlyness
       map{ w $R shj(r=>$_,J=>$J); }
       keys %{J.bb};
     $tvs;
 - K: tvo #c sort by voltage making cv,r ordered list
   D: |
     sort { a.cv <=> b.cv }
       sort{ a.r cmp b.r }
       grep { !ar.ip || $G->ip(ar.ip => $_) }
       map{ w $R shj(r=>$_,J=>$J); }
       keys %{J.bb};
 - K: tvy #c group tvo by thing ..... style
   D: |
      my @d = Rw tvo $J;
      
      my @things;
      while (@d) {
          my $th = shift @d;
          
          my $thing = [$th];
          
          push @$thing, shift @d
              while @d && $d[0]->{l} eq th.l;
          
          if ($th && th.l ne th.t) {
              my @plan;
              for (@$thing) {
                  # somehow plan to hide things from yourself
                  # <> > <>
                  # <> > <>
                  # <> > <>
                  # <> > <>
                  # <> > <>
                  # <> > <>
                  # TODO conroll polai
              }
              if (@plan != @$thing) { # unknown and thingless style action
                  #sayre "style no tip th.r", map { "   _.r     =". gp _.s } @$thing;
                  unshift @$thing, undef;
              }
              for (@plan) {
                   # TODO how it likes to get together? this set somewhere else
              }
          }
          
          push @things, $thing;
          
      }
      @things
 - K: tly #c { index  of (j.l#com)/ %style = $j  or as above
   D: |
      my @d = Rw tvo $J;
      
      my $tks;
      for my $d (@d) {
          my $pl = "d.l#d.com d.cv";
          my $fl = d.style||'';
          if (ar.comfl) { # com stuctury ^ or com floating in with style v
              $pl = "d.l d.cv";
              $fl .= "#d.com" if d.com;
          }
          $tks->{$pl}->{$fl} = $d;
      }
      
      my $tw;
      for my $tk (sort keys %$tks) {
          my $ks = $tks->{$tk};
          if (!$ks->{''}) {
              warn "no j on $tk ".wdump($ks).wdump(1,$tks);
              next;
          }
          my $j = delete $ks->{''};
          
          my $x;
          x.j = $j;
          if (keys %$ks) {
              x.sc = {map{ $_ => $ks->{$_}->{s} } keys %$ks};
              
              x.sj = {map{ $_ => $ks->{$_} } keys %$ks};
          }
          $tw->{$tk} = $x;
      }
      $tw
 - K: tyv #c { index of (j.l) / %style#com = $j
   D: |
     my $comfl = 1;
     Rw tlv + $comfl;
 - K: tlv #c { index line thing.r: $j, styles made into an $sc }
   D: |
      my $tw = Rw tly;
      
      my $cvtk;
      for my $tk (keys %$tw) {
          my $j = $tw->{$tk}->{j} || die " not thingy $tk";
          $cvtk->{j.cv}->{$tk} = $tw->{$tk};
      }
      my $lvs = [];
      for my $cv (sort keys %$cvtk) {
          my $vtk = $cvtk->{$cv};
          for my $tk (sort keys %$vtk) {
              push @$lvs, $vtk->{$tk};
          }
      }
      $lvs
 - K: ship #c l to di ydly - look on a line for yay styles
   D: |
     my $r = delete ar.r;
     my $m = delete ar.m;
     my $stz = {map{$_ => 1}@$m};
     
     my $ip = {%$ar}; 
     delete $ip->{$_} for qw'J R';
     
     my @junk = Rw tvo $J $ip;
     r.junk = \@junk;
     # or so
     my (@path) = grep { $stz->{_.style} } @junk; 
     r.path = \@path;
     if (@$m > 1) {
        my $ps = {};
        acum $ps, _.style, $_ for @path;
        @path = map { $ps->{$_} || [] } @$m;
     }
     @path;
        
 - K: Jun #c find named J, may return nothing - BS golf carts
   D: |
     my $n = Rw Jung;
     my $name = ar.name || ar.m->[0];
     say "Jun looking for $name ... ".$n->{$name};
     say "Juns: ".join', ', sort keys %$n;
     $n->{$name};
 - K: Jon #c replace namedo 
   D: |
     my $oJ = Rw Jun $name;
     $oJ ||
     Rw hiJ +;
 - K: Jung #c find all J
   D: |
     my @aw = K J;
     @aw = grep { !_.A.u_tent } @aw;
     my $na;
     map {
         my $name = _.name;
         $name =~ s/-J\d+$//;
         $na->{$name} && die "rep of $name";
         $na->{$name} = $_;
     } @aw;
     $na
 - K: Jux #c goto: muxes
   D: |
     my $J = Rw Jun;
     $J || die 'no';
     Rw Jpunt + $J;
     $J;
 - K: Jix #c goto: if ! then make it up
   D: |
     my $J = Rw Jun;
     if (!$J) {
         say "No Jix ..... HiJiNG!";
         $J = Rw hiJ +;
     }
     Rw Jpunt + $J;
     $J;
 - K: Jpunt #c gou
   D: |
     if (ar.in || ar.r) { 
         my $r = ar.in? {i=>ar.in} : ar.r;
         Rw inness $J $r;
     }
     else {
         w mux(u=>$J);
     }
 - K: jin #c +GOTO, replaces J: find name->del->hiJ
   D: |
     my $m = ar.m ||= [];
     my $name = ar.name ||= ar.m->[0];
     
     my $jo = Rw Jon $name;
     if ($jo) {
         Rw Jundel $name;
         my $u = $jo;
         sayre " - udel ".$u->pi;
         w G.R del[$u];
     }
     my $J = Rw hiJ +;
     
     Rw Jpunt + $J;
     $J;
 - K: Jundel #c ye
   D: |
     my $u = Rw Jun $name;
     sayre "Jungel $name  ($u)";
     $u || return;
     w G.R del[$u];
 - K: hiJ #c add to space # ipv6 goes in
   D: |
     my $u = ar.u ||= {};
     my @m = @{ar.m||[]};
     my $name = ar.name ||= u.name || shift @m;
     
     push @m, $name if !@m; # def style = name
     
     u.name ||= $name;
     u.nam = u.name;
     u.name .=  "-J".G.jumb.Jnumb++; # additively, paranoid # individualise
     u.style = [@m];
     
     my $J = Rw makeJ $u;
     J.noJid = 1;
     J.most.J = $J;
     
     Rw Jup $J;
     
     sayyl $_ for "---","--- hiJ    ".$J->pi,"---";
     
     w mux(u=>$J);
     
     $J
 - K: makeJ #c
   D: |
     u.K ||= 'J';
     u.name || die;
     #life J $u    # carbon
     # ^ babz to:
     my $J = w G.R fuu[$u];
     # ^ has flows_D to suJ, only first time
     $J
 - K: hamz #c C-REATIVE ZIPY
   D: |
      my $b = shift @$m;
      my $as;
      $b eq 'style' ? do {
          $as = {K=>$b, B=>{am=>shift @$m}};
        die "gotmhamz" if @$m;
      } :
      do {
          die "unknown $b     @$m ";
      };
      w G.R fuu(u=>$as);

