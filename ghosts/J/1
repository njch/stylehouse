R_Jz:
  - K: setup #c
    D: |
      my $a = S.a = {};
      w $R phat[$a];
  - K: phat #c sets up $a with bb-domin & accessors
    D: |
        a.bb = {};
        a.ord = [];
        a.bz = w $R as(bb=>a.bb, ord=>a.ord);
        a.fro = sub {
            my $fro = [a.bz, @_];
            w $R gpfro(a=>$fro);
        };
  - K: as #c get abulator
    D: |
        #my $bb = shift;
        #my $ord = shift;
        my $j = {};
        my $do;
        $do = sub {
            my $j = {%$j};
            my $ad = [@_];
            my %j = %$j;
            while (@$ad) {
                my ($k, $v) = (shift @$ad, shift @$ad);
                
                my $comp = $k =~ /^(%|\+)/;
                my $j = {%j} if $comp;
                if ($comp) {
                    $k =~ s/^\+// if $comp;
                    j.t .= $k if $comp;
                }
                else {
                    (j.t, j.cv) = split /\s+/, $k, 2;
                    %j = %$j;
                }
                j.cv || die;
                j.r = "j.t j.cv";
                j.s = $v;
                $bb->{j.r} = j.s;
                push @$ord, {%$j} if $ord;
            }
            sub{$do->(%$j, @_)}
        };
        $do
  - K: shj #c pronounce $j{r,s,t,cv,ev} from given $r and $d # post abulator but similar
    D: |
      my ($r, $d) = @_;
      my $j;
      j.r = $r;
      j.s = ref $d eq 'HASH' ? $d->{$r} : $d; # carbon in
      (j.t, j.cv) =
          j.r =~ /^(.+)\t(.+?)$/ ? ($1, $2)
          :
          split /\s+/, j.r, 2;
      (j.cv, my @e) = split /\s+/, j.cv;
      j.ev = \@e if @e;
      $j
  - K: gpfro #c fatten, by
    D: |
      my ($aser, $l, $u, $cv, @etc) = @$a;
      
      my $gp = {u=>$u, cv=>$cv};
      %$gp = (%$gp, %{delete gp.cv}) if ref gp.cv;
      
      my $v = w $R gp(a => $gp);
            
      $aser->($l => $v,
          '%gp' => $gp,
          @etc,
      );
    

