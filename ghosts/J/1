R_Jz:
 - K: setup #c sets up $a with bb-domin & accessors
   D: |
     S.bb = {};
     S.ord = [];
     S.bz = w $R as(bb=>S.bb, ord=>S.ord);
     
     S.fro = sub {
         my $fro = [S.bz, @_];
         my $also = { Jiter => $S };
         w G.theR gpfro(a=>$fro,also=>$also);
     };
     
 - K: gpfro #c .fro(...) -> Rw gp $a
   D: |
      my ($aser, $l, $u, $cv, @etc) = @$a;
      
      my $gp = {u=>$u, cv=>$cv};
      %$gp = (%$gp, %{delete gp.cv}) if ref gp.cv;
      %$gp = (%$gp, %{ar.also}) if ar.also;
      
      my $v = w $R gp(a => $gp);
            
      $aser->($l => $v,
          '%gp' => $gp,
          @etc,
      );
    
 - K: gp #c R_sur gp # another little con tent, backeting a harmonic sur-ish portal
   D: |
        G.gp_inarow++;
        my $a = ar.a || die;
        # usuall comes in on a:
        die "ref cv stilla t gp" if ref a.cv;
        %$a = (%$a, %{delete a.cv}) if ref a.cv; # sneak params in...
        a.cv = 0.1 if a.cv < 0.1;
        
        my $u = a.u;
        
        # 3
        $R->phat($a);
        
        a.isJid = a.replaceJid || $H->mkuid;
        undef a.isJid if G.gp_inarow > 1;
        
        my $c = $R->cgp($u);
        
        # 4
        my $wa = a.wa || do {
            my ($wa) = grep { $c->{$_} } qw'canpi ARRAY HASH ref undef text';
            $wa = ref $u if $wa eq 'canpi';
            $wa ||= 'wtf';
            $wa
        };
        R.way->find("pi/$wa") || die "not $wa equip";
        
        # 5

        # 6
        w $R pi/$wa[$a,$u];
        
        # 7
        my $html = w $R maka[$a,$u];
        # don't need to close it up right now...
        # top down injection gos
        
        
        # 8
        
        # 9
        G.gp_inarow--;
        my $ind = join "", ("  ") x scalar @F;
        #sayyl "$ind Done gp for $u ".F_delta;
        $html
        
 - K: hiJ #c
   D: |
     my $r;
     r.name = shift @$m;
     r.name .=  "-J".G.Jnumb++; # additively, paranoid
     r.style = [@$m];
     
     my $J = Rw makeJ $r;
     
     Rw Jup $J;
     
     waylay mux(u=>$J);
     
     $J
 - K: makeJ #c
   D: |
      my $r = ar.r || $ar;
      my $u = {K=>'J',%$r}; 
      u.name ||= "J".G.Jnumb++; # additively
      my $q = 1;
      my $J = w G.R fuu[$u, $q];
      
      sayyl "made ++ ".$J->pi;
      $J
 - K: Jup #c
   D: |
     my $style = J.style;
     my @style = map {
         saygr "J.name seeking $_...";
         my $p = "$_/styJup";
         Rw suck - $p,
         #Rw suck - */styJup/$_,
        } @$style;
     saygr "J.name styJupd: @style";
     
      J.yt = { map{$_=>1} @style};
       
     "J".G.Jnumb++; # additively

 - K: JL #c make L bracket
   D: |
      my $u = {K=>'L',%{ar.r || {}}}; 
      u.name ||= "L:J.name:".G.Lnumb++; # additively
      my $q = 1;
      my $L = w G.R fuu[$u, $q];
      sayyl "made ++ ".$L->pi;
      $L
 - K: as #c get abulator # TODO sink hashy hooks all over # TODO should chain, broke
   D: |
       my $j = {};
       my $do;
       $do = sub {
           my $j = {%$j};
           my $ad = [@_];
           my %j = %$j;
           while (@$ad) {
               my ($k, $v) = (shift @$ad, shift @$ad);
               
               my $comp = $k =~ /^(%|\+)/;
               my $j = {%j} if $comp;
               if ($comp) {
                   $k =~ s/^\+// if $comp;
                   j.t .= $k if $comp;
               }
               else {
                   (j.t, j.cv) = split /\s+/, $k, 2;
                   %j = %$j;
               }
               defined j.cv || die "NOSEYV: j.cv".wdump($j);
               j.r = j.t."\t".j.cv;
               j.s = $v;
               
               $bb->{j.r} = j.s;
               push @$ord, {%$j} if $ord;
           }
           sub{$do->(%$j, @_)} # TODO fucked, get some weed and fix it
       };
       $do
 - K: shj #c pronounce $j{r,s,t,l,com?,style?,cv,ev?} # to cache or something, is phasey
   D: |
     my $j;
     j.r = $r;
     j.s = ar.C || ar.d->{$r}; # carbon in, or from abdomin
     (j.t, j.cv) =
         j.r =~ /^(.+)\t(.+?)$/ ? ($1, $2)
         :
         split /\s+/, j.r, 2;
         
     my $t = j.t; # sep orthoogabooga
     j.com = $1 if $t =~ s/#(.+)$//;
     j.style = $1 if $t =~ s/%(.+)$//;
     j.l = $t;
     
     (j.cv, my @e) = split /\s+/, j.cv;
     j.ev = \@e if @e;
     $j
 - K: ytv #c sort by voltage making cityscape, things only
   D: |
     
     my $tvs;
     map{
         push @{ar.ord}, $_ if ar.ord;
           push @{$tvs->{_.cv}||=[]}, $_
       }
       sort{ a.r cmp b.r }
       grep{ _.t eq _.l } # things onlyness
       map{ w $R shj(r=>$_,d=>J.bb); }
       keys %{J.bb};
     $tvs;
 - K: tvo #c sort by voltage making cv,r ordered list
   D: |
     sort { a.cv <=> b.cv }
       sort{ a.r cmp b.r }
       map{ w $R shj(r=>$_,d=>J.bb); }
       keys %{J.bb};
 - K: tvy #c group tvo by thing with style
   D: |
      my @d = w $R tvo[$J]; # !style||com
      my @things;
      while (@d) {
          my $ne = shift @d;
          die wdump(1, $ne) if ne.l ne ne.t; # style no tip

          my $thing = [$ne];
          while (@d && $d[0]->{l} eq ne.l) {
              my $sj = shift @d;
              push @$thing, $sj;
          }
          push @things, $thing;
      }
      @things

