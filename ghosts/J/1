R_Jz:
 - K: poke #c
   D: |
     my @w;
         push @w, "Yheaps";
         push @w, Rw suck */curves;
         
         w pv(i=>\@w);
 - K: suck #c inhaling pins
   D: |
     #saygr "Got a J!".ar.J->pi."  @{ar.m}" if ar.J;
     my @ps = Rw fi +;
     my @wo;
     for my $p (@ps) {
         my ($dp) = split '/', $p; # domepiece (K) must be in our Jytterspace
         next if !ar.pin && ar.J && !ar.J.yt->{$dp};
         push @wo, w $R $p;
     }
     @wo
     
 - K: huck #c
   D: |
     my @ps = Rw fi +;
     my $tw;
     for my $p (@ps) {
         my ($dp) = split '/', $p; # domepiece (K) must be in our Jytterspace
         next if !ar.pin && ar.J && !ar.J.yt->{$dp};
         my @wo = w $R $p;
         $tw->{$p} = \@wo;
     }
     $tw
     
 - K: muck #c
   D: |
     my $tw = Rw wuck +;
     for my $k (keys %$tw) {
         my $v = $tw->{$k};
         die "notar" if ref $v ne 'ARRAY';
         $tw->{$k} = dclone $v
     }
     $tw
     
 - K: wuck #c return path=>strings for static way to memoize, instead of exec+dump
   D: |
     my @ps = Rw fi +;
     my $tw;
     for my $p (@ps) {
         my ($dp) = split '/', $p; # domepiece (K) must be in our Jytterspace
         next if !ar.pin && ar.J && !ar.J.yt->{$dp};
         my $str = R.way->find($p);
         $tw->{$p} = $str;
     }
     $tw
     
 - K: fi #c
   D: |
     my %wo = Rw findl +;
     map { s/^\///; $_ } keys %wo; 
     
 - K: fund #c
   D: |
     my $tw = {};
     for my $way (@{G.ways}) {
         my ($point,$Cs) = Rw findl $h:way $p;
         next if !$point;
         $tw->{way._wayfile} = $Cs;
         sayyl " ways: ".join("  ", map {_.K} @$Cs);
     }
     $tw
 - K: findl #c
   D: |
           my $point = ar.p || ar.pin || ar.m->[0];
           my @path = split /\/|\./, $point;
           my $h = ar.h || R.way;
           $h = h.hooks if h.hooks;
           
           my $doig;
           $doig = sub {
               my ($p,$h,$s) = @_;
               my @a = @$p;
               
               return $s => $h if !@a; 
               
               ($p) = shift @a;
               
               return undef if !ref $h;
               
               if (exists $h->{$p}) { 
                   $h = $h->{$p};
                   return $doig->([@a],$h,"$s/$p");
               }
               else {
                   if ($p =~ /^(.*)\*(.*)$/) {
                       my ($l,$r) = ($1, $2);
                       my $ma = join '.+', split /\*/, $p;
                       my @ke = grep { /^$l.+$r$/ } keys %$h;
                       my @wu;
                       for my $tk (@ke) {
                           push @wu, $doig->([@a], $h->{$tk}, "$s/$tk");
                       }
                       @wu = grep {defined} @wu;
                       return @wu;
                   }
                   else {
                       return undef;
                   }
               }
           };
           
           grep {defined} $doig->([@path], $h, '');
 - K: suJ #c a sudo J, %{ r:sets up $a (J or not quite J hash $a, phro etc) with bbdomin stuff
   D: |
     J.bb = {};
     J.ord = [];
     J.bz = Rw as $J;
     J.phy = {};
     J.phl = {};
     
     # PHASE JOINT
     # in time
     # to trace patches of intent back up to entropiators
     
     # carbon projection
     
     # so then %Joint knows when comparing at corner of con tent
     # what to ....
     #  eg ongoing wont need to regeo the hull much,
     #     will see new things with %Joint and that gives way
     #     to more code about things
     # know about one thing in each place ness
     
     J.idyl = sub {
         my ($J, $id, $oj) = @_;
         J.Jmost.idly->{$id} = {J=>$J, j=>$oj};
     };
     
     my $by = sub {
         my $that = shift;
         sub {
             my $j = {etc=>[]};
             (j.r, j.s, @{j.etc}) = @_;
             j.Jiter = $J; # easy reverse
             # drifter, expecting 8 (forks & events) approp.
             # this is a tent it is
             j.Jmost = J.Jmost;
             Rw suJ $J:j;
             $that->($j); 
         };
     };
     
     J.fo = sub {
         my $m = [@_];
         my $j = Rw spinash $J;
         Rw fo $J:j $m;
     };
     
     # 3
     # 4
 - K: spinash #c J chund
   D: |
     my $j;
     j.Jiter = $J; # erse rev
     j.Jmost = J.Jmost;
     # ^ outside v self
     Rw suJ $J:j;
     $j
     
 - K: foid #c
   D: |
     J.isJid = J.replaceJid || $H->mkuid; # convert
     undef J.isJid if G.jumb.gp_inarow > 1; # to
     J.idyl->($J, J.isJid) if J.isJid; # /%id stuff
 - K: fo #c gp in 3d 
   D: |
     (J.u, J.cv) = @$m;
     # cv 
     die "could be anything" if ref J.cv;
     J.cv = 0.1 if J.cv < 0.1;
     
     # give it %id, flux in cache of Jmost
     J bz / 0.9 "y"
     
     # 2
     Rw foid;
     # 3
     my $pia = Rw fopathd $J;
     
     # TODO J pass overhead, ping off impressions
     # maka suction
     # don't need to close it up right now...
     # top down injection goss
     
     # 5 forking swivel injecty redis, etc etc
     # set up more consciously the stylepliers of 5
     
     # 6
     my $u = J.u;
     Rw $pia $J $u;
     
     Rw oldschool $J;
     
     # 7 TRACTOR BLEED
     J.s = Rw maka $J $u;
     # can pin/ping light source of con
     
     # 8
     
     # 9
     $J
     
 - K: fopathd #c
   D: |
     my $u = J.u;
     my $wa = J.wa || do {
         J.c = $R->cgp($u);
         # ^
         
         # v
         my ($wa) = grep { J.c->{$_} } qw'canpi ARRAY HASH ref undef text';
         $wa = ref $u if $wa eq 'canpi';
         $wa ||= 'wtf';
         $wa;
     };
     # can stick $wa on J.wa for thrashing maths
     # funcy fuzz fields
     # mutating spiral code
     
     R.way->find("pi/$wa") || die "not $wa equip"; # more
     return "pi/$wa";
     
 - K: pha #c temporal phatness
   D: |
     my $name = ar.k || shift @{ar.m};
     
     if (my $xx = J.phy->{$name}) {
         # re endtrant
         xx.end->();
         # end - maybe new stuffright as some random part of this process
     }
     for my $outx (grep {_.outsidey} values %{J.phy}) {
        # something? # perhaps a non, fire when no other phy
     }
     
     J.phy ||= {}; # phases
     
     my $x = J.phy->{$name} = {
        begin => hitime(),
        name => $name,
        bb => {},
        ord => [],
        tim => {},
        wtf => {},
     };
     x.head = J.phl->{$name}->{l}->[-1] if J.phy->{$name};
     x.abandon = sub {
         my $why = shift;
         delete J.phy->{$name};
         x.abadoned = $why || 1;
         if (my $xx = x.head) {
             # probably dont want to lie here but...
             (x.bb,x.ord,x.tim,x.wtf) = (xx.bb,xx.ord,xx.tim,xx.wtf);
         }
         x.end->();
     };
     x.end = sub {
         my $y = J.phl->{$name} ||= {name=>$name, l=>[]};
         x.ended = hitime();
         delete J.phy->{$name};
         push @{y.l}, $x;
         # layers ^ rolling in time index .r -> the y.l
         # so last phase of $name can be found?
         my $w = @{y.l};
         y.l_bb->{$_} = $w for keys %{x.bb};
         # somewhere thinks about what happened
         return $y;
     };
     # ensure phase reset with _after_do
     $x;
 - K: blabphys #c
   D: |
     say "Active phases:".(! %{J.phy} && " NONE");
     for my $x (values %{J.phy}) {
         say " - x.name:";
         say "  * $_    == x.bb->{$_}" for sort keys %{x.bb};
     }
 - K: from_phys #c
   D: |
     my $in = {};
     for my $y (values %{J.phl}) {
         if (exists y.l_bb->{$r}) {
             $in->{y.name} = y.l_bb->{$r};
         }
     }
     $in;
 - K: ph_exactl #c or drop not in last
   D: |
       my $wtf = ar.wtf || {};
       my $cur = wtf.cur = y.l->[-1];
       my $last = wtf.last = y.l->[-2];
       wtf.same = 1;
       if (!$last) { # better not get autovivified! 
           wtf.allnew = 1;
           wtf.same = 0;
           sayre "ph_exactl: all new";
           #return;
           last.bb = {};
       }
       #y.l_bb->{$_} = $w for keys %{x.bb};
       # churn stats like 30% of last disappear, 20% new
       
       for (sort keys %{cur.bb}) {
           if (!exists last.bb->{$_}) {
               sayre " + No $_ in last";
               wtf.new->{$_} = cur.bb->{$_};
               wtf.same = 0;
           }
           elsif (last.bb->{$_} ne cur.bb->{$_}) {
               sayre " != different $_ now";
               wtf.diff->{$_} = cur.bb->{$_};
               wtf.same = 0;
           }
       }
       
       for (grep { !exists cur.bb->{$_} } sort keys %{last.bb}) {
           sayre " - No $_ in current";
           wtf.gone->{$_} = last.bb->{$_};
           wtf.same = 0;
           delete J.bb->{$_};
       }
       
       my $gl = wtf.same ? "===" : "+-";
       sayre "ph_exactl: ". slim 50, join("  ",($gl) x 6);
       $wtf;
     
 - K: ph_defaff #c loop early exity if $d same
   D: |
     my $strung = ref $d ? wdump((ar.depth||3),$d) : $d;
     x.defaff_wd = $H->dig($strung);
     return 0 if !x.head;
     if (x.defaff_wd eq x.head.defaff_wd) {
         x.abandon->(say "defaff same dig");
         say "hey hey x.defaff_wd eq x.head.defaff_wd";
         return 1;
     }
     return 0;
 - K: as #c get abulator # TODO sink hashy hooks all over # TODO should chain, broke
   D: |
       my $j = {};
       my $do;
       $do = sub {
           my $j = {%$j};
           my $ad = [@_];
           my %j = %$j;
           while (@$ad) {
               my ($k, $v) = (shift @$ad, shift @$ad);
               
               my $comp = $k =~ /^(%|\+)/;
               my $j = {%j} if $comp;
               if ($comp) {
                   $k =~ s/^\+// if $comp;
                   j.t .= $k if $comp;
               }
               else {
                   (j.t, j.cv) = $k =~ /^(.+)\s+(.+?)$/;
                   %j = %$j;
               }
               defined j.cv || die "NOSEYV: j.cv".wdump($j);
               j.r = j.t."\t".j.cv;
               j.s = $v;
               
               my @Js = $J;
               push @Js, values %{J.phy} if J.phy;
               for my $jj (@Js) {
                   jj.bb->{j.r} = j.s;
                   push @{jj.ord}, {%$j} if jj.ord;
                   jj.tim->{j.r} = hitime() if jj.tim;
                   jj.wtf->{j.r} = $F[0] if jj.wtf;
               }
           }
           wantarray ? ($j, 
               sub{$do->(%$j, @_)} # TODO fucked, get some weed and fix it
           ) : $j
       };
       $do
 - K: shj #c pronounce $j{r,s,t,l,com?,style?,cv,ev?} # to cache or something, is phasey
   D: |
     my $j;
     j.r = $r; # TODO probly sameness
     die if ar.C;
     j.s = ar.C || (ar.J ? ar.J.bb : ar.d)->{$r}; # carbon in, or from abdomin
     (j.t, j.cv) =
         j.r =~ /^(.+)\t(.+?)$/ ? ($1, $2)
         :
         j.r =~ /^(.+)\s+(.+?)$/ ? ($1, $2) : die;
         
     my $t = j.t; # sep orthoogabooga
     j.com = $1 if $t =~ s/#([^\/]+)$//;
     j.style = $1 if $t =~ s/%([^\/]+)$//;
     j.l = $t;
     
     (j.cv, my @e) = split /\s+/, j.cv;
     die if @e;
     j.ev = \@e if @e;
     die if j.b;
     j.b.b.b = ar.d;
     $j
 - K: ytv #c sort by voltage making cityscape, things only
   D: |
     
     my $tvs;
     map{
         push @{ar.ord}, $_ if ar.ord;
           push @{$tvs->{_.cv}||=[]}, $_
       }
       sort{ a.r cmp b.r }
       grep{ _.t eq _.l } # things onlyness
       map{ w $R shj(r=>$_,d=>J.bb); }
       keys %{J.bb};
     $tvs;
 - K: tvo #c sort by voltage making cv,r ordered list
   D: |
     sort { a.cv <=> b.cv }
       sort{ a.r cmp b.r }
       grep { !ar.ip || $G->ip(ar.ip => $_) }
       map{ w $R shj(r=>$_,d=>J.bb); }
       keys %{J.bb};
 - K: tvy #c group tvo by thing with style
   D: |
      my @d = Rw tvo $J;
      
      my @things;
      while (@d) {
          my $th = shift @d;
          
          my $thing = [$th];
          
          push @$thing, shift @d
              while @d && $d[0]->{l} eq th.l;
          
          if ($th && th.l ne th.t) {
              my @plan;
              for (@$thing) {
                  # somehow plan to hide things from yourself
                  # <> > <>
                  # <> > <>
                  # <> > <>
                  # <> > <>
                  # <> > <>
                  # <> > <>
                  # TODO conroll polai
              }
              if (@plan != @$thing) { # unknown and thingless style action
                  #sayre "style no tip th.r", map { "   _.r     =". gp _.s } @$thing;
                  unshift @$thing, undef;
              }
              for (@plan) {
                   # TODO how it likes to get together? this set somewhere else
              }
          }
          
          push @things, $thing;
          
      }
      @things
 - K: tyv #c { index of (j.l) / %style#com = $j
   D: |
     my $comfl = 1;
     Rw tlv + $comfl;
 - K: tly #c { index  of (j.l#com)/ %style = $j  or as above
   D: |
      my @d = Rw tvo $J;
      
      my $tks;
      for my $d (@d) {
          my $pl = "d.l#d.com d.cv";
          my $fl = d.style||'';
          if (ar.comfl) { # com stuctury ^ or com floating in with style v
              $pl = "d.l d.cv";
              $fl .= "#d.com" if d.com;
          }
          $tks->{$pl}->{$fl} = $d;
      }
      
      my $tw;
      for my $tk (sort keys %$tks) {
          my $ks = $tks->{$tk};
          my $j = delete $ks->{''};
          die "no j on $tk ".wdump($ks).wdump(1,$tks) if !$j;
          my $sc = {map{ $_ => $ks->{$_}->{s} } keys %$ks};
          
          my $x = $tw->{$tk} = {};
          x.j = $j;
          x.sc = $sc if keys %$sc;
      }
      $tw
 - K: tlv #c { index line thing.r: $j, styles made into an $sc }
   D: |
      my $tw = Rw tly;
      
      my $cvtk;
      for my $tk (keys %$tw) {
          my $j = $tw->{$tk}->{j} || die " not thingy $tk";
          $cvtk->{j.cv}->{$tk} = $tw->{$tk};
      }
      my $lvs = [];
      for my $cv (sort keys %$cvtk) {
          my $vtk = $cvtk->{$cv};
          for my $tk (sort keys %$vtk) {
              push @$lvs, $vtk->{$tk};
          }
      }
      $lvs
 - K: ship #c l to di ydly
   D: |
     my $r = delete ar.r;
     my $m = delete ar.m;
     my $style = shift @$m;
     die if @$m;
     
     my $ip = {%$ar}; 
     delete $ip->{$_} for qw'J R';
     my @junk = Rw tvo $J $ip;
     r.junk = \@junk;
     # or so
     my (@path) = grep { _.style eq $style } @junk; 
     r.path = \@path;
     @path;
        

