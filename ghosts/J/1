R_Jz:

 - K: as #c get abulator # TODO sink hashy hooks all over # TODO should chain, broke
   D: |
       my $j = {};
       my $do;
       $do = sub {
           my $j = {%$j};
           my $ad = [@_];
           my %j = %$j;
           while (@$ad) {
               my ($k, $v) = (shift @$ad, shift @$ad);
               
               my $comp = $k =~ /^(%|\+)/;
               my $j = {%j} if $comp;
               if ($comp) {
                   $k =~ s/^\+// if $comp;
                   j.t .= $k if $comp;
               }
               else {
                   (j.t, j.cv) = split /\s+/, $k, 2;
                   %j = %$j;
               }
               defined j.cv || die "NOSEYV: j.cv".wdump($j);
               j.r = j.t."\t".j.cv;
               j.s = $v;
               
               $bb->{j.r} = j.s;
               push @$ord, {%$j} if $ord;
           }
           wantarray ? ($j, 
               sub{$do->(%$j, @_)} # TODO fucked, get some weed and fix it
           ) : $j
       };
       $do
 - K: shj #c pronounce $j{r,s,t,l,com?,style?,cv,ev?} # to cache or something, is phasey
   D: |
     my $j;
     j.r = $r;
     j.s = ar.C || ar.d->{$r}; # carbon in, or from abdomin
     (j.t, j.cv) =
         j.r =~ /^(.+)\t(.+?)$/ ? ($1, $2)
         :
         split /\s+/, j.r, 2;
         
     my $t = j.t; # sep orthoogabooga
     j.com = $1 if $t =~ s/#(.+)$//;
     j.style = $1 if $t =~ s/%(.+)$//;
     j.l = $t;
     
     (j.cv, my @e) = split /\s+/, j.cv;
     j.ev = \@e if @e;
     die if j.b;
     j.b.b.b = ar.d;
     $j
 - K: ytv #c sort by voltage making cityscape, things only
   D: |
     
     my $tvs;
     map{
         push @{ar.ord}, $_ if ar.ord;
           push @{$tvs->{_.cv}||=[]}, $_
       }
       sort{ a.r cmp b.r }
       grep{ _.t eq _.l } # things onlyness
       map{ w $R shj(r=>$_,d=>J.bb); }
       keys %{J.bb};
     $tvs;
 - K: tvo #c sort by voltage making cv,r ordered list
   D: |
     sort { a.cv <=> b.cv }
       sort{ a.r cmp b.r }
       grep { !ar.ip || $G->ip(ar.ip => $_) }
       map{ w $R shj(r=>$_,d=>J.bb); }
       keys %{J.bb};
 - K: tvy #c group tvo by thing with style
   D: |
      my @d = w $R tvo[$J]; # !style||com
      
      my @things;
      while (@d) {
          my $ne = shift @d;

          my $thing = [$ne];
          while (@d && $d[0]->{l} eq ne.l) {
              my $sj = shift @d;
              push @$thing, $sj;
          }
          
          my ($th) = @$thing;
          if ($th && th.l ne th.t) {
              sayre "style no tip ".wdump(1, $th),
                  "   bbr: ".join " ", map{_.r} @$thing;
              unshift @$thing, undef;
          }
          
          push @things, $thing;
          
      }
      @things

