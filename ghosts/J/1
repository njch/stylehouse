R_Jz:
 - K: setup #c sets up $a with bb-domin & accessors
   D: |
     saybl "setup ".$J->pi;
     Rw suJ $J;
 - K: suJ #c sets up $a (J or not quite J hash $a, phro etc) with bbdomin stuff
   D: |
     J.bb = {};
     J.ord = [];
     J.bz = w $R as(bb=>J.bb, ord=>J.ord);
     
     J.lev = sub { #TODO
         my $lev = {
            r => shift,
            sub => shift,
            etc => [@_],
            Jiter => $J, # drifter, expecting 8 (forks & events) approp.
        };
        Rw lplumb $a:lev;
     };
     J.fro = sub {
         my $fro = {
            r => shift,
            u => shift,
            cv => shift,
            etc => [@_],
            Jiter => $J, # drifter, expecting 8 (forks & events) approp.
        };
        Rw gp $a:fro;
     };
 - K: lplumb #c subby plumbing, like gp but seemingly uncomplicated here
   D: |
        Rw suJ $J:a;
        a.sub->($a);
        a.v = w G.theR maka[$a];
        a.Jiter.bz->(a.r => a.v,
            '%lp' => $a,
            @{a.etc||[]},
        );
 - K: gp #c R_sur gp # another little con tent, backeting a harmonic sur-ish portal
   D: |
        G.jumb.gp_inarow++;
        %$a = (%$a, %{delete a.cv}) if ref a.cv;
        a.cv = 0.1 if a.cv < 0.1;
        
        # 3
        Rw suJ $J:a;
        
        a.isJid = a.replaceJid || $H->mkuid;
        if (G.jumb.gp_inarow > 1) {
            undef a.isJid;
            say "            GP NON ORIGIN: ".gp(a.u);
        }
        a.Jiter.Jmost.gpa.pis->{a.isJid} = $a if a.isJid;
        # TODO J pass over # maka suction
        # don't need to close it up right now...
        # top down injection gos
        
        my $u = a.u;
        my $c = $R->cgp($u);
        
        # 4
        my $wa = a.wa || do {
            my ($wa) = grep { $c->{$_} } qw'canpi ARRAY HASH ref undef text';
            $wa = ref $u if $wa eq 'canpi';
            $wa ||= 'wtf';
            $wa
        };
        G.theR.way->find("pi/$wa") || die "not $wa equip";
        
        # 5 forking swivel injecty

        # 6
        w G.theR pi/$wa[$a,$u];
        
        
        # 7
        a.v = w G.theR maka[$a,$u];
        
        
        # 8
        
        # 9
        G.jumb.gp_inarow--;
        
        a.Jiter.bz->(a.r => a.v,
            '%gp' => $a,
            @{a.etc||[]},
        );
        
 - K: hiJ #c
   D: |
     my $r;
     r.name = shift @$m;
     r.name .=  "-J".G.jumb.Jnumb++; # additively, paranoid
     r.style = [@$m];
     
     my $J = Rw makeJ $r;
     
     Rw Jup $J;
     
     waylay mux(u=>$J);
     
     $J
 - K: makeJ #c
   D: |
      my $r = ar.r || $ar;
      my $u = {K=>'J',%$r}; 
      u.name ||= "J".G.jumb.Jnumb++; # additively
      my $q = 1;
      my $J = w G.R fuu[$u, $q];
      
      sayyl "made ++ ".$J->pi;
      $J
 - K: Jup #c
   D: |
     my $style = J.style;
     my @style = map {
         saygr "J.name seeking $_...";
         my $p = "$_/styJup";
         Rw suck - $p,
         #Rw suck - */styJup/$_,
        } @$style;
     saygr "J.name styJupd: @style";
     
      J.yt = { map{$_=>1} @style};
       
     "J".G.jumb.Jnumb++; # additively
 - K: JL #c make L bracket
   D: |
      my $u = {K=>'L',%{ar.r || {}}}; 
      u.name ||= "L:J.name:".G.jumb.Lnumb++; # additively
      my $q = 1;
      my $L = w G.R fuu[$u, $q];
      sayyl "made ++ ".$L->pi;
      $L
 - K: as #c get abulator # TODO sink hashy hooks all over # TODO should chain, broke
   D: |
       my $j = {};
       my $do;
       $do = sub {
           my $j = {%$j};
           my $ad = [@_];
           my %j = %$j;
           while (@$ad) {
               my ($k, $v) = (shift @$ad, shift @$ad);
               
               my $comp = $k =~ /^(%|\+)/;
               my $j = {%j} if $comp;
               if ($comp) {
                   $k =~ s/^\+// if $comp;
                   j.t .= $k if $comp;
               }
               else {
                   (j.t, j.cv) = split /\s+/, $k, 2;
                   %j = %$j;
               }
               defined j.cv || die "NOSEYV: j.cv".wdump($j);
               j.r = j.t."\t".j.cv;
               j.s = $v;
               
               $bb->{j.r} = j.s;
               push @$ord, {%$j} if $ord;
           }
           sub{$do->(%$j, @_)} # TODO fucked, get some weed and fix it
       };
       $do
 - K: shj #c pronounce $j{r,s,t,l,com?,style?,cv,ev?} # to cache or something, is phasey
   D: |
     my $j;
     j.r = $r;
     j.s = ar.C || ar.d->{$r}; # carbon in, or from abdomin
     (j.t, j.cv) =
         j.r =~ /^(.+)\t(.+?)$/ ? ($1, $2)
         :
         split /\s+/, j.r, 2;
         
     my $t = j.t; # sep orthoogabooga
     j.com = $1 if $t =~ s/#(.+)$//;
     j.style = $1 if $t =~ s/%(.+)$//;
     j.l = $t;
     
     (j.cv, my @e) = split /\s+/, j.cv;
     j.ev = \@e if @e;
     $j
 - K: ytv #c sort by voltage making cityscape, things only
   D: |
     
     my $tvs;
     map{
         push @{ar.ord}, $_ if ar.ord;
           push @{$tvs->{_.cv}||=[]}, $_
       }
       sort{ a.r cmp b.r }
       grep{ _.t eq _.l } # things onlyness
       map{ w $R shj(r=>$_,d=>J.bb); }
       keys %{J.bb};
     $tvs;
 - K: tvo #c sort by voltage making cv,r ordered list
   D: |
     sort { a.cv <=> b.cv }
       sort{ a.r cmp b.r }
       grep { !ar.ip || $G->ip(ar.ip => $_) }
       map{ w $R shj(r=>$_,d=>J.bb); }
       keys %{J.bb};
 - K: tvy #c group tvo by thing with style
   D: |
      my @d = w $R tvo[$J]; # !style||com
      my @things;
      while (@d) {
          my $ne = shift @d;
          die wdump(1, $ne) if ne.l ne ne.t; # style no tip

          my $thing = [$ne];
          while (@d && $d[0]->{l} eq ne.l) {
              my $sj = shift @d;
              push @$thing, $sj;
          }
          push @things, $thing;
      }
      @things

