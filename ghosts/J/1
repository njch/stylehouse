R_Jz:
 - K: pul #c pulk # parses list of things from an $m (now $cs) using $m scheme, each could be named in $ar
   D: |
     my $o = {};
     my $csm = [@{$F[2]->{ar}->{m} || []}]; # looks at one ar.m above
     for my $n (@$m) {
         # can type things along
         my $acumey = $n =~ s/\+$//;
         if (defined $ar->{$n}) {
             $o->{$n} = $ar->{$n};
             next;
         }
         my $v = shift @$csm;
         if ($n =~ s/{\+}// && ref $v eq 'HASH') {
             %$o = (%$o, %$v); # other abouts spill off cv modi
         }
         elsif ($acumey) {
             $o->{$n} ||= [$v, @$csm];
         }
         else {
             $o->{$n} = $v;
         }
     }
     $o
 - K: suck #c inhaling pins - reading indexes made from codey vectors (way!) - all the way down to findl vvvv
   D: |
     inter({Jname=>ar.J.name}) if exists ar.J;
     inter({pin=>ar.p || ar.pin || ar.m->[0]});
     #saygr "Got a J!".ar.J->pi."  @{ar.m}" if ar.J;
     my @ps = Rw fi +;
     my @wo;
     for my $p (@ps) {
         my ($dp) = split '/', $p; # domepiece (K) must be in our Jytterspace
         next if !ar.pin && ar.J && !ar.J.yt->{$dp};
         push @wo, w $R $p;
     }
     @wo
     
 - K: huck #c
   D: |
     inter({Jname=>ar.J.name}) if exists ar.J;
     inter({pin=>ar.p || ar.pin || ar.m->[0]});
     my @ps = Rw fi +;
     my $tw;
     for my $p (@ps) {
         my ($dp) = split '/', $p; # domepiece (K) must be in our Jytterspace
         next if !ar.pin && ar.J && !ar.J.yt->{$dp};
         my @wo = w $R $p;
         $tw->{$p} = \@wo;
     }
     $tw
     
 - K: muck #c
   D: |
     my $tw = Rw wuck +;
     for my $k (keys %$tw) {
         my $v = $tw->{$k};
         $tw->{$k} = ref $v ? dclone $v : $v;
     }
     $tw
     
 - K: wuck #c return path=>strings for static way to memoize, instead of exec+dump
   D: |
     my @ps = Rw fi +;
     my $tw;
     for my $p (@ps) {
         my ($dp) = split '/', $p; # domepiece (K) must be in our Jytterspace
         next if !ar.pin && ar.J && !ar.J.yt->{$dp};
         my $str = R.way->find($p);
         $tw->{$p} = $str;
     }
     $tw
     
 - K: fund #c
   D: |
     my $tw = {};
     for my $way (@{G.ways}) {
         my ($point,$Cs) = my @AW = Rw findl $h:way $p;
         next if !$point;
         my $k = way._wayfile;
         $k .= $1 if $point =~ /(#.+$)/;
         $tw->{$k} = ref $Cs && ar.dclone ? dclone $Cs : $Cs;
         # want one more tent? #om
         # tiny J piles of stuff to return
         # like the tyv family
     }
     $tw
 - K: buck #c return path way, to avoid suck $m going down
   D: |
     my @ps = Rw fi +;
     my $tw;
     for my $p (@ps) {
         my ($dp) = split '/', $p; # domepiece (K) must be in our Jytterspace
         next if !ar.pin && ar.J && !ar.J.yt->{$dp};
         $tw = $p;
     }
     $tw
     
 - K: fi #c
   D: |
     my %wo = Rw findl +;
     map { s/^\///; $_ } keys %wo; 
     
 - K: findl #c
   D: |
           my $point = ar.p || ar.pin || ar.m->[0];
           my @path = split /\/|\./, $point;
           my $h = ar.h || R.way;
           $h = h.hooks if h.hooks;
           
           my $doig;
           $doig = sub {
               my ($p,$h,$s) = @_;
               my @a = @$p;
               
               return $s => $h if !@a; 
               
               ($p) = shift @a;
               
               return undef if !ref $h;#ne 'HASH';
                   if (exists $h->{$p}) { 
                       $h = $h->{$p};
                       return $doig->([@a],$h,"$s/$p");
                   }
                   if ($p =~ s/\*/.+/sg) {
                       my @ke = grep { /^$p$/ } keys %$h;
                       my @wu;
                       for my $tk (@ke) {
                           push @wu, $doig->([@a], $h->{$tk}, "$s/$tk");
                       }
                       @wu = grep {defined} @wu;
                       return @wu;
                   }
                   else {
                       return undef;
                   }
           };
           
           grep {defined} $doig->([@path], $h, '');
 - K: loadup #c
   D: |
     my $pin = ar.p||ar.pin;
     my $ac = join'',map{"{$_"}split'/',$pin;
     $R->loadup($u, $ac, $n);
     
 - K: as #c get abulator # TODO sink hashy hooks all over # TODO should chain, broke
   D: |
       my $j = {};
       my $do;
       $do = sub {
           my $j = {%$j};
           my $ad = [@_];
           my %j = %$j;
           while (@$ad) {
               my ($k, $v) = (shift @$ad, shift @$ad);
               
               my $comp = $k =~ /^(%|\+)/;
               my $j = {%j} if $comp;
               if ($comp) {
                   $k =~ s/^\+// if $comp;
                   j.t .= $k if $comp;
               }
               else {
                   (j.t, j.cv) = $k =~ /^(.+)\s+(.+?)$/;
                   %j = %$j;
               }
               defined j.cv || die "NOSEYV: j.cv".wdump($j);
               j.r = j.t."\t".j.cv;
               j.s = $v;
               
               my @Js = $J;
               push @Js, values %{J.phy} if J.phy;
               for my $jj (@Js) {
                   jj.bb->{j.r} = j.s;
                   push @{jj.ord}, {%$j} if jj.ord;
                   jj.tim->{j.r} = hitime() if jj.tim;
                   jj.wtf->{j.r} = $F[0] if jj.wtf;
               }
           }
           wantarray ? ($j, 
               sub{$do->(%$j, @_)} # TODO fucked, get some weed and fix it
           ) : $j
       };
       $do
 - K: shj #c pronounce $j{r,s,t,l,com?,style?,cv,ev?} # to cache or something, is phasey
   D: |
     my $j;
     j.r = $r; # TODO probly sameness
     die if ar.C;
     ar.d = ar.J.bb if ar.J;
     j.s = ar.C || (ar.d)->{$r}; # carbon in, or from abdomin
     (j.t, j.cv) =
         j.r =~ /^(.+)\t(.+?)$/ ? ($1, $2)
         :
         j.r =~ /^(.+)\s+(.+?)$/ ? ($1, $2) : die;
         
     my $t = j.t; # sep orthoogabooga
     j.com = $1 if $t =~ s/#([^\/]+)$//;
     j.style = $1 if $t =~ s/%([^\/]+)$//;
     j.l = $t;
     
     (j.cv, my @e) = split /\s+/, j.cv;
     die if @e;
     j.ev = \@e if @e;
     die if j.b;
     unless (J.yl.nojb) {
         j.b.b.b = ar.d;
         j.b.b.j = ar.J if ar.J;
     }
     $j
 - K: delbbl #c
   D: |
     my $ip = {l => $l};
     delete J.bb->{_.r} for
     Rw tvo $J $ip;
 - K: ytv #c sort by voltage making cityscape, things only
   D: |
     my $tvs;
     map{
         push @{ar.ord}, $_ if ar.ord;
           push @{$tvs->{_.cv}||=[]}, $_
       }
       sort{ a.r cmp b.r }
       grep{ _.t eq _.l } # things onlyness
       map{ w $R shj(r=>$_,J=>$J); }
       keys %{J.bb};
     $tvs;
 - K: tvo #c sort by voltage making cv,r ordered list
   D: |
     #say "ipin: ".ki ar.ip if ar.ip;
     if (ar.l || ar.cv) {
         my $ip = ar.ip ||= {};
         ip.l = ar.l if exists ar.l;
         ip.cv = ar.cv if exists ar.cv;
     }
     sort { a.cv <=> b.cv }
       sort{ a.r cmp b.r }
       grep { !ar.ip || $G->ip(ar.ip => $_) }
       map{ w $R shj(r=>$_,J=>$J); }
       keys %{J.bb};
 - K: tva #c woos
   D: |
     my @js = Rw tvo +;
     [@js]
 - K: tvy #c group tvo by thing ..... style
   D: |
      my @d = Rw tvo $J;
      
      my @things;
      while (@d) {
          my $th = shift @d;
          
          my $thing = [$th];
          
          push @$thing, shift @d
              while @d && $d[0]->{l} eq th.l;
          
          if ($th && th.l ne th.t) {
              my @plan;
              for (@$thing) {
                  # somehow plan to hide things from yourself
                  # <> > <>
                  # <> > <>
                  # <> > <>
                  # <> > <>
                  # <> > <>
                  # <> > <>
                  # TODO conroll polai
              }
              if (@plan != @$thing) { # unknown and thingless style action
                  #sayre "style no tip th.r", map { "   _.r     =". gp _.s } @$thing;
                  unshift @$thing, undef;
              }
              for (@plan) {
                   # TODO how it likes to get together? this set somewhere else
              }
          }
          
          push @things, $thing;
          
      }
      @things
 - K: tly #c { index  of (j.l#com)/ %style = $j  or as above
   D: |
      my @d = Rw tvo;
      
      my $tks;
      for my $d (@d) {
          my $pl = "d.l#d.com d.cv";
          my $fl = d.style||'';
          if (ar.comfl) { # com stuctury ^ or com floating in with style v
              $pl = "d.l d.cv";
              $fl .= "#d.com" if d.com;
          }
          $tks->{$pl}->{$fl} = $d;
      }
      
      my $tw;
      for my $tk (sort keys %$tks) {
          my $ks = $tks->{$tk};
          if (!$ks->{''}) {
              my ($o) = values %$ks;
              warn "no j on $tk \t%% all style %%  ".join' ',sort keys %$ks;#.wdump(2,[map {_.r}grep { 1} @d]);
              next;
          }
          my $j = delete $ks->{''};
          
          my $x;
          x.j = $j;
          if (keys %$ks) {
              x.sc = {map{ $_ => $ks->{$_}->{s} } keys %$ks};
              
              x.sj = {map{ $_ => $ks->{$_} } keys %$ks};
          }
          $tw->{$tk} = $x;
      }
      $tw
 - K: tyv #c { index of (j.l) / %style#com = $lv(j,sc,sj,
   D: |
     my $comfl = 1;
     Rw tlv + $comfl;
 - K: tlv #c { index line thing.r: $j, styles made into an $sc }
   D: |
      my $tw = Rw tly;
      
      my $cvtk;
      for my $tk (keys %$tw) {
          my $j = $tw->{$tk}->{j} || die " not thingy $tk";
          $cvtk->{j.cv}->{$tk} = $tw->{$tk};
      }
      my $lvs = [];
      for my $cv (sort keys %$cvtk) {
          my $vtk = $cvtk->{$cv};
          for my $tk (sort keys %$vtk) {
              push @$lvs, $vtk->{$tk};
          }
      }
      $lvs
 - K: ship #c l to di ydly - look on a line for yay styles
   D: |
     my $r = delete ar.r;
     my $m = delete ar.m;
     my $stz = {map{$_ => 1}@$m};
     
     my $ip = {%$ar}; 
     delete $ip->{$_} for qw'J R';
     
     my @junk = Rw tvo $J $ip;
     r.junk = \@junk;
     # or so
     my (@path) = grep { $stz->{_.style} } @junk; 
     r.path = \@path;
     if (@$m > 1) {
        my $ps = {};
        acum $ps, _.style, $_ for @path;
        @path = map { $ps->{$_} || [] } @$m;
     }
     @path;
        
 - K: Jun #c find named J, may return nothing - BS golf carts
   D: |
     my $n = Rw Jung;
     my $name = ar.name || ar.m->[0];
     say "Jun looking for $name ... ".$n->{$name};
     say "Juns: ".join', ', sort keys %$n;
     $n->{$name};
 - K: Jon #c replace namedo 
   D: |
     my $oJ = Rw Jun $name;
     $oJ ||
     Rw hiJ +;
 - K: Jung #c find all J
   D: |
     my @aw = K J;
     @aw = grep { !_.A.u_tent } @aw;
     my $na;
     map {
         my $name = _.name;
         $name =~ s/-J\d+$//;
         if ($name !~ /J\d+-/) {
             $na->{$name} && die "rep of $name";
             $na->{$name} = $_;
         }
     } @aw;
     $na
 - K: Jux #c goto: muxes
   D: |
     my $J = Rw Jun;
     $J || die 'no';
     Rw Jpunt + $J;
     $J;
 - K: Jix #c goto: if ! then make it up
   D: |
     my $J = Rw Jun;
     if (!$J) {
         say "No Jix ..... HiJiNG!";
         $J = Rw hiJ +;
     }
     Rw Jpunt + $J;
     $J;
 - K: Jpunt #c gou
   D: |
     if (ar.in || ar.r) { 
         my $r = ar.in? {i=>ar.in} : ar.r;
         Rw inness $J $r;
     }
     else {
         w mux(u=>$J);
     }
 - K: jin #c +GOTO, replaces J: find name->del->hiJ
   D: |
     my $m = ar.m ||= [];
     my $name = ar.name ||= ar.m->[0];
     
     my $jo = Rw Jon $name;
     if ($jo) {
         Rw Jundel $name;
         my $u = $jo;
         sayre " - udel ".$u->pi;
         w G.R del[$u];
     }
     my $J = Rw hiJ +;
     
     Rw Jpunt + $J;
     $J;
 - K: Jundel #c ye
   D: |
     my $u = Rw Jun $name;
     sayre "Jungel $name  ($u)";
     $u || return;
     w G.R del[$u];
 - K: hiJ #c add to space # ipv6 goes in
   D: |
     my $u = ar.u ||= {};
     my @m = @{ar.m||[]};
     my $name = ar.name ||= u.name || shift @m;
     
     push @m, $name if !@m; # def style = name
     
     u.name ||= $name;
     u.nam = u.name;
     u.name .=  "-J".G.jumb.Jnumb++; # additively, paranoid # individualise
     u.style = [@m];
     
     my $J = Rw makeJ $u;
     J.noJid = 1;
     J.most.J = $J;
     
     Rw Jup $J;
     
     sayyl $_ for "---","--- hiJ    ".$J->pi,"---";
     
     w mux(u=>$J);
     
     $J
 - K: makeJ #c
   D: |
     u.K ||= 'J';
     u.name || die;
     #life J $u    # carbon
     # ^ babz to:
     my $J = w G.R fuu[$u];
     # ^ has flows_D to suJ, only first time
     $J

