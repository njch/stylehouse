R_Jz:
 - K: poke #c
   D: |
     my @w;
         push @w, "Yheaps";
         push @w, Rw suck */curves;
         
         w pv(i=>\@w);
 - K: suck #c
   D: |
     #saygr "Got a J!".ar.J->pi."  @{ar.m}" if ar.J;
     my @ps = Rw fi +;
     my @wo;
     for my $p (@ps) {
         my ($dp) = split '/', $p; # domepiece (K) must be in our Jytterspace
         next if !ar.pin && ar.J && !ar.J.yt->{$dp};
         push @wo, w $R $p;
     }
     @wo
     
 - K: fi #c
   D: |
     my %wo = Rw findl +;
     map { s/^\///; $_ } keys %wo; 
     
 - K: findl #c
   D: |
           my $point = ar.p || ar.pin || ar.m->[0];
           my @path = split /\/|\./, $point;
           my $h = ar.h || R.way;
           $h = h.hooks if h.hooks;
           
           my $doig;
           $doig = sub {
               my ($p,$h,$s) = @_;
               my @a = @$p;
               
               return $s => $h if !@a; 
               
               ($p) = shift @a;
               
               return undef if !ref $h;
               
               if (exists $h->{$p}) { 
                   $h = $h->{$p};
                   return $doig->([@a],$h,"$s/$p");
               }
               else {
                   if ($p =~ /^(.*)\*(.*)$/) {
                       my ($l,$r) = ($1, $2);
                       my $ma = join '.+', split /\*/, $p;
                       my @ke = grep { /^$l.+$r$/ } keys %$h;
                       my @wu;
                       for my $tk (@ke) {
                           push @wu, $doig->([@a], $h->{$tk}, "$s/$tk");
                       }
                       @wu = grep {defined} @wu;
                       return @wu;
                   }
                   else {
                       return undef;
                   }
               }
           };
           
           grep {defined} $doig->([@path], $h, '');
 - K: as #c get abulator # TODO sink hashy hooks all over # TODO should chain, broke
   D: |
       my $j = {};
       my $do;
       $do = sub {
           my $j = {%$j};
           my $ad = [@_];
           my %j = %$j;
           while (@$ad) {
               my ($k, $v) = (shift @$ad, shift @$ad);
               
               my $comp = $k =~ /^(%|\+)/;
               my $j = {%j} if $comp;
               if ($comp) {
                   $k =~ s/^\+// if $comp;
                   j.t .= $k if $comp;
               }
               else {
                   (j.t, j.cv) = split /\s+/, $k, 2;
                   %j = %$j;
               }
               defined j.cv || die "NOSEYV: j.cv".wdump($j);
               j.r = j.t."\t".j.cv;
               j.s = $v;
               
               $bb->{j.r} = j.s;
               push @$ord, {%$j} if $ord;
           }
           wantarray ? ($j, 
               sub{$do->(%$j, @_)} # TODO fucked, get some weed and fix it
           ) : $j
       };
       $do
 - K: shj #c pronounce $j{r,s,t,l,com?,style?,cv,ev?} # to cache or something, is phasey
   D: |
     my $j;
     j.r = $r; # TODO probly sameness
     j.s = ar.C || (ar.J ? ar.J.bb : ar.d)->{$r}; # carbon in, or from abdomin
     (j.t, j.cv) =
         j.r =~ /^(.+)\t(.+?)$/ ? ($1, $2)
         :
         split /\s+/, j.r, 2;
         
     my $t = j.t; # sep orthoogabooga
     j.com = $1 if $t =~ s/#(.+)$//;
     j.style = $1 if $t =~ s/%(.+)$//;
     j.l = $t;
     
     (j.cv, my @e) = split /\s+/, j.cv;
     j.ev = \@e if @e;
     die if j.b;
     j.b.b.b = ar.d;
     $j
 - K: ytv #c sort by voltage making cityscape, things only
   D: |
     
     my $tvs;
     map{
         push @{ar.ord}, $_ if ar.ord;
           push @{$tvs->{_.cv}||=[]}, $_
       }
       sort{ a.r cmp b.r }
       grep{ _.t eq _.l } # things onlyness
       map{ w $R shj(r=>$_,d=>J.bb); }
       keys %{J.bb};
     $tvs;
 - K: tvo #c sort by voltage making cv,r ordered list
   D: |
     sort { a.cv <=> b.cv }
       sort{ a.r cmp b.r }
       grep { !ar.ip || $G->ip(ar.ip => $_) }
       map{ w $R shj(r=>$_,d=>J.bb); }
       keys %{J.bb};
 - K: tvy #c group tvo by thing with style
   D: |
      my @d = w $R tvo[$J]; # !style||com
      
      my @things;
      while (@d) {
          my $th = shift @d;
          
          my $thing = [$th];
          
          push @$thing, shift @d
              while @d && $d[0]->{l} eq th.l;
          
          if ($th && th.l ne th.t) {
              my @plan;
              for (@$thing) {
                  # somehow plan to hide things from yourself
                  # <> > <>
                  # <> > <>
                  # <> > <>
                  # <> > <>
                  # <> > <>
                  # <> > <>
                  # TODO conroll polai
              }
              if (@plan != @$thing) { # unknown and thingless style action
                  sayre "style no tip th.r", map { "   _.r     =". gp _.s } @$thing;
                  unshift @$thing, undef;
              }
              for (@plan) {
                   # TODO how it likes to get together? this set somewhere else
              }
          }
          
          push @things, $thing;
          
      }
      @things

