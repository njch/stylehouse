R_Jz:
 - K: pul #c pulk # parses list of things from an $m (now $cs) using $m scheme, each could be named in $ar
   D: |
     my $o = {};
     my $csm = [ar.cs ? @{ar.cs} : @{$F[2]->{ar}->{m} || []}]; # looks at one ar.m above
     for my $n (@$m) {
         # can type things along
         my $acumey = $n =~ s/\+$//;
         if (defined $ar->{$n}) {
             $o->{$n} = $ar->{$n};
             next;
         }
         my $v = shift @$csm;
         if ($n =~ s/{\+}// && ref $v eq 'HASH') {
             %$o = (%$o, %$v); # other abouts spill off cv modi
         }
         elsif ($acumey) {
             $o->{$n} ||= [$v, @$csm];
         }
         else {
             $o->{$n} = $v;
         }
     }
     $o
 - K: suck #c inhaling pins - reading indexes made from codey vectors (way!) - all the way down to findl vvvv
   D: |
     inter({Jname=>ar.J.name}) if exists ar.J;
     inter({pin=>ar.p || ar.pin || ar.m->[0]});
     my @ps = Rw fi + $sucky=1;
     my @wo;
     for my $p (@ps) {
         my ($dp) = split '/', $p; # domepiece (K) must be in our Jytterspace
         next if !ar.pin && ar.J && !ar.J.yt->{$dp};
         push @wo,
         Rw $p;
         if (ar.V) {
             saygr "Look $p is";
         }
     }
     @wo
     
 - K: huck #c
   D: |
     inter({Jname=>ar.J.name}) if exists ar.J;
     inter({pin=>ar.p || ar.pin || ar.m->[0]});
     my @ps = Rw fi +;
     my $tw;
     for my $p (@ps) {
         my ($dp) = split '/', $p; # domepiece (K) must be in our Jytterspace
         next if !ar.pin && ar.J && !ar.J.yt->{$dp};
         my @wo = Rw $p;
         $tw->{$p} = \@wo;
     }
     $tw
     
 - K: muck #c
   D: |
     my $tw = Rw wuck +;
     for my $k (keys %$tw) {
         my $v = $tw->{$k};
         $tw->{$k} = ref $v ? dclone $v : $v;
     }
     $tw
     
 - K: wuck #c return path=>strings for static way to memoize, instead of exec+dump
   D: |
     my @ps = Rw fi +;
     my $tw;
     for my $p (@ps) { 
         my ($dp) = split '/', $p; # domepiece (K) must be in our Jytterspace
         next if !ar.pin && ar.J && !ar.J.yt->{$dp};
         # R == G
         my $str = R.way->find($p);
         $tw->{$p} = $str;
     }
     $tw
     
 - K: g_wuck #c return path=>strings for static way to memoize, instead of exec+dump
   D: |
     my @ps = Rw fi +;
     my $tw;
     for my $p (@ps) { 
         my ($dp) = split '/', $p; # domepiece (K) must be in our Jytterspace
         next if !ar.pin && ar.J && !ar.J.yt->{$dp};
         # R == G
         my $str = fwind(G.way, $p);
         $tw->{$p} = $str;
     }
     $tw
     
 - K: fund #c
   D: |
     my $tw = {};
     for my $way (@{G.ways}) {
         my ($point,$Cs) = my @AW = Rw findl $h:way $p;
         next if !$point;
         my $k = way._wayfile;
         $k .= $1 if $point =~ /(#.+$)/;
         $tw->{$k} = ref $Cs && ar.dclone ? dclone $Cs : $Cs;
         # want one more tent? #om
         # tiny J piles of stuff to return
         # like the tyv family
     }
     $tw
 - K: buck #c return path way, to avoid suck $m going down
   D: |
     my @ps = Rw fi +;
     my $tw;
     for my $p (@ps) {
         my ($dp) = split '/', $p; # domepiece (K) must be in our Jytterspace
         next if !ar.pin && ar.J && !ar.J.yt->{$dp};
         $tw = $p;
     }
     $tw
     
 - K: fi #c
   D: |
     my %wo = Rw findl +;
     map { s/^\///; $_ } keys %wo; 
     
 - K: findl #c
   D: |
           my $point = ar.p || ar.pin || ar.m->[0];
           my @path = split /\/|\./, $point;
           my $h = ar.h || ar.u || R.way;
           $h = h.hooks if h.hooks;
           
           my $doig;
           $doig = sub {
               my ($p,$h,$s) = @_;
               my @a = @$p;
               
               return $s => $h if !@a; 
               
               ($p) = shift @a;
               
               return undef if !ref $h;#ne 'HASH';
                   if (exists $h->{$p}) { 
                       $h = $h->{$p};
                       return $doig->([@a],$h,"$s/$p");
                   }
                   if ($p =~ s/\*/.+/sg) {
                       my @ke = grep { /^$p$/ } keys %$h;
                       sayyl "findlke : @ke " if ar.J && ar.J.name =~ /wa/;
                       
                       my @wu;
                       for my $tk (@ke) {
                           push @wu, $doig->([@a], $h->{$tk}, "$s/$tk");
                       }
                       @wu = grep {defined} @wu;
                       return @wu;
                   }
                   else {
                       return undef;
                   }
           };
           grep {defined} $doig->([@path], $h, '');
           
 - K: g_findl #c
   D: |
           my $point = ar.p || ar.pin || ar.m->[0];
           my @path = split /\/|\./, $point;
           my $h = ar.h || G.way;
           $h = h.hooks if h.hooks;
           
           my $doig;
           $doig = sub {
               my ($p,$h,$s) = @_;
               my @a = @$p;
               
               return $s => $h if !@a; 
               
               ($p) = shift @a;
               
               return undef if !ref $h;#ne 'HASH';
                   if (exists $h->{$p}) { 
                       $h = $h->{$p};
                       return $doig->([@a],$h,"$s/$p");
                   }
                   if ($p =~ s/\*/.+/sg) {
                       my @ke = grep { /^$p$/ } keys %$h;
                       my @wu;
                       for my $tk (@ke) {
                           push @wu, $doig->([@a], $h->{$tk}, "$s/$tk");
                       }
                       @wu = grep {defined} @wu;
                       return @wu;
                   }
                   else {
                       return undef;
                   }
           };
           
           grep {defined} $doig->([@path], $h, '');
 - K: loadup #c
   D: |
     my $pin = ar.p||ar.pin;
     my $ac = join'',map{"{$_"}split'/',$pin;
     $G->loadup($u, $ac, $n);
     
 - K: shj #c pronounce $j{r,s,t,l,com?,style?,cv,ev?} # to cache or something, is phasey
   D: |
     my $j;
     j.r = $r; # TODO probly sameness
     die if ar.C;
     ar.d = ar.J.bb if ar.J;
     j.s = ar.C || (ar.d)->{$r}; # carbon in, or from abdomin
     (j.t, j.cv) =
         j.r =~ /^(.+)\t(.+?)$/ ? ($1, $2)
         :
         j.r =~ /^(.+)\s+(.+?)$/ ? ($1, $2) : die "is not r: j.r";
         
     my $t = j.t; # sep orthoogabooga
     j.com = $1 if $t =~ s/#([^\/]+)$//;
     j.style = $1 if $t =~ s/%([^\/]+)$//;
     j.l = $t;
     
     (j.cv, my @e) = split /\s+/, j.cv;
     die if @e;
     j.ev = \@e if @e;
     die if j.b;
     unless (J.yl.nojb) {
         j.b.b.b = ar.d;
         j.b.b.j = ar.J if ar.J;
     }
     $j
 - K: delbbl #c
   D: |
     my $ip = {l => $l};
     delete J.bb->{_.r} for
     Rw tvo $J $ip;
 - K: ytv #c sort by voltage making cityscape, things only
   D: |
     my $tvs;
     map{
         push @{ar.ord}, $_ if ar.ord;
           push @{$tvs->{_.cv}||=[]}, $_
       }
       sort{ a.r cmp b.r }
       grep{ _.t eq _.l } # things onlyness
       map{ w $R shj(r=>$_,J=>$J); }
       keys %{J.bb};
     $tvs;
 - K: tvo #c sort by voltage making cv,r ordered list
   D: |
     #say "ipin: ".ki ar.ip if ar.ip;
     if (ar.l || ar.cv) {
         my $ip = ar.ip ||= {};
         ip.l = ar.l if exists ar.l;
         ip.cv = ar.cv if exists ar.cv;
     }
     sort { a.cv <=> b.cv }
       sort{ a.r cmp b.r }
       grep { !ar.ip || $G->ip(ar.ip => $_) }
       map{
       Rw shj $r:_ $J;
       }
       keys %{J.bb};
 - K: tva #c woos
   D: |
     my @js = Rw tvo +;
     [@js]

 - K: tly #c { index  of (j.l#com)/ %style = $j  or as above
   D: |
      my @d = Rw tvo;
      
      my $tks;
      for my $d (@d) {
          my $pl = "d.l#d.com d.cv";
          my $fl = d.style||'';
          if (ar.comfl) { # com stuctury ^ or com floating in with style v
              $pl = "d.l d.cv";
              $fl .= "#d.com" if d.com;
          }
          $tks->{$pl}->{$fl} = $d;
      }
      
      my $tw;
      for my $tk (sort keys %$tks) {
          my $ks = $tks->{$tk};
          if (!$ks->{''}) {
              my ($o) = values %$ks;
              sayre "J.name no j on $tk \t%% all style %%  ".join' ',sort keys %$ks
              #.wdump(2,[map {_.r}grep { 1} @d]);
              if !ar.strange;
              next;
          }
          my $j = delete $ks->{''};
          
          my $x;
          x.j = $j;
          if (keys %$ks) {
              x.sc = {map{ $_ => $ks->{$_}->{s} } keys %$ks};
              
              x.sj = {map{ $_ => $ks->{$_} } keys %$ks};
          }
          $tw->{$tk} = $x;
      }
      $tw
 - K: tyv #c { index of (j.l) / %style#com = $lv(j,sc,sj,
   D: |
     my $comfl = 1;
     Rw tlv + $comfl;
 - K: tlv #c { index line thing.r: $j, styles made into an $sc }
   D: |
      my $tw = Rw tly;
      
      my $cvtk;
      for my $tk (keys %$tw) {
          my $j = $tw->{$tk}->{j} || die " not thingy $tk";
          $cvtk->{j.cv}->{$tk} = $tw->{$tk};
      }
      my $lvs = [];
      for my $cv (sort keys %$cvtk) {
          my $vtk = $cvtk->{$cv};
          for my $tk (sort keys %$vtk) {
              push @$lvs, $vtk->{$tk};
          }
      }
      $lvs
 - K: ship #c l to di ydly - look on a line for yay styles
   D: |
     my $r = delete ar.r;
     my $m = delete ar.m;
     my $stz = {map{$_ => 1}@$m};
     
     my $ip = {%$ar}; 
     delete $ip->{$_} for qw'J R';
     
     my @junk = Rw tvo $J $ip;
     r.junk = \@junk;
     # or so
     my (@path) = grep { $stz->{_.style} } @junk; 
     r.path = \@path;
     if (@$m > 1) {
        my $ps = {};
        acum $ps, _.style, $_ for @path;
        @path = map { $ps->{$_} || [] } @$m;
     }
     @path;
        
 - K: tyc #c
   D: |
     my $vs = Rw tyv;
     my $M = [];
     my $N = [map{[_.j.t,_.j.cv,{s=>_.j.s},_.sc]}@$vs];
     Rw MyN $M $N;
     $M;
 - K: tc #c
   D: |
     my $vs = Rw tyv;
     [map{{t=>_.j.t,y=>{cv=>_.j.cv},c=>{s=>_.j.s},sc=>_.sc||{}}}@$vs];
 - K: jf #c
   D: |
     my $o = Rw pul name;
     my $ip = {t=>o.name};
     my $vs = Rw tyv $J $ip;
     return shift @$vs if @$vs;

