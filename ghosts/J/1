R_Jz:
 - K: tent #c pearlesque kings of the
   D: |
     my $na = shift @$m;
     my $name = J.name.'-'.$na;
     my $conJ = Rw makeJ $name;
     $J->{$na} = $conJ;
     conJ.A->umk($J, 'tent');
     conJ.Jmost = J.Jmost || $J;
     $conJ;
 - K: conroll #c rolling away into shadow effect caused by reiteration
   D: |
       my @con = map{_.i} @{J.A.n_tent||[]};
       @con = grep { $_ ne J.on } @con;
       
       my @names = map { _.name } @con;
       @names = map { s/^J.name//; $_ } @names;
       unshift @con, $J;
       
       say "Scraping out ".$J->pi."   tents ".join ", ", @names;
       sayre "Jmost bb goners: ".join " ", grep { s/\t(.+?)$// || 1 } 
         sort grep {!/\%/} keys %{J.bb};
       
       
       for my $tent (@con) {
           #say "Scraping out the ".$tent->pi;
           Rw setup $J:tent;
       }
 - K: setup #c sets up $a with bb-domin & accessors
   D: |
     Rw suJ $J;
 - K: suJ #c a sudo J, %{ r:sets up $a (J or not quite J hash $a, phro etc) with bbdomin stuff
   D: |
     J.bb = {};
     J.ord = [];
     J.bz = Rw as $bb:J.bb $ord:J.ord;
     
     my $by = sub {
         my $that = shift;
         sub {
             my $j = {etc=>[]};
             (j.r, j.s, @{j.etc}) = @_;
             j.Jiter = $J; # easy reverse
             # drifter, expecting 8 (forks & events) approp.
             # this is a tent it is
             j.Jmost = J.Jmost;
             $that->($j); 
         };
     };
     
     J.lev = $by->(sub {
         my $j = shift;
         j.sub = delete j.s;
         Rw lplumb $J:j;
     });
     # another little con tent, backeting a harmonic sur-ish portal
     J.fro = $by->(sub {
         my $j = shift;
         j.u = delete j.s;
         j.cv = shift @{j.etc};
         Rw gp $J:j;
     });
 - K: lplumb #c abomdin, a level, subby plumbing, tin gplumb
   D: |
        Rw suJ $J;
        J.sub->($J);
        my $a = $J;
        J.s = w G.theR maka[$a];
        J.Jiter.bz->(J.r => J.s,
            '%lp' => $J,
            @{J.etc},
        );
 - K: gp #c R_sur gp
   D: |
        Rw suJ $J;
        G.jumb.gp_inarow++;
        aft { G.jumb.gp_inarow-- };
        %$J = (%$J, %{delete J.cv}) if ref J.cv;
        J.cv = 0.1 if J.cv < 0.1;
        
        # 3
        
        J.isJid = J.replaceJid || $H->mkuid;
        if (G.jumb.gp_inarow > 1) {
            undef J.isJid;
        }
        #sayyl join(" ", ("  ") x G.jumb.gp_inarow)." ooooo ".gp(J.u);
        J.Jmost.gpa.pis->{J.isJid} = $J if J.isJid;
        # TODO J pass over # maka suction
        # don't need to close it up right now...
        # top down injection gos
        
        my $a = $J; # pretend, sli C7
        my $u = J.ul;
        
        my $wa = J.wa || do {
            J.c = $R->cgp($u);
            # ^
            
            # v
            my ($wa) = grep { J.c->{$_} } qw'canpi ARRAY HASH ref undef text';
            $wa = ref $u if $wa eq 'canpi';
            $wa ||= 'wtf';
            $wa;
        };
        # can stick $wa on J.wa for thrashing maths
        
        
        G.theR.way->find("pi/$wa") || die "not $wa equip";
        
        # 5 forking swivel injecty

        # 6
        w G.theR pi/$wa[$a,$u];
        
        
        # 7
        a.s = w G.theR maka[$a,$u];
        
        
        # 8
        
        # 9
        a.Jiter.bz->(J.r => J.s,    '%gp' => $J,    @{J.etc});
        
 - K: as #c get abulator # TODO sink hashy hooks all over # TODO should chain, broke
   D: |
       my $j = {};
       my $do;
       $do = sub {
           my $j = {%$j};
           my $ad = [@_];
           my %j = %$j;
           while (@$ad) {
               my ($k, $v) = (shift @$ad, shift @$ad);
               
               my $comp = $k =~ /^(%|\+)/;
               my $j = {%j} if $comp;
               if ($comp) {
                   $k =~ s/^\+// if $comp;
                   j.t .= $k if $comp;
               }
               else {
                   (j.t, j.cv) = split /\s+/, $k, 2;
                   %j = %$j;
               }
               defined j.cv || die "NOSEYV: j.cv".wdump($j);
               j.r = j.t."\t".j.cv;
               j.s = $v;
               
               $bb->{j.r} = j.s;
               push @$ord, {%$j} if $ord;
           }
           sub{$do->(%$j, @_)} # TODO fucked, get some weed and fix it
       };
       $do
 - K: shj #c pronounce $j{r,s,t,l,com?,style?,cv,ev?} # to cache or something, is phasey
   D: |
     my $j;
     j.r = $r;
     j.s = ar.C || ar.d->{$r}; # carbon in, or from abdomin
     (j.t, j.cv) =
         j.r =~ /^(.+)\t(.+?)$/ ? ($1, $2)
         :
         split /\s+/, j.r, 2;
         
     my $t = j.t; # sep orthoogabooga
     j.com = $1 if $t =~ s/#(.+)$//;
     j.style = $1 if $t =~ s/%(.+)$//;
     j.l = $t;
     
     (j.cv, my @e) = split /\s+/, j.cv;
     j.ev = \@e if @e;
     die if j.b;
     j.b.b.b = ar.d;
     $j
 - K: ytv #c sort by voltage making cityscape, things only
   D: |
     
     my $tvs;
     map{
         push @{ar.ord}, $_ if ar.ord;
           push @{$tvs->{_.cv}||=[]}, $_
       }
       sort{ a.r cmp b.r }
       grep{ _.t eq _.l } # things onlyness
       map{ w $R shj(r=>$_,d=>J.bb); }
       keys %{J.bb};
     $tvs;
 - K: tvo #c sort by voltage making cv,r ordered list
   D: |
     sort { a.cv <=> b.cv }
       sort{ a.r cmp b.r }
       grep { !ar.ip || $G->ip(ar.ip => $_) }
       map{ w $R shj(r=>$_,d=>J.bb); }
       keys %{J.bb};
 - K: tvy #c group tvo by thing with style
   D: |
      my @d = w $R tvo[$J]; # !style||com
      my @things;
      while (@d) {
          my $ne = shift @d;
          die wdump(1, $ne) if ne.l ne ne.t; # style no tip

          my $thing = [$ne];
          while (@d && $d[0]->{l} eq ne.l) {
              my $sj = shift @d;
              push @$thing, $sj;
          }
          push @things, $thing;
      }
      @things

