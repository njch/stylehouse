R_Jz:

 - K: round #c regroup - smush cove + copy here -> there
   D: |
       # could multiple J sources and exits, provide roundness, generally...
       # not just from this J but spacing out logic according from what changed
       # a style or intentness of the bzling reshadow
       # increment
       # chunk the curve and rotate each chunk *** piles in spiral
       
       my @be = Rw tvo $J:J2;
       my $jit; # cv / l / t / $j
       my $ji = {map{$_=>[]}0..9};
       
       for my $j (@be) {
           $jit->{j.cv}->{j.l}->{j.t} && die;
           $jit->{j.cv}->{j.l}->{j.t} = $j;
           next unless j.l eq j.t; # just deal thing spines
           j.cv =~ /^0\.(\d)/ || die;
           my $cvb = $1;
           push @{$ji->{$cvb}}, $j;
       }
       
       # wavesmush # DOESn't do spaceouts
       # but that old... 
       my $away; 
       #sayyl "Be: ".@be;
       my $id = J.yy.round.id || 2;
       for my $i (0..9) {
           my $lo = $ji->{$i-1};
           my $no = $ji->{$i};
           my $ro = $ji->{$i+1};
           
           my $bulg = @$no - $id if @$no > $id;
           if ($bulg > 0 && $lo && @$lo < $id) {
               my $idspacl = $id - @$lo;
               push @$lo, map { shift @$no } 1..$idspacl;
           }
           
           $bulg = 0;
           $bulg = @$no - $id if @$no > $id;
           if ($bulg > 0 && $ro) { # without varing  && @$ro < $id
               unshift @$ro, map { pop @$no } 1..$bulg;
           }
           elsif ($bulg > 0) {
               # could flip everything around, raise $id,
               # slosh back toward the middle again
               # very painterly
               # hidden realms
               pop @$no for 1..$bulg;
               $away = {bulg=>$away};
           }
           
       }
       
       
       # measure $ji, mod up locations for things
       # give original j.cv if the $cvb/ set is same
       for my $cvb (sort keys %$ji) {
           my $no = $ji->{$cvb};
           my @cvs = map{_.cv}@$no;
           #die join(":",@cvs) if join(":",@cvs) ne join(":", sort @cvs);
           
           if (@cvs != uniq @cvs) {
               
               my $warp = @$no;
               @cvs = map { "0.".$cvb.$_ } Rw cv/oe $v:warp;
               # wind for thi like in mod
           }
           
           for my $j (@$no) {
               my $ncv = shift @cvs;
               my $ts = $jit->{j.cv}->{j.l};#/j.t => $j
               for my $k (sort keys %$ts) {
                   my $tj = $ts->{$k};
                   if (tj.t eq tj.l) {
                       J.bz->(j.l."%origin\t".$ncv, $tj); # subtlest A-tion
                       J2.bz->(j.l."%waves\t".$ncv, $j); # subtlest A-tion
                   }
                   J.bz->(tj.t."\t".$ncv, tj.s);
               }
           }
       }
       
       if ($away) {
           J.bz->("buckstop\t0.999" => "@".away.bulg."...",
           '%css' => 'color:blue');
       }
       


 - K: retile #c # TODO use L & J
   D: | 
    die "retile get rid of H.r";
    my @m = map { /W\/(.+)$/ } H.r->keys("W/*");
    @m = map { $H->djson(H.r->get("W/$_")) } @m;
    
    H.G w TODOWhack(meta=>$_) for grep { _.dead } @m;
    @m = grep { !_.dead } @m;
    
    @m = grep { _.styles =~ /\bNZ\b/ } @m;
    @m = sort { a.hol cmp b.hol } @m;
    
    my $space = 1;
    $space += 0.5 until $space * $space >= @m;
    my $r = floor $space;
    my $l = ceil $space;
    my $div = ["width:left $l", "height:top $r"];
    
    say "needed ".@m." so $space is $l $r";
    
    my $grid = {};
    for my $p (@$div) {
        my ($iv, $parts) = split ' ', $p;
        my ($mags, $ax) = split ':', $iv;
        # magnitudes of width
        # axed from unified by left, etc.
        my $in = sprintf("%.3f", 1 / $parts);
        
        my @ground = map { [$_ => $grid->{$_} ] } sort keys %$grid;
        @ground = [] if !@ground;
        my $pole = [];
        $grid = {};
        
        my $here = 0; # in accum
        for my $i (1..$parts) {
            my $ox = {};
            ox.part = $i;
            $ox->{$ax} = $here;
            $here += $in;
            $ox->{$mags} = $in;
            push @$pole, $ox;
        }
        
        for my $g (@ground) {
            my ($k, $v) = @$g;
            $v ||= {};
            for my $ox (@$pole) {
                my $K = (defined $k?"$k ":"") . ox.part;
                my $x = $grid->{$K} = {%$v, %$ox};
                delete x.part;
            }
        }
    }
    
    my @holes = sort keys %$grid;
    say "Got ".@m." pegs for ".@holes." holes: ".wdump[@m];
    for my $meta (@m) {
        my $h = shift @holes;
        my $o = {%{$grid->{$h}}};
        
        $o->{$_} = ($o->{$_} * 100)."%" for keys %$o;
        
        meta.ces = $o;
        H.r->set("W/meta.Wid" => $H->ejson($meta));
        
        my $cssset = ".animate(".$H->ejson($o).", 0)";
        my $unhide = ".removeClass('NZ')";
        
        $H->send(" \$('#".meta.Wid."')$cssset$unhide".";");
    }
 - K: maka #c
   D: |
     die "hello" if ar.hello;
     my $J = ar.J || ar.a;
     #say "maka ".gp($J)."              ".gp(J.most.J);
     
     # should be J/1 in gpasm
       J.bz->("/%id\t0.9" => J.id) if J.id && !J.noJid;
       
       J.o = {};
       my $vs = Rw tyv $J;
       
       # want the target projection to bounce diffs
       # and so to regroup, do / like envelopes
       # the maka on the border between ux and J wants to have id and tag=ux imposed down, everything else imposed up
       # interesting V shape, laces
       # execution order in J.o is ev
           
       my @s;
       J.ty.maka.s = \@s;
       
       my @things = @$vs;
       my @toplevels; # emerge from things
       
       while (@things || @toplevels) {
           my $lv = shift @things;
           $lv ||= shift @toplevels;
           my $j = lv.j;
           my $sc = lv.sc;
           my $s = j.s;
           my $l = j.l;
           #say "j.r \t\t". join "\t", sort keys %$sc; # gp($sc->{$_})
           
           my $cssdb = 0;
           
           sayyl " thji: j.r" if $cssdb;
           if (j.l eq '/') {
               die "god non 0.9 && j.l eq '/'".wdump(2,$j)
                   if j.cv != 0.9;
               if (@things) {
                      #sayre "defer ".wdump 2, $lv;
                   push @toplevels, $lv; # defer to last
                   next;
               }
           }
           die "reffy $s in $l".wdump(2,$j) if ref $s;
           
           # want to do a bit of voltage vading, opacity...
           # to all the little j makas in the most.J J
           # should take about 1 second
           # can move across network
           
           # top volt for thing selection?: # whattage
           # skip o0 &&verlap of K + name
           # should be fo pi 6 stuff
           next if $l eq 'K' && J.bb->{"name 0.1"} eq $s
              && $s ne J.bb->{"K 0.2"};

           my $ishtml;
           my $at = {};
           my $css = [];

           if ($l eq '/') {  # thingness # swoosh, swallows up the rest of @s
               # could know this is coming and defer tiny contents
               # favour big picture, only need to surf by...
               # water keeps watering anywhere you look at it
               # the @s gets too big for one message too
               $ishtml = 1;
               $s = join "", @s;
               @s = ();
           }
           # 5.5 #c appearance
           for my $k (sort keys %$sc) {
               my $cs = $sc->{$k};
               my ($style,$com) = split '#', $k;
               # < >< >< >?
               # < >< >< >?
               # Jung Cs have injected langauge
               # to grab themselves by...
               # < >< >< >?
               if ($style eq 'gp' || $style eq 'pi' || $style eq 'lp' || $style eq 'ishtml') {
                   $ishtml = 1;
               }
               # has a way to $a the gp action within...
               elsif ($style eq 'sf') {
                       push @$css,
                       map { $R::f->{$_} || die "no style $_"}
                           split '_', $cs;
                       #sayre "bit of sf: $cs";
               }
               elsif ($style eq 'css') {
                       $cs = join ';', map{"$_:$cs->{$_}"}
                           sort keys %$cs
                           if ref $cs;
                       push @$css, $cs;
                       sayre "bit of css: $cs" if ar.db;
               }
               elsif ($style eq 'id') {
                   at.id = $cs;
               }
               elsif ($style eq 'tt') {
                   at.title = $cs;
               }
               elsif ($style eq 'tag') {
                   at.tag = $cs;
               }
               elsif ($style =~ /^at:(\S+)$/) {
                   $at->{$1} = $cs;
               }
               elsif ($style eq 'path') {
                   # TODO compile J.ys
                   # should get %idly if not lev/gp too
               }
               elsif ($style eq 'origin') {
               }
               elsif ($style eq 'waves') {
               }
               elsif ($style eq 'pwar') {
               }
               elsif ($style eq 'Joint') {
               }
               elsif ($style eq 'idly') { # is knowable j id
                   my $id = $H->mkuid;
                   at.id && die "arl";
                   at.id = $id;
                   J.idyl->($J, $id, $j);
               }
               else {
                   die "style??".wdump[$style,$cs];
               }
           }
           @$css = map {
               join '', map{"$_;"} grep{defined} split ';', $_
           } @$css;
           #c TODO hold things in pockets relative to origin css comment
           # to help things break down into styles better
           at.style = join '', map{"$_;"}
               grep{defined} map { split ';' } @$css;
           
           # /////////////////////////////////////////////////////
           Rw occie/61 $at $css;
           
       # 7 #c thingness <-> appearance
       # stylecompressor 3s6 aboves
       # hooch
           if (at.title || !a.untitled) {
               at.title = join " ", grep{defined}
                   (!a.untitled ? "j.cv $l" : undef),
                   (at.title ? at.title : undef);
           }
           my $tag = delete at.tag;
           my $ts = j.l;
           $ts =~ s/[^\w]/ñ/sg;
           $tag ||= "a$ts";
           $at = join " ", $tag,
               map { saybl " : $_ " if $cssdb; $_ }
               map { $_.'="'.$at->{$_}.'"' } # attra
               grep { $at->{$_} } sort keys %$at;
           
           $s = encode_entities($s) if !$ishtml;
           $s = "<$at>$s</$tag>" if defined $s;
           push @s, $s;
       }
       @s = "no?" if !@s;
       my $html = join '', @s;
       $html;
         
 - K: domi #c Doofer
   n_D:
     recoded_init: |
       Rw domi/up;
     fresh_init: |
       Rw domi/up;
     up: |
       # quick rezip  
       sayre "THE DOMI" for 1..5;
       # vamp compressioms
       # that is things before even J personality mods
       # same Jway, phases etc.
       G.drop = {};
       delete G.drop.conv;
       delete G.drop.vonc; # TODO drop all
       Rw conv;
       Rw vonc;
       
       Rw suck */dosc;
       Rw conc;
 - K: conc #c C_whta
   D: |
     delete G.drop.esc;
     my @a = grep {/^C_.+/} sort keys %{R.way.hooks};
     for my $the (@a) {
         my $path = $1 if $the =~ /^C_(.+)/;
         Rw Con $the $path;
     }
     saygr "CONC!   ".F_delta for 1..4;
 - K: conv #c know about elemental stuff
   D: |
     my $pway = {qw'1 YIN 2 YANG 3 CARBON 4 HUMM 5 STYLE 6 TRAVEL 7 CITOZINE 8 INF 9 RETURN'};
     G.drop.conv = sub {
          my $v = shift;
         my $dig = $1 if $v =~ /^.*?([1-9]).*/;
         $pway->{$dig} || die " not convable $dig from $v";
     };
     G.drop.conv->(ar.v) if ar.v;
 - K: vonc #c elemental
   D: |
     G.drop.vonc = sub {
          my $v = shift;
         my $dig = $1 if $v =~ /^.*?([1-9]).*/;
         return $1;
     };
     G.drop.vonc->(ar.v) if ar.v;
 - K: Con #c the shunt, suck, J maint wayfile story # OSCILATE FUNCS, test frequencies tuned synapse
   D: |
     my $o = Rw pul + the src path;
     my $the = o.the || die;
     my $src = o.src || "$the/u";
     my $path = o.path || "$the/n";
     # or wherever thi src + carbon quags into existence
     # root l=$the := $the/n, otherwis whatever is l
     # so $the/X for subhash X, yin require of user
     # similar smush in G.drop.$the
     my $p = $the =~ /_/ ? "C $path" : "$the c";
     my $J = Rw Carbonja $p $the $path;
     
     my $coms = {};
     my $wtf = Rw concat $J $coms;
     
     my $real = {};
     $real->{$path} = R.way->find($src) || die "no $src";
       
     my $imag = {};
     
       for my $l (sort keys %$wtf) {
           my $was = $wtf->{$l};
           for my $cvit (sort keys %$was) {
               my $v = $was->{$cvit};
               my $type = G.drop.conv->($cvit); # con cvit
               
               $v = join "\n", @$v;        # # <<<<<<<
               
               if ($real->{$l}) {
                   # after an elemental aggregation...
                   # these'll be top posting after cv sort?
                   $real->{$l} =~ s/(# $type.*?)$/$1\n$v/sm
                   
                   || die "no $type in ... $l for $real->{$l}";
               }
               else {
                   $imag->{$l} .= "\n$v";
               }
           }
       }
       
       my $all = {%$real, %$imag};
       die wdump[[sort keys %$real],[sort keys %$imag],[sort keys %$all]]
          if keys(%$real) + keys(%$imag) != keys %$all;
       for my $pin (sort keys %$all) {
           my $n = $all->{$pin};
           $pin = $path if $pin eq $the; # $the/n
           Rw loadup $u:R.way.hooks $pin $n;
       }
       
       G.jumb.ConJ->{$the} = $J;
     

       
       #talkyelemental 
       my $ev;
       for (sort keys %$coms) {
           my $c = $coms->{$_};
           push @{$ev->{floor($_)}||=[]}, @$c;
       }
       my $sl;
       for my $k (sort keys %$ev) {
           my $r = $ev->{$k};
           $sl .= "   $k * ".(0+@$r)."(".slim(25,join(' ',@$r)).")";
       }
        
       #saybl " _________________  $mw" if $the eq 'esc';
       sayyl "$path <- $the     $sl";
       
       my $em = ["$the/Conned"];
       Rw suck $m:em $J;
       # nice thing to print ^
       
 - K: Carbonja #c 3ish
   D: |
       
       $p .= '(#*)?' if $p =~ /^C /;
       my $tw = Rw fund $p;
       die "no '$p'" if !%$tw;
       # where to suck localness
       
       my $J = {};
       Rw suJ $J;
       
       my $p = "$the/el/*";
       my $ty = Rw huck $p;
       $ty = {map{
            my $type = $1 if /el\/(.+)$/ || die;
            my $an = $ty->{$_};
            die if @$an > 1;
            $type => $an->[0];
       }keys %$ty};
       
       
       for my $file (sort keys %$tw) {
           my $Cs = $tw->{$file};
           my $coi = Rw pha $J $k:file;
           
           for my $c (@$Cs) {
               #die wdump $c if ref $c eq 'HASH' && (c.MZ || c.K eq 'MZ');
               # occasional c.MZ for things that always want in...
               # homex ty, local modulation, the radio
               # some carbon fits
               # also from $the/el
               
               if (ref $c eq 'HASH') {
                   my @wsy = grep {m/\S\s\S/} keys %$c;
                   for my $zk (@wsy) {
                       my $D = $c->{$zk};
                       my ($k, $v) = split m/\s/, $zk;
                       #die "$k ne $the      $path" if $k ne $the; # the redund
                       c.v ||= $v;
                       c.s = $D;
                       c.sc.com = "# $zk @ c.K  ";

                       Rw Nucleous $file $ty $c $the $path $J;
                   }
               }
               elsif (ref $c eq 'ARRAY') {
                   my $n = {};
                   (n.K, n.v, n.s, n.sc) = @$c;
                   n.sc.com ||= "# n.K n.v";
                   
                   Rw Nucleous $file $ty $c:n $the $path $J;
               }
               else {
                   die wdump $c;
               }
           }
           coi.end->();
       }
       $J
 - K: Nucleous #c
   D: |
          my (@l,@lr,@r);
          c.K || die;
          c.v ||= 3;
          c.v += 0;
          my $ome = "#".c.K;
          die c.v if c.v !~ /^\d/;

          # if for c.cs, for implant condits # sche
          my $cv = c.v;
          my $D = c.s;
          my $type = G.drop.conv->($cv);
          # z downgrasp
          my $sc;
          $sc = c.sc.MZ if c.sc && c.sc.MZ;
          $sc ||= $ty->{$type};
          $sc ||= {};
          $sc = {%$sc, %{c.sc}} if c.sc;
          
          # per $path if maybe ?? emberd whatsits
          # some special K of c may have meta for this too
          
               if (my $sub = sc.subhash) {
                   unshift @l, "G\.drop\.$path\.$sub\.c.K = sub {";
                   my $args = '$v,$tks,$'.$sub;
                   if (my $arp = sc.subhash_X_arp) {
                       $args .= ",$arp";
                   }
                   push @lr, '    my ('.$args.') = @_;'; # gets $X, etc
                   $D = ind '     ', $D;
                   push @r, '};';
                   if (my $list = sc.droplist) {
                       push @r, "push \@{G\.drop\.$path\.$list}, 'c.K';"; 
                       J bz ${path}_$sub#rese$list 1 "G\.drop\.$path\.$list = [];"
                   }
                   my $haD = join "\n", (sc.com||"#!?"), @l, @lr, $D, @r;
                   @l = (); @lr = (); @r = ();
                   J bz ${path}_$sub$ome $cv $haD
                   J bz ${path}_$sub#rese 1 "G\.drop\.$path\.$sub = {};"
                   J bz ${path}_$sub#return 9 "G\.drop\.$path\.$sub;"
                   J bz $path#upsubhash-$sub 1 "my \$$sub = G\.drop\.$path\.$sub ||= Rw ${path}_$sub;"
                   return; #
               }
          
          # : EXPR ? DO +
          # or they want elsif
          # see what the cv wants to land on/through
          # see twisty ops in lightcones
          # could resolve curve embeddings like this
          if (my $cs = sc.qmco) {
              push @l, ':', "\$tk eq 'c.K' ? do {";
              if (my $sub = sc.subhash) {
                  $D = "G\.drop\.$path\.$sub\.c.K->(\$v, \$tks)";
              }
              $D = ind '     ', $D;
              push @r, '}';
          }
          
          # if (sc.this) { DO } +
               if (my $cs = sc.csfrm) {
                   $cs = c.K if $cs eq 'cK';
                   sc.com .= "# cs=$cs  ";
                   unshift @l, "if (exists c\.$cs) {"
                       ."\n    my \$cs = c\.$cs;";
                   $D = ind '     ', $D;
                   push @r, '}';
               }
               
               $D = join "\n", (sc.com||"#!?"), @l, @lr, $D, @r;
               J bz $path$ome $cv $D

