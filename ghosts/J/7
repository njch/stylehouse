R_Jz:


 - K: outhere #c out
   D: |
     my @d = grep { _.t eq _.l } w $R tvo(J=>J.pha); # !style||com
     
     for my $j (@d) {
         my $here = j.s;
         # unwind # TODO wind blowing crazy
         my $swish = $RADIAN*4;
         $swish *= -1 if here.rad < 0;
         # coil something something
         here.rad -= $swish until here.rad < $RADIAN*4;
         
         # random angle like L, find the \ direction at least
         # its mass would be good too
         # share space with curves
         my $rad = here.rad;
         my $radleg = -$RADIAN;
         # and pan to hemisphere...#
         # from O- is it in the left hemisphere etc
          $radleg *= -1 unless $rad < -$RADIAN && $rad > $RADIAN;
         $rad -= $radleg; 
         
         my $ere = {
             left => here.left,
             radial => sprintf('%.5f', $rad),
             angle => sprintf('%.5f', here.rad),
             x => sprintf('%.5f', here.x),
             y => sprintf('%.5f', here.y),
         };
         
         #sayre ">>>> yep @ent  j.cv    ". j.t;
         
         J.bz->(
             "j.t%css#pha\t".j.cv =>  # concert per emportar
             'top:'.(ere.y * 100).'%;'
             .'left:'.(ere.x * 100).'%;'
             .'position:absolute;'
               .'-webkit-transform:rotate('.ere.radial.'rad);'
               .'transform-origin:0% 0%;' # animate that bit
         );
         J.bz->(
             "j.t%tt\t".j.cv =>  # concert per emportar
             "*".ere.radial
         );
      }
      sayre join " ", (">") x scalar(@d);
 - K: retile #c # TODO use L & J
   D: | 
    my @m = map { /W\/(.+)$/ } H.r->keys("W/*");
    @m = map { $H->djson(H.r->get("W/$_")) } @m;
    
    H.G w TODOWhack(meta=>$_) for grep { _.dead } @m;
    @m = grep { !_.dead } @m;
    
    @m = grep { _.styles =~ /\bNZ\b/ } @m;
    @m = sort { a.hol cmp b.hol } @m;
    
    my $space = 1;
    $space += 0.5 until $space * $space >= @m;
    my $r = floor $space;
    my $l = ceil $space;
    my $div = ["width:left $l", "height:top $r"];
    
    say "needed ".@m." so $space is $l $r";
    
    my $grid = {};
    for my $p (@$div) {
        my ($iv, $parts) = split ' ', $p;
        my ($mags, $ax) = split ':', $iv;
        # magnitudes of width
        # axed from unified by left, etc.
        my $in = sprintf("%.3f", 1 / $parts);
        
        my @ground = map { [$_ => $grid->{$_} ] } sort keys %$grid;
        @ground = [] if !@ground;
        my $pole = [];
        $grid = {};
        
        my $here = 0; # in accum
        for my $i (1..$parts) {
            my $ox = {};
            ox.part = $i;
            $ox->{$ax} = $here;
            $here += $in;
            $ox->{$mags} = $in;
            push @$pole, $ox;
        }
        
        for my $g (@ground) {
            my ($k, $v) = @$g;
            $v ||= {};
            for my $ox (@$pole) {
                my $K = (defined $k?"$k ":"") . ox.part;
                my $x = $grid->{$K} = {%$v, %$ox};
                delete x.part;
            }
        }
    }
    
    my @holes = sort keys %$grid;
    say "Got ".@m." pegs for ".@holes." holes: ".wdump[@m];
    for my $meta (@m) {
        my $h = shift @holes;
        my $o = {%{$grid->{$h}}};
        
        $o->{$_} = ($o->{$_} * 100)."%" for keys %$o;
        
        meta.ces = $o;
        H.r->set("W/meta.Wid" => $H->ejson($meta));
        
        my $cssset = ".animate(".$H->ejson($o).", 0)";
        my $unhide = ".removeClass('NZ')";
        
        $H->send(" \$('#".meta.Wid."')$cssset$unhide".";");
    }

