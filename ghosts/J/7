R_Jz:


 - K: outhere #c out
   D: |
     my @d = grep { _.t eq _.l } w $R tvo(J=>J.pha); # !style||com
     
     for my $j (@d) {
         my $here = j.s;
         # unwind # TODO wind blowing crazy
         my $swish = $RADIAN*4;
         $swish *= -1 if here.rad < 0;
         # coil something something
         here.rad -= $swish until here.rad < $RADIAN*4;
         
         # random angle like L, find the \ direction at least
         # its mass would be good too
         # share space with curves
         my $rad = here.rad;
         my $radleg = -$RADIAN;
         # and pan to hemisphere...#
         # from O- is it in the left hemisphere etc
          $radleg *= -1 unless $rad < -$RADIAN && $rad > $RADIAN;
         $rad -= $radleg; 
         
         my $ere = {
             left => here.left,
             radial => sprintf('%.5f', $rad),
             angle => sprintf('%.5f', here.rad),
             x => sprintf('%.5f', here.x),
             y => sprintf('%.5f', here.y),
         };
         
         #sayre ">>>> yep @ent  j.cv    ". j.t;
         
         # loses its compressibility as csz
         # unless we use %css#omments to spread em
         for (
         [ XY => {
           top => (ere.y * 100).'%',
           left => (ere.x * 100).'%',
         } ],
         [ Ro => {
           '-webkit-transform' => 'rotate('.ere.radial.'rad)',
         } ],
         [ R => {
           position => 'absolute',
           'transform-origin' => '0% 50%',
         } ],
         ) {
             J.bz->("j.t%css#pha-$_->[0]\t".j.cv => $_->[1]); # concert per emportar
         }
         
         J.bz->(
             "j.t%tt\t".j.cv =>  # concert per emportar
             "*".ere.radial
         );
      }
      Rw suck */outhere;
      sayre join " ", (">") x scalar(@d);
 - K: retile #c # TODO use L & J
   D: | 
    die "retile get rid of H.r";
    my @m = map { /W\/(.+)$/ } H.r->keys("W/*");
    @m = map { $H->djson(H.r->get("W/$_")) } @m;
    
    H.G w TODOWhack(meta=>$_) for grep { _.dead } @m;
    @m = grep { !_.dead } @m;
    
    @m = grep { _.styles =~ /\bNZ\b/ } @m;
    @m = sort { a.hol cmp b.hol } @m;
    
    my $space = 1;
    $space += 0.5 until $space * $space >= @m;
    my $r = floor $space;
    my $l = ceil $space;
    my $div = ["width:left $l", "height:top $r"];
    
    say "needed ".@m." so $space is $l $r";
    
    my $grid = {};
    for my $p (@$div) {
        my ($iv, $parts) = split ' ', $p;
        my ($mags, $ax) = split ':', $iv;
        # magnitudes of width
        # axed from unified by left, etc.
        my $in = sprintf("%.3f", 1 / $parts);
        
        my @ground = map { [$_ => $grid->{$_} ] } sort keys %$grid;
        @ground = [] if !@ground;
        my $pole = [];
        $grid = {};
        
        my $here = 0; # in accum
        for my $i (1..$parts) {
            my $ox = {};
            ox.part = $i;
            $ox->{$ax} = $here;
            $here += $in;
            $ox->{$mags} = $in;
            push @$pole, $ox;
        }
        
        for my $g (@ground) {
            my ($k, $v) = @$g;
            $v ||= {};
            for my $ox (@$pole) {
                my $K = (defined $k?"$k ":"") . ox.part;
                my $x = $grid->{$K} = {%$v, %$ox};
                delete x.part;
            }
        }
    }
    
    my @holes = sort keys %$grid;
    say "Got ".@m." pegs for ".@holes." holes: ".wdump[@m];
    for my $meta (@m) {
        my $h = shift @holes;
        my $o = {%{$grid->{$h}}};
        
        $o->{$_} = ($o->{$_} * 100)."%" for keys %$o;
        
        meta.ces = $o;
        H.r->set("W/meta.Wid" => $H->ejson($meta));
        
        my $cssset = ".animate(".$H->ejson($o).", 0)";
        my $unhide = ".removeClass('NZ')";
        
        $H->send(" \$('#".meta.Wid."')$cssset$unhide".";");
    }
 - K: maka #c
   D: |
     die "hello" if ar.hello;
     my $J = ar.J || ar.a;
     #say "maka ".gp($J)."              ".gp(J.most.J);
   babz:
     'maka 1': | #c should be J/1 in gpasm
       if (my $id = J.id) {
           J.bz->("/%id\t0.9" => $id);
       }
       if (my $tod = J.makaz) {
           for (keys %$tod) {
               J.bz->($_ => $tod->{$_})
           }
       }
     'maka 4': | #c thingness <-> appearance
       J.o = {};
       # shall create "/ 0.99" => something for this element
       # so that things last, embeds contooz
       # maybe J.by.maka.whol describes it, and provides its contooz (@s)
           # execution order in J.o is ev
           # / thing knows how to suck up others
       my $vs = Rw tyv $J;
       #my @things = Rw tvy $J;
       my @s;
       J.ty.maka.s = \@s;
       
       my @things = @$vs;
       while (@things) {
           my $lv = shift @things;
           my $j = lv.j;
           my $sc = lv.sc;
           my $s = j.s;
           my $l = j.l;
           #say "j.r \t\t". join "\t", sort keys %$sc; # gp($sc->{$_})
           
           my $cssdb = 0;
           
           sayyl " thji: j.r" if $cssdb;
           if (j.l eq '/') {
               die "god non 0.9 && j.l eq '/'".wdump(2,$j)
                   if j.cv != 0.9;
               if (@things) {
                   push @things, $lv; # defer to last
                   next;
               }
           }
           die "reffy $s in $l".wdump(2,$j) if ref $s;
           
           # want to do a bit of voltage vading, opacity...
           # to all the little j makas in the most.J J
           # should take about 1 second
           # can move across network
           
           # top volt for thing selection?: # whattage
           # skip o0 &&verlap of K + name
           # should be fo pi 6 stuff
           next if $l eq 'K' && J.bb->{"name 0.1"} eq $s
              && $s ne J.bb->{"K 0.2"};

           my $ishtml;
           my $at = {};
           my $css = [];

           if ($l eq '/') {  # thingness # swoosh, swallows up the rest of @s
               # could know this is coming and defer tiny contents
               # favour big picture, only need to surf by...
               # water keeps watering anywhere you look at it
               # the @s gets too big for one message too
               $ishtml = 1;
               $s = join "", @s;
               @s = ();
           }
     'maka 5.5': | #c appearance
           for my $k (sort keys %$sc) {
               my $cs = $sc->{$k};
               my ($style,$com) = split '#', $k;
               # < >< >< >?
               # < >< >< >?
               # Jung Cs have injected langauge
               # to grab themselves by...
               # < >< >< >?
               if ($style eq 'gp' || $style eq 'lp' || $style eq 'ishtml') {
                   $ishtml = 1;
               }
               # has a way to $a the gp action within...
               elsif ($style eq 'sf') {
                       push @$css,
                       map { $R::f->{$_} || die "no style $_"}
                           split '_', $cs;
                       #sayre "bit of sf: $cs";
               }
               elsif ($style eq 'css') {
                       $cs = join ';', map{"$_:$cs->{$_}"}
                           sort keys %$cs
                           if ref $cs;
                       push @$css, $cs;
                       sayre "bit of css: $cs" if ar.db;
               }
               elsif ($style eq 'id') {
                   at.id = $cs;
               }
               elsif ($style eq 'tt') {
                   at.title = $cs;
               }
               elsif ($style eq 'tag') {
                   at.tag = $cs;
               }
               elsif ($style =~ /^at:(\S+)$/) {
                   $at->{$1} = $cs;
               }
               elsif ($style eq 'path') {
                   # TODO compile J.ys
                   # should get %idly if not lev/gp too
               }
               elsif ($style eq 'origin') {
               }
               elsif ($style eq 'waves') {
               }
               elsif ($style eq 'pwar') {
               }
               elsif ($style eq 'Joint') {
               }
               elsif ($style eq 'idly') { # is knowable j id
                   my $id = $H->mkuid;
                   at.id && die "arl";
                   at.id = $id;
                   J.idyl->($J, $id, $j);
               }
               else {
                   die "style??".wdump[$style,$cs];
               }
           }
           @$css = map {
               join '', map{"$_;"} grep{defined} split ';', $_
           } @$css;
           # TODO hold things in pockets relative to origin css comment
           # to help things break down into styles better
           at.style = join '', map{"$_;"}
               grep{defined} map { split ';' } @$css;
           
           # /////////////////////////////////////////////////////
           
     'maka 7': | #c thingness <-> appearance
       # stylecompressor 3s6 aboves
       # hooch
           if (at.title || !a.untitled) {
               at.title = join " ", grep{defined}
                   (!a.untitled ? "j.cv $l" : undef),
                   (at.title ? at.title : undef);
           }
           my $tag = delete at.tag;
           my $ts = j.l;
           $ts =~ s/[^\w]/ñ/sg;
           $tag ||= "a$ts";
           $at = join " ", $tag,
               map { saybl " : $_ " if $cssdb; $_ }
               map { $_.'="'.$at->{$_}.'"' } # attra
               grep { $at->{$_} } sort keys %$at;
           
           $s = encode_entities($s) if !$ishtml;
           $s = "<$at>$s</$tag>" if defined $s;
           push @s, $s;
       }
       @s = "no?" if !@s;
       my $html = join '', @s;
       $html;
         
 - K: maky #c
   D: |
     die "hello" if ar.hello;
     if (my $id = J.id) {
         J.bz->("/%id\t0.9" => $id);
     }
     if (my $tod = J.makaz) {
           for (keys %$tod) {
               J.bz->($_ => $tod->{$_})
           }
       }
     'maka 4': | # thingness <-> appearance
       J.o = {};
       # shall create "/ 0.99" => something for this element
       # so that things last, embeds contooz
       # maybe J.by.maka.whol describes it, and provides its contooz (@s)
           # execution order in J.o is ev
           # / thing knows how to suck up others
       my $vs = Rw tyv $J;
       #my @things = Rw tvy $J;
       my @s;
       J.ty.maka.s = \@s;
       
       my @things = @$vs;
       while (@things) {
           my $lv = shift @things;
           my $j = lv.j;
           my $sc = lv.sc;
           my $s = j.s;
           my $l = j.l;
           #say "j.r \t\t". join "\t", sort keys %$sc; # gp($sc->{$_})
           
           my $cssdb = 0;
           
           sayyl " thji: j.r" if $cssdb;
           if (j.l eq '/') {
               die "god non 0.9 && j.l eq '/'".wdump(2,$j)
                   if j.cv != 0.9;
               if (@things) {
                   push @things, $lv; # defer to last
                   next;
               }
           }
           die "reffy $s in $l".wdump(2,$j) if ref $s;
           
           # want to do a bit of voltage vading, opacity...
           # to all the little j makas in the most.J J
           # should take about 1 second
           # can move across network
           
           # top volt for thing selection?: # whattage
           # skip o0 &&verlap of K + name
           next if $l eq 'K' && J.bb->{"name 0.1"} eq $s
              && $s ne J.bb->{"K 0.2"};

           my $ishtml;
           my $at = {};
           my $css = [];

           if ($l eq '/') {  # thingness # swoosh, swallows up the rest of @s
               # could know this is coming and defer tiny contents
               # favour big picture, only need to surf by...
               # water keeps watering anywhere you look at it
               # the @s gets too big for one message too
               $ishtml = 1;
               $s = join "", @s;
               @s = ();
           }
     'maka 5.5': | # appearance
           for my $k (sort keys %$sc) {
               my $cs = $sc->{$k};
               my ($style,$com) = split '#', $k;
               
               for ($style) {
                   # < >< >< >?
                   # < >< >< >?
                   # Jung Cs have injected langauge
                   # to grab themselves by...
                   # < >< >< >?
                   $ishtml = 1 when 'gp';
                   $ishtml = 1 when 'lp';
                   $ishtml = 1 when 'ishtml';
                   # has a way to $a the gp action within...
                       
                   when ('sf') {
                       push @$css,
                       map { $R::f->{$_} || die "no style $_"}
                           split '_', $cs;
                       sayre "bit of sf: $cs";
                   }
                   when ('css') {
                       $cs = join ';', map{"$_:$cs->{$_}"}
                           sort keys %$cs
                           if ref $cs;
                       push @$css, $cs;
                       sayre "bit of css: $cs" if ar.db;
                   }

                   at.id = $cs when 'id';
                   at.title = $cs when 'tt';
                   at.tag = $cs when 'tag';

                   # TODO compile J.ys
                   when ('path') {
                       # should get %idly if not lev/gp too
                   }
                   1 when 'origin';
                   1 when 'waves';
                   1 when 'Joint';
                   1 when 'lp';
                   when ('idly') { # is knowable j id
                       my $id = $H->mkuid;
                       at.id && die "arl";
                       at.id = $id;
                       J.idyl->($J, $id, $j);
                   }
                   default {
                       die "style??".wdump[$style,$cs];
                   }
               }
           }
           @$css = map {
               join '', map{"$_;"} grep{defined} split ';', $_
           } @$css;
           # TODO hold things in pockets relative to origin css comment
           # to help things break down into styles better
           at.style = join '', map{"$_;"}
               grep{defined} map { split ';' } @$css;
           
           # /////////////////////////////////////////////////////
           
     'maka 7': | # thingness <-> appearance
       # stylecompressor 3s6 aboves
       # hooch
           if (at.title || !a.untitled) {
               at.title = join " ", grep{defined}
                   (!a.untitled ? "j.cv $l" : undef),
                   (at.title ? at.title : undef);
           }
           my $tag = delete at.tag;
           saybl "Tag! $tag" if $tag;
           $tag ||= "añ";
           $at = join " ", $tag,
               map { saybl " : $_ " if $cssdb; $_ }
               map { $_.'="'.$at->{$_}.'"' } # attra
               grep { $at->{$_} } sort keys %$at;
           
           $s = encode_entities($s) if !$ishtml;
           $s = "<$at>$s</$tag>" if defined $s;
           push @s, $s;
       }
       @s = "no?" if !@s;
       my $html = join '', @s;
       $html;
         

