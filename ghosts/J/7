R_Jz:


 - K: outhere #c out
   D: |
     my @d = grep { _.t eq _.l } w $R tvo(J=>J.pha); # !style||com
     
     for my $j (@d) {
         my $here = j.s;
         # unwind # TODO wind blowing crazy
         my $swish = $RADIAN*4;
         $swish *= -1 if here.rad < 0;
         # coil something something
         here.rad -= $swish until here.rad < $RADIAN*4;
         
         # random angle like L, find the \ direction at least
         # its mass would be good too
         # share space with curves
         my $rad = here.rad;
         my $radleg = -$RADIAN;
         # and pan to hemisphere...#
         # from O- is it in the left hemisphere etc
          $radleg *= -1 unless $rad < -$RADIAN && $rad > $RADIAN;
         $rad -= $radleg; 
         
         my $ere = {
             left => here.left,
             radial => sprintf('%.5f', $rad),
             angle => sprintf('%.5f', here.rad),
             x => sprintf('%.5f', here.x),
             y => sprintf('%.5f', here.y),
         };
         
         #sayre ">>>> yep @ent  j.cv    ". j.t;
         
         # loses its compressibility as csz
         # unless we use %css#omments to spread em
         for (
         [ XY => {
           top => (ere.y * 100).'%',
           left => (ere.x * 100).'%',
         } ],
         [ Ro => {
           '-webkit-transform' => 'rotate('.ere.radial.'rad)',
         } ],
         [ R => {
           position => 'absolute',
           'transform-origin' => '0% 0%',
         } ],
         ) {
             J.bz->("j.t%css#pha-$_->[0]\t".j.cv => $_->[1]); # concert per emportar
         }
         
         J.bz->(
             "j.t%tt\t".j.cv =>  # concert per emportar
             "*".ere.radial
         );
      }
      Rw suck */outhere;
      sayre join " ", (">") x scalar(@d);
 - K: stylo #c OUT
   D: |
 - K: retile #c # TODO use L & J
   D: | 
    my @m = map { /W\/(.+)$/ } H.r->keys("W/*");
    @m = map { $H->djson(H.r->get("W/$_")) } @m;
    
    H.G w TODOWhack(meta=>$_) for grep { _.dead } @m;
    @m = grep { !_.dead } @m;
    
    @m = grep { _.styles =~ /\bNZ\b/ } @m;
    @m = sort { a.hol cmp b.hol } @m;
    
    my $space = 1;
    $space += 0.5 until $space * $space >= @m;
    my $r = floor $space;
    my $l = ceil $space;
    my $div = ["width:left $l", "height:top $r"];
    
    say "needed ".@m." so $space is $l $r";
    
    my $grid = {};
    for my $p (@$div) {
        my ($iv, $parts) = split ' ', $p;
        my ($mags, $ax) = split ':', $iv;
        # magnitudes of width
        # axed from unified by left, etc.
        my $in = sprintf("%.3f", 1 / $parts);
        
        my @ground = map { [$_ => $grid->{$_} ] } sort keys %$grid;
        @ground = [] if !@ground;
        my $pole = [];
        $grid = {};
        
        my $here = 0; # in accum
        for my $i (1..$parts) {
            my $ox = {};
            ox.part = $i;
            $ox->{$ax} = $here;
            $here += $in;
            $ox->{$mags} = $in;
            push @$pole, $ox;
        }
        
        for my $g (@ground) {
            my ($k, $v) = @$g;
            $v ||= {};
            for my $ox (@$pole) {
                my $K = (defined $k?"$k ":"") . ox.part;
                my $x = $grid->{$K} = {%$v, %$ox};
                delete x.part;
            }
        }
    }
    
    my @holes = sort keys %$grid;
    say "Got ".@m." pegs for ".@holes." holes: ".wdump[@m];
    for my $meta (@m) {
        my $h = shift @holes;
        my $o = {%{$grid->{$h}}};
        
        $o->{$_} = ($o->{$_} * 100)."%" for keys %$o;
        
        meta.ces = $o;
        H.r->set("W/meta.Wid" => $H->ejson($meta));
        
        my $cssset = ".animate(".$H->ejson($o).", 0)";
        my $unhide = ".removeClass('NZ')";
        
        $H->send(" \$('#".meta.Wid."')$cssset$unhide".";");
    }


 - K: Smak #c
   babz:
     'S 7': |
       my $html = w $R maka(R=>$R, a=>S.a, cv => 0);

 - K: prot_fits #c
   babz:
     'S#proto_fits 8.7': |
       # proto fits: shrink this webbing into a space in our webbing
       my @sty;

       my $o = 12;
       my $lines = split /\n/, $html;
       if ($lines > $o) {
           $lines = 17 if $lines > 17;
           my $fs = 100 * $o / $lines;
           $fs *= -1 if $fs < 0;
           push @sty, "font-size:$fs%";
       }
       push @sty, "background:rgba(80,50,22,0.3)"; 
       push @sty, "white-space:pre";
       push @sty, "font-family:mono";
       push @sty, "display:block";
       push @sty, "overflow-wrap:break-word";
       my $sty = join ";", @sty; 
       $html = qq{<span style="$sty"><span>$html<span></span>};
   
 - K: maka #c
   D: |
     my $cv = ar.cv; 
     $cv = a.cv if !defined $cv;
     my $a = ar.a || ar.J;
   babz:
     'maka 1': | #c
       if (my $id = a.isJid || a.replaceJid) {
           a.bz->("/%id\t"."0.1" => $id);
       }
       if (my $tod = a.makaz) {
           for (keys %$tod) {
               a.bz->($_ => $tod->{$_})
           }
       }
     'maka 2.5': | #c stylepliers
         for my $k (%{a.bb}) {
             if ($k =~ /^(\S*(?:oB|Bo|Bi|Bs))\s+(.+)$/) {
                 a.bb->{"$1\%css#maka25\t$2"} = "color:black";
             }
             if ($k =~ /^thi\s+(.+)$/) {
                 a.bb->{"thi\%css#maka25\t$1"} = "text-decoration:underline";
             }
             if ($k =~ /^name\s+(.+)$/) {
                 a.bb->{"name\%css#maka25\t$1"} = "color:#f93;";
             }
             if ($k =~ /^K\s+(.+)$/) {
                 a.bb->{"K%css#maka25\t$1"} = "color:#3f3";
             }
         }
     'maka 4': | #c thingness <-> appearance
       my @r = $G->stylekeysort(a.bb);

       a.o = {}; # by voltage, peel
       for my $r (@r) {
               my ($l, $vo, $or) = split /\s+/, $r; # split style, vectory

               $or = $vo if !defined $or;

               my $o = a.o->{$or} ||= []; 
               push @$o, $r;
       }
       
           #thingness <-> appearance
           my $th = {};
           my $ap = {};
           my @int;
           for my $ov (sort keys %{a.o}) {
                my $o = a.o->{$ov};

                for my $r (@$o) {
                    my $j = $R->shj($r, a.bb);
                    
                    j.style ? do {
                        push @{$ap->{j.l} ||= []}, $j;
                    } : do {
                        if (exists $th->{j.l}
                        && j.t ne '#more%sf' # wtf
                        && j.l ne 'name') {
                            warn "replacemont j.l ".wdump(3,[$j,$th->{j.l}]) 
                        }
                        $th->{j.l} = $j;
                        push @int, j.l;
                    }
               }
           }
     'maka 6.5': | #c
       my $apl = sub {
           my ($l, $s, $j) = @_;

           my $o = delete $ap->{$l};

           if (ref $s) {
               die "reffy $s in $l".wdump(2,$j);
           }
           #sayyl "for the $l\t\t".slim(150,150,$s) for 1..5;

           my $ishtml = $l eq '/';
           my $gp;
           my $at = {};
           my $tag = "a√±";
           my $css = [];
           for my $oj (@$o) {
               saybl "        sdtyle! oj.style oj.s" if ar.db;

               # TODO here Jung Cs have injected langauge to grab themselves by...
               for (oj.style) {

                   # < >< >< >?
                   # < >< >< >?
                   # < >< >< >?
                   # < >< >< >?
                   # < >< >< >?
                   # < >< >< >?
                   when ('gp') {
                       # has a way to $a the gp action within...
                       $gp = oj.s;
                       $ishtml = 1;
                   }
                   when ('lp') {
                       $ishtml  = 1;
                   }
                   when ('sf') {
                       push @$css, map { $R::f->{$_} || die "no style $_"}
                           split '_', oj.s;
                   }
                   when ('css') {
                       my $cs = oj.s;
                       $cs = join ';', map{"$_:$cs->{$_}"}
                           sort keys %$cs
                           if ref $cs;
                       push @$css, $cs;
                   }
                   $ishtml = 1 when 'ishtml';

                   at.id = oj.s when 'id';

                   at.title = oj.s when 'tt';

                   $tag = oj.s when 'tag';

                   # TODO compile J.ys
                   1 when 'path';
                   1 when 'origin';
                   1 when 'Joint';
                   1 when 'lp';
                   default {
                       die "style oj.style = oj.s \t for $l";
                   }
               }
           }
           # TODO hold things in pockets relative to origin css comment
           # to help things break down into styles better
         at.style = join '', map{"$_;"}
             grep{defined} map { split ';' } @$css;
     'maka 6.6': | #c
       # stylecompressor 3 aboves
           # hooch
           if (at.title || !a.untitled) {
               at.title = join " ", grep{defined}
                   (!a.untitled ? "j.cv $l" : undef),
                   (at.title ? at.title : undef);
           }
           $at = join " ", $tag,
               map { $_.'="'.$at->{$_}.'"' } # attra
               grep { $at->{$_} } sort keys %$at;

           $s = encode_entities($s) if !$ishtml;
           $s = "<$at>$s</$tag>" if defined $s;
           $s
       };
     'maka 7': | #c
         my @s;
         for my $thl (@int) {
             my $j = $th->{$thl} || next;
             my $l = j.l;
             my $s = j.s;
             die "$l  -- $thl" if $thl ne $l;
             
             # top volt for thing selection: # whattage
             if ($l eq 'K' && a.bb->{"name 0.1"} eq $s
              #|| $l eq 'name' && a.bb->{"K 0.2"} =~ $s
              && $s ne a.bb->{"K 0.2"}) {
                 delete $ap->{$l};
                 next;
             }
                 
             push @s, $apl->($l, $s, $j);
         }
         
         @s = "no?" if !@s;
         my $html = $apl->('/', join '', @s);
         
             sayre "Extr a appearance: ".
             join", ",sort keys %$ap if %$ap;
         
         #sayyl join "  ", map { _.G.name .": _.point _.id" } grep {_.name eq 'D'} reverse @F;
         $html;
         

