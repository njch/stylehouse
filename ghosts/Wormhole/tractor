
hooks:
  rr: |
    $G->{As} = [ $O->tractors ];
    my @AA;
    for my $A (@{$G->{As}}) {
        if (w $A arr_if) {
            push @AA, $A->spawn();
        }
    }
    
    if (!@AA) {
        die "No traction for! ".join "  ", %$ar;
    }
    
    die "CROWD OF TRACTORS" if @AA > 1;
    for my $A (@AA) {
        $A->{B} = {
            _ => scalar(w $A B_),
            %$ar,
        };
    }
    
    for my $A (@AA) {
        
        if (my $Already = w retract(A => $A)) {
            $Already->{B} = $A->{B};
            $A = $Already;
            say "retracted  ".join " ", %$ar;
            w $A nonfirst_times;
        }
        else {
            $A = $A->spawn;
            say "First time for  ".join " ", %$ar;
            w $A first_time;
        }
        $O->{t} = $A;
    }
    
    return @AA    ;
  retract: |
    my @keep;
    my @found;
    for my $line (@{ $O->W->{script} }) {
        #$H->info("Line: $line", $O->{name}, $line);
        next if ref $line eq "ARRAY" && @$line == 0; # wtf case
        if ($line->{t}->{B}->{_} eq $A->{B}->{_}) { # ar this to W->{G}?
             push @found, $line;
        }
        else {
            push @keep, $line;
        }
    }
    $O->W->{script} = \@keep;
    return if !@found;
    return $found[0]->{t};
  find: |
    my @wheres;
    while (my ($k, $v) = each %$ar) {
        push @wheres, [ $k, $v ];
    }
    for my $line (@{ $O->W->{script} }) {
        #$H->info("Line: $line", $O->{name}, $line);
        next if ref $line eq "ARRAY" && @$line == 0; # wtf case
        my $A = $line->{t};
        return $A if @wheres == grep {
            !exists $A->{B}->{$_->[0]} ||
                $A->{B}->{$_->[0]} eq $_->[1]  } @wheres
    }

