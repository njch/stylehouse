hooks:

  write_cone: |
      # so stupidly retarded
      # use quantum fector to drop things down
      # exhaustingly haphazard machinery crammed into the rounding error factory
      # make rounding error factory factory
      eval { write_file(@$arm) };
      if ($@) {
          my ($file) = @$arm;
          run(-in => sub{ print "   H.style \n"; },
              -out => '/tmp/fuuf',
              'xxd');
          say ''.`cat /tmp/fuuf`;
          if ($@ =~ /sysopen: No such file or directory/) {
          }
          elsif ($@ =~ /sysopen: Is a directory/) {
              my $wtah = "-f $file == ".-f $file;
              warn "thinks it's a directory: $wtah";
          }
          else {
              die "UNKNOWN WRITE CONE E\n\n$@"
          }
          sayre "Recovering from write error::: $@";
          my $fore = $file;
          $file =~ s/[^\w\/\-\.]//g; # TODO nulls
          if ($fore ne $file) {
                  warn "NONNAMES OR SO, HEXDUMP IT $fore -> $file";
          }
          
          
          my @chun = split '/', $file;
          my $fn = pop @chun;
          say "    file: $file";
          my @try = shift @chun;
          push @try, join '/', $try[-1], $_ for @chun;
          my @nodir;
          for my $d (reverse @try) {
              if (-d $d) {
                  sayyl "$d DIR EXISTS!";
                  last;
              }
              push @nodir, $d;
          }
          say "Not existing dirs: ".wdump[@nodir];
          sayre "Weeor was $!";
          undef $!;
          say "==========";
          my $broke;
          for my $d (reverse @nodir) {
              saybl "try to make_path $d";
              mkdir $d;
              if ($!) {
                  sayre "mkdir $d: $!";
                  $broke = 1;
              }
              if (!-d $d) {
                  sayre "not exist after";
                  $broke = 1;
              }
          }
          
          
          if ($broke) {
              warn "cionedddd.....\n\nWrite $file fuckup: $@";
          }
          $@ = "";
      }

  aj: |
    my $W = j.W; # wonky picture frame
    
    my $R = undef;
    my $meta = Rw mJ W $id:W.at.id;
    
    if (j._) {
        meta.unified = 1;
        meta.styles = W.at.styles;
        
        w lifage[$meta];
        # or Rw tp J $n:meta.Wid $i:meta;
        # and it ref > jsons
        # somewhere ahead RNA compiles nicely into the walls
        # which extend to infinity
        # so recur-C surface
        
        G0.Wh->{meta.id} = $W; # TODO move Wh to A.h_W auto index
    }
    
    # the depths init codes once whole
    my @lot = reverse @{j.s}; # until whole
    push @lot, reverse @{j.c}; # from whole
    
    return sayre "H: empty J aj" unless @lot;
    
    my $m = join " ", @lot;
    $m = " $m"; # space is the y that tells js to eval TODO mt lma
    H.G w send_Elvis[$m, $meta];
  mJ: |
    my $meta = {};
    meta.y = shift @$m;
    meta.id = ar.id || $H->mkuid;
    meta.hol = "H.style/H.name/H.id";
    meta.hitime = $H->hitime;
    %$meta = (%$meta, %{ar.ar.meta}) if ar.ar.meta;
    $meta
  lifage: |
    sayyl "Life! of meta.y meta.id";
    0->tai("meta.y/meta.id\.i", $meta);
    my $tinymeta = {map{$_=>$meta->{$_}}qw{id y}};
    0->tac("V/H.style/H.name/H.id\.meta.y", $tinymeta);
  emana: |
    # yoyoyo
    saybl "Emanation! of meta.y meta.id";
    0->tai("meta.y/meta.id\.c", $m);
    
    my $tinymeta = {map{$_=>$meta->{$_}}qw{id y}};
    # tas many, eg W/this   and it all joints up
    $G->tas("meta.y", $tinymeta);
  spurtJcon: | # spurt J stuff + meta through link tinto moving zipper
    say "HIHI ".slim 30,$m;
    
    $G->tai("J/meta.Jid\.c", $m);
    # J should have an .i for meta + a skinny for v zipper
    
    $G->tas('J', $meta);
    # right right    
    
  Jexit: | #c setup the J suction of O (life/J.sc) (moving zipper)
    my $l = sub {
        my $m = shift;
        w JElvis[$m];
    };
    $G->taily->{ily}->('J', $l);
  send_Elvis: | # into the elvisphere! J comes out in Elvish on eg Omy $R = undef;
    # we are now a line, W->J revelation sheds from W which is also J
    
    if (H.O) {
        # websocket right here
        H.O w send_Elvis;
    }
    else {
        my $meta = Rw mJ - J $ar;
        w emana[$meta,$m];
    }
    
  O_Elvis: |
    my $Elvis = ar.Elvis || ar.E || H.who;
    my $cb = ar.cb;
    my @Elvis = grep {defined} flatline $Elvis;
    if (!@Elvis) {
        saybl "no infiduvia ----- will spring on .... ".slim($m);
        push @{H.Jels||=[]}, $m;
        return;
    }
    
    Rw newlinewarn $m if $m =~ /\n/;
    $m =~ s/\n//g;
    
    my $talk = "Elvis";
    $talk .= " ".ki(ar.meta) if ar.meta;
    saybl " < $talk ))) ".slim(60,90,$m);
    
    my @e = map { [$_, undef] } ref $Elvis eq "ARRAY" ? @$Elvis : $Elvis;
    $e[-1]->[1] = $cb if $cb;
    
    for my $e (@e) {
        my ($Elvis,$cb) = @$e;
        w $Elvis send[$m, $cb];
    }
  newlinewarn: |
    my $last = undef;
    my $wa;
    for my $l (split "\n", $m) {
        if (!defined $last) {
            $last = $l;
            next;
        }
        $wa .= " - ";
        $wa .= $1 if $last =~ /(.{,30})$/;
        $wa .= " --- HERE --- ";
        $wa .= slim(30, $l);
        $last = $l."\n";
    }
    warn "Message contains newlines: $wa\n\n";
    
  JElvis: | #c $m from the scrambling stream
    return if H.name eq 'Z';
    my $meta = djson $m;
    
    # TODO tri
    my $m = $G->tri('J/'.meta.id.'.c');
    chomp $m;
    
    my $del = sprintf '%.4f', scalar(hitime) - meta.hitime;
    saybl "meta.hol -> meta.Jid  (lag $del)    ";
    
      # thing may contain more J structure we don't know about but it's art
      # it may throw Emissive Js through from Building Js
      # possibly without traces of U the W fab in the middle
      # which is where we can wire travel through langths of Js
      # without the bridge building ie doming needed to find the path
      my $cb;
      if (meta.unified) {
          saygr "unifid styles: meta.styles";
          
          # is test # could be more meta over there
          $G->tri('W/'.meta.Wid.'.i') || die "no such meta.Wid";
          # ^ more meta than $meta, which is from the moving zipper
          if (meta.styles =~ /\bNZ\b/) {
              $cb = sub {
                w mux(as=>"unified meta.Wid ( meta.hol");
              };
          }
      }
      $m = " $m"; 
      w to_Elvis[$m, $meta, $cb];
      
  to_Elvis: |
    my $Elvis = ar.Elvis || ar.E || H.who;
    my $cb = ar.cb;
    if (!$Elvis || ref $Elvis eq "ARRAY" && !@$Elvis) {
        saybl "no infiduvia ----- will spring on .... ".slim($m);
        push @{H.Jels||=[]}, $m;
        return;
    }
    $m =~ /\n/ && say "Message contains \\n:\n$m\n\n";
    $m =~ s/\n//g;
    
    my $talk = "Elvis";
    die wdump ar.meta if ar.meta;
    
    if (my $m = ar.meta) {
        $talk .= " meta.hol meta.Jid";
        $talk .= " meta.id" if meta.id;
        $talk .= " meta.unified" if meta.unified;
    }
    
    
        $m =~ s/\x{0}//sgm && die "HADH NULL";

    saybl " < $talk ".slim(160,190,$m);
    
    my @e = map { [$_, undef] } ref $Elvis eq "ARRAY" ? @$Elvis : $Elvis;
    $e[-1]->[1] = $cb if $cb;
    
    for my $e (@e) {
        my ($Elvis,$cb) = @$e;
        w $Elvis send[$m, $cb];
    }

