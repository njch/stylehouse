hooks:

  write_cone: | # so stupidly retarded # use quantum fector to drop things down
      eval { write_file(@$arm) };
      if ($@) {
          my ($file) = @$arm;
          run(-in => sub{ print "   H.style \n"; },
              -out => '/tmp/fuuf',
              'xxd');
          say ''.`cat /tmp/fuuf`;
          if ($@ =~ /sysopen: No such file or directory/) {
          }
          elsif ($@ =~ /sysopen: Is a directory/) {
              my $wtah = "-f $file == ".-f $file;
              warn "thinks it's a directory: $wtah";
          }
          else {
              die "UNKNOWN WRITE CONE E\n\n$@"
          }
          sayre "Recovering from write error::: $@";
          my $fore = $file;
          $file =~ s/[^\w\/\-\.]//g; # TODO nulls
          if ($fore ne $file) {
                  warn "NONNAMES OR SO, HEXDUMP IT $fore -> $file";
          }
          
          
          my @chun = split '/', $file;
          my $fn = pop @chun;
          say "    file: $file";
          my @try = shift @chun;
          push @try, join '/', $try[-1], $_ for @chun;
          my @nodir;
          for my $d (reverse @try) {
              if (-d $d) {
                  sayyl "$d DIR EXISTS!";
                  last;
              }
              push @nodir, $d;
          }
          say "Not existing dirs: ".wdump[@nodir];
          sayre "Weeor was $!";
          undef $!;
          say "==========";
          my $broke;
          for my $d (reverse @nodir) {
              saybl "try to make_path $d";
              mkdir $d;
              if ($!) {
                  sayre "mkdir $d: $!";
                  $broke = 1;
              }
              if (!-d $d) {
                  sayre "not exist after";
                  $broke = 1;
              }
          }
          
          
          if ($broke) {
              warn "cionedddd.....\n\nWrite $file fuckup: $@";
          }
          $@ = "";
      }
  JElvis: | #c $m from the scrambling stream
    return if H.name eq 'Z';
    my $meta = djson $m;
    
    # TODO tri
    my $m = $G->tri('J/'.meta.Jid.'.c');
    chomp $m;
    
    my $del = sprintf '%.4f', scalar(hitime) - meta.hitime;
    saybl "meta.hol -> meta.Jid  (lag $del)    ";
    
      # thing may contain more J structure we don't know about but it's art
      # it may throw Emissive Js through from Building Js
      # possibly without traces of U the W fab in the middle
      # which is where we can wire travel through langths of Js
      # without the bridge building ie doming needed to find the path
      my $cb;
      if (meta.unified) {
          saygr "unifid styles: meta.styles";
          
          # is test # could be more meta over there
          $G->tri('W/'.meta.Wid.'.i') || die "no such meta.Wid";
          # ^ more meta than $meta, which is from the moving zipper
          if (meta.styles =~ /\bNZ\b/) {
              $cb = sub {
                w mux(as=>"unified meta.Wid ( meta.hol");
              };
          }
      }
      $m = " $m"; 
      w to_Elvis[$m, $meta, $cb];
      
  lifage: |
    return if H.name eq 'Z';
    sayyl "Life! of meta.Wid";
    my $W = "W meta.Wid";
    0->tai("W/meta.Wid\.i", $meta);
    0->tac("V/H.style/H.name/H.id\.W", "W meta.Wid");
  aj: |
    my $W = j.W; # wonky picture frame
    
    my $meta = {};
    meta.hol = "H.style/H.name/H.id";
    meta.Wid = W.at.id;
    
    if (j._) {
        meta.unified = 1;
        meta.styles = W.at.styles;
        meta.hitime = $H->hitime;
        
        w lifage[$meta];


        # or Rw tp J $n:meta.Wid $i:meta;
        # and it ref > jsons
        # somewhere ahead RNA compiles nicely into the walls
        # which extend to infinity
        # so recur-C surface
        
        G0.Wh->{meta.Wid} = $W; # TODO move Wh to A.h_W auto index
    }
    
    my @lot = reverse @{j.s}; # until whole
    push @lot, reverse @{j.c}; # from whole
    
    return sayre "H: empty J aj" unless @lot;
    
    my $m = join" ", @lot;
    $m = " $m"; # two spaces, tells js to eval
    H.G w send_Elvis[$m, $meta];
  spurtJcon: | # spurt J stuff + meta through link tinto moving zipper
    say "HIHI ".slim 30,$m;
    
    $G->tai("J/meta.Jid\.c", $m);
    # J should have an .i for meta + a skinny for v zipper
    
    $G->tas('J', $meta);
    # right right    
    
  Jexit: | #c setup the J suction of O (life/J.sc) (moving zipper)
    my $l = sub {
        my $m = shift;
        w JElvis[$m];
    };
    $G->taily->{ily}->('J', $l);

