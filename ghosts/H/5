hooks:

  write_cone: |
      # so stupidly retarded
      # use quantum fector to drop things down
      # exhaustingly haphazard machinery crammed into the rounding error factory
      # make rounding error factory factory
      eval { write_file(@$arm) };
      if ($@) {
          my ($file) = @$arm;
          if ($@ =~ /sysopen: No such file or directory/) {
          }
          elsif ($@ =~ /sysopen: Is a directory/) {
              my $wtah = "-f $file == ".-f $file;
              warn "thinks it's a directory: $wtah";
          }
          else {
              die "UNKNOWN WRITE CONE E\n\n$@"
          }
          sayre "Recovering from write error::: $@";
          my $fore = $file;
          $file =~ s/[^\w\/\-\.]//g; # TODO nulls
          if ($fore ne $file) {
                  warn "NONNAMES OR SO, HEXDUMP IT $fore -> $file";
          }
          
          my @chun = split '/', $file;
          my $fn = pop @chun;
          say "    file: $file";
          my @try = shift @chun;
          push @try, join '/', $try[-1], $_ for @chun;
          my @nodir;
          for my $d (reverse @try) {
              if (-d $d) {
                  sayyl "$d DIR EXISTS!";
                  last;
              }
              push @nodir, $d;
          }
          say "Not existing dirs: ".wdump[@nodir];
          sayre "Weeor was $!";
          undef $!;
          say "==========";
          my $broke;
          for my $d (reverse @nodir) {
              saybl "try to make_path $d";
              mkdir $d;
              if ($!) {
                  sayre "mkdir $d: $!";
                  $broke = 1;
              }
              if (!-d $d) {
                  sayre "not exist after";
                  $broke = 1;
              }
          }
          
          sayyl "Doing again---";
           eval {
             write_file(@$arm)
           };
           if ($@) {
             say "Fucked up again: $@";
           }
          
          
          if ($broke) {
              warn "cionedddd.....\n\nWrite $file fuckup: $@";
          }
          $@ = "";
      }
  aj: |
    my $W = j.W; # wonky picture frame
    
    my $meta = Rw mJ W $id:W.at.id;
    
    if (j._) {
        # we are now a line, W->J revelation sheds from W which is also J
        meta.unified = 1;
        meta.styles = W.at.styles;
        
        Rw lifage $meta;
        
        G0.Wh->{meta.id} = $W;
        # TODO vectory auto index
    }
    # the depths init codes once whole
    my @lot = reverse @{j.s}; # until whole
    push @lot, reverse @{j.c}; # from whole
    
    return sayre "H: empty J aj" unless @lot;
    
    my $m = join " ", @lot;
    $m = " $m"; # space is the y that tells js to eval TODO mt lma
    w send_Elvis[$m, $meta];
  Jexit: | #c send elvis ^  v sock elvis  J suction of moving zipper
    sayre "RHWOHOHOHOOH" for 1..3; 
    Rw slw J Jslw;
  slw: | #c slw of stimuli
    my ($y,$z) = @$m;
    my $l = sub {
        $G->w($z,{m=>shift});
    };
    $G->ily($y, $l);
    
  send_Elvis: | # into the elvisphere! network away to O
    # W nativey aj ($W should be involved) and send() things mergey
    #say "on send Elvis";
    if (H.O) {
        Rw sock_Elvis;
    }
    else {
        my $meta = Rw mJ J;
        my $int = " W:ar.W.y ar.W.id   " if ar.W;
        #say "Emanating $int meta.y";
        w emana[$meta,$m];
    }
  Jslw: | #c $m from the scrambling stream of J KEEP
    die if H.name eq 'Z';
    my $meta = djson $m;
    
    # TODO tri
    my $m = $G->tri("meta.y/meta.id\.c");
    
      my $cb;
      if (meta.W) {
          saygr "unifid styles: meta.styles";
          
          # is test # could be more meta over there
          $G->tri("meta.y/meta.id\.i")
          || die "no such meta.id";
          # ^ more meta than $meta, which is from the moving zipper
          if (meta.styles =~ /\bNZ\b/) {
              $cb = sub {
                w mux(as=>"unified meta.Wid ( meta.hol");
              };
          }
      }
      #$m = " $m";
      my $W  = $meta;
      
      w send_Elvis[$m, $W, $cb];
      
  sock_Elvis: |
    my $Elvis = ar.Elvis || ar.E || H.who;
    my @Elvis = grep {defined} flatline $Elvis;
    @Elvis = H.who if !@Elvis;
    
    if (!@Elvis) {
        saybl "no infiduvia ----- will spring on .... ".slim($m);
        push @{H.Jels||=[]}, $m;
        return;
    }
    
    my @M = grep{length} split "\n", $m;
    
    my $cb = ar.cb;
    
    $m =~ /^(.{,90})/;
    for my $m (@M) {
        for my $Elvis (@Elvis) {
            next if ref $Elvis eq 'ARRAY';
            saybl " < ".$Elvis->pi." ))) ".slim(100,100,$m);
            w $Elvis send[$m, $cb];
        }
    }
  mJ: |
    my $meta = {};
    meta.y = shift @$m;
    meta.id = ar.id || $H->mkuid;
    meta.hol = "H.style/H.name/H.id";
    meta.hitime = $H->hitime;
    die if ar.ra;
    %$meta = (%$meta, %{ar.ra.meta}) if ar.ra.meta;
    $meta
  lifage: |
    sayyl "Life! of meta.y meta.id";
    0->tai("meta.y/meta.id\.i", $meta);
    my $tinymeta = {map{$_=>$meta->{$_}}qw{id y}};
    0->tac("V/H.style/H.name/H.id\.s", $tinymeta);
  emana: |
    # yoyoyo
    #saybl "Emanation! of meta.y meta.id ".(ar.k?"@ ar.k":"")."    > ".slim(40,40,$m) if !H.isforked;
    0->tai("meta.y/meta.id\.c", $m);
    
    my $tinymeta = {map{$_=>$meta->{$_}}qw{id y}};
    # tas many, eg W/this   and it all joints up
    $G->tas("meta.y", $tinymeta);
  nlwanr: |
    my $last = undef;
    my $wa;
    for my $l (split "\n", $m) {
        if (!defined $last) {
            $last = $l;
            next;
        }
        $wa .= " - ";
        $wa .= $1 if $last =~ /(.{,30})$/;
        $wa .= " --- HERE --- ";
        $wa .= slim(30, $l);
        $last = $l."\n";
    }
    warn "Message contains newlines: $wa\n\n";
    $m =~ s/\n//g;
    $m
    

