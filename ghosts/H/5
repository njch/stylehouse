hooks:
  Jexit: | #c setup the J suction of O (life/J.sc) (moving zipper)
    my $l = sub {
        my $m = shift;
        w JElvis[$m];
    };
    $G->taily->{ily}->('J', $l);
  JElvis: | #c $m from the scrambling stream
    my $meta = djson $m;
    
    my $dir = $G->taily->{rr}->('J');
    my $file = $dir.'/'.meta.Jid.'.c';
    
    my $del = sprintf '%.4f', scalar(hitime) - meta.hitime;
    saybl "meta.hol -> meta.Jid  (lag $del)    ". -s $file;
    my $m = read_file($file);
  
      # thing may contain more J structure we don't know about but it's art
      # it may throw Emissive Js through from Building Js
      # possibly without traces of U the W fab in the middle
      # which is where we can wire travel through langths of Js
      # without the bridge building ie doming needed to find the path
      my $cb;
      if (meta.unified) {
          saygr "unifid styles: meta.styles";
          
          # is test # could be more meta over there
          my $hmm = H.r->get("W/meta.Wid") || die "no such meta.Wid";
          
          if (meta.styles =~ /\bNZ\b/) {
              
              $cb = sub {
                w mux(as=>"unified meta.Wid ( meta.hol");
              };
          }
      }
      $m = " $m"; 
      w to_Elvis[$m, $meta, $cb];
      
  aj: |
    my $W = j.W;
    
    my $meta = {};
    meta.hol = "H.style/H.name/H.id";
    meta.Wid = W.at.id;
    
    if (j._) {
        meta.unified = 1;
        # W homing
        meta.styles = W.at.styles;
        meta.hitime = $H->hitime;
        
        H.r->set("W/meta.Wid" => $H->ejson($meta));
        
        H.r->set("V/H.id/meta.Wid" => 1);
        G0.Wh->{meta.Wid} = $W; # TODO move Wh to A.h_W auto index
    }
    
    my @lot = reverse @{j.s}; # until whole
    push @lot, reverse @{j.c}; # from whole
    
    return sayre "H: empty J aj" unless @lot;
    
    my $m = join" ", @lot;
    $m = " $m"; # two spaces, tells js to eval
    H.G w send_Elvis[$m, $meta];
  spurtJcon: | # spurt J stuff + meta through link tinto moving zipper
    say "HIHI ".slim 30,$m;
    
    my $dir = $G->taily->{rr}->('J');
    my $f = $dir.'/'.meta.Jid.'.c';
    die "al$f" if -e $f;
    
    fspu($f, $m);
    # J should have an .i for meta + a skinny for v zipper
    
    my $s = ejson $meta;
    $s .= "\n";
    my $scf = $G->taily->{rw}->('J');
    fscc($scf, $s);
    
    # right right
    warn "on met! $1" if $s =~ /(.{,20}\n.{,20})/;
    warn "con n ving! $1" if $m =~ /(.{,20}\n.{,20})/;
        
    
  taily: | #c
    my $y = G.taily ||= {};
    #
    y.rw = sub {
      my $x = y.spc->(@_);
      my $link = x.fi.'.s';
      my $s = readlink $link if -e $link;
      $s || die "nowherewhere".wdump($x);
      x.d.'/'.$s
    };
    y.rr = sub {
      my $x = y.spc->(@_);
      y.mk->($x) unless -d x.fi;
      return x.fi;
    };
    
    y.spc = sub {
      my $f = pop;
      my $o = pop || 'life';
      my $fi = "$o/$f";
      my $x = G.taily.f->{$fi} ||= {};
      if (!x.fi) {
          x.fi = $fi;
          x.f = $f;
          x.o = $o;
          x.t = $1 if $fi =~ /\/(.+?)$/;
          x.d = $1 if $fi =~ /^(.+)\/.+?$/;
      }
      $x
    };
    
    y.ily = sub { # one l/ily per file
      my $l = pop;
      my $x = y.spc->(@_);
      x.l = $l;
      x.lots = ['sc','sc2'];
      
      y.mk->($x);
      y.zipl->($x);
      
      for (@{x.lots}) {
          my $file = x.fi.'.'.$_;
          y.tailf->($x, $file);
      }
      
      y.wtfy->($x);
    };
    
    y.mk = sub {
      my $x = shift;
      run 'mkdir', '-p', x.fi unless -d x.fi;
      die "no go diggy x.fi" unless -d x.fi;  
    };
    
    y.zipl = sub {
      my $x = shift;
      for (@{x.lots}) {
          my $file = x.fi.'.'.$_;
          `cat /dev/null >> $file`;
          die "go figgy $file" unless -f $file;
      }
    };
    
    y.l_lines = sub {
      my $x = shift;
      my $b = shift;
      my $file = shift;
      y.burp->($x);
      for my $m (split "\n", $b) {
          next unless $m;
          x.l->($m);
      }
    };
    
    y.burp = sub {
      my $x = shift;
      my $time = hitime;
      x.hitime ||= $time;
      if ($time - x.hitime > 42) {
          y.wtfy->($x);
      }
    };
    
    y.wtfy = sub {
      my $x = shift;
      my $link = x.fi.'.s';
      
      my $s = readlink $link if -e $link;
      my $ex = $1 if $s && $s =~ /\.(.+?)$/;
      my ($next) = reverse reverse(@{x.lots}), reverse grep { !$ex || $_ eq $ex && do {$ex=0} } @{x.lots};
      # forth and around
      my $wt = x.t.'.'.$next;

      sayyl "ln $link    $s -> $wt";

      `ln -fs $wt $link`;

      if ($s) {
          my $sif = x.d.'/'.$s;
          # TODO acquire lock (first hol line in lock file wins, wait 0.1)
          0->timer(0.4, sub {
              my $siz = -s $sif;
              0->timer(2.3, sub {
                  y.squash->($x, $sif, $siz);
              });
          });
      }
    };
    
    y.squash = sub {
      my $x = shift;
      my $sif = shift;
      my $siz = shift;
      my $siz2 = -s $sif;
      if ($siz != $siz2) {
          warn "$sif got written to sinze changing link!?";
      }
      `cat /dev/null > $sif`;
      sayre "Cleaned $sif";
    };
    
    y.tailf = sub {
      my $x = shift;
      my $file = shift;
      sayyl "Tailing $file";
      my $al = x.s->{$file} ||= {};
      if (al.s) {
          sayre "replacing tailo $file";
          al.s->close;
      }
      open my $ha, '-|','tail','-s','0.1','-F','-n0', $file or die $!;
      my $s = al.s = Mojo::IOLoop::Stream->new($ha);
      al.h = $ha;
      al.x = $x;
      al.file = $file;
      
      $s->on(read => sub {
          my ($s,$b) = @_;
          $H->fixutf8($b);
          say "Read; ".slim 30, $b;
          y.l_lines->(al.x, $b, al.file);
      });
      $s->on(close => sub {
          my $s = shift;
          die "al.file closed!?";
      });
      $s->on(error => sub {
          my ($s, $err) = @_;
          die "al.file err: $err";
      });
      $s->timeout(0);
      $s->start;
      $s->reactor->start unless $s->reactor->is_running;
    };

    if (ar.lma) {
        my ($l,@ma) = @{ar.lma};
        return $y->{$l}->(@ma);
    }
    $y

