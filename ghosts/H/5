hooks:
  aj: |
    my $W = j.W; # wonky picture frame
    
    my $meta = {};
    meta.hol = "H.style/H.name/H.id";
    meta.Wid = W.at.id;
    
    if (j._) {
        meta.unified = 1;
        # W homing
        meta.styles = W.at.styles;
        meta.hitime = $H->hitime;
        
        H.r->set("W/meta.Wid" => $H->ejson($meta));
        
        
        H.r->set("V/H.id/meta.Wid" => 1);
        G0.Wh->{meta.Wid} = $W; # TODO move Wh to A.h_W auto index
    }
    
    my @lot = reverse @{j.s}; # until whole
    push @lot, reverse @{j.c}; # from whole
    
    return sayre "H: empty J aj" unless @lot;
    
    my $m = join" ", @lot;
    $m = " $m"; # two spaces, tells js to eval
    H.G w send_Elvis[$m, $meta];
  spurtJcon: | # spurt J stuff + meta through link tinto moving zipper
    say "HIHI ".slim 30,$m;
    
    my $dir = $G->taily->{rr}->('J');
    my $f = $dir.'/'.meta.Jid.'.c';
    die "al$f" if -e $f;
    
    fspu($f, $m);
    # J should have an .i for meta + a skinny for v zipper
    
    my $s = ejson $meta;
    $s .= "\n";
    my $scf = $G->taily->{rw}->('J');
    fscc($scf, $s);
    
    # right right
    warn "on met! $1" if $s =~ /(.{,20}\n.{,20})/;
    warn "con n ving! $1" if $m =~ /(.{,20}\n.{,20})/;
        
    
  Jexit: | #c setup the J suction of O (life/J.sc) (moving zipper)
    my $l = sub {
        my $m = shift;
        w JElvis[$m];
    };
    $G->taily->{ily}->('J', $l);
  JElvis: | #c $m from the scrambling stream
    my $meta = djson $m;
    
    my $dir = $G->taily->{rr}->('J');
    my $file = $dir.'/'.meta.Jid.'.c';
    my $m = read_file($file);
    
    my $del = sprintf '%.4f', scalar(hitime) - meta.hitime;
    saybl "meta.hol -> meta.Jid  (lag $del)    ". -s $file;
    
      # thing may contain more J structure we don't know about but it's art
      # it may throw Emissive Js through from Building Js
      # possibly without traces of U the W fab in the middle
      # which is where we can wire travel through langths of Js
      # without the bridge building ie doming needed to find the path
      my $cb;
      if (meta.unified) {
          saygr "unifid styles: meta.styles";
          
          # is test # could be more meta over there
          my $hmm = H.r->get("W/meta.Wid") || die "no such meta.Wid";
          
          if (meta.styles =~ /\bNZ\b/) {
              
              $cb = sub {
                w mux(as=>"unified meta.Wid ( meta.hol");
              };
          }
      }
      $m = " $m"; 
      w to_Elvis[$m, $meta, $cb];
      

