C:
  - K: Elvis
    max_tooth_Hz: 12
    Gw: 1
hooks:
  mess: |
    # TODO sa* all over
    # by voltage!
    $H->pub("S/H.style/H.name/sa", "$what: @$thing");
  aj: |
    my $uW = j.G.uW;
    my $ww = uW.at.id;
    my $to = $ww;
    if (j._) {
        $to .= "/_";
        # ww homing
        my $hol = "H.style/H.name/H.id";
        my $etc = 1 if uW.at.styles =~ /\bNZ\b/;
        my $hold = join ' ', $hol, $etc, $H->hitime;
        H.r->set("W/$ww" => $hold);
        H.r->set("V/H.id/$ww" => 1);
        
        H.G.A.W->{j._.at.id} = j.G.W;
    }
    
    my @lot = reverse @{j.s}; # until whole
    push @lot, reverse @{j.c}; # from whole
    
    return sayre "empty J aj" unless @lot; 
    
    @lot = join " ", @lot;
    for my $m (@lot) {
        ref $m && die;
        $m = " $m"; # two spaces, tells js to eval
        H.G w send_Elvis[$m, $to]; 
    }
  pubbedElvis: | # message for elvis via redis
      sayre "su a.top ".slim(30,30,a.m);
      my $cb;
      
      my ($meta, $Jid) = split ' ', a.m, 2;
      my ($st, $na, $ww, $uni) = split '/', $meta;
      my $m = H.r->get("J/$Jid") || die "a.m .... $Jid";
      H.r->del("J/$Jid");
      if ($uni) {
          # meta
          sayyl "unifid $st $na $ww !";
          
          my $hold = H.r->get("W/$ww") || die "no such $ww";
          say "was from $hold";
          my ($hol, $etc) = split /\s+/, $hold, 2;
          if ($etc) {
              sayyl "Retiling";
              $cb = sub { w retile; };
          }
      }
      $m = " $m";
      H.G w send_Elvis[$m, $cb];
      sayyl "pubbed elvis ".$G->F_delta."   '".slim(30,30,$m);
  jaw: |
    my $s = $H->mkuuid();
    ($s) = reverse split '-', $s;
    G.jaws->{$s} = delete ar.cb; # TODO a Z awaits, sucks $m
    ar.m = 
        " var e = function(){ $js };"   
        ."var m = e();"
        ."s\.reply({jaw:{h:'H.ol',s:'$s',e:m}});";
    my $pi = ar.E->pi if ar.E;
    sayyl "jaw $s $pi  ".slim(30,30,$js);
    sayyl ki $ar;
    w send_Elvis;
  Teeth: |
    saybl " > ".slim(75,80,$m);
    my $j = $H->djson($m);
    
    if (ref $j eq "HASH") {
        if (keys %$j != 1) {
            die "hash wide/skinny ".wdump($j);
        }
        my ($uno) = keys %$j;
        saygr "cuno $uno";
        my $a = {
            j => $j,
            m => $m,
            $uno => $j->{$uno},
        };
        a.E = ar.E if ar.E;
        w S/$uno(%$a);
        # hit or not? see post 6 with r
        return;
    }
    
    die "weird shit: '$m'" if ref $j;
    
    if ($j =~ /^([\w\/]+) (.+)$/) {
        my $a = {m => $2};
        a.E = ar.E if ar.E;
        w S/$1(%$a);
    }
    else {
        die "wei tet '$j'";
    }
  reS: |
    my ($way, $am) = split /\s+/, $m, 2;
    sayyl "$top >> $m" if $way ne 'hostinfo/ack';
    $way || die "wtf $m";
    w S/$way(%$ar,m=>$am);
  S:
    jaw: | #c TODO route with H.id
      $j = j.jaw;
      my $s = j.s || die "no s";
      my $hol = j.h || die;
      if (H.ol eq $hol) {
          my $cb = G.jaws->{$s} || die "no such jaw $s";
          saygr "Jaw doing $s ... ";
          $cb->(j.e); # TODO Z sucktion
      }
      else {
          $H->pub("S/$hol", "speaks $m");
      }
    speaks: | # concealed elvis input
      w Teeth[$m];
      
    er: |
      die "much JS error..." if H.JErrors++ > 3;
      $H->error("javascript error from client", j.m, j.e);
    event: |
      my $e = ar.e = j.event;
      
      return w S/key if e.type =~ /^key/;
      
      return w S/W if e.W;
      
      return w S/TV if e.id;
      
      $H->error("Strange event", $e);
      
    key: |
      # if key is ww switcher...
      if (H.name eq "O") {
            G.keysto || die "no key subber";
          $H->pub("S/G.keysto" => "speaks $m");
      }
      else {
          return H.keydo->($e) if H.keydo;
      }
      
    TV: |
      w duu/TV;
  
    On: |
      die "!";
      $m =~ s/^H.style\/H.name // && w reS[$m];
    W: | #c
        $e->{$_} =~ /^\w+$/ || delete $e->{$_} for qw'id ux W';
        
        my $a = {};
        if (a.W = H.G.A.W->{e.W}) {
            a.L = a.W->findL(e.id);
            a.uxL = a.W->findL(e.ux);
            a.e = $e;

            a.W.G w event(%$a);
        }
        else {
            my $hold = H.r->get("W/e.W") || die "no such e.W";
            my ($hol, $etc) = split /\s+/, $hold, 2;
            $H->pub("S/$hol", "speaks $m");
            G.keysto = $hol;
        }
    
    reextet: | #c
      
      $G->timer(1, sub{
          $H->pub("S/$_", "reexec") for split ',', $m;
          w reexec;
      });

