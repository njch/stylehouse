hooks:
  Rayway: |
    my $GG = $S;
    return unless ref $wa eq "ARRAY";
    saybl "Raywaying: ".$GG->pi;
    my $i = 0;
    for my $a (@$wa) {
        if (ref $a eq "C") {
            # travel inject
            warn "already";
        }
        else {
            my $Rw = $wa->[$i] = $GG->nw(%$a);
            
            0->deaccum(G.A, 'n_RDw', $_) for grep {_.i.K eq Rw.K} @{G.A.n_RDw};
            Rw.A->umv('', 'RDw'); # ART
            # we create lots of these ^
            # and tract G <RDw R w <R w R.way (or Cs, otherways) is the here & now 
            # is a A sucking J
            w _in_Rw[$Rw, $GG];
        }
        $i++;
    }
  ReinitRs: |
    my $GG = $S;
    my @R = map{_.i}@{GG.A.n_R||[]};
    push @R, map{_.i}@{GG.A.n_Rnons||[]} if $G eq $GG; # from G0
    saybl "even G " if $G eq $GG;
    @R = uniq @R;
    my $don = {};
    my $recoded = 1;
    for my $R (@R) {
        if ($don->{R.id}) {
            sayre "already ".$don->{R.id}->pi;
            next;
        }
        $don->{R.id} = $R;
        w _init_R[$R, $recoded]; 
    }
  _init_R: |
    my $GG = R.G;
    my $Rw;
    R.A->umk($G,'Rnons') if R.name eq 'non'; # like Gs
    
    saybl "_init_R waying ".$GG->pi."    ".$R->pi;
    
    $Rw = $GG->CsK({s=>'Ray',K=>R.name});
    $Rw ||= $G->CsK({s=>'Ray',K=>R.name});
    
    $Rw || die "no R w for R.name ".wdump($R);
    
    my $a = Rw.a;
    # have setting somewhere for whatever
    # fan out all style poss behind the source name
    # then wild R cranking + speshness distill their source from this pool
    w RZ_Ds_traction[$a, $R];
    warn "nothing in Rway ".$R->pi."\n on".wdump(2,[$a,$R]) if !keys %{a.Dh};
    
    if (!R.way) {
        R.way = R.A->spawn('C');
        R.way.R = $R;
        R.way.A->umv('', 'way');
        R.way.A->umk($Rw, 'Rw');
        R.way.name = "Rw!R.name"; 
    }
    R.way->from({hooks=>a.Dh});
    
    my $wayin = (ar.recoded ? "recoded" : "fresh")."_init";
    w $R $wayin;
    w $R any_init;
    
    
  RZ_Ds_traction: |
    # pool the style of code together for this R crazy
    # look at each $r in the source style way dimension
    
    # 7
    my $Dz = a.Dz;
    my @r = $G->stylekeysort(a.bb);
    for my $r (@r) {
        my $b = a.bb->{$r};
        my ($l, $com, $vo) = $r =~ /^(\S+?)(\#\S+)?\s(.+)$/;
        
        if ($com) {
            # should just attach them near the style
            # with one more phase of comment joining
            # also non-replace mode, maybe something of z D namespace
            exists $Dz->{$l}->{$vo} || die " the $l $vo is already , not $r";
            my $v = $Dz->{$l}->{$vo};
            $com = "# $vo $com".($b ? " $b" : "");
            $v = "$com\n$v";
            $Dz->{$l}->{$vo} = $v;
        }
        else {
            
            $Dz->{$l}->{$vo} = $b;
        }
    }
    
    
    # 8
    my $Dh = a.Dh;
    while (my ($l, $bz) = each %$Dz) {
        my $ac = join'',map{"{$_"}split'/',$l;
        
        my @s = map {$bz->{$_}} sort keys %$bz;
        
        my $b = ref $s[0] eq 'ARRAY' ? $s[0] # could join somehow, flatline 1
        :
        join("\n", @s);
        
        $R->loadup($Dh, $ac, $b);
    }
    
    
  _in_Rw: |
    saybl "_in_Rw Recipe ".$Rw->pi;
    Rw.a = {};
    Rw.a.Ds = [];
    Rw.a.Dh = {};
    Rw.a.Dz = {};
    
    my $source = Rw.findway;
    # form of from wayt ^ moves v
    my $Ds = Rw.a.Ds;
    # ghotov
    my @gs = $GG;
    push @gs, $G if $GG ne $G && Rw.K eq 'non';
    
    for my $g (@gs) {
        for my $Rsur (flatline $g->anyway("${source}s")) { # shubby
            push @$Ds, map { { K=>$_, D=>$Rsur->{$_} } } keys %$Rsur;
        }
        push @$Ds, flatline $g->anyway("${source}z");
    }
    
    # per R (traction) this kinda thing layer
    # TODO when this is natively Jish all the way along...
    my @Ks;
    @$Ds = grep {
        my $sp = _.spesh;
        if (!$sp && exists _.spesh_D) {
            $sp = $G->D({bab=>_.spesh_D});
        }
        push @Ks, _.K if !$sp;
        !$sp
    } @$Ds;
    #sayyl " -- in Rw: ".$Rw->pi.": ". join '  ', sort @Ks;
    
    
    w RZ_Ds_humm[$Rw];
    
    
  RZ_Ds_humm: |
    my $a = Rw.a;
    a.bb = {};
    my $Ds = a.Ds;
    
        @$Ds = map { 
            my $D = $_;
            !ref D.D ? $D : do {
                my $_K = D.K;
                ref D.D eq 'HASH' ?
                ( map { { K=>"$_K/$_", D=>D.D->{$_} } } keys %{D.D} )
                : do {
                    D.C = delete D.D;
                    $D
                };
            }
        } map { 
            my $D = $_;
            !D.n_D ? $D : do {
                my $_K = D.K;
                $D, map { { K=>"$_K/$_", D=>D.n_D->{$_} } } keys %{D.n_D}
            }
        } @$Ds;
        
        my $byK;
        $byK->{_.K}++ for @$Ds;
        my @toomuch = grep {$byK->{$_} > 1} keys %$byK;
        die "durplicato Ks: @toomuch" if @toomuch;
        
        for my $D (grep {_.D} @$Ds) {
            my $b = {};
            $G->D_to_style($D, $b);
            for my $k (keys %$b) {
                my $s = $b->{$k};
                my ($t, $v) = split /\t/, $k;
                my $com = "$t#D.K\t$v";
                a.bb->{$com} = undef;
                #sayyl "$k      $com";
                a.bb->{$k} = $s;
            }
        }
        #    die wdump a.bb;
 
        # IVORY puur=@$Ds
        for my $D (grep {_.key} @$Ds) {
            a.Dh.key->{$_} = "D.K/D.key->{$_}"
                for keys %{D.key};
        }
        for my $D (grep {_.C} @$Ds) {
            a.bb->{"D.K 4"} = D.C;
        }


        for my $D (grep {_.babz || grep { /^babz .+/ } keys %$_ } @$Ds) {
          for my $ba (keys %{D.babz}) {
              my $b = D.babz->{$ba};
              my ($t, $v) = $ba =~ /^(.+)\s(.+)$/;
              my $l = $t;
              my $comcom = $1 if $l =~ s/(\#\S+)$//;
              my $com = "#D.K$comcom";
              my $comba = "$l$com\t$v";
              $l = "$l\t$v";
              #sayyl "Re $l  =-==== $com";
              a.bb->{$comba} = undef;
              if (ref $b) {
                  #b.from # style grab, additive
              }
              else {
                  a.bb->{$l} = $b;
              } 
          }
        }

