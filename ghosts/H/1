hooks:
  node:
    O: #c
      - GAK: S/O
    o: #c
      - GAK: S/o
    C: #c
      - GAK: C
    Cou: #c ?
      - GAK: sul C/ool
        P:
            - K: Ims
              flo: 4
              B:
                dir: /s/public/i
            - GAK: U
              InC:
                   W:
                     styles: OxO z NZ
                     Z:
                       z-index: 5
                       overflow: hidden
                       background: url(i/jellyfish-6.jpg)
    D: #c
      - GAK: C
    
      - GAK: sul C/ool
        P:
            - K: Ims
              flo: 4
              B:
                dir: /s/public/i
            - GAK: U
              InC:
                   W:
                     styles: OxO z NZ
                     Z:
                       z-index: 5
                       overflow: hidden
                       background: url(i/future-games-fractal.jpg)
    S2: #c
      - GAK: sul C/ool
        P:
            - K: Ims
              flo: 4
              B:
                dir: /s/public/i
            - GAK: U
              InC:
                   W:
                     styles: OxO z NZ
                     Z:
                       z-index: 5
                       overflow: hidden
                       background: url(i/aloe-vera-1045_640.jpg)
    S: #c
       - GAK: bacg C/ool
         P:
          - K: Ims
            flo: 2
            B:
              dir: /s/public/i
          - GAK: U
            InC:
                 W:
                   Z:
                     z-index: -1
                     background: url(i/greencush.jpg)
    s: #c
       - GAK: sl C/ool
         P:
          - K: Ims
            flo: 2
            B:
              dir: /s/public/i
          - GAK: U
            InC:
                 W:
                   styles: OxO z NZ
                   Z:
                     z-index: -1
                     background: url(i/greencush.jpg)
    Z: #c
      - GAK: 0
      - D: | #c gitdission
          $G->recur(0.4, sub {
              w gitdission;  
          });
  in: |
    if (H.name ne 'o') {
        w hostinfo;
    }
    $G->recur(9 => sub {
        w hostinfo;
    });
  hostinfo: |
    my @ps = `ps -p$$ fu`;
    my ($u, $pid, $mem, $cpu) = (split /\s+/, $ps[1])[0,1,2,3];
    $_ = $_ / 100 for $cpu, $mem;
    my $now = $H->hitime;
    
    my $hol = H.ol ||= "H.style/H.name/H.id";
    my $info = "$cpu $mem $now";
    
    saygr "hostinfo: $info " if rand(1) > 0.7;
    H.r->set("H/$hol", $info);
    
    $H->pub("Hostinfo" => "$hol $info", 'ig');
    
    $H->pub("Hi" => $hol) if !H.lastinfo || ar.withHi;
    H.lastinfo = $now;
    
    G.hostinfo_waits++;
    if (G.hostinfo_waits > 1) {
        sayre "hostinfo uncollected";
    }

  figure_port: |
    my $listen = readlink('listen');
    my ($host,$port, $wa) = split ':', $listen;
    die "too much listen" if $wa;
    ($port, $host) = (2000, undef) if !$port && $host =~ /^\d+$/;
    $port ||= 2000;
    $host ||= '127.0.0.1';

    $port += ord(H.name) + 8000;
    
    H.listen_http = "http://$host:$port";   
    H.listen_ws = "ws://$host:$port/s";
    
  subsc: |
    my $tos = H.subscr->{$top} ||= [];
    push @$tos, $cb;
    
    H.db->listen($top);
    
    sayyl "Subbed to $top";
  enRedis: |
    my $r = Redis->new(
        server => 'localhost:8888',
        reconnect => 1,
        every => 10000,
    );
    r.gest = sub {
        my ($k, $make) = @_;
        my $c = H.r->get($k);
        return ref \$c eq "SCALAR" ? $H->fixutf8($c) : $c if $c;
        $c = $make->();
        H.r->set($k => $c);
        return $c;
    };
    $r
  reexec: |
        for my $E (@{H.who||[]}) {
            w $E disconecktie;
        }
        sayre "finish!";
        exec "nice perl $0 @ARGV";
     
  S:
    hostinfo: #c
      ack: | #c
        my (@s) = split /\s+/, $m;
        if (rand(1) > 0) {
            my $lag = (1000*sprintf('%.3f',$H->hitime - $s[-1])).'ms';
            sayyl "out there! lag: $lag";
        }
        G.hostinfo_waits = 0;

