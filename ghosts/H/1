name: G1

hooks:

  _load_ways_post: | # G/0 manages some other G's way startup ripples
    G.recoded_cbs||=[]; #1
    
    $S->w("load_ways_post");
    
    $G->Flab("$S->{name} +$S->{load_ways_count}+   ".
        join" , ", map { $_->{_wayfile} } @$w);
    
    $_ && $S->wayray($_) for $S->anyway('C');
    
    if (S.load_ways_count == 1) {
        w _init/fresh;
    }
    else {
        w _init/recoded;
    }
      
    $S->w("any_init");
    
  _init:
    recoded: |
        
        w _init/recoded_Cways[$S] if $S->anyway('recoded_Cways');
        
        $S->w("recoded_init");
        
        w _init/recoded_care_parents[$S];
        
    recoded_Cways: | # TODO reinject
      for my $i (map {_.i} $S->scGre()) {
          my $up = $S->CsK({K=>i.K});
          $i->from($up);
      }
        
    fresh: |
      w _init/keys[$S];
      
      w _init/GG[$S];
      
      S.R ||= $S->R; # or R: perc somewhere here
      
      $S->w("fresh_init");

    keys: | # TODO goner
      return unless $S->findway("keys");
      if (my $keys = G:keys) {
          push @{keys.subs}, $S unless
            grep {$_ eq $S} @{keys.subs};
      }
      else {
          sayre "G L Waiting for G keys";
          $G->timer(0.5 => sub { w keyub[$S]; });
      } 
  _gitdission: |
    my $ghosts = H.h ? H.G.GGs : $H->data->{Ghost};
    my @rG;
    for my $S (@$ghosts) {
        my $in = [grep{$Gd->{$_}} @{S.wayfiles}];
        next unless @$in;
        push @rG, $S;
        # sort stream to avoid small before big?
        waylay recode_ways[$S, $in];
    }
    for my $cb (@{G.recoded_cbs}) {
        $G->timer(0.1, sub { $cb->($Gd) });
    }
    say " Recoding: ".join"\t\t", map { $_->pi } @rG;
  recode_ways: |
    sayyl "recoding S.id S.name";
    eval {
        $S->load_ways(split /\+/, S.way); # TODO all ways on any recoded or..?
    };
    if ($@) {
        Err "Load ways fuckup: $@";
        return $@ = "";
    }
    say "S.name !  ! ! ! S.id recoded  S.way, intersects git diffage at:";
    say " - $_" for @$in; 
        
        

  zl: |
    say "Wanting to reload $name" for 1..5;

name: Ϡ
etc: intoraction... magnetic fishing rod, guy playing guitar cave art



hooks:
  Arr: |
    my ($what) = keys %$ar;
    my $u = 0->TafuB($what => $ar);
    G.GG.Be->w(ion => {u=>$u});
  fresh_init: |
    G.Es = []; # elvi beam
    
    G.am = $G->findway("node/H.name")
        || die "what am? H.name";

    waylay percs;
    
    my $yle = H.style;
    $yle =~ s/^style/s҉/;
    G.name = "Ϡ $yle H.name";
    
    $G->timer(1,sub{ w push_conin if !H.singul }); # TODO bull
  recoded_init: |
    w retile;
    w reperc;
  percs: |
    my $P = ar.P || G.am;
    my $GG = ar.GG || $G; # starting from magnetic fishing rod
    #saygr "to perc ".$GG->pi."   ".wdump($P);
    # TODO T diff new ways to get InC etc changes
    @$P = sort { !defined _.GAK } @$P;
    for my $p (@$P) {
        if (defined p.D && !defined p.K) {
        
            $GG->D({bab => p.D});
            
        } elsif (defined p.GAK) {
        
            w perc_z/GAK[$p, $GG];
            sayyl "back from ".$GG->pi;
            
        }
        else {
        
            w perc_z/carb[$p, $GG];
            
        }
    }
    $GG w percolate unless $GG eq $G;
  perc_z:
    GAK: | #c
            my ($k, @w) = split ' ', p.GAK;
            my $w = join ' ', @w;
            $w ||= $k;
            
            if (!GG.GG->{$k}) {
                $GG->GAK($k, GG.A->spawn(G=>$w));
                sayyl "Put ".GG.GG->{$k}->pi." down";
            }
            
            my $oGG = $GG;
            my $GG = GG.GG->{$k} || die;
            my $P = [];
            push @$P, $_ for @{ p.P || [] };
            my @onG = @{ $GG->anyway('P') || [] };
            sayre @onG." on oGG.name perc GG.name ! perc";
            push @$P, $_ for @onG;
            
            if (my $d = p.InC) {
                $GG->InjC($GG => {C => $d});
            }
            
            w percs[$GG, $P];
            sayyl "back from ".$GG->pi;
    carb: | #c
        # translate compression
        if (keys %$p == 1 && (keys %$p)[0] =~ /^(\w+) (.+)$/) {
            my $c = $GG->CsK({K=>$1});
            die "no BcS for $1" unless c.BcS;
            my @parc = ($2, values %$p);
            $p = {};
            p.K = $1;
            p.B->{$_} = shift @parc for split ' ', c.BcS;
        }
            
        if (p.K) { # perc u
            my $u = $GG->sway({K=>p.K}, $p);
            saybl "Making ".$u->pi;
            $u = $GG->Tafu($u);
        }
        else {
            die " wtf=>".ki($p)
        }
  reperc: |
    # coded way diff/inject/retravel above percolations
  ux: | # TODO re-spawning... fork/pause/resume
    my @GGs = ar.GG || grep { _.K !~ /L|ux/ } @{G.GGs};
    Say "ux! ".gpty(@GGs);
    for my $GG (@GGs) { 
        sayre "RWRWRWRW GG.K\t GG.name";
        
        my $U = GG.GG.U;
        delete H.G.A.W->{U.uW.at.id};
        for my $E (@{G.Es}) {
            H.G w z/conz[$E];
        }
        
        0->RW($U);
        
        0->RW($GG);
        
        w percs[$GG];
    }
    w wux;
    saybl "ux ".$G->F_delta();
  scribe_js: |
    my $new = G.js || [];
    return unless @$new;
    G.js = [];
    
    my $now = $H->hitime();
    G.jslast ||= $now;
    my $d = sprintf("%.3f",$now - G.jslast);
    G.jslast = $now;
    
    my $script = join"","[$d,function(){", @$new, "}],\n";
    write_file("o/o", {append=>1}, H::encode_utf8($script));
  wux: |
    for my $GG (@{G.GGs}) { # could ar into GG=$K orso
        $GG->w('uxd');
    }
    

