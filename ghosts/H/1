
hooks:

  _load_ways_post: | # G/0 manages some other G's way startup ripples
    G.recoded_cbs||=[]; #1
    
    $S->w("load_ways_post");
    
    for my $wa ($S->anyway('C')) {
        w wayray[$wa];
    }
    
    for my $wa ($S->anyway('R')) {
        w Rwayray[$S,$wa];
    }
    
    if (S.load_ways_count == 1) {
        w _init_fresh;
    }
    else {
        w _init_recoded;
    }
      
    $S->w("any_init");
    
  _init_recoded: |
    w _init_recoded_Cways[$S] if $S->anyway('recoded_Cways');
    $S->w("recoded_init");
        
  _init_recoded_Cways: | # TODO reinject
      for my $i (map {_.i} $S->scGre()) {
          saygr "Reinjecting i.K ...";
          my $up = $S->CsK({K=>i.K});
          $i->from($up);
      }
        
  _init_fresh: |
      S.R ||= $S->R; # or R: perc somewhere here
      
      $S->w("fresh_init");
  ghostchanges: |
    my $ghosts = H.G.GGs;
    my @rG;
    for my $S (@$ghosts) {
        my $in = [grep{$Gd->{$_}} @{S.wayfiles}];
        next unless @$in;
        push @rG, $S;
        # sort stream to avoid small before big?
        waylay recode_ways[$S, $in];
    }
    for my $cb (@{G.recoded_cbs}) {
        $G->timer(0.1, sub { $cb->($Gd) });
    }
  recode_ways: |
    sayyl "recoding S.id S.name";
    eval {
        $S->load_ways(split /\+/, S.way); # TODO all ways on any recoded or..?
    };
    if ($@) {
        Err "Load ways fuckup: $@";
        return $@ = "";
    }
    say "S.name !  ! ! ! S.id recoded  S.way, intersects git diffage at:";
    say " - $_" for @$in; 
        
        

  wayray: | # raise Cs from the dead. pass array of them from the to-be-live C data
    # should use GG after U styleup refact
    # so GG->nw ...
    return unless ref $wa eq "ARRAY";
    my $i = 0;
    for my $a (@$wa) {
        if (ref $a eq "C") {
            # travel inject
            die "already";
        }
        else {
            my $c = $wa->[$i] = $G->nw(%$a);
            c.A->umv('', 'Cw');
        }
        $i++;
    }
  Rwayray: |
    my $GG = $S;
    return unless ref $wa eq "ARRAY";
    my $i = 0;
    for my $a (@$wa) {
        if (ref $a eq "C") {
            # travel inject
            die "already";
        }
        else {
            my $Rw = $wa->[$i] = $GG->nw(%$a);
            Rw.A->umv('', 'R_w');
            # we create lots of these ^ 
            # but only the one in wa (anyway 'C') is the now
            w _in_Rw[$Rw, $GG];
        }
        $i++;
    }
    for my $Rw (map{_.i}@{GG.A.n_Rw||[]}) {
        my $R = Rw.A.u.i;
        w _init_R[$R];
    }
  _init_R: |
    my $GG = R.G;
    my $Rw = $GG->CsK({s=>'R',K=>R.name});
    return warn "no Rw for R.name" if !$Rw;
    
    my $a = Rw.rwa;
     # have setting somewhere for whatever
    # fan out all style poss behind the source name
    # then wild R cranking + speshness distill their source from this pool
    w RZ_Ds_traction[$a, $R];
    
    R.way ||= R.A->spawn('C');
    R.way.name = "Rw!R.name";
    R.way->from({hooks=>a.Dh});
    
    R.way.A->umk(R.G, 'Rw');
    
    sayyl "wayrays ".$G->F_delta;
    
  _in_Rw: |
    my $source = Rw.findway;
    my $a = {};
    Rw.rwa = $a;
    
    my $Ds=[];
    for my $Rsur ($GG->findway("${source}s")) {
        # passing phase, should beam in
        push @$Ds, map { { K=>$_, D=>$Rsur->{$_} } } keys %$Rsur;
    }
    push @$Ds, flatline $GG->findway("${source}z");
    @$Ds = grep { !_.spesh } @$Ds;
    
    a.Ds = $Ds;
    a.Dh = {};
    a.Dz = {};
    
    w RZ_Ds_humm[$a];
    
    
  RZ_Ds_humm: |
    a.bb = {};
    my $Ds = a.Ds;
    
        @$Ds = map { 
            my $D = $_;
            !ref D.D ? $D : do {
                my $_K = D.K;
                map { { K=>"$_K/$_", D=>D.D->{$_} } } keys %{D.D}
            }
        } @$Ds;
        
        die "durp" if @$Ds != uniq map {_.K} @$Ds;
        
        for my $D (grep {_.D} @$Ds) {
            my $i = 0.001;
            my @cs;
            my $up = sub {
                a.bb->{"D.K $i"} = join "\n", @cs if @cs;
                @cs = ();
            };
            for my $l (split "\n", D.D) {
                if ($l =~ /^\s*# (\d\S*)/) {
                    my $ni = $1;
                    $up->();
                    $i = $ni;
                }
                push @cs, $l;
            }
            $up->();
        }

        for my $D (grep {_.n_D} @$Ds) {
            # TODO want to be R centric, make style for these.....
            a.Dh->{key}->{$_} = "D.K/D.key->{$_}" for keys %{D.key||{}};
            a.Dh->{D.K} = D.n_D;
        }


        for my $D (grep {_.babz} @$Ds) {
          for my $ba (keys %{D.babz}) {
              my $b = D.babz->{$ba};
              my $l = $ba;
              if ($l =~ s/(\#\S+)//) {
                  a.bb->{$ba} = undef;
              }
              if (ref $b) {
                  #b.from # style grab, additive
              }
              else {
                  a.bb->{$l} = $b;
              } 
          }
        }
  RZ_Ds_traction: |
    # pool the style of code together for this R crazy
    # look at each $r in the source style way dimension
    
    # 7
    my $Dz = a.Dz;
    my @r = R.G w stylekeysort(d=>a.bb);
    for my $r (@r) {
        my $b = a.bb->{$r};
        my ($l, $com, $vo) = $r =~ /^(\S+?)(\#\S+)? (.+)$/;
        if ($com) {
            # should just attach them near the style
            # with one more phase of comment joining
            # also non-replace mode, maybe something of z D namespace
            exists $Dz->{$l}->{$vo} || die;
            my $v = $Dz->{$l}->{$vo};
            $com = "# $vo $com".($b ? " $b" : "");
            $v = "$com\n$v";
            $Dz->{$l}->{$vo} = $v;
        }
        else {
            $Dz->{$l}->{$vo} = $b;
        }
    }
    
    # 8
    my $Dh = a.Dh;
    while (my ($l, $bz) = each %$Dz) {
        my $ac = join'',map{"{$_"}split'/',$l;
        
        my $babble = join "\n", map {$bz->{$_}} sort keys %$bz;
        
        $R->loadup($Dh, $ac, $babble);
    }
  gitdission: | # look for ghostchanges
    my $some = 0;
    for my $f ($G->fs_find('/home/s/styleshed/ghosts')) {
        next if $f =~ /\/\./;
        my $mt = (stat $f)[9];
        $some = 1 if
        G.gitdissmt->{$f} ne $mt;
        G.gitdissmt->{$f} = $mt;
    }
    return unless $some;
    my @diff = `git diff`; 
    my $f;
    my $d = {};
    for (@diff) {
        if (/^diff --git "?a\/(.+?)"? "?b\/.+"?/) {
            $f = $1;
            next if -d $f; # git submodeul
            $f =~ s/^ghosts\/\\317\\240/ghosts\/Ï /sg;
            die "how to git diff unicode? $f" if $f =~ /\\\d+/;
        }
        else {
            $d->{$f} .= $_
        }
    }
    
    while (my ($f, $D) = each %$d) {
        $d->{$f} = {
            f => $f,
            D => $D,
            dig => $H->dig($D),
        };
    }
    
    return G.last_git_diff = $d if !G.last_git_diff;
    
    my $od = {%{G.last_git_diff}};
    
    my $Gd;
    while (my ($f, $n) = each %$d) { 
        my $o = delete $od->{$f};
        
        my $change = !$o || n.D ne o.D;
        
        next unless $change;
        
        if ($f =~ /^ghosts/) {
            n.o = $o;
            $Gd->{$f} = $n;
        }
        elsif ($f =~ /^l\//) { 
            # compilato del shed iggy
        }
        else {
            say join("  <>  ", ($f)x38);
            w reexec;
        }
    }
    
    # to undiffering, was commit? whatever
    for my $f (keys %$od) {
        next;
    }
    
    G.last_git_diff = $d;
    
    if (keys %$Gd) { 
        my $m = join", ", keys %$Gd;
        say "Ghost changes $m";
        $H->pub(S => "ghostchanges $m");
    }
  S:
    ghostchanges: |
      my $Gd = {map { $_ => 1 } split ', ', $m};
      $G0 w ghostchanges[$Gd];
      
    zl: |
      say "yeah well $m";
      
  zl: |
    say "Wanting to reload $name" for 1..5;
    

