
hooks:

  _load_ways_post: | # G/0 manages some other G's way startup ripples
    G.recoded_cbs||=[]; #1
    
    $S->w("load_ways_post");
    
    for my $wa ($S->anyway('C')) {
        w wayray[$wa];
    }
    
    if (S.load_ways_count == 1) {
        w _init_fresh;
    }
    else {
        w _init_recoded;
    }
      
    $S->w("any_init");
    
  wayray: | # raise Cs from the dead. pass array of them from the to-be-live C data
    return unless ref $wa eq "ARRAY";
    my $i = 0;
    for my $a (@$wa) {
        if (ref $a eq "C") {
            # travel inject
            die "already";
        }
        else {
            my $c = $wa->[$i] = $G->nw(%$a);
            c.A->umv('', 'wayray');
        }
        $i++;
    }
  _init_recoded: |
        
        w _init_recoded_Cways[$S] if $S->anyway('recoded_Cways');
        
        $S->w("recoded_init");
        
  _init_recoded_Cways: | # TODO reinject
      for my $i (map {_.i} $S->scGre()) {
          saygr "Reinjecting i.K ...";
          my $up = $S->CsK({K=>i.K});
          $i->from($up);
      }
        
  _init_fresh: |
      S.R ||= $S->R; # or R: perc somewhere here
      
      $S->w("fresh_init");
  ghostchanges: |
    my $ghosts = H.G.GGs;
    my @rG;
    for my $S (@$ghosts) {
        my $in = [grep{$Gd->{$_}} @{S.wayfiles}];
        next unless @$in;
        push @rG, $S;
        # sort stream to avoid small before big?
        waylay recode_ways[$S, $in];
    }
    for my $cb (@{G.recoded_cbs}) {
        $G->timer(0.1, sub { $cb->($Gd) });
    }
  recode_ways: |
    sayyl "recoding S.id S.name";
    eval {
        $S->load_ways(split /\+/, S.way); # TODO all ways on any recoded or..?
    };
    if ($@) {
        Err "Load ways fuckup: $@";
        return $@ = "";
    }
    say "S.name !  ! ! ! S.id recoded  S.way, intersects git diffage at:";
    say " - $_" for @$in; 
        
        
  gitdission: | # look for ghostchanges
    my $some = 0;
    for my $f ($G->fs_find('/home/s/styleshed/ghosts')) {
        next if $f =~ /\/\./;
        my $mt = (stat $f)[9];
        $some = 1 if
        G.gitdissmt->{$f} ne $mt;
        G.gitdissmt->{$f} = $mt;
    }
    return unless $some;
    my @diff = `git diff`; 
    my $f;
    my $d = {};
    for (@diff) {
        if (/^diff --git "?a\/(.+?)"? "?b\/.+"?/) {
            $f = $1;
            next if -d $f; # git submodeul
            $f =~ s/^ghosts\/\\317\\240/ghosts\/Ï /sg;
            die "how to git diff unicode? $f" if $f =~ /\\\d+/;
        }
        else {
            $d->{$f} .= $_
        }
    }
    
    while (my ($f, $D) = each %$d) {
        $d->{$f} = {
            f => $f,
            D => $D,
            dig => $H->dig($D),
        };
    }
    
    return G.last_git_diff = $d if !G.last_git_diff;
    
    my $od = {%{G.last_git_diff}};
    
    my $Gd;
    while (my ($f, $n) = each %$d) { 
        my $o = delete $od->{$f};
        
        my $change = !$o || n.D ne o.D;
        
        next unless $change;
        
        if ($f =~ /^ghosts/) {
            n.o = $o;
            $Gd->{$f} = $n;
        }
        elsif ($f =~ /^l\//) { 
            # compilato del shed iggy
        }
        else {
            say join("  <>  ", ($f)x38);
            w reexec;
        }
    }
    
    # to undiffering, was commit? whatever
    for my $f (keys %$od) {
        next;
    }
    
    G.last_git_diff = $d;
    
    if (keys %$Gd) { 
        my $m = join", ", keys %$Gd;
        say "Ghost changes $m";
        $H->pub(S => "ghostchanges $m");
    }
  S:
    ghostchanges: |
      my $Gd = {map { $_ => 1 } split ', ', $m};
      $G0 w ghostchanges[$Gd];
      
    zl: |
      say "yeah well $m";
      
  zl: |
    say "Wanting to reload $name" for 1..5;
    

