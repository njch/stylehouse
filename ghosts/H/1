name: G1

hooks:

  _load_ways_post: | # G/0 manages some other G's way startup ripples
    G.recoded_cbs||=[]; #1
    
    $S->w("load_ways_post");
    
    $G->Flab("$S->{name} +$S->{load_ways_count}+   ".
        join" , ", map { $_->{_wayfile} } @$w);
    
    $_ && $S->wayray($_) for $S->anyway('C');
    
    if (S.load_ways_count == 1) {
        w _init/fresh;
    }
    else {
        w _init/recoded;
    }
      
    $S->w("any_init");
    
  _init:
    recoded: |
        
        w _init/recoded_Cways[$S] if $S->anyway('recoded_Cways');
        
        $S->w("recoded_init");
        
        w _init/recoded_care_parents[$S];
        
    recoded_Cways: | # TODO reinject
      for my $i (map {_.i} $S->scGre()) {
          my $up = $S->CsK({K=>i.K});
          $i->from($up);
      }
        
    fresh: |
      w _init/keys[$S];
      
      w _init/GG[$S];
      
      S.R ||= $S->R; # or R: perc somewhere here
      
      $S->w("fresh_init");

    keys: | # TODO goner
      return unless $S->findway("keys");
      if (my $keys = G:keys) {
          push @{keys.subs}, $S unless
            grep {$_ eq $S} @{keys.subs};
      }
      else {
          sayre "G L Waiting for G keys";
          $G->timer(0.5 => sub { w keyub[$S]; });
      } 
  ghostchanges: |
    my $ghosts = H.G.GGs;
    my @rG;
    for my $S (@$ghosts) {
        my $in = [grep{$Gd->{$_}} @{S.wayfiles}];
        next unless @$in;
        push @rG, $S;
        # sort stream to avoid small before big?
        waylay recode_ways[$S, $in];
    }
    for my $cb (@{G.recoded_cbs}) {
        $G->timer(0.1, sub { $cb->($Gd) });
    }
    say " Recoding: ".join"\t\t", map { $_->pi } @rG;
  recode_ways: |
    sayyl "recoding S.id S.name";
    eval {
        $S->load_ways(split /\+/, S.way); # TODO all ways on any recoded or..?
    };
    if ($@) {
        Err "Load ways fuckup: $@";
        return $@ = "";
    }
    say "S.name !  ! ! ! S.id recoded  S.way, intersects git diffage at:";
    say " - $_" for @$in; 
        
        
  gitdission: | # look for ghostchanges
    my $some = 0;
    for my $f ($G->fs_find('/home/s/styleshed/ghosts')) {
        next if $f =~ /\/\./;
        my $mt = (stat $f)[9];
        $some = 1 if
        G.gitdissmt->{$f} ne $mt;
        G.gitdissmt->{$f} = $mt;
    }
    return unless $some;
    my @diff = `git diff`; 
    my $f;
    my $d = {};
    for (@diff) {
        if (/^diff --git "?a\/(.+?)"? "?b\/.+"?/) {
            $f = $1;
            next if -d $f; # git submodeul
            $f =~ s/^ghosts\/\\317\\240/ghosts\/Ï /sg;
            die "how to git diff unicode? $f" if $f =~ /\\\d+/;
        }
        else {
            $d->{$f} .= $_
        }
    }
    
    while (my ($f, $D) = each %$d) {
        $d->{$f} = {
            f => $f,
            D => $D,
            dig => $H->dig($D),
        };
    }
    
    return G.last_git_diff = $d if !G.last_git_diff;
    
    my $od = {%{G.last_git_diff}};
    
    my $Gd;
    while (my ($f, $n) = each %$d) { 
        my $o = delete $od->{$f};
        
        my $change = !$o || n.D ne o.D;
        
        next unless $change;
        
        if ($f =~ /^ghosts/) {
            n.o = $o;
            $Gd->{$f} = $n;
        }
        elsif ($f =~ /^l\//) { 
            # compilato del shed iggy
        }
        else {
            say join("  <>  ", ($f)x38);
            w reexec;
        }
    }
    
    # to undiffering, was commit? whatever
    for my $f (keys %$od) {
        next;
    }
    
    G.last_git_diff = $d;
    
    if (keys %$Gd) { 
        my $m = join", ", keys %$Gd;
        say "Ghost changes $m";
        $H->pub(S => "ghostchanges $m");
    }
  S:
    ghostchanges: |
      say "S ghostchanges";
      my $Gd = {map { $_ => 1 } split ', ', $m};
      $G0 w ghostchanges[$Gd];
      
    zl: |
      say "yeah well $m";
      
  zl: |
    say "Wanting to reload $name" for 1..5;
    

