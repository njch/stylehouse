

hooks:
  transam: |
    G.Es = []; # elvi beam
    
    G.am = $G->findway("node/H.name")
        || die "what am? H.name";

    # more about what to do, then...
    waylay percs;
    
  percs: |
    my $P = ar.P || G.am;
    my $GG = ar.GG || $G;
    # ^ starting from magnetic fishing rod
    # is kind of like J
    # may want to sweep startup ripples across many G
    
    @$P = sort { defined a.GAK <=> defined b.GAK } @$P;
    my $lg;
    
    for my $p (@$P) {
        if (p.D && !exists p.K) {
        
            $GG->D({bab => p.D});
        } elsif (defined p.GAK) {
            $lg = w pur_GAK[$p, $GG];
            sayyl "back from ".$GG->pi;
        }
        else {
            w pur_carb[$p, $GG];
        }
    }
    
    unless ($GG eq $G) {
        $GG w percolate_R;
        $GG w percolate;
    }
    $lg;
  pur_GAK: | #c
            my ($k, @w) = split ' ', p.GAK;
            @w = $k if !@w;
            
            my $g = $GG->K(G=>$k);
            if (!$g) {
                $g = GG.A->spawn(G=>@w);
                g.K = $k;
                sayyl "Put ".$g->pi." down";
            }
            
            my $oGG = $GG;
            say "bout $k (@w) from " .$oGG->pi;
            $GG = $oGG K G:$k;
            die "failed to percolate and find: $k" if !$GG || GG.K ne $k;
            my $P = [];
            push @$P, $_ for @{ p.P || [] };
            my @onG = flatline $GG->anyway('P');
            saygr "Perc from ?: ".@$P;
            sayre "Perc from G: ".@onG;
            
            push @$P, $_ for @onG;
            
            if (my $d = p.InC) {
                $GG->InjC($GG => {C => $d});
            }
            
            w percs[$GG, $P];
            $GG;
  pur_carb: | #c
        # translate compression
        if (keys %$p == 1 && (keys %$p)[0] =~ /^(\w+) (.+)$/) {
            my $c = $GG->CsK({K=>$1});
            die "no BcS for $1" unless c.BcS;
            my @parc = ($2, values %$p);
            $p = {};
            p.K = $1;
            p.B->{$_} = shift @parc for split ' ', c.BcS;
        }
            
        if (p.K) { # perc u
            w GG.R fuu(u => $p);
        }
        else {
            die " wtf=>".ki($p)
        }
  scribe_js: |
    my $new = G.js || [];
    return unless @$new;
    G.js = [];
    
    my $now = $H->hitime();
    G.jslast ||= $now;
    my $d = sprintf("%.3f",$now - G.jslast);
    G.jslast = $now;
    
    my $script = join"","[$d,function(){", @$new, "}],\n";
    write_file("o/o", {append=>1}, H::encode_utf8($script));
R:
  - K: non
    findway: R_non
R_nonz:
  - K: fuu #c
    D: |
      my $uu = $G->sway({K=>u.K}, $u);
      $uu || die "no such C on G.name for ".wdump($u);
      uu.S = dclone(uu.S) if uu.S;
      $u = $uu;
      inter({uu => $u->pi});
      $u = w $R Tafu[$u];
      sayyl $uu->pi ."     => ". $u->pi unless ar.q;
      if (ar.S) {
            u.A->umk(ar.S, 'S');
      }
      $u
  - K: Tafu #c
    D: |
      my $uu = w $R fu[$u];
      $uu ||= w $R T[$u];
      $u = $uu;
      u.A->umk($R, 'C');
      $u
  - K: fi #c
    D: |
      ar.f ||= {};
      grep{0->ip(ar.f, $_)} map{_.i} @{ R.A.n_us ||[]};
      
  - K: fu #c TODO A sess
    D: |
        my $fo = R.ca.K->{"u.K/u.name"}->{B_ki}->{ki(u.B||{})};
        
        if ($fo && fo.dead) {
            say "u.K found but dead";
            $fo = undef;
        }
        return $fo if $fo;
        
        my @all = w $R fi(f=>{});
        
        for my $i (@all) {
            my $yup = $i eq $u
                || (!exists u.K || i.K eq u.K)
                && (!exists u.name || u.name eq i.name)
                && 0->B_same($u => $i);
            if ($yup) {
                say "found i.K in script";
                return $i;
            }
        }
        return undef;
  - K: T #c
    D: |
      # 1
      saybl R.G->pi." ".$R->pi."  Making ".$u->pi;
      
      my $S = $u;
      S.A->umk($G, 'R'.R.name.'_C');
      S.A->umk($R, 'C');
      
      # 2
      R.ca.K->{"u.K/u.name"}->{B_ki}->{ki(u.B||{})} = $u;
      u.A->umk($R, 'us');
        
      # set up this dimension - allele tower
      # maths stapler - clown shoes - RNA
      
      # 3
      Sw flows_D;
      
      # 4
      Sw humms_D;
      w humms_D;
      
      $S
  - K: del #c
    D: |
        my $u = ar.u;
        return if u.dead;
        u.dead = 1;
        
        for my $Ak (grep { /^u.*$/ } keys %{u.A}) {
            my $uk = $Ak;
            $uk =~ s/^u/n/;
            my $it = u.A->{$Ak};
            $it = [$it] unless ref $it eq 'ARRAY';
            for my $uA (@$it) {
                0->deaccum($uA, $uk, u.A);
            }
        }
        
        for my $Ak (grep { /^n.*$/ } keys %{u.A}) {
            for my $n (map {_.i} @{u.A->{$Ak}||[]}) {
                w $R del(u => $n);
            }
        }

