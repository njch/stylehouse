

hooks:
  transam: |
    G.Es = []; # elvi beam
    
    G.am = $G->findway("node/H.name")
        || die "what am? H.name";

    # more about what to do, then...
    waylay percs;
    
  percs: |
    my $P = ar.P || G.am;
    my $GG = ar.GG || $G;
    # ^ starting from magnetic fishing rod
    # is kind of like J
    # may want to sweep startup ripples across many G
    
    @$P = sort { !defined _.GAK } @$P;
    for my $p (@$P) {
        if (p.D && !p.K) {
        
            $GG->D({bab => p.D});
        } elsif (defined p.GAK) {
            w pur_GAK[$p, $GG];
            sayyl "back from ".$GG->pi;
        }
        else {
            w pur_carb[$p, $GG];
        }
    }
    $GG w percolate unless $GG eq $G;
    
    waylay H_created;
  pur_GAK: | #c
            my ($k, @w) = split ' ', p.GAK;
            @w = $k if !@w;
            
            if (!GG.GG->{$k}) {
                $GG->GAK($k, GG.A->spawn(G=>@w));
                sayyl "Put ".GG.GG->{$k}->pi." down";
            }
            
            my $oGG = $GG;
            my $GG = GG.GG->{$k} || die;
            my $P = [];
            push @$P, $_ for @{ p.P || [] };
            my @onG = @{ $GG->anyway('P') || [] };
            sayre @onG." on oGG.name perc GG.name ! perc";
            push @$P, $_ for @onG;
            
            if (my $d = p.InC) {
                $GG->InjC($GG => {C => $d});
            }
            
            w percs[$GG, $P];
            sayyl "back from ".$GG->pi;
  pur_carb: | #c
        # translate compression
        if (keys %$p == 1 && (keys %$p)[0] =~ /^(\w+) (.+)$/) {
            my $c = $GG->CsK({K=>$1});
            die "no BcS for $1" unless c.BcS;
            my @parc = ($2, values %$p);
            $p = {};
            p.K = $1;
            p.B->{$_} = shift @parc for split ' ', c.BcS;
        }
            
        if (p.K) { # perc u
            my $u = $GG->sway({K=>p.K}, $p);
            saybl "Making ".$u->pi;
            $u = w GG.R Tafu[$u];
        }
        else {
            die " wtf=>".ki($p)
        }
  scribe_js: |
    my $new = G.js || [];
    return unless @$new;
    G.js = [];
    
    my $now = $H->hitime();
    G.jslast ||= $now;
    my $d = sprintf("%.3f",$now - G.jslast);
    G.jslast = $now;
    
    my $script = join"","[$d,function(){", @$new, "}],\n";
    write_file("o/o", {append=>1}, H::encode_utf8($script));
R:
  - K: non
    findway: R_non

R_nonz:
  - K: Tafu #c
    D: |
        0->fu($u) || 0->T({i => $u});

