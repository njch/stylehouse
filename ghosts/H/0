
name: hostinfo
C:
  - K: J
    Gw: 1
  - K: j
    Gw: 1
  - K: R
    Gw: 1
  - K: Elvis
    max_tooth_Hz: 12
    Gw: 1
  - K: mess  # j?
    print: |
        "m S.m".
        G::gp($thing); # R gp
R:
 - K: ivm
hooks:
  fresh_init: |
    say "     H Fresh init H.style H.name";
    H._future = 1;
    push @{G.GGs||=[]}, $G; # H self
    
    H.r = w enRedis;
    H.sur = w enRedis;
    w figure_port;
    
    0->su('H*' => sub { w Hi(a=>shift); }) if H.name eq "O";
      
    my $reS = sub { my $a = shift; w reS(%$a); }; 
    0->su(S => $reS);
    0->su("S/H.style/H.name" => $reS);
    0->su("S/H.style/H.name/H.id" => $reS);
    w hostinfo;
    $H->pub("H/H.style/H.name/H.id" => $$);
    
    
    $G->timer(60*9+(20 * rand 4),
        sub { sayre "voluntary reexec" for 1..13; w reexec; })
        if H.name !~ /Z/;
    
    
    Mojo::IOLoop->recurring(0.02 => sub {
        H.sur->wait_for_messages(0.01618);
    });
    Mojo::IOLoop->recurring(8 => sub {
        w hostinfo;
    });
    Mojo::IOLoop->recurring(2 => sub {
        H.r->set("H/H.style/H.name/H.id" => $H->hitime); # TODO lots
    });
    Mojo::IOLoop->recurring(0.4 => sub {
        w gitdission;
    }) if H.name eq 'Z';
    
    # start git torrent
    # do it all
    # $0 has become a runtime
    waylay in;
  hostinfo: |
    my @ps = `ps -p$$ fu`;
    my ($u, $pid, $mem, $cpu) = (split /\s+/, $ps[1])[0,1,2,3];
    $_ = $_ / 100 for $cpu, $mem;
    my $tot
    #= ((`wc -l ghosts/*/*`)[-1]  =~ /(\d+) total/)[0]
    ;
    my $info = "$tot $cpu $mem ".$H->hitime;
    saygr $info if rand(5) > 4;
    $H->pub("hostinfo/H.style/H.name/H.id" => $info, 'ig');
    G.hostinfo_waits++;
    if (G.hostinfo_waits > 1) {
        sayre "hostinfo uncollected";
    }
      
  mess: |
    # TODO sa* all over
    # by voltage!
    $H->pub("S/H.style/H.name/sa", "$what: @$thing");
  pubbedElvis: | # message for elvis via redis
      sayre "su a.top ".slim(30,30,a.m);
      my $m = a.m;

      my ($El, $st, $na, $ww, $uni) = split '/', a.top;
      if ($uni) {
            # meta
          sayyl "unifid $st $na $ww !";
          
          my $hold = H.r->get("W/$ww") || die "no such $ww";
          my ($hol, $etc) = split /\s+/, $hold, 2;
          if ($etc) {
              my $E = H.who;
              sayyl "Retiling";
              0->sing(retile => sub { H.G w retile[$E]; }, begin => 0.8);
          }
      }

      H.G w send_Elvis[$m];
  Teeth: |
    w $J print_in;
    my ($m, $j) = w $J decode;
    
    if (ref $j eq "HASH") {
        if (keys %$j != 1) {
            die "hash wide/skinny ".wdump($j);
        }
        my ($uno) = keys %$j;
        saygr "cuno $uno";
        my $a = {
            j => $j,
            m => $m,
            $uno => $j->{$uno},
        };
        a.E = ar.E if ar.E;
        w S/$uno(%$a);
        # hit or not? see post 6 with r
        return;
    }
    
    die "weird shit: '$m'" if ref $j;
    
    if ($j =~ /^([\w\/]+) (.+)$/) {
        my $a = {m => $2};
        a.E = ar.E if ar.E;
        w S/$1(%$a);
    }
    else {
        die "wei tet '$j'";
    }
  jaw: |
    my $s = $H->mkuuid();
    ($s) = reverse split '-', $s;
    G.jaws->{$s} = delete ar.cb; # TODO a Z awaits, sucks $m
    ar.m = 
        " var e = function(){ $js };"   
        ."var m = e();"
        ."s\.reply({jaw:{s:'$s',e:m}});";
    w send_Elvis;
  reS: |
    my ($way, $am) = split /\s+/, $m, 2;
    sayyl "S > $m" if $way ne 'hostinfo/ack';
    $way || die "wtf $m";
    w S/$way(%$ar,m=>$am);
  S:
    hostinfo:
      ack: |
        my (@s) = split /\s+/, $m;
        if (rand(5) > 1) {
            my $lag = (1000*sprintf('%.3f',$H->hitime - $s[-1])).'ms';
            sayyl "out there! lag: $lag";
        }
        G.hostinfo_waits = 0;
    speaks: | # concealed elvis input
      my $J = 0->Bu(J => {m=>$m});#2
      w Teeth[$J];
      
    jaw: | # TODO route with H.id
      $j = j.jaw;
      my $s = j.s || die "no s";
      my $cb = G.jaws->{$s} || die "no such jaw $s";
      $cb->(j.e); # TODO Z sucktion
    er: |
      die "much JS error..." if H.JErrors++ > 3;
      $H->error("javascript error from client", j.m, j.e);
    event: |
      my $e = ar.e = j.event;
      
      return w S/key if e.type =~ /^key/;
      
      return w S/W if e.W;
      
      return w S/TV if e.id;
      
      $H->error("Strange event", $e);
      
    key: |
      # if key is ww switcher...
      if (H.name eq "O") {
            G.keysto || die "no key subber";
          $H->pub("S/G.keysto" => "speaks $m");
      }
      else {
          return H.keydo->($e) if H.keydo;
      }
      
    TV: |
      w duu/TV;
  
    ghostchanges: |
      return if H.G.wtf.gitdission;
      say "S ghostchanges";
      my $Gd = {map { $_ => 1 } split ', ', $m};
      $G0 w _gitdission[$Gd];
      
    zl: |
      say "yeah well $m";
      
    On: |
      die "!";
      $m =~ s/^H.style\/H.name // && w reS[$m];
    W: |
        $e->{$_} =~ /^\w+$/ || delete $e->{$_} for qw'id ux W';
        
        my $a = {};
        if (a.W = H.G.A.W->{e.W}) {
            a.L = a.W->findL(e.id);
            a.uxL = a.W->findL(e.ux);
            a.e = $e;

            a.W.G w event(%$a);
        }
        else {
            my $hold = H.r->get("W/e.W") || die "no such e.W";
            my ($hol, $etc) = split /\s+/, $hold, 2;
            $H->pub("S/$hol", "speaks $m");
            G.keysto = $hol;
        }
  gitdission: |
    my $some = 0;
    for my $f ($G->fs_find('/home/s/styleshed/ghosts')) {
        next if $f =~ /\/\./;
        my $mt = (stat $f)[9];
        $some = 1 if
        G.gitdissmt->{$f} ne $mt;
        G.gitdissmt->{$f} = $mt;
    }
    return unless $some;
    my @diff = `git diff`; 
    my $f;
    my $d = {};
    for (@diff) {
        if (/^diff --git "?a\/(.+?)"? "?b\/.+"?/) {
            $f = $1;
            next if -d $f; # git submodeul
            $f =~ s/^ghosts\/\\317\\240/ghosts\/Ï /sg;
            die "how to git diff unicode? $f" if $f =~ /\\\d+/;
        }
        else {
            $d->{$f} .= $_
        }
    }
    
    while (my ($f, $D) = each %$d) {
        $d->{$f} = {
            f => $f,
            D => $D,
            dig => $H->dig($D),
        };
    }
    
    return G.last_git_diff = $d if !G.last_git_diff;
    
    my $od = {%{G.last_git_diff}};
    
    my $Gd;
    while (my ($f, $n) = each %$d) { 
        my $o = delete $od->{$f};
        
        my $change = !$o || n.D ne o.D;
        
        next unless $change;
        
        if ($f =~ /^ghosts/) {
            n.o = $o;
            $Gd->{$f} = $n;
        }
        elsif ($f =~ /^l\//) { 
            # compilato del shed iggy
        }
        else {
            say join("  <>  ", ($f)x38);
            w reexec;
        }
    }
    
    # to undiffering, was commit? whatever
    for my $f (keys %$od) {
        next;
    }
    
    G.last_git_diff = $d;
    
    if (keys %$Gd) { 
        my $m = join", ", keys %$Gd;
        say "Ghost changes $m";
        $H->pub(S => "ghostchanges $m");
        $G0 w _gitdission[$Gd];
    }
  suRedis: |
    my $s = 'subscribe';
    $s = "p$s" if $top =~ /\*/;
    
    my $D = sub {
      my $d = {};
      (d.m, d.top, d.sutop) = map { $H->fixutf8($_) } @_;
      $G->timer(0.00001, sub {
            $cb->($d);
      });
      1;
    };
    
    H.sur->$s($top => $D);
    push @{H.sur_subbed||=[]}, $top;
    
    sayyl "Subbed to $top";
  enRedis: |
    my $r = Redis->new(
        server => 'localhost:8888',
        reconnect => 1,
        every => 10000,
    );
    r.gest = sub {
        my ($k, $make) = @_;
        my $c = H.r->get($k);
        return ref \$c eq "SCALAR" ? $H->fixutf8($c) : $c if $c;
        $c = $make->();
        H.r->set($k => $c);
        return $c;
    };
    $r
  waits: |
    my $towait = ar.towait || 1;
    my $to = ar.to;
    
    my $max = max map { _.div } @$to;
    _.span = $max / _.div for @$to;
    
    my $tot = sum map { _.span } @$to;
    my $one = $towait / $tot;
    
    my $ord = {};
    for my $t (@$to) {
        my $waits = $one * t.span;
        $waits = sprintf("%.7f", $waits);
        t.waits = $waits;
        push @{ $ord->{$waits} ||= [] }, $t
    }
    return $ord;
    
  J: # 
    Bu_D: |
      B.m =~ s/\n?$/\n/s;
      S.dig ||= $H->dig(B.m);
      S.hitime = $F[0]->{hitime};
    decode: |
      if ($m =~ /^"(.+)"\n$/s) {
          B.j = $1;
      }
      else {
          B.j = $H->djson($m);
      }
      (B.m, B.j)
      
    print_out: |
      return if $m =~ /\$\('#(worm|mess|sky|path|land|func|somewhere|flood)/;
      # ^ trace F, tractoriose
      my $short = length($m) < 200 ? $m : substr($m,0,23*9)." >SNIP<";
      chomp $short;
      print colored("< send $pi\t\t", 'blue');
      print colored($short, 'bold blue');
      say "";
    print_in: |
      my $pi = ar.pi || S.id;
      $pi = ar.E->pi if ar.E;
      my $m = $m;
      chomp $m;
      print colored("recv > $pi\t\t", 'red');
      print colored($m, 'bold red');
      say "";
  j: #
    D: |
      # god object
      # bit that rattles around from here
      # that is from Elvis talk held in J
      # so J is the still meaning of the activity
      #    J is uncarved block of wood
      # j changes as it goes
      # spiralling, modding
      # harmon stacks procedures geometries
      # much like T but not about a line, about physics, energy, meta
      # behaviour stuff joins 
      # all of that is travelly 9 wrapz
      # in things more dynamically
      
      # in a dimension that mods
      
      # like keyword-only, plumbing-sparse talking can dilute/narrow meaning on the receiving end
      
      # the data from JSON of the websocket line will do now
      # as an origin of the energy and a place to cling complications
      # this is ACGT or whatever language
      # hash has named sentences
      # send tences - the web tightens as it nests
      
      
      
  reexec: |
      exec "nice perl $0 @ARGV";
  sing: |
    G.singing ||= {};
    # where from?
    return #sayre "\t\t\t\t $name BLOCKED"
        if G.singing->{$name}
            && G.singing->{$name}++; # ignore sing until...
    G.singing->{$name} = 1;
    my $t = ar.block || ar.again || 0.04;
    my $d = ar.begin || 0.001;
    $G->timer($d, sub {
        $G->timer($t, sub {
            my $splatter = delete G.singing->{$name};
            if ($splatter > 1 && ar.again) {
                $G->Flab("Sig reps $splatter... again!  $name");
                w sing(%$ar);
            }
        }, "sing-block        $name");
        G.singing->{$name} = 1;
        $code->();
    }, "pre-sing     $name");
    
  retile: | # TODO client side js data inter
    my $js = 
    " var e = []; \$('#ux > ww[class*=".'"z"'
    ."]').each(function(){"
        ."e\.push(\$(this).attr('id'));" # could take more clues
    ."});"
    ."return e\.join(' + ');";
    my @Es = w Es;
    @Es = ar.E if ar.E;
    for my $E (@Es) {
        my $cb = sub { my $m = shift; w divide[$m]; };
        H.G w jaw[$js, $cb];
    }
  divide: |
    my @m = sort split / \+ /, $m;
    
    my $div = Load(<<''); # hmm
        - width:left 2
        - height:top 2
    
    my $grid = {};
    for my $p (@$div) {
        my ($iv, $parts) = split ' ', $p;
        my ($mags, $ax) = split ':', $iv;
        # magnitudes of width
        # axed from unified by left, etc.
        my $in = sprintf("%.3f", 1 / $parts);
        
        my @ground = map { [$_ => $grid->{$_} ] } sort keys %$grid;
        @ground = [] if !@ground;
        my $pole = [];
        $grid = {};
        
        my $here = 0; # in accum
        for my $i (1..$parts) {
            my $ox = {};
            ox.part = $i;
            $ox->{$ax} = $here;
            $here += $in;
            $ox->{$mags} = $in;
            push @$pole, $ox;
        }
        
        for my $g (@ground) {
            my ($k, $v) = @$g;
            $v ||= {};
            for my $ox (@$pole) {
                my $K = (defined $k?"$k ":"") . ox.part;
                my $x = $grid->{$K} = {%$v, %$ox};
                delete x.part;
            }
        }
    }
    
    my @holes = sort keys %$grid;
    say "Got ".@m." pegs for ".@holes." holes";
    for my $n (@m) {
        my $h = shift @holes;
        my $o = $grid->{$h};
        my $cssset = ".animate({".join(",", map {
            "'$_':'".($o->{$_} * 100)."%'"
            } sort keys %$o)."}, 0)";
        my $E = H.who;
        $E->send(" \$('#$n')$cssset".";");
        $G->timer(0.4, sub { $E->send(" \$('#$n').removeClass('NZ');"); });
    }
  

