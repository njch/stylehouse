
name: hostinfo
C: # Elvis, J
  - K: Elvis
    max_tooth_Hz: 12
    Gw: 1
  - K: J
    Gw: 1
  - K: j
    Gw: 1
dials:
  horizon: 95%
hooks:
  websocket: |
    Say "WQbSocket opened";
    # strangers are Elvis until they're not
    # they might have $M->stash("Elvis=ae38273" => secret) to resume...
    my $Elvis = 0->TafuB(
        Elvis => {tx => $M->tx, M => $M});

    $M->on(message => sub {
        my ($M, $m) = @_;
        my $J = 0->Bu(J => {m=>$m}); # $m
        w $Elvis speaks[$J];
    });

    $M->on(finish => sub {
        my ($M, $code, $reason) = @_;
        w $Elvis leaves[$code, $reason];
    });
  Elvis:
      # here we want to graph things out real careful
      # because it is how things get around
      # the one to the many
      # apps can be multicasting too
      # none of these workings should be trapped at this level
      # send it out there and get the hair on it
    flows_D: |
      Mojo::IOLoop->stream($tx->connection)->timeout(300000);
      Say "Elvis appears from B.address";
      w $S populi;
      H.who = $S;
      B.sign = scalar(`figlet '<<<<'`);
      B.sign = substr(B.sign, length(B.sign)*(7/9));
      B.sign =~ s/\n$//s;
      B.address = $tx->remote_address;
      S.mouth = [];
      
    humms_D: |
      $H->send($_) for
          "ws".".reply({geometry: {x: screen.availWidth, y: screen.availHeight}});",
        "ws".".reply({whatsthere: 'too hard'}); \$('body').empty();",
        "\$(window).on('click', clickyhand);"
      # handy stuff...?
      
    send: |
      $tx->send(J.B.m);
      
    speaks: |
      if (w $S mouthfull[$J]) {
          # elvis losing teeth means more samples than processed
          # these lingos chew on data anyway
          sayyl "MOUTH FULL  ";
          return;
      }
      w $J print_in;
      w $J decode;
      w init/flood if H.underworld; # somewhere round here
      
      my $Elvis = $S;
      my $j = J.B.j;
      w M[$J, $j, $Elvis];
      
      w $S woosh;
      
    woosh: |
      print Hostinfo::colored($sign, 'blue on_green');
    mouthfull: |
      for my $mJ (@{S.mouth}) {
            return 1 if mJ.dig eq J.dig &&
                (1 / (J.hitime - mJ.hitime))
              > S.max_tooth_Hz
      }
      push @{S.mouth}, $J;
      shift @{S.mouth} if @{S.mouth} > 3;
      return 0;
      
    leaves: |
      sayre "WebSocket closed: $address - $code, $reason";#, $code, $reason, $S);
      
    populi: |
      my @all = 0->scGre({K=>"Elvis"});
      if (@all > 1) {
          sayre " Elvis is taking over!";
          _.B.tx->finish for @all;
          sayre " restarting...";
          w re/exec;
      }
  J:
    Bu_D: |
      #B.m = Hostinfo::encode_utf8(B.m);
      S.dig ||= Hostinfo::enhash(B.m);
      S.hitime = $F[0]->{hitime};
    decode: |        
      my $j;
      eval { $j = decode_json(Hostinfo::encode_utf8($m)) };
      die "JSON DECODE FUCKUP: $@\n\nfor $m\n\n\n\n" if $@;
      die "$m\n\nJSON decoded to ~undef~" unless defined $j;
      sayyl "J.id decoded ".$G->F_delta();
      B.j = $j;
    print_out: |
      return if $m =~ /\$\('#(worm|mess|sky|somewhere|path|land|func|appmenu|flood)/;
      # ^ trace F, tractoriose
      my $short = length($m) < 200 ? $m : substr($m,0,23*9)." >SNIP<";
      my $jabber = join"\n", map { _.name } @F;
      if ($jabber =~ /Ϡ| ux |/) {
          my $th = G:Ϡ;
          push @{th.js||=[]}, $m;
      }
      print colored("< send S.id\t\t", 'blue');
      print colored($short, 'bold blue');
      say "";
    print_in: |
      print colored("recv >\t\t", 'red');
      print colored($m, 'bold red');
      say "";
  j: # god object
    D: |
      # bit that rattles around from here
      # that is from Elvis talk held in J
      # so J is the still meaning of the activity
      #    J is uncarved block of wood
      # j changes as it goes
      # spiralling, modding
      # harmon stacks procedures geometries
      # much like T but not about a line, about physics, energy, meta
      # behaviour stuff joins 
      # all of that is travelly 9 wrapz
      # in things more dynamically
      
      # in a dimension that mods
      
      # like keyword-only, plumbing-sparse talking can dilute/narrow meaning on the receiving end
      
      # the data from JSON of the websocket line will do now
      # as an origin of the energy and a place to cling complications
      # this is ACGT or whatever language
      # hash has named sentences
      # send tences - the web tightens as it nests
      
      
      
  send_Elvis: |
    my $J = 0->Bu(J => $ar); # $m
    w $J print_out;
    # many ----
    my $Elvis = H.who || die "no individual to send $m!";
    w $Elvis send[$J];
  M: |
    # $J and $Elvis doings...
    return w serve/claw   if j.claw;
    return w serve/event  if j.event;
    return w serve/error  if j.error; # change from {e}
    return w serve/scroll if j.scroll;
    

  check:
    vitals: |
      $G->susgdb;
      my @v = (
          w check/MemAvailable,
        w check/ps,
        w check/LoC,
      );
      $G->mess(Vitals => \@v);
      waylay 8 check/vitals;
    MemAvailable: |
      my ($a) = `cat /proc/meminfo | grep MemAvailable`;
      ($a) = $a =~ /(\d+) kB/;
      $a = int($a / 1024);
      kill 'KILL', $$         if !$a || $a < 50 || $! ;
      $a < 500 ? "MemAvail: ${a}mB" : ()
    ps: |     
      my @ps = `ps -p$$ fu`;
      my ($u, $pid, $m, $c) = (split /\s+/, $ps[1])[0,1,2,3];
      $m /= 100;
      $c /= 100;
      $H->error("memory usage $m") if $m > 0.4;
      w re/exec if $m > 0.9; # unlikely to be effective from inside
      "$u`$pid  m$m  c$c"
    LoC: |
      my $tot = (`wc -l lib/* ghosts/*/* stylehouse.*`)[-1];
      ($tot) = $tot =~ /(\d+) total/;
      "$tot lines"
  mess: |
    unless (H._future) {
        warn "Pre future mess... ".ki($ar) for 1..8;
        return;
    }
    my $m = G:mess;
    $m || die'no mess!';
    H._future = 0;
    
    eval { $m ->w(mess => $ar); };
    if ($@) {
        die "Throwing mess mess: $@\n\n\n".wdump($ar);
    }
    
    H._future = 1;
  re:
    exec: |
      exec "perl stylehouse.pl";
  init:
    later: |
      waylay check/vitals;
    future: |
      $H->{_future} = 1;
    flood: |
      my $house = $H->get('style') eq 'stylehouse';
    
      G!H/mess;
      G!H/keys if !$house;
      G!H/colour;
      G!H/sky ->w('flood_init');
      G:mess  ->w('flood_init');
      G!H/ground ->w('flood_init');
      
      waylay init/later;
      # so ll that stuff is vague happens as it happens stuff built near 0 anyway ^
    
      $house ?
          Git->new($H->intro) && Codo->new($H->intro)
      :
          G!Ϡ
      ;

      $H->menu();
      $H->{floodmenu}->{Ш}->() if $house;

      $H->update_app_menu();
      $H->{underworld} = 0;
  reinit:
    everything: |
      $H->error("restarting!");
      `touch stylehouse.pl`;
  
  serve:
    claw: |
      $H->claw($j);
      
    error: |
      die j.d if H.JErrors++ > 3;
      $H->error("javascript error from client", j.d, j.error);
      
    event: |
      my $e = ar.e = j.event;
      $G->Flab("H dostuff event", $e);
      return w serve/key if e.type =~ /^key/;
      return w serve/wormhole if e.W;
      return w serve/TV if e.id;
      $H->error("Strange event", $e);
      
    key: |
      G:keys ->w(Arr => {e => $e});
      
    wormhole: |
      my $E;
      my $findL = sub {
        return unless $E->{W};
        my $id = shift;
        (grep { $_->{uuid} eq $id } @{ $E->{W}->{script} })[0]
      };
      my $id = sub {
        my $i = shift;
        return unless $i =~ /^(\w+)$/;
        $1
      };
      
      my $Wid = $id->($e->{W});
      ($E->{W}) = grep { $_->{id} eq "Wormhole-$Wid" } @{ $H->get("Wormhole") };
      
      my $Lid = $id->($e->{id});
      $E->{L} = $findL->($Lid);
      
      my $uxLid = $id->($e->{ux});
      $E->{uxL} = $findL->($uxLid);
      
      $E->{e} = $e;
      if (E.W) {
            $E->{W}->{G}->w('event', $E) if $E->{W};
      }
      else {
          Say "Nothing!!!! from $Lid\n"
          ."Well ".e.W."      \n".join"\n", map {_.id} @{ $H->get("Wormhole") };
      }
      
    TV: | #c
      my $id = $e->{id};
      my $thing = $H->tv_by_id($id) if $id;

          if ($thing) {
              sayyl "TV  $thing->{id}";
              $thing->event($e);
          }
          else {
              sayyl "TV not found".( $id ? ": $id" : ", lacking id");
              

              if (my $catcher = $H->get('clickcatcher')) {
                  sayyl "Event catcher found: $catcher";
                  $catcher->event($e);
              }
              else {
                  sayyl "NOTHING" for 1..4;
              }
          }
          sayyl "event handled in ".$G->F_delta()."\n\n";
  
  
  data:
    get_apps: |
      my $apps = {};
      my $d = $O->data;
      for (keys %$d) {
          next unless /^[A-Z]\w+$/;
          $apps->{$_} = $d->{$_};
      }
      return $apps;

