
name: hostinfo
C: # Elvis, J
  - K: Elvis
    max_tooth_Hz: 12
    Gw: 1
  - K: J
    Gw: 1
  - K: j
    Gw: 1
  - K: R
    Gw: 1
hooks:
  fresh_init: |
    say "     H Fresh init H.style";
    
    H.r = w enRedis;
    
    w config;
    
    Mojo::IOLoop->recurring(0.4 => sub { w wtf(riv => 'wtf'); });
    
    w wtf(div => 1, way => 'check/script');
    w wtf(div => 1, way => 'redission');
    w wtf(div => 1, way => 'gitdission');
    w wtf(div => 17, way => 'check/vitals');
    
    w H.style/in;
  config: |
    my $listen = readlink('listen');
        my ($host,$port, $wa) = split ':', $listen;
        die "too much listen" if $wa;
        ($port, $host) = (2000, undef) if !$port && $host =~ /^\d+$/;
        $port ||= 2000;
        $host ||= '127.0.0.1';
        
        $port += 1; # TODO find soul via redis
        
    H.listen_http = "http://$host:$port";
    H.listen_ws = "ws://$host:$port/ws";
    
  websocket: |
    sayg "strangers are Elvis until they're not";
    0->TafuB(Elvis => {tx => $M->tx, M => $M});

  Teeth: |
    w $J print_in(pi => $E->pi);
    my $m = J.B.m;
    w flood_init unless H.notunderworld; # somewhere round here
    w $J decode;
    my $j = J.B.j;
    
    return w serve/hash[$j] if ref $j eq "HASH";
    
    die "weird shit: '$m'" if ref $j;
    
    if ($j =~ /^([\w\/]+) (.+)$/) {
        $ar = {m => $2, E => $E}; #J?
        w S/$1; # < or v
        w H.style/S/$1;
    }
    else {
        die "wei tet '$j'";
    }
    
    w $E swoosh;#9
  S:
    wsy: |
      my $C = G.conz ||= {};
      (E.c.w, E.c.s) = split ' ', $m;
      if (my $EE = $C->{E.c.w}) {
            sayre "Already on E.c.w ".$EE->pi."  disco necktie ".$E->pi;
          w $E disconecktie[$EE];
          return;
      }
      $C->{E.c.w} = $E;
      if (E.c.w eq E.c.s) {
          E.singul;
          w H.style/singul;
      }
      else {
          w H.style/elvus;
      }
  stylehut:
    reexec: |
      exec "perl l/S".".pm";
    in: |
      G!H/mess;
      sleep 1;
      waylay stylehut/play;
      
    play: |
      H.h = G!Ϡ;
    
    elvus: |
      sayg "elvission modio";
      
      G:Ϡ w elvis_enters;
    
    elvibe: |
      H.notunderworld = 1;
      $H->send(" s\.r('wsy '+ w\.conin +' '+ s\.conin );");
      
    singul: |
      sayg "sSingu mode";
      
      G:Ϡ w elvis_enters;
      
      $H->send(" clon();");
      
      *Ghost::sw = sub { say "switching to G::sw @_";G::sw(@_) };
      
      $H->send(sprintf "version is v%vd", $^V);
      
      Mojo::IOLoop->recurring(32 => sub{ w stylehut/yup; });
      Mojo::IOLoop->recurring(6 => sub{ w stylehut/honk; });
    honk: |
      $H->send('.'. (("  ")x int(2 + rand 10))."!!!");
    yup: |
      $G::swdepth = 10;
      say "yup: ".sw("styleh00t ".sprintf('%.5f',rand()));
      
      
  styleshed:
    reexec: |
      exec "perl stylehouse.pl SHED";
    in: |
      G!H/mess; # due to spawn syntax
    elvibe: |
      say "Elvibin";
      $H->send($_) for 
        " w".".reply({geometry: {x: screen.availWidth, y: screen.availHeight}});",
        "\$('body').empty();", # or not...
        "clon();";
    play: |
      G!H/keys;
      
      G!Ϡ;
      
      my $Dambi = sub { G:sky w ambientness; };
      w wtf(div => 26, way => 'sky amb', D => $Dambi);
      
  stylehouse:
    reexec: |
      exec "perl stylehouse.pl HOUSE";
    in: |
      G!H/mess; # due to spawn syntax
    elvibe: |
      $H->send($_) for 
        "w".".reply({geometry: {x: screen.availWidth, y: screen.availHeight}});",
        "\$('body').empty();", # or not...
        "clon();";
    play: |
      G!H/ground ->w('flood_init');
      Git->new($H->intro);
      Codo->new($H->intro);
      $H->JS("\$('#sky').stop().slideUp();");
  wtf: |
    # TODO combine with check, fractionating importantness into time
    if (ar.way && ar.div) {
        my $a = { %$ar, now => 0 };
        $G->{ar.riv||'wtf'}->{ar.way} = $a;
        return;
    }
    my $riv = $G->{ar.riv} ||= {};
    my @to;
    while (my ($way,$R) = each %$riv) {
        R.now++;
        if (R.now >= R.div) {
            R.now = 0;
            $G->timer(0, sub {
                return R.D->() if R.D;
                $G->w("$way");
            });
        }
    }
  mess: |
    unless (H._future) { # TODO delete _future after burning SHED
        # TODO move mess into H, it's just one C
        # tractor to allow trig subs to each K
        # between H.G being here and G:mess being here
        saygr "prefut ar.what  = ".
        join"  ", map {gpty($_)} flatline(ar.thing);
        return;
    }
    my $m = G:mess;
    $m || die'no mess!';
    H._future = 0;
    
    eval { $m ->w(Arr => $ar); };
    if ($@) {
        die "Throwing mess mess: $@\n\n\n".wdump($ar);
    }
    
    H._future = 1;
  gitdission: |
    my @diff = `git diff`;
    my $f;
    my $d = {};
    for (@diff) {
        if (/^diff --git "?a\/(.+?)"? "?b\/.+"?/) {
            $f = $1;
            $f =~ s/^ghosts\/\\317\\240/ghosts\/Ϡ/sg;
            die "how to git diff unicode?" if $f =~ /\\\d+/;
        }
        else {
            $d->{$f} .= $_
        }
    }
    
    while (my ($f, $D) = each %$d) {
        $d->{$f} = {
            f => $f,
            D => $D,
            dig => $H->dig($D),
        };
    }
    
    return G.last_git_diff = $d if !G.last_git_diff;
    
    my $od = {%{G.last_git_diff}};
    
    my $Gd;
    while (my ($f, $n) = each %$d) { 
        my $o = delete $od->{$f};
        
        # TODO $H->dig hashing is rubbish at uniq?
        my $change = !$o || n.D ne o.D;
        
        next unless $change;
        
        if ($f =~ /^ghosts/) {
            n.o = $o;
            $Gd->{$f} = $n;
        }
        elsif ($f =~ /^l\//) {
            # compilato del shed iggy
        }
        else {
            say join("  <>  ", ($f)x38);
            w re/exec;
        }
    }
    
    # to undiffering, did HEAD change?
    for my $f (keys %$od) {
        say join("  <  >  ", ($f)x28);
        w re/exec;
    }
    
    G.last_git_diff = $d;
    
    if (keys %$Gd) { 
        say "Ghost changes ".join", ", keys %$Gd; 
        $G0 w _gitdission[$Gd]; 
    }
  suRedis: |
    my $a = {%$ar};
    a.div ||= 3;
    a.top || die "no su top";
    my $D = a.cb || die "no su cb";
    a.way ||= $top." D=$D"; # uniq
    
    a.r = w enRedis;
    a.r->subscribe($top => $D);
    a.r.wassubbedto = $top;
    a.riv = 'redission';
    G.redission->{a.way} = $a;
    
    my $riv = G.redission ||= {};
    my @to = values %$riv;
    G.redisco = w waits(to => \@to, towait => 0.1);
  redission: |
    my $ord = G.redisco ||= {};
    for my $k (sort keys %$ord) { # numbers wall timespace
        my $int = $ord->{$k}; # a time
        for my $t (@$int) { # in time
            t.r->wait_for_messages($k); # ooh the key
        }
    }
  enRedis: |
    my $r = Redis->new(
        server => 'localhost:8888',
        reconnect => 1,
        every => 10000,
    );
    r.gest = sub { # do a R::edis module
        my ($k, $make) = @_;
        my $c = H.r->get($k);
        return ref \$c eq "SCALAR" ? Hostinfo::fixutf8($c) : $c if $c;
        $c = $make->();
        H.r->set($k => $c);
        return $c;
    };
    $r
  waits: |
    my $towait = ar.towait || 1;
    my $to = ar.to;
    
    my $max = max map { _.div } @$to;
    _.span = $max / _.div for @$to;
    
    my $tot = sum map { _.span } @$to;
    my $one = $towait / $tot;
    
    my $ord = {};
    for my $t (@$to) {
        my $waits = $one * t.span;
        $waits = sprintf("%.7f", $waits);
        t.waits = $waits;
        push @{ $ord->{$waits} ||= [] }, $t
    }
    return $ord;
    
  check:
    script: |
      my $script = $0;
      my $nc = (stat $script)[10];
      die "no ctime?" unless $nc;
      if (H.Sctime && $nc ne H.Sctime) {
          Say "Rwestarting! ctime changeon $script";
          w re/exec;
      }
      H.Sctime = $nc;
    vitals: |
      $G->susgdb;
      my @v = (
          w check/MemAvailable,
        w check/ps,
        w check/LoC,
      );
      $G->mess(Vitals => \@v);
    MemAvailable: |
      my ($a) = `cat /proc/meminfo | grep MemAvailable`;
      ($a) = $a =~ /(\d+) kB/;
      $a = int($a / 1024);
      kill 'KILL', $$         if !$a || $a < 50 || $! ;
      $a < 500 ? "MemAvail: ${a}mB" : ()
    ps: |     
      my @ps = `ps -p$$ fu`;
      my ($u, $pid, $m, $c) = (split /\s+/, $ps[1])[0,1,2,3];
      $m /= 100;
      $c /= 100;
      sayre "memory usage $m" if $m > 0.4;
      w re/exec if $m > 0.9; # unlikely to be effective from inside
      "$u`$pid  m$m  c$c"
    LoC: |
      my $tot = (`wc -l lib/* ghosts/*/* stylehouse.*`)[-1];
      ($tot) = $tot =~ /(\d+) total/;
      "$tot lines"
  flood_init: |
      die 'only stylehouse floodsrigh?'
          unless $0 eq 'stylehouse.pl' || $0 eq "hed";
      
      G!H/colour; # TODO R
      
      G!H/sky ->w('flood_init');
      
      # no ^
      $G->w("H.style/play"); # yes
      # no v

      H.notunderworld = 1;
      # our fate's the most epic shift ever
      # TODO lose this whole sub
      # must be invoked on first Elvis/speaks for now because things ->send
  send_Elvis: |
    my $Elvis = ar.Elvis || H.who || die "no infiduvial? $m";
    my $J = 0->Bu(J => {m => ar.m, cb => ar.cb});
    w $J print_out(pi => $Elvis->pi);
    w $Elvis send[$J];
  Elvi: |
      0->rei({K=>"Elvis"});
  Elvis: #
      # here we want to graph things out real careful
      # because it is how things get around
      # the one to the many
      # apps can be multicasting too
      # none of these workings should be trapped at this level
      # send it out there and get the hair on it
    flows_D: |
      Mojo::IOLoop->stream($tx->connection)->timeout(300000);
      B.address = $tx->remote_address;
      S.mouth = [];
      
      w $S populi if ! H.h; # dodge
      
      H.who = $S; # hut later
      
      B.elvii = ++H.elvii;
      
      Sw sign;
      
      $M->on(message => sub {
          my ($M, $m) = @_;
          eval { Sw speaks[$m]; };
          $H->error("$@") if $@;
          $@ = "";
      });

      $M->on(finish => sub {
          my ($M, $code, $reason) = @_;
          Sw leaves[$code, $reason];
      });
      
      say "Elvis appears from B.address";
      
    humms_D: |
      w H.style/elvibe;
    
    print: |
      "$elvii $elvii === $address";
    
    send: |
      $tx->send(J.B.m, J.B.cb);
      
    speaks: |      
      my $E = $S;#1
      my $J = 0->Bu(J => {m=>$m});#2
      if (w $S mouthfull[$J]) {#3 pyramid full
          sayyl "elvis losing teeth ".$S->pi;
          return; # more stim than stamp
      }
      w Teeth[$J, $E];#...
      
    disconecktie: |
      $EE->send(" C[s\.conin] = s;");
      $tx->finish;
    swoosh: | #c
      saygr $sign;
      
    mouthfull: |
      for my $mJ (@{S.mouth}) {
            return 1 if mJ.dig eq J.dig &&
                (1 / (J.hitime - mJ.hitime)) > S.max_tooth_Hz
      }
      push @{S.mouth}, $J;
      shift @{S.mouth} if @{S.mouth} > 3;
      return 0;
    
    populi: |
      my @all = 0->rei({K=>"Elvis"});
      if (@all > 1) {
          sayre " Elvis is taking over!";
          _.B.tx->finish for @all;
          sayre " restarting...";
          w re/exec;
      }
      
    leaves: |
      sayre "WebSocket closed: $address - $code, $reason";#, $code, $reason, $S);
    
    sign: |
      B.sign ||= do {
          my $s = join "", (`figlet '<<<<'`)[-3];
          chomp $s;
          $s
      };
  J: # 
    Bu_D: |
      B.m =~ s/\n?$/\n/s;
      S.dig ||= $H->dig(B.m);
      S.hitime = $F[0]->{hitime};
    decode: |
      if ($m =~ /^"(.+)"\n$/s) {
          B.j = $1;
      }
      else {
          B.j = $G->djson($m);
      }
      
    print_out: |
      return if $m =~ /\$\('#(worm|mess|sky|path|land|func|somewhere|flood)/;
      # ^ trace F, tractoriose
      my $short = length($m) < 200 ? $m : substr($m,0,23*9)." >SNIP<";
      chomp $short;
      print colored("< send $pi\t\t", 'blue');
      print colored($short, 'bold blue');
      say "";
    print_in: |
      my $pi = ar.pi || S.id;
      my $m = $m;
      chomp $m;
      print colored("recv > $pi\t\t", 'red');
      print colored($m, 'bold red');
      say "";
  j: #
    D: |
      # god object
      # bit that rattles around from here
      # that is from Elvis talk held in J
      # so J is the still meaning of the activity
      #    J is uncarved block of wood
      # j changes as it goes
      # spiralling, modding
      # harmon stacks procedures geometries
      # much like T but not about a line, about physics, energy, meta
      # behaviour stuff joins 
      # all of that is travelly 9 wrapz
      # in things more dynamically
      
      # in a dimension that mods
      
      # like keyword-only, plumbing-sparse talking can dilute/narrow meaning on the receiving end
      
      # the data from JSON of the websocket line will do now
      # as an origin of the energy and a place to cling complications
      # this is ACGT or whatever language
      # hash has named sentences
      # send tences - the web tightens as it nests
      
      
      
  re:
    exec: |
      $G->w("H.style/reexec");
  sing: |
    G.singing ||= {};
    return $G->Flab("\t\t\t\t $name BLOCKED")
        if G.singing->{$name}
            && G.singing->{$name}++; # ignore sing until...
    G.singing->{$name} = 1;
    my $t = ar.block || ar.again || 0.04;
    my $d = ar.begin || 0.001;
    $G->timer($d, sub {
        $G->timer($t, sub {
            my $splatter = delete G.singing->{$name};
            if ($splatter > 1 && ar.again) {
                $G->Flab("Sig reps $splatter... again!  $name");
                w sing(%$ar);
            }
        }, "sing-block        $name");
        G.singing->{$name} = 1;
        $code->();
    }, "pre-sing     $name");
    
    
  reinit:
    everything: |
      $H->error("restarting!");
      `touch stylehouse.pl`;
  
  serve:
    hash: |
        return w serve/claw   if j.claw;
        return w serve/event  if j.event;
        return w serve/error  if j.error; # change from {e}
        return w serve/scroll if j.scroll;
    claw: |
      $H->claw($j);
      
    error: |
      die j.d if H.JErrors++ > 3;
      $H->error("javascript error from client", j.d, j.error);
      
    event: |
      my $e = ar.e = j.event;
      $G->Flab("H dostuff event", $e);
      return w serve/key if e.type =~ /^key/;
      return w serve/wormhole if e.W;
      return w serve/TV if e.id;
      $H->error("Strange event", $e);
      
    key: |
      G:keys ->w(Arr => {e => $e});
      
    wormhole: |
      my $E;
      my $findL = sub {
        return unless $E->{W};
        my $id = shift;
        (grep { $_->{uuid} eq $id } @{ $E->{W}->{script} })[0]
      };
      my $id = sub {
        my $i = shift;
        return unless $i =~ /^(\w+)$/;
        $1
      };
      
      my $Wid = $id->($e->{W});
      ($E->{W}) = grep { $_->{id} eq "Wormhole-$Wid" } @{ $H->get("Wormhole") };
      
      my $Lid = $id->($e->{id});
      $E->{L} = $findL->($Lid);
      
      my $uxLid = $id->($e->{ux});
      $E->{uxL} = $findL->($uxLid);
      
      $E->{e} = $e;
      if (E.W) {
            $E->{W}->{G}->w('event', $E) if $E->{W};
      }
      else {
          Say "Nothing!!!! from $Lid\n"
          ."Well ".e.W."      \n".join"\n", map {_.id} @{ $H->get("Wormhole") };
      }
      
    TV: | #c
      my $id = $e->{id};
      my $thing = $H->tv_by_id($id) if $id;

          if ($thing) {
              sayyl "TV  $thing->{id}";
              $thing->event($e);
          }
          else {
              sayyl "TV not found".( $id ? ": $id" : ", lacking id");
              

              if (my $catcher = $H->get('clickcatcher')) {
                  sayyl "Event catcher found: $catcher";
                  $catcher->event($e);
              }
              else {
                  sayyl "NOTHING" for 1..4;
              }
          }
          sayyl "event handled in ".$G->F_delta()."\n\n";
  
  
  data:
    get_apps: |
      my $apps = {};
      my $d = $O->data;
      for (keys %$d) {
          next unless /^[A-Z]\w+$/;
          $apps->{$_} = $d->{$_};
      }
      return $apps;

