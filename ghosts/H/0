
hooks:
  fresh_init: |
    say "     H Fresh init H.style H.name";

    H.who = [];
    
    my $ni = 0;
    H.nnn->{$_} = $ni++ for
        qw '0 d uS boo humm links travel tractor braiding *'
    ;
    
    # fading memory
    H.r = w enRedis;
    
    # shared memory
    H.pg = Mojo::Pg->new('postgresql://s@/s');
    H.db = H.pg->db;
    
    H.db->on(notification => sub {
        my ($db,$name,$pid,$payload) = @_;
        my $d = {};
        (d.top, d.m) = map { $H->fixutf8($_) } $name, $payload;
        for my $cb (@{H.subscr->{$name}}) {
            $G->timer(0.00001, sub { $cb->($d); });
        }
    });
    
    w figure_port;
    
    my $reS = sub { my $a = shift; w reS(%$a); }; 
    $G->su(S => $reS);
    $G->su("S/H.style/H.name" => $reS);
    $G->su("S/H.style/H.name/H.id" => $reS);
    
    w in_listenings; 
    # S/* mods ^
    
    $G->timer(60*9+(20 * rand 4), sub {
        return if H.nosuddendeath;
        sayre "voluntary reexec" for 1..13;
        w reexec;
    });
    
    $G->recur(5 => sub { H.r->ping || die "not redis?" });
    
    
    # start git torrent
    # do it all
    # $0 has become a runtime
    w pre_in;
    w in;
    waylay transam; # 3
  websocket: |
    my $g = G:S/O;
    $g || die "no SO!?";
    $g w websocket;
  mess: |
    # TODO sa* all over
    # by voltage!
    my $mess = "$what: @$thing";
    $mess = slim(500,500,$mess);
    $H->pub("S/H.style/H.name/sa", $mess);
  Teeth: |
    my $Eb = ar.E->pi."-" if ar.E;
    saybl ."$Eb > ".slim(75,80,$m);
    my $j = $H->djson($m);
    
    say anydump($j);
    
    if (ref $j eq "HASH") {
        if (keys %$j != 1) {
            die "hash wide/skinny ".wdump($j);
        }
        my ($uno) = keys %$j;
        my $a = {
            j => $j,
            m => $m,
            $uno => $j->{$uno},
        };
        a.E = ar.E if ar.E;
        w S/$uno(%$a);
        # hit or not? see post 6 with r 
        return;
    }
    
    die "weird shit: '$m'" if ref $j; 
    
    if ($j =~ /^([\w\/]+) (.+)$/) {
        my $a = {m => $2};
        a.E = ar.E if ar.E;
        w S/$1(%$a);
    }
    else {
        die "wei tet '$j'";
    }
  aj: |
    my $W = j.W;
    
    my $meta = {};
    meta.hol = "H.style/H.name/H.id";
    meta.Wid = W.at.id;
    
    if (j._) {
        meta.unified = 1;
        # W homing
        meta.styles = W.at.styles;
        meta.hitime = $H->hitime;
        
        H.r->set("W/meta.Wid" => $H->ejson($meta));
        
        H.r->set("V/H.id/meta.Wid" => 1);
        G0.Wh->{meta.Wid} = $W; # TODO move Wh to A.h_W auto index
    }
    
    my @lot = reverse @{j.s}; # until whole
    push @lot, reverse @{j.c}; # from whole
    
    return sayre "empty J aj" unless @lot;
    
    my $m = join" ", @lot;
    $m = " $m"; # two spaces, tells js to eval
    H.G w send_Elvis[$m, $meta];
  jaw: |
    my $s = $H->mkuuid();
    ($s) = reverse split '-', $s;
    G.jaws->{$s} = delete ar.cb; # TODO a Z awaits, sucks $m
    ar.m = 
        " var e = function(){ $js };"   
        ."var m = e();"
        ."s\.reply({jaw:{h:'H.ol',s:'$s',e:m}});";
    my $Epi = ar.E->pi if ar.E;
    my $Gpi = $F[2]->pi;
    saygr "jaw $s $Epi $Gpi js:".slim(30,30,$js);
    w send_Elvis;
  send_Elvis: |
    my $meta = ar.meta ||= {};
    meta.hol ||= "H.style/H.name/H.id";
    if (H.name eq "O") {
        my $g = G:S/O;
        $g || die "no SO";
        return $g w send_Elvis; # no emanation, socket right here
    }
    # we are now a line, W->J revelation sheds from W which is also J
    meta.Jid = $H->mkuid;
    H.r->set("J/meta.Jid", $m);
    
    $m = $H->ejson($meta);
    
    saybl "pub Elvis $meta\t*".slim(280,280,$m) unless H.isforked;
    
    H.r->lpush("Jungle", $m);
    $H->pub('Elvis', $m, 'ig');
  reS: |
    my ($way, $am) = split /\s+/, $m, 2;
    sayyl "$top >> $m" if $way ne 'hostinfo/ack';
    $way || die "wtf $m";
    w S/$way(%$ar,m=>$am);
  S: #c
    percC: | #c
        my $way = "C".($m?" $m":"");
        my $n = H.nn++;
        my $P = [{GAK => "C$n $way"}];
        H.G w percs[$P];
    
    jaw: | #c TODO route with H.id
      inter({it=>wdump($j)});
      $j = j.jaw;
      my $s = j.s || die "no s";
      my $hol = j.h || die;
      if (H.ol eq $hol) {
          my $cb = G.jaws->{$s} || die "no such jaw $s";
          saygr "Jaw doing $s ... ";
          $cb->(j.e); # TODO Z sucktion
      }
      else {
          $H->pub("S/$hol", "speaks $m");
      }
    speaks: | #c concealed elvis input
      w Teeth[$m];
      
    er: | #c
      die "much JS error..." if H.JErrors++ > 3;
      sayre "javascript error from client", j.m, j.e;
    event: | #c
      my $e = ar.e = j.event;
      
      return w S/key if e.type =~ /^key/;
      
      return w S/W if e.W;
      
      return w S/TV if e.id;
      
      sayre "Strange event", $e;
      
    key: | #c
      # if key is ww switcher...
      if (H.name eq "O") {
          G.keysto || die "no key subber";
          if (G.keysto ne H.ol) {
                return $H->pub("S/G.keysto" => "speaks $m");
          }
      }
      return H.keydo->($e) if H.keydo;
      
    TV: |
      w duu/TV;
  
    On: |
      die "!";
      $m =~ s/^H.style\/H.name // && w reS[$m];
    W: | #c
        $e->{$_} =~ /^\w+$/ || delete $e->{$_} for qw'id ux W';
        
        my $meta = H.r->get("W/e.W") || die "no such e.W but also H.G.A.W->{e.W}";
        $meta = $H->djson($meta);
        my $hol = meta.hol;
        G.keysto = $hol;
        
        my $a = {};
        if (my $W = G0.Wh->{e.W}) {
            my $find = sub {
                w W.W fi(f => {id => shift});
            };
            a.W = $W;
            a.i = $find->(e.id);
            a.ux = $find->(e.ux);
            a.e = $e;
            
            if (W.W.G.name =~ /^(D|U)$/) {
                saybl "event hook: ".W.G->pi;
                W.G w event(%$a);
            }
            else { # future: in-G Rs
                saybl "event hook: ".W.R->pi;
                w W.R event(%$a);
            }
        }
        elsif ($hol ne H.ol) {
            sayyl "HSW H.ol -> $hol";
            $H->pub("S/$hol", "speaks $m");
        }
    
    reextet: | #c
        if (H.name eq 'o') {
            my $g = G:S/o || die;
            $g w reextet;
            return;
        }
        my @m = grep { $_ ne "H.style/H.name" } split ',', $m;
        $G->timer(1.3, sub {
            if (H.name eq "O") {
                $H->pub("S/hut/Z", "reextet ".join',',@m);
            }
            elsif (H.name eq "Z") {
                sleep 1;
                $H->pub("S/$_", "reexec") for @m;
            }
            w reexec;
        });
    reexec: w reexec; #c
    retile: w retile; #c
    Hiwtidy: w Hiwtidy; #c

    
  retile: |
    my $g = G:S/O;
    $g || die "no S/O ghost!";
    $g w retile;
  Hiwtidy: |
    my $g = G:S/o || die "not o";
    $g w Hiwtidy;
    

