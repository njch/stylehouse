
name: hostinfo
hooks:
 
  elvinit: |
    $G->unrush('elvinit') || return;
    
        G TT ->G("H/mess");
        G TT ->G("H/keys");
        G TT ->G("H/colour");

    $H->init_flood();
    
    my $style = $H->get("sstyle");
    if ($style eq "shed") {
        Git->new($H->intro);
        Codo->new($H->intro);
        Lyrico->new($H->intro);
    }
    else {
        Git->new($H->intro);
        Codo->new($H->intro);
        #Keys->new($hostinfo->intro);
    }

    $H->update_app_menu();
    
    $H->{underworld} = 0;
    # where we pay attention
  sky:
    doof: |
      my $sky = G sky;
      w $sky doof;
  
  init_flood: |
    my $self = $O;
    my $data = $O->data;
    $self->{horizon} = $data->{horizon};
    
    my $sky = View->new($self->intro, $self, "sky",
        "height:$self->{horizon}; background: #00248F; width: 100%; overflow: scroll; position: absolute; top: 0px; left: 0px; z-index:3;"
    );
    G TT ->G("H/sky");
    $sky->{on_event} = sub {
        G sky ->w('touch', {e => [@_]});
    };
    
    
    View->new($self->intro, $self, "ground",
        "width: 100%; height: 100%; background: #A65300; overflow: none;position: absolute; top: $self->{horizon}; left: 0px; z-index:-1;"
    );
    my $f = $self->{ground}->spawn_floozy($self, "flood",
        "width: 22%; min-width:3em; background: #337921aa;"
        ." height: 100%; overflow: scroll;position: absolute; background-image: url(greencush.jpg); right:0px;z-index:-1;"
    );
    my $fm = $f->spawn_ceiling(
        "flood_ceiling",
        "width: 100%; margin:1em; height: 4.20em; background: #301a30; color: #afc; font-weight: bold;",
    );

    $self->{floodzy} = $f->spawn_floozy(
        floodzy => "width:100%;  background: #0000FF; color: black; height: 100px; font-weight: 7em;",
    );
    
    
    my $messborder = "border: 2px solid rgb(64,150,227);";
    my $m = $sky->spawn_floozy(mess => "max-width:39%; right:0px; bottom:0px;"
        ."position:absolute; overflow: scroll; height:100%;"
        ."$messborder z-index: 10; background: rgba(175,160,47, 0.5); color: #030; font-weight: bold; ");
    $m->{on_event} = sub {
        my @a = @_;
        G mess Tw event(e=>[@a]);
    };
    
    $m->spawn_floozy(
        Error => "width:100%; $messborder background: rgba(16,0,50, 0.7); color: rgba(178,71,0, 0.7); font-weight: bold; overflow-x: scroll; white-space: pre; word-wrap: break-word; max-height: 100%;",
    );
    
    $m->spawn_floozy(
        'Info' => "width: 100%; overflow: scroll; $messborder  background: #44ag39; font-weight: bold; color: #66c339; opacity: 0.7; z-index: 50; white-space: pre; word-wrap: break-word; max-height: 100%;",
    );
    
    $m->spawn_floozy(
        'Say' => "width: 100%; overflow: scroll; $messborder background: rgba(102,255,102, 0.7); color: #030;  font-weight: bold;  opacity: 0.7; z-index: 50; white-space: pre; word-wrap: break-word; max-height: 100%;",
    );
    
    $self->menu();
    $self->{floodmenu}->{ле}->() if $data->{style} eq 'stylehouse';

    return $f
  on_message: |
    
        return unless $H->elvis_enters($elvis, $mojo, $msg); # this'll all be way soon
        
        
        my $j;
        eval { $j = w decode_message[$mojo, $msg]; };
        if ($@) {
            $H->error("message decode fup", $@);
            return;
        }
        
        
        # all this stuff before they join the stream
        if ($mojo->stash('handy')) {
            $mojo->stash('handy')->($mojo, $j);
            $mojo->stash('handy') && return;
        }


        # it beings! not that we don't come through here all the time
        $H->{G}->w('elvinit') if $H->{underworld};
        
        eval { w dostuff[$mojo, $j, $msg]; };
        if ($@) {
            $H->error("message process fup", $@);
            return;
        }
  dostuff: |
    # ongoing stuff
    if ($j->{claw} && $H->claw($j)) {
        # done
    }
    elsif (my $k = $j->{k}) {
        my $keys = $H->getapp("Keys");
        $keys->key($k) if $keys;
    }
    elsif ($j->{e}) {
        die $j->{d} if $H->{JErrors}++ > 3;
        $H->error("javascript error from client", $j->{d}, $j->{e});
    }
    elsif (my $s = $j->{s}) {
        # the viewport of the browser moves..
        #Lyrico used to do stuff here, it's a bit crazy but it's got potential...
        # for a bit cloud of colourful chatter that builds up in layers and moves off to new lands etc.
        # then bringing things back together is the key.... substance... legible shrines to anythings...
        my $lye = $H->getapp("Lyrico");
        $lye->scroll($s) if $lye;
    }
    elsif (my $event = $j->{event}) {
        $G->Flab(event => $event);
        
        Say $event;
        
        my $id = $event->{id};
        

        my $thing = $H->tv_by_id($event->{id}) if $id;

        start_timer();

        if ($thing) {
            $mojo->app->log->info("TV  $thing->{id}");
            $thing->event($event);
        }
        else {
            my $s = "TV not found".( $id ? ": $id" : ", lacking id");
            $mojo->app->log->info("$s");

            if (my $catcher = $H->get('clickcatcher')) {
                $mojo->app->log->info("Event catcher found: $catcher");
                $catcher->event($event);
            }
            else {
                $mojo->app->log->info("NOTHING");
                $mojo->send(
                    "\$('#body').addClass('dead').delay(250).removeClass('dead');"
                );
            }
        }
        say "event handled in ".show_delta()."\n\n";
    }
    else {
        my $undorf = !defined $msg ? " is~undef~" : "";
        $H->error("EH!? '$msg'$undorf");
    }
  
  
  decode_message: |
    
    my $j;
    start_timer();
    
    `cat /dev/null > elvis_sez`;
    $H->spurt('elvis_sez', $msg);
    my $convert = q{perl -e 'use YAML::Syck; use JSON::XS; use File::Slurp;}
        .q{print " - reading json from elvis_sez";}
        .q{my $j = read_file("elvis_sez");}
        .q{print "! json already yaml !~?\n$j\n" if $j =~ /^---/s;}
        .q{print " - convert json -> yaml\n";}
        .q{my $d = decode_json($j);}
        .q{print " - write yaml to elvis_sez\n";}
        .q{DumpFile("elvis_sez", $d);}
        .q{print " - done\n";}
        .q{'};
    `$convert`;

    eval {
        $j = LoadFile('elvis_sez');

        while (my ($k, $v) = each %$j) {
            if (ref \$v eq "SCALAR") {
                $j->{$k} = Hostinfo::decode_utf8($v);
            }
        }
    };
    say "Decode in ".show_delta();
    die "JSON DECODE FUCKUP: $@\n\nfor $msg\n\n\n\n"
        if $@;

    die "$msg\n\nJSON decoded to ~undef~" unless defined $j;
    return $j;
    
  data:
    get_apps: |
      my $apps = {};
      my $d = $O->data;
      for (keys %$d) {
          next unless /^[A-Z]\w+$/;
          $apps->{$_} = $d->{$_};
      }
      return $apps;
  throwlog: |
    die "no mess!" unless G mess;
    start_timer();
    my $yep = G mess Tw throwlog(%$ar);
    say "Thrownlog: ".show_delta();
    return $yep;
  colour:
    G colour Tw arr(%$ar);
  splatmenues: |
    'db' =>
      sub { 
        Say "WOOHOO! $G->{i}->{G}->{name}";
        $G->{i}->{G}->w('go', {thing => $O->data}); 
      },

    

