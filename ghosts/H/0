
name: hostinfo
dials:
  horizon: 95%
hooks:
 
  A: # just for Codon; this jump loses the meaning of the origin
    colour: |
      $G->timer(0.01, sub {
        G colour ->w(Arr => $ar);
      });
  
  check: # blah
    vitals: |
      $G->susgdb;
      my @v = (
          w check/MemAvailable,
        w check/ps,
        w check/LoC,
      );
      $G->mess(Vitals => \@v);
      waylay 60 check/vitals;
    MemAvailable: |
      my ($a) = `cat /proc/meminfo | grep MemAvailable`;
      ($a) = $a =~ /(\d+) kB/;
      $a = int($a / 1024);
      kill 'KILL', $$         if !$a || $a < 50 || $! ;
      $a < 500 ? "MemAvail: ${a}mB" : ()
    ps: |     
      my @ps = `ps -p$$ fu`;
      my ($u, $pid, $m, $c) = (split /\s+/, $ps[1])[0,1,2,3];
      $m /= 100;
      $c /= 100;
      $H->error("memory usage $m") if $m > 0.4;
      w re/exec if $m > 0.9; # unlikely to be effective from inside
      "$u`$pid  m$m  c$c"
    LoC: |
      my $tot = (`wc -l lib/* ghosts/*/* stylehouse.*`)[-1];
      ($tot) = $tot =~ /(\d+) total/;
      "$tot lines"
  mess: |
    unless (H._future) {
        warn "Pre future mess... ".ki($ar);
        return;
    }
    my $m = Gf mess;
    $m || die'no mess!';
    H._future = 0;
    
    eval { $m ->w(mess => $ar); };
    if ($@) {
        die "Throwing mess mess: $@\n\n\n".wdump($ar);
    }
    
    H._future = 1;
  re:
    exec: |
      exec "perl stylehouse.pl";
  init:
    later: |
      waylay check/vitals;
    future: |
      $H->{_future} = 1;
    flood: | #c
      my $house = $H->get('style') eq 'stylehouse';
    
      G TT ->G("H/mess");
      G TT ->G("H/keys") if !$house;
      G TT ->G("H/colour");
      G TT ->G("H/sky") ->w('flood_init');
      G mess  ->w('flood_init');
      G TT ->G("H/ground") ->w('flood_init');
      
      waylay init/later;
    
      if (!$house) {
          #Git->new($H->intro);
          #Codo->new($H->intro);
          Lyrico->new($H->intro);
      }
      else {
          Git->new($H->intro);
          Codo->new($H->intro);
      }

      $H->menu();
      $H->{floodmenu}->{ле}->() if $house;

      $H->update_app_menu();
      $H->{underworld} = 0;
  reinit:
    everything: |
      $H->error("restarting!");
      `touch stylehouse.pl`;
  on_message: |
    return unless
        $H->elvis_enters($elvis, $mojo, $msg);
    
    my $j;
    eval { $j = w decode_message[$mojo, $msg]; };
    return $H->error("message decode fup", $@) if $@;
    
        
        
        # all this stuff before they join the stream
        if ($mojo->stash('handy')) {
            $mojo->stash('handy')->($mojo, $j);
            $mojo->stash('handy') && return;
            # it beings! not that we don't come through here all the time
            if ($H->{underworld}) {
                $H->{G}->w('init/flood');
                return;
            }
        }


        
        eval { w serve/stuff[$mojo, $j, $msg]; };
        if ($@) {
            $H->error("message process fup", $@);
            return;
        }
        
        print Hostinfo::colored(scalar(`figlet '<'`), 'blue');
  serve:
    stuff: |
      # ongoing stuff
      return w serve/claw if $j->{claw};
      return w serve/event if $j->{event};
      return w serve/error if $j->{error}; # change from {e}
      return w serve/scroll if $j->{scroll};
      
    claw: |
      $H->claw($j);
      
    error: |
      die $j->{d} if $H->{JErrors}++ > 3;
      $H->error("javascript error from client", $j->{d}, $j->{error});
      
    scroll: |
      my $s = $j->{scroll};
      # the viewport of the browser moves..
      #Lyrico used to do stuff here, it's a bit crazy but it's got potential...
      # for a bit cloud of colourful chatter that builds up in layers and moves off to new lands etc.
      # then bringing things back together is the key.... substance... legible shrines to anythings...
      my $lye = $H->getapp("Lyrico");
      $lye->scroll($s) if $lye;
      
    event: |
      my $e = $ar->{e} = $j->{event};
      $G->Flab("H dostuff event", $e);
      return w serve/key if $e->{type} =~ /^key/;
      return w serve/wormhole if $e->{W};
      return w serve/TV if $e->{id};
      $H->error("Strange event", $e);
    key: |
      return unless G keys;
      G keys ->w(Arr => {e => $e});
      
    wormhole: |
      my $E;
      my $findL = sub {
        return unless $E->{W};
        my $id = shift;
        (grep { $_->{uuid} eq $id } @{ $E->{W}->{script} })[0]
      };
      my $id = sub {
        my $i = shift;
        return unless $i =~ /^(\w+)$/;
        $1
      };
      
      my $Wid = $id->($e->{W});
      ($E->{W}) = grep { $_->{id} eq "Wormhole-$Wid" } @{ $H->get("Wormhole") };
      
      my $Lid = $id->($e->{id});
      $E->{L} = $findL->($Lid);
      
      my $uxLid = $id->($e->{ux});
      $E->{uxL} = $findL->($uxLid);
      
      $E->{e} = $e;
      $E->{W}->{G}->w('event', $E) if $E->{W};
      
    TV: |
      my $id = $e->{id};
      my $thing = $H->tv_by_id($id) if $id;

          start_timer();

          if ($thing) {
              $mojo->app->log->info("TV  $thing->{id}");
              $thing->event($e);
          }
          else {
              my $s = "TV not found".( $id ? ": $id" : ", lacking id");
              $mojo->app->log->info("$s");

              if (my $catcher = $H->get('clickcatcher')) {
                  $mojo->app->log->info("Event catcher found: $catcher");
                  $catcher->event($e);
              }
              else {
                  $mojo->app->log->info("NOTHING");
                  $mojo->send(
                      "\$('#body').addClass('dead').delay(250).removeClass('dead');"
                  );
              }
          }
          say "event handled in ".show_delta()."\n\n";
  
  
  decode_message: |
    
    my $j;
    start_timer();

    eval {
        $j = decode_json(Hostinfo::encode_utf8($msg));
    };
    
    $G->Flab("H message Decode in ".show_delta());
    die "JSON DECODE FUCKUP: $@\n\nfor $msg\n\n\n\n"
        if $@;

    die "$msg\n\nJSON decoded to ~undef~" unless defined $j;
    
    return $j;
    
  data:
    get_apps: |
      my $apps = {};
      my $d = $O->data;
      for (keys %$d) {
          next unless /^[A-Z]\w+$/;
          $apps->{$_} = $d->{$_};
      }
      return $apps;

