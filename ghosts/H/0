



hooks:
  fresh_init: |
    say "     H Fresh init H.style H.name";
    H._future = 1;
    push @{G.GGs||=[]}, $G; # H self
    
    H.r = w enRedis;
    H.sur = w enRedis;
    w figure_port;
    
    my $reS = sub { my $a = shift; w reS(%$a); }; 
    $G->su(S => $reS);
    $G->su("S/H.style/H.name" => $reS);
    $G->su("S/H.style/H.name/H.id" => $reS);
    
    
    $G->timer(60*9+(20 * rand 4),
        sub { sayre "voluntary reexec" for 1..13; w reexec; })
        if H.name !~ /Z/;
    
    
    $G->recur(0.02 => sub {
        H.sur->wait_for_messages(0.01618);
    });
    
    # start git torrent
    # do it all
    # $0 has become a runtime
    w in;
    waylay transam; # 3
  recoded_init: |
    w retile;
  jaw: |
    my $s = $H->mkuuid();
    ($s) = reverse split '-', $s;
    G.jaws->{$s} = delete ar.cb; # TODO a Z awaits, sucks $m
    ar.m = 
        " var e = function(){ $js };"   
        ."var m = e();"
        ."s\.reply({jaw:{s:'$s',e:m}});";
    w send_Elvis;
  suRedis: |
    my $s = 'subscribe';
    $s = "p$s" if $top =~ /\*/;
    
    my $D = sub {
      my $d = {};
      (d.m, d.top, d.sutop) = map { $H->fixutf8($_) } @_;
      $G->timer(0.00001, sub {
            $cb->($d);
      });
      1;
    };
    
    H.sur->$s($top => $D);
    push @{H.sur_subbed||=[]}, $top;
    
    sayyl "Subbed to $top";
  enRedis: |
    my $r = Redis->new(
        server => 'localhost:8888',
        reconnect => 1,
        every => 10000,
    );
    r.gest = sub {
        my ($k, $make) = @_;
        my $c = H.r->get($k);
        return ref \$c eq "SCALAR" ? $H->fixutf8($c) : $c if $c;
        $c = $make->();
        H.r->set($k => $c);
        return $c;
    };
    $r
  waits: |
    my $towait = ar.towait || 1;
    my $to = ar.to;
    
    my $max = max map { _.div } @$to;
    _.span = $max / _.div for @$to;
    
    my $tot = sum map { _.span } @$to;
    my $one = $towait / $tot;
    
    my $ord = {};
    for my $t (@$to) {
        my $waits = $one * t.span;
        $waits = sprintf("%.7f", $waits);
        t.waits = $waits;
        push @{ $ord->{$waits} ||= [] }, $t
    }
    return $ord;
    
  reexec: |
      exec "nice perl $0 @ARGV";
  S:
    reexec: w reexec;
    retile: w retile;
    
  retile: |
    my @m = grep { /^\S+ \S+ 1/ }
        map { $_." ".H.r->get($_) } H.r->keys("W/*");
    @m = map { join " ", reverse  /W\/(\S+) (\S+)/ } @m;
    @m = map { /\S+ (\S+)/ } sort @m;
    
    
    my $space = 2;
    $space++ until $space * $space > @m;
    my $div = ["width:left $space", "height:top $space"];
    
    
    my $grid = {};
    for my $p (@$div) {
        my ($iv, $parts) = split ' ', $p;
        my ($mags, $ax) = split ':', $iv;
        # magnitudes of width
        # axed from unified by left, etc.
        my $in = sprintf("%.3f", 1 / $parts);
        
        my @ground = map { [$_ => $grid->{$_} ] } sort keys %$grid;
        @ground = [] if !@ground;
        my $pole = [];
        $grid = {};
        
        my $here = 0; # in accum
        for my $i (1..$parts) {
            my $ox = {};
            ox.part = $i;
            $ox->{$ax} = $here;
            $here += $in;
            $ox->{$mags} = $in;
            push @$pole, $ox;
        }
        
        for my $g (@ground) {
            my ($k, $v) = @$g;
            $v ||= {};
            for my $ox (@$pole) {
                my $K = (defined $k?"$k ":"") . ox.part;
                my $x = $grid->{$K} = {%$v, %$ox};
                delete x.part;
            }
        }
    }
    
    my @holes = sort keys %$grid;
    say "Got ".@m." pegs for ".@holes." holes";
    for my $n (@m) {
        my $h = shift @holes;
        my $o = $grid->{$h};
        my $cssset = ".animate({".join(",", map {
            "'$_':'".($o->{$_} * 100)."%'"
            } sort keys %$o)."}, 0)";
        my $E = H.who;
        my $unhide = ".removeClass('NZ')";
        $E->send(" \$('#$n')$cssset$unhide".";");
    }
  

