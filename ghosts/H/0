

hooks:
  fresh_init: |
    say "     H Fresh init H.style H.name";

    H.who = [];
    
    my $ni = 0;
    H.nnn->{$_} = $ni++ for
        qw '0 d uS boo humm links travel tractor braiding *'
    ;
    
    w figure_port;
    
    my $reS = sub { my $m = shift; w reS[$m]; };
    $G->su(S => $reS);
    $G->su("S/H.style/H.name" => $reS);
    $G->su("S/H.style/H.name/H.id" => $reS);
    
    w in_listenings; 
    # S/* mods ^
    
    $G->timer(60*9+(20 * rand 4), sub {
        return if H.nosuddendeath;
        sayre "voluntary reexec" for 1..13;
        w reexec;
    });
    
    # start git torrent
    # do it all
    # $0 has become a runtime
    w pre_in;
    w in;
    waylay transam; # 3
  subsc: | # multi listening joi
    my $tos = H.subscr->{$top} ||= [];
    push @$tos, $cb;
    
    H.db->listen($top);
    
    sayyl "Subbed to $top";
  websocket: |
    my $g = K G:S/O;
    $g || die "no SO!?";
    $g w websocket;
  Teeth: |
    my $Eb = ar.E->pi."-" if ar.E;
    saybl ."$Eb > ".slim(75,80,$m);
    my $j = $H->djson($m);
    
    if (ref $j eq "HASH") {
        if (keys %$j != 1) {
            die "hash wide/skinny ".wdump($j);
        }
        my ($uno) = keys %$j;
        my $a = {
            j => $j,
            m => $m,
            $uno => $j->{$uno},
        };
        a.E = ar.E if ar.E;
        w S/$uno(%$a);
        # hit or not? see post 6 with r 
        return;
    }
    
    die "weird shit: '$m'" if ref $j; 
    
    if ($j =~ /^([\w\/]+) (.+)$/) {
        my $a = {m => $2};
        a.E = ar.E if ar.E;
        w S/$1(%$a);
    }
    else {
        die "wei tet '$j'";
    }
  jaw: |
    my $s = $H->mkuuid();
    ($s) = reverse split '-', $s;
    G.jaws->{$s} = delete ar.cb; # TODO a Z awaits, sucks $m
    ar.m = 
        " var e = function(){ $js };"   
        ."var m = e();"
        ."s\.reply({jaw:{h:'H.ol',s:'$s',e:m}});";
    my $Epi = ar.E->pi if ar.E;
    my $Gpi = $F[2]->pi;
    saygr "jaw $s $Epi $Gpi js:".slim(30,30,$js);
    w send_Elvis;
  send_Elvis: | # into the elvisphere! comes out in Elvish on eg O
    my $meta = ar.meta ||= {};
    meta.hol ||= "H.style/H.name/H.id";
    meta.hitime ||= hitime;
    if (H.name eq "O") {
        my $g = K G:S/O;
        $g || die "no SO";
        return $g w send_Elvis; # no emanation, socket right here
    }
    # we are now a line, W->J revelation sheds from W which is also J
    meta.Jid = $H->mkuid;
    
    w spurtJcon[$meta,$m];
    
    saybl "Elvisiin: $m";
  to_Elvis: |
    my $Elvis = ar.Elvis || ar.E || H.who;
    my $cb = ar.cb;
    if (!$Elvis || ref $Elvis eq "ARRAY" && !@$Elvis) {
        saybl "no infiduvia ----- will spring on .... ".slim($m);
        push @{H.Jels||=[]}, $m;
        return;
    }
    $m =~ /\n/ && say "Message contains \\n:\n$m\n\n";
    $m =~ s/\n//g;
    
    my $talk = "Elvis";
    
    if (my $m = ar.meta) {
        $talk .= " meta.hol meta.Jid";
        $talk .= " meta.Wid" if meta.Wid;
        $talk .= " meta.unified" if meta.unified;
    }

    saybl " < $talk ".slim(60,90,$m);
    
    my @e = map { [$_, undef] } ref $Elvis eq "ARRAY" ? @$Elvis : $Elvis;
    $e[-1]->[1] = $cb if $cb;
    
    for my $e (@e) {
        my ($Elvis,$cb) = @$e;
        w $Elvis send[$m, $cb];
    }
  reexec: |
    for my $E (@{H.who||[]}) {
        w $E disconecktie;
    }
    sayre "finish!";
    exec "nice perl $0 @ARGV";
  cyc: |
    w reexec unless H.busy;
  busy: |
    my $y = H.busy = hitime;
    timer 42 { delete H.busy if H.busy eq $y; }
  reS: |
    my ($way, $am) = split /\s+/, $m, 2;
    sayyl "reS >> $m" if $way ne 'hostinfo/ack';
    $way || die "wtf $m";
    w S/$way(%$ar,m=>$am);
  S: #c
    percC: | #c
        my $way = "C".($m?" $m":"");
        my $n = H.nn++;
        my $P = [{GAK => "C$n $way"}];
        H.G w percs[$P];
    
    jaw: | #c TODO route with H.id
      inter({it=>wdump($j)});
      $j = j.jaw;
      my $s = j.s || die "no s";
      my $hol = j.h || die;
      if (H.ol eq $hol) {
          my $cb = G.jaws->{$s} || die "no such jaw $s";
          saygr "Jaw doing $s ... ";
          $cb->(j.e); # TODO Z sucktion
      }
      else {
          $H->pub("S/$hol", "speaks $m");
      }
    speaks: | #c concealed elvis input
      w Teeth[$m];
      
    er: | #c
      die "much JS error..." if H.JErrors++ > 3;
      sayre "javascript error from client", j.m, j.e;
    event: | #c
      my $e = ar.e = j.event;
      
      if (e.W) {
          G.lastWe = $e
      }
      if (e.type =~ /^key/ && !e.W && G.lastWe) {
          my $We = G.lastWe;
          for my $k (keys %$We) {
              $e->{$k} = $We->{$k} unless exists $e->{$k};
          }
      }
      return w S/W if e.W;
      sayre "Strange event", wdump $e;
      
    key: | #c key -> W switch
      saybl "e: ".wdump($e);
      
      return w S/W;
      return H.keydo->($e) if H.keydo;
    On: | #c
      die "!";
      $m =~ s/^H.style\/H.name // && w reS[$m];
    W: | #c
        $e->{$_} =~ /^\w+$/ || delete $e->{$_} for qw'id ux W';
        
        my $meta = $G->tri('W/'.e.W.'.i');
        $meta || return warn "no such e.W but also H.G.A.W->{e.W}";
        $meta = djson $meta if $meta;
        
        my $hol = meta.hol;
        G.keysto = $hol;
        
        my $a = {};
        if (my $W = G0.Wh->{e.W}) {
            my $find = sub {
                w W.W fi(f => {id => shift});
            };
            a.W = $W;
            a.i = $find->(e.id);
            a.ux = $find->(e.ux);
            a.e = $e;
            
            if (W.W.G.name =~ /^(D|U)$/) {
                die "wta";
                saybl "event hook: ".W.G->pi;
                W.G w event(%$a);
            }
            else { # future: in-G Rs
                saybl "event hook: ".W.R->pi;
                w W.R event(%$a);
            }
        }
        elsif ($hol ne H.ol) {
            sayyl "HSW H.ol -> $hol";
            saybl "e: ".wdump($e);
            $G->pub("S/$hol", "speaks $m"); # our json event again over there
        }
        else {
            die "goner";
        }
    
    reextet: | #c
        if (H.name eq 'o') {
            my $g = K G:o || die;
            $g w reextet;
            return;
        }
        my @m = grep { $_ ne "H.style/H.name" } split ',', $m;
        $G->timer(1.3, sub {
            if (H.name eq "O") {
                $G->pub("S/hut/Z", "reextet ".join',',@m);
            }
            elsif (H.name eq "Z") {
                sleep 1;
                $G->pub("S/$_", "reexec") for @m;
            }
            w reexec;
        });
    reexec: w reexec; #c
    retile: w retile; #c
    Hiwtidy: w Hiwtidy; #c

    
  retile: |
    my $g = K G:S/O;
    $g || die "no S/O ghost!";
    $g w retile;
  Hiwtidy: |
    my $g = K G:o || die "not o";
    $g w Hiwtidy;
    

