
name: hostinfo
dials:
  horizon: 95%
hooks:
 
  A:
    colour: |
      $G->timer(0.01, sub {
        G colour Tw arr(%$ar);
      });
  
  elvinit: |
    $G->unrush('elvinit') || return;
    
    G TT ->G("H/mess");
    
    
    G TT ->G("H/keys") if $H->get('style') =~ /shed/;
    
    
    G TT ->G("H/colour");

    waylay init/later;
    w init/flood;
    
    # grep '.-.travel' -R * # like an art student game

    my $style = $H->get("sstyle");
    if ($style eq "shed") {
        Git->new($H->intro);
        Codo->new($H->intro);
        Lyrico->new($H->intro);
    }
    else {
        Git->new($H->intro);
        Codo->new($H->intro);
        #Keys->new($hostinfo->intro);
    }

    $H->update_app_menu();
    
    $H->{underworld} = 0;
    # where we pay attention
  sky:
    doof: |
      my $sky = G sky;
      $sky->w('doof');
  check:
    vitals: |
      my @v = (
          w check/MemAvailable,
        w check/ps,
        w check/LoC,
      );
      throwlog("Vitals", @v);
      waylay 4 check/vitals;
    MemAvailable: |
      my ($a) = `cat /proc/meminfo | grep MemAvailable`;
      ($a) = $a =~ /(\d+) kB/;
      $a = int($a / 1024);
      !$a || $a < 50 || $! ? kill 'KILL', $$ : ();
      $a < 500 ? "${a}mB" : ()
    ps: |     
      my @ps = `ps -p$$ fu`;
      my ($u, $pid, $m, $c) = (split /\s+/, $ps[1])[0,1,2,3];
      $m /= 100;
      $c /= 100;
      $H->error("memory usage $m") if $m > .4;
      w reinit/everything if $m > .66;
      $H->error("vitals error: $!") if $!;
      "$u`$pid  m$m  c$c"
    LoC: |
      my $tot = (`wc -l lib/* ghosts/*/* stylehouse.*`)[-1];
      ($tot) = $tot =~ /(\d+) total/;
      "$tot lines"
  init:
    later: |
      waylay check/vitals;
    flood: | #c 
      my $self = $O;
      my $data = $O->data;
      G TT ->G("H/sky") ->w('flood_init');
      G TT ->G("H/ground") ->w('flood_init');

      
      G mess ->w('flood_init');

      $self->menu();
      $self->{floodmenu}->{ле}->() if $data->{style} eq 'stylehouse';

      return $f
  reinit:
    everything: |
      $H->error("restarting!");
      `touch stylehouse.pl`;
  on_message: |
    
        return unless $H->elvis_enters($elvis, $mojo, $msg); # this'll all be way soon
        
        
        
        my $j;
        eval { $j = w decode_message[$mojo, $msg]; };
        if ($@) {
            $H->error("message decode fup", $@);
            return;
        }
        
        
        # all this stuff before they join the stream
        if ($mojo->stash('handy')) {
            $mojo->stash('handy')->($mojo, $j);
            $mojo->stash('handy') && return;
            # it beings! not that we don't come through here all the time
            if ($H->{underworld}) {
                $H->{G}->w('elvinit');
                return;
            }
        }


        
        eval { w dostuff[$mojo, $j, $msg]; };
        if ($@) {
            $H->error("message process fup", $@);
            return;
        }
        
        print Hostinfo::colored(scalar(`figlet '<'`), 'blue');
  dostuff: |
    # ongoing stuff
    if ($j->{claw} && $H->claw($j)) {
        # done
    }
    elsif (my $k = $j->{k}) {
        my $keys = $H->getapp("Keys");
        $keys->key($k) if $keys;
    }
    elsif ($j->{e}) {
        die $j->{d} if $H->{JErrors}++ > 3;
        $H->error("javascript error from client", $j->{d}, $j->{e});
    }
    elsif (my $s = $j->{s}) {
        # the viewport of the browser moves..
        #Lyrico used to do stuff here, it's a bit crazy but it's got potential...
        # for a bit cloud of colourful chatter that builds up in layers and moves off to new lands etc.
        # then bringing things back together is the key.... substance... legible shrines to anythings...
        my $lye = $H->getapp("Lyrico");
        $lye->scroll($s) if $lye;
    }
    elsif (my $event = $j->{event}) {
        $G->Flab("H dostuff event", $event);
        
        if ($event->{type} =~ /^key/) {
            return unless G keys;
            G keys Tw arr[$event];
            return;
        }
        
        my $id = $event->{id};
        

        my $thing = $H->tv_by_id($event->{id}) if $id;

        start_timer();

        if ($thing) {
            $mojo->app->log->info("TV  $thing->{id}");
            $thing->event($event);
        }
        else {
            my $s = "TV not found".( $id ? ": $id" : ", lacking id");
            $mojo->app->log->info("$s");

            if (my $catcher = $H->get('clickcatcher')) {
                $mojo->app->log->info("Event catcher found: $catcher");
                $catcher->event($event);
            }
            else {
                $mojo->app->log->info("NOTHING");
                $mojo->send(
                    "\$('#body').addClass('dead').delay(250).removeClass('dead');"
                );
            }
        }
        say "event handled in ".show_delta()."\n\n";
    }
    else {
        my $undorf = !defined $msg ? " is~undef~" : "";
        $H->error("EH!? '$msg'$undorf");
    }
  
  
  decode_message: |
    
    my $j;
    start_timer();

    eval {
        $j = decode_json(Hostinfo::encode_utf8($msg));
    };
    
    $G->Flab("H message Decode in ".show_delta());
    die "JSON DECODE FUCKUP: $@\n\nfor $msg\n\n\n\n"
        if $@;

    die "$msg\n\nJSON decoded to ~undef~" unless defined $j;
    
    return $j;
    
  data:
    get_apps: |
      my $apps = {};
      my $d = $O->data;
      for (keys %$d) {
          next unless /^[A-Z]\w+$/;
          $apps->{$_} = $d->{$_};
      }
      return $apps;
  throwlog: |
    die "no mess!" unless G mess;
    my $yep = G mess Tw throwlog(%$ar);
    return $yep;

