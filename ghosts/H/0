
hooks:
  fresh_init: |
    say "     H Fresh init H.style H.name";

    push @{G.GGs||=[]}, $G; # H self
    H.who = [];
    
    H.r = w enRedis;
    
    H.pg = Mojo::Pg->new('postgresql://s@/s');
    H.db = H.pg->db;
    
    H.db->on(notification => sub {
        my ($db,$name,$pid,$payload) = @_;
        my $d = {};
        (d.top, d.m) = map { $H->fixutf8($_) } $name, $payload;
        for my $cb (@{H.subscr->{$name}}) {
            $G->timer(0.00001, sub { $cb->($d); });
        }
    });
    
    w figure_port;
    
    my $reS = sub { my $a = shift; w reS(%$a); }; 
    $G->su(S => $reS);
    $G->su("S/H.style/H.name" => $reS);
    $G->su("S/H.style/H.name/H.id" => $reS);
    
    w in_listenings; 
    # S/* mods ^
    
    $G->timer(60*9+(20 * rand 4),
        sub { sayre "voluntary reexec" for 1..13; w reexec; })
        if H.name !~ /Z/;
    
    
    $G->recur(5 => sub { H.r->ping || die "not redis?" });
    
    
    # start git torrent
    # do it all
    # $0 has become a runtime
    w pre_in;
    w in;
    waylay transam; # 3
  websocket: |
    my $g = G:S/O;
    $g || die "no SO!?";
    $g w websocket;
  aj: |
    my $W = j.G.W;
    my $ww = W.at.id;
    my $to = $ww;
    if (j._) {
        $to .= "/_";
        # ww homing
        my $hol = "H.style/H.name/H.id";
        my $etc = 1 if W.at.styles =~ /\bNZ\b/;
        my $hold = join ' ', $hol, $etc, $H->hitime;
        H.r->set("W/$ww" => $hold);
        H.r->set("V/H.id/$ww" => 1);
        G0.Wh->{$ww} = $W; # TODO move Wh to A.h_W auto index
    }
    
    my @lot = reverse @{j.s}; # until whole
    push @lot, reverse @{j.c}; # from whole
    
    return sayre "empty J aj" unless @lot; 
    
    @lot = join " ", @lot;
    for my $m (@lot) {
        ref $m && die;
        $m = " $m"; # two spaces, tells js to eval
        H.G w send_Elvis[$m, $to]; 
    }
  send_Elvis: |
    if (H.name eq "O") {
        my $g = G:S/O;
        $g || die "no SO";
        return $g w send_Elvis;
    }
    
    my $to = "H.style/H.name";
    $to .= "/ar.to" if ar.to;
    my $Jid = $H->mkuid;
    H.r->set("J/$Jid", $m);
    saybl "pub Elvis $to $Jid\t*".slim(80,80,$m) unless H.isforked;
    $H->pub('Elvis', "$to $Jid", 'ig');
  figure_port: |
    my $listen = readlink('listen');
    my ($host,$port, $wa) = split ':', $listen;
    die "too much listen" if $wa;
    ($port, $host) = (2000, undef) if !$port && $host =~ /^\d+$/;
    $port ||= 2000;
    $host ||= '127.0.0.1';

    $port += ord(H.name) + 8000;
    
    H.listen_http = "http://$host:$port";   
    H.listen_ws = "ws://$host:$port/s";
    
  subsc: |
    my $tos = H.subscr->{$top} ||= [];
    push @$tos, $cb;
    
    H.db->listen($top);
    
    sayyl "Subbed to $top";
  enRedis: |
    my $r = Redis->new(
        server => 'localhost:8888',
        reconnect => 1,
        every => 10000,
    );
    r.gest = sub {
        my ($k, $make) = @_;
        my $c = H.r->get($k);
        return ref \$c eq "SCALAR" ? $H->fixutf8($c) : $c if $c;
        $c = $make->();
        H.r->set($k => $c);
        return $c;
    };
    $r
  reexec: |
        for my $E (@{H.who||[]}) {
            w $E disconecktie;
        }
        sayre "finish!";
        exec "nice perl $0 @ARGV";
  S:
    reexec: w reexec;
    retile: w retile;
    Hiwtidy: w Hiwtidy;

    
  retile: |
    my $g = G:S/O;
    $g || die "no S/O ghost!";
    $g w retile;
  Hiwtidy: |
    my $g = G:S/o || die "not o";
    $g w Hiwtidy;
    

