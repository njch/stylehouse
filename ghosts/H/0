

hooks:
  fresh_init: |
    say "     H Fresh init H.style H.name";

    $SIG{HUP} = sub { sleep 1; H.G w reexec; };
    H.who = [];
    H.uptime = hitime;
    
    my $ni = 0;
    H.nnn->{$_} = $ni++ for
        qw '0 d uS boo humm links travel tractor braiding *';
    
    w figure_port;
    
    my $reS = sub { my $m = shift; w reS[$m]; };
    $G->su(S => $reS);
    $G->su("S/H.style" => $reS);
    $G->su("S/H.style/H.name" => $reS);
    $G->su("S/H.style/H.name/H.id" => $reS);
    
    $G->timer(60*9+(20 * rand 4), sub {
        return if H.nosuddendeath;
        sayre "voluntary reexec" for 1..13;
        w reexec;
    });
    
    # start git torrent
    # do it all
    # $0 has become a runtime
    
    w in;
    
    waylay transam; # 3
  figure_port: | # S
    my $listen = readlink('listen');
    my ($host,$port, $wa) = split ':', $listen;
    die "too much listen" if $wa;
    ($port, $host) = (2000, undef) if !$port && $host =~ /^\d+$/;
    $port ||= 2000;
    $host ||= '127.0.0.1';
    my $also = $1 if `wc -l pp` =~ /^(\d+)/;
    $port += ord(H.name) + 8004 + $also;
    
    H.listen_http = "http://$host:$port";   
    H.listen_ws = "ws://$host:$port/s";
    
  websocket: |
    my $g = K G:S/O;
    $g || die "no SO!?";
    $g w websocket;
  Teeth: |
    my $Eb = ar.E->pi."-" if ar.E;
    saybl ."$Eb > ".slim(75,80,$m);
    my $j = $H->djson($m);
    
    if (ref $j eq "HASH") {
        if (keys %$j != 1) {
            die "hash wide/skinny ".wdump($j);
        }
        my ($uno) = keys %$j;
        my $a = {
            j => $j,
            m => $m,
            $uno => $j->{$uno},
        };
        a.E = ar.E if ar.E;
        w S/$uno(%$a);
        # hit or not? see post 6 with r 
        return;
    }
    
    die "weird shit: '$m'" if ref $j; 
    
    if ($j =~ /^([\w\/]+) (.+)$/) {
        my $a = {m => $2};
        a.E = ar.E if ar.E;
        w S/$1(%$a);
    }
    else {
        die "wei tet '$j'";
    }
  jaw: |
    my $s = $H->mkuuid();
    ($s) = reverse split '-', $s;
    G.jaws->{$s} = delete ar.cb; # TODO a Z awaits, sucks $m
    ar.m = 
        " var e = function(){ $js };"   
        ."var m = e();"
        ."s\.reply({jaw:{h:'H.ol',s:'$s',e:m}});";
    my $Epi = ar.E->pi if ar.E;
    my $Gpi = $F[2]->pi;
    saygr "jaw $s $Epi $Gpi js:".slim(30,30,$js);
    w send_Elvis;
  reexec: |
    for my $E (@{H.who||[]}) {
        w $E disconecktie;
    }
    sayre "finish!";
    exec "nice perl $0 @ARGV";
  cyc: |
    w reexec unless H.busy;
  busy: |
    my $y = H.busy = hitime;
    timer 42 { delete H.busy if H.busy eq $y; }
  reS: |
    my ($way, $am) = split /\s+/, $m, 2;
    sayyl "reS >> $m" if $way ne 'hostinfo/ack';
    $way || die "wtf $m";
    if (my $co = G.reSway->{$way}) {
        $co->($am);
    }
    else {
        w S/$way(%$ar,m=>$am);
    }
  S: #c
    percC: | #c
        my $way = "C".($m?" $m":"");
        my $n = H.nn++;
        my $P = [{GAK => "C$n $way"}];
        H.G w percs[$P];
    
    jaw: | #c TODO route with H.id
      inter({it=>wdump($j)});
      $j = j.jaw;
      my $s = j.s || die "no s";
      my $hol = j.h || die;
      if (H.ol eq $hol) {
          my $cb = G.jaws->{$s} || die "no such jaw $s";
          saygr "Jaw doing $s ... ";
          $cb->(j.e); # TODO Z sucktion
      }
      else {
          $G->pub("S/$hol", "speaks $m");
      }
    speaks: | #c concealed elvis input
      w Teeth[$m];
      
    er: | #c
      warn "much JS error..." if H.JErrors++ > 3;
      my $er = j.er;
      sayre ind 'EEE ', join "\n", "javascript error from client",
          "m  er.m", "", wdump 6, er.e;
    event: | #c
      my $e = ar.e = j.event;
      
      if (e.W) {
          G.lastWe = $e
      }
      if (e.type =~ /^key/ && !e.W && G.lastWe) {
          my $We = G.lastWe;
          for my $k (keys %$We) {
              $e->{$k} = $We->{$k} unless exists $e->{$k};
          }
      }
      return w S/W if e.W;
      sayre "Strange event", wdump $e;
      
    elv: | #c enters
      my @ghosts = H.G K Gs:*;
      for my $g (@ghosts) {
          $g->w('elv', {m=>$m});
      }
    key: | #c key -> W switch
      saybl "e: ".wdump($e);
      
      return w S/W;
      return H.keydo->($e) if H.keydo;
    On: | #c
      die "!";
      $m =~ s/^H.style\/H.name // && w reS[$m];
    do: | #c
       H.GL.G->w($m,{},H.GL);
      
    W: | #c
        $e->{$_} =~ /^\w+$/ || delete $e->{$_} for qw'id ux W';
        
        saybl "e: ".wdump($e);
        my $f =  "W/e.ids->[0]\.e";
        if (-f "life/$f") {
            my $m = sjson($e)."\n";
            write_file("life/$f",{append=>1},encode_utf8 $m);
        }
        else {
            die "Nogo $f";
        }
        return;
        
        my $meta = $G->tri('W/'.e.W.'.i');
        $meta || return warn "no such e.W but also H.G.A.W->{e.W}";
        $meta = djson $meta if $meta;
        
        my $hol = meta.hol;
        G.keysto = $hol;
        
        my $a = {};
        if (my $W = G0.Wh->{e.W}) {
            if (!W.R) {
                my $R = G0.WhR->{e.W};
                my $G = R.G;
                my $J = $W;
                Rw event $J $e;
                return;
            }
            my $find = sub {
                w W.W fi(f => {id => shift});
            };
            a.W = $W;
            a.i = $find->(e.id); # sometimes something
            a.ux = $find->(e.ux);
            a.e = $e;
            
            saybl "event hook e.W  ->  e.ux  ->  e.id  ";
            w W.R event(%$a);
            
            if (!W.R) {
              die;
            }
            else { # future: in-G Rs
                saybl "event hook: ".W.R->pi;
                w W.R event(%$a);
            }
        }
        elsif ($hol ne H.ol) {
            sayyl "HSW H.ol -> $hol";
            $G->pub("S/$hol", "speaks $m");
        }
        else {
            die "goner";
        }
    
    reextet: | #c
        if (H.name eq 'o') {
            my $g = K G:o || die;
            $g w reextet;
            return;
        }
        my @m = grep { $_ ne "H.style/H.name" } split ',', $m;
        $G->timer(1.3, sub {
            if (H.name eq "O") {
                $G->pub("S/hut/Z", "reextet ".join',',@m);
            }
            elsif (H.name eq "Z") {
                sleep 1;
                $G->pub("S/$_", "reexec") for @m;
            }
            w reexec;
        });
    reexec: w reexec; #c
    retile: w retile; #c
    Hiwtidy: w Hiwtidy; #c

    
  retile: |
    my $g = K G:S/O;
    $g || die "no S/O ghost!";
    $g w retile;
  Hiwtidy: |
    my $g = K G:o || die "not o";
    $g w Hiwtidy;
    

