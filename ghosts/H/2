
hooks:

  _load_ways_post: |
    G0.recoded_cbs||=[];
    
    $S->w("load_ways_post");
    
    for my $wa ($S->anyway('C')) {
        w wayray[$S,$wa];
    }
    
    for my $wa ($S->anyway('R')) {
        w Rwayray[$S,$wa];
    }
    
    S.R ||= $S->R;
    
    if (S.load_ways_count == 1) {
        w _init_fresh;
    }
    else {
        w _init_recoded;
    }
      
    $S->w("any_init");
    
  _init_recoded: |
    w _init_recoded_Cways[$S] if $S->anyway('recoded_Cways');
    $S->w("recoded_init");
        
  _init_recoded_Cways: | # TODO reinject
      my @p = w S.R fi(f=>{});
      for my $i (@p) {
          saygr "Reinjecting i.K ..." for 1..15;
          my $up = $S->CsK({K=>i.K});
          $i->from($up);
      }
        
  _init_fresh: |
      $S->w("fresh_init");
  ghostchanges: |
    my $ghosts = H.G.GGs;
    my @rG;
    for my $S (@$ghosts) {
        my $in = [grep{$Gd->{$_}} @{S.wayfiles}];
        next unless @$in;
        push @rG, $S;
        # sort stream to avoid small before big?
        waylay recode_ways[$S, $in];
    }
    for my $cb (@{G.recoded_cbs}) {
        $G->timer(0.1, sub { $cb->($Gd) });
    }
  recode_ways: |
    sayyl "recoding S.id S.name";
    eval {
        $S->load_ways(split /\+/, S.way); # TODO all ways on any recoded or..?
    };
    if ($@) {
        sayre "Load ways fuckup: $@";
        return $@ = "";
    }
    say "S.name !  ! ! ! S.id recoded  S.way, intersects git diffage at:";
    say " - $_" for @$in; 
        
        
  wayray: | # raise Cs from the dead
    # pass the each C: array of them from the way
    # should use GG after U styleup refact
    # so GG->nw ...
    return unless ref $wa eq "ARRAY";
    my $i = 0;
    for my $a (@$wa) {
        if (ref $a eq "C") {
            # travel inject
            die "already";
        }
        else {
            my $c = $wa->[$i] = $S->nw(%$a);
            c.A->umv('', 'Cw');
        }
        $i++;
    }
  gitdission: | # look for ghostchanges
    my $some = 0;
    for my $f ($G->fs_find('/home/s/styleshed/ghosts')) {
        next if $f =~ /\/\./;
        my $mt = (stat $f)[9];
        $some = 1 if
        G.gitdissmt->{$f} ne $mt;
        G.gitdissmt->{$f} = $mt;
    }
    return unless $some;
    my @diff = `git diff`; 
    my $f;
    my $d = {};
    for (@diff) {
        if (/^diff --git "?a\/(.+?)"? "?b\/.+"?/) {
            $f = $1;
            next if -d $f; # git submodeul
            $f =~ s/^ghosts\/\\317\\240/ghosts\/Ï /sg;
            die "how to git diff unicode? $f" if $f =~ /\\\d+/;
        }
        else {
            $d->{$f} .= $_
        }
    }
    
    while (my ($f, $D) = each %$d) {
        $d->{$f} = {
            f => $f,
            D => $D,
            dig => $H->dig($D),
        };
    }
    
    return G.last_git_diff = $d if !G.last_git_diff;
    
    my $od = {%{G.last_git_diff}};
    
    my $Gd;
    while (my ($f, $n) = each %$d) { 
        my $o = delete $od->{$f};
        
        my $change = !$o || n.D ne o.D;
        
        next unless $change;
        
        if ($f =~ /^ghosts/) {
            n.o = $o;
            $Gd->{$f} = $n;
        }
        elsif ($f =~ /^l\//) { 
            # compilato del shed iggy
        }
        else {
            say join("  <>  ", ($f)x38);
            w reexec;
        }
    }
    
    # to undiffering, was commit? whatever
    for my $f (keys %$od) {
        next;
    }
    
    G.last_git_diff = $d;
    
    if (keys %$Gd) { 
        my $m = join", ", keys %$Gd;
        say "Ghost changes $m";
        w prop_ghostchanges[$m];
    }
  prop_ghostchanges: |
    my @n = sort map { "S/".(split '/', $_, 2)[1] } H.r->keys("H/*");
    my $i = 0;
    for my $t (@n) {
        $H->pub($t => "ghostchanges $m");    
        $H->snooze(240000) if $i++ < 3;      
        $H->snooze(240000) if $i < 6; 
    }
  S:
    ghostchanges: | #c
      my $Gd = {map { $_ => 1 } split ', ', $m};
      $G0 w ghostchanges[$Gd];
      
      

